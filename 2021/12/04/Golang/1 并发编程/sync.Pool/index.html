<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->

<meta name="description" content="[Go] sync.Pool" />


<!-- Website keywords -->

<meta name="keywords" content="Golang, Draco&#39;s Blog" />




<!-- Website rss -->

<link rel="alternate" href="/atom.xml" title="Draco's Blog" type="application/atom+xml">


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://stardustorz.github.io/2021/12/04/Golang/1 并发编程/sync.Pool/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":false};
</script>
  
  <title>[Go] sync.Pool - Draco&#39;s Blog</title>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Draco&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        Home              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        Archives              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        Tags              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        Categories              </li>
    </a>
    
    <a href="/links/">
      <li class="mobile-menu-item">
        
        
        Links              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        About              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">Draco's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              Home  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              Archives  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              Tags  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              Categories  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/links/">  
              
              
              Links  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              About  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      [Go] sync.Pool
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2021-12-04
      </span>
      
      
      <span class="post-category">
        
        <a href="/categories/Golang/">Golang</a>
        
        <a href="/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a>
        
      </span>
      
      
    </div>
  </header>

  
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">1 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E5%A4%A7%E8%87%B4%E7%90%86%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 大致理念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 基本使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 使用案例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-fmt-%E5%8C%85"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1 fmt 包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-gin-%E6%A1%86%E6%9E%B6"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.3.2 gin 框架</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 正确姿势</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">2 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Pool-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 Pool 结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-local"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1 local</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-cpu-cache-amp-false-sharing"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2 cpu cache &amp; false sharing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-poolChain"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3 poolChain</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%A4%A7%E8%87%B4%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 大致流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Get"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 Get</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-pin"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 pin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-pinSlow"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 pinSlow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-getSlow"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3 getSlow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-popTail"><span class="toc-number">2.3.4.</span> <span class="toc-text">2.3.4 popTail</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-5-%E5%B0%8F%E7%BB%93"><span class="toc-number">2.3.5.</span> <span class="toc-text">2.3.5 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-Put"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 Put</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-pushHead"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1 pushHead</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-pack-unpack"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2 pack&#x2F;unpack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-%E5%B0%8F%E7%BB%93"><span class="toc-number">2.4.3.</span> <span class="toc-text">2.4.3 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-GC"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 GC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%B0%8F%E7%BB%93"><span class="toc-number">3.</span> <span class="toc-text">3 小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">4 参考</span></a></li></ol>
    </div>
  </div>
  

  <div class="post-content">
    
    <blockquote>
<p>sync.Pool 可以作为保存临时取还对象的一个“池子”，可以缓存暂时不用的对象，下次需要时直接使用（无需重新分配）。</p>
</blockquote>
<span id="more"></span>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><h3 id="1-1-大致理念"><a href="#1-1-大致理念" class="headerlink" title="1.1 大致理念"></a>1.1 大致理念</h3><blockquote>
<p>因为频繁的内存分配和回收会对性能产生影响，通过复用临时对象就可以避免改问题。</p>
</blockquote>
<p>下面是 2018 年的时候，《Go 夜读》上关于 <code>sync.Pool</code> 的分享，关于适用场景：</p>
<blockquote>
<p>当多个 goroutine 都需要创建同⼀个对象的时候，如果 goroutine 数过多，导致对象的创建数⽬剧增，进⽽导致 GC 压⼒增大。形成 “并发⼤－占⽤内存⼤－GC 缓慢－处理并发能⼒降低－并发更⼤”这样的恶性循环。 在这个时候，需要有⼀个对象池，每个 goroutine 不再⾃⼰单独创建对象，⽽是从对象池中获取出⼀个对象（如果池中已经有的话）。</p>
</blockquote>
<p>因此关键思想就是对象的复用，避免重复创建、销毁，下面我们来看看如何使用。</p>
<p>所以，sync.pool 的作用一句话描述就是，<strong>复用临时对象，以避免频繁的内存分配和回收，从而减少 GC 压力</strong>。</p>
<h3 id="1-2-基本使用"><a href="#1-2-基本使用" class="headerlink" title="1.2 基本使用"></a>1.2 基本使用</h3><p>首先，<code>sync.Pool</code> 是协程安全的，这对于使用者来说是极其方便的。使用前，设置好对象的 <code>New</code> 函数，用于在 <code>Pool</code> 里没有缓存的对象时，创建一个。之后，在程序的任何地方、任何时候仅通过 <code>Get()</code>、<code>Put()</code> 方法就可以取、还对象了。</p>
<p>以下为基本使用 demo：</p>
<blockquote>
<p>完整代码见 <a href="#">Github</a><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> main  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">   <span class="string">&quot;sync&quot;</span>  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;  </span><br><span class="line">   Name   <span class="type">string</span>  </span><br><span class="line">   Remark [<span class="number">1024</span>]<span class="type">byte</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Gopher)</span></span> Reset() &#123;  </span><br><span class="line">   s.Name = <span class="string">&quot;&quot;</span>  </span><br><span class="line">   s.Remark = [<span class="number">1024</span>]<span class="type">byte</span>&#123;&#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">var</span> gopherPool = sync.Pool&#123;  </span><br><span class="line">   New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">new</span>(Gopher)  </span><br><span class="line">   &#125;,  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   g := gopherPool.Get().(*Gopher)  </span><br><span class="line">   fmt.Println(<span class="string">&quot;首次从 pool 里获取：&quot;</span>, g.Name)  </span><br><span class="line"> ​  </span><br><span class="line">   g.Name = <span class="string">&quot;first&quot;</span>  </span><br><span class="line">   fmt.Printf(<span class="string">&quot;设置 p.Name = %s\n&quot;</span>, g.Name)  </span><br><span class="line">   gopherPool.Put(g)  </span><br><span class="line"> ​  </span><br><span class="line">   fmt.Println(<span class="string">&quot;Pool 里已有一个对象：&amp;&#123;first&#125;，调用 Get: &quot;</span>, gopherPool.Get().(*Gopher).Name)  </span><br><span class="line">   fmt.Println(<span class="string">&quot;Pool 没有对象了，调用 Get: &quot;</span>, gopherPool.Get().(*Gopher).Name)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>运行结果：<br> 首次从 pool 里获取：<br> 设置 p.Name = first<br> Pool 里已有一个对象：&amp;{first}，调用 Get:  first<br> Pool 没有对象了，调用 Get:<br>首先，需要初始化 <code>Pool</code>，唯一需要的就是设置好 <code>New</code> 函数。当调用 Get 方法时，如果池子里缓存了对象，就直接返回缓存的对象。如果没有存货，则调用 New 函数创建一个新的对象。</p>
</blockquote>
<p>另外，我们发现 Get 方法取出来的对象和上次 Put 进去的对象实际上是同一个，Pool 没有做任何“清空”的处理。但我们不应当对此有任何假设，因为在实际的并发使用场景中，无法保证这种顺序，<strong>最好的做法是在 Put 前，将对象清空</strong>。</p>
<p><strong>Benchmark</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> defaultGopher, _ = json.Marshal(Gopher&#123;Name: <span class="string">&quot;17x&quot;</span>&#125;)  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">BenchmarkUnmarshal</span><span class="params">(b *testing.B)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">var</span> g *Gopher  </span><br><span class="line">   <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;  </span><br><span class="line">     g = <span class="built_in">new</span>(Gopher)  </span><br><span class="line">     json.Unmarshal(defaultGopher, g)  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">BenchmarkUnmarshalWithPool</span><span class="params">(b *testing.B)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">var</span> g *Gopher  </span><br><span class="line">   <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;  </span><br><span class="line">     g = gopherPool.Get().(*Gopher)  </span><br><span class="line">     json.Unmarshal(defaultGopher, g)  </span><br><span class="line">     g.Reset() <span class="comment">// 重置后在放进去  </span></span><br><span class="line">     gopherPool.Put(g)  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure><br> ​<br>运行结果：</p>
<p> BenchmarkUnmarshal-6                9518            124806 ns/op            1280 B/op          6 allocs/op<br> BenchmarkUnmarshalWithPool-6       10000            124350 ns/op             128 B/op          5 allocs/op<br> <code>3287449 357 ns/op</code> 表示单位时间内（默认是1s）被测函数运行了 3287449 次，每次运行耗时 357ns，<br> <code>B/op</code> 是每个操作分配的字节数<br> <code>allocs/op</code> 表示每个操作(单次迭代)发生了多少不同的内存分配。</p>
<p>功能比较简单，其中 json 反序列化占用了大量时间，因此两种方式最终的执行时间几乎没什么变化。但是内存占用差了一个数量级，使用了 <code>sync.Pool</code> 后，内存占用仅为未使用的 128/1280=1/10，对 GC 的影响就很大了。</p>
<h3 id="1-3-使用案例"><a href="#1-3-使用案例" class="headerlink" title="1.3 使用案例"></a>1.3 使用案例</h3><h4 id="1-3-1-fmt-包"><a href="#1-3-1-fmt-包" class="headerlink" title="1.3.1 fmt 包"></a>1.3.1 fmt 包</h4><p>这部分主要看 <code>fmt.Printf</code> 如何使用：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;  </span><br><span class="line">   <span class="keyword">return</span> Fprintf(os.Stdout, format, a...)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>继续看 <code>Fprintf</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;  </span><br><span class="line">   p := newPrinter()  </span><br><span class="line">   p.doPrintf(format, a)  </span><br><span class="line">   n, err = w.Write(p.buf)  </span><br><span class="line">   p.free()  </span><br><span class="line">   <span class="keyword">return</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br><code>Fprintf</code> 函数的参数是一个 <code>io.Writer</code>，<code>Printf</code> 传的是 <code>os.Stdout</code>，相当于直接输出到标准输出。这里的 <code>newPrinter</code> 用的就是 Pool：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> ppFree = sync.Pool&#123;  </span><br><span class="line">   New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123; <span class="keyword">return</span> <span class="built_in">new</span>(pp) &#125;,  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">newPrinter</span><span class="params">()</span></span> *pp &#123;  </span><br><span class="line">   p := ppFree.Get().(*pp)  </span><br><span class="line">   p.panicking = <span class="literal">false</span>  </span><br><span class="line">   p.erroring = <span class="literal">false</span>  </span><br><span class="line">   p.wrapErrs = <span class="literal">false</span>  </span><br><span class="line">   p.fmt.init(&amp;p.buf)  </span><br><span class="line">   <span class="keyword">return</span> p  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>回到 <code>Fprintf</code> 函数，拿到 pp 指针后，会做一些 format 的操作，并且将 p.buf 里面的内容写入 w。最后，调用 free 函数，将 pp 指针归还到 Pool 中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(p *pp)</span></span> free() &#123;  </span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">cap</span>(p.buf) &gt; <span class="number">64</span>&lt;&lt;<span class="number">10</span> &#123;  </span><br><span class="line">     <span class="keyword">return</span>  </span><br><span class="line">   &#125;  </span><br><span class="line"> ​  </span><br><span class="line">   p.buf = p.buf[:<span class="number">0</span>]  </span><br><span class="line">   p.arg = <span class="literal">nil</span>  </span><br><span class="line">   p.value = reflect.Value&#123;&#125;  </span><br><span class="line">   p.wrappedErr = <span class="literal">nil</span>  </span><br><span class="line">   ppFree.Put(p)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>归还到 Pool 前还进行了<strong>字段清零</strong>，这样，通过 Get 拿到缓存的对象时，就可以安全地使用了。</p>
<h4 id="1-3-2-gin-框架"><a href="#1-3-2-gin-框架" class="headerlink" title="1.3.2 gin 框架"></a>1.3.2 gin 框架</h4><p>gin 框架会给每个请求分配一个 Context 用以进行追踪，这就是典型的 sync.pool 使用场景：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Engine &#123;  </span><br><span class="line">	engine := &amp;Engine&#123;  </span><br><span class="line">		  </span><br><span class="line">	&#125;  </span><br><span class="line">	engine.pool.New = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line">		<span class="keyword">return</span> engine.allocateContext()  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> engine  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> allocateContext() *Context &#123;  </span><br><span class="line">	<span class="keyword">return</span> &amp;Context&#123;engine: engine&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;  </span><br><span class="line">	c := engine.pool.Get().(*Context)  </span><br><span class="line">	c.writermem.reset(w)  </span><br><span class="line">	c.Request = req  </span><br><span class="line">	c.reset()  </span><br><span class="line">  </span><br><span class="line">	engine.handleHTTPRequest(c)  </span><br><span class="line">  </span><br><span class="line">	engine.pool.Put(c)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从 pool 中获取 Context 对象，用完后又还回去，注意 还回去之前这里也调用了 reset() 方法进行<strong>字段清空</strong>。</p>
<h3 id="1-4-正确姿势"><a href="#1-4-正确姿势" class="headerlink" title="1.4 正确姿势"></a>1.4 正确姿势</h3><p>根据以上几个案例，可以看出正确使用姿势就是：</p>
<ul>
<li><p>1）设置 New 方法</p>
</li>
<li><p>2）使用时直接 Get</p>
</li>
<li><p>3）使用完成后先进行<strong>字段清空</strong>,然后在 Put 回去。</p>
</li>
</ul>
<blockquote>
<p>一定要进行 Reset，不然会出现意想不到的问题。分享一个<a target="_blank" rel="noopener" href="https://github.com/lixd/daily-notes/blob/master/Golang/FAQ/mongodb%E9%87%87%E5%9D%91.md">类似的坑</a></p>
</blockquote>
<h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><blockquote>
<p>一下分析基于 Go 1.17.1</p>
</blockquote>
<h3 id="2-1-Pool-结构体"><a href="#2-1-Pool-结构体" class="headerlink" title="2.1 Pool 结构体"></a>2.1 Pool 结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;  </span><br><span class="line">	noCopy noCopy  </span><br><span class="line">	local     unsafe.Pointer <span class="comment">// local fixed-size per-P pool, actual type is [P]poolLocal  </span></span><br><span class="line">	localSize <span class="type">uintptr</span>        <span class="comment">// size of the local array  </span></span><br><span class="line">	victim     unsafe.Pointer <span class="comment">// local from previous cycle  </span></span><br><span class="line">	victimSize <span class="type">uintptr</span>        <span class="comment">// size of victims array  </span></span><br><span class="line">	New <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字段详解：</p>
<ul>
<li><code>noCopy</code>对象，实现了<code>sync.Locker</code>接口，使得内嵌了 noCopy 的对象在进行 go vet 静态检查的时候，可以检查出是否被复制。<ul>
<li>具体见 <a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/8005">Go issues 8005</a></li>
<li>说明 Pool 对象也是不允许复制的。</li>
</ul>
</li>
<li><code>local</code> 字段存储指向 <code>[P]poolLocal</code> 数组（严格来说，它是一个切片）的指针。<code>localSize</code> 则表示 local 数组的大小。<ul>
<li>访问时，根据 P 的 id 去访问对应下标的 <code>local[pid]</code></li>
<li>通过这样的设计，多个 goroutine 使用同一个 Pool 时，减少了竞争，提升了性能。</li>
<li>有点类似于降低锁粒度，分段锁的思想。</li>
</ul>
</li>
<li><code>victim</code> 和 <code>victimSize</code> 则会在在一轮 GC 到来时，分别“接管” local 和 localSize。<ul>
<li>victim cache 是一种提高缓存性能的硬件技术;</li>
<li><code>victim</code> 的机制用于减少 GC 后冷启动导致的性能抖动，让分配对象更平滑;</li>
</ul>
</li>
<li><code>New</code>就是我们指定的新建对象的方法。</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Victim_cache">Victim Cache</a> 是一种提高缓存性能的硬件技术，主要用于提升缓存命令率。<br>所谓受害者缓存（Victim Cache），是一个与直接匹配或低相联缓存并用的、容量很小的全相联缓存。当一个数据块被逐出缓存时，并不直接丢弃，而是暂先进入受害者缓存。如果受害者缓存已满，就替换掉其中一项。当进行缓存标签匹配时，在与索引指向标签匹配的同时，并行查看受害者缓存，如果在受害者缓存发现匹配，就将其此数据块与缓存中的不匹配数据块做交换，同时返回给处理器。</p>
</blockquote>
<h4 id="2-1-1-local"><a href="#2-1-1-local" class="headerlink" title="2.1.1 local"></a>2.1.1 local</h4><p>local 具体结构如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> &#123;  </span><br><span class="line">	poolLocalInternal  </span><br><span class="line">    <span class="comment">// 将 poolLocal 补齐至128字节(即两个cache line)的倍数，防止 false sharing,  </span></span><br><span class="line">    <span class="comment">// 伪共享，仅占位用，防止在 cache line 上分配多个 poolLocalInternal  </span></span><br><span class="line">	pad [<span class="number">128</span> - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%<span class="number">128</span>]<span class="type">byte</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">type</span> poolLocalInternal <span class="keyword">struct</span> &#123;  </span><br><span class="line">	private <span class="keyword">interface</span>&#123;&#125; <span class="comment">// Can be used only by the respective P.  </span></span><br><span class="line">	shared  poolChain   <span class="comment">// Local P can pushHead/popHead; any P can popTail.  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>poolLocalInternal</code>对象 中包含一个 <code>private</code> 和 <code>shared</code>。其中 private 只有当前 p 能用，shared 则是其他 p 都可以用。</p>
<h4 id="2-1-2-cpu-cache-amp-false-sharing"><a href="#2-1-2-cpu-cache-amp-false-sharing" class="headerlink" title="2.1.2 cpu cache &amp; false sharing"></a>2.1.2 cpu cache &amp; false sharing</h4><p><strong>cpu cache</strong><br>现代 cpu 中，cache 都划分成以 cache line (cache block) 为单位，在 x86_64 体系下一般都是 64 字节，cache line 是操作的最小单元。 程序即使只想读内存中的 1 个字节数据，也要同时把附近 63 节字加载到 cache 中，如果读取超个 64 字节，那么就要加载到多个 cache line 中。<br>这样，访问后续 63 字节数据时就可以直接从 cache line 中读取，性能有很大提升。</p>
<p><strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/False_sharing">false sharing</a></strong></p>
<blockquote>
<p>伪共享的非标准定义为：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会令整个 cache line 失效，无意中影响彼此的性能，这就是伪共享。</p>
</blockquote>
<p>简单来说，如果没有 pad 字段，那么当需要访问 0 号索引的 poolLocal 时，CPU 同时会把 0 号和 1 号索引同时加载到 cpu cache。在只修改 0 号索引的情况下，会让 1 号索引的 poolLocal 失效。这样，当其他线程想要读取 1 号索引时，发生 cache miss，还得重新再加载，对性能有损。增加一个 <code>pad</code>，补齐缓存行，让相关的字段能独立地加载到缓存行就不会出现 <code>false sharding</code> 了。</p>
<h4 id="2-1-3-poolChain"><a href="#2-1-3-poolChain" class="headerlink" title="2.1.3 poolChain"></a>2.1.3 poolChain</h4><p><code>poolChain</code> 是一个双端队列的实现<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolChain <span class="keyword">struct</span> &#123;  </span><br><span class="line">  </span><br><span class="line">   head *poolChainElt  </span><br><span class="line">  </span><br><span class="line">   tail *poolChainElt  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> poolChainElt <span class="keyword">struct</span> &#123;  </span><br><span class="line">	poolDequeue  </span><br><span class="line">  </span><br><span class="line">	next, prev *poolChainElt  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> poolDequeue <span class="keyword">struct</span> &#123;  </span><br><span class="line">  </span><br><span class="line">	headTail <span class="type">uint64</span>  </span><br><span class="line">  </span><br><span class="line">	vals []eface  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>poolDequeue</code> 被实现为单生产者、多消费者的固定大小的无锁（atomic 实现） Ring 式队列（底层存储使用数组，使用两个指针标记 head、tail）。生产者可以从 head 插入、head 删除，而消费者仅可从 tail 删除。 <code>headTail</code> 指向队列的头和尾，通过位运算将 head 和 tail 存入 headTail 变量中。</p>
<p>我们用一幅图来完整地描述 Pool 结构体：</p>
<p>![[pool-structure.png]]</p>
<blockquote>
<p>图源：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/133638023">码农桃花源</a></p>
<h3 id="2-2-大致流程"><a href="#2-2-大致流程" class="headerlink" title="2.2 大致流程"></a>2.2 大致流程</h3></blockquote>
<p>分析完 Pool 结构体之后，先提前说明一下大致的流程，后续分析时便于理解。</p>
<p><strong>存储</strong></p>
<p>为每个 P 开辟了一个 Local 用于数据，降低竞争。</p>
<p>Local 中包含 private 和 shared。</p>
<ul>
<li><p>private ：只有当前 P 能使用</p>
</li>
<li><p>shared：所有 P 共享，当 private 没有时优先去当前 P 的 local.shared 中取，如果还没有就去其他 P 中 local.shared 中窃取一个来用。</p>
</li>
</ul>
<p><strong>Get</strong></p>
<p>优先从当前P 的 local.private 中取，没有则从当前 P 的 local.shared 中取，还没有则去其他 P 中 local.shared 中窃取一个。</p>
<p><strong>Put</strong></p>
<p>优先存放到当前 P 的 local.private，local.private 已经有值了就往 shared 中放。</p>
<h3 id="2-3-Get"><a href="#2-3-Get" class="headerlink" title="2.3 Get"></a>2.3 Get</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Get() <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line">	<span class="comment">// ...  </span></span><br><span class="line">	l, pid := p.pin()  </span><br><span class="line">	x := l.private  </span><br><span class="line">	l.private = <span class="literal">nil</span>  </span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;  </span><br><span class="line">		x, _ = l.shared.popHead()  </span><br><span class="line">		<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;  </span><br><span class="line">			x = p.getSlow(pid)  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">	runtime_procUnpin()  </span><br><span class="line">	<span class="comment">// ...  </span></span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;  </span><br><span class="line">		x = p.New()  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">return</span> x  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程如下：</p>
<ol>
<li><p>首先，调用 <code>p.pin()</code> 函数将当前的 goroutine 和 P 绑定，禁止被抢占，返回当前 P 对应的 poolLocal，以及 pid。</p>
</li>
<li><p>然后直接取 l.private，赋值给 x，并置 l.private 为 nil。</p>
</li>
<li><p>判断 x 是否为空，若为空，则尝试从 l.shared 的头部 pop 一个对象出来，同时赋值给 x。</p>
</li>
<li><p>如果 x 仍然为空，则调用 getSlow 尝试从其他 P 的 shared 双端队列尾部“偷”一个对象出来。</p>
</li>
<li><p>Pool 的相关操作做完了，调用 <code>runtime_procUnpin()</code> 解除禁止抢占。</p>
</li>
<li><p>最后如果还是没有取到缓存的对象，那就直接调用预先设置好的 New 函数，创建一个出来。</p>
</li>
</ol>
<h4 id="2-3-1-pin"><a href="#2-3-1-pin" class="headerlink" title="2.3.1 pin"></a>2.3.1 pin</h4><p>首先，调用 <code>p.pin()</code> 函数将当前的 goroutine 和 P 绑定，禁止被抢占，返回当前 P 对应的 poolLocal，以及 pid。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pin() (*poolLocal, <span class="type">int</span>) &#123;  </span><br><span class="line">   <span class="comment">// pin 具体逻辑由 runtime_procPin 实现  </span></span><br><span class="line">   pid :=  runtime_procPin()  </span><br><span class="line">   <span class="comment">// 原子操作取出 p.localSize 和 p.local  </span></span><br><span class="line">   s := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire  </span></span><br><span class="line">   l := p.local                              <span class="comment">// load-consume  </span></span><br><span class="line">   <span class="comment">// 因为是把 pid 做下标从 pool.local 中取得 p 对应的 local 的，  </span></span><br><span class="line">   <span class="comment">// 所以如果 pid 小于 pool.local size 的时候才有可能取到对应的 local  </span></span><br><span class="line">   <span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;  </span><br><span class="line">      <span class="keyword">return</span> indexLocal(l, pid), pid  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// 正常情况下会一直满足该条件，  </span></span><br><span class="line">   <span class="comment">// 只有刚开始  pool.local 还没创建或者动态调整了 P 的数量这两种情况  </span></span><br><span class="line">   <span class="comment">// 会进入到下面的逻辑 去创建 pool.local  </span></span><br><span class="line">   <span class="keyword">return</span> p.pinSlow()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-3-2-pinSlow"><a href="#2-3-2-pinSlow" class="headerlink" title="2.3.2 pinSlow"></a>2.3.2 pinSlow</h4><p>pinSlow 主要是完成 pool.local 的创建。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pinSlow() (*poolLocal, <span class="type">int</span>) &#123;  </span><br><span class="line">    <span class="comment">// 这里先取消绑定，然后加锁，最后有绑定上  </span></span><br><span class="line">	runtime_procUnpin()  </span><br><span class="line">	allPoolsMu.Lock()  </span><br><span class="line">	<span class="keyword">defer</span> allPoolsMu.Unlock()  </span><br><span class="line">	pid := runtime_procPin()  </span><br><span class="line">	<span class="comment">// doubleCheck 因为在执行上述命令过程中 pinSlow 可能已经被其他的线程调用，因此这时候需要再次对 pid 进行检查  </span></span><br><span class="line">	s := p.localSize  </span><br><span class="line">	l := p.local  </span><br><span class="line">	<span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;  </span><br><span class="line">		<span class="keyword">return</span> indexLocal(l, pid), pid  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">if</span> p.local == <span class="literal">nil</span> &#123;  </span><br><span class="line">		allPools = <span class="built_in">append</span>(allPools, p)  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">// 根据当前 P 的数量创建 pool.local并更新pool.localSize  </span></span><br><span class="line">	size := runtime.GOMAXPROCS(<span class="number">0</span>)  </span><br><span class="line">	local := <span class="built_in">make</span>([]poolLocal, size)  </span><br><span class="line">	atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="number">0</span>])) <span class="comment">// store-release  </span></span><br><span class="line">	runtime_StoreReluintptr(&amp;p.localSize, <span class="type">uintptr</span>(size))     <span class="comment">// store-release  </span></span><br><span class="line">    <span class="comment">// 最后根据 pid 返回当前 P 对应的 local  </span></span><br><span class="line">	<span class="keyword">return</span> &amp;local[pid], pid  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### popHead</span><br><span class="line"></span><br><span class="line">然后回到 Get 方法</span><br><span class="line">```go</span><br><span class="line">x := l.private  </span><br><span class="line">	l.private = nil  </span><br><span class="line">	if x == nil &#123;  </span><br><span class="line">		x, _ = l.shared.popHead()  </span><br><span class="line">		if x == nil &#123;  </span><br><span class="line">			x = p.getSlow(pid)  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">优先从 local.private 中取，如果没有就调用`poolChain.popHead()`去 local.shared 中取一个。</span><br><span class="line">```go</span><br><span class="line">func (c *poolChain) popHead() (interface&#123;&#125;, bool) &#123;  </span><br><span class="line">	d := c.head  </span><br><span class="line">	for d != nil &#123;  </span><br><span class="line">		if val, ok := d.popHead(); ok &#123;  </span><br><span class="line">			return val, ok  </span><br><span class="line">		&#125;  </span><br><span class="line">		d = loadPoolChainElt(&amp;d.prev)  </span><br><span class="line">	&#125;  </span><br><span class="line">	return nil, false  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`popHead` 函数只会被 producer 调用。首先拿到头节点：c.head，如果头节点不为空的话，尝试调用头节点的 `poolDequeue.popHead` 方法。</span><br><span class="line">```go</span><br><span class="line">func (d *poolDequeue) popHead() (interface&#123;&#125;, bool) &#123;  </span><br><span class="line">	var slot *eface  </span><br><span class="line">	for &#123;  </span><br><span class="line">		ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">		head, tail := d.unpack(ptrs)  </span><br><span class="line">        // 收尾相连则说明队列是空的  </span><br><span class="line">		if tail == head &#123;  </span><br><span class="line">			return nil, false  </span><br><span class="line">		&#125;  </span><br><span class="line">  </span><br><span class="line">		// head 位置是队头的前一个位置，所以此处要先退一位。  </span><br><span class="line">        // 在读出 slot 的 value 之前就把 head 值减 1，取消对这个 slot 的控制  </span><br><span class="line">		head--  </span><br><span class="line">		ptrs2 := d.pack(head, tail)  </span><br><span class="line">        // 通过 CAS 操作更新头部的位置 这样当前头部第一个元素就算是被移除了  </span><br><span class="line">		if atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;  </span><br><span class="line">			slot = &amp;d.vals[head&amp;uint32(len(d.vals)-1)]  </span><br><span class="line">			break  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">    // 类型转换与 nil 判断  </span><br><span class="line">	val := *(*interface&#123;&#125;)(unsafe.Pointer(slot))  </span><br><span class="line">	if val == dequeueNil(nil) &#123;  </span><br><span class="line">		val = nil  </span><br><span class="line">	&#125;  </span><br><span class="line">    // 然后把这个 slot 置空，因为现在这个 slot 已经是队列的 head 了，置空便于前一个 head 被回收。  </span><br><span class="line">	*slot = eface&#123;&#125;  </span><br><span class="line">	return val, true  </span><br><span class="line">&#125;```</span><br></pre></td></tr></table></figure>
<p>此函数会删掉并且返回 <code>queue</code> 的头节点。但如果 <code>queue</code> 为空的话，返回 false。这里的 <code>queue</code> 存储的实际上就是 Pool 里缓存的对象。</p>
<p>整个函数的核心是一个无限循环，这是 Go 中常用的无锁化编程形式。</p>
<p>首先调用 unpack 函数分离出 head 和 tail 指针，如果 head 和 tail 相等，即首尾相等，那么这个队列就是空的，直接就返回 nil，false。</p>
<p>否则，将 head 指针后移一位，即 head 值减 1，然后调用 pack 打包 head 和 tail 指针。使用 CAS 更新 headTail 的值，并且把 vals 相应索引处的元素赋值给 slot。</p>
<blockquote>
<p>因为 <code>vals</code> 长度实际是只能是 2 的 n 次幂，因此 <code>len(d.vals)-1</code> 实际上得到的值的低 n 位是全 1，它再与 head 进行与运算，实际就是取 head 低 n 位的值作为下标。</p>
</blockquote>
<p>得到相应 slot 的元素后，经过类型转换并判断是否是 <code>dequeueNil</code>，如果是，说明没取到缓存的对象，返回 nil。</p>
<p>type dequeueNil *struct{}</p>
<p>最后，返回 val 之前，将 slot “归零”，移除和上一个 head 的关联，便于回收上一个 Head。</p>
<p>*slot = eface{}</p>
<p>结束后回到 <code>poolChain.popHead()</code>，如果调用 <code>poolDequeue.popHead()</code> 拿到了缓存的对象，就直接返回。否则，将 <code>d</code> 重新指向 <code>d.prev</code>，继续尝试获取缓存的对象。</p>
<h4 id="2-3-3-getSlow"><a href="#2-3-3-getSlow" class="headerlink" title="2.3.3 getSlow"></a>2.3.3 getSlow</h4><p>如果在 shared 里没有获取到缓存对象，则继续调用 <code>Pool.getSlow()</code>，尝试从其他 P 的 poolLocal 偷取：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> getSlow(pid <span class="type">int</span>) <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line">	size := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire  </span></span><br><span class="line">	locals := p.local                            <span class="comment">// load-consume  </span></span><br><span class="line">    <span class="comment">// 尝试从其他 p 中窃取一个对象  </span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;  </span><br><span class="line">        <span class="comment">// (pid+i+1)%int(size) 保证每次都可以从 当前pid+1 这个位置开始尝试窃取。  </span></span><br><span class="line">		l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="type">int</span>(size))  </span><br><span class="line">        <span class="comment">// 如果能取到就直接返回  </span></span><br><span class="line">		<span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;  </span><br><span class="line">			<span class="keyword">return</span> x  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 尝试从其他 P 的 poolLocal 窃取失败后，再尝试从victim cache中取对象  </span></span><br><span class="line">    <span class="comment">// 这样可以使 victim 中的对象更容易被回收。  </span></span><br><span class="line">	size = atomic.LoadUintptr(&amp;p.victimSize)  </span><br><span class="line">	<span class="keyword">if</span> <span class="type">uintptr</span>(pid) &gt;= size &#123;  </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">	&#125;  </span><br><span class="line">	locals = p.victim  </span><br><span class="line">	l := indexLocal(locals, pid)  </span><br><span class="line">	<span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123;  </span><br><span class="line">		l.private = <span class="literal">nil</span>  </span><br><span class="line">		<span class="keyword">return</span> x  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;  </span><br><span class="line">		l := indexLocal(locals, (pid+i)%<span class="type">int</span>(size))  </span><br><span class="line">		<span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;  </span><br><span class="line">			<span class="keyword">return</span> x  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 清空 victim cache。下次就不用再从这里找了  </span></span><br><span class="line">	atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;<span class="string">``</span><span class="string">`</span></span><br></pre></td></tr></table></figure></p>
<p>从索引为 pid+1 的 poolLocal 处开始，尝试调用 <code>shared.popTail()</code> 获取缓存对象。如果没有拿到，则从 victim 里找，和 poolLocal 的逻辑类似。</p>
<p>最后，实在没找到，就把 victimSize 置 0，防止后来的“人”再到 victim 里找。</p>
<p>在 Get 函数的最后，经过这一番操作还是没找到缓存的对象，就调用 New 函数创建一个新的对象。</p>
<h4 id="2-3-4-popTail"><a href="#2-3-4-popTail" class="headerlink" title="2.3.4 popTail"></a>2.3.4 popTail</h4><p>最后，还剩一个 popTail 函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> popTail() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;  </span><br><span class="line">    <span class="comment">// tail 指针为空直接返回 这里的 tail 是一个双端队列  </span></span><br><span class="line">	d := loadPoolChainElt(&amp;c.tail)  </span><br><span class="line">	<span class="keyword">if</span> d == <span class="literal">nil</span> &#123;  </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">for</span> &#123;  </span><br><span class="line">		<span class="comment">// It&#x27;s important that we load the next pointer  </span></span><br><span class="line">		<span class="comment">// *before* popping the tail. In general, d may be  </span></span><br><span class="line">		<span class="comment">// transiently empty, but if next is non-nil before  </span></span><br><span class="line">		<span class="comment">// the pop and the pop fails, then d is permanently  </span></span><br><span class="line">		<span class="comment">// empty, which is the only condition under which it&#x27;s  </span></span><br><span class="line">		<span class="comment">// safe to drop d from the chain.  </span></span><br><span class="line">        <span class="comment">// 在 for 循环的一开始，就把 d.next 加载到了 d2。因为 d 可能会短暂为空，但如果 d2 在 pop 或者 pop fails 之前就不为空的话，说明 d 就会永久为空了。在这种情况下，可以安全地将 d 这个结点“甩掉”。  </span></span><br><span class="line">		d2 := loadPoolChainElt(&amp;d.next)  </span><br><span class="line">  </span><br><span class="line">		<span class="keyword">if</span> val, ok := d.popTail(); ok &#123;  </span><br><span class="line">			<span class="keyword">return</span> val, ok  </span><br><span class="line">		&#125;  </span><br><span class="line">  </span><br><span class="line">		<span class="keyword">if</span> d2 == <span class="literal">nil</span> &#123;  </span><br><span class="line">			<span class="comment">// This is the only dequeue. It&#x27;s empty right  </span></span><br><span class="line">			<span class="comment">// now, but could be pushed to in the future.  </span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">		&#125;  </span><br><span class="line">  </span><br><span class="line">		<span class="comment">// 同样的通过 CAS 来更新 tail 的值为 d2  </span></span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) &#123;  </span><br><span class="line">			storePoolChainElt(&amp;d2.prev, <span class="literal">nil</span>)  </span><br><span class="line">		&#125;  </span><br><span class="line">        <span class="comment">// 最后将d2赋值给d便于进行下一轮循环。  </span></span><br><span class="line">		d = d2  </span><br><span class="line">	&#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p>
<p>在 for 循环的一开始，就把 d.next 加载到了 d2。因为 d 可能会短暂为空，但如果 d2 在 pop 或者 pop fails 之前就不为空的话，说明 d 就会永久为空了。在这种情况下，可以安全地将 d 这个结点“甩掉”。</p>
<p>最后，将 c.tail 更新为 d2，可以防止下次 popTail 的时候查看一个空的 dequeue；而将 d2.prev 设置为 nil，可以防止下次 popHead 时查看一个空的 dequeue。</p>
<p>我们再看一下核心的 <code>poolDequeue.popTail</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popTail() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;  </span><br><span class="line">	<span class="keyword">var</span> slot *eface  </span><br><span class="line">	<span class="keyword">for</span> &#123;  </span><br><span class="line">		ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">		head, tail := d.unpack(ptrs)  </span><br><span class="line">        <span class="comment">// 同样的 head=tail 说明队列为空  </span></span><br><span class="line">		<span class="keyword">if</span> tail == head &#123;  </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">		&#125;  </span><br><span class="line">  </span><br><span class="line">		<span class="comment">// 同样是 CAS 更新 headTail 以移除 tail 元素  </span></span><br><span class="line">		ptrs2 := d.pack(head, tail+<span class="number">1</span>)  </span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;  </span><br><span class="line">			<span class="comment">// Success.  </span></span><br><span class="line">			slot = &amp;d.vals[tail&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]  </span><br><span class="line">			<span class="keyword">break</span>  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 类型转换和 nil 判断  </span></span><br><span class="line">	val := *(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot))  </span><br><span class="line">	<span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;  </span><br><span class="line">		val = <span class="literal">nil</span>  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 最后也是将这个 slot 置空  </span></span><br><span class="line">    <span class="comment">// 先清空 val 再清空 typ 操作顺序和 pushHead 正好相反  </span></span><br><span class="line">	slot.val = <span class="literal">nil</span>  </span><br><span class="line">	atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">return</span> val, <span class="literal">true</span>  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popTail() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;  </span><br><span class="line">	<span class="keyword">var</span> slot *eface  </span><br><span class="line">	<span class="keyword">for</span> &#123;  </span><br><span class="line">		ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">		head, tail := d.unpack(ptrs)  </span><br><span class="line">        <span class="comment">// 同样的 head=tail 说明队列为空  </span></span><br><span class="line">		<span class="keyword">if</span> tail == head &#123;  </span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">		&#125;  </span><br><span class="line">  </span><br><span class="line">		<span class="comment">// 同样是 CAS 更新 headTail 以移除 tail 元素  </span></span><br><span class="line">		ptrs2 := d.pack(head, tail+<span class="number">1</span>)  </span><br><span class="line">		<span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;  </span><br><span class="line">			<span class="comment">// Success.  </span></span><br><span class="line">			slot = &amp;d.vals[tail&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]  </span><br><span class="line">			<span class="keyword">break</span>  </span><br><span class="line">		&#125;  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 类型转换和 nil 判断  </span></span><br><span class="line">	val := *(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot))  </span><br><span class="line">	<span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;  </span><br><span class="line">		val = <span class="literal">nil</span>  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 最后也是将这个 slot 置空  </span></span><br><span class="line">    <span class="comment">// 先清空 val 再清空 typ 操作顺序和 pushHead 正好相反  </span></span><br><span class="line">	slot.val = <span class="literal">nil</span>  </span><br><span class="line">	atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>)  </span><br><span class="line">	<span class="keyword">return</span> val, <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整体逻辑和 popHead 差不多。</p>
<h4 id="2-3-5-小结"><a href="#2-3-5-小结" class="headerlink" title="2.3.5 小结"></a>2.3.5 小结</h4><p>首先从 当前 p 对应的 local.private 上取，没有就从 local.shared 里取，还没有就去其他 p 的 local.shared 里取，都没有就 new 一个返回。</p>
<h3 id="2-4-Put"><a href="#2-4-Put" class="headerlink" title="2.4 Put"></a>2.4 Put</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Put(x <span class="keyword">interface</span>&#123;&#125;) &#123;  </span><br><span class="line">	<span class="keyword">if</span> x == <span class="literal">nil</span> &#123;  </span><br><span class="line">		<span class="keyword">return</span>  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">// ...  </span></span><br><span class="line">	l, _ := p.pin()  </span><br><span class="line">	<span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123;  </span><br><span class="line">		l.private = x  </span><br><span class="line">		x = <span class="literal">nil</span>  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="keyword">if</span> x != <span class="literal">nil</span> &#123;  </span><br><span class="line">		l.shared.pushHead(x)  </span><br><span class="line">	&#125;  </span><br><span class="line">	runtime_procUnpin()  </span><br><span class="line">	<span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程也比较简单：</p>
<ol>
<li>先绑定 g 和 P，然后尝试将 x 赋值给 private 字段。</li>
<li>如果失败，就调用 <code>pushHead</code> 方法尝试将其放入 shared 字段所维护的双端队列中。<h4 id="2-4-1-pushHead"><a href="#2-4-1-pushHead" class="headerlink" title="2.4.1 pushHead"></a>2.4.1 pushHead</h4></li>
</ol>
<p>p.pin() 和之前是一样的，就不分析了，主要看一下 pushHead()<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> pushHead(val <span class="keyword">interface</span>&#123;&#125;) &#123;  </span><br><span class="line">	d := c.head  </span><br><span class="line">	<span class="keyword">if</span> d == <span class="literal">nil</span> &#123;  </span><br><span class="line">		<span class="comment">// 第一次写入，队列为空则进行初始化 默认长度为8  </span></span><br><span class="line">		<span class="keyword">const</span> initSize = <span class="number">8</span> <span class="comment">// Must be a power of 2  </span></span><br><span class="line">		d = <span class="built_in">new</span>(poolChainElt)  </span><br><span class="line">		d.vals = <span class="built_in">make</span>([]eface, initSize)  </span><br><span class="line">		c.head = d  </span><br><span class="line">		storePoolChainElt(&amp;c.tail, d)  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">// 存储元素 存储成功直接返回  </span></span><br><span class="line">	<span class="keyword">if</span> d.pushHead(val) &#123;  </span><br><span class="line">		<span class="keyword">return</span>  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// The current dequeue is full. Allocate a new one of twice  </span></span><br><span class="line">	<span class="comment">// the size.  </span></span><br><span class="line">    <span class="comment">// 存储失败说明队列满了 进行扩容  </span></span><br><span class="line">	newSize := <span class="built_in">len</span>(d.vals) * <span class="number">2</span>  </span><br><span class="line">	<span class="keyword">if</span> newSize &gt;= dequeueLimit &#123; <span class="comment">// 限制一下，不能无限扩容  </span></span><br><span class="line">		newSize = dequeueLimit  </span><br><span class="line">	&#125;  </span><br><span class="line">	<span class="comment">// 扩容逻辑也比较简单，就是首尾相连，构成链表  </span></span><br><span class="line">	d2 := &amp;poolChainElt&#123;prev: d&#125;  </span><br><span class="line">	d2.vals = <span class="built_in">make</span>([]eface, newSize)  </span><br><span class="line">	c.head = d2  </span><br><span class="line">	storePoolChainElt(&amp;d.next, d2)  </span><br><span class="line">	d2.pushHead(val)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果 <code>c.head</code> 为空，就要创建一个 poolChainElt，作为首结点，当然也是尾节点。它管理的双端队列的长度，初始为 8，放满之后，再创建一个 poolChainElt 节点时，双端队列的长度就要翻倍。当然，有一个最大长度限制（2^30）：</p>
<p>const dequeueBits = 32  </p>
<p>const dequeueLimit = (1 &lt;&lt; dequeueBits) / 4</p>
<p>调用 <code>poolDequeue.pushHead</code> 尝试将对象放到 poolDeque 里去：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> pushHead(val <span class="keyword">interface</span>&#123;&#125;) <span class="type">bool</span> &#123;  </span><br><span class="line">	ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">	head, tail := d.unpack(ptrs)  </span><br><span class="line">    <span class="comment">// 首先判断队列是否已满： 也就是将尾部指针加上 d.vals 的长度，再取低 31 位，看它是否和 head 相等  </span></span><br><span class="line">	<span class="keyword">if</span> (tail+<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)))&amp;(<span class="number">1</span>&lt;&lt;dequeueBits<span class="number">-1</span>) == head &#123;  </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">	&#125;  </span><br><span class="line">	slot := &amp;d.vals[head&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// Check if the head slot has been released by popTail.  </span></span><br><span class="line">	typ := atomic.LoadPointer(&amp;slot.typ)  </span><br><span class="line">	<span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;  </span><br><span class="line">		<span class="comment">// Another goroutine is still cleaning up the tail, so  </span></span><br><span class="line">		<span class="comment">// the queue is actually still full.  </span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// slot占位，将val存入vals中  </span></span><br><span class="line">	<span class="keyword">if</span> val == <span class="literal">nil</span> &#123;  </span><br><span class="line">		val = dequeueNil(<span class="literal">nil</span>)  </span><br><span class="line">	&#125;  </span><br><span class="line">	*(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot)) = val  </span><br><span class="line">  </span><br><span class="line">	<span class="comment">// head 增加 1  </span></span><br><span class="line">	atomic.AddUint64(&amp;d.headTail, <span class="number">1</span>&lt;&lt;dequeueBits)  </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先判断队列是否已满：</p>
<pre><code>if (tail+uint32(len(d.vals)))&amp;(1&lt;&lt;dequeueBits-1) == head &#123;  
    return false  
&#125;
</code></pre><p>队列没满，通过 head 指针找到即将填充的 slot 位置：取 head 指针的低 31 位。</p>
<pre><code>slot := &amp;d.vals[head&amp;uint32(len(d.vals)-1)]  

// Check if the head slot has been released by popTail.  
typ := atomic.LoadPointer(&amp;slot.typ)  
if typ != nil &#123;  
    // Another goroutine is still cleaning up the tail, so  
    // the queue is actually still full.  
    return false  
&#125;
</code></pre><p>这里还判断了当前 slot 是否正在被 popTail 释放，popTail 相关语句如下：</p>
<pre><code>// 最后也是将这个 slot 置空  
// 先清空 val 再清空 typ 操作顺序和 pushHead 正好相反  
slot.val = nil  
atomic.StorePointer(&amp;slot.typ, nil)
</code></pre><p>所以如果 slot.typ==nil 就说明这个 slot 正在被 popTail 释放，说明队列其实还是满的，直接返回 false，走后续的扩容逻辑。</p>
<p>最后，将 val 赋值到 slot，并将 head 指针值加 1。</p>
<p>// slot占位，将val存入vals中<br><em>(</em>interface{})(unsafe.Pointer(slot)) = val</p>
<blockquote>
<p>这里的实现比较巧妙，slot 是 eface 类型，即空接口，将 slot 转为 interface{} 类型，这样 val 能以 interface{} 赋值给 slot 让 slot.typ 和 slot.val 指向其内存块，于是 slot.typ 和 slot.val 均不为空。</p>
</blockquote>
<h4 id="2-4-2-pack-unpack"><a href="#2-4-2-pack-unpack" class="headerlink" title="2.4.2 pack/unpack"></a>2.4.2 pack/unpack</h4><p>最后我们再来看一下 pack 和 unpack 函数，它们实际上是一组绑定、解绑 head 和 tail 指针的两个函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> pack(head, tail <span class="type">uint32</span>) <span class="type">uint64</span> &#123;  </span><br><span class="line">	<span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span>  </span><br><span class="line">	<span class="keyword">return</span> (<span class="type">uint64</span>(head) &lt;&lt; dequeueBits) |  </span><br><span class="line">		<span class="type">uint64</span>(tail&amp;mask)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`mask`</span> 的低 <span class="number">31</span> 位为全 <span class="number">1</span>，其他位为 <span class="number">0</span>，它和 tail 相与，就是只看 tail 的低 <span class="number">31</span> 位。而 head 向左移 <span class="number">32</span> 位之后，低 <span class="number">32</span> 位为全 <span class="number">0</span>。最后把两部分“或”起来，head 和 tail 就“绑定”在一起了。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> unpack(ptrs <span class="type">uint64</span>) (head, tail <span class="type">uint32</span>) &#123;  </span><br><span class="line">	<span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span>  </span><br><span class="line">	head = <span class="type">uint32</span>((ptrs &gt;&gt; dequeueBits) &amp; mask)  </span><br><span class="line">	tail = <span class="type">uint32</span>(ptrs &amp; mask)  </span><br><span class="line">	<span class="keyword">return</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>unpack 则是相反的逻辑，取出 head 指针的方法就是将 ptrs 右移 32 位，再与 mask 相与，同样只看 head 的低 31 位。而 tail 实际上更简单，直接将 ptrs 与 mask 相与就可以了。</p>
<h4 id="2-4-3-小结"><a href="#2-4-3-小结" class="headerlink" title="2.4.3 小结"></a>2.4.3 小结</h4><p>Put 和 Get 类似，首先尝试将放到当前 p 的 local.private 上，已经有了就放到 local.shared。</p>
<h3 id="2-5-GC"><a href="#2-5-GC" class="headerlink" title="2.5 GC"></a>2.5 GC</h3><p>对于 Pool 而言，并不能无限扩展，否则对象占用内存太多了，会引起内存溢出。<br>sync.pool 选择了在 GC 时进行清理。<br>在 pool.go 文件的 init 函数里，注册了 GC 发生时，如何清理 Pool 的函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/pool.go  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;  </span><br><span class="line">	runtime_registerPoolCleanup(poolCleanup)  </span><br><span class="line">&#125;</span><br><span class="line">编译器在编译时将其注册到运行时：</span><br><span class="line"><span class="comment">// src/runtime/mgc.go  </span></span><br><span class="line"><span class="comment">// Hooks for other packages  </span></span><br><span class="line"><span class="keyword">var</span> poolcleanup <span class="function"><span class="keyword">func</span><span class="params">()</span></span>  </span><br><span class="line"><span class="comment">// 利用编译器标志将 sync 包中的清理注册到运行时  </span></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_registerPoolCleanup sync.runtime_registerPoolCleanup  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_registerPoolCleanup</span><span class="params">(f <span class="keyword">func</span>()</span></span>) &#123;  </span><br><span class="line">  poolcleanup = f  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">具体的 poolCleanup() 函数如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolCleanup</span><span class="params">()</span></span> &#123;  </span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> oldPools &#123;  </span><br><span class="line">		p.victim = <span class="literal">nil</span>  </span><br><span class="line">		p.victimSize = <span class="number">0</span>  </span><br><span class="line">	&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> allPools &#123;  </span><br><span class="line">		p.victim = p.local  </span><br><span class="line">		p.victimSize = p.localSize  </span><br><span class="line">		p.local = <span class="literal">nil</span>  </span><br><span class="line">		p.localSize = <span class="number">0</span>  </span><br><span class="line">	&#125;  </span><br><span class="line">	oldPools, allPools = allPools, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整体看起来，比较简洁。主要是将 local 和 victim 作交换，这样也就不致于让 GC 把所有的 Pool 都清空了，有 victim 在“兜底”。</p>
<ol>
<li>初始状态下，oldPools 和 allPools 均为 nil。</li>
<li>第 1 次调用 Get，由于 p.local 为 nil，将会在 pinSlow 中创建 p.local，然后将 p 放入 allPools，此时 allPools 长度为 1，oldPools 为 nil。</li>
<li>对象使用完毕，第 1 次调用 Put 放回对象。</li>
<li>第 1 次GC STW 阶段，allPools 中所有 p.local 将值赋值给 victim 并置为 nil。allPools 赋值给 oldPools，最后 allPools 为 nil，oldPools 长度为 1。</li>
<li>第 2 次调用 Get，由于 p.local 为 nil，此时会从 p.victim 里面尝试取对象。</li>
<li>对象使用完毕，第 2 次调用 Put 放回对象，但由于 p.local 为 nil，重新创建 p.local，并将对象放回，此时 allPools 长度为 1，oldPools 长度为 1。</li>
<li>第 2 次 GC STW 阶段，oldPools 中所有 p.victim 置 nil，前一次的 cache 在本次 GC 时被回收，allPools 所有 p.local 将值赋值给 victim 并置为nil，最后 allPools 为 nil，oldPools 长度为 1。<br>简单来说就是清理时，先清理 oldPools 的 local.victim,然后把 allPools 中的 local 赋值给 victim，最后再把 allPools 赋值给 oldPools，把 allPools 置空。<blockquote>
<p>GC 时只会清理 oldPools，allPools 只会先把数据转移到 victim，然后把 allPools 变成 oldPools，如果从 oldPools 中读取出来的数据进行 Put 也会直接放到 allPools 中，相当于要两次 GC 都没有被访问到并且Put回来才会被移除。</p>
</blockquote>
</li>
</ol>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><ul>
<li>关键思想是对象的复用，避免重复创建、销毁。将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力。</li>
<li><code>sync.Pool</code> 是协程安全的，使用起来非常方便。设置好 New 函数后，调用 Get 获取，调用 Put 归还对象。</li>
<li>不要对 Get 得到的对象有任何假设，更好的做法是归还对象时，将对象“清空”。</li>
<li>Pool 里对象的生命周期受 GC 影响，不适合于做连接池，因为连接池需要自己管理对象的生命周期。</li>
</ul>
<p>一些设计思想或者相关知识点：</p>
<ul>
<li><p>lock free：无锁编程是很多编程语言里逃离不了的话题。<code>sync.Pool</code>的无锁是在<code>poolDequeue</code>和<code>poolChain</code>层面实现的。</p>
</li>
<li><p>原子操作代替锁：<code>poolDequeue</code>对一些关键变量采用了CAS操作，比如<code>poolDequeue.headTail</code>，既可完整保证并发又能降低相比锁而言的开销。</p>
</li>
<li><p>cacheline false sharing 问题</p>
</li>
<li><p>noCopy 禁止复制</p>
</li>
<li><p>分段锁，降低锁粒度</p>
</li>
<li><p>victim cache</p>
</li>
<li><p>常见优化手段：复用</p>
</li>
</ul>
<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><code>https://golang.org/src/sync/pool.go</code></p>
<p><code>https://en.wikipedia.org/wiki/False_sharing</code></p>
<p><code>https://en.wikipedia.org/wiki/Victim_cache</code></p>
<p><code>https://zhuanlan.zhihu.com/p/110140126</code></p>
<p><code>https://medium.com/swlh/go-the-idea-behind-sync-pool-32da5089df72</code></p>
<p><code>https://zhuanlan.zhihu.com/p/133638023</code></p>
<p><code>https://www.jianshu.com/p/dc4b5562aad2</code></p>
<p><code>https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/</code></p>
<p>[Github]  <a target="_blank" rel="noopener" href="https://github.com/lixd/i-go/blob/master/a-tutorials/lib/sync_pool/main.go">https://github.com/lixd/i-go/blob/master/a-tutorials/lib/sync_pool/main.go</a> </p>
<p>[pool-structure]  <a target="_blank" rel="noopener" href="https://github.com/lixd/blog/raw/master/images/golang/lib/sync-pool/pool-structure.png">https://github.com/lixd/blog/raw/master/images/golang/lib/sync-pool/pool-structure.png</a></p>

    
  </div>

  
  <!-- Post Copyright -->

<div class="post-copyright">
  <p class="copyright-item">
    <span>Author: </span>
    <a href="https://stardustorz.github.io">draco</a>
  </p>
  <p class="copyright-item">
    <span>Link: </span>
    <a href="https://stardustorz.github.io/2021/12/04/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Pool/">https://stardustorz.github.io/2021/12/04/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Pool/</a>
  </p>
  <p class="copyright-item">
    <span>License: </span>
    
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
  </p>
</div>

    

  

  
  <footer class="post-footer">
    
    <div class="post-tags">
      
      <a href="/tags/Golang/">Golang</a>
      
    </div>
    
      
  <nav class="post-nav">  
      
      <a class="prev" href="/2021/12/04/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E9%97%AD%E5%8C%85/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text nav-default">[Go] 闭包</span>  
        <span class="prev-text nav-mobile">Prev</span>  
      </a>  
      
      
      <a class="next" href="/2021/10/26/Golang/4%20%E5%85%B6%E4%BB%96/Golang%20Test%20%E5%B7%A5%E5%85%B7%E6%8C%87%E4%BB%A4/">  
        <span class="next-text nav-default">[Go] Golang Test 工具指令</span>  
        <span class="prev-text nav-mobile">Next</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  </footer>
  

</article>
        </div>
      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2019 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">draco</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
  







<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>



<script type="text/javascript" src="/lib/slideout/slideout.js"></script>



<script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>