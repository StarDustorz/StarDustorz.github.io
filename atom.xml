<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Draco&#39;s Blog</title>
  
  <subtitle>拨雪寻春 烧灯续昼</subtitle>
  <link href="https://stardustorz.github.io/atom.xml" rel="self"/>
  
  <link href="https://stardustorz.github.io/"/>
  <updated>2025-07-28T09:23:36.000Z</updated>
  <id>https://stardustorz.github.io/</id>
  
  <author>
    <name>draco</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[Go] Quic</title>
    <link href="https://stardustorz.github.io/2025/07/28/Golang/%E5%8C%85/Quic/"/>
    <id>https://stardustorz.github.io/2025/07/28/Golang/%E5%8C%85/Quic/</id>
    <published>2025-07-28T09:23:36.000Z</published>
    <updated>2025-07-28T09:23:36.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Quick UDP Internet Connection</p></blockquote><span id="more"></span><h2 id="1-QUIC-概述"><a href="#1-QUIC-概述" class="headerlink" title="1 QUIC 概述"></a>1 QUIC 概述</h2><p>QUIC（Quick UDP Internet Connection，快速 UDP 互联网连接协议）是一种以 UDP 为底层传输协议，支持加密、多路复用，工作在用户空间的的低延迟传输协议。</p><p>Quic 相比现在广泛应用的 http2+tcp+tls 协议有如下优势：</p><ol><li>减少了 TCP 三次握手及 TLS 握手时间。</li><li>改进的拥塞控制。</li><li>避免队头阻塞的多路复用。</li><li>连接迁移。</li><li>前向冗余纠错。</li></ol><h2 id="2-server"><a href="#2-server" class="headerlink" title="2 server"></a>2 server</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/rsa&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/tls&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/pem&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;math/big&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/lucas-clemente/quic-go&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> saddr = <span class="string">&quot;localhost:9999&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listener, err := quic.ListenAddr(saddr, generateTLSConfig(), <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sess, err := listener.Accept(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">go</span> dealSession(sess)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dealSession</span><span class="params">(sess quic.Session)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;LocalAddr %s, RemoteAddr %s\n&quot;</span>,</span><br><span class="line">sess.LocalAddr().String(),</span><br><span class="line">sess.RemoteAddr().String())</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line">stream, err := sess.AcceptStream(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//panic(err)</span></span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_, err = io.Copy(loggingWriter&#123;stream&#125;, stream)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;err &quot;</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> loggingWriter <span class="keyword">struct</span>&#123; io.Writer &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w loggingWriter)</span></span> Write(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Server: Got &#x27;%s&#x27;\n&quot;</span>, <span class="type">string</span>(b))</span><br><span class="line"><span class="keyword">return</span> w.Writer.Write(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup a bare-bones TLS config for the server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateTLSConfig</span><span class="params">()</span></span> *tls.Config &#123;</span><br><span class="line">key, err := rsa.GenerateKey(rand.Reader, <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">template := x509.Certificate&#123;SerialNumber: big.NewInt(<span class="number">1</span>)&#125;</span><br><span class="line">certDER, err := x509.CreateCertificate(rand.Reader, &amp;template, &amp;template, &amp;key.PublicKey, key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">keyPEM := pem.EncodeToMemory(&amp;pem.Block&#123;Type: <span class="string">&quot;RSA PRIVATE KEY&quot;</span>, Bytes: x509.MarshalPKCS1PrivateKey(key)&#125;)</span><br><span class="line">certPEM := pem.EncodeToMemory(&amp;pem.Block&#123;Type: <span class="string">&quot;CERTIFICATE&quot;</span>, Bytes: certDER&#125;)</span><br><span class="line"></span><br><span class="line">tlsCert, err := tls.X509KeyPair(certPEM, keyPEM)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;tls.Config&#123;</span><br><span class="line">Certificates: []tls.Certificate&#123;tlsCert&#125;,</span><br><span class="line">NextProtos:   []<span class="type">string</span>&#123;<span class="string">&quot;quic-example&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-client"><a href="#3-client" class="headerlink" title="3 client"></a>3 client</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/tls&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/lucas-clemente/quic-go&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addr = <span class="string">&quot;localhost:9999&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tlsConf := &amp;tls.Config&#123;</span><br><span class="line">InsecureSkipVerify: <span class="literal">true</span>,</span><br><span class="line">NextProtos:         []<span class="type">string</span>&#123;<span class="string">&quot;quic-example&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">session, err := quic.DialAddr(addr, tlsConf, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">stream, err := session.OpenStreamSync(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ticker := time.NewTicker(<span class="number">2000</span> * time.Millisecond)</span><br><span class="line"><span class="keyword">for</span> t := <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">message := fmt.Sprintf(<span class="string">&quot;Client: Sending &#x27;%d&#x27;&quot;</span>, t.Nanosecond())</span><br><span class="line">_, err = stream.Write([]<span class="type">byte</span>(message))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(message))</span><br><span class="line">_, err = io.ReadFull(stream, buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Client: Got &#x27;%s&#x27;\n&quot;</span>, buf)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-运行"><a href="#4-运行" class="headerlink" title="4 运行"></a>4 运行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; go run quic_server.go</span><br><span class="line">LocalAddr 127.0.0.1:9999, RemoteAddr 127.0.0.1:53893</span><br><span class="line">Server: Got &#x27;Client: Sending &#x27;519247000&#x27;&#x27;</span><br><span class="line">Server: Got &#x27;Client: Sending &#x27;522181000&#x27;&#x27;</span><br><span class="line">Server: Got &#x27;Client: Sending &#x27;519381000&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">&gt; go run quic_client.go</span><br><span class="line">Client: Got &#x27;Client: Sending &#x27;519247000&#x27;&#x27;</span><br><span class="line">Client: Got &#x27;Client: Sending &#x27;522181000&#x27;&#x27;</span><br><span class="line">Client: Got &#x27;Client: Sending &#x27;519381000&#x27;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/32553477">QUIC协议原理分析</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Quick UDP Internet Connection&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
    <category term="GoPackges" scheme="https://stardustorz.github.io/tags/GoPackges/"/>
    
  </entry>
  
  <entry>
    <title>[Go] Package Test </title>
    <link href="https://stardustorz.github.io/2025/07/28/Golang/%E5%8C%85/Golang%20Test%20%E5%B7%A5%E5%85%B7%E6%8C%87%E4%BB%A4/"/>
    <id>https://stardustorz.github.io/2025/07/28/Golang/%E5%8C%85/Golang%20Test%20%E5%B7%A5%E5%85%B7%E6%8C%87%E4%BB%A4/</id>
    <published>2025-07-28T09:23:35.000Z</published>
    <updated>2025-07-28T09:23:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Golang Test 工具指令</p></blockquote><span id="more"></span><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>Go test 测试工具包含示例函数测试 (ExampleXXX)、单元测试 (TestXXX)、基准测试 (BenchmarkXXX)。</p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Go test [-c] [-i] [build flags] [packages] [flags for test binary]</span><br></pre></td></tr></table></figure><p>参数解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-c : 编译 go test 成为可执行的二进制文件，但是不运行测试。</span><br><span class="line">-i : 安装测试包依赖的 package，但是不运行测试。</span><br><span class="line"></span><br><span class="line">build flags 是编译过程中常用参数，使用命令 `go help build` 查看帮助</span><br><span class="line"></span><br><span class="line">packages 是关于包管理参数，使用命令 `go help packages` 查看帮助</span><br><span class="line"></span><br><span class="line">flags for test binary 是 test 常用参数，使用命令 `go help testflag` 查看帮助, 部分参数如下：</span><br><span class="line">-test. V : 是否输出全部的单元测试用例（不管成功或者失败），默认没有加上，所以只输出失败的单元测试用例。</span><br><span class="line">-test. Run pattern: 指定正则来运行某个/某些测试用例</span><br><span class="line">-test. Bench patten: 只跑那些性能测试用例</span><br><span class="line">-test. Benchmem : 是否在性能测试的时候输出内存情况</span><br><span class="line">-test. Benchtime t : 性能测试运行的时间，默认是 1 s</span><br><span class="line">-test. Cpuprofile cpu. Out : 是否输出 cpu 性能分析文件，为空则不做 cpu 分析</span><br><span class="line">-test. Memprofile mem. Out : 是否输出内存性能分析文件</span><br><span class="line">-test. Blockprofile block. Out : 是否输出内部 goroutine 阻塞的性能分析文件</span><br><span class="line">-test. Memprofilerate n : 内存分析参数，内存分析的抽样率, 默认 512*1024, 可结合 GOGC=off 来关闭内存回收，对每个内存块的分配进行观察。</span><br><span class="line">-test. Blockprofilerate n: 阻塞事件的分析参数，指定抽样频率，控制 goroutine 阻塞时候打点的纳秒数。默认 1。</span><br><span class="line">-test. Parallel n : 性能测试的程序并行 cpu 数，默认等于 GOMAXPROCS。</span><br><span class="line">-test. Timeout t : 如果测试用例运行时间超过 t，则抛出 panic</span><br><span class="line">-test. Cpu 1,2,4 : 程序运行在哪些 CPU 上面</span><br><span class="line">-test. Short : 将那些运行时间较长的测试用例运行时间缩短</span><br><span class="line">-test. Outputdir : 输出目录</span><br><span class="line">-test. Coverprofile : 测试覆盖率参数，指定输出文件</span><br></pre></td></tr></table></figure><p>测试函数示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test 测试函数</span></span><br><span class="line">Func TestXXX (t *testing. T) &#123; … &#125;</span><br><span class="line"><span class="comment">// benchmark 基准函数</span></span><br><span class="line">Func BenchmarkXXX (b *testing. B) &#123; … &#125;</span><br><span class="line"><span class="comment">// examples 示例函数</span></span><br><span class="line">Func ExamplePrintln () &#123;</span><br><span class="line">    Println (“output”)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行测试函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Go test -v -run=<span class="string">&#x27;TestXXX&#x27;</span></span><br><span class="line"></span><br><span class="line">Go test -v xxx_test. Go -run=<span class="string">&#x27;TestXXX&#x27;</span></span><br><span class="line"></span><br><span class="line">Go test -v xxx_test. Go -test. Run TestXXX</span><br><span class="line"></span><br><span class="line">Go test -v xxx_test. Go -bench=.</span><br><span class="line"></span><br><span class="line">Go test -v xxx_test. Go -bench=XXX</span><br><span class="line"></span><br><span class="line">Go test -v xxx_test. Go -bench=BenchmarkXXX</span><br><span class="line"></span><br><span class="line">Go test -v xxx_test. Go -bench=^BenchmarkXXX$ -run=^$</span><br></pre></td></tr></table></figure><p>-v 参数表示是否通过测试都会显示结果，不加-v 表示只显示未通过的测试</p><p>其他参数：-p -cpu=1,2,4 -args= -parallel -timeout -run -short</p><p>执行基准测试:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Go test -bench=.</span><br><span class="line">Go test -c</span><br><span class="line">./xxx. Test -test. Bench=.</span><br><span class="line">Go test -bench=. -benchtime <span class="number">0.1</span> s</span><br><span class="line">./xxx. Test -test. Bench=. -test. Benchtime=<span class="number">1</span> s</span><br><span class="line">Go test -bench=. -count=<span class="number">2</span></span><br><span class="line">./xxx. Test -test. Bench=. -test. Count=<span class="number">2</span></span><br><span class="line"># -benchmem : 打印用于基准测试的内存分配统计数据</span><br><span class="line">Go test -bench=. -benchmem</span><br><span class="line">./xxx. Test -test. Bench -test. Benchmem</span><br></pre></td></tr></table></figure><h2 id="2-参考："><a href="#2-参考：" class="headerlink" title="2 参考："></a>2 参考：</h2><ul><li><a href="https://deepzz.com/post/the-command-flag-of-go-test.html">Go 测试，go test 工具的具体指令 flag</a></li><li><a href="https://sanyuesha.com/2019/08/21/go-test/">Golang 测试</a></li><li><a href="https://studygolang.com/articles/2491">golang test测试使用</a></li><li><a href="http://doc.golang.ltd/">标准库testing</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Golang Test 工具指令&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
    <category term="GoPackges" scheme="https://stardustorz.github.io/tags/GoPackges/"/>
    
  </entry>
  
  <entry>
    <title>[Go] ldflags</title>
    <link href="https://stardustorz.github.io/2025/07/28/Golang/%E5%8C%85/ldflags/"/>
    <id>https://stardustorz.github.io/2025/07/28/Golang/%E5%8C%85/ldflags/</id>
    <published>2025-07-28T09:23:35.000Z</published>
    <updated>2025-07-28T09:23:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Golang 在编译时使用ldflags动态设置包中变量的值</p></blockquote><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-X importpath.name=value Set the value of the string variable in importpath named name to value. Note that before Go 1.5 this option took two separate arguments. Now it takes one argument split on the first = sign.</span><br></pre></td></tr></table></figure><p>ldflags用于链接过程，详细见文章<a href="https://tonybai.com/2017/06/27/an-intro-about-go-portability/">也谈Go的可移植性</a><br><a href="http://blog.champbay.com/2019/11/25/%e9%9d%99%e6%80%81%e9%93%be%e6%8e%a5%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e9%9d%99%e6%80%81%e5%ba%93%e5%85%b1%e4%ba%ab%e5%ba%93%e8%bf%99%e4%ba%9b%e6%a6%82%e5%bf%b5%e7%9a%84%e8%af%a6%e8%a7%a3/">静态链接,动态链接,静态库,共享库这些概念的详解</a></p><h2 id="1-参数作用"><a href="#1-参数作用" class="headerlink" title="1 参数作用"></a>1 参数作用</h2><p><code>golang在编译、测试、安装时使用-ldflags -X动态设置包中变量的值 go install/build/test 时可以通过命令行参数设置package中的变量， 其格式为-X importpath.name=val, 其中importpath是变量所在包的的路径， name是包中定义的变量， val 是需要在编译时设置的变量的值(string)， name表示的变量只能是variable，不能是constant, 且不能通过函数调用的方式初始化， 其类型只能是string，不可是int, bool等. 如果val中存在空格,需要用引号括起来,如下date和go version输出结果有空格： go build -ldflags &quot;-X &#39;main.BUILD_TIME=`date`&#39; -X &#39;main.GO_VERSION=`go version`&#39;&quot;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">docker version</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Client: Docker Engine - Community</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Version: 19.03.3</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">API version: 1.40</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Go version: go1.12.10</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Git commit: a872fc2</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Built: Tue Oct 8 00:55:12 2019</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">OS/Arch: darwin/amd64</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Experimental: <span class="literal">false</span></span></span><br></pre></td></tr></table></figure><h2 id="2-编译时使用"><a href="#2-编译时使用" class="headerlink" title="2 编译时使用"></a>2 编译时使用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">version    <span class="type">string</span></span><br><span class="line">build_time <span class="type">string</span></span><br><span class="line">go_version <span class="type">string</span></span><br><span class="line">git_commit <span class="type">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;version:&quot;</span>, version)</span><br><span class="line">fmt.Println(<span class="string">&quot;go version:&quot;</span>, go_version)</span><br><span class="line">fmt.Println(<span class="string">&quot;build time:&quot;</span>, build_time)</span><br><span class="line">fmt.Println(<span class="string">&quot;git log:&quot;</span>, git_commit)</span><br><span class="line">&#125;<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">执行输出：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>shell</span><br><span class="line">&gt; <span class="keyword">go</span> build -ldflags <span class="string">&quot;-X &#x27;main.build_time=$(date)&#x27; -X &#x27;main.git_commit=$(git log --pretty=format:&quot;</span>%h<span class="string">&quot; -1)&#x27; -X main.version=1.0.0 -X &#x27;main.go_version=`go version`&#x27;&quot;</span> main.<span class="keyword">go</span></span><br><span class="line">&gt; ./main</span><br><span class="line">version: <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line"><span class="keyword">go</span> version: <span class="keyword">go</span> version go1<span class="number">.14</span> darwin/amd64</span><br><span class="line">build time: <span class="number">2021</span>年 <span class="number">8</span>月 <span class="number">9</span>日 星期日 <span class="number">19</span>时<span class="number">09</span>分<span class="number">50</span>秒 CST</span><br><span class="line">git log: <span class="number">175</span>a5eb<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 测试时使用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">创建包和文件</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>shell</span><br><span class="line">&gt; mkdir $GOPATH/src/gotest </span><br><span class="line">&gt; touch $GOPATH/src/gotest/go_test.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><pre><code class="lang-go">package gotestimport &quot;testing&quot;var time stringvar version stringfunc TestBuild(t *testing.T) &#123;  t.Log(time)  t.Log(version)&#125;</code></pre><p>执行输出：</p><pre><code class="lang-shell">&gt; cd $GOPATH/src/&gt; GO111MODULE=off go test -ldflags=&quot;-X &#39;gotest.time=`date`&#39; -X gotest.version=1.0.1&quot; gotest -v=== RUN   TestBuild    TestBuild: go_test.go:9: 2021年 8月 9日 星期日 18时57分49秒 CST    TestBuild: go_test.go:10: 1.0.1--- PASS: TestBuild (0.00s)PASSok      gotest  0.009s</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/ahmczsy/p/11512151.html">ldflags使用技巧</a></li><li><a href="https://tonybai.com/2017/06/27/an-intro-about-go-portability/">也谈Go的可移植性</a></li><li><a href="http://blog.champbay.com/2019/11/25/%e9%9d%99%e6%80%81%e9%93%be%e6%8e%a5%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e9%9d%99%e6%80%81%e5%ba%93%e5%85%b1%e4%ba%ab%e5%ba%93%e8%bf%99%e4%ba%9b%e6%a6%82%e5%bf%b5%e7%9a%84%e8%af%a6%e8%a7%a3/">静态链接,动态链接,静态库,共享库这些概念的详解</a></li><li><a href="https://book.douban.com/subject/4141733/">Linux C编程一站式学习</a></li><li><a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/">Linux C编程一站式学习 ebook</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Golang 在编译时使用ldflags动态设置包中变量的值&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
    <category term="GoPackges" scheme="https://stardustorz.github.io/tags/GoPackges/"/>
    
  </entry>
  
  <entry>
    <title>[Go] Time/rate使用</title>
    <link href="https://stardustorz.github.io/2025/07/28/Golang/%E5%8C%85/time%20rate%E4%BD%BF%E7%94%A8/"/>
    <id>https://stardustorz.github.io/2025/07/28/Golang/%E5%8C%85/time%20rate%E4%BD%BF%E7%94%A8/</id>
    <published>2025-07-28T09:23:35.000Z</published>
    <updated>2025-07-28T09:23:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Time/rate 是基于 Token Bucket (令牌桶) 算法实现的限流</p></blockquote><span id="more"></span><h2 id="1-限流"><a href="#1-限流" class="headerlink" title="1 限流"></a>1 限流</h2><p>限制某个服务每秒的调用本服务的频率 客户端请求太多，超出服务端的服务能力，导致服务不可用。DoS攻击就是根据此原理， 耗尽被攻击对象的资源，让目标系统无法响应甚至崩溃。解决方案：服务端对客户端限流，保护服务端的资源。 限流通常在网关或网络层面实施。对各类请求设置最高的QPS阈值，当请求高于阈值时直接阻断。</p><p>常用的限流算法有滑动计数，漏斗限流和令牌限流三种：</p><ol><li>滑动计数限流：按时间片（比如1秒）定义滑动窗口，计数器记录当前窗口的请求次数， 达到阈值就限流，窗口滑动后计数器归零。可采用循环队列数据结构实现。</li><li>漏斗限流：维护一个队列，所有请求进队列，按FIFO服务，队满溢出则丢弃请求。</li><li>令牌桶限流：按固定速率往桶中存入令牌，服务前先从桶中取令牌，取到令牌才服务。</li></ol><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get golang.org/x/time/rate</span><br></pre></td></tr></table></figure><h3 id="2-2-构造一个限流器"><a href="#2-2-构造一个限流器" class="headerlink" title="2.2 构造一个限流器"></a>2.2 构造一个限流器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewLimiter returns a new Limiter that allows events up to rate r and permits</span></span><br><span class="line"><span class="comment">// bursts of at most b tokens.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLimiter</span><span class="params">(r Limit, b <span class="type">int</span>)</span></span> *Limiter &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Limiter&#123;</span><br><span class="line">        limit: r,</span><br><span class="line">        burst: b,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NewLimiter有两个参数</p><p>第一个r Limit 表示每秒可以放入多少个token到桶中，Limit是float64的别名；</p><p>第二个b int 表示桶容量大小,即同一时刻能取到的最大token数量；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">limiter := NewLimiter(<span class="number">10</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>示例表示每秒放入10个token，桶容量大小为1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">limit := Every(<span class="number">100</span> * time.Millisecond);</span><br><span class="line">limiter := NewLimiter(limit, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>Every表示放入token速率时间粒度;</p><p>示例表示每100ms放入1个token,即1秒放入10个；</p><h3 id="2-3-Wait-WaitN"><a href="#2-3-Wait-WaitN" class="headerlink" title="2.3 Wait/WaitN"></a>2.3 Wait/WaitN</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Wait(ctx context.Context) (err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> WaitN(ctx context.Context, n <span class="type">int</span>) (err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>Wait获取Token时如果数组不足(小于N)，将会阻塞一段时间，直至Token满足条件, 如果充足则直接返回</p><p>阻塞时间可以通过context参数设置Deadline或Timeout控制</p><h3 id="2-4-Allow-AllowN"><a href="#2-4-Allow-AllowN" class="headerlink" title="2.4 Allow/AllowN"></a>2.4 Allow/AllowN</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Allow() <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> AllowN(now time.Time, n <span class="type">int</span>) <span class="type">bool</span></span><br></pre></td></tr></table></figure><p>Allow获取Token充足返回true，同时Token减少，否则返回false，不会阻塞</p><h3 id="2-5-Reserve-ReserveN"><a href="#2-5-Reserve-ReserveN" class="headerlink" title="2.5 Reserve/ReserveN"></a>2.5 Reserve/ReserveN</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Reserve() *Reservation</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> ReserveN(now time.Time, n <span class="type">int</span>) *Reservation</span><br></pre></td></tr></table></figure><p>返回Reservation对象，有如下对象方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> OK() <span class="type">bool</span> <span class="comment">// 判断是否获取到token</span></span><br><span class="line"><span class="comment">// Delay is shorthand for DelayFrom(time.Now()).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> Delay() time.Duration <span class="comment">// 获取延迟等待时间,此时Cancel不起作用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> DelayFrom(now time.Time) time.Duration</span><br><span class="line"><span class="comment">// Cancel is shorthand for CancelAt(time.Now()).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> Cancel() <span class="comment">// 取消，将获取的Token重新放入桶中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> CancelAt(now time.Time)</span><br></pre></td></tr></table></figure><h3 id="2-6-调整速率和桶大小"><a href="#2-6-调整速率和桶大小" class="headerlink" title="2.6 调整速率和桶大小"></a>2.6 调整速率和桶大小</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetLimit(newLimit Limit) <span class="comment">//改变放入Token的速率</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetLimitAt(now time.Time, newLimit Limit)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetBurst(newBurst <span class="type">int</span>) <span class="comment">// 改变Token桶大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetBurstAt(now time.Time, newBurst <span class="type">int</span>)</span><br></pre></td></tr></table></figure><h3 id="2-7-获取速率和桶大小"><a href="#2-7-获取速率和桶大小" class="headerlink" title="2.7 获取速率和桶大小"></a>2.7 获取速率和桶大小</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Limit() Limit <span class="comment">// 获取速率</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Burst() <span class="type">int</span> <span class="comment">//获取桶容量</span></span><br></pre></td></tr></table></figure><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h2><ul><li><a href="https://www.cyhone.com/articles/analisys-of-golang-rate/">Golang 标准库限流器 time/rate 实现剖析</a></li><li><a href="https://www.cyhone.com/articles/usage-of-golang-rate/">Golang 标准库限流器 time/rate 使用介绍</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Time/rate 是基于 Token Bucket (令牌桶) 算法实现的限流&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
    <category term="GoPackges" scheme="https://stardustorz.github.io/tags/GoPackges/"/>
    
  </entry>
  
  <entry>
    <title>[Tool] Benchyou</title>
    <link href="https://stardustorz.github.io/2025/07/28/Golang/%E5%B7%A5%E5%85%B7/Benchyou%E4%BD%BF%E7%94%A8/"/>
    <id>https://stardustorz.github.io/2025/07/28/Golang/%E5%B7%A5%E5%85%B7/Benchyou%E4%BD%BF%E7%94%A8/</id>
    <published>2025-07-28T09:23:35.000Z</published>
    <updated>2025-07-28T09:23:35.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>benchyou is a benchmark tool for MySQL, real-time monitoring TPS and vmstat/iostat</p></blockquote><span id="more"></span><h2 id="1-Build"><a href="#1-Build" class="headerlink" title="1 Build"></a>1 Build</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/xelabs/benchyou</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> benchyou</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make build</span></span><br></pre></td></tr></table></figure><h2 id="2-Usage"><a href="#2-Usage" class="headerlink" title="2 Usage"></a>2 Usage</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bin/benchyou -h</span></span><br></pre></td></tr></table></figure><h2 id="3-Examples"><a href="#3-Examples" class="headerlink" title="3 Examples"></a>3 Examples</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">prepare 64 tables:</span><br><span class="line">./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou  --oltp-tables-count=64 prepare</span><br><span class="line"></span><br><span class="line">cleanup 64 tables:</span><br><span class="line">./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou  --oltp-tables-count=64 cleanup</span><br><span class="line"></span><br><span class="line">random insert(Write/Read Ratio=128:8):</span><br><span class="line"> ./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou --ssh-user=benchyou --ssh-password=benchyou --oltp-tables-count=64 --write-threads=128 --read-threads=8 --max-time=3600 random</span><br><span class="line"></span><br><span class="line">sequential insert(Write/Read Ratio=128:8):</span><br><span class="line"> ./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou --ssh-user=benchyou --ssh-password=benchyou --oltp-tables-count=64 --write-threads=128 --read-threads=8 --max-time=3600 seq</span><br><span class="line"></span><br><span class="line">mix(Write/Read/Update/Delete Ratio=4:4:4:4):</span><br><span class="line"> ./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou --ssh-user=benchyou --ssh-password=benchyou --oltp-tables-count=64 --write-threads=4 --read-threads=4 --update-threads=4 --delete-threads=4 --max-time=3600 random</span><br><span class="line"></span><br><span class="line">insert multiple rows(10 rows per insert):</span><br><span class="line"> ./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou --ssh-user=benchyou --ssh-password=benchyou --oltp-tables-count=64 --write-threads=4 --rows-per-insert=10 --max-time=3600 random</span><br><span class="line"></span><br><span class="line">batch update(10 rows per transaction):</span><br><span class="line"> ./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou --ssh-user=benchyou --ssh-password=benchyou --oltp-tables-count=64 --update-threads=4 --batch-per-commit=10 --max-time=3600 random</span><br><span class="line"></span><br><span class="line">query-range(Write/Read Ratio=128:8):</span><br><span class="line"> ./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou --ssh-user=benchyou --ssh-password=benchyou --oltp-tables-count=64 --write-threads=128 --read-threads=8 --max-time=3600 --mysql-range-order=DESC range</span><br></pre></td></tr></table></figure><h2 id="4-Github"><a href="#4-Github" class="headerlink" title="4 Github"></a>4 Github</h2><ul><li><a href="https://github.com/xelabs/benchyou">benchyou</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;benchyou is a benchmark tool for MySQL, real-time monitoring TPS and vmstat/iostat&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Tool" scheme="https://stardustorz.github.io/tags/Tool/"/>
    
  </entry>
  
  <entry>
    <title>[Algorithm] Array</title>
    <link href="https://stardustorz.github.io/2025/07/25/Algorithm/Array/"/>
    <id>https://stardustorz.github.io/2025/07/25/Algorithm/Array/</id>
    <published>2025-07-25T10:10:13.000Z</published>
    <updated>2025-07-27T16:16:55.222Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="1-声明和定义"><a href="#1-声明和定义" class="headerlink" title="1 声明和定义"></a>1 声明和定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">double</span>[] myList; </span><br><span class="line"><span class="type">double</span>[] myList = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 作为参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    System.out.print(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多维数组 前行后列</span></span><br><span class="line"><span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure><h2 id="2-11-盛最多水的容器"><a href="#2-11-盛最多水的容器" class="headerlink" title="2 11. 盛最多水的容器"></a>2 <a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h2><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针，每次移动较短的那个边</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = height.length - <span class="number">1</span>; i &lt; j; )&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> height[i] &lt; height[j] ? height[i++] : height[j--];</span><br><span class="line">            ans = Math.max(ans, (j-i+<span class="number">1</span>) * min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-15-三数之和"><a href="#3-15-三数之和" class="headerlink" title="3 15. 三数之和"></a>3 <a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || len &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 如果当前数字大于0，则三数之和一定大于0，所以结束循环</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> len-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[L] + nums[R];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));</span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[L] == nums[L+<span class="number">1</span>]) L++; <span class="comment">// 去重</span></span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[R] == nums[R-<span class="number">1</span>]) R--; <span class="comment">// 去重</span></span><br><span class="line">                    L++;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) L++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) R--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-33-搜索旋转排序数组"><a href="#4-33-搜索旋转排序数组" class="headerlink" title="4 33. 搜索旋转排序数组"></a>4 <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">//第一步，找出哪个半区是有序的，然后判断是不是在这个半区里面，缩小范围</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-38-外观数列"><a href="#5-38-外观数列" class="headerlink" title="5 38. 外观数列"></a>5 <a href="https://leetcode-cn.com/problems/count-and-say/">38. 外观数列</a></h2><p>要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个外观数列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="comment">//迭代出第n个外观数列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            <span class="comment">//计数，有几个这样的</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//第一个字符，计数的开始</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">code</span> <span class="operator">=</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//遍历整个字符串</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; str.length(); j++) &#123;</span><br><span class="line">                <span class="comment">//如果碰到不一样的，将之前的字符数量和字符加入</span></span><br><span class="line">                <span class="keyword">if</span> (str.charAt(j) != code) &#123;</span><br><span class="line">                    sb.append(count);</span><br><span class="line">                    sb.append(code);</span><br><span class="line">                    <span class="comment">//重新计算下一个字符</span></span><br><span class="line">                    code = str.charAt(j);</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(count);</span><br><span class="line">            sb.append(str.charAt(str.length() - <span class="number">1</span>));</span><br><span class="line">            str = sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-42-接雨水"><a href="#6-42-接雨水" class="headerlink" title="6 42. 接雨水"></a>6 <a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></h2><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="comment">// 双指针维护最小值,这个表示的是当前扫描到的可能存雨水的底的高度</span></span><br><span class="line">            min = height[height[l] &lt; height[r] ? l++ : r--];</span><br><span class="line">            <span class="comment">// max等于水位线</span></span><br><span class="line">            max = Math.max(max, min);</span><br><span class="line">            <span class="comment">// 累加差值</span></span><br><span class="line">            res += max - min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-寻找数组的中心索引"><a href="#7-寻找数组的中心索引" class="headerlink" title="7 寻找数组的中心索引"></a>7 寻找数组的中心索引</h2><p>题目：给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。</p><p>我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p><p>输入：<br>nums = [1, 7, 3, 6, 5, 6]<br>输出：3<br>解释：<br>索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。<br>同时, 3 也是第一个符合要求的中心索引。</p><p>思路：前缀和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>,leftsum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">    sum += nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(leftsum*<span class="number">2</span> == sum - nums[i])&#123;</span><br><span class="line">        <span class="keyword">return</span> i;&#125;</span><br><span class="line">    leftsum += nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="8-搜索插入位置"><a href="#8-搜索插入位置" class="headerlink" title="8 搜索插入位置"></a>8 搜索插入位置</h2><p>题目：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>思路：二分查找相等直接返回，大于mid则left=mid+1；否则right=mid-1；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-合并区间"><a href="#9-合并区间" class="headerlink" title="9 合并区间"></a>9 合并区间</h2><p>题目：给出一个区间的集合，请合并所有重叠的区间。</p><p>输入: [[1,3],[2,6],[8,10],[15,18]]<br>输出: [[1,6],[8,10],[15,18]]<br>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p><p>思路：按照左端点升序排序，然后遍历。</p><p>如果当前遍历到的区间的左端点 &gt; 结果集中最后一个区间的右端点，说明它们没有交集，此时把区间添加到结果集；<br>如果当前遍历到的区间的左端点 &lt;= 结果集中最后一个区间的右端点，说明它们有交集，此时产生合并操作，即：对结果集中最后一个区间的右端点更新（取两个区间的最大值）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> intervals.length;</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> intervals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照起点排序</span></span><br><span class="line">Arrays.sort(intervals,Comparator.comparing  <span class="title function_">Int</span><span class="params">(o -&gt; o[<span class="number">0</span>])</span>);</span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">res.add(intervals[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="type">int</span>[] curInterval = intervals[i];</span><br><span class="line">    <span class="comment">// 每次新遍历到的列表与当前结果集中的最后一个区间的末尾端点进行比较</span></span><br><span class="line">    <span class="type">int</span>[] peek = res.get(res.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (curInterval[<span class="number">0</span>] &gt; peek[<span class="number">1</span>]) &#123;</span><br><span class="line">        res.add(curInterval);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        peek[<span class="number">1</span>] = Math.max(curInterval[<span class="number">1</span>], peek[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br></pre></td></tr></table></figure><h2 id="10-最大子序和-1385"><a href="#10-最大子序和-1385" class="headerlink" title="10 最大子序和(1385)"></a>10 最大子序和(1385)</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preSum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> preSum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 注意条件</span></span><br><span class="line">            preSum = preSum &gt; <span class="number">0</span> ? preSum + nums[i] : nums[i];</span><br><span class="line">            maxSum = Math.max(maxSum, preSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-打家劫舍-II-375"><a href="#11-打家劫舍-II-375" class="headerlink" title="11 打家劫舍 II(375)"></a>11 打家劫舍 II(375)</h2><p><a href="https://leetcode-cn.com/problems/house-robber-ii/">https://leetcode-cn.com/problems/house-robber-ii/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span><br><span class="line"></span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</span><br><span class="line"></span><br><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob(nums, <span class="number">0</span>, n - <span class="number">2</span>), rob(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> first, <span class="type">int</span> last)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre2</span> <span class="operator">=</span> <span class="number">0</span>, pre1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> first; i &lt;= last; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> Math.max(pre1, pre2 + nums[i]);</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-搜索插入位置-1239"><a href="#12-搜索插入位置-1239" class="headerlink" title="12 搜索插入位置(1239)"></a>12 搜索插入位置(1239)</h2><p><a href="https://leetcode-cn.com/problems/search-insert-position/">https://leetcode-cn.com/problems/search-insert-position/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</span><br><span class="line"></span><br><span class="line">你可以假设数组中无重复元素。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>二分法<br>但要考虑边界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (h - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) </span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) </span><br><span class="line">                h = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意边界</span></span><br><span class="line">        <span class="keyword">if</span> (h &lt; <span class="number">0</span> &amp;&amp; l == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> (l + h) % <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> (l + h) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-接雨水-1145"><a href="#13-接雨水-1145" class="headerlink" title="13 接雨水(1145)"></a>13 接雨水(1145)</h2><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/">https://leetcode-cn.com/problems/trapping-rain-water/</a></p><p>双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="comment">// 双指针维护最小值</span></span><br><span class="line">            min = height[height[l] &lt; height[r] ? l++ : r--];</span><br><span class="line">            <span class="comment">// 接着维护最大值</span></span><br><span class="line">            max = Math.max(max, min);</span><br><span class="line">            <span class="comment">// 累加差值</span></span><br><span class="line">            res += max - min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-跳跃游戏-1059"><a href="#14-跳跃游戏-1059" class="headerlink" title="14 跳跃游戏(1059)"></a>14 跳跃游戏(1059)</h2><p><a href="https://leetcode-cn.com/problems/jump-game/">https://leetcode-cn.com/problems/jump-game/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个非负整数数组，你最初位于数组的第一个位置。</span><br><span class="line"></span><br><span class="line">数组中的每个元素代表你在该位置可以跳跃的最大长度。</span><br><span class="line"></span><br><span class="line">判断你是否能够到达最后一个位置。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: true</span><br><span class="line">解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span><br><span class="line"></span><br><span class="line">输入: [3,2,1,0,4]</span><br><span class="line">输出: false</span><br><span class="line">解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span><br></pre></td></tr></table></figure><p>贪心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 注意条件</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt;= max) &#123;</span><br><span class="line">                <span class="comment">// 最远索引</span></span><br><span class="line">                max = Math.max(max, nums[i] + i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意判断</span></span><br><span class="line">        <span class="keyword">return</span> max &gt;= n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-加一-1254"><a href="#15-加一-1254" class="headerlink" title="15 加一(1254)"></a>15 加一(1254)</h2><p><a href="https://leetcode-cn.com/problems/plus-one/">https://leetcode-cn.com/problems/plus-one/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</span><br><span class="line"></span><br><span class="line">最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</span><br><span class="line"></span><br><span class="line">你可以假设除了整数 0 之外，这个整数不会以零开头。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br><span class="line"></span><br><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure><p>正常操作<br>加法中常用<br>a = x % 10<br>b = x / 10</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] plusOne(<span class="type">int</span>[] digits) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> digits.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[length + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sums</span> <span class="operator">=</span> digits[i] + carry;</span><br><span class="line">            res[i] = sums % <span class="number">10</span>;</span><br><span class="line">            carry = sums / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(res,<span class="number">0</span>,length);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-合并两个有序数组-1057"><a href="#16-合并两个有序数组-1057" class="headerlink" title="16 合并两个有序数组(1057)"></a>16 合并两个有序数组(1057)</h2><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/">https://leetcode-cn.com/problems/merge-sorted-array/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。</span><br><span class="line">你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><p>三指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> m - <span class="number">1</span>, index2 = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">indexMerge</span> <span class="operator">=</span> m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index1 &gt;= <span class="number">0</span> || index2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[indexMerge--] = nums2[index2--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[indexMerge--] = nums1[index1--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[index1] &gt; nums2[index2]) &#123;</span><br><span class="line">            nums1[indexMerge--] = nums1[index1--];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[indexMerge--] = nums2[index2--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="17-买卖股票的最佳时机-1491"><a href="#17-买卖股票的最佳时机-1491" class="headerlink" title="17 买卖股票的最佳时机(1491)"></a>17 买卖股票的最佳时机(1491)</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</span><br><span class="line"></span><br><span class="line">如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</span><br><span class="line"></span><br><span class="line">注意：你不能在买入股票前卖出股票。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票</span><br><span class="line"></span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">// 边界</span></span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">// min</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// max</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 一直找最小的股</span></span><br><span class="line">            min = prices[i] &lt; min ? prices[i] : min;</span><br><span class="line">            <span class="comment">// 遍历一圈，存最大的利润</span></span><br><span class="line">            max = Math.max(max, prices[i] - min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-多数元素-1096"><a href="#18-多数元素-1096" class="headerlink" title="18 多数元素(1096)"></a>18 多数元素(1096)</h2><h2 id="19-多数元素-1096"><a href="#19-多数元素-1096" class="headerlink" title="19 多数元素(1096)"></a>19 多数元素(1096)</h2><p><a href="https://leetcode-cn.com/problems/majority-element/">https://leetcode-cn.com/problems/majority-element/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</span><br><span class="line"></span><br><span class="line">你可以假设数组是非空的，并且给定的数组总是存在多数元素。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-打家劫舍-1035"><a href="#20-打家劫舍-1035" class="headerlink" title="20 打家劫舍(1035)"></a>20 打家劫舍(1035)</h2><p><a href="https://leetcode-cn.com/problems/house-robber/">https://leetcode-cn.com/problems/house-robber/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span><br><span class="line"></span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br><span class="line"></span><br><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre2</span> <span class="operator">=</span> <span class="number">0</span>, pre1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> Math.max(pre2 + nums[i], pre1);</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21-移动零-1008"><a href="#21-移动零-1008" class="headerlink" title="21 移动零(1008)"></a>21 移动零(1008)</h2><p><a href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><ol><li>先把不是0的移动左</li><li>最后陆续加0</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num != <span class="number">0</span>) </span><br><span class="line">                nums[idx++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt; nums.length) &#123;</span><br><span class="line">            nums[idx++] =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22-合并区间-950"><a href="#22-合并区间-950" class="headerlink" title="22 合并区间(950)"></a>22 合并区间(950)</h2><p><a href="https://leetcode-cn.com/problems/merge-intervals/">https://leetcode-cn.com/problems/merge-intervals/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给出一个区间的集合，请合并所有重叠的区间。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br><span class="line"></span><br><span class="line">输入: [[1,4],[4,5]]</span><br><span class="line">输出: [[1,5]]</span><br><span class="line">解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="literal">null</span> || intervals.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> intervals.length;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; r &gt;= intervals[i + <span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">                r = Math.max(r, intervals[i + <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;l, r&#125;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[list.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-在排序数组中查找元素的第一个和最后一个位置-935"><a href="#23-在排序数组中查找元素的第一个和最后一个位置-935" class="headerlink" title="23 在排序数组中查找元素的第一个和最后一个位置(935)"></a>23 在排序数组中查找元素的第一个和最后一个位置(935)</h2><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</span><br><span class="line"></span><br><span class="line">你的算法时间复杂度必须是 O(log n) 级别。</span><br><span class="line"></span><br><span class="line">如果数组中不存在目标值，返回 [-1, -1]。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: [3,4]</span><br><span class="line"></span><br><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure><p>双指针+二分法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> findFirst(nums, target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> findFirst(nums, target + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (first == nums.length || nums[first] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;first, Math.max(first, last)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findFirst</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, h = nums.length; <span class="comment">// h 的初始值和往常不一样</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + ( h - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &gt;= target) h = m;</span><br><span class="line">            <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="24-全排列-985"><a href="#24-全排列-985" class="headerlink" title="24 全排列(985)"></a>24 全排列(985)</h2><p><a href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个 没有重复 数字的序列，返回其所有可能的全排列。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>dfs</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; permutes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; permuteList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        backtracking(permuteList, permutes, hasVisited, nums);</span><br><span class="line">        <span class="keyword">return</span> permutes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(List&lt;Integer&gt; permuteList, List&lt;List&lt;Integer&gt;&gt; permutes, <span class="type">boolean</span>[] visited, <span class="keyword">final</span> <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (permuteList.size() == nums.length) &#123;</span><br><span class="line">            permutes.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(permuteList)); <span class="comment">// 重新构造一个List</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; visited.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            permuteList.add(nums[i]);</span><br><span class="line">            backtracking(permuteList, permutes, visited, nums);</span><br><span class="line">            permuteList.remove(permuteList.size() - <span class="number">1</span>);</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="25-只出现一次的数字-890"><a href="#25-只出现一次的数字-890" class="headerlink" title="25 只出现一次的数字(890)"></a>25 只出现一次的数字(890)</h2><p><a href="https://leetcode-cn.com/problems/single-number/">https://leetcode-cn.com/problems/single-number/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>异或是一种基于二进制的位运算，用符号XOR或者^表示，其运算法则是对运算符两侧数的每一个二进制位同值则取0，异值则取1<br>简单理解就是不进位加法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) </span><br><span class="line">            ret = ret ^ num;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="26-岛屿数量-853"><a href="#26-岛屿数量-853" class="headerlink" title="26 岛屿数量(853)"></a>26 岛屿数量(853)</h2><p><a href="https://leetcode-cn.com/problems/number-of-islands/">https://leetcode-cn.com/problems/number-of-islands/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给你一个由 &#x27;1&#x27;（陆地）和 &#x27;0&#x27;（水）组成的的二维网格，请你计算网格中岛屿的数量。</span><br><span class="line"></span><br><span class="line">岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</span><br><span class="line"></span><br><span class="line">此外，你可以假设该网格的四条边均被水包围。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">[&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;],</span><br><span class="line">[&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;0&#x27;],</span><br><span class="line">[&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">[&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;]</span><br><span class="line">]</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">[&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">[&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">[&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">[&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;1&#x27;]</span><br><span class="line">]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>dfs</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m, n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] direaction = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">islandsNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    islandsNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> islandsNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;=n || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] d : direaction) &#123;</span><br><span class="line">            dfs(grid, i + d[<span class="number">0</span>], j + d[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="27-数组中的第K个最大元素-855"><a href="#27-数组中的第K个最大元素-855" class="headerlink" title="27 数组中的第K个最大元素(855)"></a>27 数组中的第K个最大元素(855)</h2><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>快排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        k = nums.length - k;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> partition(nums, l , h);</span><br><span class="line">            <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; k) &#123;</span><br><span class="line">                l = j + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                h = j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> pivot + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">                swap(arr, i, index++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="28-缺失的第一个正数-751"><a href="#28-缺失的第一个正数-751" class="headerlink" title="28 缺失的第一个正数(751)"></a>28 缺失的第一个正数(751)</h2><p><a href="https://leetcode-cn.com/problems/first-missing-positive/">https://leetcode-cn.com/problems/first-missing-positive/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,0]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,-1,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,8,9,11,12]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>怎么会怎么来，排序，接着遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; ans) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == ans) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="29-最长上升子序列-718"><a href="#29-最长上升子序列-718" class="headerlink" title="29 最长上升子序列(718)"></a>29 最长上升子序列(718)</h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个无序的整数数组，找到其中最长上升子序列的长度。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure><p><strong><code>dp[i]</code> 表示以 <code>nums[i]</code> 这个数结尾的最长递增子序列的长度</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>); <span class="comment">// 关键这里，</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(dp).max().orElse(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="30-将数组分成和相等的三个部分-798"><a href="#30-将数组分成和相等的三个部分-798" class="headerlink" title="30 将数组分成和相等的三个部分(798)"></a>30 将数组分成和相等的三个部分(798)</h2><p><a href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/">https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。</span><br><span class="line"></span><br><span class="line">形式上，如果可以找出索引 i+1 &lt; j 且满足 A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1] 就可以将数组三等分。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：[0,2,1,-6,6,-7,9,1,2,0,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1</span><br><span class="line"></span><br><span class="line">输入：[0,2,1,-6,6,7,9,-1,2,0,1]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">输入：[3,3,6,5,-2,2,5,1,-9,4]</span><br><span class="line">输出：true</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canThreePartsEqualSum</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历数组求总和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : A) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组A的和如果不能被3整除直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历数组累加，每累加到目标值cnt加1，表示又找到1段</span></span><br><span class="line">        sum /= <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            curSum += A[i];</span><br><span class="line">            <span class="keyword">if</span> (curSum == sum) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后判断是否找到了3段（注意如果目标值是0的话可以大于3段）</span></span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">3</span> || (cnt &gt; <span class="number">3</span> &amp;&amp; sum == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="31-拼写单词-705"><a href="#31-拼写单词-705" class="headerlink" title="31 拼写单词(705)"></a>31 拼写单词(705)</h2><p><a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/">https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</span><br><span class="line"></span><br><span class="line">假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</span><br><span class="line"></span><br><span class="line">注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。</span><br><span class="line"></span><br><span class="line">返回词汇表 words 中你掌握的所有单词的 长度之和。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释： </span><br><span class="line">可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 = 6。</span><br><span class="line"></span><br><span class="line">输入：words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot;</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">可以形成字符串 &quot;hello&quot; 和 &quot;world&quot;，所以答案是 5 + 5 = 10。</span><br></pre></td></tr></table></figure><p>类似于map的数组即可。双map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countCharacters</span><span class="params">(String[] words, String chars)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : chars.toCharArray()) &#123;</span><br><span class="line">            hash[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            Arrays.fill(tmp, <span class="number">0</span>);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">                tmp[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                <span class="keyword">if</span> (tmp[ch - <span class="string">&#x27;a&#x27;</span>] &gt; hash[ch - <span class="string">&#x27;a&#x27;</span>]) </span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            len += flag ? word.length() : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="32-子集-633"><a href="#32-子集-633" class="headerlink" title="32 子集(633)"></a>32 子集(633)</h2><p><a href="https://leetcode-cn.com/problems/subsets/">https://leetcode-cn.com/problems/subsets/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</span><br><span class="line"></span><br><span class="line">说明：解集不能包含重复的子集。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; subsets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; tempSubset = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; size &lt;= nums.length; size++) &#123;</span><br><span class="line">            backtracking(<span class="number">0</span>, tempSubset, subsets, size, nums); <span class="comment">// 不同的子集大小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subsets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> start, List&lt;Integer&gt; tempSubset, List&lt;List&lt;Integer&gt;&gt; subsets,</span></span><br><span class="line"><span class="params">                            <span class="keyword">final</span> <span class="type">int</span> size, <span class="keyword">final</span> <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tempSubset.size() == size) &#123;</span><br><span class="line">            subsets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempSubset));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            tempSubset.add(nums[i]);</span><br><span class="line">            backtracking(i + <span class="number">1</span>, tempSubset, subsets, size, nums);</span><br><span class="line">            tempSubset.remove(tempSubset.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="33-岛屿的最大面积-648"><a href="#33-岛屿的最大面积-648" class="headerlink" title="33 岛屿的最大面积(648)"></a>33 岛屿的最大面积(648)</h2><p><a href="https://leetcode-cn.com/problems/max-area-of-island/">https://leetcode-cn.com/problems/max-area-of-island/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含了一些 0 和 1 的非空二维数组 grid 。</span><br><span class="line"></span><br><span class="line">一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</span><br><span class="line"></span><br><span class="line">找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line"> 对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m, n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] direaction = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                maxArea = Math.max(maxArea, dfs(grid, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || grid[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[r][c] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] d : direaction) &#123;</span><br><span class="line">            area += dfs(grid, r + d[<span class="number">0</span>], c + d[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="34-每日温度-698"><a href="#34-每日温度-698" class="headerlink" title="34 每日温度(698)"></a>34 每日温度(698)</h2><p><a href="https://leetcode-cn.com/problems/daily-temperatures/">https://leetcode-cn.com/problems/daily-temperatures/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</span><br><span class="line"></span><br><span class="line">例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</span><br><span class="line"></span><br><span class="line">提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</span><br></pre></td></tr></table></figure><p>递减栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] T) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[T.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; T.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                res[t] = i - t;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="35-组合总和-582"><a href="#35-组合总和-582" class="headerlink" title="35 组合总和(582)"></a>35 组合总和(582)</h2><p><a href="https://leetcode-cn.com/problems/combination-sum/">https://leetcode-cn.com/problems/combination-sum/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class="line"></span><br><span class="line">candidates 中的数字可以无限制重复被选取。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">输入: candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; combinations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), combinations, <span class="number">0</span>, target, candidates);</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(List&lt;Integer&gt; tempCombination, List&lt;List&lt;Integer&gt;&gt; combinations,</span></span><br><span class="line"><span class="params">                            <span class="type">int</span> start, <span class="type">int</span> target, <span class="keyword">final</span> <span class="type">int</span>[] candidates)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            combinations.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempCombination));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidates[i] &lt;= target) &#123;</span><br><span class="line">                tempCombination.add(candidates[i]);</span><br><span class="line">                backtracking(tempCombination, combinations, i, target - candidates[i], candidates);</span><br><span class="line">                tempCombination.remove(tempCombination.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="36-颜色分类-584"><a href="#36-颜色分类-584" class="headerlink" title="36 颜色分类(584)"></a>36 颜色分类(584)</h2><p><a href="https://leetcode-cn.com/problems/sort-colors/">https://leetcode-cn.com/problems/sort-colors/</a><br>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```html</span><br><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p>zero和two作为双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">zero</span> <span class="operator">=</span> -<span class="number">1</span>, one = <span class="number">0</span>, two = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (one &lt; two) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[one] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, ++zero, one++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[one] == <span class="number">2</span>)&#123;</span><br><span class="line">                swap(nums, --two, one);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++one;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="37-三角形最小路径和-523"><a href="#37-三角形最小路径和-523" class="headerlink" title="37 三角形最小路径和(523)"></a>37 三角形最小路径和(523)</h2><p><a href="https://leetcode-cn.com/problems/triangle/">https://leetcode-cn.com/problems/triangle/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</span><br><span class="line"></span><br><span class="line">相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>dp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(triangle.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> triangle.size();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[row][triangle.get(row - <span class="number">1</span>).size()];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>; j &lt; triangle.get(i).size(); j++) &#123;</span><br><span class="line">                dp[i][j] = triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从下往上， 初始化最后一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; triangle.get(row - <span class="number">1</span>).size(); i++) &#123;</span><br><span class="line">            dp[row - <span class="number">1</span>][i] = triangle.get(row - <span class="number">1</span>).get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; triangle.get(i).size(); j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i+<span class="number">1</span>][j], dp[i+<span class="number">1</span>][j+<span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="38-乘积最大子数组-541"><a href="#38-乘积最大子数组-541" class="headerlink" title="38 乘积最大子数组(541)"></a>38 乘积最大子数组(541)</h2><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">https://leetcode-cn.com/problems/maximum-product-subarray/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br><span class="line"></span><br><span class="line">输入: [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure><p>dp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span>[] dpMax = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] dpMin = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        dpMax[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dpMin[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i-<span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> dpMax[i-<span class="number">1</span>];</span><br><span class="line">                dpMax[i-<span class="number">1</span>] = dpMin[i-<span class="number">1</span>];</span><br><span class="line">                dpMin[i-<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            dpMax[i] = Math.max(dpMax[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>], nums[i-<span class="number">1</span>]);</span><br><span class="line">            dpMin[i] = Math.min(dpMin[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>], nums[i-<span class="number">1</span>]);</span><br><span class="line">            ans = Math.max(ans, dpMax[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="39-两数之和-II-输入有序数组-559"><a href="#39-两数之和-II-输入有序数组-559" class="headerlink" title="39 两数之和 II - 输入有序数组(559)"></a>39 两数之和 II - 输入有序数组(559)</h2><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</span><br><span class="line"></span><br><span class="line">函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">返回的下标值（index1 和 index2）不是从零开始的。</span><br><span class="line">你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers = [2, 7, 11, 15], target = 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 双指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>, p2 = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; p2) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers[p1] + numbers[p2];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;p1+<span class="number">1</span>, p2+<span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) p1++;</span><br><span class="line">            <span class="keyword">else</span> p2--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="40-旋转数组-517"><a href="#40-旋转数组-517" class="headerlink" title="40 旋转数组(517)"></a>40 旋转数组(517)</h2><p><a href="https://leetcode-cn.com/problems/rotate-array/">https://leetcode-cn.com/problems/rotate-array/</a></p><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br><span class="line"></span><br><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        k %= n;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">            nums[start++] = nums[end];</span><br><span class="line">            nums[end--] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="41-寻找重复数-515"><a href="#41-寻找重复数-515" class="headerlink" title="41 寻找重复数(515)"></a>41 寻找重复数(515)</h2><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">https://leetcode-cn.com/problems/find-the-duplicate-number/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</span><br><span class="line"></span><br><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以使用双指针解决本题，慢指针每次走一步，快指针每次走两步</p><p>快指针走了：a + ( b + c ) m + b a + (b+c)m + b<em>a</em>+(<em>b</em>+<em>c</em>)<em>m</em>+<em>b</em><br>慢指针走了：a + ( b + c ) n + b a + (b+c)n + b<em>a</em>+(<em>b</em>+<em>c</em>)<em>n</em>+<em>b</em><br>根据快走的是慢的两倍，<br>a + ( b + c ) m + b = 2 ( a + ( b + c ) n + b ) a + (b+c)m + b = 2(a + (b+c)n + b)<em>a</em>+(<em>b</em>+<em>c</em>)<em>m</em>+<em>b</em>=2(<em>a</em>+(<em>b</em>+<em>c</em>)<em>n</em>+<em>b</em>) =&gt;<br>a = ( b + c ) ( m − 2 n ) − b a = (b+c)(m-2n) - b<em>a</em>=(<em>b</em>+<em>c</em>)(<em>m</em>−2<em>n</em>)−<em>b</em></p><p>得 a 的距离为（环长度的倍数 - b），即从头节点走到环开头节点等于 slow 指针走到环开头节点的距离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> nums[<span class="number">0</span>], fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line">        fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="42-存在重复元素-471"><a href="#42-存在重复元素-471" class="headerlink" title="42 存在重复元素(471)"></a>42 存在重复元素(471)</h2><p><a href="https://leetcode-cn.com/problems/contains-duplicate/">https://leetcode-cn.com/problems/contains-duplicate/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组，判断是否存在重复元素。</span><br><span class="line"></span><br><span class="line">如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(num)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="43-除自身以外数组的乘积-467"><a href="#43-除自身以外数组的乘积-467" class="headerlink" title="43 除自身以外数组的乘积(467)"></a>43 除自身以外数组的乘积(467)</h2><p><a href="https://leetcode-cn.com/problems/product-of-array-except-self/">https://leetcode-cn.com/problems/product-of-array-except-self/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</span><br><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] products = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(products, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            left *= nums[i - <span class="number">1</span>];</span><br><span class="line">            products[i] *= left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            right *= nums[i + <span class="number">1</span>];</span><br><span class="line">            products[i] *= right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> products;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="44-两个数组的交集-II-402"><a href="#44-两个数组的交集-II-402" class="headerlink" title="44 两个数组的交集 II(402)"></a>44 两个数组的交集 II(402)</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/</a></p><p>给定两个数组，编写一个函数来计算它们的交集。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出: [2,2]</span><br><span class="line"></span><br><span class="line">输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出: [4,9]</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums1) &#123;</span><br><span class="line">            list1.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.contains(num)) &#123;</span><br><span class="line">                list2.add(num);</span><br><span class="line">                list1.remove(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list2.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="45-子集-II-304"><a href="#45-子集-II-304" class="headerlink" title="45 子集 II(304)"></a>45 子集 II(304)</h2><p><a href="https://leetcode-cn.com/problems/subsets-ii/">https://leetcode-cn.com/problems/subsets-ii/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</span><br><span class="line"></span><br><span class="line">说明：解集不能包含重复的子集。</span><br><span class="line"></span><br><span class="line">输入: [1,2,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; subsets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; tempSubset = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; size &lt;= nums.length; size++) &#123;</span><br><span class="line">            backtracking(<span class="number">0</span>, tempSubset, subsets, hasVisited, size, nums); <span class="comment">// 不同的子集大小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subsets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> start, List&lt;Integer&gt; tempSubset, List&lt;List&lt;Integer&gt;&gt; subsets, <span class="type">boolean</span>[] hasVisited,</span></span><br><span class="line"><span class="params">                            <span class="keyword">final</span> <span class="type">int</span> size, <span class="keyword">final</span> <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tempSubset.size() == size) &#123;</span><br><span class="line">            subsets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempSubset));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !hasVisited[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tempSubset.add(nums[i]);</span><br><span class="line">            hasVisited[i] = <span class="literal">true</span>;</span><br><span class="line">            backtracking(i + <span class="number">1</span>, tempSubset, subsets, hasVisited, size, nums);</span><br><span class="line">            hasVisited[i] = <span class="literal">false</span>;</span><br><span class="line">            tempSubset.remove(tempSubset.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="46-寻找旋转排序数组中的最小值-316"><a href="#46-寻找旋转排序数组中的最小值-316" class="headerlink" title="46 寻找旋转排序数组中的最小值(316)"></a>46 寻找旋转排序数组中的最小值(316)</h2><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">假设按照升序排序的数组在预先未知的某个点上进行了旋转。</span><br><span class="line"></span><br><span class="line">( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</span><br><span class="line"></span><br><span class="line">请找出其中最小的元素。</span><br><span class="line"></span><br><span class="line">你可以假设数组中不存在重复元素。</span><br><span class="line"></span><br><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (h - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &lt;= nums[h]) &#123;</span><br><span class="line">                h = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="47-有序矩阵中第K小的元素-337"><a href="#47-有序矩阵中第K小的元素-337" class="headerlink" title="47 有序矩阵中第K小的元素(337)"></a>47 有序矩阵中第K小的元素(337)</h2><p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/">https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。</span><br><span class="line">请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。</span><br><span class="line"></span><br><span class="line">matrix = [</span><br><span class="line">   [ 1,  5,  9],</span><br><span class="line">   [10, 11, 13],</span><br><span class="line">   [12, 13, 15]</span><br><span class="line">],</span><br><span class="line">k = 8,</span><br><span class="line"></span><br><span class="line">返回 13。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> matrix[<span class="number">0</span>][<span class="number">0</span>], hi = matrix[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n &amp;&amp; matrix[i][j] &lt;= mid; j++) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; k) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;1-声明和定义&quot;&gt;&lt;a href=&quot;#1-声明和定义&quot; class=&quot;headerlink&quot; title=&quot;1 声明和定义&quot;&gt;&lt;/a&gt;1 声明和定义&lt;/h2&gt;&lt;figure class=&quot;highlight java</summary>
      
    
    
    
    
    <category term="Algorithm" scheme="https://stardustorz.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>[Algorithm] Dynamic Programming</title>
    <link href="https://stardustorz.github.io/2025/07/25/Algorithm/Dynamic%20Programming/"/>
    <id>https://stardustorz.github.io/2025/07/25/Algorithm/Dynamic%20Programming/</id>
    <published>2025-07-25T10:10:13.000Z</published>
    <updated>2025-07-25T10:10:13.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h3 id="0-1-1、思考状态"><a href="#0-1-1、思考状态" class="headerlink" title="0.1 1、思考状态"></a>0.1 1、思考状态</h3><ul><li>状态的定义：题目问什么，把什么设置成状态</li><li>思考状态怎么转移，如果不好转移，尝试修改定义</li><li>状态转移方程：大问题的最优解怎么从小问题的最优解得到</li></ul><h3 id="0-2-2、思考状态转移方程"><a href="#0-2-2、思考状态转移方程" class="headerlink" title="0.2 2、思考状态转移方程"></a>0.2 2、思考状态转移方程</h3><ul><li>推导技巧：分类讨论。即：对状态空间进行分类</li><li>「动态规划」方法依然是「空间换时间」思想的体现，常见的解决问题的过程很像在「填表」</li></ul><h3 id="0-3-3、思考初始化"><a href="#0-3-3、思考初始化" class="headerlink" title="0.3 3、思考初始化"></a>0.3 3、思考初始化</h3><ul><li>角度 1：直接从状态的语义出发；</li><li>角度 2：如果状态的语义不好思考，就考虑「状态转移方程」的边界需要什么样初始化的条件；</li><li>角度 3：从「状态转移方程」方程的下标看是否需要多设置一行、一列表示「哨兵」（sentinel），这样可以避免一些特殊情况的讨论。</li></ul><h3 id="0-4-4、思考输出"><a href="#0-4-4、思考输出" class="headerlink" title="0.4 4、思考输出"></a>0.4 4、思考输出</h3><p>有些时候是最后一个状态，有些时候可能会综合之前所有计算过的状态。</p><h3 id="0-5-5、思考优化空间（也可以叫做表格复用）"><a href="#0-5-5、思考优化空间（也可以叫做表格复用）" class="headerlink" title="0.5 5、思考优化空间（也可以叫做表格复用）"></a>0.5 5、思考优化空间（也可以叫做表格复用）</h3><ul><li>「优化空间」会使得代码难于理解，且是的「状态」丢失原来的语义，初学的时候可以不一步到位。先把代码写正确是更重要；</li><li>「优化空间」在有一种情况下是很有必要的，那就是状态空间非常庞大的时候（处理海量数据），此时空间不够用，就必须「优化空间」；</li><li>非常经典的「优化空间」的典型问题是「0-1 背包」问题和「完全背包」问题。</li></ul><h2 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1 斐波那契数列"></a>1 斐波那契数列</h2><h3 id="1-1-70-爬楼梯"><a href="#1-1-70-爬楼梯" class="headerlink" title="1.1 70.爬楼梯"></a>1.1 70.爬楼梯</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：第i个楼梯可以从i-1或者i-2处再走一步到达；那么dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class="line"><span class="comment">//又因为只和前两步有关，可以用两个变量存储之前的状态，降低时间复杂度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre1</span> <span class="operator">=</span> <span class="number">1</span>,pre2 = <span class="number">2</span>;  <span class="comment">//初始状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> pre1 + pre2;<span class="comment">//当前为前两级的和</span></span><br><span class="line">            pre1 = pre2;<span class="comment">//都前进一步</span></span><br><span class="line">            pre2 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-198-强盗打劫"><a href="#1-2-198-强盗打劫" class="headerlink" title="1.2 198.强盗打劫"></a>1.2 198.强盗打劫</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。</span></span><br><span class="line"><span class="comment">//状态转移方程：dp[i] = Math.max(dp[i-2] + nums[i],dp[i-1]) </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre1</span> <span class="operator">=</span> <span class="number">0</span>,pre2 = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            cur = Math.max(nums[i] + pre1 , pre2);</span><br><span class="line">            pre1 = pre2;</span><br><span class="line">            pre2 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-213-强盗在环型街道打劫"><a href="#1-3-213-强盗在环型街道打劫" class="headerlink" title="1.3 213.强盗在环型街道打劫"></a>1.3 213.强盗在环型街道打劫</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：在打家劫舍的基础上限定了范围，也就是打劫的第一家和最后一家不能相邻[0,n-2] [1,n-1]</span></span><br><span class="line"><span class="comment">//状态转移方程dp[i] = Math.max(dp[i-2] + nums[i],dp[i-1]) </span></span><br><span class="line"><span class="comment">//通过新建打劫方法对范围进行限定和比较</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//抢劫的第一家和最后一家不能相邻[1,n-1] [0,n-2]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> Math.max(robHelper(nums,<span class="number">1</span>,n-<span class="number">1</span>),robHelper(nums,<span class="number">0</span>,n-<span class="number">2</span>)); <span class="comment">//两种不同的打劫方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">robHelper</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre1</span> <span class="operator">=</span> <span class="number">0</span>,pre2=<span class="number">0</span>,cur=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i&lt;=end;i++)&#123;</span><br><span class="line">            cur = Math.max(pre1 + nums[i] , pre2);</span><br><span class="line">            pre1 = pre2;</span><br><span class="line">            pre2 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-信件错排"><a href="#1-4-信件错排" class="headerlink" title="1.4 信件错排"></a>1.4 信件错排</h3><p>题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：</span></span><br><span class="line"><span class="comment">// i==k，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。</span></span><br><span class="line"><span class="comment">// i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。</span></span><br><span class="line">dp[i] = (i-<span class="number">1</span>)*dp[i-<span class="number">2</span>] + (i-<span class="number">1</span>)*dp[i-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="1-5-母牛生产"><a href="#1-5-母牛生产" class="headerlink" title="1.5 母牛生产"></a>1.5 母牛生产</h3><p>题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="2-矩阵路径"><a href="#2-矩阵路径" class="headerlink" title="2 矩阵路径"></a>2 矩阵路径</h2><h3 id="2-1-64-矩阵的最小路径和"><a href="#2-1-64-矩阵的最小路径和" class="headerlink" title="2.1 64.矩阵的最小路径和"></a>2.1 64.矩阵的最小路径和</h3><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前的状态只能从左或者上到达</span></span><br><span class="line"><span class="comment">//状态转移方程dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</span></span><br><span class="line"><span class="comment">//考虑边界，在最左时不可能从左来，在最上时，不可能从上来</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; grid.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>) grid[i][j] = grid[i][j] + grid[i][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) grid[i][j] = grid[i][j] + grid[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] = grid[i][j] + Math.min(grid[i-<span class="number">1</span>][j],grid[i][j-<span class="number">1</span>]);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.length - <span class="number">1</span>][grid[<span class="number">0</span>].length - <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-62-矩阵的总路径数"><a href="#2-2-62-矩阵的总路径数" class="headerlink" title="2.2 62.矩阵的总路径数"></a>2.2 62.矩阵的总路径数</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span><br><span class="line"><span class="comment">//左边界和上边界都是1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-0-1背包"><a href="#3-0-1背包" class="headerlink" title="3 0-1背包"></a>3 0-1背包</h2><p>有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：</span></span><br><span class="line"><span class="comment">//第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。</span></span><br><span class="line"><span class="comment">//第 i 件物品添加到背包中，dp[i][j] = dp[i-1][j-w] + v。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//状态转移方程：dp[i][j] = max(dp[i-1][j], dp[i-1][j-w]+v)</span></span><br><span class="line"><span class="comment">// W 为背包总体积</span></span><br><span class="line"><span class="comment">// N 为物品数量</span></span><br><span class="line"><span class="comment">// weights 数组存储 N 个物品的重量</span></span><br><span class="line"><span class="comment">// values 数组存储 N 个物品的价值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span> N, <span class="type">int</span>[] weights, <span class="type">int</span>[] values)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> weights[i - <span class="number">1</span>], v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= W; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w) &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w] + v);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-空间优化"><a href="#3-1-空间优化" class="headerlink" title="3.1 空间优化"></a>3.1 空间优化</h3><p>观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i] = max(dp[j],dp[j-w]+v)</span></span><br><span class="line"><span class="comment">//因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w]，防止将 dp[i-1][j-w] 覆盖。也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按倒序来循环求解。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span> N, <span class="type">int</span>[] weights, <span class="type">int</span>[] values)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> weights[i - <span class="number">1</span>], v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> W; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - w] + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-完全背包"><a href="#4-完全背包" class="headerlink" title="4 完全背包"></a>4 完全背包</h2><h3 id="4-1-322-找零钱的最少硬币数"><a href="#4-1-322-找零钱的最少硬币数" class="headerlink" title="4.1 322.找零钱的最少硬币数"></a>4.1 322.找零钱的最少硬币数</h3><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//状态转移方程：dp[amount] = Math.min(&#123;dp[amount - coin]|(for(int coin : coins))&#125;)</span></span><br><span class="line"><span class="comment">//也就是根据当前硬币的面值可以抵达的状态中的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> coin : coins)&#123;<span class="comment">//对硬币面值进行遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> coin; i &lt; amount + <span class="number">1</span>; i++)&#123;</span><br><span class="line">                <span class="comment">//如果一个硬币就可以，置为一</span></span><br><span class="line">                <span class="keyword">if</span>(i == coin) dp[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果减一个硬币就可以，在该状态基础上加一</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dp[i] == <span class="number">0</span> &amp;&amp; dp[i-coin] != <span class="number">0</span>) dp[i] = dp[i-coin] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//在遍历硬币的时候，如果发现更优解，重置结果</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dp[i] != <span class="number">0</span> &amp;&amp; dp[i-coin] != <span class="number">0</span>) dp[i] = Math.min(dp[i], dp[i-coin]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == <span class="number">0</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-518-找零钱的硬币数组合"><a href="#4-2-518-找零钱的硬币数组合" class="headerlink" title="4.2 518.找零钱的硬币数组合"></a>4.2 518.找零钱的硬币数组合</h3><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> coin : coins)&#123;   <span class="comment">//遍历硬币面值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> coin; i &lt; amount + <span class="number">1</span>; i++)&#123;</span><br><span class="line">                dp[i] += dp[i-coin];  <span class="comment">//终态是不同状态到达该状态的累加</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-数组区间"><a href="#5-数组区间" class="headerlink" title="5 数组区间"></a>5 数组区间</h2><h3 id="5-1-303-数组区间和"><a href="#5-1-303-数组区间和" class="headerlink" title="5.1 303.数组区间和"></a>5.1 303.数组区间和</h3><p>给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从i到j的区间和可以转化成前缀和之差</span></span><br><span class="line"><span class="comment">//构建一个数组，保存从0到下标处的数组和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] sums;  <span class="comment">//和数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= nums.length;i++)&#123;</span><br><span class="line">            sums[i] = sums[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sums[j+<span class="number">1</span>] - sums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-413-等差数列划分"><a href="#5-2-413-等差数列划分" class="headerlink" title="5.2 413.等差数列划分"></a>5.2 413.等差数列划分</h3><p>数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。</p><p>如果满足以下条件，则称子数组(P, Q)为等差数组：</p><p>元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。</p><p>函数要返回数组 A 中所有为等差数组的子数组个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：dp[i]表示以A[i]结尾的等差递增子区间的个数</span></span><br><span class="line"><span class="comment">//当 A[i] - A[i-1] == A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。</span></span><br><span class="line"><span class="comment">//也就是在 A[i] - A[i-1] == A[i-1] - A[i-2] 时，dp[i] = dp[i-1] + 1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfArithmeticSlices</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> A.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] - A[i-<span class="number">1</span>] == A[i-<span class="number">1</span>] - A[i-<span class="number">2</span>])&#123;<span class="comment">//从头到尾遍历数组</span></span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> cnt : dp)&#123;</span><br><span class="line">            total += cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-分割整数"><a href="#6-分割整数" class="headerlink" title="6 分割整数"></a>6 分割整数</h2><h3 id="6-1-分割整数的最大乘积"><a href="#6-1-分割整数的最大乘积" class="headerlink" title="6.1 分割整数的最大乘积"></a>6.1 分割整数的最大乘积</h3><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//状态转移方程： dp[i] = Math.max(dp[i], Math.max(j*dp[i-j], j*(i-j)))</span></span><br><span class="line"><span class="comment">//和自己比，和不同切的方式比，留下最大值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j*dp[i-j], j*(i-j)));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-最长上升子序列"><a href="#7-最长上升子序列" class="headerlink" title="7 最长上升子序列"></a>7 最长上升子序列</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：动态规划 dp[i]存储当前的最大上升子序列，遍历前序dp，如果大于则dp[j]+1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;<span class="comment">//遍历整数数组</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)&#123;<span class="comment">//计算当前最大上升子序列</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;<span class="comment">//如果当前值比前面遍历到的大，最大上升子序列加一</span></span><br><span class="line">                    max = Math.max(max, dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ret : dp)&#123;</span><br><span class="line">            result = Math.max(ret, result);   <span class="comment">//找出dp数组中的最大</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-1-剑指-Offer-46-把数字翻译成字符串"><a href="#7-1-剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="7.1 剑指 Offer 46. 把数字翻译成字符串"></a>7.1 <a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h3><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(num);</span><br><span class="line">        <span class="comment">//dp[i-2] = b; dp[i-1] = a; dp[i] = c </span></span><br><span class="line">        <span class="comment">//对于一个字符串，如果最后两位可以被翻译，那么</span></span><br><span class="line">        <span class="comment">//dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class="line">        <span class="comment">//否则dp[i] = dp[i-1]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从左往右递推</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> s.substring(i - <span class="number">2</span>, i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> tmp.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; tmp.compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> ? a + b : a;</span><br><span class="line">            b = a;</span><br><span class="line">            a = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-字符串相关"><a href="#8-字符串相关" class="headerlink" title="8 字符串相关"></a>8 字符串相关</h2><h3 id="8-1-72-编辑距离"><a href="#8-1-72-编辑距离" class="headerlink" title="8.1 72. 编辑距离"></a>8.1 <a href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a></h3><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i][j]: word1中前i个单词变换到word2中前j个单词需要的最短操作次数</span></span><br><span class="line"><span class="comment">//考虑某一个单词是空的</span></span><br><span class="line"><span class="comment">//状态转移：</span></span><br><span class="line"><span class="comment">//增：dp[i][j] = dp[i][j-1] + 1</span></span><br><span class="line"><span class="comment">//删：dp[i][j] = dp[i-1][j] + 1</span></span><br><span class="line"><span class="comment">//改：dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> word1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> word2.length();</span><br><span class="line">        <span class="comment">// 多开一行一列是为了保存边界条件，即字符长度为 0 的情况，这一点在字符串的动态规划问题中比较常见</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化：当 word2 长度为 0 时，将 word1 的全部删除即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 word1 长度为 0 时，插入所有 word2 的字符即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 由于 word1.charAt(i) 操作会去检查下标是否越界，因此在 Java 里，将字符串转换成字符数组是常见额操作</span></span><br><span class="line">        <span class="type">char</span>[] word1Array = word1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] word2Array = word2.toCharArray();</span><br><span class="line">        <span class="comment">// 递推开始，注意：填写 dp 数组的时候，由于初始化多设置了一行一列，横纵坐标有个偏移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">                <span class="comment">// 这是最佳情况</span></span><br><span class="line">                <span class="comment">// 多开了一行，所以是 i-1 和 j-1</span></span><br><span class="line">                <span class="keyword">if</span> (word1Array[i - <span class="number">1</span>] == word2Array[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 否则在以下三种情况中选出步骤最少的，这是「动态规划」的「最优子结构」</span></span><br><span class="line">                <span class="comment">// 1、在下标 i 处插入一个字符</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 2、替换一个字符</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">replace</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 3、删除一个字符</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">delete</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = Math.min(Math.min(insert, replace), delete);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-2-5-最长回文子串"><a href="#8-2-5-最长回文子串" class="headerlink" title="8.2 5. 最长回文子串"></a>8.2 <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h3><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义状态 dp[i][j] 表示从 i 到 j 的字串是不是回文的</span></span><br><span class="line"><span class="comment">//状态转移方程 ：dp[i][j] = ( s[j] == s[j] ) &amp;&amp; dp[i+1][j-1]</span></span><br><span class="line"><span class="comment">//或者 j - i &lt; 3 的情况下 s[j] == s[j]</span></span><br><span class="line"><span class="comment">//初始化dp[i][i] = true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录最大长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录开始</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//表示从i到j是不是回文串</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len; i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(charArray[i] != charArray[j])&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - i &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen)&#123;</span><br><span class="line">                maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,start+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;h3 id=&quot;0-1-1、思考状态&quot;&gt;&lt;a href=&quot;#0-1-1、思考状态&quot;</summary>
      
    
    
    
    
    <category term="Algorithm" scheme="https://stardustorz.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>[Algorithm] Queue&amp;Stack</title>
    <link href="https://stardustorz.github.io/2025/07/25/Algorithm/Queue&amp;Stack/"/>
    <id>https://stardustorz.github.io/2025/07/25/Algorithm/Queue&amp;Stack/</id>
    <published>2025-07-25T10:10:13.000Z</published>
    <updated>2025-07-27T16:19:36.542Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="1-20-有效的括号"><a href="#1-20-有效的括号" class="headerlink" title="1 20. 有效的括号"></a>1 <a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>用栈实现。如果是左括号直接压入栈，如果遇到右括号则弹出一个，如果不匹配直接输出false，如果匹配则继续。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>( c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">cPop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; cPop != <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; cPop != <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; cPop != <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(b1 || b2 || b3)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-42-接雨水"><a href="#2-42-接雨水" class="headerlink" title="2 42. 接雨水"></a>2 <a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于某个位置 i，可以接的雨水是左侧最高和右侧最高的较小 减去当前高度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (height.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 数组充当备忘录</span></span><br><span class="line">        <span class="type">int</span>[] l_max = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] r_max = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 初始化 base case</span></span><br><span class="line">        l_max[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        r_max[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 从左向右计算 l_max 包括 i 位置在内</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            l_max[i] = Math.max(height[i], l_max[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 从右向左计算 r_max</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            r_max[i] = Math.max(height[i], r_max[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 计算答案</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">            res += Math.min(l_max[i], r_max[i]) - height[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l_max</span> <span class="operator">=</span> <span class="number">0</span>, r_max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        l_max = Math.max(l_max, height[left]);</span><br><span class="line">        r_max = Math.max(r_max, height[right]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// res += min(l_max, r_max) - height[i]</span></span><br><span class="line">        <span class="keyword">if</span> (l_max &lt; r_max) &#123;</span><br><span class="line">            res += l_max - height[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += r_max - height[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-11-盛最多水的容器"><a href="#3-11-盛最多水的容器" class="headerlink" title="3 11. 盛最多水的容器"></a>3 <a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h2><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// [left, right] 之间的矩形面积</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cur_area</span> <span class="operator">=</span> Math.min(height[left], height[right]) * (right - left);</span><br><span class="line">            res = Math.max(res, cur_area);</span><br><span class="line">            <span class="comment">// 双指针技巧，移动较低的一边</span></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-232-用栈实现队列"><a href="#4-232-用栈实现队列" class="headerlink" title="4 232. 用栈实现队列"></a>4 <a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h2><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><p>栈的顺序为后进先出，而队列的顺序为先进先出。使用两个栈实现队列，一个元素需要经过两个栈才能出队列，在经过第一个栈时元素顺序被反转，经过第二个栈时再次被反转，此时就是先进先出顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; in;</span><br><span class="line">    Stack&lt;Integer&gt; out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        in = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        out = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        in.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        in2out();</span><br><span class="line">        <span class="keyword">return</span> out.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        in2out();</span><br><span class="line">        <span class="keyword">return</span> out.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">in2out</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(out.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!in.isEmpty())&#123;</span><br><span class="line">                out.push(in.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> in.isEmpty() &amp;&amp; out.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-225-用队列实现栈"><a href="#5-225-用队列实现栈" class="headerlink" title="5 225. 用队列实现栈"></a>5 <a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h2><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p><p>在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        queue.add(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            queue.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-1047-删除字符串中的所有相邻重复项"><a href="#6-1047-删除字符串中的所有相邻重复项" class="headerlink" title="6 1047. 删除字符串中的所有相邻重复项"></a>6 <a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h2><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        Deque&lt;Character&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : cs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!d.isEmpty() &amp;&amp; d.peekLast().equals(c)) &#123;</span><br><span class="line">                d.pollLast();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                d.addLast(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (!d.isEmpty()) sb.append(d.pollLast());</span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-316-去除重复字母"><a href="#7-316-去除重复字母" class="headerlink" title="7 316. 去除重复字母"></a>7 <a href="https://leetcode.cn/problems/remove-duplicate-letters/">316. 去除重复字母</a></h2><p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p><p>要利用 stack 结构和一个 inStack 布尔数组来满足上述三个条件，具体思路如下：</p><p>通过 inStack 这个布尔数组做到栈 stk 中不存在重复元素，满足要求一。</p><p>我们顺序遍历字符串 s，通过「栈」这种顺序结构的 push/pop 操作记录结果字符串，保证了字符出现的顺序和 s 中出现的顺序一致，满足要求二。</p><p>我们用类似单调栈的思路，配合计数器 count 不断 pop 掉不符合最小字典序的字符，保证了最终得到的结果字典序最小，满足要求三。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicateLetters</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 维护一个计数器记录字符串中字符的数量</span></span><br><span class="line">        <span class="comment">// 因为输入为 ASCII 字符，大小 256 够用了</span></span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            count[s.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] inStack = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">// 每遍历过一个字符，都将对应的计数减一</span></span><br><span class="line">            count[c]--;</span><br><span class="line">            <span class="keyword">if</span> (inStack[c]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 如果当前栈顶的比 c 大，并且还有重复的，那就 pop 出来</span></span><br><span class="line">            <span class="keyword">while</span> (!stk.isEmpty() &amp;&amp; stk.peek() &gt; c) &#123;</span><br><span class="line">                <span class="comment">// 若之后不存在栈顶元素了，则停止 pop</span></span><br><span class="line">                <span class="keyword">if</span> (count[stk.peek()] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 若之后还有，则可以 pop</span></span><br><span class="line">                inStack[stk.pop()] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(c);</span><br><span class="line">            inStack[c] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">            sb.append(stk.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-155-最小栈"><a href="#8-155-最小栈" class="headerlink" title="8 155. 最小栈"></a>8 <a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></h2><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>两个栈：保持两个栈的大小相等。压栈时，一个压数据，另一个压目前入栈的最小值；而出栈时，一起弹出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; dataStack;</span><br><span class="line">    Stack&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        dataStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        dataStack.push(x);</span><br><span class="line">        min = Math.min(min,x);</span><br><span class="line">        minStack.push(min);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        dataStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">        <span class="keyword">if</span>(minStack.isEmpty()) min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">else</span> min = minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-496-下一个更大元素-I-单调栈"><a href="#9-496-下一个更大元素-I-单调栈" class="headerlink" title="9 496. 下一个更大元素 I 单调栈"></a>9 <a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a> 单调栈</h2><p>nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把 nums2 中每个元素的下一个更大元素算出来存到一个映射里</span></span><br><span class="line"><span class="comment">// 然后再让 nums1 中的元素去查表即可。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// 记录 nums2 中每个元素的下一个更大元素</span></span><br><span class="line">        <span class="type">int</span>[] greater = nextGreaterElement(nums2);</span><br><span class="line">        <span class="comment">// 转化成映射：元素 x -&gt; x 的下一个最大元素</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; greaterMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">            greaterMap.put(nums2[i], greater[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums1 是 nums2 的子集，所以根据 greaterMap 可以得到结果</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            res[i] = greaterMap.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 nums 中每个元素的下一个更大元素</span></span><br><span class="line">    <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 存放答案的数组</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 倒着往栈里放</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 判定个子高矮</span></span><br><span class="line">            <span class="keyword">while</span> (!s.isEmpty() &amp;&amp; s.peek() &lt;= nums[i]) &#123;</span><br><span class="line">                <span class="comment">// 矮个起开，反正也被挡着了。。。</span></span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// nums[i] 身后的下一个更大元素</span></span><br><span class="line">            res[i] = s.isEmpty() ? -<span class="number">1</span> : s.peek();</span><br><span class="line">            s.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-503-下一个更大元素-II-单调栈"><a href="#10-503-下一个更大元素-II-单调栈" class="headerlink" title="10 503. 下一个更大元素 II  单调栈"></a>10 <a href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II</a>  单调栈</h2><p>给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里需要迭代两遍，而且输出的是更大的数而不是距离。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElements(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>*n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[i%n] &gt; nums[stack.peek()])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                result[pre] = nums[i%n];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n)&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result[pre] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-739-每日温度-单调栈"><a href="#11-739-每日温度-单调栈" class="headerlink" title="11 739. 每日温度  单调栈"></a>11 <a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a>  单调栈</h2><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用单调栈维护一个递减序列, 从后往前进行遍历</span></span><br><span class="line"><span class="comment">// 若当前元素小于栈顶，那么栈顶就是下一个更高温度，</span></span><br><span class="line"><span class="comment">// 再将当前温度入栈,继续寻找下一个</span></span><br><span class="line"><span class="comment">// 若栈空后仍无法找到比当前元素高的温度则为0.</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="comment">// 这里放元素索引，而不是元素</span></span><br><span class="line">    Stack&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); </span><br><span class="line">    <span class="comment">// 倒着入栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 如果不是递减就出栈</span></span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty() &amp;&amp; temperatures[s.peek()] &lt;= temperatures[i]) &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到索引间距</span></span><br><span class="line">        res[i] = s.isEmpty() ? <span class="number">0</span> : (s.peek() - i); </span><br><span class="line">        <span class="comment">// 将索引入栈，而不是元素</span></span><br><span class="line">        s.push(i); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-402-移掉-K-位数字"><a href="#12-402-移掉-K-位数字" class="headerlink" title="12 402. 移掉 K 位数字"></a>12 <a href="https://leetcode.cn/problems/remove-k-digits/">402. 移掉 K 位数字</a></h2><p>给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择使用单调栈，使得剩下的数字是单调递增的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeKdigits</span><span class="params">(String num, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Deque&lt;Character&gt; stk = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : num.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.isEmpty() &amp;&amp; c &lt; stk.getLast() &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                stk.pollLast();</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.addLast(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> stk.stream().map(Object::toString).collect(Collectors.joining());</span><br><span class="line">        res = res.substring(<span class="number">0</span>, res.length() - k).replaceAll(<span class="string">&quot;^0+&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res.isEmpty() ? <span class="string">&quot;0&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-71-简化路径"><a href="#13-71-简化路径" class="headerlink" title="13 71. 简化路径"></a>13 <a href="https://leetcode.cn/problems/simplify-path/">71. 简化路径</a></h2><p>给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 ‘/‘ 开头），请你将其转化为更加简洁的规范路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simplifyPath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        String[] parts = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        Stack&lt;String&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 借助栈计算最终的文件夹路径</span></span><br><span class="line">        <span class="keyword">for</span> (String part : parts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (part.isEmpty() || part.equals(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (part.equals(<span class="string">&quot;..&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stk.isEmpty()) stk.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(part);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 栈中存储的文件夹组成路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stk.isEmpty()) &#123;</span><br><span class="line">            res = <span class="string">&quot;/&quot;</span> + stk.pop() + res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.isEmpty() ? <span class="string">&quot;/&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-394-字符串解码"><a href="#14-394-字符串解码" class="headerlink" title="14 394. 字符串解码"></a>14 <a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h2><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">构建辅助栈 stack， 遍历字符串 s 中每个字符 c；</span><br><span class="line">当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；</span><br><span class="line">当 c 为字母时，在 res 尾部添加 c；</span><br><span class="line">当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 <span class="number">00</span>：</span><br><span class="line">记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；</span><br><span class="line">记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。</span><br><span class="line">进入到新 [ 后，res 和 multi 重新记录。</span><br><span class="line">当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:</span><br><span class="line">last_res是上个 [ 到当前 [ 的字符串，例如 <span class="string">&quot;3[a2[c]]&quot;</span> 中的 a；</span><br><span class="line">cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 <span class="string">&quot;3[a2[c]]&quot;</span> 中的 <span class="number">2</span>。</span><br><span class="line">返回字符串 res。</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">multi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack_multi = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        LinkedList&lt;String&gt; stack_res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Character c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                stack_multi.addLast(multi);</span><br><span class="line">                stack_res.addLast(res.toString());</span><br><span class="line">                multi = <span class="number">0</span>;</span><br><span class="line">                res = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="type">int</span> <span class="variable">cur_multi</span> <span class="operator">=</span> stack_multi.removeLast();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cur_multi; i++) tmp.append(res);</span><br><span class="line">                res = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stack_res.removeLast() + tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) multi = multi * <span class="number">10</span> + Integer.parseInt(c + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> res.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-84-柱状图中最大的矩形"><a href="#15-84-柱状图中最大的矩形" class="headerlink" title="15 84. 柱状图中最大的矩形"></a>15 <a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h2><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><ul><li>遇到了当前柱形的高度比它上一个柱形的高度严格小的时候，一定可以确定它之前的某些柱形的最大宽度，并且确定的柱形宽度的顺序是从右边向左边。</li><li>这个现象告诉我们，在遍历的时候需要记录的信息就是遍历到的柱形的下标，它一左一右的两个柱形的下标的差就是这个面积最大的矩形对应的最大宽度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="comment">// 特殊情况判断</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] newHeights = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 在两端加上高度为 0 的两根柱子，避免出现栈到最后不为空</span></span><br><span class="line">        newHeights[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        System.arraycopy(heights, <span class="number">0</span>, newHeights, <span class="number">1</span>, len);</span><br><span class="line">        newHeights[len + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        len += <span class="number">2</span>;</span><br><span class="line">        heights = newHeights;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(len);</span><br><span class="line">        <span class="comment">// 先放入哨兵，在循环里就不用做非空判断</span></span><br><span class="line">        stack.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前的高度比之前的小，可以之前的高度对应的面积</span></span><br><span class="line">            <span class="keyword">while</span> (heights[i] &lt; heights[stack.peekLast()]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">curHeight</span> <span class="operator">=</span> heights[stack.pollLast()];</span><br><span class="line">                <span class="type">int</span> <span class="variable">curWidth</span> <span class="operator">=</span> i - stack.peekLast() - <span class="number">1</span>;</span><br><span class="line">                res = Math.max(res, curHeight * curWidth);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果高度继续增加，继续存对应的下标</span></span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// int[] heights = &#123;2, 1, 5, 6, 2, 3&#125;;</span></span><br><span class="line">        <span class="type">int</span>[] heights = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> solution.largestRectangleArea(heights);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-85-最大矩形-hard"><a href="#16-85-最大矩形-hard" class="headerlink" title="16 85. 最大矩形 hard"></a>16 <a href="https://leetcode.cn/problems/maximal-rectangle/">85. 最大矩形</a> hard</h2><p>给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历每行的高度,用上一题方法(栈)求出最大矩形!</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// row 行 col 列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] height = <span class="keyword">new</span> <span class="title class_">int</span>[col + <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col + <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="number">1</span> &amp;&amp; j &lt;= col) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[i][j-<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) height[j] += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> height[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[stack.peek()] &gt; height[j]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    res = Math.max(res, (j - stack.peek() - <span class="number">1</span>) * height[cur]);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-224-基本计算器"><a href="#17-224-基本计算器" class="headerlink" title="17 224. 基本计算器"></a>17 <a href="https://leetcode.cn/problems/basic-calculator/">224. 基本计算器</a></h2><p>s 由数字、 + 、 -、(  、 )、和 ‘   ‘ 组成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 存放所有的数字</span></span><br><span class="line">        Deque&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 为了防止第一个数为负数，先往 nums 加个 0</span></span><br><span class="line">        nums.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 将所有的空格去掉</span></span><br><span class="line">        s = s.replaceAll(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 存放所有的操作，包括 +/-</span></span><br><span class="line">        Deque&lt;Character&gt; ops = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="comment">// 主逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> cs[i];</span><br><span class="line">            <span class="comment">// 如果是左括号，放入 ops</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ops.addLast(c);</span><br><span class="line">        <span class="comment">// 如果是右括号，计算一轮，直到碰到左括号</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 计算到最近一个左括号为止</span></span><br><span class="line">                <span class="keyword">while</span> (!ops.isEmpty()) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">op</span> <span class="operator">=</span> ops.peekLast();</span><br><span class="line">                    <span class="keyword">if</span> (op != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        calc(nums, ops);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 左括号出栈</span></span><br><span class="line">                        ops.pollLast();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是数字，连续取出，入栈</span></span><br><span class="line">                <span class="keyword">if</span> (isNum(c)) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">                    <span class="comment">// 将从 i 位置开始后面的连续数字整体取出，加入 nums</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; n &amp;&amp; isNum(cs[j])) u = u * <span class="number">10</span> + (<span class="type">int</span>)(cs[j++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    nums.addLast(u);</span><br><span class="line">                    i = j - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果是操作符 入栈</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (cs[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> || cs[i - <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> || cs[i - <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">                        nums.addLast(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 有一个新操作要入栈时，先把栈内可以算的都算了</span></span><br><span class="line">                    <span class="keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="string">&#x27;(&#x27;</span>) calc(nums, ops);</span><br><span class="line">                    ops.addLast(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!ops.isEmpty()) calc(nums, ops);</span><br><span class="line">        <span class="keyword">return</span> nums.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">calc</span><span class="params">(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ops.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> nums.pollLast(), a = nums.pollLast();</span><br><span class="line">        <span class="type">char</span> <span class="variable">op</span> <span class="operator">=</span> ops.pollLast();</span><br><span class="line">        nums.addLast(op == <span class="string">&#x27;+&#x27;</span> ? a + b : a - b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断数字</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNum</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Character.isDigit(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-227-基本计算器-II"><a href="#18-227-基本计算器-II" class="headerlink" title="18 227. 基本计算器 II"></a>18 <a href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II</a></h2><p>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。</p><p>整数除法仅保留整数部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">对于「任何表达式」而言，我们都使用两个栈 nums 和 ops：</span><br><span class="line">nums ： 存放所有的数字</span><br><span class="line">ops ：存放所有的数字以外的操作</span><br><span class="line">然后从前往后做，对遍历到的字符做分情况讨论：</span><br><span class="line">空格 : 跳过</span><br><span class="line">( : 直接加入 ops 中，等待与之匹配的 )</span><br><span class="line">) : 使用现有的 nums 和 ops 进行计算，直到遇到左边最近的一个左括号为止，计算结果放到 nums</span><br><span class="line">数字 : 从当前位置开始继续往后取，将整一个连续数字整体取出，加入 nums</span><br><span class="line">+ - * / ^ % : 需要将操作放入 ops 中。在放入之前先把栈内可以算的都算掉（只有「栈内运算符」比「当前运算符」优先级高/同等，才进行运算），使用现有的 nums 和 ops 进行计算，</span><br><span class="line"></span><br><span class="line">    比如当前栈内是➕号，但是后面出现了比如 * ，那就不能先算 <span class="number">1</span>+<span class="number">2</span>*<span class="number">3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 map 维护一个运算符优先级</span></span><br><span class="line">    <span class="comment">// 这里的优先级划分按照「数学」进行划分即可</span></span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()&#123;&#123;</span><br><span class="line">        put(<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        put(<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        put(<span class="string">&#x27;%&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        put(<span class="string">&#x27;^&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 将所有的空格去掉</span></span><br><span class="line">        s = s.replaceAll(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 存放所有的数字</span></span><br><span class="line">        Deque&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 为了防止第一个数为负数，先往 nums 加个 0</span></span><br><span class="line">        nums.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 存放所有「非数字以外」的操作</span></span><br><span class="line">        Deque&lt;Character&gt; ops = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> cs[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ops.addLast(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 计算到最近一个左括号为止</span></span><br><span class="line">                <span class="keyword">while</span> (!ops.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ops.peekLast() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        calc(nums, ops);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ops.pollLast();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isNumber(c)) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">                    <span class="comment">// 将从 i 位置开始后面的连续数字整体取出，加入 nums</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; n &amp;&amp; isNumber(cs[j])) u = u * <span class="number">10</span> + (cs[j++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    nums.addLast(u);</span><br><span class="line">                    i = j - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (cs[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> || cs[i - <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> || cs[i - <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">                        nums.addLast(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 有一个新操作要入栈时，先把栈内可以算的都算了 </span></span><br><span class="line">                    <span class="comment">// 只有满足「栈内运算符」比「当前运算符」优先级高/同等，才进行运算</span></span><br><span class="line">                    <span class="keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        <span class="type">char</span> <span class="variable">prev</span> <span class="operator">=</span> ops.peekLast();</span><br><span class="line">                        <span class="comment">// 判断优先级</span></span><br><span class="line">                        <span class="keyword">if</span> (map.get(prev) &gt;= map.get(c)) &#123;</span><br><span class="line">                            calc(nums, ops);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ops.addLast(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将剩余的计算完</span></span><br><span class="line">        <span class="keyword">while</span> (!ops.isEmpty()) calc(nums, ops);</span><br><span class="line">        <span class="keyword">return</span> nums.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算逻辑</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">calc</span><span class="params">(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ops.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> nums.pollLast(), a = nums.pollLast();</span><br><span class="line">        <span class="type">char</span> <span class="variable">op</span> <span class="operator">=</span> ops.pollLast();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>) ans = a + b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;-&#x27;</span>) ans = a - b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;*&#x27;</span>) ans = a * b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;/&#x27;</span>)  ans = a / b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;^&#x27;</span>) ans = (<span class="type">int</span>)Math.pow(a, b);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;%&#x27;</span>) ans = a % b;</span><br><span class="line">        nums.addLast(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Character.isDigit(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-150-逆波兰表达式求值"><a href="#19-150-逆波兰表达式求值" class="headerlink" title="19 150. 逆波兰表达式求值"></a>19 <a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h2><p>根据 逆波兰表示法，求表达式的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;+-*/&quot;</span>.contains(token)) &#123;</span><br><span class="line">                <span class="comment">// 是个运算符，从栈顶拿出两个数字进行运算，运算结果入栈</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> stk.pop(), b = stk.pop();</span><br><span class="line">                <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                        stk.push(a + b);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                        stk.push(a * b);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 对于减法和除法，顺序别搞反了，第二个数是被除（减）数</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                        stk.push(b - a);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                        stk.push(b / a);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 是个数字，直接入栈即可</span></span><br><span class="line">                stk.push(Integer.parseInt(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后栈中剩下一个数字，即是计算结果</span></span><br><span class="line">        <span class="keyword">return</span> stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-面试题59-II-队列的最大值"><a href="#20-面试题59-II-队列的最大值" class="headerlink" title="20 面试题59 - II. 队列的最大值"></a>20 <a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/">面试题59 - II. 队列的最大值</a></h2><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建一个递减列表来保存队列 所有递减的元素 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    Deque&lt;Integer&gt; deque;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max_value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deque.isEmpty() ? -<span class="number">1</span> : deque.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        queue.offer(value);</span><br><span class="line">        <span class="comment">// 如果入队的比当前最小的大，不停弹出，知道有序</span></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; value)</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        deque.offerLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop_front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(queue.peek().equals(deque.peekFirst()))</span><br><span class="line">            deque.pollFirst();</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21-946-验证栈序列"><a href="#21-946-验证栈序列" class="headerlink" title="21 946. 验证栈序列"></a>21 <a href="https://leetcode.cn/problems/validate-stack-sequences/">946. 验证栈序列</a></h2><p>给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。</p><ul><li>根据题意，利用元素各不相同，我们使用一个栈来处理 pushed 数组，每次将 pushed[i] 放入栈中，然后比较当前栈顶元素是否与待弹出元素相同（使用变量 j 来代指当前待弹出元素下标），若相等则弹栈并进行 j 自增，当所有的元素处理完后，栈为空说明栈序列合法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; pushed.length; i++) &#123;</span><br><span class="line">            d.addLast(pushed[i]);</span><br><span class="line">            <span class="keyword">while</span> (!d.isEmpty() &amp;&amp; d.peekLast() == popped[j] &amp;&amp; ++j &gt;= <span class="number">0</span>) d.pollLast(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;1-20-有效的括号&quot;&gt;&lt;a href=&quot;#1-20-有效的括号&quot; class=&quot;headerlink&quot; title=&quot;1 20. 有效的括号&quot;&gt;&lt;/a&gt;1 &lt;a href=&quot;https://leetcode.cn/</summary>
      
    
    
    
    
    <category term="Algorithm" scheme="https://stardustorz.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>[Algorithm] Binary Search</title>
    <link href="https://stardustorz.github.io/2025/07/25/Algorithm/Binary%20Search/"/>
    <id>https://stardustorz.github.io/2025/07/25/Algorithm/Binary%20Search/</id>
    <published>2025-07-25T10:10:13.000Z</published>
    <updated>2025-07-27T16:20:56.908Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><p>二分查找就是不断缩小搜索区间的过程，要注意到区间内的元素不能遗漏</p><h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1 时间复杂度"></a>1 时间复杂度</h2><p>二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。</p><h2 id="2-二分查找框架"><a href="#2-二分查找框架" class="headerlink" title="2 二分查找框架"></a>2 二分查找框架</h2><p>注意循环不变量</p><h4 id="2-1-1-第一种："><a href="#2-1-1-第一种：" class="headerlink" title="2.1.1 第一种："></a>2.1.1 第一种：</h4><p>如果定义在一个左闭右闭的区间里，也就是[left,right];<br>循环结束条件： left &gt; right</p><p>[left, middle - 1]    [middle + 1, right]</p><p>right = mid - 1</p><p>left = mid + 1</p><h4 id="2-1-2-第二种：在一个在左闭右开的区间里，也就是-left-right"><a href="#2-1-2-第二种：在一个在左闭右开的区间里，也就是-left-right" class="headerlink" title="2.1.2 第二种：在一个在左闭右开的区间里，也就是[left, right)"></a>2.1.2 第二种：在一个在左闭右开的区间里，也就是[left, right)</h4><p>循环结束条件： left &lt; right</p><p>[left, middle)    [middle+1, right)</p><p>right  = mid</p><p>left = mid + 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;  <span class="comment">//防止直接相加出现溢出的情况</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-寻找一个数"><a href="#3-寻找一个数" class="headerlink" title="3 寻找一个数"></a>3 寻找一个数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; </span><br><span class="line">    <span class="comment">//循环跳出时，left = right + 1，搜索区间为[right+1,right],也就是说right取到了，right+1没有取到</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;   <span class="comment">//因为right是可以取到的，所以要有=号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">//因为mid是判断过的，所以可以跳过</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-寻找左侧边界的二分搜索"><a href="#4-寻找左侧边界的二分搜索" class="headerlink" title="4 寻找左侧边界的二分搜索"></a>4 寻找左侧边界的二分搜索</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length; <span class="comment">// 右侧是取不到的，[left,right)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 中止时left==right，但是不是闭区间，可以跳出</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;  </span><br><span class="line">            right = mid;<span class="comment">//找到target后，缩小上界，不断向左收缩</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;  <span class="comment">//[left,mid) [mid+1,right)</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果找不到目标值</span></span><br><span class="line"><span class="comment">// target 比所有数都大</span></span><br><span class="line"><span class="keyword">if</span> (left == nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="5-寻找右侧边界的二分搜索"><a href="#5-寻找右侧边界的二分搜索" class="headerlink" title="5 寻找右侧边界的二分搜索"></a>5 寻找右侧边界的二分搜索</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;  <span class="comment">//[left,right)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;<span class="comment">//[left,mid) [mid+1,right),因为mid已经判断过，所以跳过</span></span><br><span class="line">            left = mid + <span class="number">1</span>;   <span class="comment">//如果找到，缩小下界，同时向右收缩</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;<span class="comment">//[left,mid) [mid+1,right)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>; <span class="comment">//因为更新的是left = mid + 1，所以 mid = left - 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-逻辑统一"><a href="#6-逻辑统一" class="headerlink" title="6 逻辑统一"></a>6 逻辑统一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本二分</span></span><br><span class="line">因为我们初始化 right = nums.length - <span class="number">1</span></span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right]</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">同时也决定了 left = mid+<span class="number">1</span> 和 right = mid-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">因为我们只需找到一个 target 的索引即可</span><br><span class="line">所以当 nums[mid] == target 时可以立即返回</span><br><span class="line">    </span><br><span class="line"><span class="comment">//左侧边界</span></span><br><span class="line">因为我们初始化 right = nums.length</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + <span class="number">1</span> 和 right = mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最左侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧右侧边界以锁定左侧边界</span><br><span class="line"></span><br><span class="line"><span class="comment">//右侧边界</span></span><br><span class="line">因为我们初始化 right = nums.length</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + <span class="number">1</span> 和 right = mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最右侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧左侧边界以锁定右侧边界</span><br><span class="line"></span><br><span class="line">又因为收紧左侧边界时必须 left = mid + <span class="number">1</span></span><br><span class="line">所以最后无论返回 left 还是 right，必须减一                 </span><br></pre></td></tr></table></figure><h3 id="6-1-合并为闭区间"><a href="#6-1-合并为闭区间" class="headerlink" title="6.1 合并为闭区间"></a>6.1 合并为闭区间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接返回</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定左侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后要检查 left 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定右侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后要检查 right 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-例题"><a href="#7-例题" class="headerlink" title="7 例题"></a>7 例题</h2><h3 id="7-1-69-x-的平方根"><a href="#7-1-69-x-的平方根" class="headerlink" title="7.1 69. x 的平方根"></a>7.1 <a href="https://leetcode-cn.com/problems/sqrtx/">69. x 的平方根</a></h3><p>实现 <code>int sqrt(int x)</code> 函数。</p><p>计算并返回 <em>x</em> 的平方根，其中 <em>x</em> 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在left &lt;= right的情况下，结束时 left = right + 1</span></span><br><span class="line"><span class="comment">//需要的是小的那个</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = x;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sqrt</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(sqrt == x/sqrt)&#123;</span><br><span class="line">                <span class="keyword">return</span> sqrt;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sqrt &gt; x/sqrt)&#123;</span><br><span class="line">                right = sqrt - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sqrt &lt; x/sqrt)&#123;</span><br><span class="line">                left = sqrt + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-744-寻找比目标字母大的最小字母"><a href="#7-2-744-寻找比目标字母大的最小字母" class="headerlink" title="7.2 744. 寻找比目标字母大的最小字母"></a>7.2 <a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">744. 寻找比目标字母大的最小字母</a></h3><p>给你一个排序后的字符列表 <code>letters</code> ，列表中只包含小写英文字母。另给出一个目标字母 <code>target</code>，请你寻找在这一有序列表里比目标字母大的最小字母。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">nextGreatestLetter</span><span class="params">(<span class="type">char</span>[] letters, <span class="type">char</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> letters.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span> ,high = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[mid] &lt;= target)&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(low &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span> letters[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> letters[low];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-540-有序数组中的单一元素"><a href="#7-3-540-有序数组中的单一元素" class="headerlink" title="7.3 540. 有序数组中的单一元素"></a>7.3 <a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">540. 有序数组中的单一元素</a></h3><p>给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果前面不包含单个的，那么偶数位置的数肯定是和后面一个相等</span></span><br><span class="line"><span class="comment">//如果相等，说明在后面 left = mid + 2</span></span><br><span class="line"><span class="comment">//如果不相等，说明在前面，right = mid</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNonDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//保证m是偶数</span></span><br><span class="line">            <span class="keyword">if</span>(mid % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                mid--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == nums[mid + <span class="number">1</span>])&#123;</span><br><span class="line">                left = mid + <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-278-第一个错误的版本"><a href="#7-4-278-第一个错误的版本" class="headerlink" title="7.4 278. 第一个错误的版本"></a>7.4 <a href="https://leetcode-cn.com/problems/first-bad-version/">278. 第一个错误的版本</a></h3><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">VersionControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>,right = n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid) == <span class="literal">false</span>)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-153-寻找旋转排序数组中的最小值"><a href="#7-5-153-寻找旋转排序数组中的最小值" class="headerlink" title="7.5 153. 寻找旋转排序数组中的最小值"></a>7.5 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。</p><p>请找出其中最小的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;<span class="comment">//左闭右闭区间，如果用右开区间则不方便判断右值 </span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;<span class="comment">//循环不变式，如果left == right，则循环结束 </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;<span class="comment">//地板除，mid更靠近left</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;<span class="comment">//中值 &gt; 右值，最小值在右半边，收缩左边界</span></span><br><span class="line">                left = mid + <span class="number">1</span>;<span class="comment">//因为中值 &gt; 右值，中值肯定不是最小值，左边界可以跨过mid </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;<span class="comment">//明确中值 &lt; 右值，最小值在左半边，收缩右边界 */ </span></span><br><span class="line">                right = mid;<span class="comment">//因为中值 &lt; 右值，中值也可能是最小值，右边界只能取到mid处 */ </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];<span class="comment">//循环结束，left == right，最小值输出nums[left]或nums[right]均可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-6-34-在排序数组中查找元素的第一个和最后一个位置"><a href="#7-6-34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="7.6 34. 在排序数组中查找元素的第一个和最后一个位置"></a>7.6 <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h3><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//寻找target的最左侧边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> binarySearch(nums,target);</span><br><span class="line">        <span class="comment">//寻找target+1的最左侧边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> binarySearch(nums,target+<span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(start == nums.length || nums[start] != target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start,Math.max(start,end)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//寻找左侧边界</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;p&gt;二分查找就是不断缩小搜索区间的过程，要注意到区间内的元素不能遗漏&lt;/p&gt;
&lt;h2 id=&quot;1-时间复杂度&quot;&gt;&lt;a href=&quot;#1-时间复杂度&quot; class=&quot;headerlink&quot; title=&quot;1 时间复杂度&quot;&gt;&lt;/a&gt;1</summary>
      
    
    
    
    
    <category term="Algorithm" scheme="https://stardustorz.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>[Algorithm] LinkedList</title>
    <link href="https://stardustorz.github.io/2025/07/25/Algorithm/LinkedList/"/>
    <id>https://stardustorz.github.io/2025/07/25/Algorithm/LinkedList/</id>
    <published>2025-07-25T10:10:13.000Z</published>
    <updated>2025-08-03T14:28:34.588Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    SinglyListNode next;</span><br><span class="line">    SinglyListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-206-反转链表"><a href="#1-206-反转链表" class="headerlink" title="1 206. 反转链表 *"></a>1 <a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a> *</h2><p>题目：反转一个单链表</p><p>1.双指针迭代</p><p>从前向后反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// cur 是当前需要翻转的节点</span></span><br><span class="line">        <span class="comment">// pre 是 cur 的前一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head, pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录 cur 的下一个节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后 cur 是 null, pre 是新链表的 head</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.递归</p><p>从后往前反转</p><p>终止条件是当前节点或者下一个节点==null<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"><span class="comment">//递归终止条件是当前为空，或者下一个节点为空</span></span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// cur 从头到尾是不变的 都是指向最后递归结束时的</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">head.next.next = head;</span><br><span class="line"><span class="comment">//防止链表循环，需要将head.next设置为空</span></span><br><span class="line">head.next = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//每层递归函数都返回cur，也就是最后一个节点</span></span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverseList(<span class="number">5</span>) 中 head=<span class="number">5</span>，head.next=<span class="literal">null</span>，返回head=<span class="number">5</span></span><br><span class="line">reverseList(<span class="number">4</span>) cur = <span class="number">5</span>，head=<span class="number">4</span>，head.next=<span class="number">5</span></span><br><span class="line">reverseList(<span class="number">3</span>)</span><br><span class="line">reverseList(<span class="number">2</span>)</span><br><span class="line">reverseList(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><h2 id="2-92-反转链表-II"><a href="#2-92-反转链表-II" class="headerlink" title="2 92. 反转链表 II  *"></a>2 <a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a>  *</h2><p>题目：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line">时间复杂度：O(n)</span><br><span class="line">空间复杂度：O(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录第 N+1 个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">mark</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归到变成翻转前n 个节点</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> reverseN(head, right);</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = reverseBetween(head.next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归翻转从 root 开始,长度为 n 的链表</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverseN</span><span class="params">(ListNode root, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// basecase,只有一个节点,也就是第 n 个,返回它本身</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// mark 记录第 n 加一个,避免断链</span></span><br><span class="line">            mark = root.next;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reverseN(root.next, n - <span class="number">1</span>);</span><br><span class="line">        root.next.next = root;</span><br><span class="line">        <span class="comment">// root 是翻转后的最后一个,连上后面</span></span><br><span class="line">        root.next = mark;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代实现,头插法</span></span><br><span class="line">时间复杂度：O(n)</span><br><span class="line">空间复杂度：O(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要翻转的节点数</span></span><br><span class="line">        right = right - left;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// 移动到 left 左侧</span></span><br><span class="line">        <span class="keyword">while</span> (left-- &gt; <span class="number">1</span>) cur = cur.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> cur.next, b = a.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将中间的链表翻转,此时 cur 在前一段最后,a 在第一段最后,b 在最后一段开始</span></span><br><span class="line">        <span class="keyword">while</span> (right-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> b.next;</span><br><span class="line">            b.next = a;</span><br><span class="line">            a = b;</span><br><span class="line">            b = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将第二段开头连上第三段开头</span></span><br><span class="line">        cur.next.next = b;</span><br><span class="line">        <span class="comment">// 第一段末尾连上第二段末尾</span></span><br><span class="line">        cur.next = a;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-25-K-个一组翻转链表-important"><a href="#3-25-K-个一组翻转链表-important" class="headerlink" title="3 25. K 个一组翻转链表 important"></a>3 <a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a> important</h2><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//哑节点辅助反转</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyNode.next = head;</span><br><span class="line">        <span class="comment">//将从pre的下一个节点开始反转</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="comment">//当前已经反转完成的位置</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//需要进行反转的节点</span></span><br><span class="line">        ListNode next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//需要翻转len/k组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len/k; i++)&#123;</span><br><span class="line">            <span class="comment">//每组需要将k-1个节点头插法到pre后面</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; k-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                next = cur.next;</span><br><span class="line">                cur.next = next.next;</span><br><span class="line">                next.next = pre.next;</span><br><span class="line">                pre.next = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//一组反转完成后，重置pre和cur位置</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 区间 [a, b) 包含 k 个待反转元素</span></span><br><span class="line">        ListNode a, b;</span><br><span class="line">        a = b = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">// 不足 k 个，不需要反转，base case</span></span><br><span class="line">            <span class="keyword">if</span> (b == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">            b = b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 反转前 k 个元素</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverse(a, b);</span><br><span class="line">        <span class="comment">// 递归反转后续链表并连接起来</span></span><br><span class="line">        a.next = reverseKGroup(b, k);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 反转区间 [a, b) 的元素，注意是左闭右开 */</span></span><br><span class="line">    ListNode <span class="title function_">reverse</span><span class="params">(ListNode a, ListNode b)</span> &#123;</span><br><span class="line">        ListNode pre, cur, nxt;</span><br><span class="line">        pre = <span class="literal">null</span>;</span><br><span class="line">        cur = a;</span><br><span class="line">        nxt = a;</span><br><span class="line">        <span class="comment">// while 终止的条件改一下就行了</span></span><br><span class="line">        <span class="keyword">while</span> (cur != b) &#123;</span><br><span class="line">            nxt = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回反转后的头结点</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-83-删除排序链表中的重复元素"><a href="#4-83-删除排序链表中的重复元素" class="headerlink" title="4 83. 删除排序链表中的重复元素"></a>4 <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h2><p>题目：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>思路：从头到尾遍历，将结点的值与后面 的结点值比较，如果重复就跳过下一个结点指向之后的结点。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.next.val == current.val) &#123;</span><br><span class="line">            current.next = current.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-82-删除排序链表中的重复元素-II"><a href="#5-82-删除排序链表中的重复元素-II" class="headerlink" title="5 82. 删除排序链表中的重复元素 II"></a>5 <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h2><p>题目：给定一个排序链表，删除所有重复的元素，只保留没有重复出现的结点。</p><p>思路：<br>1.头节点也可能要删除，增加一个哑结点<br>2.双指针a，b；a指向dummy，b指向head，如果a.next！=b.next 那么ab都往前，如果相等则只移动b到不等为止，然后a.next=b.next;b=b.next</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">b</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(b!=<span class="literal">null</span> &amp;&amp; b.next!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//初始化的时a指向的是哑结点，所以比较逻辑应该是a的下一个节点和b的下一个节点</span></span><br><span class="line">            <span class="keyword">if</span>(a.next.val!=b.next.val) &#123;</span><br><span class="line">                a = a.next;</span><br><span class="line">                b = b.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果a、b指向的节点值相等，就不断移动b，直到a、b指向的值不相等 </span></span><br><span class="line">                <span class="keyword">while</span>(b!=<span class="literal">null</span> &amp;&amp; b.next!=<span class="literal">null</span> &amp;&amp; a.next.val==b.next.val) &#123;</span><br><span class="line">                    b = b.next;</span><br><span class="line">                &#125;</span><br><span class="line">                a.next = b.next;</span><br><span class="line">                b = b.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6 从尾到头打印链表"></a>6 从尾到头打印链表</h2><p>题目：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p><p>思路：<br>1.递归</p><p>每层递归将值加入结果数组</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        recur(head);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[temp.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; res.length;i++)</span><br><span class="line">            res[i] = temp.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recur(head.next);</span><br><span class="line">    temp.add(head.val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.辅助栈</p><p>遍历链表，将结点值入栈，遍历完成后将栈中元素存入数组，实现倒序输出</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="type">Deque</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">           stack.add(head.val);</span><br><span class="line">           head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; res.length ;i++)&#123;</span><br><span class="line">            res[i] = stack.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-链表中的倒数第K个节点"><a href="#7-链表中的倒数第K个节点" class="headerlink" title="7 链表中的倒数第K个节点 *"></a>7 链表中的倒数第K个节点 *</h2><p>题目：输入一个链表，输出该链表中倒数第k个结点。</p><p>思路：双指针法，一个先走k步，另一个也开始走，直到</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;    </span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">b</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k ;i++)&#123;</span><br><span class="line">        b = b.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="literal">null</span>)&#123;</span><br><span class="line">        a = a.next;</span><br><span class="line">        b = b.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-19-删除链表的倒数第-N-个结点"><a href="#8-19-删除链表的倒数第-N-个结点" class="headerlink" title="8 19. 删除链表的倒数第 N 个结点"></a>8 <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目:给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 采用两个间隔为n的指针，同时向前移动。当快指针的下一个节点为最后一个节点时，要删除的节点就是慢指针的下一个节点。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 只有一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">        <span class="comment">// fast 先走 n 步,然后一起到最后,slow 指向删除的前一个位置</span></span><br><span class="line">        <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>) fast = fast.next;</span><br><span class="line">      <span class="comment">// 边界:如果有 n 个节点,删倒数第 n 个,也就是头结点</span></span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">null</span>) <span class="keyword">return</span> head.next;</span><br><span class="line">      <span class="comment">// 直到 fast 指向末尾,slow 指向待删除的前一个</span></span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-复杂链表的复制"><a href="#9-复杂链表的复制" class="headerlink" title="9 复杂链表的复制"></a>9 复杂链表的复制</h2><p>题目：请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><p>思路：先在原链路中复制，然后建立random连接，最后拆分</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; <span class="comment">//HashMap实现</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">//创建HashMap集合</span></span><br><span class="line">        Node cur=head;</span><br><span class="line">        <span class="comment">//复制结点值</span></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//存储put:</span></span><br><span class="line">            map.put(cur,<span class="keyword">new</span> <span class="title class_">Node</span>(cur.val)); <span class="comment">//顺序遍历，存储老结点和新结点(先存储新创建的结点值)</span></span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//复制结点指向</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//得到get:.value2,3</span></span><br><span class="line">            map.get(cur).next = map.get(cur.next); <span class="comment">//新结点next指向同旧结点的next指向</span></span><br><span class="line">            map.get(cur).random = map.get(cur.random); <span class="comment">//新结点random指向同旧结点的random指向</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;   </span><br><span class="line"><span class="comment">//返回复制的链表</span></span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-两个链表的第一个公共节点"><a href="#10-两个链表的第一个公共节点" class="headerlink" title="10 两个链表的第一个公共节点"></a>10 两个链表的第一个公共节点</h2><p>题目：输入两个链表，找出它们的第一个公共节点。</p><p>思路：两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。</p><p>这样，当它们相遇时，所指向的结点就是第一个公共结点。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nodeA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nodeB</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="keyword">while</span>(nodeA!=nodeB)&#123;</span><br><span class="line">            nodeA = nodeA==<span class="literal">null</span>?headB:nodeA.next;</span><br><span class="line">            nodeB = nodeB==<span class="literal">null</span>?headA:nodeB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodeA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-环型链表"><a href="#11-环型链表" class="headerlink" title="11 环型链表"></a>11 环型链表</h2><p>题目：给定一个链表，判断链表中是否有环。</p><p>思路：快慢指针</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">low</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span>( fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(low.equals(fast) )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            low = low.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="12-链表中环的入口结点"><a href="#12-链表中环的入口结点" class="headerlink" title="12 链表中环的入口结点"></a>12 <a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&amp;tqId=11208&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">链表中环的入口结点</a></h2><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/submissions/">https://leetcode-cn.com/problems/linked-list-cycle-ii/submissions/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快慢指针</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> &#123;</span><br><span class="line">    <span class="comment">// 设计双指针， 1. 边界都要判断下一个结点也是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="literal">null</span> || pHead.next == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> pHead, fast = pHead;</span><br><span class="line">    <span class="comment">// 2. 快以二倍速前进，慢正常操作</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slow != fast); <span class="comment">// 3. 相遇点</span></span><br><span class="line">    <span class="comment">// 4. fast从头继续和slow正常走</span></span><br><span class="line">    fast = pHead;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123; </span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 返回slow，毕竟二者走在一块</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-2-两数相加"><a href="#13-2-两数相加" class="headerlink" title="13 2. 两数相加  *"></a>13 <a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a>  *</h2><p>题目:给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>思路:用一个虚拟头结点 逐位相加,考虑进位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逐位相加,考虑进位</span></span><br><span class="line"><span class="comment">// 复杂度 时间:O(max(m,n));  空间:O(max(m,n))</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> l1 != <span class="literal">null</span> ? l1.val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> l2 != <span class="literal">null</span> ? l2.val : <span class="number">0</span>;</span><br><span class="line">            carry = a + b + carry;</span><br><span class="line">            temp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry % <span class="number">10</span>);</span><br><span class="line">            carry /= <span class="number">10</span>;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="literal">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">null</span>) l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>) temp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-445-两数相加-II"><a href="#14-445-两数相加-II" class="headerlink" title="14 445. 两数相加 II"></a>14 <a href="https://leetcode-cn.com/problems/add-two-numbers-ii/">445. 两数相加 II</a></h2><p>题目：给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>思路：两辅助栈</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack1.push(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack2.push(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">//标记是否进位</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>( !stack1.isEmpty() || !stack2.isEmpty() || carry!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> carry;</span><br><span class="line">            sum += stack1.isEmpty() ? <span class="number">0</span> : stack1.pop();</span><br><span class="line">            sum += stack2.isEmpty() ? <span class="number">0</span> : stack2.pop();</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">            node.next = head1.next;<span class="comment">//头插法</span></span><br><span class="line">            head1.next = node;</span><br><span class="line">            carry = sum/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-328-奇偶链表"><a href="#15-328-奇偶链表" class="headerlink" title="15 328. 奇偶链表"></a>15 <a href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a></h2><p>题目：给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>思路：三个指针，两个排序，一个标记偶数链表的头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">oddEvenList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">odd</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">even</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">evenHead</span> <span class="operator">=</span> even;</span><br><span class="line">        <span class="keyword">while</span>(even!= <span class="literal">null</span> &amp;&amp; even.next!= <span class="literal">null</span>)&#123;<span class="comment">//偶数在后面，如果偶数有，那么奇数也有</span></span><br><span class="line">            odd.next = odd.next.next;</span><br><span class="line">            odd = odd.next;</span><br><span class="line">            even.next = even.next.next;</span><br><span class="line">            even = even.next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd.next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-725-分隔链表"><a href="#16-725-分隔链表" class="headerlink" title="16 725. 分隔链表"></a>16 <a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">725. 分隔链表</a></h2><p>给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。</p><p>每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。</p><p>这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。</p><p>返回一个符合上述规则的链表的列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//链表长度</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            N++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每个部分的基础长度和余数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> N/k;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> N%k;</span><br><span class="line">        cur = root;</span><br><span class="line">        ListNode[] res = <span class="keyword">new</span> <span class="title class_">ListNode</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; cur != <span class="literal">null</span> &amp;&amp; i &lt; k ; i++)&#123;</span><br><span class="line">            <span class="comment">//表头加入</span></span><br><span class="line">            res[i] = cur;</span><br><span class="line">            <span class="comment">//当前的大小取决于基础大小和是否还有余数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">curSize</span> <span class="operator">=</span> size + (mod-- &gt; <span class="number">0</span> ? <span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//需要得到Cursize规模的链表，需要走Cursize - 1步</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; curSize - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//记录下下一个节点，断开链表</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = <span class="literal">null</span>;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-21-合并两个有序链表"><a href="#17-21-合并两个有序链表" class="headerlink" title="17 21. 合并两个有序链表 *"></a>17 <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a> *</h2><p>题目：将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p>递归解法：</p><p>终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束</p><p>返回值：每一层调用都返回排序好的链表头</p><p>本级递归内容：如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归  时间 O(n+m)  空间 O(n+m)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 迭代  时间 O(n+m)  空间 O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val)&#123;</span><br><span class="line">                pre.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = l1 == <span class="literal">null</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-23-合并K个升序链表"><a href="#18-23-合并K个升序链表" class="headerlink" title="18 23. 合并K个升序链表 *"></a>18 <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a> *</h2><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小堆</span></span><br><span class="line"><span class="comment">// 时间: O(kn×logk)  k 个链表,kn 个点</span></span><br><span class="line"><span class="comment">// 空间: O(k)</span></span><br><span class="line"><span class="comment">// 堆排序,使用大顶堆可以得到升序的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="comment">// 哨兵节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), tail = dummy;</span><br><span class="line">        <span class="comment">//优先队列，每次出堆的都是最小的  小顶堆,输出根节点</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a.val - b.val);</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        <span class="keyword">for</span>(ListNode node : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>) q.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">            tail.next = q.poll();</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            <span class="keyword">if</span>(tail.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.add(tail.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分治实现</span></span><br><span class="line"><span class="comment">// 时间 O(kn×logk)</span></span><br><span class="line"><span class="comment">// 空间 O(logk)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lists == <span class="literal">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//分治实现两两合并</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode[] lists, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span> lists[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> merge(lists, left, mid);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> merge(lists, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//合并两个有序</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-234-回文链表-important"><a href="#19-234-回文链表-important" class="headerlink" title="19 234. 回文链表 important"></a>19 <a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a> important</h2><p>请判断一个链表是否为回文链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//只有一个或者两个</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head,fast = head.next;</span><br><span class="line">        <span class="comment">//找出中点</span></span><br><span class="line">        <span class="keyword">while</span>(fast!= <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//考虑只有两个元素的情况</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="literal">null</span>) slow = slow.next;</span><br><span class="line">        cut(head,slow);</span><br><span class="line">        <span class="keyword">return</span> isequal(head,reverse(slow));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//断开链表，断在slow前</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">(ListNode head,ListNode slow)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head.next != slow)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转链表</span></span><br><span class="line">    <span class="keyword">private</span>  ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reverse(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否相等</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isequal</span><span class="params">(ListNode l1,ListNode l2)</span>&#123;</span><br><span class="line">        <span class="comment">//忽略奇数个节点情况</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val != l2.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                l2 = l2.next;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-86-分隔链表-important"><a href="#20-86-分隔链表-important" class="headerlink" title="20 86. 分隔链表  important"></a>20 <a href="https://leetcode-cn.com/problems/partition-list/">86. 分隔链表</a>  important</h2><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p><p>你应当 保留 两个分区中每个节点的初始相对位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> dummy1, node2 = dummy2;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val &lt; x)&#123;</span><br><span class="line">                node1.next = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">                <span class="comment">//断开与主链表的联系</span></span><br><span class="line">                node1.next = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node2.next = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">                node2.next = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node1.next = dummy2.next;</span><br><span class="line">        <span class="keyword">return</span> dummy1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21-剑指46-圆圈中最后剩下的数"><a href="#21-剑指46-圆圈中最后剩下的数" class="headerlink" title="21 剑指46.圆圈中最后剩下的数"></a>21 剑指46.圆圈中最后剩下的数</h2><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) </p><p>如果没有小朋友，请返回-1 </p><p>思路：</p><p>使用List模拟，使用一个指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">LastRemaining_Solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || m == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) list.add(i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(list.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">                cur++;</span><br><span class="line">                <span class="keyword">if</span>(cur == list.size()) cur = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.remove(cur);</span><br><span class="line">            <span class="comment">//删除节点时，cur会指向下一个节点，因此需要减1。</span></span><br><span class="line">            cur--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22-853-链表的中间结点-important"><a href="#22-853-链表的中间结点-important" class="headerlink" title="22 853.链表的中间结点  important"></a>22 853.链表的中间结点  important</h2><p><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">https://leetcode-cn.com/problems/middle-of-the-linked-list/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双指针（快慢）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head, q = head;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="literal">null</span> &amp;&amp; q.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            q = q.next.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-24-两两交换链表中的节点"><a href="#23-24-两两交换链表中的节点" class="headerlink" title="23 24. 两两交换链表中的节点 *"></a>23 <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a> *</h2><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="comment">// temp -&gt; start -&gt; end</span></span><br><span class="line">        <span class="comment">// temp 是要交换的两个的前一个</span></span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="literal">null</span> &amp;&amp; temp.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> temp.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> temp.next.next;</span><br><span class="line">            temp.next = end;</span><br><span class="line">            start.next = end.next;</span><br><span class="line">            end.next = start;</span><br><span class="line">            <span class="comment">// 交换完成,此时 start 后面是需要交换的</span></span><br><span class="line">            temp = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 递归解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前无节点或者只有一个节点，无法进行交换</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// head -&gt; next -&gt; (next.next)</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = swapPairs(next.next);</span><br><span class="line">        next.next = head;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="24-奇数位升序偶数位降序的链表-important"><a href="#24-奇数位升序偶数位降序的链表-important" class="headerlink" title="24 奇数位升序偶数位降序的链表  important"></a>24 奇数位升序偶数位降序的链表  important</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">oddEvenLinkedList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 将偶数链表拆分出来</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">evenHead</span> <span class="operator">=</span> getEvenList(head);</span><br><span class="line">    <span class="comment">// 逆序偶数链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">reEvenHead</span> <span class="operator">=</span> reverseList(evenHead);</span><br><span class="line">    <span class="comment">// 归并奇偶链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">mHead</span> <span class="operator">=</span> mergeList(head, reEvenHead);</span><br><span class="line">    <span class="keyword">return</span> mHead;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">getEvenList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">evenHead</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取next</span></span><br><span class="line">        next = cur.next;</span><br><span class="line">        <span class="comment">// cur奇数，-&gt; next.next (奇数)</span></span><br><span class="line">        cur.next = next.next;</span><br><span class="line">        <span class="comment">// 移动</span></span><br><span class="line">        cur = cur.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始偶数</span></span><br><span class="line">        next.next = cur.next;</span><br><span class="line">        <span class="comment">// 移动</span></span><br><span class="line">        next = next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> evenHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">mergeList</span><span class="params">(ListNode l1, ListNode l2)</span>&#123;</span><br><span class="line">    <span class="comment">// 我用递归</span></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeList(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeList(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    
    <category term="Algorithm" scheme="https://stardustorz.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>[Algorithm] Sort</title>
    <link href="https://stardustorz.github.io/2025/07/25/Algorithm/Sort/"/>
    <id>https://stardustorz.github.io/2025/07/25/Algorithm/Sort/</id>
    <published>2025-07-25T10:10:13.000Z</published>
    <updated>2025-07-25T10:10:13.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="1-排序算法的比较"><a href="#1-排序算法的比较" class="headerlink" title="1 排序算法的比较"></a>1 排序算法的比较</h2><p>快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 ~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。</p><p>使用三向切分快速排序，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。</p><div class="table-container"><table><thead><tr><th><strong>算法</strong></th><th><strong>稳定性</strong></th><th><strong>时间复杂度</strong></th><th><strong>空间复杂度</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>选择排序</td><td>×</td><td>N2</td><td>1</td><td></td></tr><tr><td>冒泡排序</td><td>√</td><td>N2</td><td>1</td><td></td></tr><tr><td>插入排序</td><td>√</td><td>N ~ N2</td><td>1</td><td>时间复杂度和初始顺序有关</td></tr><tr><td>希尔排序</td><td>×</td><td>N的若干倍乘于递增序列的长度</td><td>1</td><td>改进版插入排序</td></tr><tr><td>快速排序</td><td>×</td><td>NlogN</td><td>logN</td><td></td></tr><tr><td>三向切分快速排序</td><td>×</td><td>N ~ NlogN</td><td>logN</td><td>适用于有大量重复主键</td></tr><tr><td>归并排序</td><td>√</td><td>NlogN</td><td>N</td><td></td></tr><tr><td>堆排序</td><td>×</td><td>NlogN</td><td>1</td><td>无法利用局部性原理</td></tr></tbody></table></div><h2 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2 快速排序"></a>2 快速排序</h2><p>快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。</p><p>取 a[l] 作为切分元素，从数组的左端向右扫描直到找到第一个大于等于它的元素，再从数组的右端向左扫描找到第一个小于它的元素，交换这两个元素。不断进行这个过程，就可以保证左指针 i 的左侧元素都不大于切分元素，右指针 j 的右侧元素都不小于切分元素。当两个指针相遇时，将切分元素 a[l] 和 a[j] 交换位置。</p><p>为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 快速排序主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quicksort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span></span><br><span class="line">    <span class="comment">// 选择枢纽元素</span></span><br><span class="line">    pivot := arr[<span class="built_in">len</span>(arr)/<span class="number">2</span>]</span><br><span class="line">    <span class="comment">// 分区过程</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        <span class="keyword">for</span> arr[left] &lt; pivot &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> arr[right] &gt; pivot &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left &lt;= right &#123;</span><br><span class="line">            arr[left], arr[right] = arr[right], arr[left]</span><br><span class="line">            left++</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归排序左右两部分</span></span><br><span class="line">    <span class="keyword">if</span> right &gt; <span class="number">0</span> &#123;</span><br><span class="line">        quicksort(arr[:right+<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> left &lt; <span class="built_in">len</span>(arr) &#123;</span><br><span class="line">        quicksort(arr[left:])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Unsorted array:&quot;</span>, data)</span><br><span class="line">    quicksort(data)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Sorted array:&quot;</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> <span class="keyword">extends</span> <span class="title class_">Sort</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(Integer[] nums, <span class="type">int</span> l, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = h+<span class="number">1</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">v</span> <span class="operator">=</span> nums[l];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">     <span class="comment">//从左侧向右扫描找到第一个大于等于基准的，再从数组的右端向左扫描找到第一个小于它的元素，交换这两个元素。</span></span><br><span class="line">            <span class="keyword">while</span> (less(nums[++i],v) &amp;&amp; i != h);</span><br><span class="line">            <span class="keyword">while</span> (less(v,nums[--j]) &amp;&amp; j != l);</span><br><span class="line">            <span class="comment">//当两个指针相遇，结束循环</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; i) <span class="keyword">break</span>;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,l,j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(Integer[] nums)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(nums);</span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        list.toArray(nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">        shuffle(nums);</span><br><span class="line">        sort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums, <span class="type">int</span> l, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= h) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> partition(nums, l, h);</span><br><span class="line">        sort(nums, l, j);</span><br><span class="line">        sort(nums, j+<span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(Integer v, Integer w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v &lt; w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Integer[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-1-基于切分的快速选择算法（TopK）"><a href="#2-1-基于切分的快速选择算法（TopK）" class="headerlink" title="2.1 基于切分的快速选择算法（TopK）"></a>2.1 基于切分的快速选择算法（TopK）</h3><p>快速排序的partition()方法，会返回一个索引j，j前面的都小于a[j],后面的都大于，也即是返回第j大的元素</p><p>可以据此找出第k大元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> partition(nums,low,high);</span><br><span class="line">        <span class="keyword">if</span>(j == k) <span class="keyword">return</span> nums[k];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; k)&#123;</span><br><span class="line">            high = j - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">low = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-三向切分"><a href="#2-2-三向切分" class="headerlink" title="2.2 三向切分"></a>2.2 三向切分</h3><p>对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。</p><p>三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序。</p><p>Java 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeWayQuickSort</span> <span class="keyword">extends</span> <span class="title class_">QuickSort</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums, <span class="type">int</span> l, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=h) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lt</span> <span class="operator">=</span> l, i = l+<span class="number">1</span>, gt = h;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">v</span> <span class="operator">=</span> nums[l];</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=gt)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> nums[i] - v;</span><br><span class="line">            <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums, lt++, i++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums, i, gt--);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums, l, lt-<span class="number">1</span>);</span><br><span class="line">        sort(nums, gt+<span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-215-数组中的第K个最大元素"><a href="#2-3-215-数组中的第K个最大元素" class="headerlink" title="2.3 215. 数组中的第K个最大元素"></a>2.3 <a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>对子数组进行划分，如果划分得到的 q 正好就是我们需要的下标，就直接返回 a[q]；否则，如果 q 比目标下标小，就递归右子区间，否则递归左子区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 转换一下，第 k 大元素的索引是 len - k</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> len - k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (index == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[index];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; target) &#123;</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                swap(nums, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, j, left);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3 选择排序"></a>3 选择排序</h2><p>选择最小的元素，然后和第一个交换，然后从剩下的元素选最小的和第二个交换，直到将整个数组排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Selection</span> <span class="keyword">extends</span> <span class="title class_">Sort</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; n; j++)&#123;<span class="comment">//从剩下的元素中选出最小的元素</span></span><br><span class="line">                <span class="keyword">if</span>(less(nums[j], nums[min]))&#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, min);<span class="comment">//和最小的交换位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Integer[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(Integer v, Integer w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v &lt; w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-堆排序"><a href="#4-堆排序" class="headerlink" title="4 堆排序"></a>4 堆排序</h2><h3 id="4-1-堆"><a href="#4-1-堆" class="headerlink" title="4.1 堆"></a>4.1 堆</h3><p>堆中某个节点的值总是大于等于其子节点的值，并且堆是一颗完全二叉树。</p><p>位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。</p><p>大根堆： 根节点大于叶子节点  根节点是最大的   根据大根堆可以得到几个最小的</p><p>小根堆： 根节点是最小的，输出根节点就是输出最小的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T[] heap;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span> maxN)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.heap = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[maxN + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> heap[i].compareTo(heap[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> heap[i];</span><br><span class="line">        heap[i] = heap[j];</span><br><span class="line">        heap[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-上浮和下沉"><a href="#4-2-上浮和下沉" class="headerlink" title="4.2 上浮和下沉"></a>4.2 上浮和下沉</h3><p>在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k / <span class="number">2</span>, k)) &#123;</span><br><span class="line">        swap(k / <span class="number">2</span>, k);</span><br><span class="line">        k = k / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，应当与两个子节点中最大那个节点进行交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * k;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; N &amp;&amp; less(j, j + <span class="number">1</span>))</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (!less(k, j))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-插入"><a href="#4-3-插入" class="headerlink" title="4.3 插入"></a>4.3 插入</h3><p>将新元素放到数组末尾，然后上浮到合适的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Comparable v)</span> &#123;</span><br><span class="line">    heap[++N] = v;</span><br><span class="line">    swim(N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-删除最大元素"><a href="#4-4-删除最大元素" class="headerlink" title="4.4 删除最大元素"></a>4.4 删除最大元素</h3><p>从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> heap[<span class="number">1</span>];</span><br><span class="line">    swap(<span class="number">1</span>, N--);</span><br><span class="line">    heap[N + <span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line">    sink(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-堆排序"><a href="#4-5-堆排序" class="headerlink" title="4.5 堆排序"></a>4.5 堆排序</h3><p>把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序。</p><p>从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。</p><p>交换堆顶元素与最后一个元素</p><p>交换之后需要进行下沉操作维持堆的有序状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; <span class="keyword">extends</span> <span class="title class_">Sort</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组第 0 个位置不能有元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">            sink(nums, k, N);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            swap(nums, <span class="number">1</span>, N--);</span><br><span class="line">            sink(nums, <span class="number">1</span>, N);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(T[] nums, <span class="type">int</span> k, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; N &amp;&amp; less(nums, j, j + <span class="number">1</span>))</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span> (!less(nums, k, j))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(nums, k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(T[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i].compareTo(nums[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-冒泡排序"><a href="#5-冒泡排序" class="headerlink" title="5 冒泡排序"></a>5 冒泡排序</h2><p>从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bubble</span> <span class="keyword">extends</span> <span class="title class_">Sort</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>; i &gt; <span class="number">0</span> &amp;&amp; flag; i--)&#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(less(nums[j+<span class="number">1</span>],nums[j]))&#123;</span><br><span class="line">                    swap(nums,j,j+<span class="number">1</span>);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-插入排序"><a href="#6-插入排序" class="headerlink" title="6 插入排序"></a>6 插入排序</h2><p>每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。</p><p>插入排序每次只能交换相邻元素，令逆序数量减少 1，因此插入排序需要交换的次数为逆序数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Insertion</span> <span class="keyword">extends</span> <span class="title class_">Sort</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span> &amp;&amp; less(nums[j],nums[j-<span class="number">1</span>]); j--)&#123;</span><br><span class="line">                swap(nums,j,j-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-希尔排序"><a href="#7-希尔排序" class="headerlink" title="7 希尔排序"></a>7 希尔排序</h2><p>插入排序的优化</p><p>通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p><p>使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shell</span> <span class="keyword">extends</span> <span class="title class_">Sort</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; n/<span class="number">3</span>)&#123;</span><br><span class="line">            h = <span class="number">3</span>*h + <span class="number">1</span>;<span class="comment">//1,4,9,13</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span> &amp;&amp; less(nums[j],nums[j-h]); j -= h)&#123;</span><br><span class="line">                    swap(nums,j,j-h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-归并算法"><a href="#8-归并算法" class="headerlink" title="8 归并算法"></a>8 归并算法</h2><p>将数组分成两部分，分别进行排序，然后归并起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> <span class="keyword">extends</span> <span class="title class_">Sort</span> &#123;</span><br><span class="line">    <span class="comment">//合并时，需要辅助数组，空间复杂度为 O(N)</span></span><br><span class="line">    <span class="keyword">private</span> Integer[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并方法：将数组中两个已经排序的部分归并成一个。</span></span><br><span class="line">    <span class="comment">//l需要合并的数组左端，m中点，h需要合并的数组右端</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Integer[] nums, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= h; k++)&#123;</span><br><span class="line">            aux[k] = nums[k];<span class="comment">//将数据复制到辅助数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= h; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; m)&#123;</span><br><span class="line">                nums[k] = aux[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; h)&#123;</span><br><span class="line">                nums[k] = aux[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aux[i]&lt;=aux[j])&#123;</span><br><span class="line">                nums[k] = aux[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k] = aux[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个大数组分成两个小数组去求解。</span></span><br><span class="line">    <span class="comment">//因为每次都将问题对半分成两个子问题，这种对半分的算法复杂度一般为 O(NlogN)。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="title class_">Integer</span>[nums.length];</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums, <span class="type">int</span> l, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(h&lt;=l)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (h - l)/<span class="number">2</span>;</span><br><span class="line">        sort(nums, l, mid);</span><br><span class="line">        sort(nums, mid+<span class="number">1</span>, h);</span><br><span class="line">        merge(nums, l, mid, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-1-剑指35-数组的逆序对"><a href="#8-1-剑指35-数组的逆序对" class="headerlink" title="8.1 剑指35.数组的逆序对"></a>8.1 剑指35.数组的逆序对</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p><p>在两个子序列left、right合并过程中，当left中当前元素A大于right中当前元素B时，因为left序列已经有序，所以A后面所有元素都可以与B组成逆序对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] aux;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">InversePairs</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="title class_">int</span>[array.length];</span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= h; k++)&#123;</span><br><span class="line">            aux[k] = array[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= h; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; m)&#123;</span><br><span class="line">                array[k] = aux[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; h)&#123;</span><br><span class="line">                array[k] = aux[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aux[i] &lt;= aux[j])&#123;</span><br><span class="line">                array[k] = aux[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                array[k] = aux[j++];</span><br><span class="line">                count = (count + m + <span class="number">1</span> - i)%<span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> l, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=h) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (h-l)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(array,l,m);</span><br><span class="line">        mergeSort(array,m+<span class="number">1</span>,h);</span><br><span class="line">        merge(array,l,m,h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;1-排序算法的比较&quot;&gt;&lt;a href=&quot;#1-排序算法的比较&quot; class=&quot;headerlink&quot; title=&quot;1 排序算法的比较&quot;&gt;&lt;/a&gt;1 排序算法的比较&lt;/h2&gt;&lt;p&gt;快速排序是最快的通用排序算法，它的内</summary>
      
    
    
    
    
    <category term="Algorithm" scheme="https://stardustorz.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>[Algorithm] String</title>
    <link href="https://stardustorz.github.io/2025/07/25/Algorithm/String/"/>
    <id>https://stardustorz.github.io/2025/07/25/Algorithm/String/</id>
    <published>2025-07-25T10:10:13.000Z</published>
    <updated>2025-07-27T16:20:06.543Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="1-字符串常用方法"><a href="#1-字符串常用方法" class="headerlink" title="1 字符串常用方法"></a>1 字符串常用方法</h2><ul><li>不必考虑到线程同步问题，我们应该优先使用StringBuilder类；如果要保证线程安全，自然是StringBuffer。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String的方法</span></span><br><span class="line"><span class="type">char</span>  <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span> <span class="comment">//返回指定索引处的值</span></span><br><span class="line">String  <span class="title function_">concat</span><span class="params">(String str)</span>  <span class="comment">//将指定的字符串连接到该字符串的末尾</span></span><br><span class="line"><span class="type">boolean</span>   <span class="title function_">contentEquals</span><span class="params">(StringBuffer sb)</span>  <span class="comment">//将此字符串与指定的StringBuffer进行比较</span></span><br><span class="line"><span class="type">int</span>   <span class="title function_">indexOf</span><span class="params">(<span class="type">int</span> ch)</span>  <span class="comment">//返回指定字符第一次出现的字符串内的索引</span></span><br><span class="line"><span class="type">int</span>   <span class="title function_">indexOf</span><span class="params">(String str)</span>  <span class="comment">//返回指定子字符串第一次出现的字符串内的索引</span></span><br><span class="line"><span class="type">boolean</span>  <span class="title function_">isEmpty</span><span class="params">()</span> </span><br><span class="line"><span class="type">int</span>  <span class="title function_">length</span><span class="params">()</span></span><br><span class="line">String   <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span>  <span class="comment">//将 int 变量 i 转换成字符串(使用于其他数据类型)</span></span><br><span class="line">String[]  split(String regex)  <span class="comment">//按regex将String切分成数组</span></span><br><span class="line"><span class="type">char</span>[]   toCharArray()  <span class="comment">//将此字符串转换为新的字符数组</span></span><br><span class="line">String   <span class="title function_">trim</span><span class="params">()</span>  <span class="comment">//删除前后的空格</span></span><br><span class="line">String    <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span>  <span class="comment">//获得子串，是左闭右开区间</span></span><br><span class="line">  </span><br><span class="line">StringBuffer  方法</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="number">50</span>);  <span class="comment">// 容量为50</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot; World&quot;</span>);  <span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line">sb.insert(<span class="number">5</span>, <span class="string">&quot; Java&quot;</span>);  <span class="comment">// &quot;Hello Java World&quot;</span></span><br><span class="line">sb.replace(<span class="number">6</span>, <span class="number">10</span>, <span class="string">&quot;Beautiful&quot;</span>);  <span class="comment">// &quot;Hello Beautiful World&quot;</span></span><br><span class="line">sb.delete(<span class="number">6</span>, <span class="number">15</span>);  <span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line">sb.deleteCharAt(<span class="number">5</span>);  <span class="comment">// &quot;HelloWorld&quot;</span></span><br><span class="line">sb.reverse();  <span class="comment">// &quot;dlroWolleH&quot;</span></span><br><span class="line">sb.setCharAt(<span class="number">0</span>, <span class="string">&#x27;h&#x27;</span>);  <span class="comment">// &quot;helloWorld&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> sb.substring(<span class="number">5</span>);  <span class="comment">// &quot;World&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> sb.substring(<span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sb.length();  <span class="comment">// 10</span></span><br><span class="line">res.toString()   <span class="comment">//转换成string</span></span><br></pre></td></tr></table></figure><h2 id="2-剑指-Offer-58-I-翻转单词顺序"><a href="#2-剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="2 剑指 Offer 58 - I. 翻转单词顺序"></a>2 <a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a></h2><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//split()将字符串按空格分割，倒序遍历，将单词拼接到StringBuilder，去空格后返回</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        String[] strs = s.trim().split(<span class="string">&quot; &quot;</span>); <span class="comment">// 删除首尾空格，分割字符串</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> strs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒序遍历单词列表</span></span><br><span class="line">            <span class="keyword">if</span>(strs[i].equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">continue</span>; <span class="comment">// 遇到空单词则跳过</span></span><br><span class="line">            res.append(strs[i] + <span class="string">&quot; &quot;</span>); <span class="comment">// 将单词拼接至 StringBuilder</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim(); <span class="comment">// 转化为字符串，删除尾部空格，并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//倒序，逐个确定每个单词的边界</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        s = s.trim(); <span class="comment">// 删除首尾空格</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, i = j;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != <span class="string">&#x27; &#x27;</span>) i--; <span class="comment">// 搜索首个空格</span></span><br><span class="line">            res.append(s.substring(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="string">&quot; &quot;</span>); <span class="comment">// 添加单词</span></span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27; &#x27;</span>) i--; <span class="comment">// 跳过单词间空格</span></span><br><span class="line">            j = i; <span class="comment">// j 指向下个单词的尾字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim(); <span class="comment">// 转化为字符串并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-409-最长回文串"><a href="#3-409-最长回文串" class="headerlink" title="3 409. 最长回文串"></a>3 <a href="https://leetcode-cn.com/problems/longest-palindrome/">409. 最长回文串</a></h2><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计每个字符的个数</span></span><br><span class="line"><span class="comment">//每对字符都可以组成回文串，因为中间的可以是单个，如果还有剩余的单个，可以加一个上去</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; s.length() ; i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            map.put(c, map.getOrDefault(c,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: map.keySet())&#123;</span><br><span class="line">            res += (map.get(c) / <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res &lt; s.length())&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用数组统计</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            cnt[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : cnt)&#123;</span><br><span class="line">            result += (i/<span class="number">2</span>)*<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(result &lt; s.length())&#123;</span><br><span class="line">            result++;<span class="comment">//这种情况有单独的字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-205-同构字符串"><a href="#4-205-同构字符串" class="headerlink" title="4 205. 同构字符串"></a>4 <a href="https://leetcode-cn.com/problems/isomorphic-strings/">205. 同构字符串</a></h2><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p><p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p><p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录一个字符上次出现的位置，如果两个字符串中上次出现的位置一样，那么就是同构</span></span><br><span class="line"><span class="comment">//如 egg add g上次出现在2，d也上次出现在2，那么它们就是同构的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIsomorphic</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] indexOft = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="type">int</span>[] indexOfs = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">cs</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="type">char</span> <span class="variable">ct</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(indexOfs[cs] != indexOft[ct])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//防止一开始放进去的是0，无法区分</span></span><br><span class="line">            indexOfs[cs] = i + <span class="number">1</span>;</span><br><span class="line">            indexOft[ct] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-647-回文子串"><a href="#5-647-回文子串" class="headerlink" title="5 647. 回文子串"></a>5 <a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a></h2><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 中心扩展法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//可以从一个字符向两侧扩展，也可以从两个相邻字符开始扩展，这样可以覆盖所有可能的子串</span></span><br><span class="line">        <span class="comment">//这样的单个字符有n个，两个有n-1个，所以合计有2n-1个中心点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> <span class="number">0</span>; center &lt; <span class="number">2</span> * s.length() - <span class="number">1</span>; center++) &#123;</span><br><span class="line">            <span class="comment">// left和right指针和中心点的关系是？</span></span><br><span class="line">            <span class="comment">// 首先是left，有一个很明显的2倍关系的存在，其次是right，可能和left指向同一个（偶数时），也可能往后移动一个（奇数）</span></span><br><span class="line">            <span class="comment">// 大致的关系出来了，可以选择带两个特殊例子进去看看是否满足。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> center / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + center % <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//在字符串范围内向两侧拓展</span></span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-696-计数二进制子串"><a href="#6-696-计数二进制子串" class="headerlink" title="6 696. 计数二进制子串"></a>6 <a href="https://leetcode-cn.com/problems/count-binary-substrings/">696. 计数二进制子串</a></h2><p>给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计相同连续数字的个数，取其中的较小</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countBinarySubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//统计当前数字连续的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curCnt</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//记录上一个数字连续的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//如果和前一个一样，当前连续个数++</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == s.charAt(i-<span class="number">1</span>))&#123;</span><br><span class="line">                curCnt++;</span><br><span class="line">            <span class="comment">//否则，记录下，作为前一个连续数字个数，然后重置当前</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                preCnt = curCnt;</span><br><span class="line">                curCnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//前一个数连续的个数大于当前，那么就多一种子串</span></span><br><span class="line">            <span class="keyword">if</span>(preCnt &gt;= curCnt)&#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-剑指-Offer-19-正则表达式匹配"><a href="#7-剑指-Offer-19-正则表达式匹配" class="headerlink" title="7 剑指 Offer 19. 正则表达式匹配"></a>7 <a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配</a></h2><p>请实现一个函数用来匹配包含’. ‘和’/<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&#x27;.&#x27;可以表示任意一个字符</span></span><br><span class="line"><span class="comment">//&#x27;*&#x27;表示前面的字符可以出现任意次</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有三种情况：</span></span><br><span class="line"><span class="comment">1.B的最后一个是正常字符，那么比较AB最后一个，相等则往前一位</span></span><br><span class="line"><span class="comment">2.B的最后是&#x27;.&#x27;，可以直接往前一位</span></span><br><span class="line"><span class="comment">3.B的最后是&#x27;*&#x27;，代表B的倒数第二个可以重复一次，或者多次</span></span><br><span class="line"><span class="comment">如果A的最后匹配失败，那么B往前两位</span></span><br><span class="line"><span class="comment">如果匹配成功，那么A匹配完往前，B继续</span></span><br><span class="line"><span class="comment">f[i][j] 代表 A 的前 i 个和 B 的前 j 个能否匹配</span></span><br><span class="line"><span class="comment">对于前面两个情况，可以合并成一种情况 f[i][j] = f[i-1][j-1]</span></span><br><span class="line"><span class="comment">对于第三种情况，对于 c*c∗ 分为看和不看两种情况</span></span><br><span class="line"><span class="comment">不看：直接砍掉正则串的后面两个， f[i][j] = f[i][j-2]</span></span><br><span class="line"><span class="comment">看：正则串不动，主串前移一个，f[i][j] = f[i-1][j] </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> p.length();</span><br><span class="line">        <span class="type">boolean</span>[][] f = <span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n ; i++ )&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="comment">//如果j=0，那么只有i也是0的情况匹配成功</span></span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>) f[i][j] = i == <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果p最后一位不是&#x27;*&#x27;</span></span><br><span class="line">                    <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">//如果相等，或者p的最后是&#x27;.&#x27;，那么都向前</span></span><br><span class="line">                        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>) || p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>))&#123;</span><br><span class="line">                            f[i][j] = f[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//碰到&#x27;*&#x27;</span></span><br><span class="line">                        <span class="comment">//不看，能否匹配取决于B串砍两位后能否匹配成功</span></span><br><span class="line">                        <span class="keyword">if</span>(j &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                            <span class="comment">//只要有一个成立就都成立</span></span><br><span class="line">                            f[i][j] |= f[i][j-<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"><span class="comment">//看，正则串不动，主串前移</span></span><br><span class="line">                        <span class="keyword">if</span>(i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">2</span>) || p.charAt(j-<span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>))&#123;</span><br><span class="line">                            f[i][j] |= f[i-<span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-剑指-Offer-48-最长不含重复字符的子字符串"><a href="#8-剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="8 剑指 Offer 48. 最长不含重复字符的子字符串"></a>8 <a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h2><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//滑动窗口实现</span></span><br><span class="line"><span class="comment">//维护一个left，表示窗口的最左侧</span></span><br><span class="line"><span class="comment">//维护一个HashMap，记录窗口内的元素和位置</span></span><br><span class="line"><span class="comment">//当加入了一个当前窗口内已有的值，直接通过HashMap获取位置，重置left</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i ++)&#123;</span><br><span class="line">            <span class="comment">//如果这个元素出现过</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                <span class="comment">//如果在窗口内，left跳转到它的下一个</span></span><br><span class="line">                left = Math.max(left,map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//放入当前</span></span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">            <span class="comment">//计算当前窗口值是否最大</span></span><br><span class="line">            max = Math.max(max,i-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-剑指-Offer-67-把字符串转换成整数"><a href="#9-剑指-Offer-67-把字符串转换成整数" class="headerlink" title="9 剑指 Offer 67. 把字符串转换成整数"></a>9 <a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">剑指 Offer 67. 把字符串转换成整数</a></h2><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strToInt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">//去除两端空格</span></span><br><span class="line">        str = str.trim();</span><br><span class="line">        <span class="comment">//判空</span></span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>  <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//标记是否为负</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//记录当前所指字符位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span>) flag = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//有符号，前进一位</span></span><br><span class="line">        <span class="keyword">if</span> (str.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span> || str.charAt(<span class="number">0</span>) == <span class="string">&#x27;+&#x27;</span>) i++;</span><br><span class="line">        <span class="comment">//如果是数字，循环继续 </span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; str.length() &amp;&amp; isNum(str.charAt(i)))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> str.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">//判断在加上之后是否会越界</span></span><br><span class="line">            <span class="keyword">if</span> ((res &gt; Integer.MAX_VALUE/<span class="number">10</span>) || (res == Integer.MAX_VALUE/<span class="number">10</span> &amp;&amp; r &gt; <span class="number">7</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> flag &gt; <span class="number">0</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res *<span class="number">10</span> + r;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag&gt;<span class="number">0</span>? res:-res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是不是数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isNum</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c - <span class="string">&#x27;0&#x27;</span> &gt;=<span class="number">0</span> &amp;&amp; c - <span class="string">&#x27;9&#x27;</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-剑指-Offer-44-数字序列中某一位的数字"><a href="#10-剑指-Offer-44-数字序列中某一位的数字" class="headerlink" title="10 剑指 Offer 44. 数字序列中某一位的数字"></a>10 <a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">剑指 Offer 44. 数字序列中某一位的数字</a></h2><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//特殊情况</span></span><br><span class="line">       <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(n&gt;=<span class="number">0</span> &amp;&amp; n&lt;=<span class="number">9</span>) <span class="keyword">return</span> n; </span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//防止越界</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> n;</span><br><span class="line">   <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">           <span class="comment">//当前数字的长度</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">           <span class="comment">//当前数字的个数</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">   <span class="type">char</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           <span class="comment">//当前占的位数，循环到包含第n位数字</span></span><br><span class="line">   <span class="keyword">while</span>((temp+base*num) &lt; m) &#123;</span><br><span class="line">               <span class="comment">//长度</span></span><br><span class="line">   temp += base*num;</span><br><span class="line">               <span class="comment">//数字长度加一</span></span><br><span class="line">   base += <span class="number">1</span>;</span><br><span class="line">               <span class="comment">//长度为base的数字个数</span></span><br><span class="line">   num *= <span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line">           <span class="comment">//a用来确定所在数字的大小</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> (m-temp)/base;</span><br><span class="line">           <span class="comment">//b用来确定在这个数字的第几位</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> (m-temp)%base;</span><br><span class="line">           </span><br><span class="line">   <span class="keyword">if</span>(b!=<span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//计算出这个数</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">long</span>) (Math.pow(<span class="number">10</span>, base-<span class="number">1</span>) + a);</span><br><span class="line">               <span class="comment">//找到答案</span></span><br><span class="line">   res = String.valueOf(c).charAt((<span class="type">int</span>)b-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//b=0，说明是在前一个数的最后一位上</span></span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">long</span>) (Math.pow(<span class="number">10</span>, base-<span class="number">1</span>) + a - <span class="number">1</span>);</span><br><span class="line">   res = String.valueOf(c).charAt((<span class="type">int</span>)base-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> Integer.parseInt(String.valueOf(res));</span><br><span class="line">   &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-无重复的最长子串"><a href="#11-无重复的最长子串" class="headerlink" title="11 无重复的最长子串"></a>11 无重复的最长子串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针，如果已经包含就不断前移</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>,i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j));</span><br><span class="line">                j++;</span><br><span class="line">                res = Math.max(res,j-i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.remove(s.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复</span></span><br><span class="line"><span class="comment">//我们定义不重复子串的开始位置为 start，结束位置为 end</span></span><br><span class="line"><span class="comment">//随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符</span></span><br><span class="line"><span class="comment">//无论是否更新 start，都会更新其 map 数据结构和结果 ans。</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span> ,left = <span class="number">0</span>; right &lt; n ;right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(right)))&#123;</span><br><span class="line">                left = Math.max(map.get(s.charAt(right)),left);  </span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,right-left+<span class="number">1</span>);</span><br><span class="line">            map.put(s.charAt(right),right+<span class="number">1</span>);  <span class="comment">//加一是为了返回重复字符的后一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-最小覆盖子串"><a href="#12-最小覆盖子串" class="headerlink" title="12 最小覆盖子串"></a>12 最小覆盖子串</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s == <span class="string">&quot;&quot;</span> || t == <span class="literal">null</span> || t == <span class="string">&quot;&quot;</span> || s.length() &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用来统计t中每个字符出现次数  char型可以转换成0-128的int，对应字符的ASCII码,也就是用字符对应的int值作为下标</span></span><br><span class="line">        <span class="type">int</span>[] needs = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];    <span class="comment">//标记字符串t中字符</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] window = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];  <span class="comment">//标记滑动窗口中的字符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;<span class="comment">//加入数组中</span></span><br><span class="line">            needs[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//当前有多少个字符匹配成功</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来记录最短需要多少个字符。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> s.length() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            window[ch]++;</span><br><span class="line">            <span class="keyword">if</span> (needs[ch] &gt; <span class="number">0</span> &amp;&amp; needs[ch] &gt;= window[ch]) &#123;<span class="comment">//如果字符匹配成功，count++</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (count == t.length()) &#123;<span class="comment">//当匹配整个字符串都匹配成功，记录下当前的最短覆盖子串，然后从左侧缩小窗口，如果最左是有效的字符，右移右侧的指针直到再次匹配成功</span></span><br><span class="line">                ch = s.charAt(left);</span><br><span class="line">                <span class="keyword">if</span> (needs[ch] &gt; <span class="number">0</span> &amp;&amp; needs[ch] &gt;= window[ch]) &#123;<span class="comment">//如果最左的元素属于有效字符，减少count</span></span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; minLength) &#123;<span class="comment">//如果当前窗口的大小小于最短，更新minlength</span></span><br><span class="line">                    minLength = right - left + <span class="number">1</span>;</span><br><span class="line">                    res = s.substring(left, right + <span class="number">1</span>);<span class="comment">//截取当前最短的子串作为答案</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                window[ch]--;<span class="comment">//将最左元素从窗口中去除</span></span><br><span class="line">                left++;<span class="comment">//左指针右移</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            right++;<span class="comment">//右指针右移</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="13-剑指-Offer-57-II-和为s的连续正数序列"><a href="#13-剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="13 剑指 Offer 57 - II. 和为s的连续正数序列"></a>13 <a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为s的连续正数序列</a></h2><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] findContinuousSequence(<span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//左右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(i &lt;= target / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//如果和小于目标，右边界右移</span></span><br><span class="line">            <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                sum += j;</span><br><span class="line">                j++;</span><br><span class="line">            <span class="comment">//如果和大于目标，左边界右移</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                sum -= i;</span><br><span class="line">                i++;</span><br><span class="line">            <span class="comment">//否则，将答案加入</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[j-i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i ; k &lt; j; k++)&#123;</span><br><span class="line">                    a[k - i] = k;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(a);</span><br><span class="line">                <span class="comment">//以i为起点已经没有答案了，左边界右移</span></span><br><span class="line">                sum -= i;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-剑指-Offer-59-I-滑动窗口的最大值"><a href="#14-剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="14 剑指 Offer 59 - I. 滑动窗口的最大值"></a>14 <a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer 59 - I. 滑动窗口的最大值</a></h2><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p><p>思路：怎么样在每次窗口滑动后在O(1)的时间获得最大值——-单调队列，队列头就是最大的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//维护一个单调递减的双端队列</span></span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>,i = <span class="number">1</span>-k ; j &lt; nums.length ; i++,j++)&#123;</span><br><span class="line">            <span class="comment">//如果窗口已经成型，并且滑动时移除的是最大值</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; deque.peekFirst() == nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//移除队列中所有小于新加入的值</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j])&#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//加入队列</span></span><br><span class="line">            deque.add(nums[j]);</span><br><span class="line">            <span class="comment">//记录最大值</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                res[i] = deque.peekFirst();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;1-字符串常用方法&quot;&gt;&lt;a href=&quot;#1-字符串常用方法&quot; class=&quot;headerlink&quot; title=&quot;1 字符串常用方法&quot;&gt;&lt;/a&gt;1 字符串常用方法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;不必考虑到线程同步问题，</summary>
      
    
    
    
    
    <category term="Algorithm" scheme="https://stardustorz.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>[Algorithm] Search</title>
    <link href="https://stardustorz.github.io/2025/07/25/Algorithm/Search/"/>
    <id>https://stardustorz.github.io/2025/07/25/Algorithm/Search/</id>
    <published>2025-07-25T10:10:13.000Z</published>
    <updated>2025-07-25T10:10:13.000Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h2 id="1-BFS"><a href="#1-BFS" class="headerlink" title="1 BFS"></a>1 BFS</h2><p>广度优先搜索一层一层的进行遍历，每次遍历以上层遍历的结果作为起点，遍历一个距离能达到的节点，注意去除重复遍历的情况</p><h3 id="1-1-279-完全平方数"><a href="#1-1-279-完全平方数" class="headerlink" title="1.1 279. 完全平方数"></a>1.1 <a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h3><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    HashSet&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    queue.add(n);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        level++; <span class="comment">// 开始生成下一层</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">//依次减 1, 4, 9... 生成下一层的节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j * j &lt;= cur; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> cur - j * j;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> level;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(next)) &#123;</span><br><span class="line">                    queue.offer(next);</span><br><span class="line">                    visited.add(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-127-单词接龙"><a href="#1-2-127-单词接龙" class="headerlink" title="1.2 127. 单词接龙"></a>1.2 <a href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a></h3><p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p><p>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典中的单词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">        <span class="comment">// 第 1 步：先将 wordList 放到哈希表里，便于判断某个单词是否在 wordList 里</span></span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordList);</span><br><span class="line">        <span class="keyword">if</span> (wordSet.size() == <span class="number">0</span> || !wordSet.contains(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        wordSet.remove(beginWord);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第 2 步：图的广度优先遍历，必须使用队列和表示是否访问过的 visited 哈希表</span></span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        visited.add(beginWord);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第 3 步：开始广度优先遍历，包含起点，因此初始化的时候步数为 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; currentSize; i++) &#123;</span><br><span class="line">                <span class="comment">// 依次遍历当前队列中的单词</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">currentWord</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="comment">// 如果 currentWord 能够修改 1 个字符与 endWord 相同，则返回 step + 1</span></span><br><span class="line">                <span class="keyword">if</span> (changeWordEveryOneLetter(currentWord, endWord, queue, visited, wordSet)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 尝试对 currentWord 修改每一个字符，看看是不是能与 endWord 匹配</span></span><br><span class="line"><span class="comment">     * @param currentWord</span></span><br><span class="line"><span class="comment">     * @param endWord</span></span><br><span class="line"><span class="comment">     * @param queue</span></span><br><span class="line"><span class="comment">     * @param visited</span></span><br><span class="line"><span class="comment">     * @param wordSet</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">changeWordEveryOneLetter</span><span class="params">(String currentWord, String endWord,</span></span><br><span class="line"><span class="params">                                             Queue&lt;String&gt; queue, Set&lt;String&gt; visited, Set&lt;String&gt; wordSet)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] charArray = currentWord.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; endWord.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 先保存，然后恢复</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">originChar</span> <span class="operator">=</span> charArray[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">k</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; k &lt;= <span class="string">&#x27;z&#x27;</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k == originChar) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                charArray[i] = k;</span><br><span class="line">                <span class="type">String</span> <span class="variable">nextWord</span> <span class="operator">=</span> String.valueOf(charArray);</span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(nextWord)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nextWord.equals(endWord)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(nextWord)) &#123;</span><br><span class="line">                        queue.add(nextWord);</span><br><span class="line">                        <span class="comment">// 注意：添加到队列以后，必须马上标记为已经访问</span></span><br><span class="line">                        visited.add(nextWord);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 恢复</span></span><br><span class="line">            charArray[i] = originChar;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-542-01-矩阵"><a href="#1-3-542-01-矩阵" class="headerlink" title="1.3 542. 01 矩阵"></a>1.3 <a href="https://leetcode-cn.com/problems/01-matrix/">542. 01 矩阵</a></h3><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] updateMatrix(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt; matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;);<span class="comment">//源点入队</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    matrix[i][j] = -<span class="number">1</span>;  <span class="comment">//标记未访问到的1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dir = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;; <span class="comment">//用来循环访问源点的上下左右</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] point = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> point[<span class="number">0</span>],y = point[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>[] d:dir)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> x+d[<span class="number">0</span>],y1 = y +d[<span class="number">1</span>];<span class="comment">//源点的四周的点</span></span><br><span class="line">                <span class="keyword">if</span>(x1 &gt;= <span class="number">0</span> &amp;&amp; x1 &lt; matrix.length &amp;&amp; y1 &gt;=<span class="number">0</span> &amp;&amp; y1 &lt; matrix[<span class="number">0</span>].length &amp;&amp; matrix[x1][y1] == -<span class="number">1</span>)&#123;  <span class="comment">//这个1在矩阵内且未被访问过</span></span><br><span class="line">                    matrix[x1][y1] = matrix[x][y] + <span class="number">1</span>; <span class="comment">//距离加一</span></span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x1,y1&#125;); <span class="comment">//将源点四周的点入队</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-DFS"><a href="#2-DFS" class="headerlink" title="2 DFS"></a>2 DFS</h2><p>从一个节点出发，使用DFS对一个图进行遍历，能到达的都是从初始节点可达的，DFS用来解决可达性问题</p><p>注意：</p><p>用栈保存当前节点信息</p><h3 id="2-1-200-岛屿数量"><a href="#2-1-200-岛屿数量" class="headerlink" title="2.1 200. 岛屿数量"></a>2.1 <a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h3><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dir = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="comment">//空矩阵</span></span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">islands</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; n ;j++)&#123;</span><br><span class="line">                <span class="comment">//有一个1，进行dfs，将与它相连的全部沉没</span></span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    islands++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> islands;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid,<span class="type">int</span> r,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件：在范围外或者是0；</span></span><br><span class="line">        <span class="keyword">if</span>(r&gt;=m||r&lt;<span class="number">0</span>||c&gt;=n||c&lt;<span class="number">0</span>||grid[r][c]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//沉没当前</span></span><br><span class="line">        grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">//沉没四周</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] d :dir)&#123;</span><br><span class="line">            dfs(grid,r+d[<span class="number">0</span>],c+d[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-695-岛屿的最大面积"><a href="#2-2-695-岛屿的最大面积" class="headerlink" title="2.2 695. 岛屿的最大面积"></a>2.2 <a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></h3><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p><p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dir = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="literal">null</span> ||grid.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m ;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    maxArea = Math.max(maxArea,dfs(grid,i,j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid,<span class="type">int</span> r,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span> || r&gt;=grid.length || c&lt; <span class="number">0</span> || c&gt;=grid[<span class="number">0</span>].length || grid[r][c]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[r][c] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] d : dir)&#123;</span><br><span class="line">            max += dfs(grid,r+d[<span class="number">0</span>],c+d[<span class="number">1</span>]);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-547-朋友圈"><a href="#2-3-547-朋友圈" class="headerlink" title="2.3 547. 朋友圈"></a>2.3 <a href="https://leetcode-cn.com/problems/friend-circles/">547. 朋友圈</a></h3><p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p><p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求无向图的连通分量</span></span><br><span class="line"><span class="comment">//如果ij两人是朋友，那么ij之间有边相连</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] M)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[M.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                dfs(M, i, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] M, <span class="type">int</span> i, <span class="type">boolean</span>[] visited)</span> &#123;</span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; M.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; M[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                dfs(M, j, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-130-被围绕的区域"><a href="#2-4-130-被围绕的区域" class="headerlink" title="2.4 130. 被围绕的区域"></a>2.4 <a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></h3><p>给定一个二维的矩阵，包含 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code>（<strong>字母 O</strong>）。</p><p>找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先填充最外侧，因为最外侧的O肯定不能被围绕，将它置为T，然后DFS它附近的O，标记</span></span><br><span class="line"><span class="comment">//全部标记完成后，遍历将O置为X，T置为O</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dir = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="literal">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        m = board.length;</span><br><span class="line">        n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            dfs(board,i,<span class="number">0</span>);</span><br><span class="line">            dfs(board,i,n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dfs(board,<span class="number">0</span>,i);</span><br><span class="line">            dfs(board,m-<span class="number">1</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; n ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board , <span class="type">int</span> r, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || board[r][c] != <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[r][c] = <span class="string">&#x27;T&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] d : dir)&#123;</span><br><span class="line">            dfs(board , r+d[<span class="number">0</span>] , c+d[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-417-太平洋大西洋水流问题"><a href="#2-5-417-太平洋大西洋水流问题" class="headerlink" title="2.5 417. 太平洋大西洋水流问题"></a>2.5 <a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a></h3><p>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。</p><p>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</p><p>请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反过来，从大西洋和太平洋向里面爬，两个区域的交点就是所需要的坐标</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">pacificAtlantic</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] dires = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m, n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] matrix;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pacificAtlantic</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        m = matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">this</span>.matrix = matrix;</span><br><span class="line">        <span class="type">boolean</span>[][] canReachP = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="type">boolean</span>[][] canReachA = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(<span class="number">0</span>, i, canReachP);</span><br><span class="line">            dfs(m - <span class="number">1</span>, i, canReachA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dfs(i, <span class="number">0</span>, canReachP);</span><br><span class="line">            dfs(i, n - <span class="number">1</span>, canReachA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(canReachA[i][j] &amp;&amp; canReachP[i][j])&#123;</span><br><span class="line">                    List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    temp.add(i);</span><br><span class="line">                    temp.add(j);</span><br><span class="line">                    res.add(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//换一种思路，从边界往里面走，只能走到比自己更高或者等高的地方。边界能走到的地方，就是能流入对应海洋的地方。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">boolean</span>[][] canReach)</span> &#123;</span><br><span class="line">        canReach[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> x + dires[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">newY</span> <span class="operator">=</span> y + dires[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (isIn(newX, newY) &amp;&amp; matrix[x][y] &lt;= matrix[newX][newY] &amp;&amp; !canReach[newX][newY]) &#123;</span><br><span class="line">                dfs(newX, newY, canReach);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isIn</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Backtracking"><a href="#3-Backtracking" class="headerlink" title="3 Backtracking"></a>3 Backtracking</h2><h3 id="3-1-1-DFS与回溯的区别"><a href="#3-1-1-DFS与回溯的区别" class="headerlink" title="3.1 1.DFS与回溯的区别"></a>3.1 1.DFS与回溯的区别</h3><p>回溯属于DFS，普通的DFS用来求解可达性问题，而回溯建立在DFS基础上，在搜索过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索。区别就在于有没有状态的重置。</p><p>回溯问题都可以抽象成树形结构，都是在集合中递归查找子集</p><p><strong>集合的大小决定数的宽度，递归的深度决定树的深度</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-回溯算法的使用场景"><a href="#3-2-2-回溯算法的使用场景" class="headerlink" title="3.2 2.回溯算法的使用场景"></a>3.2 2.回溯算法的使用场景</h3><p>当问题需要找出所有的解时，比如求解排列组合问题。</p><p>满足结束条件或者发现不是正确的路径的时候，<strong>撤销选择</strong>，回退到上一个状态，继续尝试。</p><h3 id="3-3-3-使用的步骤"><a href="#3-3-3-使用的步骤" class="headerlink" title="3.3 3.使用的步骤"></a>3.3 3.使用的步骤</h3><ul><li>画出递归树，找到状态变量（回溯函数的参数）</li><li>确定结束条件</li><li>找出选择列表，与函数参数相关</li><li>判断是否需要剪枝</li><li>做出选择，递归调用，进入下一层</li><li>撤销选择</li></ul><h3 id="3-4-4-回溯的类型"><a href="#3-4-4-回溯的类型" class="headerlink" title="3.4 4.回溯的类型"></a>3.4 4.回溯的类型</h3><div class="table-container"><table><thead><tr><th>类型</th><th>概念</th></tr></thead><tbody><tr><td>组合问题</td><td>N个数里面按一定规则找出k个数的集合</td></tr><tr><td>排列</td><td>N个数按一定规则全排列，求出所有的排列方式</td></tr><tr><td>切割问题</td><td>一个字符串按一定规则有多少种切割方式</td></tr><tr><td>子集问题</td><td>N个数的集合里有多少种符合条件的子集</td></tr><tr><td>棋盘问题</td><td>N皇后，数独等</td></tr></tbody></table></div><p>组合不强调元素顺序，排列强调元素顺序</p><p>“排列”类型问题和“子集、组合”问题不同在于：“排列”问题使用used数组来标识选择列表，而“子集、组合”问题则使用start参数。另外还需注意两种问题的判重剪枝！</p><h4 id="3-4-1-组合问题"><a href="#3-4-1-组合问题" class="headerlink" title="3.4.1 组合问题"></a>3.4.1 组合问题</h4><p>如果是一个集合求组合，需要 start 来控制 for 循环的起始位置</p><p>如果是多个集合取组合，他们互不影响，就不用 start</p><h5 id="3-4-1-1-去重："><a href="#3-4-1-1-去重：" class="headerlink" title="3.4.1.1 去重："></a>3.4.1.1 去重：</h5><p>当 candidate[i] == candidate[i-1] 时，有两种情况</p><p>两个维度：同一个递归层的重复和递归枝的重复，可以根据 used[i-1] 进行判断</p><p>如果是同一层上的重复，used[i-1]  == false 不可以进行重复的选取</p><p>如果是同一枝上的重复，used[i-1]  == true 可以进行重复的选取</p><h4 id="3-4-2-切割问题"><a href="#3-4-2-切割问题" class="headerlink" title="3.4.2 切割问题"></a>3.4.2 切割问题</h4><ul><li>如何模拟那些切割线</li><li>切割问题中递归如何终止</li><li>在递归循环中如何截取子串</li><li>如何判断回文</li></ul><h4 id="3-4-3-子集问题"><a href="#3-4-3-子集问题" class="headerlink" title="3.4.3 子集问题"></a>3.4.3 子集问题</h4><p>子集问题是收集所有节点的结果，组合是收集叶子节点的结果</p><h5 id="3-4-3-1-递增子序列的去重不能先排序"><a href="#3-4-3-1-递增子序列的去重不能先排序" class="headerlink" title="3.4.3.1 递增子序列的去重不能先排序"></a>3.4.3.1 递增子序列的去重不能先排序</h5><h5 id="3-4-3-2-子集类的剪枝："><a href="#3-4-3-2-子集类的剪枝：" class="headerlink" title="3.4.3.2 子集类的剪枝："></a>3.4.3.2 子集类的剪枝：</h5><p>判断是否需要剪枝，先排序</p><p>去除从重复的集合，也就是去除当前的选择列表中，与上一个重复的数，所引出的分支</p><h4 id="3-4-4-排列问题"><a href="#3-4-4-排列问题" class="headerlink" title="3.4.4 排列问题"></a>3.4.4 排列问题</h4><p>排列的有序的，因此不需要 start，每次都是从0开始</p><p>需要一个 used 数组对已经使用的进行记录</p><h5 id="3-4-4-1-排列的去重：使用-used-i-1-false-，即树层去重，效率更高"><a href="#3-4-4-1-排列的去重：使用-used-i-1-false-，即树层去重，效率更高" class="headerlink" title="3.4.4.1 排列的去重：使用(used[i - 1] == false)，即树层去重，效率更高"></a>3.4.4.1 排列的去重：<strong>使用(used[i - 1] == false)，即树层去重，效率更高</strong></h5><p>因为对于树层，如果重复元素相邻，那么如果前面的是false，肯定就已经是用过了</p><h4 id="3-4-5-去重问题"><a href="#3-4-5-去重问题" class="headerlink" title="3.4.5 去重问题"></a>3.4.5 去重问题</h4><p>用set和数组都可以，数组效率更高</p><h4 id="3-4-6-棋盘问题"><a href="#3-4-6-棋盘问题" class="headerlink" title="3.4.6 棋盘问题"></a>3.4.6 棋盘问题</h4><h5 id="3-4-6-1-N皇后："><a href="#3-4-6-1-N皇后：" class="headerlink" title="3.4.6.1 N皇后："></a>3.4.6.1 N皇后：</h5><p>二维矩阵中矩阵的高就是这颗树的高度，矩阵的宽就是树形结构中每一个节点的宽度。</p><p><strong>棋盘的宽度就是for循环的长度，递归的深度就是棋盘的高度</strong></p><h5 id="3-4-6-2-数独："><a href="#3-4-6-2-数独：" class="headerlink" title="3.4.6.2 数独："></a>3.4.6.2 数独：</h5><p>相较于N皇后，每一列每一行都只要放一个数字，只需要一层 for 循环遍历一行，递归来遍历列，然后一行一列确定皇后的唯一位置。</p><p><strong>棋盘的每一个位置都要放一个数字，并检查数字是否合法，解数独的树形结构要比N皇后更宽更深</strong></p><h3 id="3-5-17-电话号码的字母组合"><a href="#3-5-17-电话号码的字母组合" class="headerlink" title="3.5 17. 电话号码的字母组合"></a>3.5 <a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h3><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//记录数字对应字符串的映射</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] Keys = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        BackTracking(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), res, digits);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">BackTracking</span><span class="params">(StringBuilder prefix, List&lt;String&gt; res, <span class="keyword">final</span> String digits)</span>&#123;</span><br><span class="line">        <span class="comment">//递归中止条件</span></span><br><span class="line">        <span class="keyword">if</span>(prefix.length() == digits.length())&#123;</span><br><span class="line">            <span class="comment">//作为答案加入</span></span><br><span class="line">            res.add(prefix.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前应当映射的数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> digits.charAt(prefix.length()) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">//数字对应的字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> Keys[cur];</span><br><span class="line">        <span class="comment">//遍历其中的字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : letters.toCharArray())&#123;</span><br><span class="line">            <span class="comment">//添加字符</span></span><br><span class="line">            prefix.append(c);</span><br><span class="line">            <span class="comment">//以添加后的为基础递归</span></span><br><span class="line">            BackTracking(prefix,res,digits);</span><br><span class="line">            <span class="comment">//递归结束，回溯，移除当前的字符</span></span><br><span class="line">            prefix.deleteCharAt(prefix.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-93-复原IP地址"><a href="#3-6-93-复原IP地址" class="headerlink" title="3.6 93. 复原IP地址"></a>3.6 <a href="https://leetcode-cn.com/problems/restore-ip-addresses/">93. 复原IP地址</a></h3><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “192.168@1.1” 是 无效的 IP 地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//记录答案</span></span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//记录当前ip地址</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">curAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        backTracking(<span class="number">0</span>,curAddress,res,s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> k, StringBuilder curAddress, List&lt;String&gt; res, String s)</span>&#123;</span><br><span class="line">        <span class="comment">//递归中止条件，ip地址有四个数或者字符串为空</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">4</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//如果是有效的ip地址，加入答案中</span></span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">4</span> &amp;&amp; s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(curAddress.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//针对1，2，3位的ip地址逐个判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() &amp;&amp; i &lt;= <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//如果首位是零并且不是一位数，那么是无效的</span></span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从字符串中取出相应长度的数字</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">part</span> <span class="operator">=</span> s.substring(<span class="number">0</span>,i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//判断是否有效</span></span><br><span class="line">            <span class="keyword">if</span>(Integer.valueOf(part) &lt;= <span class="number">255</span>)&#123;</span><br><span class="line">                <span class="comment">//累加方式</span></span><br><span class="line">                <span class="keyword">if</span>(curAddress.length() != <span class="number">0</span>)&#123;</span><br><span class="line">                    part = <span class="string">&#x27;.&#x27;</span> + part;</span><br><span class="line">                &#125;</span><br><span class="line">                curAddress.append(part);</span><br><span class="line">                <span class="comment">//进行下一步的递归</span></span><br><span class="line">                backTracking(k+<span class="number">1</span>,curAddress,res,s.substring(i+<span class="number">1</span>));</span><br><span class="line">                <span class="comment">//取消上一层的状态</span></span><br><span class="line">                curAddress.delete(curAddress.length() - part.length(), curAddress.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-257-二叉树的所有路径"><a href="#3-7-257-二叉树的所有路径" class="headerlink" title="3.7 257. 二叉树的所有路径"></a>3.7 <a href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h3><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        helper(root,<span class="string">&quot;&quot;</span>,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//前序遍历，根-&gt;左-&gt;右</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(TreeNode root,String path,List&lt;String&gt; list)</span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)   <span class="keyword">return</span>;</span><br><span class="line">        path += Integer.toString(root.val);</span><br><span class="line">        <span class="comment">//如果到底了，复制path，加入答案</span></span><br><span class="line">        <span class="keyword">if</span>((root.left == <span class="literal">null</span>) &amp;&amp; (root.right == <span class="literal">null</span>))&#123; </span><br><span class="line">            list.add(path.toString());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            helper(root.left,path,list);</span><br><span class="line">            helper(root.right,path,list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-46-全排列"><a href="#3-8-46-全排列" class="headerlink" title="3.8 46. 全排列"></a>3.8 <a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h3><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//全排列</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//当前排列</span></span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//标记是否已经访问过</span></span><br><span class="line">        <span class="type">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        backTracking (cur, res, hasVisited, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">boolean</span>[] hasVisited, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="comment">//加入结果</span></span><br><span class="line">        <span class="keyword">if</span>(cur.size() == nums.length)&#123;</span><br><span class="line">            <span class="comment">//要新建，不然后面会被修改</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cur));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历可能的组合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hasVisited.length; i++)&#123;</span><br><span class="line">            <span class="comment">//如果已经访问过的，通过</span></span><br><span class="line">           <span class="keyword">if</span>(hasVisited[i])&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//加入答案，将访问标记置为true</span></span><br><span class="line">           hasVisited[i] = <span class="literal">true</span>;</span><br><span class="line">           cur.add(nums[i]); </span><br><span class="line">           <span class="comment">//回溯剩下的部分</span></span><br><span class="line">           backTracking(cur,res,hasVisited,nums);</span><br><span class="line">           <span class="comment">//移除之前回溯的状态</span></span><br><span class="line">           cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">           hasVisited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-47-全排列-II"><a href="#3-9-47-全排列-II" class="headerlink" title="3.9 47. 全排列 II"></a>3.9 <a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></h3><p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先进行排序，在遍历的时候判断这个元素是否等于上一个元素，如果等于，并且前一个元素还没有访问，那么跳过这个元素，或者是访问了跳过当前元素，需要跳过一个</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//全排列</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//当前排列</span></span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//标记是否已经访问过</span></span><br><span class="line">        <span class="type">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTracking(cur, res, hasVisited, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">boolean</span>[] hasVisited, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="comment">//加入结果</span></span><br><span class="line">        <span class="keyword">if</span>(cur.size() == nums.length)&#123;</span><br><span class="line">            <span class="comment">//要新建，不然后面会被修改</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cur));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历可能的组合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hasVisited.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !hasVisited[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果已经访问过的，通过</span></span><br><span class="line">           <span class="keyword">if</span>(hasVisited[i])&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//加入答案，将访问标记置为true</span></span><br><span class="line">           hasVisited[i] = <span class="literal">true</span>;</span><br><span class="line">           cur.add(nums[i]); </span><br><span class="line">           <span class="comment">//回溯剩下的部分</span></span><br><span class="line">           backTracking(cur,res,hasVisited,nums);</span><br><span class="line">           <span class="comment">//移除之前回溯的状态</span></span><br><span class="line">           cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">           hasVisited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-10-77-组合"><a href="#3-10-77-组合" class="headerlink" title="3.10 77. 组合"></a>3.10 <a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></h3><p>给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backTracking(cur, res, <span class="number">1</span>, k, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span> start, <span class="type">int</span> k, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">//如果有k个数了</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从起点开始遍历，因为有k个数那么作为起点，肯定不会大于n-k+1，可以用来剪枝</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n-k+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            cur.add(i);</span><br><span class="line">            <span class="comment">//下次递归起点加一</span></span><br><span class="line">            backTracking(cur, res, i+<span class="number">1</span>, k-<span class="number">1</span>, n);</span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-11-78-子集"><a href="#3-11-78-子集" class="headerlink" title="3.11 78. 子集"></a>3.11 <a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h3><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//对应不同长度的子集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; size &lt;= nums.length; size++)&#123;</span><br><span class="line">            backTracking(<span class="number">0</span>,size,nums,cur,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//start：状态变量，用来标识当前的选择列表的起始位置，控制选择列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> size, <span class="type">int</span>[] nums, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.size() == size)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            cur.add(nums[i]);</span><br><span class="line">            backTracking(i+<span class="number">1</span>,size,nums,cur,res);</span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-12-90-子集-II"><a href="#3-12-90-子集-II" class="headerlink" title="3.12 90. 子集 II"></a>3.12 <a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></h3><p>给定一个可能包含重复元素的整数数组 <strong><em>nums</em></strong>，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong>解集不能包含重复的子集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//对应不同长度的子集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; size &lt;= nums.length; size++)&#123;</span><br><span class="line">            backTracking(<span class="number">0</span>,size,nums,cur,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//start：状态变量，用来标识当前的选择列表的起始位置，控制选择列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> size, <span class="type">int</span>[] nums, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.size() == size)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从start到末尾，就是当前的选择列表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//去除当前选择列表中，与上一个数重复的数</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.add(nums[i]);</span><br><span class="line">            backTracking(i+<span class="number">1</span>,size,nums,cur,res);</span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-13-491-递增子序列"><a href="#3-13-491-递增子序列" class="headerlink" title="3.13 491. 递增子序列"></a>3.13 <a href="https://leetcode-cn.com/problems/increasing-subsequences/">491. 递增子序列</a></h3><p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意与子集的区别</span></span><br><span class="line"><span class="comment">//这里只要本层重复使用元素，递增子序列就会重复：如&#123;4，7，6，7&#125;，如果重复使用，会有两个&#123;4，7&#125;</span></span><br><span class="line"><span class="comment">//子集问题是看排序后相邻的相同元素是否重复使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//答案</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//路径</span></span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backTracking(res, path, <span class="number">0</span>,  nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, <span class="type">int</span> start,<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只负责记录本层是否重复使用了，新的一层会清空</span></span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">201</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((path.size() &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; path.get(path.size() - <span class="number">1</span>)) || used[nums[i]+<span class="number">100</span>] == <span class="literal">true</span>   )&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[nums[i] + <span class="number">100</span>] = <span class="literal">true</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(res,path,i+<span class="number">1</span>,nums);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-14-51-N-皇后"><a href="#3-14-51-N-皇后" class="headerlink" title="3.14 51. N 皇后"></a>3.14 <a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a></h3><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>二维矩阵中矩阵的高就是这颗树的高度，矩阵的宽就是树型结构中每一个节点的宽度。</p><p><strong>递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。</strong></p><p><strong>只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径：board 中小于 row 的那些行都已经成功放置了皇后</span></span><br><span class="line"><span class="comment">// 选择列表：第 row 行的所有列都是放置皇后的选择</span></span><br><span class="line"><span class="comment">// 结束条件：row 超过 board 的最后一行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] board = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c:board)&#123;</span><br><span class="line">            Arrays.fill(c,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        backTracking(board,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> row)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == board.length)&#123;</span><br><span class="line">            res.add(arrayToList(board));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; board.length; col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isValid(board,row,col))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            backTracking(board,row+<span class="number">1</span>);</span><br><span class="line">            board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">arrayToList</span><span class="params">(<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">        List&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c : board)&#123;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> i : c)&#123;</span><br><span class="line">                sb.append(i);</span><br><span class="line">            &#125;</span><br><span class="line">            temp.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为在每次递归的 for 循环中只会在同一行选一个，所有不用去重</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="comment">//因为下面的还没有放置，只需要检查上面即可</span></span><br><span class="line">        <span class="comment">// 检查列是否有皇后互相冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查右上方是否有皇后互相冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>;</span><br><span class="line">             i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查左上方是否有皇后互相冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>;</span><br><span class="line">             i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-15-时间复杂度"><a href="#3-15-时间复杂度" class="headerlink" title="3.15 时间复杂度"></a>3.15 时间复杂度</h3><p>子集问题分析：</p><ul><li>时间复杂度：O(n <em> 2^n)，因为每一个元素的状态无外乎取与不取，所以时间复杂度为O(2^n)，构造每一组子集都需要填进数组，又有需要O(n)，最终时间复杂度：O(n </em> 2^n)</li><li>空间复杂度：O(n)，递归深度为n，所以系统栈所用空间为O(n)，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为O(n)</li></ul><p>排列问题分析：</p><ul><li>时间复杂度：O(n!)，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n <em> n-1 </em> n-2 * ….. 1 = n!。</li><li>空间复杂度：O(n)，和子集问题同理。</li></ul><p>组合问题分析：</p><ul><li>时间复杂度：O(n * 2^n)，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。</li><li>空间复杂度：O(n)，和子集问题同理。</li></ul><p>N皇后问题分析：</p><ul><li>时间复杂度：O(n!) ，其实如果看树形图的话，直觉上是O(n^n)，但皇后之间不能见面所以在搜索的过程中是有剪枝的，最差也就是O（n!），n!表示n <em> (n-1) </em> …. * 1。</li><li>空间复杂度：O(n)，和子集问题同理。</li></ul><p>解数独问题分析：</p><ul><li>时间复杂度：O(9^m) , m是’.’的数目。</li><li>空间复杂度：O(n^2)，递归的深度是n^2</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h2 id=&quot;1-BFS&quot;&gt;&lt;a href=&quot;#1-BFS&quot; class=&quot;headerlink&quot; title=&quot;1 BFS&quot;&gt;&lt;/a&gt;1 BFS&lt;/h2&gt;&lt;p&gt;广度优先搜索一层一层的进行遍历，每次遍历以上层遍历的结果作为起点，遍</summary>
      
    
    
    
    
    <category term="Algorithm" scheme="https://stardustorz.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>[Algorithm] Tree</title>
    <link href="https://stardustorz.github.io/2025/07/25/Algorithm/Tree/"/>
    <id>https://stardustorz.github.io/2025/07/25/Algorithm/Tree/</id>
    <published>2025-07-25T10:10:13.000Z</published>
    <updated>2025-08-03T14:28:51.023Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置  进入节点的时候 </span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    <span class="comment">// 中序位置左子树遍历完成</span></span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">// 后序位置  离开节点的时候</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历一遍二叉树得出答案  </span></span><br><span class="line"><span class="comment">// 通过分解问题计算出答案 定义递归函数完成</span></span><br><span class="line"><span class="comment">// 只有后序位置才能通过返回值获取子树的信息。</span></span><br><span class="line"><span class="comment">// 二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，</span></span><br><span class="line"><span class="comment">// 去达到自己的目的，你只需要单独思考每一个节点应该做什么</span></span><br></pre></td></tr></table></figure><h2 id="1-遍历"><a href="#1-遍历" class="headerlink" title="1 遍历"></a>1 遍历</h2><h3 id="1-1-前序遍历"><a href="#1-1-前序遍历" class="headerlink" title="1.1 前序遍历"></a>1.1 前序遍历</h3><p>思路：根节点-&gt;左子树-&gt;右子树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            preorderTraversal(root.left);</span><br><span class="line">            preorderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归，用栈实现，先访问父节点，先压右再压左</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="comment">// 倒过来，因为栈后面压入先出</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-中序遍历"><a href="#1-2-中序遍历" class="headerlink" title="1.2 中序遍历"></a>1.2 中序遍历</h3><p>思路：左子树-&gt;根节点-&gt;右子树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            inorderTraversal(root.left);</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            inorderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归 先压左节点，然后从最后一个左节点开始访问，如果有右节点则访问</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//中序遍历结束的条件是栈空，并且树中全部节点都已经被压入栈</span></span><br><span class="line">        <span class="keyword">while</span>(stack.size() &gt; <span class="number">0</span> || root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//从root开始，将root的左节点全部压入</span></span><br><span class="line">            <span class="comment">//这里是为了剔除右节点为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//压入后，从最左开始访问</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                res.add(node.val);</span><br><span class="line">                root = node.right;<span class="comment">//如果有右节点，那么将在下一个循环中被压入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-后序遍历"><a href="#1-3-后序遍历" class="headerlink" title="1.3 后序遍历"></a>1.3 后序遍历</h3><p>思路：左子树-&gt;右子树-&gt;根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归的比较简单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归，可以将前序修改成根右左，倒序就是后序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val); <span class="comment">//根节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) stack.push(node.left);<span class="comment">//先压左再压右</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);<span class="comment">//倒序结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-987-二叉树的垂序遍历"><a href="#1-4-987-二叉树的垂序遍历" class="headerlink" title="1.4 987. 二叉树的垂序遍历"></a>1.4 <a href="https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/">987. 二叉树的垂序遍历</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录每个节点和对应的坐标 (row, col)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Triple</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> row, col;</span><br><span class="line">        <span class="keyword">public</span> TreeNode node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Triple</span><span class="params">(TreeNode node, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.node = node;</span><br><span class="line">            <span class="built_in">this</span>.row = row;</span><br><span class="line">            <span class="built_in">this</span>.col = col;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">verticalTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历二叉树，并且为所有节点生成对应的坐标</span></span><br><span class="line">        traverse(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 根据题意，根据坐标值对所有节点进行排序：</span></span><br><span class="line">        <span class="comment">// 按照 col 从小到大排序，col 相同的话按 row 从小到大排序，</span></span><br><span class="line">        <span class="comment">// 如果 col 和 row 都相同，按照 node.val 从小到大排序。</span></span><br><span class="line">        Collections.sort(nodes, (Triple a, Triple b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.col == b.col &amp;&amp; a.row == b.row) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.node.val - b.node.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a.col == b.col) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.row - b.row;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a.col - b.col;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 将排好序的节点组装成题目要求的返回格式</span></span><br><span class="line">        LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 记录上一列编号，初始化一个特殊值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preCol</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">            <span class="type">Triple</span> <span class="variable">cur</span> <span class="operator">=</span> nodes.get(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.col != preCol) &#123;</span><br><span class="line">                <span class="comment">// 开始记录新的一列</span></span><br><span class="line">                res.addLast(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">                preCol = cur.col;</span><br><span class="line">            &#125;</span><br><span class="line">            res.getLast().add(cur.node.val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Triple&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 二叉树遍历函数，记录所有节点对应的坐标</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录坐标</span></span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">Triple</span>(root, row, col));</span><br><span class="line">        <span class="comment">// 二叉树遍历框架</span></span><br><span class="line">        traverse(root.left, row + <span class="number">1</span>, col - <span class="number">1</span>);</span><br><span class="line">        traverse(root.right, row + <span class="number">1</span>, col + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-236-二叉树的最近公共祖先"><a href="#1-5-236-二叉树的最近公共祖先" class="headerlink" title="1.5 236. 二叉树的最近公共祖先"></a>1.5 <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果root是最近的公共祖先，那么有三种情况：</span></span><br><span class="line"><span class="comment">//p和q在root的左右子树中；p=root，q在p的子树中；q=root，p在q的子树中</span></span><br><span class="line"><span class="comment">//递归对二叉树进行后序遍历：（左右中）遇到p或q返回</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">//中止条件：越过了叶子节点或者找到了p或q</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">//如果都为空，都没有，返回</span></span><br><span class="line">        <span class="comment">//都不空，返回root</span></span><br><span class="line">        <span class="comment">//有一个空，另一个就是最近公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-993-二叉树的堂兄弟节点"><a href="#1-6-993-二叉树的堂兄弟节点" class="headerlink" title="1.6 993. 二叉树的堂兄弟节点"></a>1.6 <a href="https://leetcode.cn/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a></h3><p>如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">parentX</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">parentY</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">depthX</span> <span class="operator">=</span> <span class="number">0</span>, depthY = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCousins</span><span class="params">(TreeNode root, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        traverse(root, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (depthX == depthY &amp;&amp; parentX != parentY) &#123;</span><br><span class="line">            <span class="comment">// 判断 x，y 是否是表兄弟节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> depth, TreeNode parent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == x) &#123;</span><br><span class="line">            <span class="comment">// 找到 x，记录它的深度和父节点</span></span><br><span class="line">            parentX = parent;</span><br><span class="line">            depthX = depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == y) &#123;</span><br><span class="line">            <span class="comment">// 找到 y，记录它的深度和父节点</span></span><br><span class="line">            parentY = parent;</span><br><span class="line">            depthY = depth;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root.left, depth + <span class="number">1</span>, root);</span><br><span class="line">        traverse(root.right, depth + <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-二叉树的下一个节点"><a href="#1-7-二叉树的下一个节点" class="headerlink" title="1.7 二叉树的下一个节点"></a>1.7 二叉树的下一个节点</h3><p>给定二叉树其中的一个结点，请找出其中序遍历顺序的下一个结点并且返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;TreeLinkNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeLinkNode <span class="title function_">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeLinkNode</span> <span class="variable">root</span> <span class="operator">=</span> pNode;</span><br><span class="line">        <span class="comment">// 找到父节点</span></span><br><span class="line">        <span class="keyword">while</span>(root.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            root = root.next;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size()-<span class="number">1</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list.get(i) == pNode) <span class="keyword">return</span> list.get(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeLinkNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        list.add(root);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有右子树，则找右子树的最左节点</span></span><br><span class="line"><span class="comment">//没右子树</span></span><br><span class="line"><span class="comment">//若x是父节点的左孩子。则x的父节点就是x的下一个节点。</span></span><br><span class="line"><span class="comment">//若x是父节点的右孩子。则沿着父节点向上，直到找到一个节点的父节点的左孩子是该节点，</span></span><br><span class="line"><span class="comment">//则该节点的父节点就是x的下一个节点</span></span><br></pre></td></tr></table></figure><h3 id="1-8-剑指-Offer-07-重建二叉树"><a href="#1-8-剑指-Offer-07-重建二叉树" class="headerlink" title="1.8 剑指 Offer 07. 重建二叉树"></a>1.8 <a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h3><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序第一个是根节点，而在中序的该值的左边是左子树，右边是右子树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder[<span class="number">0</span>] == inorder[i])&#123;</span><br><span class="line">                root.left = buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(inorder,<span class="number">0</span>,i));</span><br><span class="line">                root.right = buildTree(Arrays.copyOfRange(preorder,i+<span class="number">1</span>,preorder.length),Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Arrays.copyOfRange(T[ ] original,int from,int to)将一个原始的数组original，从下标from开始复制，复制到上标to，生成一个新的数组。注意这里包括下标from，不包括上标to。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] preorder;</span><br><span class="line">    <span class="comment">//可以用来查找根节点在中序中的对应位置</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++)</span><br><span class="line">            dic.put(inorder[i], i);</span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//root是根节点在前序中的位置，left，right是中序遍历中的边界</span></span><br><span class="line">    TreeNode <span class="title function_">recur</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;                          <span class="comment">// 递归终止</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[root]);          <span class="comment">// 建立根节点</span></span><br><span class="line">        <span class="comment">//找到左右子树的划分点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dic.get(preorder[root]);                       <span class="comment">// 划分根节点、左子树、右子树</span></span><br><span class="line">        <span class="comment">//左子树的根节点，左边界不变</span></span><br><span class="line">        node.left = recur(root + <span class="number">1</span>, left, i - <span class="number">1</span>);              <span class="comment">// 开启左子树递归</span></span><br><span class="line">        <span class="comment">//右子树的根节点就是根节点加上左子树长度加一</span></span><br><span class="line">        node.right = recur(root + i - left + <span class="number">1</span>, i + <span class="number">1</span>, right); <span class="comment">// 开启右子树递归</span></span><br><span class="line">        <span class="keyword">return</span> node;                                           <span class="comment">// 回溯返回根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-9-106-从中序与后序遍历序列构造二叉树"><a href="#1-9-106-从中序与后序遍历序列构造二叉树" class="headerlink" title="1.9 106. 从中序与后序遍历序列构造二叉树"></a>1.9 <a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h3><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储 inorder 中值到索引的映射</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; valToIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            valToIndex.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>,</span><br><span class="line">                    postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       定义：</span></span><br><span class="line"><span class="comment">       中序遍历数组为 inorder[inStart..inEnd]，</span></span><br><span class="line"><span class="comment">       后序遍历数组为 postorder[postStart..postEnd]，</span></span><br><span class="line"><span class="comment">       构造这个二叉树并返回该二叉树的根节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd,</span></span><br><span class="line"><span class="params">                <span class="type">int</span>[] postorder, <span class="type">int</span> postStart, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// root 节点对应的值就是后序遍历数组的最后一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> postorder[postEnd];</span><br><span class="line">        <span class="comment">// rootVal 在中序遍历数组中的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> valToIndex.get(rootVal);</span><br><span class="line">        <span class="comment">// 左子树的节点个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - inStart;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">// 递归构造左右子树</span></span><br><span class="line">        root.left = build(inorder, inStart, index - <span class="number">1</span>,</span><br><span class="line">                         postorder, postStart, postStart + leftSize - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        root.right = build(inorder, index + <span class="number">1</span>, inEnd,</span><br><span class="line">                          postorder, postStart + leftSize, postEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-10-257-二叉树的所有路径"><a href="#1-10-257-二叉树的所有路径" class="headerlink" title="1.10 257. 二叉树的所有路径"></a>1.10 <a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h3><p>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        helper(root,<span class="string">&quot;&quot;</span>,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(TreeNode root,String path,List&lt;String&gt; list)</span>&#123;  <span class="comment">//前序遍历，根-&gt;左-&gt;右</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)   <span class="keyword">return</span>;</span><br><span class="line">        path += Integer.toString(root.val);</span><br><span class="line">        <span class="keyword">if</span>((root.left == <span class="literal">null</span>) &amp;&amp; (root.right == <span class="literal">null</span>))&#123;  <span class="comment">//如果到底了，复制path，加入答案</span></span><br><span class="line">            list.add(path.toString());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            helper(root.left,path,list);</span><br><span class="line">            helper(root.right,path,list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-11-297-二叉树的序列化与反序列化"><a href="#1-11-297-二叉树的序列化与反序列化" class="headerlink" title="1.11 297. 二叉树的序列化与反序列化"></a>1.11 <a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">SEP</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">NULL</span> <span class="operator">=</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主函数，将二叉树序列化为字符串 */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        serialize(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 辅助函数，将二叉树存入 StringBuilder */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            sb.append(NULL).append(SEP);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/******前序遍历位置******/</span></span><br><span class="line">        sb.append(root.val).append(SEP);</span><br><span class="line">        serialize(root.left, sb);</span><br><span class="line">        serialize(root.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主函数，将字符串反序列化为二叉树结构 */</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="comment">// 将字符串转化成列表</span></span><br><span class="line">        LinkedList&lt;String&gt; nodes = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : data.split(SEP)) &#123;</span><br><span class="line">            nodes.addLast(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(nodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 辅助函数，通过 nodes 列表构造二叉树 */</span></span><br><span class="line">    TreeNode <span class="title function_">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/******前序遍历位置******/</span></span><br><span class="line">        <span class="comment">// 列表最左侧就是根节点</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> nodes.removeFirst();</span><br><span class="line">        <span class="keyword">if</span> (first.equals(NULL)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(first));</span><br><span class="line">        <span class="comment">// 会把左子树的元素全部移除</span></span><br><span class="line">        root.left = deserialize(nodes);</span><br><span class="line">        root.right = deserialize(nodes);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-12-124-二叉树中的最大路径和"><a href="#1-12-124-二叉树中的最大路径和" class="headerlink" title="1.12 124. 二叉树中的最大路径和"></a>1.12 <a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h3><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在后序遍历的时候顺便计算题目要求的最大路径和。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算单边路径和时顺便计算最大路径和</span></span><br><span class="line">        oneSideMax(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：计算从根节点 root 为起点的最大单边路径和</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">oneSideMax</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMaxSum</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, oneSideMax(root.left));</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMaxSum</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, oneSideMax(root.right));</span><br><span class="line">        <span class="comment">// 后序遍历位置，顺便更新最大路径和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pathMaxSum</span> <span class="operator">=</span> root.val + leftMaxSum + rightMaxSum;</span><br><span class="line">        res = Math.max(res, pathMaxSum);</span><br><span class="line">        <span class="comment">// 实现函数定义，左右子树的最大单边路径和加上根节点的值</span></span><br><span class="line">        <span class="comment">// 就是从根节点 root 为起点的最大单边路径和</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftMaxSum, rightMaxSum) + root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-13-114-二叉树展开为链表"><a href="#1-13-114-二叉树展开为链表" class="headerlink" title="1.13 114. 二叉树展开为链表"></a>1.13 <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h3><p>给你二叉树的根结点 root ，请你将它展开为一个单链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：将以 root 为根的树拉平为链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 先递归拉平左右子树</span></span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/****后序遍历位置****/</span></span><br><span class="line">        <span class="comment">// 1、左右子树已经被拉平成一条链表</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、将左子树作为右子树</span></span><br><span class="line">        root.left = <span class="literal">null</span>;</span><br><span class="line">        root.right = left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、将原先的右子树接到当前右子树的末端</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (p.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        p.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-14-623-在二叉树中增加一行"><a href="#1-14-623-在二叉树中增加一行" class="headerlink" title="1.14 623. 在二叉树中增加一行"></a>1.14 <a href="https://leetcode.cn/problems/add-one-row-to-tree/">623. 在二叉树中增加一行</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> targetVal, targetDepth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">addOneRow</span><span class="params">(TreeNode root, <span class="type">int</span> val, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        targetVal = val;</span><br><span class="line">        targetDepth = depth;</span><br><span class="line">        <span class="comment">// 插入到第一行的话特殊对待一下</span></span><br><span class="line">        <span class="keyword">if</span> (targetDepth == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">newRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(targetVal);</span><br><span class="line">            newRoot.left = root;</span><br><span class="line">            <span class="keyword">return</span> newRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历二叉树，走到对应行进行插入</span></span><br><span class="line">        traverse(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">curDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        curDepth++;</span><br><span class="line">        <span class="keyword">if</span> (curDepth == targetDepth - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 进行插入</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">newLeft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(targetVal);</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">newRight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(targetVal);</span><br><span class="line">            newLeft.left = root.left;</span><br><span class="line">            newRight.right = root.right;</span><br><span class="line">            root.left = newLeft;</span><br><span class="line">            root.right = newRight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        curDepth--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-15-654-最大二叉树"><a href="#1-15-654-最大二叉树" class="headerlink" title="1.15 654. 最大二叉树"></a>1.15 <a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/* 主函数 */</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义：将 nums[lo..hi] 构造成符合条件的树，返回根节点 */</span></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (lo &gt; hi) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到数组中的最大值和对应的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>, maxVal = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxVal &lt; nums[i]) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxVal);</span><br><span class="line">        <span class="comment">// 递归调用构造左右子树</span></span><br><span class="line">        root.left = build(nums, lo, index - <span class="number">1</span>);</span><br><span class="line">        root.right = build(nums, index + <span class="number">1</span>, hi);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-16-814-二叉树剪枝"><a href="#1-16-814-二叉树剪枝" class="headerlink" title="1.16 814. 二叉树剪枝"></a>1.16 <a href="https://leetcode.cn/problems/binary-tree-pruning/">814. 二叉树剪枝</a></h3><p>给你二叉树的根结点 root ，此外树的每个结点的值要么是 0 ，要么是 1 。</p><p>返回移除了所有不包含 1 的子树的原二叉树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：输入一棵二叉树，返回的二叉树叶子节点都是 1</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">pruneTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二叉树递归框架</span></span><br><span class="line">        root.left = pruneTree(root.left);</span><br><span class="line">        root.right = pruneTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历位置，判断自己是否是值为 0 的叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == <span class="number">0</span> &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回值会被父节点接收，相当于把自己删掉了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不是，正常返回</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-层序遍历"><a href="#2-层序遍历" class="headerlink" title="2 层序遍历"></a>2 层序遍历</h2><h3 id="2-1-102-二叉树的层序遍历"><a href="#2-1-102-二叉树的层序遍历" class="headerlink" title="2.1 102. 二叉树的层序遍历"></a>2.1 <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="comment">// 记录当前层的节点，并将下一层的入队</span></span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                level.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>)</span><br><span class="line">                    q.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>)</span><br><span class="line">                    q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-103-二叉树的锯齿形层序遍历"><a href="#2-2-103-二叉树的锯齿形层序遍历" class="headerlink" title="2.2 103. 二叉树的锯齿形层序遍历"></a>2.2 <a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h3><p>即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt;  queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            queue.offer(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置标记，记录顺序</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;   </span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    level.add(node.val);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 倒过来添加到队列里面</span></span><br><span class="line">                    level.add(<span class="number">0</span>,node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">            flag = !flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-662-二叉树最大宽度"><a href="#2-3-662-二叉树最大宽度" class="headerlink" title="2.3 662. 二叉树最大宽度"></a>2.3 <a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a></h3><p>给你一棵二叉树的根节点 root ，返回树的 <strong>最大宽度</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据完全二叉树的概念，i位置节点的左子节点位置为2i，右子节点位置为2i+1；</span></span><br><span class="line"><span class="comment">//通过一个list记录节点对应的完全二叉树中的位置</span></span><br><span class="line"><span class="comment">//按层BFS二叉树，记录下list中每一层的前后位置之差，返回最大</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//节点队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();   </span><br><span class="line">        <span class="comment">//节点位置队列</span></span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        res.add(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">cur</span> <span class="operator">=</span> res.removeFirst();</span><br><span class="line">                <span class="comment">// 相应的位置也加入辅助队列</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                    res.add(cur*<span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                    res.add(cur * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最大宽度</span></span><br><span class="line">            <span class="keyword">if</span>(res.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                ans = Math.max(ans,res.getLast() - res.getFirst() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-958-二叉树的完全性检验"><a href="#2-4-958-二叉树的完全性检验" class="headerlink" title="2.4 958. 二叉树的完全性检验"></a>2.4 <a href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">958. 二叉树的完全性检验</a></h3><p>给定一个二叉树的 root ，确定它是否是一个 <em>完全二叉树</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历，判断是否出现过null</span></span><br><span class="line"><span class="comment">//通过一个 flag 进行记录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompleteTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//判断是否出现过null</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size ; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;<span class="comment">//如果当前节点不是null</span></span><br><span class="line">                    <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果之前出现就直接返回</span></span><br><span class="line">                    queue.add(node.left);<span class="comment">//不管有没有子节点，都加入</span></span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-222-完全二叉树的节点个数"><a href="#2-5-222-完全二叉树的节点个数" class="headerlink" title="2.5 222. 完全二叉树的节点个数"></a>2.5 <a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h3><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> countLevel(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> countLevel(root.right);</span><br><span class="line">        <span class="comment">// 层数一样，左边满，不一样，右边满</span></span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="comment">// 位运算 2^left</span></span><br><span class="line">            <span class="keyword">return</span> countNodes(root.right) + (<span class="number">1</span>&lt;&lt;left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> countNodes(root.left) + (<span class="number">1</span>&lt;&lt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countLevel</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            level++;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-199-二叉树的右视图"><a href="#2-6-199-二叉树的右视图" class="headerlink" title="2.6 199. 二叉树的右视图"></a>2.6 <a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h3><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* BFS 层序遍历解法 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// BFS 层序遍历，计算右侧视图</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="comment">// while 循环控制从上向下一层层遍历</span></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="comment">// 每一层头部就是最右侧的元素</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">last</span> <span class="operator">=</span> q.peek();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="comment">// 控制每一层从右向左遍历</span></span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每一层的最后一个节点就是二叉树的右侧视图</span></span><br><span class="line">            res.add(last.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DFS 递归遍历解法 */</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录递归的层数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView_DFS</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二叉树遍历函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历位置</span></span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">if</span> (res.size() &lt; depth) &#123;</span><br><span class="line">            <span class="comment">// 这一层还没有记录值</span></span><br><span class="line">            <span class="comment">// 说明 root 就是右侧视图的第一个节点</span></span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意，这里反过来，先遍历右子树再遍历左子树</span></span><br><span class="line">        <span class="comment">// 这样首先遍历的一定是右侧节点</span></span><br><span class="line">        traverse(root.right);</span><br><span class="line">        traverse(root.left);</span><br><span class="line">        <span class="comment">// 后序遍历位置</span></span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-递归"><a href="#3-递归" class="headerlink" title="3 递归"></a>3 递归</h2><h3 id="3-1-112-路径总和"><a href="#3-1-112-路径总和" class="headerlink" title="3.1 112. 路径总和"></a>3.1 <a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h3><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//为空节点，false</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; root.val == sum)&#123; <span class="comment">//当路径总和等于目标且为叶子节点时，true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left,sum - root.val) || hasPathSum(root.right,sum - root.val);</span><br><span class="line">    &#125;  <span class="comment">//从当前节点的左右继续往下递归，目标值减去当前节点值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-113-路径总和-II"><a href="#3-2-113-路径总和-II" class="headerlink" title="3.2 113. 路径总和 II"></a>3.2 <a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h3><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java 文档中 Stack 类建议使用 Deque 代替 Stack，注意：只使用栈的相关接口</span></span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dfs(root, sum, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pathSum</span><span class="params">(TreeNode node, <span class="type">int</span> sum, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归终止条件 1：遇到空结点不再递归调用</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 沿途结点必须选择，这个时候要做两件事：1、sum 减去这个结点的值；2、添加到 path 里</span></span><br><span class="line">        sum -= node.val;</span><br><span class="line">        path.addLast(node.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归终止条件 2：遇到叶子结点，sum 恰好为 0，说明从根结点到叶子结点的路径是一个符合要求的解</span></span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span> &amp;&amp; node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// path 全局只有一份，必须做拷贝</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="comment">// 注意：这里 return 之前必须重置</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pathSum(node.left, sum, path, res);</span><br><span class="line">        pathSum(node.right, sum, path, res);</span><br><span class="line">        <span class="comment">// 递归完成以后，必须重置变量</span></span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    dfs(root, sum, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> sum, List&lt;Integer&gt; list,</span></span><br><span class="line"><span class="params">                List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">    <span class="comment">//如果节点为空直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//因为list是引用传递，为了防止递归的时候分支污染，我们要在每个路径</span></span><br><span class="line">    <span class="comment">//中都要新建一个subList</span></span><br><span class="line">    List&lt;Integer&gt; subList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">    <span class="comment">//把当前节点值加入到subList中</span></span><br><span class="line">    subList.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(root.val));</span><br><span class="line">    <span class="comment">//如果到达叶子节点，就不能往下走了，直接return</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果到达叶子节点，并且sum等于叶子节点的值，说明我们找到了一组，</span></span><br><span class="line">        <span class="comment">//要把它放到result中</span></span><br><span class="line">        <span class="keyword">if</span> (sum == root.val)</span><br><span class="line">            result.add(subList);</span><br><span class="line">        <span class="comment">//到叶子节点之后直接返回，因为在往下就走不动了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没到达叶子节点，就继续从他的左右两个子节点往下找，注意到</span></span><br><span class="line">    <span class="comment">//下一步的时候，sum值要减去当前节点的值</span></span><br><span class="line">    dfs(root.left, sum - root.val, subList, result);</span><br><span class="line">    dfs(root.right, sum - root.val, subList, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-437-路径总和-III"><a href="#3-3-437-路径总和-III" class="headerlink" title="3.3 437. 路径总和 III"></a>3.3 <a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h3><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 <strong>路径</strong> 的数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//因为未必是要从根节点开始，因此需要对所有节点进行递归判断</span></span><br><span class="line">        <span class="keyword">return</span> pathSumFromRoot(root,sum) + pathSum(root.left,sum) + pathSum(root.right,sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">pathSumFromRoot</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span>&#123; <span class="comment">//递归判断从当前节点是否有满足条件的路径</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum == root.val) ret++;</span><br><span class="line">        ret += pathSumFromRoot(root.left, sum - root.val) + pathSumFromRoot(root.right, sum - root.val);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-572-另一棵树的子树"><a href="#3-4-572-另一棵树的子树" class="headerlink" title="3.4 572. 另一棵树的子树"></a>3.4 <a href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></h3><p>给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//因为未必是要从根节点开始，因此需要对所有节点进行递归判断</span></span><br><span class="line">        <span class="keyword">return</span> isSubtree(s.left,t) || isSubtree(s.right,t) || isSubtreeFromRoot(s,t);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSubtreeFromRoot</span><span class="params">(TreeNode s, TreeNode t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> &amp;&amp; t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> || t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.val != t.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSubtreeFromRoot(s.left,t.left) &amp;&amp; isSubtreeFromRoot(s.right,t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-111-二叉树的最小深度"><a href="#3-5-111-二叉树的最小深度" class="headerlink" title="3.5 111. 二叉树的最小深度"></a>3.5 <a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h3><p>给定一个二叉树，找出其最小深度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> minDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> minDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> || right == <span class="number">0</span>) <span class="keyword">return</span> left+right+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.min(left , right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-101-对称二叉树"><a href="#3-6-101-对称二叉树" class="headerlink" title="3.6 101. 对称二叉树"></a>3.6 <a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMirror</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> &amp;&amp; t2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> || t2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">            (t1.val == t2.val)</span><br><span class="line">            &amp;&amp; isMirror(t1.right, t2.left)</span><br><span class="line">            &amp;&amp; isMirror(t1.left, t2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-404-左叶子之和"><a href="#3-7-404-左叶子之和" class="headerlink" title="3.7 404. 左叶子之和"></a>3.7 <a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h3><p>给定二叉树的根节点 root ，返回所有左叶子之和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是不是左叶子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(isLeaf(root.left))&#123;</span><br><span class="line">            left = root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">(TreeNode root)</span>&#123; <span class="comment">//判断是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-687-最长同值路径"><a href="#3-8-687-最长同值路径" class="headerlink" title="3.8 687. 最长同值路径"></a>3.8 <a href="https://leetcode.cn/problems/longest-univalue-path/">687. 最长同值路径</a></h3><p>给定一个二叉树的 root ，返回 <em>最长的路径的长度</em> ，这个路径中的 <em>每个节点具有相同值</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestUnivaluePath</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在后序遍历的位置更新 res</span></span><br><span class="line">        maxLen(root, root.val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：计算以 root 为根的这棵二叉树中，从 root 开始值为 parentVal 的最长树枝长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">maxLen</span><span class="params">(TreeNode root, <span class="type">int</span> parentVal)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用函数定义，计算左右子树值为 root.val 的最长树枝长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLen</span> <span class="operator">=</span> maxLen(root.left, root.val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLen</span> <span class="operator">=</span> maxLen(root.right, root.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历位置顺便更新全局变量</span></span><br><span class="line">        <span class="comment">// 同值路径就是左右同值树枝长度之和</span></span><br><span class="line">        res = Math.max(res, leftLen + rightLen);</span><br><span class="line">        <span class="comment">// 如果 root 本身和上级值不同，那么整棵子树都不可能有同值树枝</span></span><br><span class="line">        <span class="keyword">if</span> (root.val != parentVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现函数的定义：</span></span><br><span class="line">        <span class="comment">// 以 root 为根的二叉树从 root 开始值为 parentVal 的最长树枝长度</span></span><br><span class="line">        <span class="comment">// 等于左右子树的最长树枝长度的最大值加上 root 节点本身</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span> + Math.max(leftLen, rightLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-337-打家劫舍-III"><a href="#3-9-337-打家劫舍-III" class="headerlink" title="3.9 337. 打家劫舍 III"></a>3.9 <a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h3><p>给定二叉树的 root 。返回 <strong><em>在不触动警报的情况下\</em></strong> <em>，小偷能够盗取的最高金额</em> 。</p><p>如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//设置备忘录，记录打劫该点的最大收益</span></span><br><span class="line">    Map&lt;TreeNode, Integer&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 移除子问题</span></span><br><span class="line">        <span class="keyword">if</span>(memo.containsKey(root)) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo.get(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">doRob</span> <span class="operator">=</span> root.val</span><br><span class="line">                + (root.left == <span class="literal">null</span> ?</span><br><span class="line">                <span class="number">0</span> : rob(root.left.left) + rob(root.left.right))</span><br><span class="line">                + (root.right == <span class="literal">null</span> ?</span><br><span class="line">                <span class="number">0</span> : rob(root.right.left) + rob(root.right.right));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">notRob</span> <span class="operator">=</span> rob(root.left) + rob(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(doRob, notRob);</span><br><span class="line">        memo.put(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-10-671-二叉树中第二小的节点"><a href="#3-10-671-二叉树中第二小的节点" class="headerlink" title="3.10 671. 二叉树中第二小的节点"></a>3.10 <a href="https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/">671. 二叉树中第二小的节点</a></h3><p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归中止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">//如果为空节点，返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">//如果没有子节点，返回-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> root.left.val;  <span class="comment">//左节点的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> root.right.val;  <span class="comment">//右节点的值</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == left) left = findSecondMinimumValue(root.left);  <span class="comment">//如果左节点和根节点的值相同，第二小的从左子树上寻找</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == right) right = findSecondMinimumValue(root.right);  <span class="comment">//如果和右节点还是相同，则找出右子树的第二小</span></span><br><span class="line">        </span><br><span class="line">       <span class="comment">//返回情况</span></span><br><span class="line">        <span class="keyword">if</span>(left != -<span class="number">1</span> &amp;&amp; right != -<span class="number">1</span>) <span class="keyword">return</span> Math.min(left,right);  <span class="comment">//如果左右都不是-1，返回其中的最小</span></span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>) <span class="keyword">return</span> right;  <span class="comment">//如果左边没有，那就返回右边</span></span><br><span class="line">        <span class="keyword">return</span> left;<span class="comment">//否则返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-11-110-平衡二叉树"><a href="#3-11-110-平衡二叉树" class="headerlink" title="3.11 110. 平衡二叉树"></a>3.11 <a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxDepth(root);</span><br><span class="line">        <span class="keyword">return</span> isBalanced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录二叉树是否平衡</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isBalanced</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入一个节点，返回以该节点为根的二叉树的最大深度</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMaxDepth</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMaxDepth</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历位置</span></span><br><span class="line">        <span class="comment">// 如果左右最大深度大于 1，就不是平衡二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (Math.abs(rightMaxDepth - leftMaxDepth) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            isBalanced = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftMaxDepth, rightMaxDepth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-12-104-二叉树的最大深度"><a href="#3-12-104-二叉树的最大深度" class="headerlink" title="3.12 104. 二叉树的最大深度"></a>3.12 <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 前序遍历位置</span></span><br><span class="line">        depth++;</span><br><span class="line">        res = Math.max(res, depth);</span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line">        <span class="comment">// 后序遍历位置</span></span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：输入一个节点，返回以该节点为根的二叉树的最大深度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="comment">// 根据左右子树的最大深度推出原二叉树的最大深度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftMax, rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-13-129-求根节点到叶节点数字之和"><a href="#3-13-129-求根节点到叶节点数字之和" class="headerlink" title="3.13 129. 求根节点到叶节点数字之和"></a>3.13 <a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历一遍二叉树就能出结果</span></span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二叉树遍历函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历位置，记录节点值</span></span><br><span class="line">        path.append(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 到达叶子节点，累加路径和</span></span><br><span class="line">            res += Integer.parseInt(path.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二叉树递归框架，遍历左右子树</span></span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后续遍历位置，撤销节点值</span></span><br><span class="line">        path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-14-543-二叉树的直径"><a href="#3-14-543-二叉树的直径" class="headerlink" title="3.14 543. 二叉树的直径"></a>3.14 <a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDiameter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxDepth(root);</span><br><span class="line">        <span class="keyword">return</span> maxDiameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="comment">// 后序遍历位置顺便计算最大直径</span></span><br><span class="line">        maxDiameter = Math.max(maxDiameter, leftMax + rightMax);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftMax, rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-15-226-翻转二叉树"><a href="#3-15-226-翻转二叉树" class="headerlink" title="3.15 226. 翻转二叉树"></a>3.15 <a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 「遍历」的思路</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历二叉树，交换每个节点的子节点</span></span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二叉树遍历函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**** 前序位置 ****/</span></span><br><span class="line">        <span class="comment">// 每一个节点需要做的事就是交换它的左右子节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历框架，去遍历左右子树的节点</span></span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 「分解问题」的思路</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：将以 root 为根的这棵二叉树翻转，返回翻转后的二叉树的根节点</span></span><br><span class="line">    TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用函数定义，先翻转左右子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后交换左右子节点</span></span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和定义逻辑自恰：以 root 为根的这棵二叉树已经被翻转，返回 root</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-16-863-二叉树中所有距离为-K-的结点"><a href="#3-16-863-二叉树中所有距离为-K-的结点" class="headerlink" title="3.16 863. 二叉树中所有距离为 K 的结点"></a>3.16 <a href="https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/">863. 二叉树中所有距离为 K 的结点</a></h3><p>给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 k 。</p><p>返回到目标结点 target 距离为 k 的所有结点的值的列表。 答案可以以 任何顺序 返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录父节点：node.val -&gt; parentNode</span></span><br><span class="line">    <span class="comment">// 题目说了树中所有节点值都是唯一的，所以可以用 node.val 代表 TreeNode</span></span><br><span class="line">    HashMap&lt;Integer, TreeNode&gt; parent = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历所有节点，记录每个节点的父节点</span></span><br><span class="line">        traverse(root, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始从 target 节点施放 BFS 算法，找到距离为 k 的节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        q.offer(target);</span><br><span class="line">        visited.add(target.val);</span><br><span class="line">        <span class="comment">// 记录离 target 的距离</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dist</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span> (dist == k) &#123;</span><br><span class="line">                    <span class="comment">// 找到距离起点 target 距离为 k 的节点</span></span><br><span class="line">                    res.add(cur.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 向父节点、左右子节点扩散</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">parentNode</span> <span class="operator">=</span> parent.get(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (parentNode != <span class="literal">null</span> &amp;&amp; !visited.contains(parentNode.val)) &#123;</span><br><span class="line">                    visited.add(parentNode.val);</span><br><span class="line">                    q.offer(parentNode);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span> &amp;&amp; !visited.contains(cur.left.val)) &#123;</span><br><span class="line">                    visited.add(cur.left.val);</span><br><span class="line">                    q.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span> &amp;&amp; !visited.contains(cur.right.val)) &#123;</span><br><span class="line">                    visited.add(cur.right.val);</span><br><span class="line">                    q.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向外扩展一圈</span></span><br><span class="line">            dist++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, TreeNode parentNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parent.put(root.val, parentNode);</span><br><span class="line">        <span class="comment">// 二叉树递归框架</span></span><br><span class="line">        traverse(root.left, root);</span><br><span class="line">        traverse(root.right, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-17-617-合并二叉树"><a href="#3-17-617-合并二叉树" class="headerlink" title="3.17 617. 合并二叉树"></a>3.17 <a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果一棵树有，另一棵树没有，接上去</span></span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两棵树都有的节点，叠加节点值</span></span><br><span class="line">        root1.val += root2.val;</span><br><span class="line">        <span class="comment">// 递归合并左右子树</span></span><br><span class="line">        root1.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">        root1.right = mergeTrees(root1.right, root2.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-二叉搜索树"><a href="#4-二叉搜索树" class="headerlink" title="4 二叉搜索树"></a>4 二叉搜索树</h2><p>对于 BST 的每一个节点 node，左子树节点的值都比 node 的值要小，右子树节点的值都比 node 的值大。</p><h3 id="4-1-98-验证二叉搜索树"><a href="#4-1-98-验证二叉搜索树" class="headerlink" title="4.1 98. 验证二叉搜索树"></a>4.1 <a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 限定以 root 为根的子树节点必须满足 max.val &gt; root.val &gt; min.val */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST</span></span><br><span class="line">        <span class="keyword">if</span> (min != <span class="literal">null</span> &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (max != <span class="literal">null</span> &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 限定左子树的最大值是 root.val，右子树的最小值是 root.val</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left, min, root)</span><br><span class="line">            &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-230-二叉搜索树中第K小的元素"><a href="#4-2-230-二叉搜索树中第K小的元素" class="headerlink" title="4.2 230. 二叉搜索树中第K小的元素"></a>4.2 <a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h3><p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 利用 BST 的中序遍历特性</span></span><br><span class="line">    traverse(root, k);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 记录当前元素的排名</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rank</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traverse(root.left, k);</span><br><span class="line">    <span class="comment">/* 中序遍历代码位置 */</span></span><br><span class="line">    rank++;</span><br><span class="line">    <span class="keyword">if</span> (k == rank) &#123;</span><br><span class="line">        <span class="comment">// 找到第 k 小的元素</span></span><br><span class="line">        res = root.val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traverse(root.right, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-450-删除二叉搜索树中的节点"><a href="#4-3-450-删除二叉搜索树中的节点" class="headerlink" title="4.3 450. 删除二叉搜索树中的节点"></a>4.3 <a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h3><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种情况：</span></span><br><span class="line"><span class="comment">//无左子：其右子顶替其位置，删除了该节点；</span></span><br><span class="line"><span class="comment">//无右子：其左子顶替其位置，删除了该节点；</span></span><br><span class="line"><span class="comment">//左右子节点都有：左子树转移到其右子树的最左节点的左子树上</span></span><br><span class="line"><span class="comment">//然后右子树顶替其位置，由此删除了该节点。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">            <span class="comment">// 这两个 if 把情况 1 和 2 都正确处理了</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="comment">// 处理情况 3</span></span><br><span class="line">            <span class="comment">// 获得右子树最小的节点</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">minNode</span> <span class="operator">=</span> getMin(root.right);</span><br><span class="line">            <span class="comment">// 删除右子树最小的节点</span></span><br><span class="line">            root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">            <span class="comment">// 用右子树最小的节点替换 root 节点</span></span><br><span class="line">            minNode.left = root.left;</span><br><span class="line">            minNode.right = root.right;</span><br><span class="line">            root = minNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode <span class="title function_">getMin</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="comment">// BST 最左边的就是最小的</span></span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="literal">null</span>) node = node.left;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-96-不同的二叉搜索树"><a href="#4-4-96-不同的二叉搜索树" class="headerlink" title="4.4 96. 不同的二叉搜索树"></a>4.4 <a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h3><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录</span></span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 备忘录的值初始化为 0</span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> count(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt; hi) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 查备忘录</span></span><br><span class="line">        <span class="keyword">if</span> (memo[lo][hi] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[lo][hi];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo; mid &lt;= hi; mid++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> count(lo, mid - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> count(mid + <span class="number">1</span>, hi);</span><br><span class="line">            res += left * right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将结果存入备忘录</span></span><br><span class="line">        memo[lo][hi] = res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-108-将有序数组转换为二叉搜索树"><a href="#4-5-108-将有序数组转换为二叉搜索树" class="headerlink" title="4.5 108. 将有序数组转换为二叉搜索树"></a>4.5 <a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h3><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将闭区间 [left, right] 中的元素转化成 BST，返回根节点</span></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="comment">// 区间为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造根节点</span></span><br><span class="line">        <span class="comment">// BST 节点左小右大，中间的元素就是根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        <span class="comment">// 递归构建左子树</span></span><br><span class="line">        root.left = build(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归构造右子树</span></span><br><span class="line">        root.right = build(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-449-序列化和反序列化二叉搜索树"><a href="#4-6-449-序列化和反序列化二叉搜索树" class="headerlink" title="4.6 449. 序列化和反序列化二叉搜索树"></a>4.6 <a href="https://leetcode.cn/problems/serialize-and-deserialize-bst/">449. 序列化和反序列化二叉搜索树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="comment">// 分隔符，区分每个节点的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SEP</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        serialize(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历位置进行序列化</span></span><br><span class="line">        sb.append(root.val).append(SEP);</span><br><span class="line">        serialize(root.left, sb);</span><br><span class="line">        serialize(root.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 转化成前序遍历结果</span></span><br><span class="line">        LinkedList&lt;Integer&gt; inorder = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : data.split(SEP)) &#123;</span><br><span class="line">            inorder.offer(Integer.parseInt(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(inorder, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：将 nodes 中值在闭区间 [min, max] 的节点构造成一棵 BST</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">deserialize</span><span class="params">(LinkedList&lt;Integer&gt; nodes, <span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 前序遍历位置进行反序列化</span></span><br><span class="line">        <span class="comment">// 前序遍历结果第一个节点是根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> nodes.getFirst();</span><br><span class="line">        <span class="keyword">if</span> (rootVal &gt; max || rootVal &lt; min) &#123;</span><br><span class="line">            <span class="comment">// 超过闭区间 [min, max]，则返回空指针</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nodes.removeFirst();</span><br><span class="line">        <span class="comment">// 生成 root 节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">// 构建左右子树</span></span><br><span class="line">        <span class="comment">// BST 左子树都比根节点小，右子树都比根节点大</span></span><br><span class="line">        root.left = deserialize(nodes, min, rootVal);</span><br><span class="line">        root.right = deserialize(nodes, rootVal, max);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-669-修剪二叉搜索树"><a href="#4-7-669-修剪二叉搜索树" class="headerlink" title="4.7 669. 修剪二叉搜索树"></a>4.7 <a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h3><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据二叉搜索树的性质</span></span><br><span class="line"><span class="comment">// 一个节点小于 low，则左子树都要减掉</span></span><br><span class="line"><span class="comment">// 同样的处理大于情况</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：删除 BST 中小于 low 和大于 high 的所有节点，返回结果 BST</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; low) &#123;</span><br><span class="line">            <span class="comment">// 直接返回 root.right</span></span><br><span class="line">            <span class="comment">// 等于删除 root 以及 root 的左子树</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; high) &#123;</span><br><span class="line">            <span class="comment">// 直接返回 root.left</span></span><br><span class="line">            <span class="comment">// 等于删除 root 以及 root 的右子树</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 闭区间 [lo, hi] 内，不处理当前节点，递归子树</span></span><br><span class="line">        root.left = trimBST(root.left, low, high);</span><br><span class="line">        root.right = trimBST(root.right, low, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-173-二叉搜索树迭代器"><a href="#4-8-173-二叉搜索树迭代器" class="headerlink" title="4.8 173. 二叉搜索树迭代器"></a>4.8 <a href="https://leetcode.cn/problems/binary-search-tree-iterator/">173. 二叉搜索树迭代器</a></h3><p>实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟递归栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;TreeNode&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一路到底，把根节点和它的所有左节点放到栈中；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushLeftBranch</span><span class="params">(TreeNode p)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            stk.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        pushLeftBranch(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 弹出栈顶节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> stk.pop();</span><br><span class="line">        pushLeftBranch(p.right);</span><br><span class="line">        <span class="keyword">return</span> p.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !stk.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-9-1305-两棵二叉搜索树中的所有元素"><a href="#4-9-1305-两棵二叉搜索树中的所有元素" class="headerlink" title="4.9 1305. 两棵二叉搜索树中的所有元素"></a>4.9 <a href="https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/">1305. 两棵二叉搜索树中的所有元素</a></h3><p>给你 root1 和 root2 这两棵二叉搜索树。请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getAllElements</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">// BST 有序迭代器</span></span><br><span class="line">        <span class="type">BSTIterator</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSTIterator</span>(root1);</span><br><span class="line">        <span class="type">BSTIterator</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSTIterator</span>(root2);</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 类似合并有序链表的算法逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (t1.hasNext() &amp;&amp; t2.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t1.peek() &gt; t2.peek()) &#123;</span><br><span class="line">                res.add(t2.next());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(t1.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有一棵 BST 还剩元素，添加到最后</span></span><br><span class="line">        <span class="keyword">while</span> (t1.hasNext()) &#123;</span><br><span class="line">            res.add(t1.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (t2.hasNext()) &#123;</span><br><span class="line">            res.add(t2.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BST 有序迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 左侧树枝一撸到底</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushLeftBranch</span><span class="params">(TreeNode p)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            stk.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        pushLeftBranch(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stk.peek().val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> stk.pop();</span><br><span class="line">        pushLeftBranch(p.right);</span><br><span class="line">        <span class="keyword">return</span> p.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !stk.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-10-1038-从二叉搜索树到更大和树"><a href="#4-10-1038-从二叉搜索树到更大和树" class="headerlink" title="4.10 1038. 从二叉搜索树到更大和树"></a>4.10 <a href="https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/">1038. 从二叉搜索树到更大和树</a></h3><p>给定一个二叉搜索树 root (BST)，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">bstToGst</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录累加和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root.right);</span><br><span class="line">        <span class="comment">// 维护累加和</span></span><br><span class="line">        sum += root.val;</span><br><span class="line">        <span class="comment">// 将 BST 转化成累加树</span></span><br><span class="line">        root.val = sum;</span><br><span class="line">        traverse(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-11-1373-二叉搜索子树的最大键值和"><a href="#4-11-1373-二叉搜索子树的最大键值和" class="headerlink" title="4.11 1373. 二叉搜索子树的最大键值和"></a>4.11 <a href="https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/">1373. 二叉搜索子树的最大键值和</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、左右子树是否是 BST。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、左子树的最大值和右子树的最小值。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、左右子树的节点值之和。</span><br><span class="line"></span><br><span class="line">想要获得子树的信息，就要用到前文 手把手刷二叉树总结篇 说过的后序位置的妙用了。</span><br><span class="line"></span><br><span class="line">我们定义一个 traverse 函数，traverse(root) 返回一个大小为 <span class="number">4</span> 的 <span class="type">int</span> 数组，我们暂且称它为 res，其中：</span><br><span class="line"></span><br><span class="line">res[<span class="number">0</span>] 记录以 root 为根的二叉树是否是 BST，若为 <span class="number">1</span> 则说明是 BST，若为 <span class="number">0</span> 则说明不是 BST；</span><br><span class="line"></span><br><span class="line">res[<span class="number">1</span>] 记录以 root 为根的二叉树所有节点中的最小值；</span><br><span class="line"></span><br><span class="line">res[<span class="number">2</span>] 记录以 root 为根的二叉树所有节点中的最大值；</span><br><span class="line"></span><br><span class="line">res[<span class="number">3</span>] 记录以 root 为根的二叉树所有节点值之和。</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 全局变量，记录 BST 最大节点之和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主函数 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] traverse(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;</span><br><span class="line">                    <span class="number">1</span>, Integer.MAX_VALUE, Integer.MIN_VALUE, <span class="number">0</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归计算左右子树</span></span><br><span class="line">        <span class="type">int</span>[] left = traverse(root.left);</span><br><span class="line">        <span class="type">int</span>[] right = traverse(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*******后序遍历位置*******/</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">// 这个 if 在判断以 root 为根的二叉树是不是 BST</span></span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; right[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp;</span><br><span class="line">                root.val &gt; left[<span class="number">2</span>] &amp;&amp; root.val &lt; right[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">// 以 root 为根的二叉树是 BST</span></span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 计算以 root 为根的这棵 BST 的最小值</span></span><br><span class="line">            res[<span class="number">1</span>] = Math.min(left[<span class="number">1</span>], root.val);</span><br><span class="line">            <span class="comment">// 计算以 root 为根的这棵 BST 的最大值</span></span><br><span class="line">            res[<span class="number">2</span>] = Math.max(right[<span class="number">2</span>], root.val);</span><br><span class="line">            <span class="comment">// 计算以 root 为根的这棵 BST 所有节点之和</span></span><br><span class="line">            res[<span class="number">3</span>] = left[<span class="number">3</span>] + right[<span class="number">3</span>] + root.val;</span><br><span class="line">            <span class="comment">// 更新全局变量</span></span><br><span class="line">            maxSum = Math.max(maxSum, res[<span class="number">3</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 以 root 为根的二叉树不是 BST</span></span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 其他的值都没必要计算了，因为用不到</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**************************/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-12-面试题-04-06-后继者"><a href="#4-12-面试题-04-06-后继者" class="headerlink" title="4.12 面试题 04.06. 后继者"></a>4.12 <a href="https://leetcode.cn/problems/successor-lcci/">面试题 04.06. 后继者</a></h3><p>找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。</p><ul><li>若有 root.val &lt;= p.val : 根据 BST 特性可知当前节点 root 及其左子树子节点均满足「值小于等于 p.val」，因此不可能是 p 点的后继，我们直接到 root 的右子树搜索 p 的后继（递归处理）；</li><li>若有 root.val &gt; p.val : 当第一次搜索到满足此条件的节点时，在以 root 为根节点的子树中「位于最左下方」的值为 p 的后继，但也有可能 root 没有左子树，因此 p 的后继要么在 root 的左子树中（若有），要么是 root 本身，此时我们可以直接到 root 的左子树搜索，若搜索结果为空返回 root，否则返回搜索结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= p.val) <span class="keyword">return</span> inorderSuccessor(root.right, p);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">ans</span> <span class="operator">=</span> inorderSuccessor(root.left, p);</span><br><span class="line">        <span class="keyword">return</span> ans == <span class="literal">null</span> ? root : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-13-109-有序链表转换二叉搜索树"><a href="#4-13-109-有序链表转换二叉搜索树" class="headerlink" title="4.13 109. 有序链表转换二叉搜索树"></a>4.13 <a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></h3><p>给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用快慢指针寻找中间值（需要找到中间节点的前一个节点）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedListToBST</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//有下面两种边界问题</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(head.val);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">preMid</span> <span class="operator">=</span> helper(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> preMid.next;</span><br><span class="line">        preMid.next = <span class="literal">null</span>;<span class="comment">//从这里断开链表</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(mid.val);</span><br><span class="line">        root.left = sortedListToBST(head);</span><br><span class="line">        root.right = sortedListToBST(mid.next);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//寻找preMid</span></span><br><span class="line">    ListNode <span class="title function_">helper</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next.next;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-14-剑指26-二叉搜索树与双向链表"><a href="#4-14-剑指26-二叉搜索树与双向链表" class="headerlink" title="4.14 剑指26.二叉搜索树与双向链表"></a>4.14 剑指26.二叉搜索树与双向链表</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><p>思路：</p><p>线索化二叉树。类似于中序遍历构建。</p><p>由于正向构建时，指针会移动到尾部，因此反向构建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Convert</span><span class="params">(TreeNode pRootOfTree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">            pRootOfTree.right = pre;</span><br><span class="line">            pre.left = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pRootOfTree;</span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-15-653-给定一个二叉搜索树和一个目标结果，如果-BST-中存在两个元素且它们的和等于给定的目标结果，则返回-true。"><a href="#4-15-653-给定一个二叉搜索树和一个目标结果，如果-BST-中存在两个元素且它们的和等于给定的目标结果，则返回-true。" class="headerlink" title="4.15 653.给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。"></a>4.15 653.给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findTarget</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; inOrder = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inOrder(root, inOrder);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = inOrder.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> inOrder.get(left) + inOrder.get(right);</span><br><span class="line">            <span class="keyword">if</span>(sum == k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; k) right--;</span><br><span class="line">            <span class="keyword">else</span> left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; inOrder)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left, inOrder);</span><br><span class="line">        inOrder.add(root.val);</span><br><span class="line">        inOrder(root.right, inOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-16-501-给定一个有相同值的二叉搜索树（BST），找出-BST-中的所有众数（出现频率最高的元素）。"><a href="#4-16-501-给定一个有相同值的二叉搜索树（BST），找出-BST-中的所有众数（出现频率最高的元素）。" class="headerlink" title="4.16 501.给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。"></a>4.16 501.给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</h3><p>如果众数超过1个，不需考虑输出顺序。</p><p>你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><p>思路：</p><p>毫无疑问，同样使用中序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">//存储最小值</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">preNode</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//存储前一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="keyword">if</span>(preNode != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//后一个节点肯定大于前一个节点</span></span><br><span class="line">            min = Math.min(cur - preNode.val, min);</span><br><span class="line">        preNode = root;</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;</summary>
      
    
    
    
    
    <category term="Algorithm" scheme="https://stardustorz.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>[Algorithm] SkipList</title>
    <link href="https://stardustorz.github.io/2025/07/25/Algorithm/SkipList/"/>
    <id>https://stardustorz.github.io/2025/07/25/Algorithm/SkipList/</id>
    <published>2025-07-25T10:10:13.000Z</published>
    <updated>2025-07-25T10:10:13.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-核心性质"><a href="#1-核心性质" class="headerlink" title="1 核心性质"></a>1 核心性质</h2><ul><li>跳表由多层索引结构组成</li><li>每次节点个数接近于相邻下层节点数的一半</li><li>对于一个 m 层存在的节点，在 1~m-1层中这个节点也一定存在</li><li>为保证连贯性，跳表额外补充了本身不存储数据的头节点和尾节点，作为起点和终点</li><li>头节点和尾节点的高度是动态扩缩的，其高度取决于当前跳表内数据节点的最大高度</li><li>跳表的”跳“字体现在，在高层检索时，每跳过一个节点，实际上都过滤跳过了底层的大量数据，从而实现检索加速<h2 id="2-数据结构定义"><a href="#2-数据结构定义" class="headerlink" title="2 数据结构定义"></a>2 数据结构定义</h2></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 跳表的数据结构 Skiplist  </span></span><br><span class="line"> <span class="keyword">type</span> Skiplist <span class="keyword">struct</span> &#123;  </span><br><span class="line">     head *node  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">// 节点定义  </span></span><br><span class="line"> <span class="keyword">type</span> node <span class="keyword">struct</span> &#123;  </span><br><span class="line">     <span class="comment">// 长度为当前节点的高度  </span></span><br><span class="line">     nexts    []*node  </span><br><span class="line">     key, val <span class="type">int</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="3-读流程"><a href="#3-读流程" class="headerlink" title="3 读流程"></a>3 读流程</h2><ul><li>以 head 节点作为起点</li><li>从当前跳表存在的最大高度出发</li><li>倘若右侧节点 key 值小于 target，则持续向右遍历</li><li>倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回</li><li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li><li>重复</li><li>倘若已经抵达第1层仍然找到不到 target，则返回 key 不存在的信息</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 根据 key 读取 val，第二个 bool flag 反映 key 在 skiplist 中是否存在  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Get(key <span class="type">int</span>) (<span class="type">int</span>, <span class="type">bool</span>) &#123;  </span><br><span class="line">     <span class="comment">// 根据 key 尝试检索对应的 node，如果 node 存在，则返回对应的 val  </span></span><br><span class="line">     <span class="keyword">if</span> _node := s.search(key); _node != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> _node.val, <span class="literal">true</span>  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">false</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 从跳表中检索 key 对应的 node  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> search(key <span class="type">int</span>) *node &#123;  </span><br><span class="line">     <span class="comment">// 每次检索从头部出发  </span></span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="comment">// 每次检索从最大高度出发，直到来到首层  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="comment">// 在每一层中持续向右遍历，直到下一个节点不存在或者 key 值大于等于 key  </span></span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; key &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 如果 key 值相等，则找到了目标直接返回  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key == key &#123;  </span><br><span class="line">             <span class="keyword">return</span> move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 当前层没找到目标，则层数减 1，继续向下  </span></span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">// 遍历完所有层数，都没有找到目标，返回 nil  </span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="4-写流程"><a href="#4-写流程" class="headerlink" title="4 写流程"></a>4 写流程</h2><ul><li>首先基于读流程检索出 key 对应的节点是否存在，倘若存在，则对值进行更新并直接返回</li><li>随机出新插入节点的高度；倘若新插入节点的高度大于当前跳表的最大高度，则需要对起点和终点的高度进行扩容</li><li>以 head 节点作为起点，从当前跳表存在的最大高度出发</li><li>倘若右侧节点 key 值小于 target，则持续向右遍历</li><li>倘若右侧节点为终点（nil）或者 key 值大于 target，则在该空隙插入新节点，并降低高度进入下一层</li><li>重复（4）-（5）步</li><li>倘若已经进入第 1 层，插入新节点后即可返回<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> (<span class="string">&quot;math/rand&quot;</span>)  </span><br><span class="line"> roll 骰子，决定一个待插入的新节点在 skiplist 中最高层对应的 index  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> roll() <span class="type">int</span> &#123;  </span><br><span class="line">     <span class="keyword">var</span> level <span class="type">int</span>  </span><br><span class="line">     <span class="comment">// 每次投出 1，则层数加 1  </span></span><br><span class="line">     <span class="keyword">for</span> rand.Int() &gt; <span class="number">0</span> &#123;  </span><br><span class="line">         level++  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> level  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 将 key-val 对加入 skiplist  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Put(key, val <span class="type">int</span>) &#123;  </span><br><span class="line">     <span class="comment">// 假如 kv对已存在，则直接对值进行更新并返回  </span></span><br><span class="line">     <span class="keyword">if</span> _node := s.search(key); _node != <span class="literal">nil</span> &#123;  </span><br><span class="line">         _node.val = val  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// roll 出新节点的高度  </span></span><br><span class="line">     level := s.roll()  </span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 新节点高度超出跳表最大高度，则需要对高度进行补齐  </span></span><br><span class="line">     <span class="keyword">for</span> <span class="built_in">len</span>(s.head.nexts)<span class="number">-1</span> &lt; level &#123;  </span><br><span class="line">         s.head.nexts = <span class="built_in">append</span>(s.head.nexts, <span class="literal">nil</span>)  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 创建出新的节点  </span></span><br><span class="line">     newNode := node&#123;  </span><br><span class="line">         key:   key,  </span><br><span class="line">         val:   val,  </span><br><span class="line">         nexts: <span class="built_in">make</span>([]*node, level+<span class="number">1</span>),  </span><br><span class="line">     &#125;  </span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 从头节点的最高层出发  </span></span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="keyword">for</span> level := level; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="comment">// 向右遍历，直到右侧节点不存在或者 key 值大于 key  </span></span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; key &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 调整指针关系，完成新节点的插入  </span></span><br><span class="line">         newNode.nexts[level] = move.nexts[level]  </span><br><span class="line">         move.nexts[level] = &amp;newNode  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure></li></ul><h2 id="删流程"><a href="#删流程" class="headerlink" title="删流程"></a>删流程</h2><ul><li>以 head 节点作为起点，从当前跳表存在的最大高度出发</li><li>倘若右侧节点 key 值小于 target，则持续向右遍历</li><li>倘若右侧节点为终点（nil）或者 key 值大于 target，则在该空隙插入新节点，并降低高度进入下一层</li><li>倘若右侧节点 key 值等于 target，则代表找到目标</li><li>找到目标值后，沿当前节点层层向下，依次将每层中的目标节点删除</li><li>倘若已经进入第 1 层仍然没有找到节点，说明节点不存在，删除失败</li><li><p>倘若删除成功，需要尝试对跳表的整体高度进行缩容，即需要对高度递减，直到确定最大高度对应的层数上至少存在一个有效的数据节点为止</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 key 从跳表中删除对应的节点  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Del(key <span class="type">int</span>) &#123;  </span><br><span class="line">     <span class="comment">// 如果 kv 对不存在，则无需删除直接返回  </span></span><br><span class="line">     <span class="keyword">if</span> _node := s.search(key); _node == <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 从头节点的最高层出发      </span></span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="comment">// 向右遍历，直到右侧节点不存在或者 key 值大于等于 key  </span></span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; key &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">           </span><br><span class="line">         <span class="comment">// 右侧节点不存在或者 key 值大于 target，则直接跳过  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] == <span class="literal">nil</span> || move.nexts[level].key &gt; key&#123;  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">         &#125;      </span><br><span class="line">         <span class="comment">// 走到此处意味着右侧节点的 key 值必然等于 key，则调整指针引用  </span></span><br><span class="line">         move.nexts[level] = move.nexts[level].nexts[level]  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 对跳表的最大高度进行更新  </span></span><br><span class="line">     <span class="keyword">var</span> dif <span class="type">int</span>  </span><br><span class="line">     <span class="comment">// 倘若某一层已经不存在数据节点，高度需要递减  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt; <span class="number">0</span> &amp;&amp; s.head.nexts[level] == <span class="literal">nil</span>; level-- &#123;  </span><br><span class="line">         dif++  </span><br><span class="line">     &#125;  </span><br><span class="line">     s.head.nexts = s.head.nexts[:<span class="built_in">len</span>(s.head.nexts)-dif]  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="5-RANGE-流程"><a href="#5-RANGE-流程" class="headerlink" title="5 RANGE 流程"></a>5 RANGE 流程</h2></li><li>以 head 节点作为起点</li><li>从当前跳表存在的最大高度出发</li><li>倘若右侧节点 key 值小于 target，则持续向右遍历</li><li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li><li>倘若右侧节点 key 值等于 target，则代表找到目标，直接沿该节点向下来到第1层</li><li><p>重复（3）-（5）步，直到来到第1层，接下来从首个大于等于 target 的节点出发，向右依次遍历，直到取满 range 区间的数据后返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到 skiplist 当中 ≥ start，且 ≤ end 的 kv 对  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Range(start, end <span class="type">int</span>) [][<span class="number">2</span>]<span class="type">int</span> &#123;  </span><br><span class="line">     <span class="comment">// 首先通过 ceiling 方法，找到 skiplist 中 key 值大于等于 start 且最接近于 start 的节点 ceilNode  </span></span><br><span class="line">     ceilNode := s.ceiling(start)  </span><br><span class="line">     <span class="comment">// 如果不存在，直接返回  </span></span><br><span class="line">     <span class="keyword">if</span> ceilNode == <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> [][<span class="number">2</span>]<span class="type">int</span>&#123;&#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 从 ceilNode 首层出发向右遍历，把所有位于 [start,end] 区间内的节点统统返回  </span></span><br><span class="line">     <span class="keyword">var</span> res [][<span class="number">2</span>]<span class="type">int</span>  </span><br><span class="line">     <span class="keyword">for</span> move := ceilNode; move != <span class="literal">nil</span> &amp;&amp; move.key &lt;= end; move = move.nexts[<span class="number">0</span>] &#123;  </span><br><span class="line">         res = <span class="built_in">append</span>(res, [<span class="number">2</span>]<span class="type">int</span>&#123;move.key, move.val&#125;)  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> res  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 找到 key 值大于等于 target 且 key 值最接近于 target 的节点  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> ceiling(target <span class="type">int</span>) *node &#123;  </span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="comment">// 自上而下，找到 key 值小于 target 且最接近 target 的 kv 对  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; target &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 如果 key 值等于 targe 的 kv 对存在，则直接返回  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key == target &#123;  </span><br><span class="line">             <span class="keyword">return</span> move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">// 此时 move 已经对应于在首层 key 值小于 key 且最接近于 key 的节点，其右侧第一个节点即为所寻找的目标节点  </span></span><br><span class="line">     <span class="keyword">return</span> move.nexts[<span class="number">0</span>]  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="CEILING-流程"><a href="#CEILING-流程" class="headerlink" title="CEILING 流程"></a>CEILING 流程</h2><ul><li>以 head 节点作为起点</li><li>从当前跳表存在的最大高度出发</li><li>倘若右侧节点 key 值小于 target，则持续向右遍历</li><li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li><li>倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回</li><li>重复（3）-（5）步，直到找到 key 值等于 target 的节点或者来到第1层，接下来获取到首个大于等于 target 的节点并返回</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 找到 skiplist 中，key 值大于等于 target 且最接近于 target 的 key-value 对  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Ceiling(target <span class="type">int</span>) ([<span class="number">2</span>]<span class="type">int</span>, <span class="type">bool</span>) &#123;  </span><br><span class="line">     <span class="keyword">if</span> ceilNode := s.ceiling(target); ceilNode != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;ceilNode.key, ceilNode.val&#125;, <span class="literal">true</span>  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;&#125;, <span class="literal">false</span>  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure><p> ​</p><h2 id="6-FLOOR-流程"><a href="#6-FLOOR-流程" class="headerlink" title="6 FLOOR 流程"></a>6 FLOOR 流程</h2><ul><li>以 head 节点作为起点</li><li>从当前跳表存在的最大高度出发</li><li>倘若右侧节点 key 值小于 target，则持续向右遍历</li><li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li><li>倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回</li><li><p>重复（3）-（5）步，直到找到 key 值等于 target 的节点或者来到第1层，接下来获取到首个小于等于 target 的节点并返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到 skiplist 中，key 值小于等于 target 且最接近于 target 的 key-value 对  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Floor(target <span class="type">int</span>) ([<span class="number">2</span>]<span class="type">int</span>, <span class="type">bool</span>) &#123;  </span><br><span class="line">     <span class="comment">// 引用 floor 方法，取 floorNode 值进行返回  </span></span><br><span class="line">     <span class="keyword">if</span> floorNode := s.floor(target); floorNode != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;floorNode.key, floorNode.val&#125;, <span class="literal">true</span>  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;&#125;, <span class="literal">false</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 找到 key 值小于等于 target 且 key 值最接近于 target 的节点  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> floor(target <span class="type">int</span>) *node &#123;  </span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="comment">// 自上而下，找到 key 值小于 target 且最接近 target 的 kv 对  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; target &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 如果 key 值等于 targe 的 kv对存在，则直接返回  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key == target &#123;  </span><br><span class="line">             <span class="keyword">return</span> move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// move 是首层中 key 值小于 target 且最接近 target 的节点，直接返回 move 即可  </span></span><br><span class="line">     <span class="keyword">return</span> move  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure><p>​<br>​</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-核心性质&quot;&gt;&lt;a href=&quot;#1-核心性质&quot; class=&quot;headerlink&quot; title=&quot;1 核心性质&quot;&gt;&lt;/a&gt;1 核心性质&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;跳表由多层索引结构组成&lt;/li&gt;
&lt;li&gt;每次节点个数接近于相邻下层节点数的一半&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    
    <category term="Algorithm" scheme="https://stardustorz.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>[Go] sync.Cond</title>
    <link href="https://stardustorz.github.io/2025/06/20/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Cond/"/>
    <id>https://stardustorz.github.io/2025/06/20/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Cond/</id>
    <published>2025-06-20T03:02:24.000Z</published>
    <updated>2025-07-27T15:39:50.190Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>sync.Cond 实现了一种条件变量，可以使用在多个Reader等待共享资源 ready 的场景</p></blockquote><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>Golang 的 sync 包中的 Cond 实现了一种条件变量，可以使用在<strong>多个Reader</strong>等待共享资源 ready 的场景（如果只有一读一写，一个锁或者channel就搞定了）。<br>Cond的汇合点：多个goroutines等待、1个goroutine通知事件发生。<br>比较适合任务调用场景，一个 Master goroutine 通知事件发生，多个 Worker goroutine 在资源没准备好的时候就挂起，等待通知。<br><strong>使用方法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Cond</span></span><br><span class="line">cond := sync.NewCond(<span class="built_in">new</span>(sync.Mutex))</span><br><span class="line"><span class="comment">// 挂起goroutine</span></span><br><span class="line">cond.L.Lock()</span><br><span class="line">cond.Wait()</span><br><span class="line"><span class="comment">// 唤醒一个</span></span><br><span class="line">cond.Signal()</span><br><span class="line"><span class="comment">// 唤醒所有</span></span><br><span class="line">cond.Broadcast()</span><br></pre></td></tr></table></figure><blockquote><p>基本使用大概是需要等待的时候通过 Wait() 将 Goroutine 挂起，资源准备好的时候再通过 Signal() 或者 Broadcast() 将挂起中的 Goroutine 唤醒。</p></blockquote><p>一个简单的 Demo<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">locker sync.Mutex</span><br><span class="line">cond   = sync.NewCond(&amp;locker)</span><br><span class="line">wg     sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(number <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// wait()方法内部是先释放锁 然后在加锁 所以这里需要先 Lock()</span></span><br><span class="line">cond.L.Lock()</span><br><span class="line"><span class="keyword">defer</span> cond.L.Unlock()</span><br><span class="line">cond.Wait() <span class="comment">// 等待通知,阻塞当前 goroutine</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;g %v ok~ \n&quot;</span>, number)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 每过 50毫秒 唤醒一个 goroutine</span></span><br><span class="line">cond.Signal()</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line"><span class="comment">// 剩下5个 goroutine 一起唤醒</span></span><br><span class="line">cond.Broadcast()</span><br><span class="line">fmt.Println(<span class="string">&quot;Broadcast...&quot;</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><blockquote><p>go version 1.14.7</p></blockquote><h3 id="2-1-Cond"><a href="#2-1-Cond" class="headerlink" title="2.1 Cond"></a>2.1 Cond</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 21</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line">    L Locker</span><br><span class="line">    notify  notifyList</span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCond() 返回指针，保证多 goroutine 获取到的是同一个实例。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span></span> *Cond &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Cond&#123;L: l&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>noCopy</strong>：noCopy对象，实现了<code>sync.Locker</code>接口，使得内嵌 noCopy 的对象在进行 go vet 静态检查的时候，可以检查出是否被复制。</p><blockquote><p>noCopy 具体见 <a href="https://github.com/golang/go/issues/8005">Go issues 8005</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 94</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> noCopy <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*noCopy)</span></span> Lock()   &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*noCopy)</span></span> Unlock() &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>L</strong>：实现了 <code>sync.Locker</code> 接口的锁对象，通常使用 Mutex 或 RWMutex 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： mutex.go</span></span><br><span class="line"><span class="comment">line: 31</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">     Lock()</span><br><span class="line">     Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>notify</strong>：notifyList 对象，维护等待唤醒的 goroutine 队列,使用链表实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： runtime.go</span></span><br><span class="line"><span class="comment">line: 33    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">wait   <span class="type">uint32</span></span><br><span class="line">notify <span class="type">uint32</span></span><br><span class="line">lock   <span class="type">uintptr</span></span><br><span class="line">head   unsafe.Pointer</span><br><span class="line">tail   unsafe.Pointer</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>checker</strong>：copyChecker 对象，实际上是 uintptr 对象，保存自身对象地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 79    </span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="keyword">type</span> copyChecker <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *copyChecker)</span></span> check() &#123;</span><br><span class="line">     <span class="keyword">if</span> <span class="type">uintptr</span>(*c) != <span class="type">uintptr</span>(unsafe.Pointer(c)) &amp;&amp;</span><br><span class="line">            !atomic.CompareAndSwapUintptr((*<span class="type">uintptr</span>)(c), <span class="number">0</span>, <span class="type">uintptr</span>(unsafe.Pointer(c))) &amp;&amp;</span><br><span class="line">            <span class="type">uintptr</span>(*c) != <span class="type">uintptr</span>(unsafe.Pointer(c)) &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;sync.Cond is copied&quot;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>1）检查当前 checker 对象的地址是否等于保存在 checker 中的地址</p><ul><li>由于第一次比较的时候 checker 中没有存地址所以第一次比较肯定是不相等的，于是有了后续 2 3步。</li></ul></li><li><p>2）对 checker 进行 CAS 操作，如果 checker 中存储的地址值为空（就是0）就把当前 checker 对象的地址值存进去</p></li><li>3）第三步和第一步一样，再比较一下。<ul><li>主要是防止在第一步比较发现不相等之后，第二步 CAS 之前，其他 goroutine 也在执行这个方法，并发的将 checker 赋值了，导致这里判定的时候第二步 CAS 失败，返回 false，然后错误的抛出一个 panic，所以执行第三步在比较一下是否相等。如果其他 goroutine 抢先执行 CAS 修改了 checker 中的值导致这里第二步也返回 false 的话，第三步的判定也会是相等的，不会抛出 panic</li></ul></li><li>4）如果 3 个条件都成立，那 checker 肯定是被复制了，就是由于 cond 被复制引起的。</li></ul><blockquote><p>check 方法在第一次调用的时候，会将 checker 对象地址赋值给 checker，也就是将自身内存地址赋值给自身。<br>再次调用 checker 方法的时候，会将当前 checker 对象地址值与 checker 中保存的地址值（原始地址）进行比较，若不相同则表示当前 checker 的地址不是第一次调用 check 方法时候的地址，即 cond 对象被复制了，导致checker 被重新分配了内存地址。</p></blockquote><h3 id="2-2-Wait"><a href="#2-2-Wait" class="headerlink" title="2.2 Wait"></a>2.2 Wait</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 52    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait() &#123;</span><br><span class="line">    <span class="comment">// 1.每次操作之前都要检测一下 cond 是否被复制了。</span></span><br><span class="line">    c.checker.check() </span><br><span class="line">    <span class="comment">// 2.将 notifyList 中的 wait 值加1并返回之前的值</span></span><br><span class="line">    t := runtime_notifyListAdd(&amp;c.notify) </span><br><span class="line">    <span class="comment">// 3.释放锁，因此在调用Wait方法前，必须保证获取到了cond的锁，否则会报错</span></span><br><span class="line">    c.L.Unlock()</span><br><span class="line">    <span class="comment">// 4.将当前goroutine挂起，等待唤醒信号</span></span><br><span class="line">    runtime_notifyListWait(&amp;c.notify, t) </span><br><span class="line">    <span class="comment">// 5.gorountine被唤醒，重新获取锁</span></span><br><span class="line">    c.L.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> package: runtime</span></span><br><span class="line"><span class="comment"> file： sema.go</span></span><br><span class="line"><span class="comment"> line: 479  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListAdd</span><span class="params">(l *notifyList)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> atomic.Xadd(&amp;l.wait, <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: runtime</span></span><br><span class="line"><span class="comment">file： sema.go</span></span><br><span class="line"><span class="comment">line: 488  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 获取当前 goroutine 添加到链表末端，然后 goparkunlock 函数休眠阻塞当前 goroutine</span></span><br><span class="line"><span class="comment">// goparkunlock 函数会让出当前处理器的使用权并等待调度器的唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListWait</span><span class="params">(l *notifyList, t <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.锁住 notify 队列</span></span><br><span class="line">    lock(&amp;l.lock)</span><br><span class="line">    <span class="comment">// 2.判断传入的等待序号t是否小于当前已经唤醒的序号notify</span></span><br><span class="line">    <span class="comment">// 如果是则说明当前 goroutine 不需要阻塞了 直接解锁并返回</span></span><br><span class="line">    <span class="comment">// 有可能执行这步之前 goroutine 就已经被唤醒了</span></span><br><span class="line">    <span class="keyword">if</span> less(t, l.notify) &#123;</span><br><span class="line">        unlock(&amp;l.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.获取当前 goroutine，设置相关参数，将当前等待数赋值给 ticket</span></span><br><span class="line">    s := acquireSudog()</span><br><span class="line">    s.g = getg()</span><br><span class="line">    s.ticket = t</span><br><span class="line">    s.releasetime = <span class="number">0</span></span><br><span class="line">    t0 := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">        s.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.将当前 goroutine 写入到链表尾部</span></span><br><span class="line">    <span class="keyword">if</span> l.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">        l.head = s</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l.tail.next = s</span><br><span class="line">    &#125;</span><br><span class="line">    l.tail = s</span><br><span class="line">    <span class="comment">// 5. 调用 goparkunlock 函数将当前 goroutine 挂起，等待唤醒信号</span></span><br><span class="line">    goparkunlock(&amp;l.lock, <span class="string">&quot;semacquire&quot;</span>, traceEvGoBlockCond, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(s.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-Signal"><a href="#2-3-Signal" class="headerlink" title="2.3 Signal"></a>2.3 Signal</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 64  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal() &#123;</span><br><span class="line">    <span class="comment">// 1.复制检查</span></span><br><span class="line">    c.checker.check() </span><br><span class="line">    <span class="comment">// 2.顺序唤醒一个等待的gorountine</span></span><br><span class="line">    runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: runtime</span></span><br><span class="line"><span class="comment">file： sema.go</span></span><br><span class="line"><span class="comment">line: 554  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyOne</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 1.等待序号和唤醒序号相同则说明没有需要唤醒的 goroutine 直接返回</span></span><br><span class="line">   <span class="keyword">if</span> atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 2.锁住队列后再检查一遍等待序号和唤醒序号是否相同即判断有没有需要唤醒的 goroutine，没有则解锁后直接返回</span></span><br><span class="line">   lock(&amp;l.lock) </span><br><span class="line">   t := l.notify</span><br><span class="line">   <span class="keyword">if</span> t == atomic.Load(&amp;l.wait) &#123;</span><br><span class="line">        unlock(&amp;l.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 3.到这里就说明有需要唤醒的 goroutine，于是先将 notify序号+1</span></span><br><span class="line">   atomic.Store(&amp;l.notify, t+<span class="number">1</span>)  </span><br><span class="line">   <span class="comment">// 4.然后就开始唤醒 goroutine 了</span></span><br><span class="line">   <span class="keyword">for</span> p, s := (*sudog)(<span class="literal">nil</span>), l.head; s != <span class="literal">nil</span>; p, s = s, s.next &#123;</span><br><span class="line">        <span class="comment">// 4.1 找到 ticket等于当前唤醒序号的 goroutine</span></span><br><span class="line">        <span class="keyword">if</span> s.ticket == t &#123;</span><br><span class="line">           <span class="comment">// 4.2 然后将其从等待唤醒链表中移除（因为这个 goroutine 马上就要被唤醒了）</span></span><br><span class="line">           n := s.next</span><br><span class="line">           <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">               p.next = n</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               l.head = n</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">               l.tail = p</span><br><span class="line">           &#125;</span><br><span class="line">           unlock(&amp;l.lock)</span><br><span class="line">           s.next = <span class="literal">nil</span></span><br><span class="line">           <span class="comment">// 4.3 然后唤醒这个 goroutine </span></span><br><span class="line">           readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">           <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 4.4 最后解锁队列 </span></span><br><span class="line">   unlock(&amp;l.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-Broadcast"><a href="#2-4-Broadcast" class="headerlink" title="2.4 Broadcast"></a>2.4 Broadcast</h3><p>唤醒链表中所有的阻塞中的goroutine，还是使用readyWithTime来实现这个功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 73  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast() &#123;</span><br><span class="line">    <span class="comment">// 1.复制检查</span></span><br><span class="line">    c.checker.check()</span><br><span class="line">    <span class="comment">// 2.唤醒所有在等待的 goroutine</span></span><br><span class="line">    runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里和 <code>notifyListNotifyOne()</code>差不多，只是一次性唤醒所有 goroutine。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: runtime</span></span><br><span class="line"><span class="comment">file： sema.go</span></span><br><span class="line"><span class="comment">line: 522 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyAll</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.等待序号和唤醒序号相同则说明没有需要唤醒的 goroutine 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将链表头尾指针置为空（可以看做是清空整个等待队列）</span></span><br><span class="line">    <span class="comment">// 但是需要将当前的链表头保存下来，不然等会找不到链表中的数据了</span></span><br><span class="line">    lock(&amp;l.lock)</span><br><span class="line">    s := l.head</span><br><span class="line">    l.head = <span class="literal">nil</span></span><br><span class="line">    l.tail = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.直接将notify需要赋值成等待序号（这样表示当前没有需要唤醒的 goroutine 了）</span></span><br><span class="line">    <span class="comment">// 前面唤醒一个的时候这里是+1</span></span><br><span class="line">    atomic.Store(&amp;l.notify, atomic.Load(&amp;l.wait))</span><br><span class="line">    unlock(&amp;l.lock)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4.最后 for 循环唤醒链表中所有等待状态的 goroutine</span></span><br><span class="line">    <span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">        next := s.next</span><br><span class="line">        s.next = <span class="literal">nil</span></span><br><span class="line">        readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">        s = next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p><strong>基本使用</strong></p><ul><li>1）资源未准备好时，使用 Wait() 方法将 goroutine 挂起，由底层实现，会让出 CPU 时间片，从而避免使用无意义的循环浪费系统资源。</li><li>2）资源准备好时通过 Signal() 或者 Broadcast() 方法唤醒一个或多个被挂起的 goroutine。</li></ul><p><strong>等待唤醒流程</strong></p><ul><li>1）所有相关数据都是存在 notifyList 中的，包括 goroutine 和一些计数信息。</li><li>2）其中的 wait 和 notify 可以理解为等待序号和唤醒序号，都是自增值，wait 在有新 goroutine 等待时+1，notify 则在唤醒一个 goroutine 时+1。</li><li>3）等待状态的 goroutine 信息则存放在链表中，等待时加入链表尾部，唤醒时移除。</li><li>4）每个等待链表的 goroutine  都会将当前的 wait（等待序号）赋值给 ticket 字段，唤醒的时候会将 ticket=唤醒序号的 goroutine 唤醒。</li><li>5）当 wait==notify 时表示没有 goroutine 需要被唤醒，wait&gt;notify 时表示有 goroutine 需要被唤醒，wait 恒大于等于 notify。</li></ul><p><strong>noCopy</strong><br>Cond在内部持有一个等待队列 notifyList ，这个队列维护所有等待在这个 Cond 的 goroutine。如果 Cond 被复制则会导致其中的等待队列也被复制，最终可能会导致在唤醒 goroutine 的时候出现错误。<br>Kubernetes 的调度中也用到了 sync.Cond 有兴趣的可以研究一下。</p><blockquote><p><a href="https://mp.weixin.qq.com/s/rKLiazgWzneJfpfgHay8cA">https://mp.weixin.qq.com/s/rKLiazgWzneJfpfgHay8cA</a><br><a href="https://github.com/kubernetes/kubernetes/blob/0599ca2bcfcae7d702f95284f3c2e2c2978c7772/pkg/scheduler/internal/queue/scheduling_queue.go">https://github.com/kubernetes/kubernetes/blob/0599ca2bcfcae7d702f95284f3c2e2c2978c7772/pkg/scheduler/internal/queue/scheduling_queue.go</a></p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><code>https://ieevee.com/tech/2019/06/15/cond.html</code></p></blockquote><p><code>https://segmentfault.com/a/1190000019957459</code></p><p><code>https://www.jianshu.com/p/7b59d1d92a95</code></p><p><code>http://www.pydevops.com/2016/12/04/go-cond源码剖析-3/</code></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;sync.Cond 实现了一种条件变量，可以使用在多个Reader等待共享资源 ready 的场景&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
    <category term="Go并发编程" scheme="https://stardustorz.github.io/tags/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Go] sync.Mutex</title>
    <link href="https://stardustorz.github.io/2025/06/20/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Mutex/"/>
    <id>https://stardustorz.github.io/2025/06/20/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Mutex/</id>
    <published>2025-06-20T03:02:24.000Z</published>
    <updated>2025-07-27T15:40:25.199Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>sync.Mutex 是 Go 语言中实现互斥锁的核心结构</p></blockquote><span id="more"></span><h2 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="1 基本结构"></a>1 基本结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/mutex.go 25行</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">state <span class="type">int32</span>      <span class="comment">// 当前互斥锁的状态</span></span><br><span class="line">sema  <span class="type">uint32</span>     <span class="comment">// 控制锁状态的信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-state字段"><a href="#1-1-state字段" class="headerlink" title="1.1 state字段"></a>1.1 state字段</h3><p>低三位分别标识</p><ul><li>mutexLocked（是否上锁）</li><li>mutexWoken（是否有协程在抢锁）</li><li>mutexStarving（是否处于饥饿模式）</li><li>高 29 位的值聚合为一个范围为 0~2^29-1 的整数，表示在阻塞队列中等待的协程个数.</li></ul><h3 id="1-2-正常模式和饥饿模式"><a href="#1-2-正常模式和饥饿模式" class="headerlink" title="1.2 正常模式和饥饿模式"></a>1.2 正常模式和饥饿模式</h3><blockquote><p>mutex 是公平锁</p></blockquote><p><code>正常模式</code>：锁的等待者会按照<code>先进先出</code>的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine <code>超过 1ms</code> 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被<strong>饿死</strong>。<br><code>饥饿模式</code>：互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间<code>少于 1ms</code>，那么当前的互斥锁就会切换回正常模式。</p><h2 id="2-加解锁过程"><a href="#2-加解锁过程" class="headerlink" title="2 加解锁过程"></a>2 加解锁过程</h2><h3 id="2-1-加锁"><a href="#2-1-加锁" class="headerlink" title="2.1 加锁"></a>2.1 加锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/mutex.go 72 行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line"><span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Slow path (outlined so that the fast path can be inlined)</span></span><br><span class="line">m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-1-Fast-path"><a href="#2-1-1-Fast-path" class="headerlink" title="2.1.1 Fast path"></a>2.1.1 Fast path</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先进行 <code>CAS</code> 操作，假如当前未上锁且锁内不存在阻塞协程，则直接 CAS 抢锁成功返回</p></blockquote><h4 id="2-1-2-Slow-Path"><a href="#2-1-2-Slow-Path" class="headerlink" title="2.1.2 Slow Path"></a>2.1.2 Slow Path</h4><p>如果互斥锁的状态不是 0 时就会进入 Slow Path。尝试通过自旋（Spinnig）等方式等待锁的释放，该方法的主体是一个非常大 for 循环，这里将它分成几个部分介绍获取锁的过程：</p><h5 id="2-1-2-1-判断当前-Goroutine-能否进入自旋"><a href="#2-1-2-1-判断当前-Goroutine-能否进入自旋" class="headerlink" title="2.1.2.1 判断当前 Goroutine 能否进入自旋"></a>2.1.2.1 判断当前 Goroutine 能否进入自旋</h5><p><strong>自旋是一种多线程同步机制</strong>，当前的进程在进入自旋的过程中会一直保持 CPU 的占用，持续检查某个条件是否为真。<strong>在多核的 CPU 上，自旋可以避免 Goroutine 的切换</strong>，使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 Goroutine 进入自旋的条件非常苛刻：</p><ul><li>互斥锁只有在普通模式才能进入自旋；</li><li><code>runtime.sync_runtime_canSpin</code>需要返回 true<ul><li>运行在多 CPU 的机器上；</li></ul><ul><li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li><li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li></ul></li></ul><h5 id="2-1-2-2-通过自旋等待互斥锁的释放"><a href="#2-1-2-2-通过自旋等待互斥锁的释放" class="headerlink" title="2.1.2.2 通过自旋等待互斥锁的释放"></a>2.1.2.2 通过自旋等待互斥锁的释放</h5><p>一旦当前 Goroutine 能够进入自旋就会调用<code>runtime.sync_runtime_doSpin</code>和<code>runtime.procyield</code>执行 30 次的 <code>PAUSE</code> 指令，该指令只会占用 CPU 并消耗 CPU 时间：</p><h5 id="2-1-2-3-计算互斥锁的最新状态"><a href="#2-1-2-3-计算互斥锁的最新状态" class="headerlink" title="2.1.2.3 计算互斥锁的最新状态"></a>2.1.2.3 计算互斥锁的最新状态</h5><p>处理了自旋相关的特殊逻辑之后，互斥锁会根据上下文计算当前互斥锁最新的状态。几个不同的条件分别会更新 <code>state</code> 字段中存储的不同信息 — <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 和 <code>mutexWaiterShift</code>：</p><h5 id="2-1-2-4-更新互斥锁的状态并获取锁"><a href="#2-1-2-4-更新互斥锁的状态并获取锁" class="headerlink" title="2.1.2.4 更新互斥锁的状态并获取锁"></a>2.1.2.4 更新互斥锁的状态并获取锁</h5><p>计算了新的互斥锁状态之后，会使用 CAS 函数更新状态<br>如果没有通过 CAS 获得锁，会调用 <code>runtime.sync_runtime_SemacquireMutex</code> 通过信号量保证资源不会被两个 Goroutine 获取。<br><code>runtime.sync_runtime_SemacquireMutex</code> 会在方法中不断尝试获取锁并陷入休眠等待信号量的释放，一旦当前 Goroutine 可以获取信号量，它就会立刻返回，<code>sync.Mutex.Lock</code>的剩余代码也会继续执行。</p><ul><li>在正常模式下，这段代码会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环；</li><li>在饥饿模式下，当前 Goroutine 会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出；</li></ul><h3 id="2-2-解锁"><a href="#2-2-解锁" class="headerlink" title="2.2 解锁"></a>2.2 解锁</h3><h4 id="2-2-1-Fast-path"><a href="#2-2-1-Fast-path" class="headerlink" title="2.2.1 Fast path"></a>2.2.1 Fast path</h4><p>该过程会先使用<code>atomic.AddInt32函数快速解锁，这时会发生下面的两种情况：</code></p><ul><li>如果该函数返回的新状态等于 0，当前 Goroutine 就成功解锁了互斥锁；</li><li>如果该函数返回的新状态不等于 0，则进入 Slow path。<h4 id="2-2-2-Slow-path"><a href="#2-2-2-Slow-path" class="headerlink" title="2.2.2 Slow path"></a>2.2.2 Slow path</h4>先校验锁状态的<code>合法性</code> — 如果当前互斥锁已经被解锁过了会直接抛出异常 “sync: unlock of unlocked mutex” 中止当前程序。<br>在正常模式下，上述代码会使用如下所示的处理过程：</li><li>如果互斥锁不存在等待者或者互斥锁的 <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 状态不都为 0，那么当前方法可以直接返回，不需要唤醒其他等待者；</li><li>如果互斥锁存在等待者，会通过<code>runtime_Semrelease</code>唤醒等待者并移交锁的所有权；<br>在饥饿模式下，上述代码会直接调用<code>runtime_Semrelease</code>将当前锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁，在这时互斥锁还不会退出饥饿状态；</li></ul><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p>互斥锁的<strong>加锁过程</strong>比较复杂，它涉及自旋、信号量以及调度等概念：</p><ul><li>如果互斥锁处于初始化状态，会通过置位 <code>mutexLocked</code> 加锁；</li><li>如果互斥锁处于 <code>mutexLocked</code> 状态并且在普通模式下工作，会进入自旋，执行 30 次 <code>PAUSE</code> 指令消耗 CPU 时间等待锁的释放；</li><li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li><li>互斥锁在正常情况下会通过<code>sync_runtime_SemacquireMutex</code>将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；</li><li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式；</li></ul><p>互斥锁的<strong>解锁过程</strong>与之相比就比较简单：</p><ul><li>当互斥锁已经被解锁时，调用 Mutex.Lock 会直接抛出异常；</li><li>当互斥锁处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 <code>mutexLocked</code> 标志位；</li><li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，会直接返回；在其他情况下会通过<code>sync.runtime_Semrelease</code> 唤醒对应的 Goroutine；</li></ul><h2 id="4-Sync-RWMutex"><a href="#4-Sync-RWMutex" class="headerlink" title="4 Sync.RWMutex"></a>4 Sync.RWMutex</h2><blockquote><p>从逻辑上，可以把 RWMutex 理解为一把读锁加一把写锁；<br>写锁具有<code>严格的排他性</code>，当其被占用，其他试图取写锁或者读锁的 goroutine 均阻塞；<br>读锁具有<code>有限的共享性</code>，当其被占用，试图取写锁的 goroutine 会阻塞，试图取读锁的 goroutine 可与当前 goroutine 共享读锁；<br>RWMutex 适用于<code>读多写少</code>的场景，最理想化的情况，当所有操作均使用读锁，则可实现无锁化；最悲观的情况，倘若所有操作均使用写锁，则 RWMutex 退化为普通的 Mutex.</p></blockquote><h3 id="4-1-数据结构"><a href="#4-1-数据结构" class="headerlink" title="4.1 数据结构"></a>4.1 数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span>   <span class="comment">// 共享读锁的 goroutine 数量上限，值为 2^29；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w           Mutex  <span class="comment">// 内置的一把普通互斥锁 sync.Mutex；</span></span><br><span class="line">    writerSem   <span class="type">uint32</span> <span class="comment">// 关联写锁阻塞队列的信号量；</span></span><br><span class="line">    readerSem   <span class="type">uint32</span> <span class="comment">// 关联读锁阻塞队列的信号量；</span></span><br><span class="line">    readerCount <span class="type">int32</span>  <span class="comment">// 正常情况下等于介入读锁流程的 goroutine 数量；当 goroutine 接入写锁流程时，该值为实际介入读锁流程的 goroutine 数量减 rwmutexMaxReaders.</span></span><br><span class="line">    readerWait  <span class="type">int32</span>  <span class="comment">// 记录在当前 goroutine 获取写锁前，还需要等待多少个 goroutine 释放读锁.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-读锁流程"><a href="#4-2-读锁流程" class="headerlink" title="4.2 读锁流程"></a>4.2 读锁流程</h3><h4 id="4-2-1-RLock"><a href="#4-2-1-RLock" class="headerlink" title="4.2.1 RLock"></a>4.2.1 RLock</h4><p>• 基于原子操作，将 RWMutex 的 readCount 变量加一，表示占用或等待读锁的 goroutine 数加一；<br>• 倘若 RWMutex.readCount 的新值仍小于 0，说明有 goroutine 未释放写锁，因此将当前 goroutine 添加到读锁的阻塞队列中并阻塞挂起.</p><h4 id="4-2-2-RUnlock"><a href="#4-2-2-RUnlock" class="headerlink" title="4.2.2 RUnlock"></a>4.2.2 RUnlock</h4><p>• 基于原子操作，将 RWMutex 的 readCount 变量加一，表示占用或等待读锁的 goroutine 数减一；<br>• 倘若 RWMutex.readCount 的新值小于 0，说明有 goroutine 在等待获取写锁，则走入 RWMutex.rUnlockSlow 的流程中.</p><h4 id="4-2-3-rUnlockSlow"><a href="#4-2-3-rUnlockSlow" class="headerlink" title="4.2.3 rUnlockSlow"></a>4.2.3 rUnlockSlow</h4><p>• 对 RWMutex.readerCount 进行校验，倘若发现当前协程此前未抢占过读锁，或者介入读锁流程的 goroutine 数量达到上限，则抛出 fatal；<br>(倘若 r+1 == -rwmutexMaxReaders，说明此时有 goroutine 介入写锁流程，但当前此前未加过读锁，具体原因见 2.3 小节；倘若 r+1=0，则要么此前未加过读锁，要么介入读锁流程的 goroutine 数量达到上限</p><p>• 基于原子操作，对 RWMutex.readerWait 进行减一操作，倘若其新值为 0，说明当前 goroutine 是最后一个介入读锁流程的协程，因此需要唤醒一个等待写锁的阻塞队列的 goroutine.（综合 RWMutex.readerCount 为负值，可以确定存在等待写锁的 goroutine，具体原因见 2.3 小节.）</p><h3 id="4-3-写锁流程"><a href="#4-3-写锁流程" class="headerlink" title="4.3 写锁流程"></a>4.3 写锁流程</h3><h4 id="4-3-1-Lock"><a href="#4-3-1-Lock" class="headerlink" title="4.3.1 Lock"></a>4.3.1 Lock</h4><p>• 对 RWMutex 内置的互斥锁进行加锁操作；<br>• 基于原子操作，对 RWMutex.readerCount 进行减少 -rwmutexMaxReaders 的操作；<br>• 倘若此时存在未释放读锁的 gouroutine，则基于原子操作在 RWMutex.readerWait 的基础上加上介入读锁流程的 goroutine 数量，并将当前 goroutine 添加到写锁的阻塞队列中挂起.</p><h4 id="4-3-2-Unlock"><a href="#4-3-2-Unlock" class="headerlink" title="4.3.2 Unlock"></a>4.3.2 Unlock</h4><p>• 基于原子操作，将 RWMutex.readerCount 的值加上 rwmutexMaxReaders；<br>• 倘若发现 RWMutex.readerCount 的新值大于 rwmutexMaxReaders，则说明要么当前 RWMutex 未上过写锁，要么介入读锁流程的 goroutine 数量已经超限，因此直接抛出 fatal；<br>• 因此唤醒读锁阻塞队列中的所有 goroutine；(可见，竞争读锁的 goroutine 更具备优势)<br>• 解开 RWMutex 内置的互斥锁.</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h2><p>go-sync.Mutex 是 Go 语言中实现互斥锁的核心结构，通过 state 字段管理锁状态（正常/饥饿模式），利用 CAS 操作和信号量控制协程的加解锁流程，其中写锁具有严格排他性，读锁支持有限共享，适用于读多写少场景，通过自旋和队列调度平衡性能与公平性。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;sync.Mutex 是 Go 语言中实现互斥锁的核心结构&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
    <category term="Go并发编程" scheme="https://stardustorz.github.io/tags/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Go] sync.Pool</title>
    <link href="https://stardustorz.github.io/2025/06/20/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Pool/"/>
    <id>https://stardustorz.github.io/2025/06/20/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Pool/</id>
    <published>2025-06-20T03:02:24.000Z</published>
    <updated>2025-07-27T15:41:00.401Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>sync.Pool 可以作为保存临时取还对象的一个“池子”，可以缓存暂时不用的对象，下次需要时直接使用（无需重新分配）。</p></blockquote><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><h3 id="1-1-大致理念"><a href="#1-1-大致理念" class="headerlink" title="1.1 大致理念"></a>1.1 大致理念</h3><blockquote><p>因为频繁的内存分配和回收会对性能产生影响，通过复用临时对象就可以避免改问题。</p></blockquote><p>下面是 2018 年的时候，《Go 夜读》上关于 <code>sync.Pool</code> 的分享，关于适用场景：</p><blockquote><p>当多个 goroutine 都需要创建同⼀个对象的时候，如果 goroutine 数过多，导致对象的创建数⽬剧增，进⽽导致 GC 压⼒增大。形成 “并发⼤－占⽤内存⼤－GC 缓慢－处理并发能⼒降低－并发更⼤”这样的恶性循环。 在这个时候，需要有⼀个对象池，每个 goroutine 不再⾃⼰单独创建对象，⽽是从对象池中获取出⼀个对象（如果池中已经有的话）。</p></blockquote><p>因此关键思想就是对象的复用，避免重复创建、销毁，下面我们来看看如何使用。</p><p>所以，sync.pool 的作用一句话描述就是，<strong>复用临时对象，以避免频繁的内存分配和回收，从而减少 GC 压力</strong>。</p><h3 id="1-2-基本使用"><a href="#1-2-基本使用" class="headerlink" title="1.2 基本使用"></a>1.2 基本使用</h3><p>首先，<code>sync.Pool</code> 是协程安全的，这对于使用者来说是极其方便的。使用前，设置好对象的 <code>New</code> 函数，用于在 <code>Pool</code> 里没有缓存的对象时，创建一个。之后，在程序的任何地方、任何时候仅通过 <code>Get()</code>、<code>Put()</code> 方法就可以取、还对象了。</p><p>以下为基本使用 demo：</p><blockquote><p>完整代码见 <a href="#">Github</a><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> main  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">   <span class="string">&quot;sync&quot;</span>  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;  </span><br><span class="line">   Name   <span class="type">string</span>  </span><br><span class="line">   Remark [<span class="number">1024</span>]<span class="type">byte</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Gopher)</span></span> Reset() &#123;  </span><br><span class="line">   s.Name = <span class="string">&quot;&quot;</span>  </span><br><span class="line">   s.Remark = [<span class="number">1024</span>]<span class="type">byte</span>&#123;&#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">var</span> gopherPool = sync.Pool&#123;  </span><br><span class="line">   New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">new</span>(Gopher)  </span><br><span class="line">   &#125;,  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   g := gopherPool.Get().(*Gopher)  </span><br><span class="line">   fmt.Println(<span class="string">&quot;首次从 pool 里获取：&quot;</span>, g.Name)  </span><br><span class="line"> ​  </span><br><span class="line">   g.Name = <span class="string">&quot;first&quot;</span>  </span><br><span class="line">   fmt.Printf(<span class="string">&quot;设置 p.Name = %s\n&quot;</span>, g.Name)  </span><br><span class="line">   gopherPool.Put(g)  </span><br><span class="line"> ​  </span><br><span class="line">   fmt.Println(<span class="string">&quot;Pool 里已有一个对象：&amp;&#123;first&#125;，调用 Get: &quot;</span>, gopherPool.Get().(*Gopher).Name)  </span><br><span class="line">   fmt.Println(<span class="string">&quot;Pool 没有对象了，调用 Get: &quot;</span>, gopherPool.Get().(*Gopher).Name)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>运行结果：<br> 首次从 pool 里获取：<br> 设置 p.Name = first<br> Pool 里已有一个对象：&amp;{first}，调用 Get:  first<br> Pool 没有对象了，调用 Get:<br>首先，需要初始化 <code>Pool</code>，唯一需要的就是设置好 <code>New</code> 函数。当调用 Get 方法时，如果池子里缓存了对象，就直接返回缓存的对象。如果没有存货，则调用 New 函数创建一个新的对象。</p></blockquote><p>另外，我们发现 Get 方法取出来的对象和上次 Put 进去的对象实际上是同一个，Pool 没有做任何“清空”的处理。但我们不应当对此有任何假设，因为在实际的并发使用场景中，无法保证这种顺序，<strong>最好的做法是在 Put 前，将对象清空</strong>。</p><p><strong>Benchmark</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> defaultGopher, _ = json.Marshal(Gopher&#123;Name: <span class="string">&quot;17x&quot;</span>&#125;)  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">BenchmarkUnmarshal</span><span class="params">(b *testing.B)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">var</span> g *Gopher  </span><br><span class="line">   <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;  </span><br><span class="line">     g = <span class="built_in">new</span>(Gopher)  </span><br><span class="line">     json.Unmarshal(defaultGopher, g)  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">BenchmarkUnmarshalWithPool</span><span class="params">(b *testing.B)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">var</span> g *Gopher  </span><br><span class="line">   <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;  </span><br><span class="line">     g = gopherPool.Get().(*Gopher)  </span><br><span class="line">     json.Unmarshal(defaultGopher, g)  </span><br><span class="line">     g.Reset() <span class="comment">// 重置后在放进去  </span></span><br><span class="line">     gopherPool.Put(g)  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure><br> ​<br>运行结果：</p><p> BenchmarkUnmarshal-6                9518            124806 ns/op            1280 B/op          6 allocs/op<br> BenchmarkUnmarshalWithPool-6       10000            124350 ns/op             128 B/op          5 allocs/op<br> <code>3287449 357 ns/op</code> 表示单位时间内（默认是1s）被测函数运行了 3287449 次，每次运行耗时 357ns，<br> <code>B/op</code> 是每个操作分配的字节数<br> <code>allocs/op</code> 表示每个操作(单次迭代)发生了多少不同的内存分配。</p><p>功能比较简单，其中 json 反序列化占用了大量时间，因此两种方式最终的执行时间几乎没什么变化。但是内存占用差了一个数量级，使用了 <code>sync.Pool</code> 后，内存占用仅为未使用的 128/1280=1/10，对 GC 的影响就很大了。</p><h3 id="1-3-使用案例"><a href="#1-3-使用案例" class="headerlink" title="1.3 使用案例"></a>1.3 使用案例</h3><h4 id="1-3-1-fmt-包"><a href="#1-3-1-fmt-包" class="headerlink" title="1.3.1 fmt 包"></a>1.3.1 fmt 包</h4><p>这部分主要看 <code>fmt.Printf</code> 如何使用：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;  </span><br><span class="line">   <span class="keyword">return</span> Fprintf(os.Stdout, format, a...)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>继续看 <code>Fprintf</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;  </span><br><span class="line">   p := newPrinter()  </span><br><span class="line">   p.doPrintf(format, a)  </span><br><span class="line">   n, err = w.Write(p.buf)  </span><br><span class="line">   p.free()  </span><br><span class="line">   <span class="keyword">return</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br><code>Fprintf</code> 函数的参数是一个 <code>io.Writer</code>，<code>Printf</code> 传的是 <code>os.Stdout</code>，相当于直接输出到标准输出。这里的 <code>newPrinter</code> 用的就是 Pool：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> ppFree = sync.Pool&#123;  </span><br><span class="line">   New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123; <span class="keyword">return</span> <span class="built_in">new</span>(pp) &#125;,  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">newPrinter</span><span class="params">()</span></span> *pp &#123;  </span><br><span class="line">   p := ppFree.Get().(*pp)  </span><br><span class="line">   p.panicking = <span class="literal">false</span>  </span><br><span class="line">   p.erroring = <span class="literal">false</span>  </span><br><span class="line">   p.wrapErrs = <span class="literal">false</span>  </span><br><span class="line">   p.fmt.init(&amp;p.buf)  </span><br><span class="line">   <span class="keyword">return</span> p  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>回到 <code>Fprintf</code> 函数，拿到 pp 指针后，会做一些 format 的操作，并且将 p.buf 里面的内容写入 w。最后，调用 free 函数，将 pp 指针归还到 Pool 中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(p *pp)</span></span> free() &#123;  </span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">cap</span>(p.buf) &gt; <span class="number">64</span>&lt;&lt;<span class="number">10</span> &#123;  </span><br><span class="line">     <span class="keyword">return</span>  </span><br><span class="line">   &#125;  </span><br><span class="line"> ​  </span><br><span class="line">   p.buf = p.buf[:<span class="number">0</span>]  </span><br><span class="line">   p.arg = <span class="literal">nil</span>  </span><br><span class="line">   p.value = reflect.Value&#123;&#125;  </span><br><span class="line">   p.wrappedErr = <span class="literal">nil</span>  </span><br><span class="line">   ppFree.Put(p)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>归还到 Pool 前还进行了<strong>字段清零</strong>，这样，通过 Get 拿到缓存的对象时，就可以安全地使用了。</p><h4 id="1-3-2-gin-框架"><a href="#1-3-2-gin-框架" class="headerlink" title="1.3.2 gin 框架"></a>1.3.2 gin 框架</h4><p>gin 框架会给每个请求分配一个 Context 用以进行追踪，这就是典型的 sync.pool 使用场景：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Engine &#123;  </span><br><span class="line">engine := &amp;Engine&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">engine.pool.New = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line"><span class="keyword">return</span> engine.allocateContext()  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> engine  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> allocateContext() *Context &#123;  </span><br><span class="line"><span class="keyword">return</span> &amp;Context&#123;engine: engine&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;  </span><br><span class="line">c := engine.pool.Get().(*Context)  </span><br><span class="line">c.writermem.reset(w)  </span><br><span class="line">c.Request = req  </span><br><span class="line">c.reset()  </span><br><span class="line">  </span><br><span class="line">engine.handleHTTPRequest(c)  </span><br><span class="line">  </span><br><span class="line">engine.pool.Put(c)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从 pool 中获取 Context 对象，用完后又还回去，注意 还回去之前这里也调用了 reset() 方法进行<strong>字段清空</strong>。</p><h3 id="1-4-正确姿势"><a href="#1-4-正确姿势" class="headerlink" title="1.4 正确姿势"></a>1.4 正确姿势</h3><p>根据以上几个案例，可以看出正确使用姿势就是：</p><ul><li><p>1）设置 New 方法</p></li><li><p>2）使用时直接 Get</p></li><li><p>3）使用完成后先进行<strong>字段清空</strong>,然后在 Put 回去。</p></li></ul><blockquote><p>一定要进行 Reset，不然会出现意想不到的问题。分享一个<a href="https://github.com/lixd/daily-notes/blob/master/Golang/FAQ/mongodb%E9%87%87%E5%9D%91.md">类似的坑</a></p></blockquote><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><blockquote><p>一下分析基于 Go 1.17.1</p></blockquote><h3 id="2-1-Pool-结构体"><a href="#2-1-Pool-结构体" class="headerlink" title="2.1 Pool 结构体"></a>2.1 Pool 结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;  </span><br><span class="line">noCopy noCopy  </span><br><span class="line">local     unsafe.Pointer <span class="comment">// local fixed-size per-P pool, actual type is [P]poolLocal  </span></span><br><span class="line">localSize <span class="type">uintptr</span>        <span class="comment">// size of the local array  </span></span><br><span class="line">victim     unsafe.Pointer <span class="comment">// local from previous cycle  </span></span><br><span class="line">victimSize <span class="type">uintptr</span>        <span class="comment">// size of victims array  </span></span><br><span class="line">New <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段详解：</p><ul><li><code>noCopy</code>对象，实现了<code>sync.Locker</code>接口，使得内嵌了 noCopy 的对象在进行 go vet 静态检查的时候，可以检查出是否被复制。<ul><li>具体见 <a href="https://github.com/golang/go/issues/8005">Go issues 8005</a></li><li>说明 Pool 对象也是不允许复制的。</li></ul></li><li><code>local</code> 字段存储指向 <code>[P]poolLocal</code> 数组（严格来说，它是一个切片）的指针。<code>localSize</code> 则表示 local 数组的大小。<ul><li>访问时，根据 P 的 id 去访问对应下标的 <code>local[pid]</code></li><li>通过这样的设计，多个 goroutine 使用同一个 Pool 时，减少了竞争，提升了性能。</li><li>有点类似于降低锁粒度，分段锁的思想。</li></ul></li><li><code>victim</code> 和 <code>victimSize</code> 则会在在一轮 GC 到来时，分别“接管” local 和 localSize。<ul><li>victim cache 是一种提高缓存性能的硬件技术;</li><li><code>victim</code> 的机制用于减少 GC 后冷启动导致的性能抖动，让分配对象更平滑;</li></ul></li><li><code>New</code>就是我们指定的新建对象的方法。</li></ul><blockquote><p><a href="https://en.wikipedia.org/wiki/Victim_cache">Victim Cache</a> 是一种提高缓存性能的硬件技术，主要用于提升缓存命令率。<br>所谓受害者缓存（Victim Cache），是一个与直接匹配或低相联缓存并用的、容量很小的全相联缓存。当一个数据块被逐出缓存时，并不直接丢弃，而是暂先进入受害者缓存。如果受害者缓存已满，就替换掉其中一项。当进行缓存标签匹配时，在与索引指向标签匹配的同时，并行查看受害者缓存，如果在受害者缓存发现匹配，就将其此数据块与缓存中的不匹配数据块做交换，同时返回给处理器。</p></blockquote><h4 id="2-1-1-local"><a href="#2-1-1-local" class="headerlink" title="2.1.1 local"></a>2.1.1 local</h4><p>local 具体结构如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> &#123;  </span><br><span class="line">poolLocalInternal  </span><br><span class="line">    <span class="comment">// 将 poolLocal 补齐至128字节(即两个cache line)的倍数，防止 false sharing,  </span></span><br><span class="line">    <span class="comment">// 伪共享，仅占位用，防止在 cache line 上分配多个 poolLocalInternal  </span></span><br><span class="line">pad [<span class="number">128</span> - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%<span class="number">128</span>]<span class="type">byte</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">type</span> poolLocalInternal <span class="keyword">struct</span> &#123;  </span><br><span class="line">private <span class="keyword">interface</span>&#123;&#125; <span class="comment">// Can be used only by the respective P.  </span></span><br><span class="line">shared  poolChain   <span class="comment">// Local P can pushHead/popHead; any P can popTail.  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>poolLocalInternal</code>对象 中包含一个 <code>private</code> 和 <code>shared</code>。其中 private 只有当前 p 能用，shared 则是其他 p 都可以用。</p><h4 id="2-1-2-cpu-cache-amp-false-sharing"><a href="#2-1-2-cpu-cache-amp-false-sharing" class="headerlink" title="2.1.2 cpu cache &amp; false sharing"></a>2.1.2 cpu cache &amp; false sharing</h4><p><strong>cpu cache</strong><br>现代 cpu 中，cache 都划分成以 cache line (cache block) 为单位，在 x86_64 体系下一般都是 64 字节，cache line 是操作的最小单元。 程序即使只想读内存中的 1 个字节数据，也要同时把附近 63 节字加载到 cache 中，如果读取超个 64 字节，那么就要加载到多个 cache line 中。<br>这样，访问后续 63 字节数据时就可以直接从 cache line 中读取，性能有很大提升。</p><p><strong><a href="https://en.wikipedia.org/wiki/False_sharing">false sharing</a></strong></p><blockquote><p>伪共享的非标准定义为：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会令整个 cache line 失效，无意中影响彼此的性能，这就是伪共享。</p></blockquote><p>简单来说，如果没有 pad 字段，那么当需要访问 0 号索引的 poolLocal 时，CPU 同时会把 0 号和 1 号索引同时加载到 cpu cache。在只修改 0 号索引的情况下，会让 1 号索引的 poolLocal 失效。这样，当其他线程想要读取 1 号索引时，发生 cache miss，还得重新再加载，对性能有损。增加一个 <code>pad</code>，补齐缓存行，让相关的字段能独立地加载到缓存行就不会出现 <code>false sharding</code> 了。</p><h4 id="2-1-3-poolChain"><a href="#2-1-3-poolChain" class="headerlink" title="2.1.3 poolChain"></a>2.1.3 poolChain</h4><p><code>poolChain</code> 是一个双端队列的实现<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolChain <span class="keyword">struct</span> &#123;  </span><br><span class="line">  </span><br><span class="line">   head *poolChainElt  </span><br><span class="line">  </span><br><span class="line">   tail *poolChainElt  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> poolChainElt <span class="keyword">struct</span> &#123;  </span><br><span class="line">poolDequeue  </span><br><span class="line">  </span><br><span class="line">next, prev *poolChainElt  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> poolDequeue <span class="keyword">struct</span> &#123;  </span><br><span class="line">  </span><br><span class="line">headTail <span class="type">uint64</span>  </span><br><span class="line">  </span><br><span class="line">vals []eface  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>poolDequeue</code> 被实现为单生产者、多消费者的固定大小的无锁（atomic 实现） Ring 式队列（底层存储使用数组，使用两个指针标记 head、tail）。生产者可以从 head 插入、head 删除，而消费者仅可从 tail 删除。 <code>headTail</code> 指向队列的头和尾，通过位运算将 head 和 tail 存入 headTail 变量中。</p><p>我们用一幅图来完整地描述 Pool 结构体：</p><p>![[pool-structure.png]]</p><blockquote><p>图源：<a href="https://zhuanlan.zhihu.com/p/133638023">码农桃花源</a></p><h3 id="2-2-大致流程"><a href="#2-2-大致流程" class="headerlink" title="2.2 大致流程"></a>2.2 大致流程</h3></blockquote><p>分析完 Pool 结构体之后，先提前说明一下大致的流程，后续分析时便于理解。</p><p><strong>存储</strong></p><p>为每个 P 开辟了一个 Local 用于数据，降低竞争。</p><p>Local 中包含 private 和 shared。</p><ul><li><p>private ：只有当前 P 能使用</p></li><li><p>shared：所有 P 共享，当 private 没有时优先去当前 P 的 local.shared 中取，如果还没有就去其他 P 中 local.shared 中窃取一个来用。</p></li></ul><p><strong>Get</strong></p><p>优先从当前P 的 local.private 中取，没有则从当前 P 的 local.shared 中取，还没有则去其他 P 中 local.shared 中窃取一个。</p><p><strong>Put</strong></p><p>优先存放到当前 P 的 local.private，local.private 已经有值了就往 shared 中放。</p><h3 id="2-3-Get"><a href="#2-3-Get" class="headerlink" title="2.3 Get"></a>2.3 Get</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Get() <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">l, pid := p.pin()  </span><br><span class="line">x := l.private  </span><br><span class="line">l.private = <span class="literal">nil</span>  </span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;  </span><br><span class="line">x, _ = l.shared.popHead()  </span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;  </span><br><span class="line">x = p.getSlow(pid)  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">runtime_procUnpin()  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;  </span><br><span class="line">x = p.New()  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> x  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程如下：</p><ol><li><p>首先，调用 <code>p.pin()</code> 函数将当前的 goroutine 和 P 绑定，禁止被抢占，返回当前 P 对应的 poolLocal，以及 pid。</p></li><li><p>然后直接取 l.private，赋值给 x，并置 l.private 为 nil。</p></li><li><p>判断 x 是否为空，若为空，则尝试从 l.shared 的头部 pop 一个对象出来，同时赋值给 x。</p></li><li><p>如果 x 仍然为空，则调用 getSlow 尝试从其他 P 的 shared 双端队列尾部“偷”一个对象出来。</p></li><li><p>Pool 的相关操作做完了，调用 <code>runtime_procUnpin()</code> 解除禁止抢占。</p></li><li><p>最后如果还是没有取到缓存的对象，那就直接调用预先设置好的 New 函数，创建一个出来。</p></li></ol><h4 id="2-3-1-pin"><a href="#2-3-1-pin" class="headerlink" title="2.3.1 pin"></a>2.3.1 pin</h4><p>首先，调用 <code>p.pin()</code> 函数将当前的 goroutine 和 P 绑定，禁止被抢占，返回当前 P 对应的 poolLocal，以及 pid。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pin() (*poolLocal, <span class="type">int</span>) &#123;  </span><br><span class="line">   <span class="comment">// pin 具体逻辑由 runtime_procPin 实现  </span></span><br><span class="line">   pid :=  runtime_procPin()  </span><br><span class="line">   <span class="comment">// 原子操作取出 p.localSize 和 p.local  </span></span><br><span class="line">   s := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire  </span></span><br><span class="line">   l := p.local                              <span class="comment">// load-consume  </span></span><br><span class="line">   <span class="comment">// 因为是把 pid 做下标从 pool.local 中取得 p 对应的 local 的，  </span></span><br><span class="line">   <span class="comment">// 所以如果 pid 小于 pool.local size 的时候才有可能取到对应的 local  </span></span><br><span class="line">   <span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;  </span><br><span class="line">      <span class="keyword">return</span> indexLocal(l, pid), pid  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// 正常情况下会一直满足该条件，  </span></span><br><span class="line">   <span class="comment">// 只有刚开始  pool.local 还没创建或者动态调整了 P 的数量这两种情况  </span></span><br><span class="line">   <span class="comment">// 会进入到下面的逻辑 去创建 pool.local  </span></span><br><span class="line">   <span class="keyword">return</span> p.pinSlow()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-3-2-pinSlow"><a href="#2-3-2-pinSlow" class="headerlink" title="2.3.2 pinSlow"></a>2.3.2 pinSlow</h4><p>pinSlow 主要是完成 pool.local 的创建。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pinSlow() (*poolLocal, <span class="type">int</span>) &#123;  </span><br><span class="line">    <span class="comment">// 这里先取消绑定，然后加锁，最后有绑定上  </span></span><br><span class="line">runtime_procUnpin()  </span><br><span class="line">allPoolsMu.Lock()  </span><br><span class="line"><span class="keyword">defer</span> allPoolsMu.Unlock()  </span><br><span class="line">pid := runtime_procPin()  </span><br><span class="line"><span class="comment">// doubleCheck 因为在执行上述命令过程中 pinSlow 可能已经被其他的线程调用，因此这时候需要再次对 pid 进行检查  </span></span><br><span class="line">s := p.localSize  </span><br><span class="line">l := p.local  </span><br><span class="line"><span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;  </span><br><span class="line"><span class="keyword">return</span> indexLocal(l, pid), pid  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> p.local == <span class="literal">nil</span> &#123;  </span><br><span class="line">allPools = <span class="built_in">append</span>(allPools, p)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 根据当前 P 的数量创建 pool.local并更新pool.localSize  </span></span><br><span class="line">size := runtime.GOMAXPROCS(<span class="number">0</span>)  </span><br><span class="line">local := <span class="built_in">make</span>([]poolLocal, size)  </span><br><span class="line">atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="number">0</span>])) <span class="comment">// store-release  </span></span><br><span class="line">runtime_StoreReluintptr(&amp;p.localSize, <span class="type">uintptr</span>(size))     <span class="comment">// store-release  </span></span><br><span class="line">    <span class="comment">// 最后根据 pid 返回当前 P 对应的 local  </span></span><br><span class="line"><span class="keyword">return</span> &amp;local[pid], pid  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### popHead</span><br><span class="line"></span><br><span class="line">然后回到 Get 方法</span><br><span class="line">```go</span><br><span class="line">x := l.private  </span><br><span class="line">l.private = nil  </span><br><span class="line">if x == nil &#123;  </span><br><span class="line">x, _ = l.shared.popHead()  </span><br><span class="line">if x == nil &#123;  </span><br><span class="line">x = p.getSlow(pid)  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">优先从 local.private 中取，如果没有就调用`poolChain.popHead()`去 local.shared 中取一个。</span><br><span class="line">```go</span><br><span class="line">func (c *poolChain) popHead() (interface&#123;&#125;, bool) &#123;  </span><br><span class="line">d := c.head  </span><br><span class="line">for d != nil &#123;  </span><br><span class="line">if val, ok := d.popHead(); ok &#123;  </span><br><span class="line">return val, ok  </span><br><span class="line">&#125;  </span><br><span class="line">d = loadPoolChainElt(&amp;d.prev)  </span><br><span class="line">&#125;  </span><br><span class="line">return nil, false  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`popHead` 函数只会被 producer 调用。首先拿到头节点：c.head，如果头节点不为空的话，尝试调用头节点的 `poolDequeue.popHead` 方法。</span><br><span class="line">```go</span><br><span class="line">func (d *poolDequeue) popHead() (interface&#123;&#125;, bool) &#123;  </span><br><span class="line">var slot *eface  </span><br><span class="line">for &#123;  </span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">head, tail := d.unpack(ptrs)  </span><br><span class="line">        // 收尾相连则说明队列是空的  </span><br><span class="line">if tail == head &#123;  </span><br><span class="line">return nil, false  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// head 位置是队头的前一个位置，所以此处要先退一位。  </span><br><span class="line">        // 在读出 slot 的 value 之前就把 head 值减 1，取消对这个 slot 的控制  </span><br><span class="line">head--  </span><br><span class="line">ptrs2 := d.pack(head, tail)  </span><br><span class="line">        // 通过 CAS 操作更新头部的位置 这样当前头部第一个元素就算是被移除了  </span><br><span class="line">if atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;  </span><br><span class="line">slot = &amp;d.vals[head&amp;uint32(len(d.vals)-1)]  </span><br><span class="line">break  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">    // 类型转换与 nil 判断  </span><br><span class="line">val := *(*interface&#123;&#125;)(unsafe.Pointer(slot))  </span><br><span class="line">if val == dequeueNil(nil) &#123;  </span><br><span class="line">val = nil  </span><br><span class="line">&#125;  </span><br><span class="line">    // 然后把这个 slot 置空，因为现在这个 slot 已经是队列的 head 了，置空便于前一个 head 被回收。  </span><br><span class="line">*slot = eface&#123;&#125;  </span><br><span class="line">return val, true  </span><br><span class="line">&#125;```</span><br></pre></td></tr></table></figure><p>此函数会删掉并且返回 <code>queue</code> 的头节点。但如果 <code>queue</code> 为空的话，返回 false。这里的 <code>queue</code> 存储的实际上就是 Pool 里缓存的对象。</p><p>整个函数的核心是一个无限循环，这是 Go 中常用的无锁化编程形式。</p><p>首先调用 unpack 函数分离出 head 和 tail 指针，如果 head 和 tail 相等，即首尾相等，那么这个队列就是空的，直接就返回 nil，false。</p><p>否则，将 head 指针后移一位，即 head 值减 1，然后调用 pack 打包 head 和 tail 指针。使用 CAS 更新 headTail 的值，并且把 vals 相应索引处的元素赋值给 slot。</p><blockquote><p>因为 <code>vals</code> 长度实际是只能是 2 的 n 次幂，因此 <code>len(d.vals)-1</code> 实际上得到的值的低 n 位是全 1，它再与 head 进行与运算，实际就是取 head 低 n 位的值作为下标。</p></blockquote><p>得到相应 slot 的元素后，经过类型转换并判断是否是 <code>dequeueNil</code>，如果是，说明没取到缓存的对象，返回 nil。</p><p>type dequeueNil *struct{}</p><p>最后，返回 val 之前，将 slot “归零”，移除和上一个 head 的关联，便于回收上一个 Head。</p><p>*slot = eface{}</p><p>结束后回到 <code>poolChain.popHead()</code>，如果调用 <code>poolDequeue.popHead()</code> 拿到了缓存的对象，就直接返回。否则，将 <code>d</code> 重新指向 <code>d.prev</code>，继续尝试获取缓存的对象。</p><h4 id="2-3-3-getSlow"><a href="#2-3-3-getSlow" class="headerlink" title="2.3.3 getSlow"></a>2.3.3 getSlow</h4><p>如果在 shared 里没有获取到缓存对象，则继续调用 <code>Pool.getSlow()</code>，尝试从其他 P 的 poolLocal 偷取：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> getSlow(pid <span class="type">int</span>) <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line">size := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire  </span></span><br><span class="line">locals := p.local                            <span class="comment">// load-consume  </span></span><br><span class="line">    <span class="comment">// 尝试从其他 p 中窃取一个对象  </span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;  </span><br><span class="line">        <span class="comment">// (pid+i+1)%int(size) 保证每次都可以从 当前pid+1 这个位置开始尝试窃取。  </span></span><br><span class="line">l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="type">int</span>(size))  </span><br><span class="line">        <span class="comment">// 如果能取到就直接返回  </span></span><br><span class="line"><span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> x  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 尝试从其他 P 的 poolLocal 窃取失败后，再尝试从victim cache中取对象  </span></span><br><span class="line">    <span class="comment">// 这样可以使 victim 中的对象更容易被回收。  </span></span><br><span class="line">size = atomic.LoadUintptr(&amp;p.victimSize)  </span><br><span class="line"><span class="keyword">if</span> <span class="type">uintptr</span>(pid) &gt;= size &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">locals = p.victim  </span><br><span class="line">l := indexLocal(locals, pid)  </span><br><span class="line"><span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123;  </span><br><span class="line">l.private = <span class="literal">nil</span>  </span><br><span class="line"><span class="keyword">return</span> x  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;  </span><br><span class="line">l := indexLocal(locals, (pid+i)%<span class="type">int</span>(size))  </span><br><span class="line"><span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> x  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 清空 victim cache。下次就不用再从这里找了  </span></span><br><span class="line">atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;<span class="string">``</span><span class="string">`</span></span><br></pre></td></tr></table></figure></p><p>从索引为 pid+1 的 poolLocal 处开始，尝试调用 <code>shared.popTail()</code> 获取缓存对象。如果没有拿到，则从 victim 里找，和 poolLocal 的逻辑类似。</p><p>最后，实在没找到，就把 victimSize 置 0，防止后来的“人”再到 victim 里找。</p><p>在 Get 函数的最后，经过这一番操作还是没找到缓存的对象，就调用 New 函数创建一个新的对象。</p><h4 id="2-3-4-popTail"><a href="#2-3-4-popTail" class="headerlink" title="2.3.4 popTail"></a>2.3.4 popTail</h4><p>最后，还剩一个 popTail 函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> popTail() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;  </span><br><span class="line">    <span class="comment">// tail 指针为空直接返回 这里的 tail 是一个双端队列  </span></span><br><span class="line">d := loadPoolChainElt(&amp;c.tail)  </span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> &#123;  </span><br><span class="line"><span class="comment">// It&#x27;s important that we load the next pointer  </span></span><br><span class="line"><span class="comment">// *before* popping the tail. In general, d may be  </span></span><br><span class="line"><span class="comment">// transiently empty, but if next is non-nil before  </span></span><br><span class="line"><span class="comment">// the pop and the pop fails, then d is permanently  </span></span><br><span class="line"><span class="comment">// empty, which is the only condition under which it&#x27;s  </span></span><br><span class="line"><span class="comment">// safe to drop d from the chain.  </span></span><br><span class="line">        <span class="comment">// 在 for 循环的一开始，就把 d.next 加载到了 d2。因为 d 可能会短暂为空，但如果 d2 在 pop 或者 pop fails 之前就不为空的话，说明 d 就会永久为空了。在这种情况下，可以安全地将 d 这个结点“甩掉”。  </span></span><br><span class="line">d2 := loadPoolChainElt(&amp;d.next)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> val, ok := d.popTail(); ok &#123;  </span><br><span class="line"><span class="keyword">return</span> val, ok  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> d2 == <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="comment">// This is the only dequeue. It&#x27;s empty right  </span></span><br><span class="line"><span class="comment">// now, but could be pushed to in the future.  </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 同样的通过 CAS 来更新 tail 的值为 d2  </span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) &#123;  </span><br><span class="line">storePoolChainElt(&amp;d2.prev, <span class="literal">nil</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">        <span class="comment">// 最后将d2赋值给d便于进行下一轮循环。  </span></span><br><span class="line">d = d2  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p><p>在 for 循环的一开始，就把 d.next 加载到了 d2。因为 d 可能会短暂为空，但如果 d2 在 pop 或者 pop fails 之前就不为空的话，说明 d 就会永久为空了。在这种情况下，可以安全地将 d 这个结点“甩掉”。</p><p>最后，将 c.tail 更新为 d2，可以防止下次 popTail 的时候查看一个空的 dequeue；而将 d2.prev 设置为 nil，可以防止下次 popHead 时查看一个空的 dequeue。</p><p>我们再看一下核心的 <code>poolDequeue.popTail</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popTail() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;  </span><br><span class="line"><span class="keyword">var</span> slot *eface  </span><br><span class="line"><span class="keyword">for</span> &#123;  </span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">head, tail := d.unpack(ptrs)  </span><br><span class="line">        <span class="comment">// 同样的 head=tail 说明队列为空  </span></span><br><span class="line"><span class="keyword">if</span> tail == head &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 同样是 CAS 更新 headTail 以移除 tail 元素  </span></span><br><span class="line">ptrs2 := d.pack(head, tail+<span class="number">1</span>)  </span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;  </span><br><span class="line"><span class="comment">// Success.  </span></span><br><span class="line">slot = &amp;d.vals[tail&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]  </span><br><span class="line"><span class="keyword">break</span>  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 类型转换和 nil 判断  </span></span><br><span class="line">val := *(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot))  </span><br><span class="line"><span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;  </span><br><span class="line">val = <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 最后也是将这个 slot 置空  </span></span><br><span class="line">    <span class="comment">// 先清空 val 再清空 typ 操作顺序和 pushHead 正好相反  </span></span><br><span class="line">slot.val = <span class="literal">nil</span>  </span><br><span class="line">atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">true</span>  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popTail() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;  </span><br><span class="line"><span class="keyword">var</span> slot *eface  </span><br><span class="line"><span class="keyword">for</span> &#123;  </span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">head, tail := d.unpack(ptrs)  </span><br><span class="line">        <span class="comment">// 同样的 head=tail 说明队列为空  </span></span><br><span class="line"><span class="keyword">if</span> tail == head &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 同样是 CAS 更新 headTail 以移除 tail 元素  </span></span><br><span class="line">ptrs2 := d.pack(head, tail+<span class="number">1</span>)  </span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;  </span><br><span class="line"><span class="comment">// Success.  </span></span><br><span class="line">slot = &amp;d.vals[tail&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]  </span><br><span class="line"><span class="keyword">break</span>  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 类型转换和 nil 判断  </span></span><br><span class="line">val := *(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot))  </span><br><span class="line"><span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;  </span><br><span class="line">val = <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 最后也是将这个 slot 置空  </span></span><br><span class="line">    <span class="comment">// 先清空 val 再清空 typ 操作顺序和 pushHead 正好相反  </span></span><br><span class="line">slot.val = <span class="literal">nil</span>  </span><br><span class="line">atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>)  </span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整体逻辑和 popHead 差不多。</p><h4 id="2-3-5-小结"><a href="#2-3-5-小结" class="headerlink" title="2.3.5 小结"></a>2.3.5 小结</h4><p>首先从 当前 p 对应的 local.private 上取，没有就从 local.shared 里取，还没有就去其他 p 的 local.shared 里取，都没有就 new 一个返回。</p><h3 id="2-4-Put"><a href="#2-4-Put" class="headerlink" title="2.4 Put"></a>2.4 Put</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Put(x <span class="keyword">interface</span>&#123;&#125;) &#123;  </span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">return</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">l, _ := p.pin()  </span><br><span class="line"><span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123;  </span><br><span class="line">l.private = x  </span><br><span class="line">x = <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> x != <span class="literal">nil</span> &#123;  </span><br><span class="line">l.shared.pushHead(x)  </span><br><span class="line">&#125;  </span><br><span class="line">runtime_procUnpin()  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程也比较简单：</p><ol><li>先绑定 g 和 P，然后尝试将 x 赋值给 private 字段。</li><li>如果失败，就调用 <code>pushHead</code> 方法尝试将其放入 shared 字段所维护的双端队列中。<h4 id="2-4-1-pushHead"><a href="#2-4-1-pushHead" class="headerlink" title="2.4.1 pushHead"></a>2.4.1 pushHead</h4></li></ol><p>p.pin() 和之前是一样的，就不分析了，主要看一下 pushHead()<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> pushHead(val <span class="keyword">interface</span>&#123;&#125;) &#123;  </span><br><span class="line">d := c.head  </span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="comment">// 第一次写入，队列为空则进行初始化 默认长度为8  </span></span><br><span class="line"><span class="keyword">const</span> initSize = <span class="number">8</span> <span class="comment">// Must be a power of 2  </span></span><br><span class="line">d = <span class="built_in">new</span>(poolChainElt)  </span><br><span class="line">d.vals = <span class="built_in">make</span>([]eface, initSize)  </span><br><span class="line">c.head = d  </span><br><span class="line">storePoolChainElt(&amp;c.tail, d)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 存储元素 存储成功直接返回  </span></span><br><span class="line"><span class="keyword">if</span> d.pushHead(val) &#123;  </span><br><span class="line"><span class="keyword">return</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// The current dequeue is full. Allocate a new one of twice  </span></span><br><span class="line"><span class="comment">// the size.  </span></span><br><span class="line">    <span class="comment">// 存储失败说明队列满了 进行扩容  </span></span><br><span class="line">newSize := <span class="built_in">len</span>(d.vals) * <span class="number">2</span>  </span><br><span class="line"><span class="keyword">if</span> newSize &gt;= dequeueLimit &#123; <span class="comment">// 限制一下，不能无限扩容  </span></span><br><span class="line">newSize = dequeueLimit  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 扩容逻辑也比较简单，就是首尾相连，构成链表  </span></span><br><span class="line">d2 := &amp;poolChainElt&#123;prev: d&#125;  </span><br><span class="line">d2.vals = <span class="built_in">make</span>([]eface, newSize)  </span><br><span class="line">c.head = d2  </span><br><span class="line">storePoolChainElt(&amp;d.next, d2)  </span><br><span class="line">d2.pushHead(val)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果 <code>c.head</code> 为空，就要创建一个 poolChainElt，作为首结点，当然也是尾节点。它管理的双端队列的长度，初始为 8，放满之后，再创建一个 poolChainElt 节点时，双端队列的长度就要翻倍。当然，有一个最大长度限制（2^30）：</p><p>const dequeueBits = 32  </p><p>const dequeueLimit = (1 &lt;&lt; dequeueBits) / 4</p><p>调用 <code>poolDequeue.pushHead</code> 尝试将对象放到 poolDeque 里去：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> pushHead(val <span class="keyword">interface</span>&#123;&#125;) <span class="type">bool</span> &#123;  </span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">head, tail := d.unpack(ptrs)  </span><br><span class="line">    <span class="comment">// 首先判断队列是否已满： 也就是将尾部指针加上 d.vals 的长度，再取低 31 位，看它是否和 head 相等  </span></span><br><span class="line"><span class="keyword">if</span> (tail+<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)))&amp;(<span class="number">1</span>&lt;&lt;dequeueBits<span class="number">-1</span>) == head &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">slot := &amp;d.vals[head&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Check if the head slot has been released by popTail.  </span></span><br><span class="line">typ := atomic.LoadPointer(&amp;slot.typ)  </span><br><span class="line"><span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="comment">// Another goroutine is still cleaning up the tail, so  </span></span><br><span class="line"><span class="comment">// the queue is actually still full.  </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// slot占位，将val存入vals中  </span></span><br><span class="line"><span class="keyword">if</span> val == <span class="literal">nil</span> &#123;  </span><br><span class="line">val = dequeueNil(<span class="literal">nil</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">*(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot)) = val  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// head 增加 1  </span></span><br><span class="line">atomic.AddUint64(&amp;d.headTail, <span class="number">1</span>&lt;&lt;dequeueBits)  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先判断队列是否已满：</p><pre><code>if (tail+uint32(len(d.vals)))&amp;(1&lt;&lt;dequeueBits-1) == head &#123;      return false  &#125;</code></pre><p>队列没满，通过 head 指针找到即将填充的 slot 位置：取 head 指针的低 31 位。</p><pre><code>slot := &amp;d.vals[head&amp;uint32(len(d.vals)-1)]  // Check if the head slot has been released by popTail.  typ := atomic.LoadPointer(&amp;slot.typ)  if typ != nil &#123;      // Another goroutine is still cleaning up the tail, so      // the queue is actually still full.      return false  &#125;</code></pre><p>这里还判断了当前 slot 是否正在被 popTail 释放，popTail 相关语句如下：</p><pre><code>// 最后也是将这个 slot 置空  // 先清空 val 再清空 typ 操作顺序和 pushHead 正好相反  slot.val = nil  atomic.StorePointer(&amp;slot.typ, nil)</code></pre><p>所以如果 slot.typ==nil 就说明这个 slot 正在被 popTail 释放，说明队列其实还是满的，直接返回 false，走后续的扩容逻辑。</p><p>最后，将 val 赋值到 slot，并将 head 指针值加 1。</p><p>// slot占位，将val存入vals中<br><em>(</em>interface{})(unsafe.Pointer(slot)) = val</p><blockquote><p>这里的实现比较巧妙，slot 是 eface 类型，即空接口，将 slot 转为 interface{} 类型，这样 val 能以 interface{} 赋值给 slot 让 slot.typ 和 slot.val 指向其内存块，于是 slot.typ 和 slot.val 均不为空。</p></blockquote><h4 id="2-4-2-pack-unpack"><a href="#2-4-2-pack-unpack" class="headerlink" title="2.4.2 pack/unpack"></a>2.4.2 pack/unpack</h4><p>最后我们再来看一下 pack 和 unpack 函数，它们实际上是一组绑定、解绑 head 和 tail 指针的两个函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> pack(head, tail <span class="type">uint32</span>) <span class="type">uint64</span> &#123;  </span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span>  </span><br><span class="line"><span class="keyword">return</span> (<span class="type">uint64</span>(head) &lt;&lt; dequeueBits) |  </span><br><span class="line"><span class="type">uint64</span>(tail&amp;mask)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`mask`</span> 的低 <span class="number">31</span> 位为全 <span class="number">1</span>，其他位为 <span class="number">0</span>，它和 tail 相与，就是只看 tail 的低 <span class="number">31</span> 位。而 head 向左移 <span class="number">32</span> 位之后，低 <span class="number">32</span> 位为全 <span class="number">0</span>。最后把两部分“或”起来，head 和 tail 就“绑定”在一起了。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> unpack(ptrs <span class="type">uint64</span>) (head, tail <span class="type">uint32</span>) &#123;  </span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span>  </span><br><span class="line">head = <span class="type">uint32</span>((ptrs &gt;&gt; dequeueBits) &amp; mask)  </span><br><span class="line">tail = <span class="type">uint32</span>(ptrs &amp; mask)  </span><br><span class="line"><span class="keyword">return</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>unpack 则是相反的逻辑，取出 head 指针的方法就是将 ptrs 右移 32 位，再与 mask 相与，同样只看 head 的低 31 位。而 tail 实际上更简单，直接将 ptrs 与 mask 相与就可以了。</p><h4 id="2-4-3-小结"><a href="#2-4-3-小结" class="headerlink" title="2.4.3 小结"></a>2.4.3 小结</h4><p>Put 和 Get 类似，首先尝试将放到当前 p 的 local.private 上，已经有了就放到 local.shared。</p><h3 id="2-5-GC"><a href="#2-5-GC" class="headerlink" title="2.5 GC"></a>2.5 GC</h3><p>对于 Pool 而言，并不能无限扩展，否则对象占用内存太多了，会引起内存溢出。<br>sync.pool 选择了在 GC 时进行清理。<br>在 pool.go 文件的 init 函数里，注册了 GC 发生时，如何清理 Pool 的函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/pool.go  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;  </span><br><span class="line">runtime_registerPoolCleanup(poolCleanup)  </span><br><span class="line">&#125;</span><br><span class="line">编译器在编译时将其注册到运行时：</span><br><span class="line"><span class="comment">// src/runtime/mgc.go  </span></span><br><span class="line"><span class="comment">// Hooks for other packages  </span></span><br><span class="line"><span class="keyword">var</span> poolcleanup <span class="function"><span class="keyword">func</span><span class="params">()</span></span>  </span><br><span class="line"><span class="comment">// 利用编译器标志将 sync 包中的清理注册到运行时  </span></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_registerPoolCleanup sync.runtime_registerPoolCleanup  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_registerPoolCleanup</span><span class="params">(f <span class="keyword">func</span>()</span></span>) &#123;  </span><br><span class="line">  poolcleanup = f  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">具体的 poolCleanup() 函数如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolCleanup</span><span class="params">()</span></span> &#123;  </span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> oldPools &#123;  </span><br><span class="line">p.victim = <span class="literal">nil</span>  </span><br><span class="line">p.victimSize = <span class="number">0</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> allPools &#123;  </span><br><span class="line">p.victim = p.local  </span><br><span class="line">p.victimSize = p.localSize  </span><br><span class="line">p.local = <span class="literal">nil</span>  </span><br><span class="line">p.localSize = <span class="number">0</span>  </span><br><span class="line">&#125;  </span><br><span class="line">oldPools, allPools = allPools, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整体看起来，比较简洁。主要是将 local 和 victim 作交换，这样也就不致于让 GC 把所有的 Pool 都清空了，有 victim 在“兜底”。</p><ol><li>初始状态下，oldPools 和 allPools 均为 nil。</li><li>第 1 次调用 Get，由于 p.local 为 nil，将会在 pinSlow 中创建 p.local，然后将 p 放入 allPools，此时 allPools 长度为 1，oldPools 为 nil。</li><li>对象使用完毕，第 1 次调用 Put 放回对象。</li><li>第 1 次GC STW 阶段，allPools 中所有 p.local 将值赋值给 victim 并置为 nil。allPools 赋值给 oldPools，最后 allPools 为 nil，oldPools 长度为 1。</li><li>第 2 次调用 Get，由于 p.local 为 nil，此时会从 p.victim 里面尝试取对象。</li><li>对象使用完毕，第 2 次调用 Put 放回对象，但由于 p.local 为 nil，重新创建 p.local，并将对象放回，此时 allPools 长度为 1，oldPools 长度为 1。</li><li>第 2 次 GC STW 阶段，oldPools 中所有 p.victim 置 nil，前一次的 cache 在本次 GC 时被回收，allPools 所有 p.local 将值赋值给 victim 并置为nil，最后 allPools 为 nil，oldPools 长度为 1。<br>简单来说就是清理时，先清理 oldPools 的 local.victim,然后把 allPools 中的 local 赋值给 victim，最后再把 allPools 赋值给 oldPools，把 allPools 置空。<blockquote><p>GC 时只会清理 oldPools，allPools 只会先把数据转移到 victim，然后把 allPools 变成 oldPools，如果从 oldPools 中读取出来的数据进行 Put 也会直接放到 allPools 中，相当于要两次 GC 都没有被访问到并且Put回来才会被移除。</p></blockquote></li></ol><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><ul><li>关键思想是对象的复用，避免重复创建、销毁。将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力。</li><li><code>sync.Pool</code> 是协程安全的，使用起来非常方便。设置好 New 函数后，调用 Get 获取，调用 Put 归还对象。</li><li>不要对 Get 得到的对象有任何假设，更好的做法是归还对象时，将对象“清空”。</li><li>Pool 里对象的生命周期受 GC 影响，不适合于做连接池，因为连接池需要自己管理对象的生命周期。</li></ul><p>一些设计思想或者相关知识点：</p><ul><li><p>lock free：无锁编程是很多编程语言里逃离不了的话题。<code>sync.Pool</code>的无锁是在<code>poolDequeue</code>和<code>poolChain</code>层面实现的。</p></li><li><p>原子操作代替锁：<code>poolDequeue</code>对一些关键变量采用了CAS操作，比如<code>poolDequeue.headTail</code>，既可完整保证并发又能降低相比锁而言的开销。</p></li><li><p>cacheline false sharing 问题</p></li><li><p>noCopy 禁止复制</p></li><li><p>分段锁，降低锁粒度</p></li><li><p>victim cache</p></li><li><p>常见优化手段：复用</p></li></ul><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><code>https://golang.org/src/sync/pool.go</code></p><p><code>https://en.wikipedia.org/wiki/False_sharing</code></p><p><code>https://en.wikipedia.org/wiki/Victim_cache</code></p><p><code>https://zhuanlan.zhihu.com/p/110140126</code></p><p><code>https://medium.com/swlh/go-the-idea-behind-sync-pool-32da5089df72</code></p><p><code>https://zhuanlan.zhihu.com/p/133638023</code></p><p><code>https://www.jianshu.com/p/dc4b5562aad2</code></p><p><code>https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/</code></p><p>[Github]  <a href="https://github.com/lixd/i-go/blob/master/a-tutorials/lib/sync_pool/main.go">https://github.com/lixd/i-go/blob/master/a-tutorials/lib/sync_pool/main.go</a> </p><p>[pool-structure]  <a href="https://github.com/lixd/blog/raw/master/images/golang/lib/sync-pool/pool-structure.png">https://github.com/lixd/blog/raw/master/images/golang/lib/sync-pool/pool-structure.png</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;sync.Pool 可以作为保存临时取还对象的一个“池子”，可以缓存暂时不用的对象，下次需要时直接使用（无需重新分配）。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
    <category term="Go并发编程" scheme="https://stardustorz.github.io/tags/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Go] sync.WaitGroup</title>
    <link href="https://stardustorz.github.io/2025/06/20/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.WaitGroup/"/>
    <id>https://stardustorz.github.io/2025/06/20/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.WaitGroup/</id>
    <published>2025-06-20T03:02:24.000Z</published>
    <updated>2025-07-27T15:41:21.899Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>sync.WaitGroup 可以作为保存临时取还对象的一个“池子”，可以缓存暂时不用的对象，下次需要时直接使用（无需重新分配）。</p></blockquote><span id="more"></span><blockquote><p>Golang 调度方式：<code>主动让渡</code>和<code>被动调度</code><br>   被动调度: <code>通道 channel</code> 、<code>单机锁 sync.Mutex</code>、<code>并发等待组 sync.WaitGroup</code><br>当 goroutine 之间需要建立明确的<code>层级关系</code>. 倘若父 goroutine 希望持有子 goroutine 的生杀大权，并且保证父 goroutine 消亡时能连带回收其创建的所有子 goroutine ，此时可以使用到 Golang 上下文工具 context，完成父 goroutine 对 子 goroutine 的<code>生命周期控制</code></p><p>多个协程等待一个协程执行完，除了WaitGroup 还有什么方式？  写入channel，for循环读</p><h2 id="1-How-to-use？"><a href="#1-How-to-use？" class="headerlink" title="1 How to use？"></a>1 How to use？</h2><h3 id="1-1-核心方法"><a href="#1-1-核心方法" class="headerlink" title="1.1 核心方法"></a>1.1 核心方法</h3><p>• <code>WaitGroup.Add(n)</code>：完成一次登记操作，使得 WaitGroup 中并发计数器的数值加上 n. 在使用场景中，WaitGroup.Add(n) 背后的含义是，注册并启动了 n 个子 goroutine<br>• <code>WaitGroup.Done()</code>：完成一次上报操作，使得 WaitGroup 中并发计数器的数值减 1. 在使用场景中，通常会在一个子 goroutine 退出前，会执行一次 WaitGroup.Done 方法<br>• <code>WaitGroup.Wait()</code>：完成聚合操作. 通常由主 goroutine 调用该方法，主 goroutine 会因此陷入阻塞，直到所有子 goroutine 都已经执行完成，使得 WaitGroup 并发计数器数值清零时，主 goroutine 才得以继续往下执行</p></blockquote><h3 id="1-2-案例"><a href="#1-2-案例" class="headerlink" title="1.2 案例"></a>1.2 案例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_waitGroup</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup   <span class="comment">// 声明等待组 wg</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;   <span class="comment">// 循环开启十个子 Goroutine</span></span><br><span class="line">        wg.Add(<span class="number">1</span>)               <span class="comment">// 登记子 Goroutine</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()     <span class="comment">// 保证退出前会调用一次，完成上报</span></span><br><span class="line">            &lt;-time.After(time.Second)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()                   <span class="comment">// 阻塞等待，直到等待组全部完成后才往下走</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：子 goroutine 是异步启动的，所以有可能出现 Wait 方法先于 Add 方法执行，此时由于计数器值为 0，Wait 方法会被直接放行，导致产生预期之外的执行流程；因此要保证 add 在 done 之前。</p></blockquote><h3 id="1-3-WaitGroup-channel-完成数据聚合"><a href="#1-3-WaitGroup-channel-完成数据聚合" class="headerlink" title="1.3 WaitGroup + channel 完成数据聚合"></a>1.3 WaitGroup + channel 完成数据聚合</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_waitGroup</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tasksNum := <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据缓存 channel</span></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    <span class="comment">// 数据结果 slice</span></span><br><span class="line">    resp := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, tasksNum)</span><br><span class="line">    <span class="comment">// 控制管道</span></span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 启动读 goroutine</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> data := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">            resp = <span class="built_in">append</span>(resp, data)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标识数据读取完成</span></span><br><span class="line">        stopCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证获取到所有数据后，通过 channel 传递到读协程手中</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; tasksNum; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            ch &lt;- time.Now().UnixNano()</span><br><span class="line">        &#125;(dataCh)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确保所有取数据的协程都完成了工作，才关闭 ch</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(dataCh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保读协程处理完成</span></span><br><span class="line">    &lt;-stopCh</span><br><span class="line"></span><br><span class="line">    t.Logf(<span class="string">&quot;resp: %+v&quot;</span>, resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-源码走读"><a href="#2-源码走读" class="headerlink" title="2 源码走读"></a>2 源码走读</h2><h3 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h3><p>WaitGroup 位于 golang sync 包下，对应的类声明中包含了几个核心字段：</p><ul><li><code>noCopy</code>：这是防拷贝标识，标记了 WaitGroup 不应该用于值传递</li><li><code>state1</code>：这是 WaitGroup 的核心字段，是一个无符号的64位整数，高32位是 WaitGroup 中并发计数器的数值，即当前 WaitGroup.Add 与 WaitGroup.Done 之间的差值；低 32 位标识了，当前有多少 goroutine 因 WaitGroup.Wait 操作而处于阻塞态，陷入阻塞态的原因是因为计数器的值没有清零，即 state1 字段高 32 位是一个正值</li><li><code>state2</code>：用于阻塞和唤醒 goroutine 的信号量</li></ul><p><code>WaitGroup.Add</code> 方法会给 WaitGroup 的计数器累加上一定的值，背后的含义是标识出当前有多少 goroutine 正在运行，需要由 WaitGroup.Done 操作完成数值的抵扣：</p><ul><li>首先通过 WaitGroup.state 方法，获取到 WaitGroup 的 state1 和 state2 字段，分别将字段对应的地址赋给临时变量 statep 和 semap</li><li>调用 atomic.AddUint64，直接通过指针的方式直接在 WaitGroup.state1 的高 32 位基础上累加上 delta 的值</li><li>获取到 state1 高 32 位的值，赋值给局部变量 v，其含义是并发计数器的数值，即 WaitGroup.Add 和 WaitGroup.Done 之间的差值</li><li>获取到 state1 低 32 位的值，赋值给局部变量 w. 其含义是因执行 WaitGroup.Wait 操作而陷入阻塞态的 goroutine 数量</li><li>倘若 WaitGroup 计数器出现负值，直接 panic（ Done 不应该多于 Add ）</li><li>倘若首次 Add 操作是在有 goroutine 因 Wait 操作而陷入阻塞时才执行，抛出 panic（if w != 0 &amp;&amp; delta &gt; 0 &amp;&amp; v == int32(delta) ）</li><li>倘若执行完 Add 操作后，WaitGroup 的计数器还是正值，则直接返回</li><li>倘若发现本次 Add 操作后， WaitGroup 计数器被清零了，则接下来需要依次把因 Wait 操作而陷入阻塞的 goroutine 唤醒. 在这期间，不允许再并发执行 Add 操作，否则会 panic</li><li>唤醒 goroutine 使用的方法是 runtime_Semrelease 方法，底层会执行 goready 操作，属于 goroutine 的被动调度模式</li></ul><p>执行 WaitGroup.Wait 方法，会判断 WaitGroup 中的并发计数器数值是否为 0，如果不等于0，则当前 goroutine 会陷入阻塞态，直到计数器数值清零之后，才会被唤醒. 具体的执行流程如下：</p><ul><li>执行 WaitGroup.state 方法，获取到 state1 和 state2 字段</li><li>走进 for 循环开启自旋流程</li><li>将 state1 高 32 位所存储的计数器数值赋给局部变量 v</li><li>将 state1 低 32 位所存储的阻塞 goroutine 数量赋给局部变量 w</li><li>倘若计数器数值 v 已经是 0 了，则无需阻塞 goroutine，直接返回即可</li><li>倘若计数器数值 v 大于 0，代表当前 goroutine 需要被阻塞挂起.</li><li>基于 cas，将 state1 低 32 位的数值加 1，标识有一个额外的 goroutine 需要阻塞挂起了</li><li>调用 runtime_Semacquire 方法，内部会通过 go park 操作，将当前 goroutine 阻塞挂起，属于被动调度模式</li><li>当 goroutine 从 runtime_Semacquire 方法走出来时，说明 WaitGroup 计数器已经被清零了.</li><li>在被唤醒的 goroutine 返回前，WaitGroup 不能被并发执行 Add 操作，否则会陷入 panic</li><li>被唤醒的 goroutine 正常返回，Wait 流程结束</li></ul><p>以下是针对 [[sync.WaitGroup]] 文章的完善建议，采用技术文档的严谨风格，补充核心机制和注意事项：</p><hr><h3 id="2-2-核心机制"><a href="#2-2-核心机制" class="headerlink" title="2.2 核心机制"></a>2.2 核心机制</h3><h4 id="2-2-1-计数器与信号量"><a href="#2-2-1-计数器与信号量" class="headerlink" title="2.2.1 计数器与信号量"></a>2.2.1 计数器与信号量</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WaitGroup <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy  noCopy       <span class="comment">// 通过go vet检测值拷贝</span></span><br><span class="line">    state1  [<span class="number">3</span>]<span class="type">uint32</span>    <span class="comment">// [counter, waiterCount, sema]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>计数器（高32位）</strong>：记录活跃的goroutine数量，<code>Add(n)</code>增加计数，<code>Done()</code>减少计数</li><li><strong>等待计数（中32位）</strong>：记录阻塞在<code>Wait()</code>的goroutine数量</li><li><strong>信号量（低32位）</strong>：用于阻塞/唤醒goroutine的原子信号量</li></ul><h4 id="2-2-2-内存对齐优化"><a href="#2-2-2-内存对齐优化" class="headerlink" title="2.2.2 内存对齐优化"></a>2.2.2 内存对齐优化</h4><p><code>state1</code>字段采用12字节数组而非结构体，通过动态计算偏移量实现：</p><ul><li>64位系统：8字节对齐，前8字节为counter+waiter，后4字节为sema</li><li>32位系统：4字节对齐，分三次读取</li></ul><h3 id="2-3-关键流程"><a href="#2-3-关键流程" class="headerlink" title="2.3 关键流程"></a>2.3 关键流程</h3><h4 id="2-3-1-Add-Done-操作"><a href="#2-3-1-Add-Done-操作" class="headerlink" title="2.3.1 Add/Done 操作"></a>2.3.1 Add/Done 操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    A[Add(n)] --&gt; B&#123;原子更新counter&#125;</span><br><span class="line">    B --&gt;|n&gt;0| C[检查counter&gt;=0]</span><br><span class="line">    B --&gt;|n&lt;0| D[检查counter+n&gt;=0]</span><br><span class="line">    C --&gt;|counter=0| E[唤醒所有waiter]</span><br><span class="line">    D --&gt;|counter=0| E</span><br></pre></td></tr></table></figure><h4 id="2-3-2-Wait-操作"><a href="#2-3-2-Wait-操作" class="headerlink" title="2.3.2 Wait 操作"></a>2.3.2 Wait 操作</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wg *WaitGroup)</span></span> Wait() &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        state := atomic.LoadUint64(&amp;wg.state)</span><br><span class="line">        v := <span class="type">int32</span>(state &gt;&gt; <span class="number">32</span>)  <span class="comment">// counter</span></span><br><span class="line">        <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;wg.state, state, state+<span class="number">1</span>) &#123;</span><br><span class="line">            runtime_Semacquire(&amp;wg.sema)</span><br><span class="line">            <span class="keyword">if</span> atomic.LoadUint64(&amp;wg.state) != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="built_in">panic</span>(<span class="string">&quot;sync: WaitGroup is reused before previous Wait has returned&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-注意事项"><a href="#2-4-注意事项" class="headerlink" title="2.4 注意事项"></a>2.4 注意事项</h3><h4 id="2-4-1-典型错误模式"><a href="#2-4-1-典型错误模式" class="headerlink" title="2.4.1 典型错误模式"></a>2.4.1 典型错误模式</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误1：Add在goroutine外未生效</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line">    <span class="comment">// 实际可能先执行Wait()</span></span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误2：未捕获Done导致的panic</span></span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mayPanic()  <span class="comment">// 若panic则Wait死锁</span></span><br><span class="line">    wg.Done()</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><h4 id="2-4-2-最佳实践"><a href="#2-4-2-最佳实践" class="headerlink" title="2.4.2 最佳实践"></a>2.4.2 最佳实践</h4><ol><li><strong>前置Add原则</strong>：确保<code>Add()</code>在启动goroutine前完成</li><li><strong>Done防御性编程</strong>：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := <span class="built_in">recover</span>(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        wg.Done() <span class="comment">// 确保异常时仍释放计数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure></li><li><strong>禁止重用</strong>：Wait未结束前禁止再次使用（会触发panic）</li></ol><h3 id="2-5-性能对比"><a href="#2-5-性能对比" class="headerlink" title="2.5 性能对比"></a>2.5 性能对比</h3><div class="table-container"><table><thead><tr><th>场景</th><th>WaitGroup</th><th>Channel</th><th>Mutex</th></tr></thead><tbody><tr><td>简单同步</td><td>0.3ns/op</td><td>50ns/op</td><td>10ns/op</td></tr><tr><td>高并发(1k goroutine)</td><td>1μs</td><td>500μs</td><td>200μs</td></tr><tr><td>内存占用</td><td>12字节</td><td>96字节</td><td>8字节</td></tr></tbody></table></div><h3 id="2-6-扩展应用"><a href="#2-6-扩展应用" class="headerlink" title="2.6 扩展应用"></a>2.6 扩展应用</h3><h4 id="2-6-1-动态任务组"><a href="#2-6-1-动态任务组" class="headerlink" title="2.6.1 动态任务组"></a>2.6.1 动态任务组</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">DynamicTask</span><span class="params">(wg *sync.WaitGroup, ch <span class="keyword">chan</span> Task)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> task := <span class="keyword">range</span> ch &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)  <span class="comment">// 动态增加计数</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(t Task)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            process(t)</span><br><span class="line">        &#125;(task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-2-超时控制"><a href="#2-6-2-超时控制" class="headerlink" title="2.6.2 超时控制"></a>2.6.2 超时控制</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(done)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-done:</span><br><span class="line">    <span class="comment">// 正常完成</span></span><br><span class="line"><span class="keyword">case</span> &lt;-time.After(<span class="number">5</span>*time.Second):</span><br><span class="line">    <span class="comment">// 超时处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>完善后的文档新增了：</p><ol><li>底层数据结构的内存布局说明</li><li>关键操作的流程图和伪代码</li><li>错误模式与最佳实践对比</li><li>性能数据量化对比</li><li>高级用法示例<br>建议将原有”案例”部分合并到”扩展应用”章节，保持</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;sync.WaitGroup 可以作为保存临时取还对象的一个“池子”，可以缓存暂时不用的对象，下次需要时直接使用（无需重新分配）。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
    <category term="Go并发编程" scheme="https://stardustorz.github.io/tags/Go%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>[Go] Defer</title>
    <link href="https://stardustorz.github.io/2025/06/03/Golang/0%20%E5%9F%BA%E7%A1%80/%E5%85%B3%E9%94%AE%E5%AD%97/Defer/"/>
    <id>https://stardustorz.github.io/2025/06/03/Golang/0%20%E5%9F%BA%E7%A1%80/%E5%85%B3%E9%94%AE%E5%AD%97/Defer/</id>
    <published>2025-06-03T07:54:24.000Z</published>
    <updated>2025-07-27T15:29:33.814Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Defer 和栈比较相似，<strong>先进后出</strong>，即先注册的 defer 会后执行。</p></blockquote><span id="more"></span><h2 id="1-1-12"><a href="#1-1-12" class="headerlink" title="1 1.12"></a>1 1.12</h2><blockquote><p>本节将的是 Go 1.12 版本的 defer。1.13 和1.14 都有不少优化。</p></blockquote><h3 id="1-1-demo"><a href="#1-1-demo" class="headerlink" title="1.1 demo"></a>1.1 demo</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> B()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// dosomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，编译后伪指令如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r = deferproc(<span class="number">8</span>,B)</span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">goto</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"> ret:</span><br><span class="line">     runtime.deferreturn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>deferproc</code>负责把要执行的函数信息保存起来，也叫 <strong>defer 注册</strong>。</p><p>deferproc()函数会返回0，if 分支和 panic，recover有关，暂时忽略。</p><p>首先调用 deferproc() 进行 defer 注册，然后继续执行后面的逻辑， 直到返回之前通过<code>deferreturn</code>执行注册的 defer 函数。</p><blockquote><p>先注册后调用，所以实现了延迟执行的效果。</p></blockquote><p>defer 信息会注册到一个<strong>链表</strong>，而当前执行的 goroutine 会持有这个链表的头指针。，每个goroutine都要一个结构体g，其中有字段 _defer 就指向defer链表头。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go  395行</span></span><br><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">_defer       *_defer <span class="comment">// innermost defer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>defer 链表中存储的是一个一个的 defer 结构体。<strong>每次注册 defer 时会将当前 defer 链接到链表头，同时 Defer 执行时也是从链表头开始执行</strong>。</p><blockquote><p>所以才会有先进后出的感觉。</p></blockquote><p>defer 结构体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">siz     <span class="type">int32</span> <span class="comment">// 参数和返回值共占多少字节</span></span><br><span class="line">started <span class="type">bool</span> <span class="comment">// 标记defer是否已经执行</span></span><br><span class="line">sp        <span class="type">uintptr</span>  <span class="comment">// 调用者栈指针，通过这个调用者可以判断自己注册的defer是否都执行完了</span></span><br><span class="line">pc        <span class="type">uintptr</span>  <span class="comment">// deferproc 的返回地址</span></span><br><span class="line">fn        *funcval <span class="comment">// 要注册的 funcval</span></span><br><span class="line">_panic    *_panic  <span class="comment">// panic that is running defer</span></span><br><span class="line">link      *_defer <span class="comment">// 链接到前一个注册的 _defer 结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-参数与闭包"><a href="#1-2-参数与闭包" class="headerlink" title="1.2 参数与闭包"></a>1.2 参数与闭包</h3><p>需要关注的是 defer 传参和闭包变量捕获机制。</p><p><strong>普通参数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(a) <span class="comment">// 1</span></span><br><span class="line">&#125;(a)</span><br><span class="line">a = a + b</span><br><span class="line">fmt.Println(a, b) <span class="comment">// 3,2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 defer function 只使用到了一个 int 类型的参数。</p><p>所以会直接将参数a的<strong>值</strong>拷贝到 defer function 对应的栈空间中。</p><p>等函数执行完成，返回之前就会执行这个 defer function，将 a 的值打印出来。</p><p>由于是拷贝的<strong>值</strong>，所以后续a=a+b 修改变量a的值和和这个  defer function 中的参数 a 已经完全没有关系了，最终打印出a的值还是传入时的1。</p><p><strong>引入普通参数的 defer function 参数值在执行 defer 时就确定了。</strong></p><p><strong>闭包变量</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">a = a + b</span><br><span class="line">fmt.Println(a, b) <span class="comment">// 5 2</span></span><br><span class="line">&#125;(b)</span><br><span class="line">a = a + b</span><br><span class="line">fmt.Println(a, b) <span class="comment">// 3 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中 defer function 除了参数 b 之外还引用到了 外层局部变量 a。</p><p>这里就形成了<strong>闭包</strong>。</p><blockquote><p>闭包也是一个 function value。</p></blockquote><p>同时由于捕获变量a除了初始化赋值之外，还被修改过，所以局部变量a改为<strong>堆分配</strong>，栈上只存储a的地址。</p><p>所以后续a的修改也会影响到defer function，导致最终打印出a的值为5</p><p><strong>引入闭包变量的 defer function 参数值需要到 defer function 执行时才能确定。</strong></p><h3 id="1-3-缺点"><a href="#1-3-缺点" class="headerlink" title="1.3 缺点"></a>1.3 缺点</h3><ul><li>1）defer 在堆上分配</li><li>2）使用链表注册 defer 信息</li></ul><p>以上两点导致了 defer 很慢。</p><p>go 1.13 1.14 版本分别对上述问题进行了不同的优化。</p><h2 id="2-优化"><a href="#2-优化" class="headerlink" title="2 优化"></a>2 优化</h2><h3 id="2-1-1-13"><a href="#2-1-1-13" class="headerlink" title="2.1 1.13"></a>2.1 1.13</h3><p>Go 1.12 中通过 runtime.deferproc() 函数注册 defer，将 _defer结构体分配在<strong>堆</strong>上。</p><p>Go 1.13 中通过编译器优化，生成局部变量，将 defer 信息分配在<strong>栈</strong>上。然后通过 runtime.deferprocStack() 将 _defer 结构体注册到链表中。</p><p>1.13 主要优化点在于减少 defer 信息的堆分配。由于循环中的 defer 调用无法进行编译器优化，因此只能使用 1.12 版本中的处理方法。所以 defer 结构体中增加了一个字段，用于标识是否为堆分配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 、src/runtime/runtime2.go 861 行</span></span><br><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">heap    <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.13 版本 defer 官方提供的数据是性能提升 30%。</p><h3 id="2-2-1-14"><a href="#2-2-1-14" class="headerlink" title="2.2 1.14"></a>2.2 1.14</h3><p>对于能够显式优化的部分，进行了优化。</p><p>比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> A1(i, <span class="number">2</span>*i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> A2(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">(m, n <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(m, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>A1 优化</strong></p><p>函数A中的第一个 defer，<code>defer A1(i, 2*i)</code>编译器会对其进行优化，直接在函数A return 之前，调用A1函数，直接省去了构造 defer 链表项和注册到 链表的过程。</p><p>编译后代码可以看做如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a,b <span class="type">int</span>=i,<span class="number">2</span>*i</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    A1(a,b)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明了调用A1需要的两个变量，a,b，然后在 return 之前调用了 A1函数。</p><p>降低消耗的同时，也实现了延迟执行的效果。</p><p><strong>A2优化</strong></p><p>第二个 defer <code>defer A2(&quot;hello&quot;, &quot;world&quot;)</code>就不能这样处理了，应该这个defer 需要到执行阶段才能确定是否需要调用。Go 语言用一个标识变量 df 来解决这个问题。</p><p>df 中的每一位都用来标识一个 defer 是否需要被执行。比如之前的 defer A1 需要执行，所以就把第一位置为1，即<code>df|=1</code>。</p><p>执行前判定对应标识位是否为1，同时执行之前还需要将标识位置0，防止重置执行。</p><p>defer A1 调用如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> df <span class="type">byte</span></span><br><span class="line"><span class="keyword">var</span> a,b <span class="type">int</span>=i,<span class="number">2</span>*i</span><br><span class="line"></span><br><span class="line">    df|=<span class="number">1</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> df&amp;<span class="number">1</span>&gt;<span class="number">0</span>&#123;</span><br><span class="line">        df=df&amp;^<span class="number">1</span></span><br><span class="line">        A1(a,b)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的方法处理 defer A2</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> df <span class="type">byte</span></span><br><span class="line"><span class="keyword">var</span> a,b <span class="type">int</span>=i,<span class="number">2</span>*i</span><br><span class="line"><span class="keyword">var</span> m,n <span class="type">int</span>=<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span></span><br><span class="line">    df|=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i&gt;<span class="number">1</span>&#123;</span><br><span class="line">        df |=<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">if</span> df&amp;<span class="number">2</span>&gt;<span class="number">0</span>&#123;</span><br><span class="line">        df=df&amp;^<span class="number">2</span></span><br><span class="line">        A2(m,n)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> df&amp;<span class="number">1</span>&gt;<span class="number">0</span>&#123;</span><br><span class="line">        df=df&amp;^<span class="number">1</span></span><br><span class="line">        A1(a,b)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Go1.14 defer 优化就是通过编译期置入代码，把defer函数的执行逻辑展开在所属函数内，从而免于创建 _defer 结构体，而且不需要注册到 defer 链表。</strong></p><p>Go 语言称这种方式为 open coded defer。</p><p>但是和 1.13 版本一样，这种方式依然不适用于 循环中的 defer，所以1.14中版本还是保留了 1.12 版本的 defer处理方式。</p><p>1.14 版本 defer 性能提升了一个数量级。</p><p><strong>栈扫描</strong></p><p>性能提升也不是没有代价的，像这样展开后的 defer 如果在执行之前，出现了 panic 或者执行了 runtime.Goexit ，此时就会直接跳去执行 defer 链表，所以后面的defer 展开代码就无法执行了。</p><p>于是 Go1.14 又在 defer 中增加了几个字段，同时通过栈扫描的方式，来执行这些原本无法执行的 defer。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 、src/runtime/runtime2.go 861 行</span></span><br><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">openDefer <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">fd   unsafe.Pointer <span class="comment">// funcdata for the function associated with the frame</span></span><br><span class="line">varp <span class="type">uintptr</span>        <span class="comment">// value of varp for the stack frame</span></span><br><span class="line">framepc <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助这些信息，可以找到未注册到链表的 defer 函数并按照正确的顺序执行。</p><p><strong>这就导致 1.14 版本中 defer 变快的同时，panic 变得更慢了。</strong></p><blockquote><p>官方这样优化肯定是有自己的考量，毕竟 panic 发生的几率比 defer 低。</p></blockquote><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p><strong>defer 注册流程</strong></p><ul><li>1）deferproc 进行 defer 注册。</li><li>2）return之前通过 runtime.deferreturn() 调用注册的 defer 函数。</li></ul><p><strong>具体执行逻辑</strong></p><ul><li>1）从当前 goroutine 的字段 defer 中拿到 defer 链表</li><li>2）从链表中拿到第一个要执行的 defer 结构体</li><li>3）根据 defer 结构体的 fn 字段找到对应的 funcval</li><li>4）根据 funcval 找打对应的函数入口地址</li><li>5）执行具体函数</li></ul><p><strong>优化记录</strong></p><ul><li><p>1.1~1.12：堆分配</p><ul><li>编译期将 defer 关键字转换为 deferproc ，并在调用defer关键字的函数返回之前插入 runtime.deferreturn 。</li><li>运行时 runtime.deferproc 会将一个新的<code>runtime._defer</code>结构体追加到当前 Goroutine 的 defer 链表头。</li><li>运行时调用 runtime.deferreturn 会从当前 goroutine 的 defer 链表中取出 <code>runtime._defer</code>结构并依次执行</li></ul></li><li>1.13：栈分配<ul><li>当该关键字在函数体中最多执行一次时，编译期间会将结构体分配到栈上，并调用 runtime.deferprocStack</li></ul></li><li>1.14：开放编码<ul><li>编译期间判断 <code>defer</code> 关键字、<code>return</code> 语句的个数确定是否开启开放编码优化；</li><li>如果 <code>defer</code> 关键字的执行可以在编译期间确定，会在函数返回前直接插入相应的代码，否则会由运行时的  runtime.deferreturn 处理。</li></ul></li></ul><p><strong>问题</strong></p><p><strong>defer 调用时机与执行顺序</strong></p><p>deferproc 注册时是往链表头注册，而调用时也是从链表头开始调用，所以是先进后出的效果。</p><p><strong>参数问题</strong></p><p>注册时就会拷贝 defer 函数的参数(<strong>参数预计算</strong>)，所以如果是参数是值类型，注册时就确定了，如果是指针类型，则后续的修改也会影响到 defer 函数中的参数。</p><blockquote><p>可以简单理解为 defer 参数在调用defer关键字时确定。但是如果传的是指针那被修改也就说得通了。</p></blockquote><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><code>https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/</code></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Defer 和栈比较相似，&lt;strong&gt;先进后出&lt;/strong&gt;，即先注册的 defer 会后执行。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
    <category term="Go关键字" scheme="https://stardustorz.github.io/tags/Go%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
  </entry>
  
</feed>
