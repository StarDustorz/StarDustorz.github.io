<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Draco&#39;s Blog</title>
  
  <subtitle>拨雪寻春 烧灯续昼</subtitle>
  <link href="https://stardustorz.github.io/atom.xml" rel="self"/>
  
  <link href="https://stardustorz.github.io/"/>
  <updated>2025-04-05T11:04:56.302Z</updated>
  <id>https://stardustorz.github.io/</id>
  
  <author>
    <name>draco</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[DDIA] 批处理</title>
    <link href="https://stardustorz.github.io/2023/08/10/DDIA/09%20%E6%89%B9%E5%A4%84%E7%90%86/"/>
    <id>https://stardustorz.github.io/2023/08/10/DDIA/09%20%E6%89%B9%E5%A4%84%E7%90%86/</id>
    <published>2023-08-09T16:00:00.000Z</published>
    <updated>2025-04-05T11:04:56.302Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>批处理系统通常会接受大量数据作为输入，然后基于这些数据执行任务，进而产生一些数据作为输出。</p></blockquote><span id="more"></span><p>web 服务和日趋增长的基于 HTTP/REST 的 API，让请求/应答风格的交互如此普遍，以至于我们理所当然的认为系统就应该长这样。但须知，这并非构建系统的唯一方式，其他方法也各有其应用场景。我们来对下面三种类型系统进行考察：</p><ul><li><strong>服务（在线系统，online systems）</strong> 服务（service）类型的系统会等待客户端发来的请求或指令。当收到一个请求时，服务会试图尽快的处理它，然后将返回应答。<strong>响应时间</strong>通常是衡量一个服务性能的最主要指标，且<strong>可用性</strong>通常很重要（如果客户端不能够触达服务，则用户可能会收到一条报错消息）。之前章节我们主要在讨论此类系统。</li><li><strong>批处理系统（离线系统，offline systems）</strong> 一个批处理系统通常会接受大量数据作为输入，然后在这批数据上跑<strong>任务</strong>（job），进而产生一些数据作为输出。任务通常会运行一段时间（从数分钟到数天不等），因此一般来说没有用户会死等任务结束。相反，批处理任务通常会周期性的执行（例如，每天一次）。<strong>吞吐量</strong>（throughput，处理单位数据量所耗费的时间）通常是衡量批处理任务最主要指标。本章会主要围绕该类型系统进行讨论。</li><li><strong>流式系统（近实时系统，near-real-time systems）</strong> 流式处理介于在线处理和离线处理（批处理）之间（因此也被称为<strong>近实时</strong>，near-real-time，或者<strong>准在线处理</strong>，nearline processing）。和批处理系统一样，流式处理系统接受输入，产生一些输出（而不是对请求做出响应，因此更像批处理而非服务）。然而，一个流式任务通常会在事件产生不久后就对其进行处理，与之相对，一个批处理任务通常会<strong>攒够一定尺寸</strong>的输入数据才会进行处理。这种区别让流式处理系统比同样功能的批处理系统具有更低的延迟。由于流式处理基于批处理，因此我们下一章再讨论它。</li></ul><p>批处理是寻求构建<strong>可靠的、可扩展的、可维护</strong>的应用的重要组成部分。</p><h2 id="1-使用Unix工具进行批处理"><a href="#1-使用Unix工具进行批处理" class="headerlink" title="1 使用Unix工具进行批处理"></a>1 使用Unix工具进行批处理</h2><p>有一个 web 服务器，并且当有请求进来时，服务器就会向日志文件中追加一行日志：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">216.58</span><span class="number">.210</span><span class="number">.78</span> - - [<span class="number">27</span>/Feb/<span class="number">2015</span>:<span class="number">17</span>:<span class="number">55</span>:<span class="number">11</span> +<span class="number">0000</span>] <span class="string">&quot;GET /css/typography.css HTTP/1.1&quot;</span> <span class="number">200</span> <span class="number">3377</span> <span class="string">&quot;http://martin.kleppmann.com/&quot;</span> <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.115 Safari/537.36&quot;</span></span><br></pre></td></tr></table></figure></p><p>在 2015 年的 2 月 27 号，UTC 时间 ，服务器从 IP 为 216.58.210.78 的客户端收到了一条请求，请求路径为 <code>/css/typography.css</code>。该用户没有经过认证，因此用户位置显示了一个连字符（-）。响应状态码是 200（即，该请求成功了），响应大小是 3377 字节。web 浏览器是 Chrome 49，由于该资源在 <a href="http://martin.kleppmann.com/">http://martin.kleppmann.com/</a> 网站中被引用，因此浏览器加载了该 CSS 文件。</p><h3 id="1-1-简单的日志分析"><a href="#1-1-简单的日志分析" class="headerlink" title="1.1 简单的日志分析"></a>1.1 简单的日志分析</h3><p>获取<strong>网站上访问频次最高的五个页面</strong>，则可以在 Unix Shell 中输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/nginx/access.log | <span class="comment">#(1)</span></span><br><span class="line">      awk <span class="string">&#x27;&#123;print $7&#125;&#x27;</span> |        <span class="comment">#(2)</span></span><br><span class="line">      <span class="built_in">sort</span>             |        <span class="comment">#(3)</span></span><br><span class="line">      <span class="built_in">uniq</span> -c          |        <span class="comment">#(4)</span></span><br><span class="line">      <span class="built_in">sort</span> -r -n       |        <span class="comment">#(5)</span></span><br><span class="line">      <span class="built_in">head</span> -n 5                 <span class="comment">#(6)</span></span><br></pre></td></tr></table></figure></p><p>每一行作用如下：</p><ol><li>读取给定日志文件</li><li>将每一行按空格分成多个字段，然后取出第七个，即我们关心的 URL 字段。在上面的例子中，即：<code>/css/typography.css</code></li><li>按字符序对所有 url 进行排序。如果某个 url 出现了 n 次，则排序后他们会连着出现 n 次。</li><li><code>uniq</code> 命令会将输入中相邻的重复行过滤掉。<code>-c</code> 选项告诉命令输出一个计数：对于每个 URL，输出其重复的次数。</li><li>第二个 <code>sort</code> 命令会按每行起始数字进行排序（<code>-n</code>），即按请求次数多少进行排序。<code>-r</code> 的意思是按出现次数降序排序，不加该参数默认是升序的。</li><li>最后，<code>head</code> 命令会只输出前 5 行，丢弃其他多余输入。<br>比如，如果你想<strong>在输出中跳过 CSS 文件</strong>，可以将 awk 的参数改成 <code>&#39;$7 !~ /\.css$/ &#123;print $7&#125;&#39;</code> 。如果你想<strong>统计最常访问的 IP 数</strong>而非访问网页，则可以将 awk 的参数变为 <code>&#39;&#123;print $1&#125;&#39;</code>。如此种种。</li></ol><h4 id="1-1-1-排序-vs-内存聚合"><a href="#1-1-1-排序-vs-内存聚合" class="headerlink" title="1.1.1 排序 vs 内存聚合"></a>1.1.1 排序 vs 内存聚合</h4><p>Ruby 脚本在内存中保存了 URL 的<strong>哈希表</strong>，记录每个 URL 到其出现次数的映射。Unix 管道例子中并没有这样一个哈希表。作为替代，它将所有 URL 进行<strong>排序</strong>，从而让所有相同的 URL 聚集到一块，从而对 URL 出现次数进行统计。</p><p>如果工作集足够小，则基于内存的哈希表能够很好地工作<br>但如果，任务的工作集大于可用内存，则排序方式更有优势，因为能够充分利用磁盘空间。</p><h3 id="1-2-Unix-哲学"><a href="#1-2-Unix-哲学" class="headerlink" title="1.2 Unix 哲学"></a>1.2 Unix 哲学</h3><ol><li><strong>每一个程序专注干一件小事</strong>。在想做一个新任务时，新造一个轮子，而非向已有的程序中增加新的“功能”。</li><li><strong>每个程序的输出成为其他程序（即便下一个程序还没有确定）的输入</strong>。不要在输出中混入无关信息（比如在数据中混入日志信息），避免使用严格的列式数据（数据要面向行，以行为最小粒度？）或者二进制数据格式。不要使用<strong>交互式输入</strong>。</li><li><strong>尽快的设计和构建软件</strong>，即便复杂如操作系统，也最好在几周内完成（译注：这里翻译稍微有些歧义，即到底是尽快迭代还是尽早让用户试用，当然他们最终思想差不多，即构造最小可用模型，试用-迭代）。对于丑陋部分，不要犹豫，立即推倒重构。</li><li>（Q：unskilled help是指？这一条没太理解）<strong>相比不成熟的帮助，更倾向于使用工具完成编程任务</strong>，即使可能会进行反复构建相似的工具，并且在用完之后大部分工具就再也不会用到。<br>尽可能自动化、快速原型验证、小步增量迭代、易于实验测试，将大型工程拆解成一组易于管理的模块</li></ol><h4 id="1-2-1-统一的接口"><a href="#1-2-1-统一的接口" class="headerlink" title="1.2.1 统一的接口"></a>1.2.1 统一的接口</h4><p>如果你想让任意程序的输出能接到任意程序的输入上，则意味着<strong>所有</strong>这些程序必须使用同样的<strong>输入输出</strong>接口。<br>在 Unix 中，这种接口是<strong>文件</strong>（a file，更准确的说，是文件描述符，file descriptor）。文件本质上是一种<strong>有序的字节序列</strong>。<br><code>awk</code>，<code>sort</code>，<code>uniq</code> 和 <code>head</code> 都将其输入文件视为由 <code>\n</code>（换行符，ASCII 码是 0x0A）分割的一系列记录。</p><h2 id="2-MapReduce和分布式文件系统"><a href="#2-MapReduce和分布式文件系统" class="headerlink" title="2 MapReduce和分布式文件系统"></a>2 MapReduce和分布式文件系统</h2><p>一个 MapReduce 任务就像一个 Unix 进程：<strong>接受一到多个输入，产生一到多个输出</strong>。<br>和 Unix 工具一样，执行一个 MapReduce 任务<strong>不会修改输入文件</strong>，并且除了产生输出<strong>没有其他的副作用</strong>。输出文件都是<strong>单次写入、顺序追加</strong>而成（即 ，一旦文件写完，就不会再有任何改动）。<br>相比 Unix 工具使用 stdin 和 stdout 作为输入和输出，MapReduce 任务的输入和输出都是<strong>分布式文件系统上的文件</strong>。在 Hadoop 的 MapReduce 实现中，该文件系统被称为 HDFS（Hadoop Distributed File System），是谷歌文件系统（GFS，Google File System）的一个开源实现。</p><p>HDFS 基本设计理念是：<strong>shared-nothing</strong> （机器间不共享任何特殊硬件，纯通过网络来通信）架构。HDFS 和<strong>对象存储</strong>不同点之一是，HDFS 能够将计算<strong>就近的</strong>调度到存储所在的机器上（调度亲和性，本质原因在于计算和存储在同一个集群，有好处也有劣势），但对象存储会将存储和计算分离。</p><p>HDFS 由一组运行在每个主机上的<strong>守护进程</strong>（Daemon Process）组成，对外暴露网络接口，以使其他的节点可以访问存储于本机的数据文件（假设数据中心中的通用机器节点上都附有一定数量的磁盘）。一个叫做 <strong>NameNode</strong> 的<strong>中心节点</strong>会保存文件块和其所在机器的映射（也即文件块的 placement 信息）。因此，HDFS 可以利用所有运行有守护进程的机器上（<strong>DataNode</strong>）存储空间，在逻辑上对外提供单一且巨大的文件系统抽象。</p><h3 id="2-1-MapReduce-任务执行"><a href="#2-1-MapReduce-任务执行" class="headerlink" title="2.1 MapReduce 任务执行"></a>2.1 MapReduce 任务执行</h3><ol><li><strong>读取一组输入文件，将其切分为记录（records）</strong>。在网站服务器日志的例子中，每个记录就是日志中的一行（即，使用 \n 作为记录分隔符）</li><li><strong>调用 Mapper 函数从每个记录中抽取 key 和 value</strong>。在之前的例子中，mapper 函数是 <code>awk &#39;&#123;print $7&#125;&#39;</code> ：抽取 URL（$7）作为 key，value 留空。</li><li><strong>将所有的 key-value 对按 key 进行排序</strong>。在前面例子中，该环节由 sort 承担。</li><li><strong>调用 Reducer 函数对排好序的 kv 列表迭代处理</strong>。如果某个 key 出现了多次，排序环节会让其在在列表中集中到一块，因此可以在不在内存中保存过多状态的的情况下，对具有相同 key 的数据进行汇总处理。在前面例子中，reducer 对应命令 <code>uniq -c</code> ，功能是对所有具有相同 key 的记录值进行计数。<br>这四个步骤（split-map-sort-reduce）可以通过一个 MapReduce 任务来实现。你可以在步骤 2 （map）和步骤 4（reduce）编写代码来自定义数据处理逻辑。步骤 1 （将文件拆分成记录）由<strong>输入格式解析器</strong>（input format parser）来完成。步骤 3，排序阶段，由 MapReduce 框架<strong>隐式完成</strong>，所有 Mapper 的输出在给到 Reducer 前，框架都会对其进行排序。</li></ol><p>需要实现两个回调函数：mapper 和 reducer，其行为如下：</p><ul><li><strong>Mapper</strong> 对于每个输入<strong>记录</strong>都会调用一次 Mapper 函数，其任务是从记录中抽取 key 和 value。对于每一个输入记录，都有可能产生任意数量（包括 0 个）的 kv 对。框架不会保存任何<strong>跨记录的状态</strong>，因此每个记录都可以独立的被处理（即 Mapper 可以进行任意并发的运行）。</li><li><strong>Reducer</strong> MapReduce 框架会拿到 Mapper 输出的 kv 对，通过排序将具有相同 key 的 value 聚集到一块，以迭代器的形式给到 Reducer 函数。reducer 会继续输出一组新的记录（如 URL 的出现频次）。</li></ul><h4 id="2-1-1-MapReduce-的分布式执行"><a href="#2-1-1-MapReduce-的分布式执行" class="headerlink" title="2.1.1 MapReduce 的分布式执行"></a>2.1.1 MapReduce 的分布式执行</h4><p>与 Unix 工具流水线的相比，MapReduce 的最大区别在于可以在<strong>多台机器上</strong>进行分布式的执行，但并不需要用户显式地写处理并行的代码。mapper 和 Reducer 函数每次只处理一个记录；他们不必关心输入从哪里来，输出要到哪里去，框架会处理分布式系统所带来的的复杂度</p><p>每个输入文件通常有数百 M，每个输入通常有多个副本，分散在多个机器上。MapReduce 的调度器（图中没有显示）在调度时，会在这多个副本所在机器上选择一个具有足够内存和 CPU 资源运行该 Mapper 任务的机器，将 map 任务调度过去。这个策略也被称为：<strong>将计算调度到数据上</strong>。从而省去在网络中拷贝数据的环节，提高了局部性，减少了网络带宽消耗。</p><p>多数情况下，<strong>应用层的代码</strong>通常不会存在于 map 任务调度到的机器上。因此，MapReduce 框架首先会将用户代码（如对于 Java 来说就是 Jar 包）<strong>序列化后</strong>复制过去。然后在对应机器上，动态加载这些代码，继而执行 map 任务。读取输入文件，逐个解析数据记录（record），传给 Mapper 回调函数执行。每个 Mapper 会产生一组 key-value 对。</p><p>reduce 侧的计算也是分片的。对于 MapReduce 任务来说，<strong>map 任务的数量</strong>，取决于该任务的输入文件数（或者文件 block 数）的数量；<strong>但 reduce 任务的多少</strong>，可以由用户显式的配置（可以不同于 map 任务的数量）。为了保证所有具有相同 key 的 kv 对被同一个 Reducer 函数处理，框架会使用哈希函数，将所有 Mapper 的输出的 kv 对进行分桶（桶的数量就是 Reducer 的数量），进而路由到对应的 Reducer 函数。</p><p>根据 MapReduce 的设定，reducer 接受的 kv 对需要是有序的，但任何传统的排序算法都无法在单机上对如此大尺度的数据进行排序。为了解决这个问题，mapper 和 Reducer 间的<strong>排序被分成多个阶段</strong>。</p><p>首先，每个 map 任务在输出时，会先将所有输出哈希后分片（一个分片对应一个 reducer），然后在每个分片内对输出进行排序。由于每个分片的数据量仍然可能很大，因此使用外排算法。</p><p>当某个 Mapper 任务读取结束，并将输出排好了序，MapReduce 调度器就会通知所有 reducers 来该 Mapper 机器上拉取各自对应的输出。最终，每个 Reducer 会去所有 Mapper 上<strong>拉取</strong>一遍其对应分片数据数据。这里有个推还是拉的设计权衡，拉的好处在于 reducuer 失败后，可以很方便地进行重试，再次拉取计算即可。</p><p>这个<strong>分片</strong>（partitioning by reducer）-<strong>排序</strong>（sorting）-<strong>复制</strong>（coping）过程也被称为<strong>数据重排</strong>（<strong>shuffle</strong>，虽然英文是洗牌的意思，但该过程并没有任何随机性，都是确定的）。</p><p>框架会在 Reducer 处将所有从 Mapper 处拿来的 kv 文件进行归并排序，然后在所有数据拉取完毕后，将排好序数据送给 reducer。这样一来，不同 Mapper 产生的具有相同 key 的记录就会被聚集到一块。</p><p>总结来说，map 和 reduce 间的排序分为<strong>两个阶段</strong>：</p><ol><li>在每个 Mapper 上对<strong>输出</strong>分片后各自排序。</li><li>在每个 Reducer 上对<strong>输入</strong>（有序文件）进行归并排序。<br>Reducer 在调用时会传入一个 key 一个 Iterator（迭代器），使用该迭代器能够访问所有具有相同 key 的记录（极端情况下，内存可能放不下这些记录，因此是给一个迭代器，而非内存数组）。reducer 函数可以使用任意的逻辑对这些记录进行处理，并可以产生任意数量的输出。这些输出最终会被写到分布式文件系统中的文件里（通常该输出文件会在 Reducer 机器上放一个副本，在另外一些机器上放其他副本）。</li></ol><h4 id="2-1-2-MapReduce-工作流"><a href="#2-1-2-MapReduce-工作流" class="headerlink" title="2.1.2 MapReduce 工作流"></a>2.1.2 MapReduce 工作流</h4><p>将多个 MapReduce 首尾相接（前面任务的输出作为后面任务的输入）地串成<strong>工作流</strong>（workflow）极为常见。Hadoop MapReduce 框架本身没有提供任何关于工作流的支持，因此通常依赖文件夹名进行<strong>隐式的链式调用</strong>：</p><ol><li>第一个 MapReduce 任务将其输出写入特定的文件夹。</li><li>第二个 MapReduce 任务读取这些文件夹中文件作为输入。</li></ol><p>仅当一个任务完全成功的执行后，其输出才被认为是有效的（也即，MapReduce 任务会丢掉失败任务的不完整输出）。因此，工作流中的任务只有在前一个任务成功结束后才能启动——即，前驱任务必须<strong>成功地</strong>将输出写入到对应文件夹中。为了处理多个任务间执行的依赖关系（比如 DAG 依赖），人们开发了很多针对 Hadoop的工作流调度框架，如 Oozie，Azkaban，Luigi，Airflow 和 Pinball。</p><h3 id="2-2-Reduce-侧的-Join-和-Group"><a href="#2-2-Reduce-侧的-Join-和-Group" class="headerlink" title="2.2 Reduce 侧的 Join 和 Group"></a>2.2 Reduce 侧的 Join 和 Group</h3><p>在很多数据集中，一个记录和其他记录有<strong>关联</strong>（association）是一个很常见的现象：关系模型中的<strong>外键</strong>（foreign key），文档模型中的<strong>文档引用</strong>（document reference），图模型中的<strong>边</strong>（edge）。在代码需要访问有关联的双方记录（引用记录和被引用记录）时，Join 是必须的</p><p>当一个 MapReduce 任务拿到一组输入文件时，会读取文件中的所有内容；在数据库中，这种操作称为<strong>全表扫描</strong>（full table scan）。如果你进项访问一小部分记录，相比索引查找，全表扫描操作会非常的重。</p><h4 id="2-2-1-基于排序-合并的-Join"><a href="#2-2-1-基于排序-合并的-Join" class="headerlink" title="2.2.1 基于排序-合并的 Join"></a>2.2.1 基于排序-合并的 Join</h4><p> Mapper 的职责：从所有输入记录中提取 key 和 value。</p><p> 当 MapReduce 框架将所有 Mapper 的输出按照 key（也就是用户 ID）进行排序后，所有具有同样的用户 ID 的记录就会聚集到一块，作为输入给到 reducer。MapReduce 任务甚至可以将输出进行特殊组织，以使 Reducer 先看到同一个用户的资料信息，再看到其行为信息——这种技术也被称为<strong>二级排序</strong>（secondary sort，使用多个字段进行排序）。</p><p>在此基础上，reducer 可以进行轻松的进行 join：reducer 函数会在每一个用户 ID 上进行调用，由于使用了二级排序，reducer 会先看到该用户的资料信息。在实现 Reducer 时，可以首先将用户<strong>资料信息</strong>（比如生日）保存在局部变量里，然后对其所有<strong>行为信息</strong>进行迭代，提取相关信息，输出 <viewed-url, viewed age in years> kv 对。之后可以再接一个 MapReduce 任务，对每个 url 访问用户的年龄分布进行统计，并按年龄段进行聚集。</p><p>由于 Reducer 会在单个函数里处理所有同一个 user ID 的记录，因此一次只需要在内存中保存一个用户的资料信息，并且不用进行任何网络请求。这种算法也被称为<strong>基于排序和归并的连接</strong>（sort-merge join），由于 Mapper 的输出是按 key 有序的，则 reducers 可将来自多方的同一个 key 的输入轻松的进行合并。</p><h4 id="2-2-2-将相关数据聚到一块"><a href="#2-2-2-将相关数据聚到一块" class="headerlink" title="2.2.2 将相关数据聚到一块"></a>2.2.2 将相关数据聚到一块</h4><p>在排序-归并 join 中，mappers 和排序会确保同一个用户 id 所有用于 join 必要输入会被放到一起：<strong>即作为一个输入给到某次 Reducer 中</strong>。预先让所有相关数据聚集到一起，可以让 Reducer 逻辑非常简单，并且可以仅使用单个线程，就能进行高吞吐、低耗存地执行。</p><p>我们可以从另外一种角度来理解这种架构：mapper <strong>发消息</strong>给 reducer。当某个 Mapper 发出一个 key-value 对时，<strong>key 是投递地址，value 就是要投递的内容</strong>。尽管 key 在物理上仅是一个任意的字符串（而非像网络中的 IP 和端口号那样真的网络地址），但在逻辑上充当<strong>地址</strong>的作用：所有具有相同 key 的 kv 对都会被投递到同一个目的地（某个 Reducer 的调用处）。</p><p>MapReduce 编程模型，可以将计算的<strong>物理拓扑</strong>（将数据放到合适的机器上）与<strong>应用逻辑</strong>（当有了数据后就进行处理）<strong>解耦</strong>开来。这种解耦与数据库形成对比——在使用数据库的场景中，进行数据库连接（物理）通常藏在应用代码（逻辑）深处。由于 MapReduce 框架会处理所有网络通信细节，它也会让应用层代码免于关心<strong>部分失败</strong>（partial failure），如某些节点宕机：MapReduce 框架会透明的（应用代码无感）的对失败的子任务进行重试，而不会影响应用逻辑。</p><h4 id="2-2-3-Group-By"><a href="#2-2-3-Group-By" class="headerlink" title="2.2.3 Group By"></a>2.2.3 Group By</h4><p>将所有记录按某些 key 进行<strong>分组</strong>（对应 SQL 中的 <code>GROUP BY</code> 子句）。首先将具有相同 key 的所有记录被分到一组，然后对这些分组分别执行某些<strong>聚集</strong>操作（aggregation）</p><p>使用 MapReduce 实现 Group By 语义，最简单的方法是在 Mapper 中<strong>抽取 key 为待分组的 key</strong>。MapReduce 框架就会按照这些 key 将所有 Mapper 的输出记录进行分区和排序，然后按 key 聚集给到 reducer。本质上，使用 MapReduce 来实现 group 和 join ，逻辑是极为相似的。</p><p>分组的另外一个使用场景是：收集某个用户会话中的所有用户活动——也称为<strong>会话化</strong>（sessionization）。例如，可以用来对比用户对于新老版本网站的分别购买意愿（A/B 测试）或者统计某些市场推广活动是否起作用。</p><p>假设你的 web 服务架设在多台服务器上，则某个特定用户的活动日志大概率会分散在不同服务器上。这时，你可以实现一个会话化的 MapReduce 程序，使用会话 cookie、用户 ID或者其他类似的 ID 作为分组 key，以将相<strong>同用户</strong>的所有活动记录聚集到一块、并将<strong>不同用户</strong>分散到多个分区进行处理。</p><h4 id="2-2-4-处理偏斜（skew）"><a href="#2-2-4-处理偏斜（skew）" class="headerlink" title="2.2.4 处理偏斜（skew）"></a>2.2.4 处理偏斜（skew）</h4><p>如果某个 key 的数据量超级大，则“将相同 key 的数据聚集到一块” 的模型将不再适用。例如，在社交网络中，绝大多数的人都只会连接到较少的其他人，但数量较少的名人会有高达数百万的关注者。数据库中这种不成比例的记录常被称为<strong>关键对象</strong>（<em>linchpin objects</em> ）或者<strong>热键</strong>（<em>hot keys</em>）。<br>在单个 Reducer 中收集处理名人（celebrity）所有的活动事件（比如他们发布信息的回复），可能会造成严重的<strong>数据倾斜</strong>（<strong>skew</strong>，有时也被称为热点，hot spots）——即，一个 Reducer 处理的数据量远超其他。由于只有其所属的所有 mappers 和 reducers 执行完时，该 MapReduce 任务才算完成，该 MapReduce 之后的任何任务都需要等待最慢的 Reducer （长尾任务）完成后才能启动。</p><p>如果某个 join 的输入存在热点数据，你可以借助一些算法来进行缓解。例如，Pig 中的偏斜 join（skewed join）方法会事先对所有 key 的分布进行<strong>采样</strong>，以探测是否有热点 key。然后，在执行真正的 Join 时，对于 Join 有热点 key 的这一测，mapper 会将含有热点 key 的记录发送到多个 reducer（每次随机挑选一个，相比之下，常规的 MapReduce 只会根据 key 的哈希确定性的选择一个 reducer）；对于 Join 的另一侧输入，所有包含热点 key 的相关记录需要每个给每个具有该 key 的 Reducer 都发一份。</p><p>该技术将处理热点 key 的工作分摊到多个 Reducer 上，从而可以让其更好的并行，当然代价就是需要将 join 的非热点侧的数据冗余多份。Crunch 中的<strong>分片连接</strong>（shared join）也使用类似的技术，但需要<strong>显式地指定</strong>热点 key，而非通过采样来<strong>自动获取</strong>。</p><p>当对热点 key 进行分组聚集（group）时，可以将分组过程拆成<strong>两个阶段</strong>，即使用两个相接的 MapReduce。第一个 MapReduce 会将记录随机得发给不同的 reducer，则每个 Reducer 会对热点 key 的一个子集执行分组操作，并且产生一个更为紧凑的<strong>聚合值</strong>（aggregated value，如 count，sum，max 等等）。第二个 MapReduce 操作会将第一阶段中 MapReduce 产生的同一个 key 的多个聚合值进行真正的归并。总结来说，就是第一阶段进行<strong>预分组，减小数据量</strong>；第二阶段真正的全局分组，可以想象这种方式，要求聚合操作满足<strong>交换律和结合律</strong>。</p><h3 id="2-3-Map-侧的连接"><a href="#2-3-Map-侧的连接" class="headerlink" title="2.3 Map 侧的连接"></a>2.3 Map 侧的连接</h3><p>上一节讲到的 join 算法是在 reduce 阶段真正执行的 join 逻辑，因此也被称为 <strong>reduce 侧连接</strong>（<em>reduce-side join</em>）。其中，mapper 仅扮演准备数据的角色：从每个输入记录中提取 key 和 value，并且将每个 kv 对发给合适的 Reducer 分区，并将其进行排序。</p><p>reduce 侧的连接的好处在于，你不需要对输入数据有任何的假设：不管输入数据具有怎样的属性和结构，mappers 都可以进行合适的预处理后送给 reducers 进行连接。然而，缺点在于排序、复制到 reducers、将 Reducer 的输入进行合并等过程代价十分高昂。根据可用内存缓存大小不同，数据在流经 MapReduce 中各阶段时可能会被写入多次（写放大）。</p><p>但如果，输入数据满足某种假设，就可以利用所谓的 <strong>map 侧连接</strong>（map-side join）进行更快的连接。这种方式利用了一种简化过的 MapReduce 任务，去掉了 reducer，从而也去掉了对 Mapper 输出的排序阶段。此时，每个 Mapper 只需要从分布式文件系统中的输入文件块中读取记录、处理、并将输出写回到文件系统，即可。</p><h4 id="2-3-1-广播哈希连接"><a href="#2-3-1-广播哈希连接" class="headerlink" title="2.3.1 广播哈希连接"></a>2.3.1 广播哈希连接</h4><p>使用 map 侧连接的一个最常见的场景是一个大数据集和一个小数据集进行连接时。此种情况下，小数据集需要小到能全部装进 Mapper 进程所在机器的内存。<br>但仍然会有多个 Mapper 任务：join 的<strong>大数据量输入侧</strong> 每个文件块一个 mapper。其中 MapReduce 任务中的每个 Mapper 都会将小输入侧的数据全部加载进内存。</p><p>称为<strong>广播哈希连接</strong>（broadcast hash joins）：</p><ol><li><strong>广播（broadcast）</strong>：处理大数据侧每个分片的 Mapper 都会将小数据侧数据全部载入内存。从另外一个角度理解，就是将小数据集<strong>广播到了</strong>所有相关 Mapper 机器上。</li><li><strong>哈希（hash）</strong>：即在将小数据集在内存中组织为哈希表。</li></ol><h4 id="2-3-2-分区哈希连接"><a href="#2-3-2-分区哈希连接" class="headerlink" title="2.3.2 分区哈希连接"></a>2.3.2 分区哈希连接</h4><p>如果待 join 的多个输入，能够以同样的方式进行分区，则每个分区在处理时可以独立地进行 join。</p><p>如果分区方式正确，则所有需要连接的双方都会落到同一个分区内，因此每个 Mapper 只需要读取一个分区就可以获取待连接双方的所有记录。这样做的好处是，每个 Mapper 所需构建哈希表的数据集要小很多。</p><p>在 Hive 中，分区哈希连接也被称为<strong>分桶 map 侧连接</strong>（ bucketed map join）。</p><h4 id="2-3-3-Map-侧合并连接"><a href="#2-3-3-Map-侧合并连接" class="headerlink" title="2.3.3 Map 侧合并连接"></a>2.3.3 Map 侧合并连接</h4><p>当 map 的输入数据集不仅以相同的方式分片过了，而且每个分片是<strong>按该 key 有序的</strong>。在这种情况下，是否有足够小的、能够载入内存的输入已经无关紧要，因为 Mapper 可以以类似普通 Reducer 的方式对输入数据进行<strong>归并</strong>：都以 key 递增（都递减也可以，取决于输入文件中 key 的顺序）的顺序，增量式（迭代式）的读取两个输入文件，对相同的 key 进行匹配连接。</p><h3 id="2-4-批处理工作流的输出"><a href="#2-4-批处理工作流的输出" class="headerlink" title="2.4 批处理工作流的输出"></a>2.4 批处理工作流的输出</h3><p>对于数据库查询场景，我们会区分事务型处理场景（OLTP）和分析性场景（OLAP）</p><p>OLTP 场景下的查询通常只会涉及很小的一个数据子集，因此通常会使用索引加速查询，然后将结果<strong>展示</strong>给用户（例如，使用网页展示）。另一方面，分析型查询通常会扫描大量的数据记录，执行<strong>分组</strong>（grouping）和<strong>聚集</strong>（aggregating）等统计操作，然后以<strong>报表</strong>的形式呈现给用户。</p><p>一组 MapReduce 任务组成的执行流通常和用于分析型的 SQL 查询并不相同（参见 Hadoop 和分布式数据库的对比）。批处理的输出通常不是一个报表，而是<strong>另外某种格式的数据</strong>。</p><h4 id="2-4-1-构建查询索引"><a href="#2-4-1-构建查询索引" class="headerlink" title="2.4.1 构建查询索引"></a>2.4.1 构建查询索引</h4><p>倒排索引是一个<strong>词表</strong>（the term dictionary），利用该词表，你可以针对关键词快速地查出对应<strong>文档列表</strong>（the postings list）。</p><p>在一个<strong>固定文档集合</strong>上构建全文索引，批处理非常合适且高效：</p><ol><li>Mapper 会将文档集合按合适的方式进行分区</li><li>Reducer 会对每个分区构建索引</li><li>最终将索引文件写回分布式文件系统</li></ol><p>由于使用关键词进行索引查询是一种只读操作，因此，这些索引文件一旦构建完成，就是不可变的（immutable）。</p><p>如果被索引的文档集发生变动，一种应对策略是，定期针对所有文档重跑全量索引构建工作流（workflow），并在索引构建完时使用新的索引对旧的进行整体替换。如果两次构建之间，仅有一小部分文档发生了变动，则这种方法代价实在有点高。但也有优点，索引构建过程很好理解：<strong>文档进去，索引出来</strong>。</p><h4 id="2-4-2-以-KV-存储承接批处理输出"><a href="#2-4-2-以-KV-存储承接批处理输出" class="headerlink" title="2.4.2 以 KV 存储承接批处理输出"></a>2.4.2 以 KV 存储承接批处理输出</h4><p>搜索索引只是批处理工作流一种可能的输出。批处理其他的用途还包括构建机器学习系统，如<strong>分类器</strong>（classifiers，如 垃圾邮件过滤，同义词检测，图片识别）和<strong>推荐系统</strong>（recommendation system，如你可能认识的人，可能感兴趣的产品或者相关的检索）。</p><p>在批处理任务内部生成全新的数据库，并将其以文件的形式写入分布式系统的文件夹中。一旦任务成功执行，这些数据文件就会称为<strong>不可变的</strong>（immutable），并且可以<strong>批量加载</strong>（bulk loading）进只处理只读请求的服务中。很多 KV 存储都支持使用 MapReduce 任务构建数据库文件，比如 Voldemort，Terrapin， ElephantDB 和 HBase bulk loading。另外 RocksDB 支持 ingest SST 文件，也是类似的情况。</p><p><strong>直接构建数据库底层文件</strong>，就是一个 MapReduce 应用的绝佳案例：使用 Mapper 抽取 key，然后利用该 key 进行排序，已经<strong>覆盖了</strong>构建索引中的大部分流程。由于大部 KV 存储都是只读的（通过批处理任务一次写入后，即不可变），这些存储的底层数据结构可以设计的非常简单。</p><p>当数据加载进 Voldemort 时，服务器可以利用老文件<strong>继续对外提供服务</strong>，新文件会从分布式文件系统中拷贝的 Voldemort 服务本地。一旦拷贝完成，服务器可以立即将外部查询请求<strong>原子地</strong>切到新文件上。如果导入过程中发生了任何问题，也可以<strong>快速地切回</strong>，使用老文件提供服务。因为老文件是不可变的，且没有立即被删除。</p><h4 id="2-4-3-批处理输出的哲学"><a href="#2-4-3-批处理输出的哲学" class="headerlink" title="2.4.3 批处理输出的哲学"></a>2.4.3 批处理输出的哲学</h4><ul><li><strong>容忍人为错误</strong>。如果你在代码中不小心引入了 bug，使得输出出错，你可以简单地将代码回滚到最近一个正确的版本，然后重新运行任务，则输出就会变正确。或者，更简单地，你可将之前正确的输出保存在其他的文件夹，然后在遇到问题时简单的切回去即可。使用读写事务的数据库是没法具有这种性质的：如果你部署了有 bug 的代码，并且因此往数据库中写入了错误的数据，回滚代码版本也并不能<strong>修复这些损坏的数据</strong>。（从有 bug 的代码中恢复，称为容忍人为错误，human fault tolerance）。这其实是通过牺牲空间换来的，也是经典的增量更新而非原地更新。</li><li><strong>便于敏捷开发</strong>。相比可能会造成不可逆损坏的环境，由于能够很方便地进行回滚，可以大大加快功能迭代的速度（因为不需要进行严密的测试即可上生产）。<strong>最小化不可逆性</strong>（<em>minimizing irreversibility</em>）的原则，有助于敏捷软件开发。</li><li><strong>简单重试就可以容错</strong>。如果某个 map 或者 reduce 任务失败了，MapReduce 框架会自动在相同输入上对其重新调度。如果失败是由代码 bug 引起的，在重试多次后（可以设置某个阈值），会最终引起任务失败；但如果失败是暂时的，该错误就能够被容忍。这种自动重试的机制之所以安全，是因为输入是不可变的，且失败子任务的输出会被自动抛弃。</li><li><strong>数据复用</strong>。同一个文件集能够作为不同任务的输入，包括用于计算指标的监控任务、评估任务的输出是否满足预期性质（如，和之前一个任务的比较并计算差异）。</li><li><strong>逻辑布线分离</strong>。和 Unix 工具一样，MapReduce 也将逻辑和接线分离（通过配置输入、输出文件夹），从而分拆复杂度并且提高代码复用度：一些团队可以专注于实现干好单件事的任务开发；另一些团队可以决定在哪里、在何时来组合跑这些代码。</li></ul><h3 id="2-5-对比-Hadoop-和分布式数据库"><a href="#2-5-对比-Hadoop-和分布式数据库" class="headerlink" title="2.5 对比 Hadoop 和分布式数据库"></a>2.5 对比 Hadoop 和分布式数据库</h3><p>Hadoop 很像一个<strong>分布式形态的 Unix</strong>。其中，HDFS 对标 Unix 中的文件系统，MapReduce 类似于 Unix 进程的一个奇怪实现（在 map 阶段和 reduce 阶段间必须要进行排序）。</p><h4 id="2-5-1-存储类型更为多样"><a href="#2-5-1-存储类型更为多样" class="headerlink" title="2.5.1 存储类型更为多样"></a>2.5.1 存储类型更为多样</h4><p>Hadoop 允许你以<strong>任意格式</strong>的数据灌入 HDFS，将如何处理的灵活性推到之后</p><p>Hadoop 经常用于 <strong>ETL 处理</strong>：将数据以某种原始的格式从事务型的处理系统中引入到分布式文件系统中，然后编写 MapReduce 任务以处理这些数据，将其转换回关系形式</p><h4 id="2-5-2-处理模型更为多样"><a href="#2-5-2-处理模型更为多样" class="headerlink" title="2.5.2 处理模型更为多样"></a>2.5.2 处理模型更为多样</h4><p>基于 Hadoop 实现的各种处理模型可以<strong>共享集群并行运行</strong>，且不同的处理模型都可以访问 HDFS 上的相同文件。在 Hadoop 生态中，无需将数据在不同的特化系统间倒来倒去以进行不同类型的处理：<strong>Hadoop 系统足够开放，能够以单一集群支持多种负载类型</strong>。<strong>无需移动数据</strong>让我们更容易的从数据中挖掘价值，也更容易开发新的处理模型。</p><h4 id="2-5-3-面向频繁出错设计"><a href="#2-5-3-面向频繁出错设计" class="headerlink" title="2.5.3 面向频繁出错设计"></a>2.5.3 面向频繁出错设计</h4><p>MapReduce 在遇到某个 map 或 reduce 子任务运行出错时，可以单独、自动地进行重试，而不会引起整个 MapReduce 任务的重试。此外，MapReduce 倾向于将数据（甚至是 map 到 reduce 中间环节的数据）进行落盘，一方面是为了容错，另一方面是因为 MapReduce 在设计时假设面对的数据量足够大，内存通常装不下。</p><p>因此，MapReduce 通常更适合<strong>大任务</strong>：即那些需要处理大量数据、运行较长时间的任务。而巨量的数据、过长的耗时，都会使得处理过程中遇到故障司空见惯。在这种情况下，由于一个<strong>子任务（task）</strong> 的故障而重试整个<strong>任务（job）</strong> 就非常得不偿失。当然，即使只在子任务粒度进行重试，也会让那些并不出错的任务运行的更慢（数据要持久化）。但对于频繁出错的任务场景来说，这个取舍是合理的。</p><h3 id="2-6-MapReduce之外"><a href="#2-6-MapReduce之外" class="headerlink" title="2.6 MapReduce之外"></a>2.6 MapReduce之外</h3><h4 id="2-6-1-中间状态的物化"><a href="#2-6-1-中间状态的物化" class="headerlink" title="2.6.1 中间状态的物化"></a>2.6.1 中间状态的物化</h4><p>在大多数情况下，我们事先就明确地知道某个任务的输出<strong>只会为</strong>同一团队的另一个任务所使用。在这种情况下，保存到分布式文件系统上的两个任务间的数据其实只是一种<strong>中间状态</strong>（intermediate state）：只是一种将数据从前序任务传递到后继任务的方式。在诸如推荐系统等复杂的<strong>数据流</strong>中，通常会包含 50~100 个 MapReduce 任务，其中绝大部分任务间的数据都属于数据流中间状态。</p><p>将中间状态写入文件的过程称为<strong>物化</strong>（materialization）。</p><p>MapReduce 将工作流中间结果进行物化的方式有很多缺点：</p><ul><li><strong>无谓等待</strong>。一个 MapReduce 任务只能在所有前置依赖任务完成后才能启动。然而由 Unix 管道缀连起来的命令却能够并行运行，只要一个任务开始产生输出，下一个任务就可以开始消费处理。由于机器配置和负载的不同，总会在某些机器上出现一些执行时间过长<strong>拖后腿的任务</strong>（struggler）。而 MapReduce 的这种等待机制，会让单个任务拖垮整个工作流。</li><li><strong>Mapper 冗余</strong>。Mapper 职责非常简单，仅是读出前置 Reducer 产生的数据，并为之后 Reducer 的分片和排序做准备。在很多情况下，mapper 的职责其实可以并到前序任务的 Reducer 中：如果可以将 Reducer 的输出按照后继 Reducer 的要求准备好，则可将 Reducer 直接串起来，从而省去中间夹杂的 Mapper 阶段。</li><li><strong>数据冗余</strong>。在分布式文件系统中存储中间结果，意味着将数据在不同机器上冗余了几份。对于并不需要共享的中间结果来说，这种方式太过奢侈。</li></ul><h4 id="2-6-2-数据流引擎"><a href="#2-6-2-数据流引擎" class="headerlink" title="2.6.2 数据流引擎"></a>2.6.2 数据流引擎</h4><p>针对分布式系统中的批处理负载，人们开发了很多新的执行引擎。将<strong>整个数据流看做一个任务，而非将其拆分成几个相对独立的子任务</strong>。和 MapReduce 一样，这些引擎也会对每个数据记录在单个线程中，重复调用用户的定制函数（包裹用户逻辑）。并且会将输入数据集进行<strong>切片</strong>（partition），并行地执行（数据并行），然后将一个函数的输出通过网络传递给下一个函数作为输入。</p><p>和 MapReduce 不同的是，这些函数可以进行更灵活地组织，而不需要严格遵循 map 或者 reduce 格式。我们成这些函数为<strong>算子</strong>（operators），且 dataflow 引擎会提供多种选择，以将一个算子的数据输出导入到下一个算子（<strong>类似数据流接线方式</strong>）：</p><ul><li><strong>repartition + sort（sort merge join）</strong>：一种方法是进行 repartition 并按 key 对 record 进行排序，就像 MapReduce 的 shuffle 阶段一样。该功能能够提供像 MapReduce 一样的 <strong>sort-merge join</strong> 和分区方式。</li><li><strong>only repartition（partition hash join）</strong>：另一种可能是接受多个输入，并且用同样的方式进行<strong>分区</strong>（partitioning），但是会跳过排序阶段。这对于分区哈希 join 很有用，因为该算子只关心记录的分区，但其顺序并不重要，因为总会过哈希表重新组织。</li><li><strong>broadcast（broadcast hash join）</strong>：对于广播哈希 join，一个算子的输出会被发送到多个待 join 分区算子。</li></ul><ul><li><strong>按需 shuffle</strong>：对于排序等高代价负载，只有在需要的时候才会执行，而不是总强制发生在 map 和 reduce 之间。</li><li><strong>省掉无用 Mapper</strong>：由于 map 本身并没有进行 repartition，因此可以将其合并到前一个算子中的 reduceer 阶段。</li><li><strong>数据传输优化</strong>：由于所有 join 和依赖等数据拓扑是显式声明的，调度器可以事先知道哪些数据在哪里被需要。因此可以尽可能地做<strong>局部性优化</strong>（locality optimization）。例如，可以尽量将消费某分区数据的任务放到生产该数据的机器上执行，从而通过共享内存而非网络来共享数据。</li><li><strong>中间结果只存一份</strong>：通常来说，只需要将算子的中间结果，在内存中或者本地硬盘中放一份就够了，而不用写到分布式文件系统中。在 MapReduce 中 Mapper 的输出其实也是用了此优化，只不过 dataflow 引擎将该思想扩展到了所有中间状态的存储中。</li><li><strong>算子执行流水化</strong>：大部分算子只要有输入了就可以执行，而不用等到前置任务都完成了才能够执行。</li><li><strong>进程复用</strong>：同一个工作流中，前面算子所使用的 JVM 进程池可以为之后算子所复用，而不用像 MapReduce 一样每个任务都要开一个新的 JVM 进程。</li></ul><p><strong>算子</strong>是 map 和 reduce 的泛化</p><h4 id="2-6-3-容错"><a href="#2-6-3-容错" class="headerlink" title="2.6.3 容错"></a>2.6.3 容错</h4><p>将所有中间状态持久化到分布式文件系统中的一个好处是——<strong>持久性</strong>（durable），这会使得 MapReduce 的容错方式变得非常简单：如果某个任务挂了，仅需要在其他机器上重新启动，并从文件系统中读取相同的输入即可。</p><p>Spark、Flink 和 Tez 都会避免将中间状态写到 HDFS 中，因此他们采用了完全不同的容错方式：<strong>如果某个机器上的中间结果丢了，就回溯工作流的算子依赖（DAG 依赖），找到最近可用的数据按照工作流重新计算</strong>（最差的情况会一直找到输入数据，而输入数据通常存在于 HDFS 上）。</p><p>为了能够通过重新计算来容错，框架必须跟踪每一部分数据的<strong>计算轨迹</strong>（DGA 依赖，或者说数据谱系，data lineage）——涉及哪些输入分片、应用了哪些算子。Spark 使用<strong>弹性分区数据集</strong>（RDD）抽象来追踪数据的祖先；Flink 使用了快照来记录所有算子状态，以从最近的<strong>检查点</strong>（checkpoint）重启运行出错的算子。</p><p>当通过重算来容错时，最重要的是要明确<strong>计算过程</strong>（即算子）是否为<strong>确定性的</strong>（deterministic）：即，<strong>给定同样的输入数据，多次运行同一算子总会产生同样的输出吗</strong>？当算子的数据已经发到下游后出错时，该问题变的非常重要。如果算子重新运行时产生的数据和之前不一致，则下游算子很难在新老数据间进行冲突处理。对于非确定性算子的容错方案，通常是将下游算子也都清空状态一并重启。</p><h4 id="2-6-4-分布式处理框架最主要解决的两个问题是："><a href="#2-6-4-分布式处理框架最主要解决的两个问题是：" class="headerlink" title="2.6.4 分布式处理框架最主要解决的两个问题是："></a>2.6.4 分布式处理框架最主要解决的两个问题是：</h4><ul><li><strong>分片</strong> 在 MapReduce 中，会根据输入数据的文件块（file chunk）的数量来调度 mappers。mappers 的输出会在<strong>二次分片、排序、合并</strong>（我们通常称之为 shuffle）到用户指定数量的 Reducer 中。该过程是为了将所有相关的数据（如具有相同 key）集结到一块。 后 MapReduce 时代的数据流工具会尽量避免不必要的排序（因为代价太高了），但他们仍然使用了和 MapReduce 类似的分区方式。</li><li><strong>容错</strong> MapReduce 通过频繁的（每次 MapReduce 后）<strong>刷盘</strong>，从而可以避免重启整个任务，而只重新运行相关子任务就可以从其故障中快速恢复过来。但在错误频率很低的情况下，这种频繁刷盘做法代价很高。数据流工具通过尽可能的减少中间状态的刷盘（当然，shuffle 之后还是要刷的），并将其尽可能的保存在内存中，但这意味着一旦出现故障就要从头重算。算子的<strong>确定性</strong>可以减少重算的数据范围（确定性能保证只需要算失败分区，并且结果和其他分区仍然一致）。</li></ul><p>批处理任务的基本特点是——读取输入，进行处理，产生输出的过程中，<strong>不会修改原数据</strong>。换句话说，输出是输入的衍生数据。其中一个重要特点是，输入数据是<strong>有界的</strong>（bounded）：<strong>输入的大小是固定的、事先确定的</strong>（比如输入是包含一组日志的数据或者一个快照点的数据）。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;批处理系统通常会接受大量数据作为输入，然后基于这些数据执行任务，进而产生一些数据作为输出。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="阅读笔记" scheme="https://stardustorz.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DDIA" scheme="https://stardustorz.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/DDIA/"/>
    
    
    <category term="DDIA" scheme="https://stardustorz.github.io/tags/DDIA/"/>
    
  </entry>
  
  <entry>
    <title>[DDIA] 一致性和共识协议</title>
    <link href="https://stardustorz.github.io/2023/07/22/DDIA/08%20%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/"/>
    <id>https://stardustorz.github.io/2023/07/22/DDIA/08%20%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/</id>
    <published>2023-07-21T16:00:00.000Z</published>
    <updated>2025-03-09T16:09:58.290Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>共识</strong>（consensus），即，<em>让所有节点在<strong>某件事情</strong>上达成一致</em>。</p></blockquote><span id="more"></span><p>大部分<strong>数据系统</strong>都可以抽象为一系列<strong>数据操作</strong>的依次施加，即状态机模型。而共识协议可以让多机对某个<strong>确定</strong>的<strong>操作序列</strong>达成共识，进而对系统的任意状态达成共识。</p><h2 id="1-一致性保证"><a href="#1-一致性保证" class="headerlink" title="1 一致性保证"></a>1 一致性保证</h2><p><strong>收敛性</strong>（<em>convergence</em>），即最终，所有副本都会收敛到相同的值。</p><h2 id="2-线性一致性"><a href="#2-线性一致性" class="headerlink" title="2 线性一致性"></a>2 线性一致性</h2><p>一个系统对外表现的像所有数据<strong>只有一个副本</strong>，作用于数据上的操作都可以<strong>原子地完成</strong>。<br>在一个提供线性一致性的系统中，只要某个客户端成功的进行了写入某值，其他所有客户端都可以在数据库中读到该值。提供单副本的抽象，意味着客户端任何时刻读到的都是<strong>最近、最新</strong>（up-to-date）的值，而不会是过期缓存、副本中的旧值。换句话说，线性一致性是一种数据<strong>新鲜度保证</strong>（recency guarantee）。</p><h3 id="2-1-如何让系统满足线性一致？"><a href="#2-1-如何让系统满足线性一致？" class="headerlink" title="2.1 如何让系统满足线性一致？"></a>2.1 如何让系统满足线性一致？</h3><p><strong>让系统表现得好像只有一个数据副本</strong>。</p><p>线性一致性要求所有操作标记组成序列是<strong>永远向前的</strong>，即满足数据<strong>新鲜度要求：一旦我们写入或者读取到某值，所有稍后的读请求都能看到该值，直到有人再次将其改写。</strong></p><p><strong>线性一致性和可串行化</strong></p><p><strong>线性一致性</strong>（Linearizability）很容易和<strong>可串行化</strong>（serializability）相混淆，因为他们看起来都像是：可以进行拓扑化组织。但他们是不同维度的约束，我们很有必要对其进行区分：</p><p><strong>可串行化</strong>（Serializability）。可串行化是事务的一种隔离级别。每个事务可能会涉及<strong>多个数据对象</strong>（行、文档、记录）的读写，<a href="https://ddia.qtmuniao.com/#/ch07?id=%e5%8d%95%e5%af%b9%e8%b1%a1%e5%92%8c%e5%a4%9a%e5%af%b9%e8%b1%a1%e6%93%8d%e4%bd%9c">之前</a>有讨论过单对象和多对象。可串行化可以保证所有事务好像按<strong>某种顺序依次执行</strong>（后一个事务在前一个事务结束后才开始）。需要注意的是，如果某种串行顺序和实际执行顺序不一致也没事，只要是串行执行就行。举个例子，如果 A、B、C 三个事务并发执行，真实顺序是 A-&gt;B-&gt;C，但如果对应用层表现为 C-&gt;A-&gt;B 的执行顺序（可能由于多机时间戳不同步），也可以叫可串行化，但 C-&gt;A-&gt;B 的执行顺序在<strong>某个</strong>对象上可能不满足线性一致性。</p><p><strong>线性一致性</strong>（Linearizability）。线性一致性是一种针对寄存器（register，<strong>单个数据对象</strong>）的读写新鲜度保证。它不会将多个操作打包成事务，因此不能避免像之前提到的<a href="https://ddia.qtmuniao.com/#/ch07?id=%e5%86%99%e5%81%8f%e5%ba%8f%e5%92%8c%e5%b9%bb%e8%af%bb">写偏序</a>等问题，除非使用某些辅助手段，如<a href="https://ddia.qtmuniao.com/#/ch07?id=%e7%89%a9%e5%8c%96%e5%86%b2%e7%aa%81">物化冲突</a>。</p><p>一个数据库可以同时提供可串行化和线性一致性保证，我们称之为<strong>严格可串行化</strong>（<em>strict serializability</em>）或者<strong>单副本可串行化</strong>（strong one-copy serializability）。使用两阶段锁或者真正串行化执行实现的可串行化，通常都是线性一致的。</p><p>然而，基于快照隔离的串行化<strong>通常</strong>不是线性一致的。为了避免读写互相阻塞，所有的读取都会基于某个一致性的快照，则该快照之后的写入不会反映到读请求上，因此，快照读不满足线性一致性。</p><h3 id="2-2-应用线性一致性"><a href="#2-2-应用线性一致性" class="headerlink" title="2.2 应用线性一致性"></a>2.2 应用线性一致性</h3><p>在使用单主模型的系统中，需要保证任何时刻只有一个主副本，而非多个（脑裂）。一种进行主选举的方法是使用锁：每个节点在启动时都试图去获取锁，最终只有一个节点会成功并且变为主。不论使用什么方式实现锁，都必须<strong>满足线性一致性</strong>：所有节点必须就某节点拥有锁达成一致，否则这样的锁服务是不能用的。</p><p><strong>唯一性约束</strong>在数据库中很常见：比如用户名和邮箱可以用来唯一的标识一个用户、在同一个文件系统中不可能有多个文件具有相同的路径和文件名。如果你想在数据写入时<strong>维持这些约束</strong>（比如两个人使用相同的用户名并发地创建账户，其中一个会失败而报错），你需要线性一致性。</p><p>要求所有节点在<strong>单个最新值</strong>（账户余额、股票水位、座位预定）上达成一致。</p><h3 id="2-3-实现线性一致的系统"><a href="#2-3-实现线性一致的系统" class="headerlink" title="2.3 实现线性一致的系统"></a>2.3 实现线性一致的系统</h3><p>可以通过牺牲部分性能来让 Dynamo 风格的 Quorum 读写变成线性一致的：</p><ol><li>每个读请求必须进行同步的<a href="https://ddia.qtmuniao.com/#/ch05?id=%e8%af%bb%e6%97%b6%e4%bf%ae%e5%a4%8d%e5%92%8c%e5%8f%8d%e7%86%b5">读取修复</a>。</li><li>发送任意写请求之前要先读取最新值。</li></ol><h3 id="2-4-线性一致性的代价"><a href="#2-4-线性一致性的代价" class="headerlink" title="2.4 线性一致性的代价"></a>2.4 线性一致性的代价</h3><p>如果应用层要求线性一致的读写，则<strong>数据中心间的网络中断会造成服务的不可用</strong>。</p><h4 id="2-4-1-CAP-定理"><a href="#2-4-1-CAP-定理" class="headerlink" title="2.4.1 CAP 定理"></a>2.4.1 CAP 定理</h4><ul><li>如果应用层要求系统提供线性一致性，此时如果某些数据副本由于网络问题和系统其他部分<strong>断开了连接</strong>，则这些数据副本就<strong>不再能够正常地处理请求</strong>：要么等待网络恢复、要么进行报错。但这都意味着系统不可用。</li><li>如果应用不要求系统的线性一致，则即使多副本间遇到连接问题，每个副本可以独立的进行写入。从而，即使出现了网络故障，系统仍然能够保持可用，但其行为不是线性一致的。</li></ul><p>CAP 有时候被表述为，在做系统设计时，一致性（consistency）、可用性（Availability）、分区容错性（Partition tolerance），只能三取其二。<br><strong>当网络出现分区时，一致性和可用性只能二选其一</strong>（<em>either Consistent or Available when Partitioned</em>）。</p><h4 id="2-4-2-线性一致性和网络延迟"><a href="#2-4-2-线性一致性和网络延迟" class="headerlink" title="2.4.2 线性一致性和网络延迟"></a>2.4.2 线性一致性和网络延迟</h4><p>很多分布式系统选择不提供线性一致性的原因也在于此：<strong>是为了提升系统性能而非进行容错</strong>。在任何时候，提供线性一致性都会严重拖慢系统。而非在网络故障发生时，才需要对线性一致性进行牺牲。</p><p>如果你想要保证线性一致，读写请求的响应时间是<strong>正比于网络延迟</strong>的。</p><p><strong>顺序性</strong>（ordering）、<strong>线性一致性</strong>（linearizability）和<strong>共识协议</strong>（consensus）三个概念间有很深的联系。</p><h2 id="3-顺序保证"><a href="#3-顺序保证" class="headerlink" title="3 顺序保证"></a>3 顺序保证</h2><h3 id="3-1-顺序和因果（Ordering-and-Causality）"><a href="#3-1-顺序和因果（Ordering-and-Causality）" class="headerlink" title="3.1 顺序和因果（Ordering and Causality）"></a>3.1 顺序和因果（Ordering and Causality）</h3><p><strong>顺序可以维持因果性</strong><br>因果将顺序施加于<strong>事件</strong>（event）：</p><ol><li>先有因，后有果</li><li>先有消息发送，然后该消息被收到</li><li>先有问题，后有答案<br>如果一个系统遵循因果约束，则我们称其为<strong>因果一致的</strong>（<em>causally consistent</em>）。比如，快照隔离就可以提供因果一致性：当从数据库读取数据的时候，如果你能读到某个时间点的数据，就一定能读到其之前的数据</li></ol><h4 id="3-1-1-因果序非全序"><a href="#3-1-1-因果序非全序" class="headerlink" title="3.1.1 因果序非全序"></a>3.1.1 因果序非全序</h4><p><strong>全序</strong>（total order）意味着<strong>系统内任意两个元素可比大小</strong>。<br>反之，集合是<strong>偏序</strong>（partially ordered）：在某些情况下，我们可以说一个集合比另一个集合大（两个集合间有包含关系）；但在另外一些情况下，两个集合间没有可比关系。</p><p><strong>线性一致性</strong>（Linearizability）：对于任意两个操作，我们总是可以确定其发生的先后关系，也即在可线性化系统中，所有的操作顺序满足全序关系。<br><strong>因果一致性</strong>（Causality）。如果我们无从判定两个操作的先后关系，则称之为<strong>并发的</strong>（concurrent，参见<a href="https://ddia.qtmuniao.com/#/ch05?id=%e5%8f%91%e7%94%9f%e4%ba%8e%e4%b9%8b%e5%89%8d%ef%bc%88happens-before%ef%bc%89%e5%92%8c%e5%b9%b6%e5%8f%91%e5%85%b3%e7%b3%bb">发生于之前和并发关系</a>）。因果性定义了一种<strong>偏序</strong>（partial order）关系，而非全序关系：有些操作存在因果，因此可比；而另外一些操作则是并发的，即不可比。</p><h3 id="3-2-序列号定序"><a href="#3-2-序列号定序" class="headerlink" title="3.2 序列号定序"></a>3.2 序列号定序</h3><p><strong>使用序列号（sequence numbers）或者时间戳（timestamps）来给事件定序</strong>。<br>在使用单主模型的多副本系统中，主节点上<strong>操作日志的追加顺序</strong>确定了一个对所有操作的全序，且满足操作发生的因果关系。主节点可以为每条日志按顺序关联一个全局递增的序列号，如果从节点上也按都按此序列号顺序应用操作日志到状态机，则每个副本总能保持一致的状态（但有可能稍落后于主节点）。</p><h4 id="3-2-1-非因果序生成器"><a href="#3-2-1-非因果序生成器" class="headerlink" title="3.2.1 非因果序生成器"></a>3.2.1 非因果序生成器</h4><p>如果系统中没有唯一的单主节点（比如你用的是多主模型或无主模型，又或者你的系统存在多个分区），则如何为每个操作产生一个序列号就变得不那么简单直观了。常用的方式有以下几种：</p><ol><li><strong>每个节点独立地生成不相交的序列集</strong>。如，你的系统中有两个节点，一个节点只产生奇数序号，另一个节点只产生偶数序号。更通用一些，我们可以在生成的序号中保留一些位来编码对节点的标识，从而让不同的节点永远不会产生相同的序号。</li><li><strong>可以为每个操作关联一个日历时钟</strong>（或者说物理时钟）。这些时间戳不是有序的（因为回拨？），但如果有足够的精读，就可以让任意两个操作关联的时间戳不同，依次也可以达到全序的目的。此种方法有时候会被用在解决冲突使用后者胜的策略（但会有风险）。</li><li><strong>每次可以批量产生一组序列号</strong>。比如，在请求序列号时，节点 A 可以一次性声明占用 1 ~ 1000 的序列号，节点 B 会一次占用 1001~2000 的序列号。则本地的操作可以从拿到的这批序列号中直接分配，仅在快耗尽时再去请求一批。这种方法常被用在 TSO（timestamp oracle，单点授时）的优化中。<br><strong>都存在因果问题：</strong></li><li><strong>不同节点上处理操作的速率很难完全同步</strong>。因此，如果一个节点使用奇数序号，另一个节点时用偶数序号，则两个序号消耗的速率也会不一致。此时，当你有两个奇偶性不同的序号时，就难以通过比较大小来确定操作发生的先后顺序。</li><li><strong>物理时间戳会由于多机时钟偏差，而不满足因果一致</strong>。例如，在图 8-3 中（参见<a href="https://ddia.qtmuniao.com/#/ch08?id=%e6%97%b6%e9%97%b4%e6%88%b3%e4%bb%a5%e5%ae%9a%e5%ba%8f">时间戳以定序</a>），就出现了发生在之后的操作被分配了一个较小的时间戳。</li><li>对于批量分配方式，有可能发生较早的操作被分配了 1001-2000 的序列号，而较晚的操作被分配了 1-1000 的序列号。如此一来，序列号的分配不满足因果一致。</li></ol><h4 id="3-2-2-Lamport-时间戳"><a href="#3-2-2-Lamport-时间戳" class="headerlink" title="3.2.2 Lamport 时间戳"></a>3.2.2 Lamport 时间戳</h4><p>在该系统中，每个节点有一个唯一的 <strong>id</strong> 和一个记录处理过多少个操作的计数器，Lamport 时间戳是上述两者组成的二元组：<code>(counter, node ID)</code> 。不同的节点可能会有相同的 counter 值，但通过引入 node ID，可以使所有时间戳都是全局唯一的。</p><p>让 Lamport 时间戳能够满足因果一致性的核心点在于：<strong>每个节点和客户端都会让 counter 追踪当前所看到（包括本机的和通信的）的最大值</strong>。当节点看到请求或者回复中携带的 counter 值比自己大，就会立即用其值设置本地 counter。</p><p><strong>只有在收集到系统中所有操作之后，才能真正确定所有操作的全序</strong>。</p><h3 id="3-3-全序广播"><a href="#3-3-全序广播" class="headerlink" title="3.3 全序广播"></a>3.3 全序广播</h3><p>使用单主模型的系统会面临两个问题：</p><ol><li>当系统负载超过单机可以处理的尺度，如何进行扩容。</li><li>当主节点宕机时如何进行故障转移（failover）。<br>在分布式系统的语境下，该问题也被称为<strong>全序广播</strong>（total order broadcast）或者<strong>原子广播</strong>（atomic broadcast）。</li></ol><p>全序广播是一种多个节点间交换消息的协议。它要求系统满足两个安全性质：</p><ol><li><strong>可靠交付</strong>。如果一个节点收到了消息，则系统内所有的相关节点都要收到该消息。</li><li><strong>全序交付</strong>。每个节点接收到消息的顺序一致。</li></ol><p>全序广播的一个重要性质是：<strong>当收到消息时，其顺序已经确定</strong>。</p><p>可以从另外一个角度来理解全序广播——用来写日志（比如复制日志、事务日志或者写前日志）：<strong>投递消息就像追加日志</strong>。由于所有节点都会按照同样的顺序发送消息，则所有节点在读取日志的时候也会得到同样的消息序列。</p><h4 id="3-3-1-使用全序广播实现线性一致性存储"><a href="#3-3-1-使用全序广播实现线性一致性存储" class="headerlink" title="3.3.1 使用全序广播实现线性一致性存储"></a>3.3.1 使用全序广播实现线性一致性存储</h4><p>全序广播是<strong>异步的</strong>：系统保证以同样的<strong>顺序</strong>交付消息，但并不保证消息的交付<strong>时刻</strong>（即，有的消息接收者间可能存在着滞后）。与之相对，线性一致性是一种<strong>新鲜度保证</strong>：读取一定能看到最新成功的写。</p><ol><li>向服务中追加一个带有某用户名的消息条目，表明你想使用该用户名。</li><li>（由于全序广播是异步的）不断读取日志，直到能够读到刚才你追加的消息条目。</li><li>检查所有想要使用该用户名的消息，这时你可能会得到多条消息，如果你当初写下的消息在第一条，则你是成功的。此时，你可以“确认”（持久化，比如追加日志，比如写入数据库）占有该用户名的信息，然后给客户端返回成功。如果第一条消息不是你的，则终止请求。</li></ol><h4 id="3-3-2-使用线性一致存储实现全序广播"><a href="#3-3-2-使用线性一致存储实现全序广播" class="headerlink" title="3.3.2 使用线性一致存储实现全序广播"></a>3.3.2 使用线性一致存储实现全序广播</h4><p>对于每一个发给全序广播系统的消息，使用整数寄存器 increment-and-get 操作关联一个序列号；然后将消息发送给所有节点（重试任何丢失的消息）。每个节点接收到消息后利用序列号顺序对外交付消息。这种机制很像 TCP，但并不是描述通信双方，而是一个分布式系统。</p><h2 id="4-分布式事务和共识协议"><a href="#4-分布式事务和共识协议" class="headerlink" title="4 分布式事务和共识协议"></a>4 分布式事务和共识协议</h2><p>在很多场景下让多个节点达成共识是非常重要的。比如：</p><ul><li><strong>Leader 选举</strong> 在使用单主模型的数据库中，所有节点需要对谁是主节点达成一致。当网络问题导致有些节点不能正常通信时，领导权就会出现争议。在这种情形下，共识对于避免错误的故障转移非常重要。引入如果出现两个领导者可以同时接受写入（<strong>脑裂</strong>），所有副本上的数据就会产生分叉，从而变得不一致甚而数据丢失。</li><li><strong>原子提交</strong> 在一个横跨多节点或具有多分区的数据库中，可能会出现某个事务在一些节点执行成功，但在另外一些节点却运行失败。如果我们想保持事务的原子性（ACID 中的 A，参见<a href="https://ddia.qtmuniao.com/#/ch07?id=%e5%8e%9f%e5%ad%90%e6%80%a7%ef%bc%88atomicity%ef%bc%89">原子性</a>），我们就必须让所有节点就事务的结果达成一致：要么全部回滚（只要有故障），要么提交（没有任何故障）。这个共识的特例也被称为<strong>原子提交</strong>（atomic commit）。<h3 id="4-1-原子提交和两阶段提交"><a href="#4-1-原子提交和两阶段提交" class="headerlink" title="4.1 原子提交和两阶段提交"></a>4.1 原子提交和两阶段提交</h3>原子性能够避免失败的事务通过半完成（half-finished）或者半更新（half-updated）的结果来破坏数据库系统。</li></ul><p>二级索引是独立于<strong>原始数据</strong>的一种数据结构，因此如果你更新了原始数据，对应的二级索引也需要进行同步更新。原子性能够保证二级索引和原始数据时刻保持一致。</p><h4 id="4-1-1-从单机到分布式的原子提交"><a href="#4-1-1-从单机到分布式的原子提交" class="headerlink" title="4.1.1 从单机到分布式的原子提交"></a>4.1.1 从单机到分布式的原子提交</h4><p>简单地在提交事务时给每个节点发送提交请求让其提交事务，是不能够满足事务基本要求的。这是因为，可能有的节点成功提交了，有的节点却提交失败了，从而违反了原子性保证：</p><ul><li>有些节点在提交时检测到完整性约束被破坏了，因此中止事务；但另外一些节点却能够成功提交。</li><li>有些提交请求由于网络过慢而超时丢弃，另外一些提交请求却成功抵达。</li><li>有一些节点在写入提交记录前宕机重启，导致事务回滚；另外一些节点却成功提交。</li></ul><p><strong>事务提交后是不可撤销的</strong>——在事务提交后，你不能再改变主意说，我要重新中止这个事务。这是因为，一旦事务提交了，就会对其他事务可见，从而可能让其他事务依赖于该事务的结果做出一些新的决策；这个原则构成了<strong>读已提交</strong>（read commited）隔离级别的基础（参见<a href="https://ddia.qtmuniao.com/#/ch07?id=%e8%af%bb%e5%b7%b2%e6%8f%90%e4%ba%a4">读已提交</a>）。如果事务允许在提交后中止，其他已经读取了该事务结果的事务也会失效，从而引起事务的级联中止。</p><p>当然，事务所造成的<strong>结果</strong>在事实上是可以被撤销的，比如，通过<strong>补偿事务</strong>（<em>compensating transaction</em>）。但，从数据库的视角</p><h4 id="4-1-2-两阶段提交"><a href="#4-1-2-两阶段提交" class="headerlink" title="4.1.2 两阶段提交"></a>4.1.2 <em>两阶段提交</em></h4><p><strong>两阶段提交</strong>（2PC，two-phase commit）是一种在多个节点上实现原子事务的算法——即，保证所有节点要么都提交，要么都中止。   相比单机事务的一次提交请求，2PC 中的提交、中止过程被拆分成了两个阶段</p><p><strong>2PC</strong> 引入了一个单机事务中没有的角色：<strong>协调者</strong>（coordinator，有时也被称为事务管理器，transaction manager）。</p><p><strong>2PC 事务</strong>通常也由应用层对多个节点上的数据读写开始。和协调者相对，我们将这些数据节点称为事务的<strong>参与者</strong>（participants）。当应用层准备好提交后，协调者开始阶段一：向每个参与者发送 <strong>prepare</strong> 请求，询问他们是否能够提交。然后，协调者会根据参与者的返回而进行下一步动作：</p><ol><li>如果<strong>所有参与者</strong>都回复“可以”（yes），表示能够提交，则协调者就会进入第二阶段发出<strong>提交</strong>（ <strong>commit</strong> ）请求，此时，提交事实上才开始执行。</li><li><p>如果有任何参与者回复“不行”（no），或者请求超时了，协调者就会进入第二阶段并发送一个 <strong>中止</strong>（abort）请求，中止事务。</p><h4 id="4-1-3-基于承诺的系统"><a href="#4-1-3-基于承诺的系统" class="headerlink" title="4.1.3 基于承诺的系统"></a>4.1.3 基于承诺的系统</h4></li><li><p>当应用想开启一个分布式事务时，它会首先向协调者要一个<strong>事务 ID</strong>。该事务 ID 是全局唯一的。</p></li><li>应用会使用前述事务 ID 向所有的参与者发起一个单机事务，所有节点会各自完成读写请求，在此过程中，如果有任何出错（比如节点宕机或者请求超时），协调者或者任意参与者都可以中止事务。</li><li>当应用层准备好提交事务时，协调者会向所有参与者发送<strong>准备提交</strong>（prepare）请求，并在请求中打上事务 ID 标记。如果有请求失败或者超时，则协调者会对所有参与者发送带有该事务 ID 的中止请求。</li><li>当参与者收到<strong>准备提交</strong>请求时，它必须确认该事务能够在任何情况下都能被提交，才能回复“<strong>可以</strong>”。这包括，将所有写入刷到磁盘（一旦承诺了，就不能反悔，即使之后遇到宕机、断电或者磁盘空间不足）、检查是否有冲突或者违反约束的情况。换句话说，如果回复“可以”，意味着参与者<strong>让渡了中止事务的权利（给协调者）</strong>，但此时并没有真正地提交。</li><li>当协调者收到所有参与者准备提交的回复后，会决定提交还是中止该事务（只有在所有参与者都回复“可以”时，才会提交）。协调者需要将该决策写入事务日志，并下刷到磁盘，以保证即使宕机重启，该决策也不会丢失。这被称为<strong>提交点</strong>（commit point）。</li><li>协调者将决策刷入了磁盘后，就会将决策（提交或者中止）请求发给所有参与方。如果某个请求失败或者超时，则协调者会对其进行无限重试，直到成功。不允许走回头路：如果协调者决定了提交，则不管要进行多少次的重试，也必须要保证该决策的执行。如果参与者在此时宕机了，则当重启时也必须进行提交——因为它<strong>承诺过要提交</strong>，因此在重启后不能拒绝提交。</li></ol><p>该协议有两个重要的“不可回退点”：</p><ol><li>当某个参与者回复“可以”时，就做出了（将来无论发生什么）肯定可以提交的承诺。（当然，协调者可以中止事务）</li><li>当协调者决定提交时，该决定一旦做出（写入磁盘），就是不可撤回的。</li></ol><h4 id="4-1-4-协调者故障"><a href="#4-1-4-协调者故障" class="headerlink" title="4.1.4 协调者故障"></a>4.1.4 协调者故障</h4><p>如果协调者在准备提交请求发送前故障，则参与者可以放心的中止事务。然而，一旦参与者收到准备提交请求，并且回复“可以”，则根据 2PC 设定，它<strong>不能单方面的中止事务</strong>——而必须等待协调者的提交或者中止请求。如果此时协调者宕机或者网络故障，则参与者只能<strong>死等</strong>。参与者事务的这种状态称为<strong>存疑</strong>（in doubt）或者<strong>未定</strong>（uncertain）。</p><p>在 2PC 中，唯一使算法能够完成的方法就是等待协调者恢复。这也是为什么，协调者在给参与者发送提交或者中止消息时，需要先将该决策写入事务日志中：当协调者恢复时，他就能从事务日志中读取该决策，以让所有处于未决状态的参与者状态确定下来。如果协调者恢复了，发现并没有写入任何决策到事务日志中，则中止该事务。因此，2PC 的<strong>提交点</strong>（commit point）最终可以归结到协调者上的单机原子提交。</p><h4 id="4-1-5-三阶段提交"><a href="#4-1-5-三阶段提交" class="headerlink" title="4.1.5 三阶段提交"></a>4.1.5 三阶段提交</h4><p>由于 2PC 在等待协调者宕机恢复时系统可能会卡住，因此两阶段提交又称为<strong>阻塞式原子提交协议</strong>（blocking atomic commit protocol）。<br>作为 2PC 的替代，人们又提出了三阶段提交（three-phase commit）。然而，3PC 对系统有一定假设：网络具有有界延迟，请求延迟也是有界的（bounded，参见<a href="https://ddia.qtmuniao.com/#/ch08?id=%e8%b6%85%e6%97%b6%e5%92%8c%e6%97%a0%e7%95%8c%e5%bb%b6%e8%bf%9f%ef%bc%88unbounded-delays%ef%bc%89">超时和无界延迟</a>）。在具有无界网络延迟进程停顿的实际系统中，3PC 无法保证原子性。<br>在具有无界延迟的网络中，超时机制就不是一个可靠的故障检测方法，即使没有任何节点故障，一个请求仍会由于网络问题而超时。出于这个原因，即使 2PC 可能会因为协调者宕机卡住，但人们仍然在使用它，而没有转向 3PC。</p><h3 id="4-2-实践中的分布式事务"><a href="#4-2-实践中的分布式事务" class="headerlink" title="4.2 实践中的分布式事务"></a>4.2 实践中的分布式事务</h3><p>分布式事务，尤其是使用两阶段提交实现的分布式事务，毁誉参半。一方面，他们可以提供其他方式难以实现的<strong>安全保证</strong>；另一方面，由于运维复杂、降低性能、承诺过多，他们广受诟病。为了避免分布式事务带来的运维复杂度，很多云服务选择不支持分布式事务。</p><p>两种完全不同的分布式事务经常被混淆：</p><ul><li><strong>数据库内部分布式事务</strong> 在一些分布式数据中（标配支持多分区和多副本的数据库），支持跨节点的<strong>内部分布式事务</strong>。如，VoltDB 和 MySQL 集群的 NDB 存储引擎就有这样的内部事务支持。在这种情况下，所有事务参与节点都运行着同样的二进制代码。</li><li><strong>异构的分布式事务</strong> 在异构的分布式事务中，所有参与者使用了两种以上的技术栈：如，来自不同厂家的两种数据库实例，甚至可能包含非数据库系统，如消息队列。即使每个子系统内部实现完全不同，构建于其上的分布式事务也能够保证原子提交。</li></ul><p>数据库内部的事务不需要考虑和其他系统的相容性，因此在实现时可以使用任何协议、可以针对特定技术栈进行任何优化。因此，数据库内部的分布式事务通常能够很好地工作。相反，横跨多个异构系统的事务实现则充满了挑战。</p><h4 id="4-2-1-恰好一次的消息处理"><a href="#4-2-1-恰好一次的消息处理" class="headerlink" title="4.2.1 恰好一次的消息处理"></a>4.2.1 恰好一次的消息处理</h4><p>异构的分布式事务系统可以将多种异构的系统，以强大的方式进行整合。例如，<strong>当且仅当</strong>数据库中处理消息的事务成功提交时，消息队列才会将该消息标记为<strong>已处理</strong>。可以将消息确认和数据库写入打包在单个事务里进行原子提交，来实现上述行为。</p><h4 id="4-2-2-XA-事务"><a href="#4-2-2-XA-事务" class="headerlink" title="4.2.2 XA 事务"></a>4.2.2 XA 事务</h4><p>XA 不是一个网络协议——它定义了一组和事务协调者交互的 C 语言 API 接口。<br>使用事务的<strong>应用层</strong>会以网络驱动（network driver）或者客户端库（client library）来使用 XA 的 API 与参与者服务（数据库或者消息队列）进行交互。如果驱动程序支持 XA 协议，则意味着应用侧可以调用 XA 的 API 来确定一个操作是否是分布式事务的一部分（即通过 XA 定义的接口来确定事务所涵盖<strong>操作的边界</strong>）；如果是，则会发送必要的消息给参与者。XA 驱动也提供了一些回调，协调者可以使用这些回调要求参与者进行准备、提交或者中止。</p><p>事务的<strong>协调者</strong>实现了 XA API。XA 的标椎并没规定协调者该如何实现，并且在实践中协调者通常以<strong>库的形式</strong>被加载进应用程序中（作为应用程序的一部分，而非额外单独的一个服务）。它会追踪事务中的所有参与者，在要求参与者准备提交（prepare）后收集其回复，使用本地磁盘上的日志来跟踪每个事务的<strong>提交/中止</strong>决策。</p><h4 id="4-2-3-阻塞时持有锁"><a href="#4-2-3-阻塞时持有锁" class="headerlink" title="4.2.3 阻塞时持有锁"></a>4.2.3 阻塞时持有锁</h4><p>问题的关键点在于存在<strong>锁</strong>（locking）。数据库中的事务通常会使用行级别的互斥锁来保护对某一行的修改，以防止脏写。更进一步，如果想获得可串行化隔离级别，数据库在使用两阶段锁进行实现时，会对事务所有读过的行加共享锁（参见<a href="https://ddia.qtmuniao.com/#/ch07?id=%e4%b8%a4%e9%98%b6%e6%ae%b5%e9%94%81">两阶段锁</a>）。<br>数据库在提交或者中止事务前<strong>不能够释放获取的这些锁</strong>。因此，在使用两阶段提交时，一个事务必须在其处于未定状态期间一直持有锁。如果协调者在宕机后花了 20 分钟才重新启动起来，则对应参与者的锁就要持有 20 分钟。如果参与者日志由于某种原因丢掉了，这些锁会被永远的持有——除非系统管理员会手动释放它们。</p><h4 id="4-2-4-从协调者故障中恢复"><a href="#4-2-4-从协调者故障中恢复" class="headerlink" title="4.2.4 从协调者故障中恢复"></a>4.2.4 从协调者故障中恢复</h4><p>在实践中，常会产生一些孤立的（orphaned）未定事务——即，由于某种原因，<strong>事务的协调者</strong>（比如由于软件 bug 事务日志丢失或者损坏）<strong>无从判断事务的最终结果是提交还是回滚</strong>。由是，这些事务不能够被自动的处理，从而永久的卡在那里，持有锁并且阻塞其他事务。<br>唯一的出路是让管理员手动的来提交或者中止事务。<br>很多 XA 事务的实现会留有紧急后门，称为<strong>启发式决策</strong>（<em>heuristic decisions</em>）：允许一个参与者不用等待协调者的决策，而<strong>单方面</strong>决定中止还是提交一个未定事务。需要说明的是，这里的启发式仅仅是<strong>可能打破原子性</strong>（probably breaking atomicity）的一种委婉说法。因为这么做可能会违反两阶段提交所提供的保证。因此这种启发式决策仅是为了救急，而不能进行日常使用。<em>**</em></p><h4 id="4-2-5-分布式事务的限制"><a href="#4-2-5-分布式事务的限制" class="headerlink" title="4.2.5 分布式事务的限制"></a>4.2.5 分布式事务的限制</h4><p>分布式事务有<strong>放大故障</strong>的嫌疑，这与我们构建容错系统的目标背道而驰（这就是 tradeoff，为上层提供的更多的一致性保证，就会牺牲性能，降低可用性）。</p><h3 id="4-3-容错的共识算法"><a href="#4-3-容错的共识算法" class="headerlink" title="4.3 容错的共识算法"></a>4.3 容错的共识算法</h3><p>共识协议通常被描述为：一个或者多个节点可能会各自<strong>提议</strong>（propose）一些值，共识协议需要在这些值中间做出唯一的<strong>决策</strong>（decide）。</p><ul><li><strong>全局一致性</strong>（<em>Uniform agreement</em>） 没有任何两个节点最终做出不同决策。</li><li><strong>正直性</strong>（<em>Integrity</em>） 没有任何节点会做出两次决策（不会反复横跳）</li><li><strong>有效性</strong>（<em>Validity</em>） 如果一个节点做出了决策，该决策所对应的值一定来自系统内某个节点的提议</li><li><strong>可终止性</strong>（<em>Termination</em>） 任何没有宕机的节点，最终都会给出对某个值的决策<br>全局一致和正直性定义了共识协议的核心概念：<strong>所有节点都要决策出同样的结果，并且一旦做出决策，就不能反悔</strong>。加入有效性更多的是为了排除一些无效（trivial）结果</li></ul><p><strong>可终止性是对容错的一种形式化描述</strong>（从结果来描述）。它本质上是在说，一个共识算法不能让系统陷入一种卡在那、啥也不干，直到永远的状态。换句话说，系统必须能够正常运作，即使有些节点宕机，其他节点也必须能够继续做出决策。（可结束性是存活性，liveness，而其他三个性质是安全性，safety，</p><p>可终止性受限于少于半数节点宕机或不可达的假设。然而，大多数共识算法的实现在大多数节点都宕机或者网络出现大范围故障时仍然能保持安全性——一致性，正直性和有效性。也即，大范围的节点下线可能会让系统<strong>不能继续处理请求</strong>，但<strong>不会因此破坏共识协议</strong>，让其做出不合法决策。</p><h4 id="4-3-1-全序广播中的共识算法"><a href="#4-3-1-全序广播中的共识算法" class="headerlink" title="4.3.1 全序广播中的共识算法"></a>4.3.1 全序广播中的共识算法</h4><p>全序广播等价于多轮次的共识协议（每个轮次，会使用共识协议对全序广播中的一条消息的全局顺序做出决策）：</p><p>由于共识协议的全局一致性，所有节点会以同样的顺序投递同样的消息。<br>由于正直性，具有同样 id 的消息不会重复。<br>由于有效性，消息不会是损坏的，也不会是凭空捏造的。<br>由于可终止性，消息不会丢失。</p><h4 id="4-3-2-单主复制和共识协议"><a href="#4-3-2-单主复制和共识协议" class="headerlink" title="4.3.2 单主复制和共识协议"></a>4.3.2 单主复制和共识协议</h4><p>核心点在于<strong>主节点（领导者）是怎样选出的</strong>。如果主节点由运维团队的管理员手动配置，你本质上就获得了一个“共识算法”的独裁变种：只有一个节点允许接受写入（决定复制日志中所有日志的顺序），并且一旦该主节点宕机，系统便会陷入不可用的状态，直到运维人员手动的配置另外一个节点为主节点。这样的系统在实践中也可以正常运作，但是并不满足共识算法中的可终止性，因为它在停顿后要求运维人员的干预，才能继续运转。</p><p>有些数据库在遇到主节点故障时，会自动地重新进行主选举，将一个从节点提升为新的主节点（参见<a href="https://ddia.qtmuniao.com/#/ch05?id=%e5%ae%95%e6%9c%ba%e5%a4%84%e7%90%86">宕机处理</a>）。这就让我们进一步逼近了可容错的全序广播，并且解决了共识问题。</p><h4 id="4-3-3-纪元编号和法定人数"><a href="#4-3-3-纪元编号和法定人数" class="headerlink" title="4.3.3 纪元编号和法定人数"></a>4.3.3 纪元编号和法定人数</h4><p>协议会定义一个<strong>纪元编号</strong>，且保证在每一个纪元（epoch）内，主节点是唯一的。</p><p>每次当前的主节点被认为下线时（可能是宕机，也可能只是网络不通），所有认为该主下线的节点就会发起选举，以选出新的主节点。每次选举会使用一个更高的纪元编号，因此所有的纪元编号是全序且单调递增的。如果不同纪元中有两个节点都认为自己是主（比如之前的主节点并没有宕机），则具有较高纪元编号的主节点胜出。</p><p>在一个主节点被授权做任何事之前，它必须要确认不会有更权威的主节点（具有更高的纪元编号）会做出不同决策</p><p>因此，主节点在决策前需要首先从所有节点获得法定票数（参见<a href="https://ddia.qtmuniao.com/#/ch05?id=quorum-%e8%af%bb%e5%86%99">Quorum 读写</a>）。对于每个决策，主节点都必须将其作为提案发给其他所有节点，并且等待法定节点的同意。法定节点通常来说，会包含多数派节点，但也不绝对（<a href="https://arxiv.org/abs/1608.06696">Flexible Paxos</a>介绍了一种不需要多数节点的放宽的 Paxos 算法）。如果法定节点的回复中没有任何更高纪元的，则当前主节点可以放心的认为没有发生新纪元的主选举，并可以据此认为他仍然“握有领导权”。从而，可以安全的对提案进行决策。</p><p>投票过程非常像两阶段提交提交算法。最大的区别在于：</p><ol><li>2PC 中的协调者不是被选出来的。</li><li>2PC 要求每一个参与者都回复“可以”，而可容错的共识算法只要求多数节点的投票。</li></ol><h4 id="4-3-4-共识算法的局限性"><a href="#4-3-4-共识算法的局限性" class="headerlink" title="4.3.4 共识算法的局限性"></a>4.3.4 共识算法的局限性</h4><p><strong>同步复制损失性能</strong>。每次进行决策（更改数据）前都要让多数节点进行投票，意味着这是一个同步复制系统。在<a href="https://ddia.qtmuniao.com/#/ch05?id=%e5%90%8c%e6%ad%a5%e5%a4%8d%e5%88%b6%e5%92%8c%e5%bc%82%e6%ad%a5%e5%a4%8d%e5%88%b6">同步复制和异步复制</a>一节中我们讲过，很多数据库都会配置为异步复制。在这种配置下，有些已经提交的数据在进行恢复时可能会丢失，但很多人仍然选择这种模式——承担这种风险，以换取更好的性能。</p><p><strong>多数派会增加系统冗余</strong>。共识系统总是要求有<strong>严格多数节点</strong>存活才能正常运行。这意味着，如果你要容忍单节点故障就至少需要三个节点（三节点中的两个节点可以组成多数派），如果要容忍两个节点故障就至少需要五个节点（五个节点中的三个节点组成多数派）。如果网络故障切断了其中一些节点和其他节点的联系，则只有连通的多数派节点可以正常运行，其他节点都会被阻塞。</p><p><strong>动态成员变更复杂</strong>。很多共识算法会假定有固定的数目节点参与投票，这意味着你不能往集群中增删节点。共识算法的<strong>动态成员变更</strong>（dynamic membership）扩展允许集群的节点集随时间推移而发生变动，但相对于静态成员算法，这种扩展版本非常难以理解。</p><p><strong>复杂网络环境性能很差</strong>。共识系统通常通过超时机制来对故障节点进行检测。在延迟高度变化的网络中，尤其是多地部署的分布式系统中，某些存活节点由于网络的瞬时抖动常被误认为发生了故障。尽管这些问题并不会破坏安全性，但频繁的领导者选举会导致极差的性能表现——系统可能会大部分时间都在选主而不是正常干活上。</p><p><strong>共识算法对网络故障非常敏感</strong>。</p><h3 id="4-4-成员关系和协调服务"><a href="#4-4-成员关系和协调服务" class="headerlink" title="4.4 成员关系和协调服务"></a>4.4 成员关系和协调服务</h3><p>Zookeeper 和 etcd 设计目标为<strong>存储小尺度的数据</strong>，比如能装进内存里的</p><p>这些系统使用可容错的全序广播算法，将小尺寸的数据被复制到所有节点上。如前所述，我们做数据库复制的时候真正需要的东西其实是全序广播：如果每条消息代表针对数据库的一个修改，以相同的顺序对所有副本应用相同的改动，能够将数据库保持在一致的状态。</p><p>Zookeeper 是模仿 Google 的 Chunk 锁服务实现的，不仅实现了全序广播算法（进而实现了共识），也实现了其他一些对分布式系统非常有用的功能集：</p><ul><li><strong>线性化的原子操作（lock）</strong> 使用原子的 CAS 操作，可以实现锁：如果多个节点并发执行同一个操作，只有一个会成功。共识协议能够保证，即使随时可能出现节点宕机或者网络故障，操作仍然是原子和线性化的。一个分布式锁通常实现为具有<strong>过期时间的“租约”</strong>（lease），这样即使客户端宕机，锁也能够被最终释放。</li><li><strong>操作的全序保证（zxid）</strong> 在<a href="https://ddia.qtmuniao.com/#/ch08?id=%e9%a2%86%e5%af%bc%e8%80%85%e5%92%8c%e9%94%81">领导者和锁</a>一节中我们讨论过，当某个资源被锁或者租约保护时，你需要<strong>防护令牌机制</strong>来防止由于进程停顿而造成的加锁冲突。防护令牌一个在每次获取锁都会单调自增的数值。Zookeeper 通过给每个操作赋予一个全局自增的事务 id（zxid）和一个版本号（cversion）来提供该功能。</li><li><strong>故障检测（ephemeral node）</strong> 客户端和 ZooKeeper 的服务器间维持着一个长会话，客户端和服务端通过周期性的心跳来检测对端是否仍然存活。即使该连接短暂断掉，或者 ZooKeeper 节点故障，该会话仍然能够存活。但如果，心跳停顿间隔过长，超过了会话的超时阈值，ZooKeeper 会标记该会话死亡。所有该会话关联的锁在超时都将会被释放（ZooKeeper 将其称为<strong>暂态节点</strong>，ephemeral nodes，这类节点可以将生命周期与会话进行绑定）。</li><li><strong>变动通知（watch）</strong> 客户端不仅可以读取其他节点创建的锁或者值，也可以直接对这些对象的变化进行<strong>守望</strong>（watch）。通过守望机制，客户端可以立即发现是否有其他客户端加入集群（通过这些客户端写入 ZooKeeper 的值）、其他客户端是否故障（通过这些客户端注册到 ZooKeeper 中的暂态节点的消失）。通过订阅这些通知，客户端可以避免频繁地去 ZooKeeper 拉取信息，比对以确定是否发生了某些变化。</li></ul><h4 id="4-4-1-为节点分配任务"><a href="#4-4-1-为节点分配任务" class="headerlink" title="4.4.1 为节点分配任务"></a>4.4.1 为节点分配任务</h4><p>ooKeeper 通常运行在固定节点的集群上（通常是三个或者五个），并且只须在这几个节点间达成共识，然后就可以支持非常多的客户端访问。这样，ZooKeeper 提供了一种可以将<strong>部分功能</strong>（共识算法、外包定序、故障检测）“<strong>外包</strong>”（outsouring）给外部服务的方法。</p><h4 id="4-4-2-服务发现"><a href="#4-4-2-服务发现" class="headerlink" title="4.4.2 服务发现"></a>4.4.2 服务发现</h4><p>即根据服务名称找到其对应的 IP 地址以进行连接。在数据中心的环境中，虚拟机的来来去去非常普遍，因此很难事先知道某个服务的 IP 地址。因此，你可以对服务进行配置，让其在启动的时候在<strong>某个服务</strong>（通常是名字服务器，nameserver）注册自己的地址和端口，其他人就能使用名字来找到该服务的最终地址。</p><h4 id="4-4-3-成员服务"><a href="#4-4-3-成员服务" class="headerlink" title="4.4.3 成员服务"></a>4.4.3 成员服务</h4><p>成员服务可以确定当前<strong>集群中哪些节点当前是存活的</strong>。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;共识&lt;/strong&gt;（consensus），即，&lt;em&gt;让所有节点在&lt;strong&gt;某件事情&lt;/strong&gt;上达成一致&lt;/em&gt;。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="阅读笔记" scheme="https://stardustorz.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DDIA" scheme="https://stardustorz.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/DDIA/"/>
    
    
    <category term="DDIA" scheme="https://stardustorz.github.io/tags/DDIA/"/>
    
  </entry>
  
  <entry>
    <title>[DDIA] 分布式系统中的麻烦事</title>
    <link href="https://stardustorz.github.io/2023/07/14/DDIA/07%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%BA%BB%E7%83%A6%E4%BA%8B/"/>
    <id>https://stardustorz.github.io/2023/07/14/DDIA/07%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%BA%BB%E7%83%A6%E4%BA%8B/</id>
    <published>2023-07-13T16:00:00.000Z</published>
    <updated>2025-03-09T16:09:55.419Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>是否要在目标场景下解决这些问题、还是为了降低系统复杂度忽略这些问题</p></blockquote><span id="more"></span><h2 id="1-故障和部分失败"><a href="#1-故障和部分失败" class="headerlink" title="1 故障和部分失败"></a>1 故障和部分失败</h2><p>单机系统通常具有一种很好地特性：<strong>要么正常运行、要么出错崩溃，而不会处于一种中间状态</strong>。</p><p><strong>部分失败</strong>（partial failure），即系统的一部分正常工作，另一部分却以某种诡异的方式出错。这些问题，多数都是由于连接不同主机的<strong>异步网络</strong>所引入的。</p><h3 id="1-1-云计算和超算"><a href="#1-1-云计算和超算" class="headerlink" title="1.1 云计算和超算"></a>1.1 云计算和超算</h3><ul><li>在线离线， 故障常态化，  容错</li><li>为了让分布式系统能够工作，就必须假设故障一定会存在，并在设计层面考虑各种出错处理。即，<strong>我们要基于不可靠的组件构建一个可靠系统</strong>。</li></ul><h3 id="1-2-基于不可靠组件构建可靠系统"><a href="#1-2-基于不可靠组件构建可靠系统" class="headerlink" title="1.2 基于不可靠组件构建可靠系统"></a>1.2 基于不可靠组件构建可靠系统</h3><ol><li>纠错码能够容忍信道中偶尔一两个比特的误传。</li><li>IP 层不可靠，但 TCP 层却基于 IP 层提供了相对可靠的传输保证。</li></ol><h2 id="2-不可靠的网络"><a href="#2-不可靠的网络" class="headerlink" title="2 不可靠的网络"></a>2 不可靠的网络</h2><p><strong>所有机器不共享资源（如内存、磁盘），通信的唯一途径就是网络</strong>。<br>互联网和数据中心（多是以太网）的内部网络多是<strong>异步封包网络</strong>（<strong>asynchronous packet networks</strong>）。</p><ol><li>请求没有发出去就丢了（比如你的网线可能被拔了）</li><li>请求可能先排了会队，稍后才被发出去（比如网络或接收方负载过高）</li><li>对端节点挂了（比如遇到异常宕机或者断电了）</li><li>对端节点临时无响应（比如正在进行 GC），但稍后又能正常工作</li><li>对端节点处理了你的请求，但应答在网络回程中丢了（比如网关配错了）</li><li>对端节点处理了你的请求，但应答被推迟了（比如网络或你的机器负载过高）</li></ol><p>在异步网络中，当你发送出一个请求，并在一段时间内没有收到应答，任何事情都有可能发生：由于没有收到任何信息，你无从得知具体原因是什么。甚至，你都不知道你的请求是否已被送达处理。</p><p>应对这种情况的惯常做法是——<strong>超时</strong>（timeout）。即，设定一个时限，到点后，我们便认为这个请求废了。但在实际上，该请求可能只是还在排队、可能稍后到到达远端节点、甚至可能最终还会收到应答。</p><h3 id="2-1-故障检测"><a href="#2-1-故障检测" class="headerlink" title="2.1 故障检测"></a>2.1 故障检测</h3><p><strong>自动检测故障节点</strong>，并据此做出一些决策：</p><ul><li>负载均衡器需要停止对故障节点流量的分发。</li><li>在单主模型的分布式数据库中，如果主节点故障，需要选出一个从节点顶上。</li></ul><ul><li><strong>操作系统通知</strong>。如果你能触达<strong>服务</strong>所在<strong>机器</strong>，但发现没有进程在监听预期端口（比如对应服务进程挂了），操作系统会通过发送 RST 或 FIN 包来关闭 TCP 连接。但是如果对端节点在处理你的请求时整个宕机了，就很难得知你请求的具体处理进度。</li><li><strong>daemon 脚本通知</strong>。可以通过一些 daemon <strong>脚本</strong>，在本机服务进程死掉之后，主动通知其他节点。来避免其他节点通过发送请求超时来判断此节点宕机。当然这前提是，服务进程挂了，但所在节点没挂。</li><li><strong>数据链路层面</strong>。如果你是管理员，并且能访问到你数据中心的网络交换机，可以在数据链路层判断远端机器是否宕机。当然如果你访问不到交换机，那这种方法就不太行。</li><li><strong>IP 不可达</strong>。如果路由器发现你要发送请求的 IP 地址不可达，它会直接回你一个 ICMP 不可达包。但路由器也并不能真正判断是否该机器不可用了。</li></ul><p>设置一个<strong>合理的超时时限</strong>和重试次数。直到，你确认没有再重试的必要——即不管远端节点是否存活，我在重试几次后，都认为它不可用了（或者暂时不可用）。</p><h3 id="2-2-超时和无界延迟（unbounded-delays）"><a href="#2-2-超时和无界延迟（unbounded-delays）" class="headerlink" title="2.2 超时和无界延迟（unbounded delays）"></a>2.2 超时和无界延迟（unbounded delays）</h3><p><strong>超时间隔</strong>要设置多久呢？总的来说：</p><ol><li>不能太长：过长会浪费很多时间在等待上。</li><li>不能太短：太短会造成误判，误将网络抖动也视为远端节点失败。</li></ol><p>设有一个理想的网络系统，能够保证所有的网络<strong>通信延迟不超过 d</strong>：所有的网络包要么在 d 时间内送达对端、要么就会丢失，即不可能在超过 d 的时限后才到。如果网络能提供此种保证，则应用层可大为简化：假设我们预估出单个请求最大处理时间 r，则 2d+r 是一个很好超时间隔。</p><h4 id="2-2-1-网络拥塞和数据包排队"><a href="#2-2-1-网络拥塞和数据包排队" class="headerlink" title="2.2.1 网络拥塞和数据包排队"></a>2.2.1 网络拥塞和数据包排队</h4><p><strong>网络流量越满，单个请求延迟抖动越大</strong>。</p><h4 id="2-2-2-同步网络和异步网络"><a href="#2-2-2-同步网络和异步网络" class="headerlink" title="2.2.2 同步网络和异步网络"></a>2.2.2 同步网络和异步网络</h4><p>固话网会为每一次通话预留<strong>稳定低延迟</strong>和<strong>充足的带宽</strong>链路以传输语音。</p><h2 id="3-不可靠的时钟"><a href="#3-不可靠的时钟" class="headerlink" title="3 不可靠的时钟"></a>3 不可靠的时钟</h2><p>实践中，常通过 <strong>NTP</strong>（网络时间协议）对机器进行自动校准。其大致原理是，首先使用更精确时钟（如 GPS 接收器）构建一组<strong>可信服务器</strong>作为时钟源（比如阿里云的源），</p><h3 id="3-1-单调时钟"><a href="#3-1-单调时钟" class="headerlink" title="3.1 单调时钟"></a>3.1 单调时钟</h3><p>单调时钟主用于取两个时间点的<strong>差值</strong>来测量时间间隔，如服务器的超时间隔和响应时间。</p><h3 id="3-2-时间戳以定序"><a href="#3-2-时间戳以定序" class="headerlink" title="3.2 时间戳以定序"></a>3.2 时间戳以定序</h3><ol><li><strong>写入谜之丢失</strong>。一个具有落后时钟的节点产生的写入数据，无法覆盖一个具有超前时钟节点先前写入的数据，造成后写入的数据反而被没有任何提醒的丢弃。</li><li><strong>无法区分先后和并行</strong>。两者主要区别在于，一个是有明显的依赖关系，如上图中自增依赖于之前的初始化；另一个是相关的几个操作互相并不关心。为了解决这个问题，需要引入额外的时间戳机制进行因果关系追踪，如 version vector（一种逻辑时钟）。</li><li><strong>两个独立节点可能会产生相同时间戳的事件</strong>。尤其是在时钟精读不太够的情况下（比如最低只能给到毫秒），可以使用额外的随机数来对其进一步区分，但这样也会导致一些时间上的因果问题。</li></ol><h3 id="3-3-进程停顿"><a href="#3-3-进程停顿" class="headerlink" title="3.3 进程停顿"></a>3.3 进程停顿</h3><p>分布式系统中的节点可能在<strong>任意时刻</strong>的<strong>任意代码位置</strong>停顿<strong>任何时长</strong>，而在此间，系统的其他节点仍在正常往前执行，甚至由于该节点不响应而将其标记为死亡。最终，该停顿节点可能会继续执行</p><p>有一些手段可以用来减轻进程停顿现象，且不必借助代价高昂的强实时系统。比如<strong>垃圾回收器</strong>（GC 进程）可以实时追踪<strong>对象分配速率</strong>和剩余<strong>可利用内存</strong>，利用这些信息，GC 进程可以给应用程序提供一些信号。然后我们在构造系统时捕获这些信号，然后拒绝服务一段时间，等待 GC 结束。就跟临时故障或者下线的节点一样，别的节点会来接管请求。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;是否要在目标场景下解决这些问题、还是为了降低系统复杂度忽略这些问题&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="阅读笔记" scheme="https://stardustorz.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DDIA" scheme="https://stardustorz.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/DDIA/"/>
    
    
    <category term="DDIA" scheme="https://stardustorz.github.io/tags/DDIA/"/>
    
  </entry>
  
  <entry>
    <title>[DDIA] 事务</title>
    <link href="https://stardustorz.github.io/2023/06/20/DDIA/06%20%E4%BA%8B%E5%8A%A1/"/>
    <id>https://stardustorz.github.io/2023/06/20/DDIA/06%20%E4%BA%8B%E5%8A%A1/</id>
    <published>2023-06-19T16:00:00.000Z</published>
    <updated>2025-03-09T16:09:51.422Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>从<strong>时间</strong>和<strong>空间</strong>两个角度来理解事务，从生命周期（时间）来讲，事务要保证一组操作的整体性；从并发控制（空间），事务要做好多个事务间的并发控制。</p></blockquote><span id="more"></span><p>在分布式数据系统中，任何问题都有可能发生：</p><ol><li>系统侧：数据库系统和硬件系统任何时间都有可能发生故障</li><li>应用侧：使用数据库的应用程序任何时刻都有可能故障。</li><li>网络侧：应用程序和数据库间，数据库的多个节点间，随时都有可能断开连接。</li><li>多个客户端：并发写入时，可能会有竞态条件和相互覆盖。</li><li>半读：一个客户端可能会读到部分更新的数据库。</li></ol><p><strong>事务</strong>，就是数据库为了解决类似的问题，所提供的一种保证，以<strong>简化应用层的编程模型</strong>。</p><p><strong>事务</strong>就是将一组语句（或者说操作）打包成一个逻辑单元进行执行，并提供一种保证，这一组操作要么全部成功（ <strong>commit</strong>，应用到数据库里），要么全部失败（被动 <strong>abort</strong>，或者主动 <strong>rollback</strong>），而不会存在只执行了一半的中间状态。此外，如果多个客户端的事务并发执行，会涉及到隔离性的问题，一般来说，数据库允许用户在隔离级别和性能之间做选择。</p><p>用户在发现事务失败后，可以放心的进行重试，直到成功，就可以确定事务中的所有操作都生效了。但任何便利性都是有代价的，事务便是在一定程度上牺牲了性能和可用性。</p><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><h3 id="1-1-ACID"><a href="#1-1-ACID" class="headerlink" title="1.1 ACID"></a>1.1 ACID</h3><p>Atomicity、Consistency、Isolation 和 Durability</p><h4 id="1-1-1-原子性"><a href="#1-1-1-原子性" class="headerlink" title="1.1.1 原子性"></a>1.1.1 原子性</h4><p>原子性所提供的保证是：<strong>在发生错误时，会回滚该事务所有已经写入的变更</strong>。</p><h4 id="1-1-2-一致性"><a href="#1-1-2-一致性" class="headerlink" title="1.1.2 一致性"></a>1.1.2 一致性</h4><p>一致性是对某些<strong>不变性（invariants）</strong> 的维持，所谓不变性，即某些约束条件。如，在银行账户中，在任何时刻，账户余额须等于收入减去支出。</p><p>不同于 ACID 中其他性质，一致性是需要<strong>应用侧</strong>和<strong>数据库侧</strong>共同维护的：</p><ol><li>应用侧需要写入满足应用侧视角约束要求的数据。</li><li>数据库侧需要保证多次写入前后，尤其是遇到问题时，维持该约束。<h4 id="1-1-3-隔离性"><a href="#1-1-3-隔离性" class="headerlink" title="1.1.3 隔离性"></a>1.1.3 隔离性</h4>每个事务的执行是互相隔离的，每个事务都可以认为自己是系统中唯一正在运行的事务，因此传统上，教科书将事务隔离形式称为：<strong>可串行化（Serializability）</strong>。即，如果所有事务都串行执行，则任意时刻必然只有一个事务在执行，从而在根本上消除任何并发问题。<h4 id="1-1-4-持久性"><a href="#1-1-4-持久性" class="headerlink" title="1.1.4 持久性"></a>1.1.4 持久性</h4>持久性是一种保证，即事务一旦提交，即使服务器宕机重启、甚至发生硬件故障，已经提交的事务所写入的数据就不会丢失。</li></ol><p><strong>持久性</strong>都只能做到某种程度的保证，而非绝对保证，比如：</p><ol><li>对于单机，可以容忍宕机。但磁盘坏了就完犊子。</li><li>对于多机，可以容忍少数副本损坏，但是多数副本完后也没辙。</li></ol><h3 id="1-2-单对象和多对象操作"><a href="#1-2-单对象和多对象操作" class="headerlink" title="1.2 单对象和多对象操作"></a>1.2 单对象和多对象操作</h3><p>对象事务中，一个关键点是如何确定多个操作是否属于同一事务：</p><ol><li>从<strong>物理上来考虑</strong>。可以通过 TCP 连接来确定，在同一个连接中，<code>BEGIN TRANSACTION</code> 和  <code>COMMIT</code>语句之间的所有内容，可以认为属于同一个事务。但会有一些 corner case，如在客户端提交请求后，服务器确认提交之前，网络中断，连接断开，此时客户端则无从得知事务是否被成功提交。</li><li><strong>从逻辑上来考虑</strong>。使用事务管理器，为每个事务分配一个唯一标识符，从而对操作进行分组。</li></ol><p>实际中基本上使用第二种方法。</p><h4 id="1-2-1-单对象写入"><a href="#1-2-1-单对象写入" class="headerlink" title="1.2.1 单对象写入"></a>1.2.1 单对象写入</h4><p>当只更改单个对象时，仍会面临原子性和隔离性的问题<br>一般的数据库哪怕不支持完整的事务，也会提供针对单个对象的原子性和隔离性。比如，可以使用写前日志来保证原子性，使用锁来保证隔离性。</p><p>其他一些数据库，也会提供更复杂的原子支持，如原子的自增操作，从而避免交错更新。另一种更泛化的原子性保证是提供单个对象上的 CAS 操作，允许用户原子的执行针对单个对象的 read-modify-write 操作。当然，如果咬文嚼字一下，<strong>原子自增</strong>（atomic increment），在 ACID 中应该是属于隔离性（Isolation）的范畴，此处的原子自增其实是多线程的概念。</p><h4 id="1-2-2-界定对多对象事务的需求"><a href="#1-2-2-界定对多对象事务的需求" class="headerlink" title="1.2.2 界定对多对象事务的需求"></a>1.2.2 界定对多对象事务的需求</h4><p>跨机器的分布式事务很难实现、且非常损失性能（可能在一个数量级），很多分布式数据库选择不支持多对象事务。但有些场景确实需要多对象事务，因此一些数据库多将是否打开事务设为一个开关。</p><p>需要协同更新多个对象：</p><ol><li>在关系型数据库中，一些表通常会有一些外键。在更新时，需要进行同步更新。</li><li>在文档型数据库中，相关的数据通常会放到一个文档中，但由于大部分文档数据库不支持 Join，因此不得不使用前文提到的 denormalization 对信息进行冗余存储，便产生了同步更新需求。</li><li>在支持次级索引的数据库中，数据和对应的多个索引需要进行同步更新。</li></ol><h4 id="1-2-3-故障和终止"><a href="#1-2-3-故障和终止" class="headerlink" title="1.2.3 故障和终止"></a>1.2.3 故障和终止</h4><p>事务的一个重要特点是在执行到一半时，可以安全的终止并重试。事务的设计哲学是：当出现违反原子性、隔离性和持久性的危险时，就<strong>丢弃而非保留</strong>已经发生的修改。</p><p>另一些场景，如多副本中的无主模型，就采用了“<strong>尽力而为</strong>”的模型，即尽可能的保证完成任务，如不能完成，也不会回滚已经发生的修改。因此，应用侧需要处理这种半完成的状态。</p><ol><li>事务已经被成功提交，但返回给用户时出错。用户如果简单重试，就会使该事务中的操作执行两次，从而造成数据冗余，除非用户在应用代码侧进行去重（如多次执行这些语句，效果一样）。</li><li>由于系统负载过高，而造成事务执行失败。如果无脑重试，会进一步加重系统负担。此时可以使用指数后退方式重试，并且限制最大重试次数。</li><li>一些临时错误，如死锁、异常、网络抖动和故障切换时，重试才有效；对于一些永久故障，重试是没有意义的。</li><li>某事务在数据库之外如有副作用，重试事务时，会造成副作用的多次发生。如果某个事务的副作用是发送邮件，则肯定不希望事务每次重试时都发送一次电子邮件。如果想进行多个系统间的协同，可以考虑两阶段提交。</li><li>如果客户端在写入数据时故障，则所有该客户端正在执行的事务所涉及的数据修改都会丢失。</li></ol><h2 id="2-几种弱隔离级别"><a href="#2-几种弱隔离级别" class="headerlink" title="2 几种弱隔离级别"></a>2 几种弱隔离级别</h2><p>数据库试图通过<strong>事务隔离</strong>（transaction isolation）来给用户提供一种隔离保证，从而降低应用侧的编程复杂度。</p><p>最强的隔离性——可串行化，可以理解为全局一把大排它锁，每个事务在启动时获取，在提交、回滚或终止时释放，但无疑这种隔离级别性能最差。而其他几种弱隔离级别，可以理解为是为了提高性能，缩小了加锁的粒度、减小了加锁的时间，从而牺牲部分一致性换取性能。从上锁的强弱考虑，我们有<strong>互斥锁</strong>（Mutex Lock，又称写锁）和<strong>共享锁</strong>（Shared Lock，又称读锁）；从上锁的长短来考虑，我们有<strong>长时锁</strong>（Long Period Lock，事务开始获取锁，到事务结束时释放）和<strong>短时锁</strong>（Short Period Lock，访问时获取，用完旋即释放）；从上锁的粗细来考虑，我们有对象锁（Row Lock，锁一行）和谓词锁（Predicate Lock，锁一个范围）。</p><p>但这没有覆盖到到另一个常见的隔离级别——<strong>快照隔离</strong>（Snapshot Isolation），因为它引出了另一种实现族——MVCC。由于属于不同的实现，快照隔离和可重复读在隔离级别的光谱上属于一个偏序关系，不能说谁强于谁。</p><h3 id="2-1-读已提交"><a href="#2-1-读已提交" class="headerlink" title="2.1 读已提交"></a>2.1 读已提交</h3><p>性能最好的隔离级别就是不上任何锁，但会存在<strong>脏读</strong>和<strong>脏写</strong>的问题。为了避免脏写，可以给要更改的对象加长时写锁，但读数据时并不加锁，此时的隔离级别称为<strong>读未提交</strong>（RU，Read Uncommitted）。但此时仍然会有脏读，为了避免脏读，可以对要读取的对象加<strong>短时读锁</strong>，此时的隔离级别是<strong>读已提交</strong>（RC，Read Committed），他提供了两个保证：</p><ol><li>从数据库读取时，只能读到已经提交的数据（即没有脏读，no dirty reads）</li><li>往数据库写入时，只能覆盖已经提交的数据（即没有脏写，no dirty writes）</li></ol><h3 id="2-2-快照隔离和重复读"><a href="#2-2-快照隔离和重复读" class="headerlink" title="2.2 快照隔离和重复读"></a>2.2 快照隔离和重复读</h3><p>Alice 分两个账户，各存了 500 块钱，但如果其两次分别查看两个账户期间，发生了一笔转账交易，则两次查看的余额加起来并不等于 1000。<br><strong>同一个操作期间，两次读取到的数据不一致。</strong> 也就是在事务a执行中，事务b修改了数据并提交了</p><p>这种异常被称为<strong>不可重复读</strong>（non-repeatable read）或者<strong>读倾斜</strong>（read skew）。读已提交的隔离级别允许出现不可重复读问题，如上述例子，每次读取到的都是已提交的内容。</p><p>在某些情况下，这种暂时的不一致也是不可接受的：</p><ol><li><strong>备份</strong>。备份可能需要花费很长时间，而备份过程中可能会有读写存在，从而造成备份时的不一致。如果之后再利用此备份进行恢复，则会造成永久的不一致。</li><li><strong>分析型查询和完整性检查</strong>。这个操作和备份一样，耗时都会比较长，如果中间有其他事务并发导致出现不一致的现象，就会导致返回的结果有问题。</li><li><strong>快照隔离</strong>（snapshot isolation）级别能够解决上述问题，使用此级别，每个事务都可以取得一个某个时间点的<strong>一致性快照</strong>（consistent snapshot），在整个事务期间，读到的状态都是该时间点的快照。其他事务的修改并不会影响到该快照上。</li></ol><h4 id="2-2-1-快照隔离的实现"><a href="#2-2-1-快照隔离的实现" class="headerlink" title="2.2.1 快照隔离的实现"></a>2.2.1 快照隔离的实现</h4><p>快照隔离也使用加锁的方式来防止脏写，但在进行读取不使用锁。快照隔离的一个关键原则是“读不阻塞写，写不阻塞读”，从而允许用户在进行长时间查询时，不影响新的写入。</p><p>为了实现快照隔离，保证读不阻塞写，且避免脏读，数据库需要对同一个对象保留多个已提交的版本，我们称之为<strong>多版本并发控制</strong>（<strong>MVCC，multi-version concurrency control</strong>）。</p><ol><li><strong>读已提交</strong>在查询语句粒度使用单独的快照，快照粒度更小，因此性能更好。</li><li><strong>快照隔离</strong>在事务粒度使用相同的快照（主要解决<strong>不可重复读</strong>问题）。</li></ol><p><strong>MVCC 的基本要点为：</strong></p><ol><li>每个事务开始时会获取一个自增的、唯一的事务 ID（txid），该 txid = max(existing tx id) + 1。</li><li>该事务在修改数据时，不会修改以前版本，而会新增一个具有 txid 版本的数据。</li><li>该事务只能访问到所有版本 ≤ txid 的数据。</li><li>在写入时，如果发现某个数据存在 &gt; txid 的版本，则存在写写冲突。</li></ol><h4 id="2-2-2-可见性规则"><a href="#2-2-2-可见性规则" class="headerlink" title="2.2.2 可见性规则"></a>2.2.2 可见性规则</h4><p>在事务中进行读取时，对于每个对象来说，需要<strong>控制</strong>其版本对事务的可见性，以保证该事务能够看到一致性的视图。</p><ol><li>事务开始时，所有正在进行（已经开始但未提交或中止）的事务，所做的任何写入都会被忽略。</li><li>被中止的事务，所做的任何写入都会被忽略。</li><li>具有较晚事务 ID 的事务所做的任何写入都会被忽略。</li><li>剩余其他的数据，对此事务都可见。</li></ol><h3 id="2-3-索引和快照隔离"><a href="#2-3-索引和快照隔离" class="headerlink" title="2.3 索引和快照隔离"></a>2.3 索引和快照隔离</h3><p>当数据有多个版本时，如何给数据建立索引？一个简单的方法是将索引指向对象的所有版本，然后在查询时使用再进行版本过滤。当某个对象的所有版本对任何事务都不再可见时，相应的索引条目也可以被同时删除。</p><h3 id="2-4-防止更新丢失"><a href="#2-4-防止更新丢失" class="headerlink" title="2.4 防止更新丢失"></a>2.4 防止更新丢失</h3><p>更新丢失发生的关键在于，两个事务中都有读后写序列（读取 - 修改 - 写入序列，写偏序也是这个序列，但是针对多个对象），即<strong>写依赖于之前的读</strong>。如果读到的内容被其他事务修改，则本事务稍后的依赖于此读的写就会发生问题。如：</p><ol><li>并发更新计数器和账户余额。</li><li>复合值的并发修改（如 json 文档中的列表字段，需要先读出，加一个字段后写回）。</li><li>两个用户同时修改 wiki 页面，并且都是修改后将页面完整覆写回。<h4 id="2-4-1-原子写"><a href="#2-4-1-原子写" class="headerlink" title="2.4.1 原子写"></a>2.4.1 原子写</h4>有些数据库提供原子的（<strong>针对单个对象的</strong>）read-modify-write 操作，因此，如果应用层逻辑能用这个原子操作表达，就可以避免更新丢失。<br>原子操作的通常实现方式为，在读取某对象时，获取其互斥锁，从而阻止其他事务读取该对象。</li></ol><h4 id="2-4-2-显式上锁"><a href="#2-4-2-显式上锁" class="headerlink" title="2.4.2 显式上锁"></a>2.4.2 显式上锁</h4><p>应用在有针对单个对象的 read-modify-write 序列时，将是否上锁的决策交给应用层</p><h4 id="2-4-3-自动检测更新丢失"><a href="#2-4-3-自动检测更新丢失" class="headerlink" title="2.4.3 自动检测更新丢失"></a>2.4.3 自动检测更新丢失</h4><p>使用<strong>乐观</strong>方式，允许其并发执行，检测到更新丢失后进行重试。</p><h4 id="2-4-4-Compare-and-set"><a href="#2-4-4-Compare-and-set" class="headerlink" title="2.4.4 Compare-and-set"></a>2.4.4 Compare-and-set</h4><p>使用 CAS 操作也能避免更新丢失，保证 read-modify-write 的原子性。<br>仅当发现内容没有被修改时，才写会修改后的内容。</p><h4 id="2-4-5-多副本和冲突解决"><a href="#2-4-5-多副本和冲突解决" class="headerlink" title="2.4.5 多副本和冲突解决"></a>2.4.5 多副本和冲突解决</h4><p>在多副本数据库中，解决更新丢失问题会更难一些，尤其如果多个副本允许并发写入。<br>可以允许并发写入和异步更新，如果有冲突就用多版本来解决，最后使用用户代码或者特殊数据结构来合并冲突。</p><h3 id="2-5-写偏序和幻读"><a href="#2-5-写偏序和幻读" class="headerlink" title="2.5 写偏序和幻读"></a>2.5 写偏序和幻读</h3><p>假定数据库运行在快照隔离级别下，Alice 和 Bob 同时查询了今天值班情况，发现有多于一人值班，然后先后提交了休假申请，并且都通过了。这并没有违反快照隔离级别，但确实造成了问题——今天没有人值班了。</p><h4 id="2-5-1-写偏序的特点"><a href="#2-5-1-写偏序的特点" class="headerlink" title="2.5.1 写偏序的特点"></a>2.5.1 写偏序的特点</h4><p>写偏序可以算作是更新丢失的一种泛化。写偏序本质也是 read-modify-write，虽然是涉及多个对象，但本质仍然是<strong>一个事务的写入会导致另外一个事务读取到的信息失效</strong>。<br>写偏序是由 MVCC 实现的快照隔离级别的特有的缺陷，它是由于读依赖同一个不变的快照引起的。</p><p>如果没有办法使用可串行的化的隔离级别，还可以利用数据库提供的（for update）机制进行显式的加锁。</p><h4 id="2-5-2-幻读导致写偏序"><a href="#2-5-2-幻读导致写偏序" class="headerlink" title="2.5.2 幻读导致写偏序"></a>2.5.2 幻读导致写偏序</h4><p>都可以归纳为以下模式：</p><ol><li>通过 select 语句 + 条件过滤出符合条件的所有行。</li><li>依赖上述结果，应用侧代码决定是否继续。</li><li>如果应用侧决定继续，就执行更改（插入、更新或者删除），并提交事务。<br>步骤 3 会导致另一个事务的步骤 1 失效，即如果另一个事务此时重新执行 1 的 select 查询，会得到不同的结果，进而影响步骤 2 是否继续的决策。</li></ol><h4 id="2-5-3-物化冲突"><a href="#2-5-3-物化冲突" class="headerlink" title="2.5.3 物化冲突"></a>2.5.3 物化冲突</h4><p>将幻读转化为数据库物理中实实在在的表和行。但如何对冲突进行合理的物化，很难且易出错。并且，此方法会将解决冲突的细节暴露给了应用层（因为应用层需要感知物化出来的表）。因此，这是最不得以的一种方法，如果数据库本就支持可串行化，则大多数情况下，可以直接使用可串行隔离级别。</p><h2 id="3-可串行化"><a href="#3-可串行化" class="headerlink" title="3 可串行化"></a>3 可串行化</h2><p>可串行化当前主要实现方法：</p><ol><li>物理上真正的对所有事务进行串行的执行。</li><li><strong>两阶段锁</strong>（2PL，two-phase locking），曾经几十年中唯一的可用选项。</li><li><strong>乐观并发控制</strong>（OCC，Optimistic concurrency control），如可串行化的快照隔离。</li></ol><h3 id="3-1-物理上串行"><a href="#3-1-物理上串行" class="headerlink" title="3.1 物理上串行"></a>3.1 物理上串行</h3><p>将所有事务串行的执行</p><h3 id="3-2-将事务封装成存储过程"><a href="#3-2-将事务封装成存储过程" class="headerlink" title="3.2 将事务封装成存储过程"></a>3.2 将事务封装成存储过程</h3><p>线程串行事务系统不允许交互式的多语句事务。用户需要将多语句封装为存储过程一次性提交给数据库。如果数据都在内存中，则存储过程可以被快速的执行。</p><h4 id="3-2-1-存储过程的优缺点"><a href="#3-2-1-存储过程的优缺点" class="headerlink" title="3.2.1 存储过程的优缺点"></a>3.2.1 存储过程的优缺点</h4><p>对于内存数据库的单线程事务，使用存储过程可以获得不错的吞吐：</p><ol><li>内存数据库和存储过程避免了 IO</li><li>单线程避免了锁开销</li></ol><h4 id="3-2-2-对数据进行分区"><a href="#3-2-2-对数据进行分区" class="headerlink" title="3.2.2 对数据进行分区"></a>3.2.2 对数据进行分区</h4><h3 id="3-3-两阶段锁"><a href="#3-3-两阶段锁" class="headerlink" title="3.3 两阶段锁"></a>3.3 两阶段锁</h3><p>两阶段锁，其实就是将使用锁的过程分为两个阶段，通常称为<strong>扩张阶段</strong>和<strong>收缩阶段</strong>。在扩张阶段（事务的整个执行过程），只会申请锁，在收缩阶段（事务提交时），只会释放锁。从另一个角度理解，每个事务都是访问数据库的一个数据对象子集，扩张阶段就是逐渐拿到该子集所有相关对象的所有权，收缩阶段就是将持有对象所有权释放。而 <strong>S2PL</strong>（Strict 2PL），是在 2PL 的基础上，将写锁保持到事务结束； <strong>SS2PL</strong>（Strong 2PL 或 Strong Strict 2PL）是将读写锁都保持到事务结束。</p><ol><li>如果所有事务都没有写入，允许多事务并发读取一个对象。</li><li>只要任何一个事务有写入，就会将其<strong>独占</strong>到事务<strong>结束</strong>，不允许其他任何事务<strong>读或写</strong>。</li></ol><p>2PL 不允许读写并发、写写并发，而快照隔离却正好相反，即读写互相不阻塞。另一方面，2PL 通过阻止读写并发，可以避免<strong>更新丢失</strong>和<strong>写偏序</strong>等并发问题。</p><h4 id="3-3-1-实现"><a href="#3-3-1-实现" class="headerlink" title="3.3.1 实现"></a>3.3.1 实现</h4><p>通过对每个对象进行加锁，可以实现单个对象的读写互斥。锁可以处于<strong>共享模式</strong>（shared mode）或者<strong>互斥模式</strong>（exclusive mode），具体来说：</p><ol><li>如果某个事务想<strong>读取</strong>一个对象，需要首先获取该对象的<strong>共享锁</strong>。多个事务可以同时获取同一个对象的共享锁。但若某个事务持有该对象的互斥锁，则所有需要读写该对象的事务都得等待。</li><li>如果某个事务想<strong>写入</strong>一个对象，需要首先获取该对象的<strong>互斥锁</strong>。任何其他事务都不能同时持有该对象的任何种类的锁。因此，如果该对象上已经有锁，该事务必须先等待其释放。</li><li>如果某个事务要先<strong>读取</strong>，再<strong>写入</strong>某个对象，可以先获取其共享锁，然后将其升级为互斥锁。升级互斥锁和获取互斥锁的条件相同。</li><li>当某个事务获取锁之后，必须<strong>持有</strong>到事务结束（中止或者提交）。这也是上面两阶段定义的由来。</li></ol><p>由于每个对象都要上锁，而一个事务通常会访问多个对象，因此很可能造成<strong>死锁</strong>：多个事务持有锁，并且互相等待对方的锁。</p><h4 id="3-3-2-两阶段锁的性能"><a href="#3-3-2-两阶段锁的性能" class="headerlink" title="3.3.2 两阶段锁的性能"></a>3.3.2 两阶段锁的性能</h4><p>两阶段锁的实现下，事务的吞吐要比其他弱隔离级别低的多。维护大量锁的开销是一个原因，更重要的原因是<strong>并发性</strong>的降低。<br><strong>死锁更加频繁</strong>。尽管基于锁实现的<strong>读已提交</strong>隔离级别会发生死锁，但其发生频次远不如基于 2PL 实现的<strong>可串行化</strong>隔离级别。这也会造成额外的性能问题：死锁被检测到，会引发重试；如果死锁频繁，则会浪费巨大的性能。</p><h4 id="3-3-3-谓词锁"><a href="#3-3-3-谓词锁" class="headerlink" title="3.3.3 谓词锁"></a>3.3.3 谓词锁</h4><p>和共享锁类似，只不过粒度更大一些。</p><ol><li>当某个事务需要读取匹配条件的所有对象时，需要获得该查询条件的<strong>共享谓词锁</strong>。如果有任何其他事务持有该范围内对象的互斥锁，则该事务需要等待其结束。</li><li>当某个事务想要写入（插入、更新或者删除）某个对象时，上互斥锁前，需要检查是否有其他事务持有包含该对象的谓词锁。如果有，则该事务需要等待其结束。</li></ol><p>谓词锁的一个关键点是，可以锁住一个对象集合，该对象集中的对象甚至不必已存在，但将来可能会被添加。通过谓词锁，2PL 可以解决幻读问题。</p><h4 id="3-3-4-索引范围锁"><a href="#3-3-4-索引范围锁" class="headerlink" title="3.3.4 索引范围锁"></a>3.3.4 索引范围锁</h4><p>大多数 2PL 的数据库使用了谓词锁的一个近似——<strong>索引范围锁</strong>（index-range locking，也称为 next-key locking）。<br>通过适当<strong>放大锁住的对象集</strong>来简化谓词锁。如当有多个条件进行<strong>与</strong>的时候，只锁一个条件。<br>只锁定单个条件的好处在于，你可能在该条件上有索引。则可以将谓词锁，转化为一个在该索引上的范围锁、甚至单个索引对象锁。相比谓词锁，可以更快的判断冲突<br>这种方式也可以避免幻读和写偏序。相比谓词锁，索引范围锁虽然锁住的范围大，但实现开销较低。但谓词相关的索引并不总是能找到，此时可以简单的退化成整张表上的共享锁。这样做虽然有损性能，但是实现简单且安全。</p><h3 id="3-4-可串行的快照隔离"><a href="#3-4-可串行的快照隔离" class="headerlink" title="3.4 可串行的快照隔离"></a>3.4 可串行的快照隔离</h3><p>数据库中隔离级别的图景：</p><ol><li>在光谱一侧，我们有很好的隔离级别——可串行化，但其实现要么性能差（两阶段锁），要么不可扩展（物理上串行执行）。</li><li>在光谱另一个侧，我们有一些相对较弱的隔离级别，它们性能较好，但会有各种竞态条件（更新丢失、写偏序、幻读等等）。</li></ol><h4 id="3-4-1-乐悲观并发控制"><a href="#3-4-1-乐悲观并发控制" class="headerlink" title="3.4.1 乐悲观并发控制"></a>3.4.1 乐悲观并发控制</h4><p>SSI 是一种<strong>乐观</strong>（<em>optimistic</em>）的并发控制机制，类比多线程编程中的乐观锁。其相应哲学是，当存在潜在危险时，仍然不做任何检查去大胆的执行。当事务提交时，再进行冲突检测，如果存在冲突，则回退重试。</p><h4 id="3-4-2-基于失效前提的决策"><a href="#3-4-2-基于失效前提的决策" class="headerlink" title="3.4.2 基于失效前提的决策"></a>3.4.2 基于失效前提的决策</h4><p><strong>读取 - 决策 - 写入</strong>。</p><ol><li>读取：事务首先从数据库中读取到一些数据。</li><li>决策：考察读到的数据，做出某种决策。</li><li>写入：将对应决策造成结果写回数据库。</li></ol><p>如何检测前提是否失效</p><ol><li>在读取时，要检测读到的数据版本是否为最新版本。（读之前，可能有未提交的写入）</li><li>在写入时，要检测写入的数据是否覆盖了其他事务的读取。（读之后，可能发生了写入）</li></ol><h4 id="3-4-3-MVCC-读取的过时检测"><a href="#3-4-3-MVCC-读取的过时检测" class="headerlink" title="3.4.3 MVCC 读取的过时检测"></a>3.4.3 MVCC 读取的过时检测</h4><p>快照隔离通常通过<strong>多版本并发控制</strong>（MVCC）来实现。当事务基于 MVCC 数据库中的某个一致性的快照进行读取时，会忽略其他事务潜在的任何修写入。</p><p><strong>读取时，检测写读冲突，延到提交时，看有冲突的写入是否已提交</strong>。</p><h4 id="3-4-4-影响之前读取的写入检测"><a href="#3-4-4-影响之前读取的写入检测" class="headerlink" title="3.4.4 影响之前读取的写入检测"></a>3.4.4 影响之前读取的写入检测</h4><p>在一个事务写入某对象时，需要检测是否该数据被另一个事务读取过<br><strong>在写入时，利用之前在对应索引范围记下的读取事务编号记录冲突，在提交时，看有冲突的读取是否已经提交</strong>。</p><h4 id="3-4-5-可串行快照隔离的性能"><a href="#3-4-5-可串行快照隔离的性能" class="headerlink" title="3.4.5 可串行快照隔离的性能"></a>3.4.5 可串行快照隔离的性能</h4><p>和 2PL 相比，SSI 的最大优点是，不会通过锁来阻塞有依赖关系的事务并发执行。SSI 就想运行在快照隔离级别一样，读不阻塞写，写不阻塞读。只是追踪记录，在提交时决定是否提交或重试。这种设计是的查询延迟更可预测。尤其是，只读事务可以工作在一致性快照上，而不受影响，这对读负载很重的场景很有吸引力。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;从&lt;strong&gt;时间&lt;/strong&gt;和&lt;strong&gt;空间&lt;/strong&gt;两个角度来理解事务，从生命周期（时间）来讲，事务要保证一组操作的整体性；从并发控制（空间），事务要做好多个事务间的并发控制。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="阅读笔记" scheme="https://stardustorz.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DDIA" scheme="https://stardustorz.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/DDIA/"/>
    
    
    <category term="DDIA" scheme="https://stardustorz.github.io/tags/DDIA/"/>
    
  </entry>
  
  <entry>
    <title>[DDIA] 分区</title>
    <link href="https://stardustorz.github.io/2023/06/18/DDIA/05%20%E5%88%86%E5%8C%BA/"/>
    <id>https://stardustorz.github.io/2023/06/18/DDIA/05%20%E5%88%86%E5%8C%BA/</id>
    <published>2023-06-17T16:00:00.000Z</published>
    <updated>2025-03-09T16:09:47.924Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>解决数据集尺度与单机容量、负载不匹配的问题</p></blockquote><span id="more"></span><ol><li><strong>分片（Partition）</strong>：解决数据集尺度与单机容量、负载不匹配的问题，分片之后可以利用多机容量和负载。</li><li><strong>复制（Replication</strong>）：系统机器一多，单机故障概率便增大，为了防止数据丢失以及服务高可用，需要做多副本。<br>通常来说，数据系统在分布式系统中会有三级划分：数据集（如 Database、Bucket）——分片（Partition）——数据条目（Row、KV）。通常，每个分片只属于一个数据集，每个数据条目只属于一个分片。单个分片，就像一个小点的数据库。但是，跨分区的操作的，就要复杂的多。</li></ol><h2 id="1-分片和复制"><a href="#1-分片和复制" class="headerlink" title="1 分片和复制"></a>1 分片和复制</h2><p>分片通常和复制结合使用。每个分片有多个副本，可以分散到多机上去（更泛化一点：多个容错阈）；同时，每个机器含有多个分片，但通常不会有一个分片的两个副本放到一个机器上。<br><strong>如果使用多副本使用主从模型，则分片、副本、机器关系如下：</strong></p><ol><li>从一个分片的角度看，主副本在一个机器上，从副本们在另外机器上。</li><li>从一个机器的角度看，既有一些主副本分片，也有一些从副本分片。实践中，也会尽量保证主副本在集群中均匀分布，避免过多的集中到一台机器上。</li></ol><h2 id="2-键值对集的分片"><a href="#2-键值对集的分片" class="headerlink" title="2 键值对集的分片"></a>2 键值对集的分片</h2><p>键值对是数据的一种最通用、泛化的表示，其他种类数据库都可以转化为键值对表示<br><strong>分片（Partition）</strong> 的本质是对数据集合的划分。但在实践中，可以细分为两个步骤：</p><ol><li>对数据集进行<strong>逻辑</strong>划分</li><li>将逻辑分片调度到<strong>物理</strong>节点<br><strong>一些基本要求：</strong></li><li>分片过程中，要保证每个分片的数据量多少尽量均匀，否则会有<strong>数据偏斜</strong>（<strong>skew</strong>），甚而形成<strong>数据热点</strong>。</li><li>分片后，需要保存路由信息，给一个 KV 条目，能知道去<strong>哪个</strong>机器上去查；稍差一些，可以知道去<strong>哪几个</strong>机器上去找；最差的，如果需要去所有机器逐一查询，但性能一般不可接受。</li></ol><p>有三种常用的策略：</p><ol><li>通过某种固定规则，比如哈希，算出一个位置。</li><li>使用内存，保存所有数据条目到机器的映射。</li><li>结合两种，首先通过规则算出到逻辑分片的映射，然后通过内存保存逻辑分片到物理节点的映射。</li></ol><h3 id="2-1-按键范围分区"><a href="#2-1-按键范围分区" class="headerlink" title="2.1 按键范围分区"></a>2.1 按键范围分区</h3><p>对于 KV 数据来说，Key 通常会有个定义域，且在定义域内可（按某种维度）排序。则，将该连续的定义域进行切分，保存每个切分的上下界，在给出某个 Key 时，就能通过比较，定位其所在分区。<br>好处在于可以进行<strong>快速的范围查询（Rang Query）</strong><br>坏处在于，数据分散不均匀，且容易造成热点。可能需要动态的调整的分区边界，以维护分片的相对均匀。<br>一个解决办法是<strong>分级</strong>或者<strong>混合</strong>，使用拼接主键，分散到不同的机器上</p><h3 id="2-2-按键散列分区"><a href="#2-2-按键散列分区" class="headerlink" title="2.2 按键散列分区"></a>2.2 按键散列分区</h3><ul><li>选择散列函数的<strong>依据</strong>是，使得数据散列尽量均匀：即给定一个 Key，经过散列函数后，以等概率在哈希区间（如 <code>[0, 2^32-1)</code>）内产生一个值。即使原 Key 相似，他的散列值也能均匀分布。</li><li>选定哈希函数后，将原 Key 定义域映射到新的散列值阈，而散列值是均匀的，因此可以对散列值阈按给定分区数进行等分。</li><li>还有一种常提的哈希方法叫做<a href="https://zh.m.wikipedia.org/zh-hans/%E4%B8%80%E8%87%B4%E5%93%88%E5%B8%8C">一致性哈希</a> 。其特点是，会考虑逻辑分片和物理拓扑，将数据和物理节点按同样的哈希函数进行哈希，来决定如何将哈希分片路由到不同机器上。它可以避免在内存中维护<strong>逻辑分片到物理节点的映射</strong>，而是每次计算出来。即用一套算法同时解决了我们在最初提出的逻辑分片和物理路由的两个问题。<br>两种分区方式区别在于，一个使用应用相关值（ <code>Key</code> ）分区，一个使用应用无关值（<code>Hash(key)</code>）分区，前者支持高效范围查询，后者可以均摊负载。但可使用多个字段，组合使用两种方式，使用一个字段进行分区，使用另一个字段在分区内进行排序，兼取两者优点。</li></ul><h3 id="2-3-负载偏斜和热点消除"><a href="#2-3-负载偏斜和热点消除" class="headerlink" title="2.3 负载偏斜和热点消除"></a>2.3 负载偏斜和热点消除</h3><ul><li>在数据层，可以通过哈希将数据均匀散列，以期将对数据的请求均摊；但如果在应用层，不同数据条目的负载本就有倾斜，存在对某些键的热点。那么仅在数据层哈希，就不能起到消除热点的作用。<ul><li>在社交网络中的大 V，其发布的信息，天然会引起同一个键（假设键是用户 id）大量数据的写入，因为可能会有针对该用户信息的大量评论和互动。</li></ul></li><li>只能在应用层进行热点消除，如可以用拼接主键，对这些大 V 用户主键进行“分身”，即在用户主键开始或者结尾添加一个随机数，两个十进制后缀就可以增加 100 中拆分可能。但这无疑需要应用层做额外的工作，请求时需要进行拆分，返回时需要进行合并。</li></ul><h2 id="3-分片和次级索引"><a href="#3-分片和次级索引" class="headerlink" title="3 分片和次级索引"></a>3 分片和次级索引</h2><p><strong>次级索引（secondary index）</strong>，即主键以外的列的索引；由于分区都是基于主键的，在针对有分区的数据建立次级索引时，就会遇到一些困难。<br>常见的建立次级索引的方法有：</p><ol><li>本地索引（local index），书中又称 document-based index</li><li>全局索引（global index），书中又称 term-based index<h3 id="3-1-本地索引"><a href="#3-1-本地索引" class="headerlink" title="3.1 本地索引"></a>3.1 本地索引</h3>次级索引会对每个数据条目建立一个索引条目，这给数据库的实现带来了一些问题：</li><li>当数据库已有数据时，建立索引，何时针对存量数据构建索引。</li><li>当数据库中数据条目发生更改时，如何维护数据和索引的一致性，尤其是多客户端并发修改时。</li></ol><p>本地<strong>索引（local index）</strong>，就是对<strong>每个数据分区独立地建立次级索引</strong>，即，次级索引只针对本分区数据，而不关心其他分区数据。本地索引的<strong>优点</strong>是维护方便，在更新数据时，只需要在该分区所在机器同时更新索引即可。但<strong>缺点</strong>是，查询效率相对较低，所有基于索引的查询请求，都要发送到所有分区，并将结果合并，该过程也称为 <strong>scatter/gather</strong> 。但即使用多分区并发（而非顺序）进行索引查询优化，也仍然容易在某些机器上发生<strong>长尾请求</strong>（由于机器负载过高或者网络问题，导致改请求返回特别慢，称为长尾请求），导致整个请求过程变慢。</p><h3 id="3-2-全局索引"><a href="#3-2-全局索引" class="headerlink" title="3.2 全局索引"></a>3.2 全局索引</h3><p>为了避免查询索引时将请求发到所有分区，可以建立<strong>全局索引</strong>，即每个次级索引条目都是针对全局数据。但为了避免索引查询热点，我们会将索引数据本身也分片，分散到多个机器上。</p><p>全局索引能避免索引查询时的 scatter/gather 操作，但维护起来较为复杂，因为每个数据的插入，可能会影响多个索引分区</p><p>为了避免增加写入延迟，在实践中，全局索引多为异步更新。但由此会带来短暂（有时可能会比较长）的数据和索引不一致。如果想要保证强一致性，需要引入跨分区的分布式事务（实现复杂度高，且会带来较大的性能损耗）</p><h2 id="4-分片均衡"><a href="#4-分片均衡" class="headerlink" title="4 分片均衡"></a>4 分片均衡</h2><p>数据库在运行过程中，数据和机器都会发生一些变化：</p><ol><li>查询吞吐增加，需要增加机器以应对增加的负载。</li><li>数据集变大，需要增加磁盘和 RAM 来存储增加数据。</li><li>有机器故障，需要其他机器来接管故障机器数据。</li></ol><p>这些问题都会引起数据分片在节点间的迁移，我们将之称为：<strong>均衡（rebalancing）</strong>。对于 rebalancing 我们期望：</p><ol><li>均衡后负载（存储、读写）在节点间均匀分布</li><li>均衡时不能禁止读写，并且尽量减小影响</li><li>尽量减少不必要的数据移动，尽量降低网络和磁盘 IO</li></ol><h3 id="4-1-均衡策略"><a href="#4-1-均衡策略" class="headerlink" title="4.1 均衡策略"></a>4.1 均衡策略</h3><p>分区策略会影响均衡策略。比如动态分区、静态分区，对应的均衡策略就不太一样；此外，分区的粒度和数量也会影响均衡策略。</p><h3 id="4-2-不要使用：hash-mod-N"><a href="#4-2-不要使用：hash-mod-N" class="headerlink" title="4.2 不要使用：hash mod N"></a>4.2 不要使用：hash mod N</h3><p>不能应对机器数量的变化，如果要增删节点，就会有大量的数据需要发生迁移，否则，就不能保证数据在 <code>hash(key) mod N</code> 标号的机器上。在大规模集群中，机器节点增删比较频繁，这种策略更是不可接受。</p><h3 id="4-3-静态分区"><a href="#4-3-静态分区" class="headerlink" title="4.3 静态分区"></a>4.3 静态分区</h3><p>静态分区，即，逻辑分区阶段的<strong>分区数量是固定的</strong>，并且最好让分区数量大于（比如高一个数量级）机器节点。相比<strong>动态分区</strong>策略（比如，允许分区分裂和合并），固定数量分区更容易实现和维护。<br>对于数据量会超预期增长的数据集，静态分区策略就会让用户进退两难，已经有很多数据，重新分区代价很大，不重新分区又难以应对数据量的进一步增长。</p><h3 id="4-4-动态分区"><a href="#4-4-动态分区" class="headerlink" title="4.4 动态分区"></a>4.4 动态分区</h3><p>动态分区好处在于，小数据量使用少量分区，减少开销；大数据量增加分区，以均摊负载。</p><h3 id="4-5-与节点成比例分区"><a href="#4-5-与节点成比例分区" class="headerlink" title="4.5 与节点成比例分区"></a>4.5 与节点成比例分区</h3><ol><li>静态均衡的分区数量一开始就固定的，但是单分区尺寸会随着总数量增大而增大。</li><li>动态均衡会按着数据量多少进行动态切合，单分区尺寸相对保持不变，一直于某个设定的上下界。<br>他们的分区数量都和集群节点数量没有直接关系。而另一种均衡策略，则是保持<strong>总分区数量</strong>和节点数量成正比，也即，保持每个节点分区数量不变。</li></ol><h2 id="5-请求路由"><a href="#5-请求路由" class="headerlink" title="5 请求路由"></a>5 请求路由</h2><p>将分区放到节点上去后，当客户端请求到来时，我们如何决定将请求路由到哪台机器？这势必要求我们<strong>以某种方式</strong>记下：</p><ol><li>数据条目到逻辑分区的映射。</li><li>逻辑分区到物理机器的映射。</li></ol><p>其次，是在哪里记下这些路由（映射）信息，泛化一下，是一个<strong>服务发现</strong>（service discovery）问题。概括来说，由内而外，有几种方案：</p><ol><li><strong>每个节点都有全局路由表</strong>。客户端可以连接集群中任意一个节点，如该节点恰有该分区，则处理后返回；否则，根据路由信息，将其路由合适节点。</li><li><strong>由一个专门的路由层来记录</strong>。客户端所有请求都打到路由层，路由层依据分区路由信息，将请求转发给相关节点。路由层只负责请求路由，并不处理具体逻辑。</li><li><strong>让客户端感知分区到节点映射</strong>。客户端可以直接根据该映射，向某个节点发送请求。</li></ol><p>如何让所有节点就路由信息快速达成一致？</p><ul><li><strong>依赖外部协调组件</strong>。如 Zookeeper、Etcd，他们各自使用某种共识协议保持高可用，可以维护轻量的路由表，并提供发布订阅接口，在有路由信息更新时，让外部所有节点快速达成一致。</li><li><strong>使用内部元数据服务器</strong>。如三节点的 Meta 服务器，每个节点都存储一份路由数据，使用某种共识协议达成一致。如 TiDB 的 Placement Driver。</li><li><strong>使用某种协议点对点同步</strong>。如 Dynamo、Cassandra 和 Riak 使用流言协议（Gossip Protocol），在集群内所有机器节点间就路由信息进行传播，并最终达成一致</li></ul><h3 id="5-1-并行查询执行"><a href="#5-1-并行查询执行" class="headerlink" title="5.1 并行查询执行"></a>5.1 并行查询执行</h3><p>对于关系型数据库产品，尤其是支持 <strong>大规模并行处理（MPP, Massively parallel processing）</strong> 数仓，一个查询语句在执行层要复杂的多，可能会：</p><ol><li>Stage：由多个阶段组成。</li><li>Partition：每个阶段包含多个针对每个分区的并行的子查询计划。</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;解决数据集尺度与单机容量、负载不匹配的问题&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="阅读笔记" scheme="https://stardustorz.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DDIA" scheme="https://stardustorz.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/DDIA/"/>
    
    
    <category term="DDIA" scheme="https://stardustorz.github.io/tags/DDIA/"/>
    
  </entry>
  
  <entry>
    <title>[DDIA] 冗余</title>
    <link href="https://stardustorz.github.io/2023/06/14/DDIA/04%20%E5%86%97%E4%BD%99/"/>
    <id>https://stardustorz.github.io/2023/06/14/DDIA/04%20%E5%86%97%E4%BD%99/</id>
    <published>2023-06-13T16:00:00.000Z</published>
    <updated>2025-03-09T16:09:44.738Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>冗余（Replication）</strong> 是指将同一份数据复制多份，放到通过网络互联的多个机器上去。</p></blockquote><span id="more"></span><p>其好处有：</p><ol><li><strong>降低延迟</strong>：可以在地理上同时接近不同地区的用户。</li><li><strong>提高可用性</strong>：当系统部分故障时仍然能够正常提供服务。</li><li><strong>提高读吞吐</strong>：平滑扩展可用于查询的机器。</li></ol><ul><li>如果只读，直接复制即可。可以利用这个特性，使用分治策略，将数据分为只读部分和读写部分，则只读部分的冗余就会容易处理的多</li><li>允许数据变更时，如何维护多机冗余且一致。常用的冗余控制算法有：<ul><li>单领导者（single leader）</li><li>多领导者（multi-leader）</li><li>无领导者（leaderless）</li></ul></li><li>需要在多方面做取舍<ul><li>使用同步复制还是异步复制</li><li>如何处理失败的副本</li></ul></li></ul><h2 id="1-领导与跟随者"><a href="#1-领导与跟随者" class="headerlink" title="1 领导与跟随者"></a>1 领导与跟随者</h2><p><strong>副本</strong>：冗余的每份数据。  如何保证所有的数据都同步到了所有的副本上？<br>基于<strong>领导者（leader-based）</strong> 的同步算法：也就是主从同步</p><ol><li>其中一个副本称为<strong>领导者</strong>（leader），别称<strong>主副本</strong>（primary、master）。主副本作为写入的协调者，所有写入都要发给主副本。</li><li>其他副本称为<strong>跟随者</strong>（follower），也称为<strong>只读副本</strong>（read replicas）、<strong>从副本</strong>（slaves）、<strong>次副本</strong>（secondaries）、<strong>热备</strong>（hot-standby）。主副本将改动写到本地后，将其发送给各个从副本，从副本收变动到后应用到自己状态机，这个过程称为<strong>日志同步</strong>（replication log）、<strong>变更流</strong>（change steam）。</li><li>对于读取，客户端可以从主副本和从副本中读取；但写入，客户端只能将请求发到主副本。<h3 id="1-1-同步和异步复制"><a href="#1-1-同步和异步复制" class="headerlink" title="1.1 同步和异步复制"></a>1.1 同步和异步复制</h3><strong>同步（synchronously）复制</strong>和<strong>异步（asynchronously）复制</strong>和关键区别在于：请求何时返回给客户端。</li><li>如果等待某副本写完成后，则该副本为同步复制。</li><li>如果不等待某副本写完成，则该副本为异步复制。</li></ol><p>对比：</p><ol><li>同步复制牺牲了<strong>响应延迟</strong>和<strong>部分可用性</strong>（在某些副本有问题时不能完成写入操作），换取了所有副本的一致性（但并不能严格保证）。</li><li>异步复制放松了<strong>一致性</strong>，而换来了较低的写入延迟和较高的可用性。</li></ol><p>取舍：</p><ol><li><strong>全同步</strong>：所有的从副本都同步写入。如果副本数过多，可能性能较差，当然也可以做并行化、流水线化处理。</li><li><strong>半同步</strong>：（<strong>semi-synchronous</strong>），有一些副本为同步，另一些副本为异步。</li><li><strong>全异步</strong>：所有的从副本都异步写入。网络环境比较好的话，可以这么配置。</li></ol><h3 id="1-2-新增副本"><a href="#1-2-新增副本" class="headerlink" title="1.2 新增副本"></a>1.2 新增副本</h3><p>如果原副本是只读（read-only）的，只需要简单拷贝即可。但是如果是可写副本，则问题要复杂很多。因此，比较简单的一种解决方法是：禁止写入，然后拷贝。这在某些情况下很有用，比如夜间没有写入流量，同时一晚上肯定能复制完。<br>如果要不停机，可以：</p><ol><li>主副本在本地做<strong>一致性</strong>快照。何谓一致性？</li><li>将快照复制到从副本节点。</li><li>从主副本拉取快照之后的操作日志，应用到从副本。如何知道快照与其后日志的对应关系？序列号。</li><li>当从副本赶上主副本进度后，就可以正常跟随主副本了。</li></ol><h3 id="1-3-宕机处理"><a href="#1-3-宕机处理" class="headerlink" title="1.3 宕机处理"></a>1.3 宕机处理</h3><p>系统中任何节点都可能在计划内或者计划外宕机。那么如何应对这些宕机情况，保持整个系统的可用性呢？</p><h4 id="1-3-1-主副本宕机：故障转移"><a href="#1-3-1-主副本宕机：故障转移" class="headerlink" title="1.3.1 主副本宕机：故障转移"></a>1.3.1 主副本宕机：故障转移</h4><p>首先要选出新的主副本，然后要通知所有客户端主副本变更：</p><ol><li><strong>确认主副本故障</strong>。要防止由于网络抖动造成的误判。一般会用心跳探活，并设置合理超时（timeout）阈值，超过阈值后没有收到该节点心跳，则认为该节点故障。</li><li><strong>选择新的主副本</strong>。新的主副本可以通过<strong>选举</strong>（共识问题）或者<strong>指定</strong>（外部控制程序）来产生。选主时，要保证备选节点数据尽可能的新，以最小化数据损失。</li><li><strong>让系统感知新主副本</strong>。系统其他参与方，包括从副本、客户端和旧主副本。前两者不多说，旧主副本在恢复时，需要通过某种手段，让其知道已经失去领导权，避免<strong>脑裂</strong>。</li></ol><p><strong>主副切换问题</strong>：</p><ol><li><strong>新老主副本数据冲突</strong>。新主副本在上位前没有同步完所有日志，旧主副本恢复后，可能会发现和新主副本数据冲突。</li><li><strong>相关外部系统冲突</strong>。即新主副本，和使用该副本数据的外部系统冲突。书中举了 github 数据库 MySQL 和缓存系统 redis 冲突的例子。</li><li><strong>新老主副本角色冲突</strong>。即新老主副本都以为自己才是主副本，称为<strong>脑裂（split brain）</strong>。如果他们两个都能接受写入，且没有冲突解决机制，数据会丢失或者损坏。有的系统会在检测到脑裂后，关闭其中一个副本，但设计的不好可能将两个主副本都关闭。</li><li><strong>超时阈值选取</strong>。如果超时阈值选取的过小，在不稳定的网络环境中（或者主副本负载过高）可能会造成主副本频繁的切换；如果选取过大，则不能及时进行故障切换，且恢复时间也增长，从而造成服务长时间不可用。</li></ol><p>节点故障；不可靠网络；在一致性、持久化、可用性和延迟间的取舍；等等问题，都是设计分布式系统时，所面临的的基本问题。根据实际情况，对这些问题进行艺术化的取舍，便是分布式系统之美。</p><h4 id="1-3-2-从副本宕机：追赶恢复。"><a href="#1-3-2-从副本宕机：追赶恢复。" class="headerlink" title="1.3.2 从副本宕机：追赶恢复。"></a>1.3.2 从副本宕机：追赶恢复。</h4><p>类似于新增从副本。如果落后的多，可以直接向主副本拉取快照 + 日志；如果落后的少，可以仅拉取缺失日志。</p><h3 id="1-4-日志复制"><a href="#1-4-日志复制" class="headerlink" title="1.4 日志复制"></a>1.4 日志复制</h3><p>在数据库中，基于领导者的多副本是如何实现的？在不同层次有多种方法，包括：</p><ol><li><strong>语句层面的复制。</strong></li><li><strong>预写日志的复制</strong>。</li><li><strong>逻辑日志的复制</strong>。</li><li><strong>触发器的复制</strong>。</li></ol><p>对于一个<strong>系统</strong>来说，多副本同步的是什么？<strong>增量修改</strong>。<br>具体到一个由数据库构成的<strong>数据系统</strong>，通常由数据库外部的<strong>应用层</strong>、数据库内部<strong>查询层</strong>和<strong>存储层</strong>组成。<strong>修改</strong>在查询层表现为：语句；在存储层表现为：存储引擎相关的预写日志、存储引擎无关的逻辑日志；修改完成后，在应用层表现为：触发器逻辑。</p><h4 id="1-4-1-基于语句"><a href="#1-4-1-基于语句" class="headerlink" title="1.4.1 基于语句"></a>1.4.1 基于语句</h4><p>主副本记录下所有更新语句：<code>INSERT</code>、<code>UPDATE</code>  或  <code>DELETE</code> 然后发给从库。主副本在这里类似于充当其他从副本的<strong>伪客户端</strong>。</p><h4 id="1-4-2-传输预写日志（WAL）"><a href="#1-4-2-传输预写日志（WAL）" class="headerlink" title="1.4.2 传输预写日志（WAL）"></a>1.4.2 传输预写日志（WAL）</h4><p>主流的存储引擎都有<strong>预写日志</strong>（WAL，为了宕机恢复）：</p><ol><li>对于日志流派（LSM-Tree，如 LevelDB），每次修改先写入 log 文件，防止写入 MemTable 中的数据丢失。</li><li>对于原地更新流派（B+ Tree），每次修改先写入 WAL，以进行崩溃恢复。<br>所有用户层面的改动，最终都要作为状态落到存储引擎里，而存储引擎通常会维护一个：</li><li>追加写入</li><li>可重放<br>这种结构，天然适合备份同步。本质是因为磁盘的读写特点和网络类似：<strong>磁盘是顺序写比较高效，网络是只支持流式写</strong>。具体来说，主副本在写入 WAL 时，会同时通过网络发送对应的日志给所有从副本。</li></ol><h4 id="1-4-3-逻辑日志"><a href="#1-4-3-逻辑日志" class="headerlink" title="1.4.3 逻辑日志"></a>1.4.3 逻辑日志</h4><p>和具体的存储引擎物理格式解耦，在做数据同步时，可以使用不同的日志格式：<strong>逻辑日志</strong>。<br>对于关系型数据库来说，行是一个合适的粒度：</p><ol><li><strong>对于插入行</strong>：日志需包含所有列值。</li><li><strong>对于删除行</strong>：日志需要包含待删除行标识，可以是主键，也可以是其他任何可以唯一标识行的信息。</li><li><strong>对于更新行</strong>：日志需要包含待更新行的标志，以及所有列值（至少是要更新的列值）<br>对于多行修改来说，比如事务，可以在修改之后增加一条事务提交的记录。MySQL 的 binlog 就是这么干的。<br>使用逻辑日志的<strong>好处</strong>有：</li><li>方便新旧版本的代码兼容，更好的进行滚动升级。</li><li>允许不同副本使用不同的存储引擎。</li><li>允许导出变动做各种<strong>变换</strong>。如导出到数据仓库进行离线分析、建立索引、增加缓存等等。</li></ol><h2 id="2-复制滞后问题"><a href="#2-复制滞后问题" class="headerlink" title="2 复制滞后问题"></a>2 复制滞后问题</h2><p>使用多副本的好处有：</p><ol><li><strong>可用性</strong>：容忍部分节点故障</li><li><strong>可伸缩性</strong>：增加读副本处理更多读请求</li><li><strong>低延迟</strong>：让用户选择一个就近的副本访问<br>对于读多写少的场景，想象中，可以通过使劲增加读副本来均摊流量。但有个<strong>隐含</strong>的条件是，多副本间的同步得做成<strong>异步</strong>的，否则，读副本一多，某些副本就很容易出故障，进而阻塞写入。<h3 id="2-1-读你所写"><a href="#2-1-读你所写" class="headerlink" title="2.1 读你所写"></a>2.1 读你所写</h3>在一个<strong>异步复制</strong>的分布式数据库里，同一个客户端，写入<strong>主副本</strong>后返回；稍后再去读一个落后的<strong>从副本</strong>，就会发现：读不到自己刚写的内容！<br>为了避免这种反直觉的事情发生，我们引入一种新的一致性：<strong>读写一致性（read-after-write consistency）</strong>，或者  <strong>读你所写一致性（read-your-writes consistency）</strong>。<br><strong>列举几种方案：</strong></li><li><strong>按内容分类</strong>。对于客户端可能修改的内容集，<strong>只从主副本读取</strong>。如社交网络上的个人资料，读自己的资料时，从主副本读取；但读其他人资料时，可以向从副本读。</li><li><strong>按时间分类</strong>。如果每个客户端都能访问基本所有数据，则方案一就会退化成所有数据都要从主副本读取，这显然不可接受。此时，可以按时间分情况讨论，近期内有过改动的数据，从主副本读，其他的，向从副本读。那这个区分是否最近的<strong>时间阈值</strong>（比如一分钟）如何选取呢？可以监控从副本一段时间内的最大延迟这个经验值，来设置。</li><li><strong>利用时间戳</strong>。客户端记下本客户端上次改动时的时间戳，在读从副本时，利用此时间戳来看某个从副本是否已经同步了改时间戳之前内容。可以在所有副本中找到一个已同步了的；或者阻塞等待某个副本同步到改时间戳后再读取。时间戳可以是逻辑时间戳，也可以是物理时间戳（此时多机时钟同步非常重要）。</li></ol><h3 id="2-2-单调读"><a href="#2-2-单调读" class="headerlink" title="2.2 单调读"></a>2.2 单调读</h3><p>对于一个客户端来说，系统可能会发生<strong>时光倒流（moving backward in time）</strong>。<br>再引入一种一致性保证：<strong>单调读（Monotonic reads）</strong>。</p><ul><li>读写一致性和单调读有什么区别？ 写后读保证的是写后读顺序，单调读保证的是<strong>多次读</strong>之间的顺序。<br>如何实现单调读？</li></ul><ol><li>只从一个副本读数据。</li><li>前面提到的时间戳机制。<h3 id="2-3-一致前缀读"><a href="#2-3-一致前缀读" class="headerlink" title="2.3 一致前缀读"></a>2.3 一致前缀读</h3>异步复制所带来的第三个问题：有时候会违反因果关系。<br>本质在于：如果数据库由多个分区（Partition）组成，而分区间的事件顺序无法保证。此时，如果有因果关系的两个事件落在了不同分区，则有可能会出现<strong>果在前，因在后</strong>。<br>为了防止这种问题，我们又引入了一种一致性：<strong>一致前缀读（consistent prefix reads）</strong>。奇怪的名字。<br>实现这种一致性保证的方法：</li><li>不分区。</li><li>让所有有因果关系的事件路由到一个分区</li></ol><h3 id="2-4-终极解决方案"><a href="#2-4-终极解决方案" class="headerlink" title="2.4 终极解决方案"></a>2.4 终极解决方案</h3><p><strong>事务！</strong><br>多副本异步复制所带来的一致性问题，都可以通过<strong>事务（transaction）</strong> 来解决。单机事务已经存在了很长时间，但在数据库走向分布式时代，一开始很多 NoSQL 系统抛弃了事务。</p><ul><li>这是为什么？<ol><li>更容易的实现。2. 更好的性能。3. 更好的可用性。<br>于是复杂度被转移到了应用层。<br>这是数据库系统刚大规模步入分布式（<strong>多副本、多分区</strong>）时代的一种妥协，在经验积累的够多之后，事务必然会被引回。<br>于是近年来越来越多的分布式数据库开始支持事务，是为<strong>分布式事务</strong>。</li></ol></li></ul><h2 id="3-多主模型"><a href="#3-多主模型" class="headerlink" title="3 多主模型"></a>3 多主模型</h2><p><strong>单主模型一个最大问题</strong>：所有写入都要经过它，如果由于任何原因，客户端无法连接到主副本，就无法向数据库写入。<br><strong>多主复制（multi-leader replication）</strong>：有多个可以接受写入的主副本，每个主副本在接收到写入之后，都要转给所有其他副本。即一个系统，有多个<strong>写入点</strong>。</p><ol><li>数据库横跨多个数据中心</li><li>需要离线工作的客户端</li><li>协同编辑<h2 id="4-无主模型"><a href="#4-无主模型" class="headerlink" title="4 无主模型"></a>4 无主模型</h2>通常来说，在无主模型中，写入时可以：</li><li>由客户端直接写入副本。</li><li>由<strong>协调者（coordinator）</strong> 接收写入，转发给多副本。但与主副本不同，协调者并不负责定序。<h3 id="4-1-有节点故障时的写入"><a href="#4-1-有节点故障时的写入" class="headerlink" title="4.1 有节点故障时的写入"></a>4.1 有节点故障时的写入</h3>多数派写入，多数派读取，以及读时修复。<br>由于写入时，简单的忽略了宕机副本；在读取时，就要多做些事情了：<strong>同时读取多个副本，选取最新<em>版本</em>的值</strong>。</li></ol><h4 id="4-1-1-读时修复和反熵"><a href="#4-1-1-读时修复和反熵" class="headerlink" title="4.1.1 读时修复和反熵"></a>4.1.1 读时修复和反熵</h4><p>无主模型也需要维持多个副本数据的一致性。在某些节点宕机重启后，如何让其弥补错过的数据？</p><ol><li><strong>读时修复（read repair）</strong>，本质上是一种捎带修复，在读取时发现旧的就顺手修了。</li><li><strong>反熵过程（Anti-entropy process）</strong>，本质上是一种兜底修复，读时修复不可能覆盖所有过期数据，因此需要一些后台进程，持续进行扫描，寻找陈旧数据，然后更新</li></ol><h4 id="4-1-2-Quorum-读写"><a href="#4-1-2-Quorum-读写" class="headerlink" title="4.1.2 Quorum 读写"></a>4.1.2 Quorum 读写</h4><p>如果副本总数为 n，写入 w 个副本才认定写入成功，并且在查询时最少需要读取 r 个节点。只要满足 w + r &gt; n，我们就能读到最新的数据（<strong>鸽巢原理</strong>）。此时 r 和 w 的值称为 <strong>quorum 读写</strong>。即这个约束是保证数据有效所需的最低（法定）票数。</p><p>在 Dynamo 流派的存储中，n、r 和 w 通常是可以配置的：</p><ol><li>n 越大冗余度就越高，也就越可靠。</li><li>r 和 w 都常都选择超过半数，如 <code>(n+1)/2</code></li><li>w = n 时，可以让 r = 1。此时是牺牲写入性能换来读取性能。</li></ol><p>考量满足 w+r &gt; n 系统对节点故障的容忍性：</p><ol><li>如果 w &lt; n，则有节点不可用时，仍然能正常写入。</li><li>如果 r &lt; n，则有节点不可用时，仍然能正常读取。</li></ol><p>通常来说，我们会将读或者写并行的发到全部 n 个副本，但是只要等到法定个副本的结果，就可以返回。<br>如果由于某种原因，可用节点数少于 r 或者 w，则读取或者写入就会出错。</p><h3 id="4-2-quorum-一致性的局限"><a href="#4-2-quorum-一致性的局限" class="headerlink" title="4.2 quorum 一致性的局限"></a>4.2 quorum 一致性的局限</h3><ol><li>使用宽松的 Quorum 时（n 台机器范围可以发生变化），w 和 r 可能并没有交集。</li><li>对于写入并发，如果处理冲突不当时。比如使用 last-win 策略，根据本地时间戳挑选时，可能由于时钟偏差造成数据丢失。</li><li>对于读写并发，写操作仅在部分节点成功就被读取，此时不能确定应当返回新值还是旧值。</li><li>如果写入节点数 &lt; w 导致写入失败，但并没有对数据进行回滚时，客户端读取时，仍然会读到旧的数据。</li><li>虽然写入时，成功节点数 &gt; w，但中间有故障造成了一些副本宕机，导致成功副本数 &lt; w，则在读取时可能会出现问题。</li><li>即使都正常工作，也有可能出现一些关于时序（timing）的边角情况。</li></ol><h4 id="4-2-1-一致性监控"><a href="#4-2-1-一致性监控" class="headerlink" title="4.2.1 一致性监控"></a>4.2.1 一致性监控</h4><p>对于无主模型，由于没有固定写入顺序，副本的落后进度变得难以界定。如果系统只使用读时修复策略，则对于一个副本的落后程度是没有限制的。读取频率很低数据可能版本很老。</p><p>最终一致性是一种很模糊的保证，但通过监控能够量化“最终”（比如到一个阈值），也是很棒的。</p><h3 id="4-3-放松的-Quorum-和提示转交"><a href="#4-3-放松的-Quorum-和提示转交" class="headerlink" title="4.3 放松的 Quorum 和提示转交"></a>4.3 放松的 Quorum 和提示转交</h3><p>正常的 Quorum 能够容忍一些副本节点的宕机。但在大型集群（总节点数目 &gt; n）中，可能最初选中的 n 台机器，由于种种原因（宕机、网络问题），导致无法达到法定读写数目，则此时有两种选择：</p><ol><li>对于所有无法达到 r 或 w 个法定数目的读写，直接报错。</li><li>仍然接受写入，并且将新的写入暂时交给一些正常节点。<br>后者被认为是一种<strong>宽松的法定数目</strong> （<strong>sloppy quorum</strong>）：写和读仍然需要 w 和 r 个成功返回，但是其所在节点集合可以发生变化。</li></ol><p>一旦问题得到解决，数据将会根据线索移回其应该在的节点（D—&gt; B），我们称之为<strong>提示移交</strong>（hinted handoff）。这个移交过程是由反熵 anti-entropy 后台进程完成的。</p><p>这是一种典型的牺牲部分一致性，换取更高可用性的做法。在常见的 Dynamo 实现中，放松的法定人数是可选的。在 Riak 中，它们默认是启用的，而在 Cassandra 和 Voldemort 中它们默认是禁用的</p><h4 id="4-3-1-多数据中心"><a href="#4-3-1-多数据中心" class="headerlink" title="4.3.1 多数据中心"></a>4.3.1 多数据中心</h4><p>为了同时兼顾<strong>多数据中心</strong>和<strong>写入的低延迟</strong>，有一些不同的基于无主模型的多数据中心的策略：</p><ol><li>其中 Cassandra 和 Voldemort 将 n 配置到所有数据中心，但写入时只等待本数据中心副本完成就可以返回。</li><li>Riak 将 n 限制在一个数据中心内，因此所有客户端到存储节点的通信可以限制到单个数据中心内，而数据复制在后台异步进行。</li></ol><h3 id="4-4-并发写入检测"><a href="#4-4-并发写入检测" class="headerlink" title="4.4 并发写入检测"></a>4.4 并发写入检测</h3><p>由于 Dynamo 允许多个客户端并发写入相同 Key，则即使使用严格的 Quorum 读写，也会产生冲突：<strong>对于时间间隔很短（并发）的相同 key 两个写入，不同副本上收到的顺序可能不一致</strong>。<br>此外，读时修复和提示移交时，也可能产生冲突。<br>为了使所有副本最终一致，需要有一种手段来解决并发冲突。</p><h4 id="4-4-1-后者胜"><a href="#4-4-1-后者胜" class="headerlink" title="4.4.1 后者胜"></a>4.4.1 后者胜</h4><p>后者胜（LWW，last write wins）的策略是，通过某种手段确定一种全局唯一的顺序，然后让后面的修改覆盖之前的修改。</p><p>如，为所有写入附加一个全局时间戳，如果对于某个 key 的写入有冲突，可以挑选具有最大时间戳的数据保留，并丢弃较早时间戳的写入。<br>使用 LWW 唯一安全的方法是：key 是一次可写，后变为只读。</p><h4 id="4-4-2-发生于之前（Happens-before）和并发关系"><a href="#4-4-2-发生于之前（Happens-before）和并发关系" class="headerlink" title="4.4.2 发生于之前（Happens-before）和并发关系"></a>4.4.2 发生于之前（Happens-before）和并发关系</h4><ol><li>服务器为每个键分配一个版本号 V，每次该键有写入时，将 V + 1，并将版本号与写入的值一块保存。</li><li>当客户端读取该键时，服务器将返回所有未被覆盖的值以及最新的版本号。</li><li>客户端在进行下次写入时，必须<strong>包含</strong>之前读到的版本号 Vx（说明基于哪个版本进行新的写入），并将读取的值合并到一块。</li><li>当服务器收到特定版本号 Vx 的写入时，可以用其值覆盖所有 V ≤ Vx 的值。</li></ol><h4 id="4-4-3-版本向量"><a href="#4-4-3-版本向量" class="headerlink" title="4.4.3 版本向量"></a>4.4.3 版本向量</h4><p>每个副本在遇到写入时，会增加对应键的版本号，同时跟踪从其他副本中看到的版本号，通过比较版本号大小，来决定哪些值要覆盖哪些值要保留。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;冗余（Replication）&lt;/strong&gt; 是指将同一份数据复制多份，放到通过网络互联的多个机器上去。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="阅读笔记" scheme="https://stardustorz.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DDIA" scheme="https://stardustorz.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/DDIA/"/>
    
    
    <category term="DDIA" scheme="https://stardustorz.github.io/tags/DDIA/"/>
    
  </entry>
  
  <entry>
    <title>[DDIA] 编码和演进</title>
    <link href="https://stardustorz.github.io/2023/05/28/DDIA/03%20%E7%BC%96%E7%A0%81%E5%92%8C%E6%BC%94%E8%BF%9B/"/>
    <id>https://stardustorz.github.io/2023/05/28/DDIA/03%20%E7%BC%96%E7%A0%81%E5%92%8C%E6%BC%94%E8%BF%9B/</id>
    <published>2023-05-27T16:00:00.000Z</published>
    <updated>2025-03-09T16:09:37.512Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>编码主要涉及两方面问题：如何编码能够节省空间、提高性能;<br> 如何编码以适应数据的演化和兼容。</p></blockquote><span id="more"></span><p>所有涉及跨进程通信的地方，都需要对数据进行<strong>编码</strong>（<strong>Encoding</strong>），或者说<strong>序列化</strong>（<strong>Serialization</strong>）。因为持久化存储和网络传输都是面向字节流的。序列化本质上是一种“<strong>降维</strong>”操作，将内存中高维的数据结构降维成单维的字节流，于是底层硬件和相关协议，只需要处理一维信息即可。<br><strong>编码主要涉及两方面问题：</strong></p><ol><li>如何编码能够节省空间、提高性能。</li><li>如何编码以适应数据的演化和兼容。</li></ol><h2 id="1-数据编码的格式"><a href="#1-数据编码的格式" class="headerlink" title="1 数据编码的格式"></a>1 数据编码的格式</h2><h3 id="1-1-JSON、XML-及其二进制变体"><a href="#1-1-JSON、XML-及其二进制变体" class="headerlink" title="1.1 JSON、XML 及其二进制变体"></a>1.1 JSON、XML 及其二进制变体</h3><p>JSON，XML 和 CSV 属于常用的<strong>文本编码</strong>格式，其好处在于肉眼可读，坏处在于不够紧凑，占空间较多。<br>除了不够紧凑外，<strong>文本编码（text encoding）</strong> 还有以下缺点：</p><ol><li>对<strong>数值类型支持不够</strong>。CSV 和 XML 直接不支持，万物皆字符串。JSON 虽区分字符串和数值，但是不进一步区分细分数值类型。可以理解，毕竟文本编码嘛，主要还是面向字符串。</li><li><strong>对二进制数据支持不够</strong>。支持 Unicode，但是对二进制串支持不够，可能会显示为乱码。虽然可以通过 Base64 编码来绕过，但有点做无用功的感觉。</li><li><strong>XML 和 JSON 支持额外的模式</strong>。模式会描述数据的类型，告诉你如何理解数据。配合这些模式语言，虽然可以让 XML 和 JSON 变得强大，但是大大增加了复杂度。</li><li><strong>CSV 没有任何模式</strong>。</li></ol><h4 id="1-1-1-二进制编码"><a href="#1-1-1-二进制编码" class="headerlink" title="1.1.1 二进制编码"></a>1.1.1 二进制编码</h4><p>JSON 有很多二进制变种：MessagePack、BSON、BJSON、UBJSON、BISON 和 Smile 等。</p><h3 id="1-2-Thrift-和-Protocol-Buffers"><a href="#1-2-Thrift-和-Protocol-Buffers" class="headerlink" title="1.2 Thrift 和 Protocol Buffers"></a>1.2 Thrift 和 Protocol Buffers</h3><p>在编码前都需要由接口定义语言（IDL）来描述模式：<br>IDL 是编程语言无关的，可以利用相关代码生成工具，可以将上述 IDL 翻译为指定语言的代码。即，集成这些生成的代码，无论什么样的语言，都可以使用同样的格式编解码。<br>这也是不同 service 可以使用不同编码语言，且能够互相通信的基础。</p><h4 id="1-2-1-字段标号和模式演变"><a href="#1-2-1-字段标号和模式演变" class="headerlink" title="1.2.1 字段标号和模式演变"></a>1.2.1 字段标号和模式演变</h4><p><strong>模式</strong>，即有哪些字段，字段分别为什么类型。<br>在模式发生改变后，需要：</p><ol><li><strong>向后兼容</strong>：新的代码，在处理新的增量数据格式的同时，也得处理旧的存量数据。</li><li><strong>向前兼容</strong>：旧的代码，如果遇到新的数据格式，不能 crash。</li><li>ProtoBuf 和 Thrift 是怎么处理？ <ol><li><strong>字段标号</strong> + <strong>限定符</strong>（optional、required） </li><li>向后兼容：新加的字段需为 optional。这样在解析旧数据时，才不会出现字段缺失的情况。 </li><li>向前兼容：字段标号不能修改，只能追加。这样旧代码在看到不认识的标号时，省略即可。</li></ol></li></ol><h4 id="1-2-2-数据类型和模式演变"><a href="#1-2-2-数据类型和模式演变" class="headerlink" title="1.2.2 数据类型和模式演变"></a>1.2.2 数据类型和模式演变</h4><ul><li>修改数据类型比较麻烦：只能够在相容类型中进行修改。</li><li>如不能将字符串修改为整形，但是可以在整形内修改：32 bit 到 64 bit 整形。</li><li>ProtoBuf 没有列表类型，而有一个 repeated 类型。其好处在于<strong>兼容数组类型</strong>的同时，支持将可选（optional）<strong>单值字段</strong>，修改为<strong>多值字段</strong>。修改后，旧代码在看到新的多值字段时，只会使用最后一个元素。</li></ul><h3 id="1-3-模式的优点"><a href="#1-3-模式的优点" class="headerlink" title="1.3 模式的优点"></a>1.3 模式的优点</h3><p>模式的本质是显式类型约束， 先有模式，再有数据<br><strong>基于显式定义二进制编码优点有：</strong></p><ol><li>省去字段名，从而更加紧凑。</li><li>模式是数据的注释或者文档，并且总是最新的。</li><li>数据模式允许不读取数据，仅比对模式来做低成本的兼容性检查。</li><li>对于静态类型来说，可以利用代码生成做编译时的类型检查。<h2 id="2-几种数据流模式"><a href="#2-几种数据流模式" class="headerlink" title="2 几种数据流模式"></a>2 几种数据流模式</h2></li></ol><ul><li>数据可以以很多种形式从一个系统流向另一个系统，但不变的是，流动时都需要编码与解码。</li><li>在数据流动时，会涉及编解码双方模式匹配问题</li><li>几种进程间典型的数据流方式：<ul><li>通过数据库</li><li>通过服务调用</li><li>通过异步消息传递</li></ul></li></ul><h3 id="2-1-数据库"><a href="#2-1-数据库" class="headerlink" title="2.1 数据库"></a>2.1 数据库</h3><ol><li><strong>只由同一个进程访问</strong>。则数据库可以理解为该进程向将来发送数据的中介。</li><li><strong>由多个进程访问</strong>。则多个进程可能有的是旧版本，有的是新版本，此时数据库需要考虑向前和向后兼容的问题。</li></ol><p>对于应用程序，可能很短时间就可以由旧版本替换为新版本。但是对于数据，旧版本的代码写入的数据量，经年累月，可能很大。在变更了模式之后，由于这些旧模式的数据量很大，全部更新对齐到新版本的代价很高。<br>这种情况我们称之为：<strong>数据的生命周期超过了其对应代码的生命周期</strong>。<br>在读取时，数据库一般会对缺少对应列的旧数据：</p><ol><li>填充新版本字段的<strong>默认值</strong>（default value）</li><li>如果没有默认值则填充<strong>空值</strong>（nullable）<br>后返回给用户。一般来说，在更改模式时（比如 alter table），数据库不允许增加既没有默认值、也不允许为空的列。</li></ol><p>有时候需要对数据库做备份到外存。在做备份（或者说快照）时，虽然会有不同时间点生成的数据，但通常会将各种版本数据转化、对齐到最新版本。毕竟，总是要全盘拷贝数据，那就顺便做下转换好了。</p><h3 id="2-2-经由服务的数据流：REST-和-RPC"><a href="#2-2-经由服务的数据流：REST-和-RPC" class="headerlink" title="2.2 经由服务的数据流：REST 和 RPC"></a>2.2 经由服务的数据流：REST 和 RPC</h3><ul><li>通过网络通信时，通常涉及两种角色：服务器（server）和客户端（client）。</li><li>通常来说，暴露于公网的多为 HTTP 服务，而 RPC 服务常在内部使用。</li><li>服务器也可以同时是客户端：<ol><li>作为客户端访问数据库。</li><li>作为客户端访问其他服务。</li></ol></li><li>对于后者，是因为我们常把一个大的服务拆成一组功能独立、相对解耦的服务，这就是 <strong>面向服务的架构（service-oriented architecture，SOA）</strong>，或者最近比较火的<strong>微服务架构（micro-services architecture）</strong>。</li><li>服务在某种程度上和数据库类似：允许客户端以某种方式存储和查询数据。但不同的是，数据库通常提供某种灵活的查询语言，而服务只能提供相对死板的 API。</li></ul><h4 id="2-2-1-web-服务"><a href="#2-2-1-web-服务" class="headerlink" title="2.2.1 web 服务"></a>2.2.1 web 服务</h4><p>两种设计 HTTP API 的方法：REST 和 SOAP。</p><ol><li><strong>REST 并不是一种协议，而是一种设计哲学</strong>。它强调简单的 API 格式，使用 URL 来标识资源，使用 HTTP 的动作（GET、POST、PUT、DELETE）来对资源进行增删改查。由于其简洁风格，越来越受欢迎。</li><li>SOAP 是基于 XML 的协议。虽然使用 HTTP，但目的在于独立于 HTTP。现在提的比较少了。</li></ol><h4 id="2-2-2-RPC-面临的问题"><a href="#2-2-2-RPC-面临的问题" class="headerlink" title="2.2.2 RPC 面临的问题"></a>2.2.2 RPC 面临的问题</h4><ol><li>本地函数调用要么成功、要么不成功。但是 RPC 由于经过网络，可能会有各种复杂情况，比如请求丢失、响应丢失、hang 住以至于超时等等。因此，可能需要重试。</li><li>如果重试，需要考虑<strong>幂等性</strong>问题。因为上一次的请求可能已经到达了服务端，只是请求没有成功返回。那么多次调用远端函数，就要保证不会造成额外副作用。</li><li>远端调用延迟不可用，受网络影响较大。</li><li>客户端与服务端使用的编程语言可能不同，但如果有些类型不是两种语言都有，就会出一些问题<h4 id="2-2-3-RPC-当前方向"><a href="#2-2-3-RPC-当前方向" class="headerlink" title="2.2.3 RPC 当前方向"></a>2.2.3 RPC 当前方向</h4></li><li>比如局域网的网络通常比较快速、可控。</li><li>多次调用，使用幂等性来解决。</li><li>跨语言，可以使用 RPC 框架的 IDL 来解决。</li></ol><h4 id="2-2-4-数据编码和-RPC-的演化"><a href="#2-2-4-数据编码和-RPC-的演化" class="headerlink" title="2.2.4 数据编码和 RPC 的演化"></a>2.2.4 数据编码和 RPC 的演化</h4><p>通过服务的数据流通常可以假设：所有的服务端先更新，然后客户端再更新。因此，只需要在请求里考虑后向兼容性，在响应中考虑前向兼容性：</p><ol><li>Thrift、gRPC（Protobuf）和 Avro RPC 可以根据编码格式的兼容性规则进行演变。</li><li>RESTful API 通常使用 JSON 作为请求响应的格式，JSON 比较容易添加新的字段来进行演进和兼容。</li><li>SOAP 按下不表。<br>对于 RPC，服务的兼容性比较困难，因为一旦 RPC 服务的 SDK 提供出去之后，你就无法对其生命周期进行控制：总有用户因为各种原因，不会进行主动升级。因此可能需要长期保持兼容性，或者提前通知和不断预告，或者维护多个版本 SDK 并逐渐对早期版本进行淘汰。<br>对于 RESTful API，常用的兼容方法是，将版本号做到 URL 或者 HTTP 请求头中。</li></ol><h3 id="2-3-经由消息传递的数据流"><a href="#2-3-经由消息传递的数据流" class="headerlink" title="2.3 经由消息传递的数据流"></a>2.3 经由消息传递的数据流</h3><p>介于数据库和 RPC 间的<strong>异步消息系统</strong>：一个存储（消息 broker、消息队列来临时存储消息）+ 两次 RPC（生产者一次，消费者一次）。<br>与 RPC 相比，使用消息队列的优点：</p><ol><li>如果消费者暂时不可用，可以充当暂存系统。</li><li>当消费者宕机重启后，自动地重新发送消息。</li><li>生产者不必知道消费者 IP 和端口。</li><li>能将一条消息发送给多个消费者。</li><li>将生产者和消费者解耦。</li></ol><h4 id="2-3-1-消息队列"><a href="#2-3-1-消息队列" class="headerlink" title="2.3.1 消息队列"></a>2.3.1 消息队列</h4><p>消息队列的<strong>送达保证</strong>因实现和配置而异，包括：</p><ol><li><strong>最少一次（at-least-once）</strong>：同一条数据可能会送达多次给消费者。</li><li><strong>最多一次（at-most-once）</strong>：同一条数据最多会送达一次给消费者，有可能丢失。</li><li><strong>严格一次（exactly-once）</strong>：同一条数据保证会送达一次，且最多一次给消费者。</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;编码主要涉及两方面问题：如何编码能够节省空间、提高性能;&lt;br&gt; 如何编码以适应数据的演化和兼容。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="阅读笔记" scheme="https://stardustorz.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DDIA" scheme="https://stardustorz.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/DDIA/"/>
    
    
    <category term="DDIA" scheme="https://stardustorz.github.io/tags/DDIA/"/>
    
  </entry>
  
  <entry>
    <title>[DDIA] 存储和查询</title>
    <link href="https://stardustorz.github.io/2023/05/24/DDIA/02%20%E5%AD%98%E5%82%A8%E5%92%8C%E6%9F%A5%E8%AF%A2/"/>
    <id>https://stardustorz.github.io/2023/05/24/DDIA/02%20%E5%AD%98%E5%82%A8%E5%92%8C%E6%9F%A5%E8%AF%A2/</id>
    <published>2023-05-23T16:00:00.000Z</published>
    <updated>2025-03-09T16:09:34.533Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>数据库底层如何处理查询和存储。</p></blockquote><span id="more"></span><p>数据库底层如何处理查询和存储。这其中，有个<strong>逻辑链条</strong>：</p><blockquote><p>使用场景 → 查询类型 → 存储格式。</p></blockquote><p><strong>查询类型</strong></p><ul><li><strong>OLTP</strong><ul><li>侧重在线交易，数据量不大，瓶颈为寻找数据</li><li>行存储</li><li>流派<ul><li>log-structured： 只追加，把随机写改成顺序，类似LevelDB等</li><li>update-in-place：以页为单位修改，主流的关系型数据库，采用b族树的</li></ul></li></ul></li><li><strong>OLAP</strong><ul><li>侧重离线分析，数据量大</li><li>列存储逐渐流行</li></ul></li></ul><h2 id="1-底层数据结构"><a href="#1-底层数据结构" class="headerlink" title="1 底层数据结构"></a>1 底层数据结构</h2><blockquote><p>为了加快读，我们需要构建<strong>索引</strong>：一种允许基于某些字段查找的额外数据结构。</p></blockquote><p>存储引擎设计和选择时最常见的<strong>权衡（trade off）</strong>：</p><ol><li>恰当的<strong>存储格式</strong>能加快写（日志结构），但是会让读取很慢；也可以加快读（查找树、B 族树），但会让写入较慢。</li><li>为了弥补读性能，可以构建索引。但是会牺牲写入性能和耗费额外空间。</li></ol><h3 id="1-1-哈希索引"><a href="#1-1-哈希索引" class="headerlink" title="1.1 哈希索引"></a>1.1 哈希索引</h3><p>所有数据顺序追加到磁盘上。为了加快查询，我们在内存中构建一个哈希索引：</p><ol><li>Key 是查询 Key</li><li>Value 是 KV 条目的起始位置和长度。</li><li><strong>以顺序写代替随机写</strong>。对于磁盘和 SSD，顺序写都要比随机写快几个数量级。</li><li><strong>简易的并发控制</strong>。由于大部分的文件都是<strong>不可变（immutable）</strong> 的，因此更容易做并发读取和紧缩。也不用担心原地更新会造成新老数据交替。</li><li><strong>更少的内部碎片</strong>。每次紧缩会将垃圾完全挤出。但是原地更新就会在 page 中留下一些不可用空间。</li></ol><h3 id="1-2-SSTables-和-LSM-Trees"><a href="#1-2-SSTables-和-LSM-Trees" class="headerlink" title="1.2 SSTables 和 LSM-Trees"></a>1.2 SSTables 和 LSM-Trees</h3><blockquote><p>加一个限制，让这些文件按 key 有序。我们称这种格式为：SSTable（Sorted String Table）</p></blockquote><h4 id="1-2-1-构建和维护"><a href="#1-2-1-构建和维护" class="headerlink" title="1.2.1 构建和维护"></a>1.2.1 构建和维护</h4><p><strong>构建 SSTable 文件</strong>。将乱序数据在外存（磁盘 or SSD）中上整理为有序文件，是比较难的。但是在内存就方便的多。于是一个大胆的想法就形成了：</p><ol><li>在内存中维护一个有序结构（称为 <strong>MemTable</strong>）。红黑树、AVL 树、跳表。</li><li>到达一定阈值之后全量 dump 到外存。<br><strong>维护 SSTable 文件</strong>。为什么需要维护呢？首先要问，对于上述复合结构，我们怎么进行查询：</li><li>先去 MemTable 中查找，如果命中则返回。</li><li>再去 SSTable 按时间顺序由新到旧逐一查找。<br>如果 SSTable 文件越来越多，则查找代价会越来越大。因此需要将多个 SSTable 文件合并，以减少文件数量，同时进行 GC，我们称之为<strong>紧缩</strong>（ Compaction）。</li></ol><h4 id="1-2-2-从-SSTables-到-LSM-Tree"><a href="#1-2-2-从-SSTables-到-LSM-Tree" class="headerlink" title="1.2.2 从 SSTables 到 LSM-Tree"></a>1.2.2 从 SSTables 到 LSM-Tree</h4><ul><li>将前面几节的一些碎片有机的组织起来，便是时下流行的存储引擎 LevelDB 和 RocksDB 后面的存储结构：LSM-Tree</li><li>LSM-Tree 的核心思想——<strong>保存一组合理组织、后台合并的 SSTables</strong> ——简约而强大。可以方便的进行范围遍历，可以变大量随机为少量顺序。<h4 id="1-2-3-性能优化"><a href="#1-2-3-性能优化" class="headerlink" title="1.2.3 性能优化"></a>1.2.3 性能优化</h4><strong>优化 SSTable 的查找</strong>。常用 <a href="https://www.qtmuniao.com/2020/11/18/leveldb-data-structures-bloom-filter/"><strong>Bloom Filter</strong></a>。该数据结构可以使用较少的内存为每个 SSTable 做一些指纹，起到一些初筛的作用。<br><strong>层级化组织 SSTable</strong>。以控制 Compaction 的顺序和时间。常见的有 size-tiered 和 leveled compaction。LevelDB 便是支持后者而得名。前者比较简单粗暴，后者性能更好，也因此更为常见。</li></ul><h3 id="1-3-B-族树"><a href="#1-3-B-族树" class="headerlink" title="1.3 B 族树"></a>1.3 B 族树</h3><ol><li>以页（在磁盘上叫 page，在内存中叫 block，通常为 4k）为单位进行组织。</li><li>页之间以页 ID 来进行逻辑引用，从而组织成一颗磁盘上的树。</li></ol><ul><li><strong>查找</strong>。从根节点出发，进行二分查找，然后加载新的页到内存中，继续二分，直到命中或者到叶子节点。查找复杂度，树的高度—— O(lgn)，影响树高度的因素：分支因子（分叉数，通常是几百个）。</li><li><strong>插入 or 更新</strong>。和查找过程一样，定位到原 Key 所在页，插入或者更新后，将页完整写回。如果页剩余空间不够，则分裂后写入。</li></ul><h4 id="1-3-1-可靠保证："><a href="#1-3-1-可靠保证：" class="headerlink" title="1.3.1 可靠保证："></a>1.3.1 可靠保证：</h4><p>在树结构调整时，可能会级联修改很多 Page。比如叶子节点分裂后，就需要写入两个新的叶子节点，和一个父节点（更新叶子指针）。</p><ol><li>增加预写日志（WAL），将所有修改操作记录下来，预防宕机时中断树结构调整而产生的混乱现场。</li><li>使用 latch 对树结构进行并发控制。</li></ol><h4 id="1-3-2-优化"><a href="#1-3-2-优化" class="headerlink" title="1.3.2 优化"></a>1.3.2 优化</h4><ol><li>不使用 WAL，而在写入时利用 Copy On Write 技术。同时，也方便了并发控制。如 LMDB、BoltDB。</li><li>对中间节点的 Key 做压缩，保留足够的路由信息即可。以此，可以节省空间，增大分支因子。</li><li>为了优化范围查询，有的 B 族树将叶子节点存储时物理连续。但当数据不断插入时，维护此有序性的代价非常大。</li><li>为叶子节点增加兄弟指针，以避免顺序遍历时的回溯。即 B+ 树的做法，但远不局限于 B+ 树。</li><li>B 树的变种，分形树，从 LSM-tree 借鉴了一些思想以优化 seek。</li></ol><h4 id="1-3-3-对比"><a href="#1-3-3-对比" class="headerlink" title="1.3.3 对比"></a>1.3.3 对比</h4><ul><li>LSM-Tree  写入更快，更加紧凑  但是同一个 Key 存多遍</li><li>B Tree 读取更快，范围锁更方便</li></ul><h3 id="1-4-其他索引结构"><a href="#1-4-其他索引结构" class="headerlink" title="1.4 其他索引结构"></a>1.4 其他索引结构</h3><p><strong>次级索引（secondary indexes）</strong>。即，非主键的其他属性到该元素（SQL 中的行，MongoDB 中的文档和图数据库中的点和边）的映射。</p><h4 id="1-4-1-聚集索引和非聚集索引（cluster-indexes-and-non-cluster-indexes）"><a href="#1-4-1-聚集索引和非聚集索引（cluster-indexes-and-non-cluster-indexes）" class="headerlink" title="1.4.1 聚集索引和非聚集索引（cluster indexes and non-cluster indexes）"></a>1.4.1 聚集索引和非聚集索引（cluster indexes and non-cluster indexes）</h4><ol><li>数据本身<strong>无序</strong>的存在文件中，称为 <strong>堆文件（heap file）</strong>，索引的值指向对应数据在 heap file 中的位置。这样可以避免多个索引时的数据拷贝。</li><li>数据本身按某个字段有序存储，该字段通常是主键。则称基于此字段的索引为<strong>聚集索引</strong>（clustered index），从另外一个角度理解，即将索引和数据存在一块。则基于其他字段的索引为<strong>非聚集索引</strong>，在索引中仅存数据的引用。</li><li>一部分列内嵌到索引中存储，一部分列数据额外存储。称为<strong>覆盖索引（covering index）</strong>   或  <strong>包含列的索引（index with included columns）</strong>。</li></ol><h4 id="1-4-2-多列索引"><a href="#1-4-2-多列索引" class="headerlink" title="1.4.2 多列索引"></a>1.4.2 多列索引</h4><ol><li>将二维编码为一维，然后按普通索引存储。</li><li>使用特殊数据结构，如 R 树。</li></ol><h4 id="1-4-3-全文索引和模糊索引"><a href="#1-4-3-全文索引和模糊索引" class="headerlink" title="1.4.3 全文索引和模糊索引"></a>1.4.3 全文索引和模糊索引</h4><p>前述索引只提供全字段的精确匹配，而不提供类似搜索引擎的功能。比如，按字符串中包含的单词查询，针对笔误的单词查询。</p><p>在工程中常用 <a href="https://lucene.apache.org/" title="Apace Lucene">Apace Lucene</a> 库，和其包装出来的服务：<a href="https://www.elastic.co/cn/" title="Elasticsearch">Elasticsearch</a>。他也使用类似 LSM-tree 的日志存储结构，但使用其索引进行模糊匹配的过程，本质上是一个有限状态自动机，在行为上类似 Trie 树。</p><h4 id="1-4-4-全内存数据结构"><a href="#1-4-4-全内存数据结构" class="headerlink" title="1.4.4 全内存数据结构"></a>1.4.4 全内存数据结构</h4><p>根据是否需要持久化，内存数据大概可以分为两类：</p><ol><li><strong>不需要持久化</strong>。如只用于缓存的 Memcached。</li><li><strong>需要持久化</strong>。通过 WAL、定期 snapshot、远程备份等等来对数据进行持久化。但使用内存处理全部读写，因此仍是内存数据库。</li></ol><h2 id="2-事务型还是分析型"><a href="#2-事务型还是分析型" class="headerlink" title="2 事务型还是分析型"></a>2 事务型还是分析型</h2><p>术语 <strong>OL</strong>（Online）主要是指交互式的查询。<br>术语<strong>事务</strong>（transaction）由来有一些历史原因。早期的数据库使用方多为商业交易（commercial），比如买卖、发工资等等。但是随着数据库应用不断扩大，交易\事务作为名词保留了下来。</p><p>事务不一定具有 ACID 特性，事务型处理多是随机的以较低的延迟进行读写，与之相反，分析型处理多为定期的批处理，延迟较高。</p><h4 id="2-1-1-数据仓库"><a href="#2-1-1-数据仓库" class="headerlink" title="2.1.1 数据仓库"></a>2.1.1 数据仓库</h4><p>需要一种手段将数据从原库导入到专门的<strong>数仓</strong>。<br>我们称之为 <strong>ETL：extract-transform-load</strong>。</p><h3 id="2-2-AP-建模：星状型和雪花型"><a href="#2-2-AP-建模：星状型和雪花型" class="headerlink" title="2.2 AP 建模：星状型和雪花型"></a>2.2 AP 建模：星状型和雪花型</h3><p>星状模型通常包含一张<strong>事件表（<em>fact table</em>）</strong> 和多张<strong>维度表（<em>dimension tables</em>）</strong>。事件表以事件流的方式将数据组织起来，然后通过外键指向不同的维度。</p><p>星状模型的一个变种是雪花模型，可以类比雪花（❄️）图案，其特点是在维度表中会进一步进行二次细分，讲一个维度分解为几个子维度。比如品牌和产品类别可能有单独的表格。星状模型更简单，雪花模型更精细，具体应用中会做不同取舍。</p><p>在典型的数仓中，事件表可能会非常宽，即有很多的列：一百到数百列。</p><h2 id="3-列存"><a href="#3-列存" class="headerlink" title="3 列存"></a>3 列存</h2><p><strong>维度表</strong>和<strong>事实表</strong>，对于后者来说，有可能达到数十亿行和数 PB 大。虽然事实表可能通常有几十上百列，但是单次查询通常只关注其中几个维度（列）。</p><h3 id="3-1-列压缩"><a href="#3-1-列压缩" class="headerlink" title="3.1 列压缩"></a>3.1 列压缩</h3><p>将所有数据分列存储在一块，带来了一个意外的好处，由于同一属性的数据相似度高，因此更易压缩。</p><p>如果每一列中值阈相比行数要小的多，可以用<strong>位图编码（<em><a href="https://en.wikipedia.org/wiki/Bitmap_index" title="bitmap encoding">bitmap encoding</a></em>）</strong>。举个例子，零售商可能有数十亿的销售交易，但只有 100,000 个不同的产品。</p><h3 id="3-2-列式存储的排序"><a href="#3-2-列式存储的排序" class="headerlink" title="3.2 列式存储的排序"></a>3.2 列式存储的排序</h3><p>可以如 LSM-Tree 一样，对所有行按某一列进行排序后存储。</p><ul><li>不同副本，不同排序</li></ul><h3 id="3-3-列式存储的写入"><a href="#3-3-列式存储的写入" class="headerlink" title="3.3 列式存储的写入"></a>3.3 列式存储的写入</h3><ol><li>将新写入的数据在<strong>内存</strong>中 Batch 好，按行按列，选什么数据结构可以看需求。</li><li>然后达到一定阈值后，批量刷到<strong>外存</strong>，并与老数据合并。</li></ol><h3 id="3-4-聚合：数据立方和物化视图"><a href="#3-4-聚合：数据立方和物化视图" class="headerlink" title="3.4 聚合：数据立方和物化视图"></a>3.4 聚合：数据立方和物化视图</h3><p>数据仓库查询通常涉及聚合函数，如 SQL 中的 COUNT、SUM、AVG、MIN 或 MAX。如果这些函数被多次用到，每次都即时计算显然存在巨大浪费。因此一个想法就是，能不能将其缓存起来。</p><p>其与关系数据库中的<strong>视图</strong>（View）区别在于，视图是<strong>虚拟的、逻辑存在</strong>的，只是对用户提供的一种抽象，是一个查询的中间结果，并没有进行持久化（有没有缓存就不知道了）。</p><p>物化视图本质上是对数据的一个摘要存储，如果原数据发生了变动，该视图要被重新生成。因此，如果<strong>写多读少</strong>，则维持物化视图的代价很大。但在数仓中往往反过来，因此物化视图才能较好的起作用。</p><p>物化视图一个特化的例子，是<strong>数据立方</strong>（data cube，或者 OLAP cube）：按不同维度对量化数据进行聚合。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;数据库底层如何处理查询和存储。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="阅读笔记" scheme="https://stardustorz.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DDIA" scheme="https://stardustorz.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/DDIA/"/>
    
    
    <category term="DDIA" scheme="https://stardustorz.github.io/tags/DDIA/"/>
    
  </entry>
  
  <entry>
    <title>[DDIA] 可靠、可拓展、可维护</title>
    <link href="https://stardustorz.github.io/2023/05/17/DDIA/01%20%E5%8F%AF%E9%9D%A0%E3%80%81%E5%8F%AF%E6%8B%93%E5%B1%95%E3%80%81%E5%8F%AF%E7%BB%B4%E6%8A%A4/"/>
    <id>https://stardustorz.github.io/2023/05/17/DDIA/01%20%E5%8F%AF%E9%9D%A0%E3%80%81%E5%8F%AF%E6%8B%93%E5%B1%95%E3%80%81%E5%8F%AF%E7%BB%B4%E6%8A%A4/</id>
    <published>2023-05-16T16:00:00.000Z</published>
    <updated>2025-03-09T16:09:30.086Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如何评价一个好数据系统，如何构建一个好的数据系统，有哪些可以遵循的设计模式？有哪些通常需要考虑的方面？</p></blockquote><span id="more"></span><h2 id="Why-Data-System"><a href="#Why-Data-System" class="headerlink" title="Why Data System"></a>Why Data System</h2><h3 id="常见的数据系统"><a href="#常见的数据系统" class="headerlink" title="常见的数据系统"></a>常见的数据系统</h3><ul><li>存储数据，以便之后再次使用——<strong>数据库</strong></li><li>记住一些非常“重”的操作结果，方便之后加快读取速度——<strong>缓存</strong></li><li>允许用户以各种关键字搜索、以各种条件过滤数据——<strong>搜索引擎</strong></li><li>源源不断的产生数据、并发送给其他进程进行处理——<strong>流式处理</strong></li><li>定期处理累积的大量数据——<strong>批处理</strong></li><li>进行消息的传送与分发——<strong>消息队列</strong></li></ul><h3 id="数据系统的复杂化"><a href="#数据系统的复杂化" class="headerlink" title="数据系统的复杂化"></a>数据系统的复杂化</h3><blockquote><p>如何评价一个好数据系统，如何构建一个好的数据系统，有哪些可以遵循的设计模式？有哪些通常需要考虑的方面？</p><ol><li><strong>Kafka</strong>：可以作为存储持久化一段时间日志数据、可以作为消息队列对数据进行分发、可以作为流式处理组件对数据反复蒸馏等等。</li><li><strong>Spark</strong>：可以对数据进行批处理、也可以化小批为流，对数据进行流式处理。</li><li><strong>Redis</strong>：可以作为缓存加速对数据库的访问、也可以作为事件中心对消息的发布订阅。<br><strong>常见的问题：</strong></li><li>使用何种缓存策略？是旁路还是写穿透？</li><li>部分组件机器出现问题时，是保证可用性还是保证一致性？</li><li>当机器一时难以恢复，如何保证数据的正确性和完整性？</li><li>当负载增加时，是增加机器还是提升单机性能？</li><li>设计对外的 API 时，是力求简洁还是追求强大？</li></ol></blockquote><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>如何衡量？</p><ul><li><strong>功能上</strong><ol><li>正常情况下，应用行为满足 API 给出的行为</li><li>在用户误输入/误操作时，能够正常处理</li></ol></li><li><strong>性能上</strong> 在给定硬件和数据量下，能够满足承诺的性能指标。</li><li><strong>安全上</strong> 能够阻止未授权、恶意破坏。</li><li>可用性也是可靠性的一个侧面，云服务通常以多少个 9 来衡量可用性。<br>两个易混淆的概念：<strong>Fault（系统出现问题）</strong> 和 <strong>Failure（系统不能提供服务）</strong></li></ul><h3 id="硬件故障"><a href="#硬件故障" class="headerlink" title="硬件故障"></a>硬件故障</h3><p>网络抖动、不通， 硬盘损坏， 机房断电等情况</p><p>数据系统中常见的需要考虑的硬件指标：</p><ul><li><strong>MTTF mean time to failure</strong> 单块盘 平均故障时间 5 ~10 年，如果你有 1w+ 硬盘，则均匀期望下，每天都有坏盘出现。当然事实是硬盘会一波一波坏。<br>解决办法，增加冗余度：机房多路供电，双网络等等。<br>对于数据：</li><li><strong>单机</strong>：可以做 RAID 冗余。如：EC 编码。</li><li><strong>多机</strong>：多副本 或 EC 编码。</li></ul><h3 id="软件错误"><a href="#软件错误" class="headerlink" title="软件错误"></a>软件错误</h3><ol><li>不能处理特定输入，导致系统崩溃。</li><li>失控进程（如循环未释放资源）耗尽 CPU、内存、网络资源。</li><li>系统依赖组件变慢甚至无响应。</li><li>级联故障。</li></ol><p>在设计软件时，我们通常有一些<strong>环境假设</strong>，和一些<strong>隐性约束</strong>。随着时间的推移、系统的持续运行，如果这些假设不能够继续被满足；如果这些约束被后面维护者增加功能时所破坏；都有可能让一开始正常运行的系统，突然崩溃。</p><h3 id="人为问题"><a href="#人为问题" class="headerlink" title="人为问题"></a>人为问题</h3><ul><li><strong>设计编码</strong><ol><li>尽可能消除所有不必要的假设，提供合理的抽象，仔细设计 API</li><li>进程间进行隔离，对尤其容易出错的模块使用沙箱机制</li><li>对服务依赖进行熔断设计</li></ol></li><li><strong>测试阶段</strong><ol><li>尽可能引入第三方成员测试，尽量将测试平台自动化</li><li>单元测试、集成测试、e2e 测试、混沌测试</li></ol></li><li><strong>运行阶段</strong><ol><li>详细的仪表盘</li><li>持续自检</li><li>报警机制</li><li>问题预案</li></ol></li><li><strong>针对组织</strong><ol><li>科学的培训和管理</li></ol></li></ul><h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><h3 id="衡量负载"><a href="#衡量负载" class="headerlink" title="衡量负载"></a>衡量负载</h3><p>应对负载之前，要先找到合适的方法来衡量负载，如<strong>负载参数（load parameters）</strong>：</p><ul><li>应用日活月活</li><li>每秒向 Web 服务器发出的请求</li><li>数据库中的读写比率</li><li>聊天室中同时活跃的用户数量</li></ul><p>以 2012 年 11 月 推特为例</p><ul><li>主营业务：发布推文、首页 Feed 流</li><li>请求量级：发布推文（平均 4.6k 请求/秒，峰值超过 12k 请求/秒），查看其他人推文（300k 请求/秒）</li><li>需要根据用户之间的关注与被关注关系来对数据进行多次处理。常见的有推拉两种方式：<ol><li><strong>拉</strong>。每个人查看其首页 Feed 流时，从数据库现<strong>拉取</strong>所有关注用户推文，合并后呈现。</li><li><strong>推</strong>。为每个用户保存一个 Feed 流视图，当用户发推文时，将其插入所有关注者 Feed 流视图中。</li></ol></li></ul><h3 id="描述性能"><a href="#描述性能" class="headerlink" title="描述性能"></a>描述性能</h3><p>注意和系统负载区分，系统负载是从用户视角来审视系统，是一种<strong>客观指标</strong>。而系统性能则是描述的系统的一种<strong>实际能力</strong>。比如：</p><ol><li><strong>吞吐量（throughput）</strong>：每秒可以处理的单位数据量，通常记为 QPS。</li><li><strong>响应时间（response time）</strong>：从用户侧观察到的发出请求到收到回复的时间。</li><li><strong>延迟（latency）</strong>：日常中，延迟经常和响应时间混用指代响应时间；但严格来说，延迟只是指请求过程中排队等休眠时间，虽然其在响应时间中一般占大头；但只有我们把请求真正处理耗时认为是瞬时，延迟才能等同于响应时间。<br>响应时间通常以百分位点来衡量，比如 p95，p99 和 p999，它们意味着 95％，99％或 99.9％ 的请求都能在该阈值内完成。在实际中，通常使用滑动窗口滚动计算最近一段时间的响应时间分布，并通常以折线图或者柱状图进行呈现。</li></ol><h3 id="应对负载"><a href="#应对负载" class="headerlink" title="应对负载"></a>应对负载</h3><p>如何应对负载的不断增长，即使系统具有可扩展性。</p><ol><li><strong>纵向扩展（scaling up）或 垂直扩展（vertical scaling）</strong>：换具有更强大性能的机器。e.g. 大型机机器学习训练。</li><li><strong>横向扩展（scaling out）或 水平扩展（horizontal scaling）</strong>：“并联”很多廉价机，分摊负载。e.g. 马斯克造火箭。<br>负载扩展的两种方式：</li></ol><ul><li><strong>自动</strong> 如果负载不好预测且多变，则自动较好。坏处在于不易跟踪负载，容易抖动，造成资源浪费。</li><li><strong>手动</strong> 如果负载容易预测且不长变化，最好手动。设计简单，且不容易出错。</li></ul><p>两种服务类型：</p><ul><li><strong>无状态服务</strong> 比较简单，多台机器，外层罩一个 gateway 就行。</li><li><strong>有状态服务</strong> 根据需求场景，如读写负载、存储量级、数据复杂度、响应时间、访问模式，来进行取舍，设计合乎需求的架构。</li></ul><h2 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h2><ol><li>友好的文档和一致的运维规范。</li><li>细致的监控仪表盘、自检和报警。</li><li>通用的缺省配置。</li><li>出问题时的自愈机制，无法自愈时允许管理员手动介入。</li><li>将维护过程尽可能的自动化。</li><li>避免单点依赖，无论是机器还是人。</li></ol><h3 id="简洁性"><a href="#简洁性" class="headerlink" title="简洁性"></a>简洁性</h3><p>复杂度表现：</p><ol><li>状态空间的膨胀。</li><li>组件间的强耦合。</li><li>不一致的术语和<a href="https://www.qtmuniao.com/2021/12/12/how-to-write-code-scrutinize-names/">命名</a>。</li><li>为了提升性能的 hack。</li><li>随处可见的补丁（workaround）。</li></ol><h3 id="可演化性"><a href="#可演化性" class="headerlink" title="可演化性"></a>可演化性</h3><p>需求一定是不断在变，引起变化的原因多种多样：</p><ol><li>对问题阈了解更全面</li><li>出现了之前未考虑到的用例</li><li>商业策略的改变</li><li>客户爸爸要求新功能</li><li>依赖平台的更迭</li><li>合规性要求</li><li>体量的改变</li></ol><p>合理抽象，合理封装，对修改关闭，对扩展开放。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如何评价一个好数据系统，如何构建一个好的数据系统，有哪些可以遵循的设计模式？有哪些通常需要考虑的方面？&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="阅读笔记" scheme="https://stardustorz.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DDIA" scheme="https://stardustorz.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/DDIA/"/>
    
    
    <category term="DDIA" scheme="https://stardustorz.github.io/tags/DDIA/"/>
    
  </entry>
  
  <entry>
    <title>[DDIA] 数据模型和查询语言</title>
    <link href="https://stardustorz.github.io/2023/05/16/DDIA/00%20%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/"/>
    <id>https://stardustorz.github.io/2023/05/16/DDIA/00%20%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/</id>
    <published>2023-05-15T16:00:00.000Z</published>
    <updated>2025-03-09T16:09:26.990Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>如何分析一个数据模型 &amp; 如何考量查询语言</p></blockquote><span id="more"></span><h2 id="1-概要"><a href="#1-概要" class="headerlink" title="1 概要"></a>1 概要</h2><p>如何分析一个<strong>数据模型</strong>：</p><ol><li>基本考察点：数据基本元素，和元素之间的对应关系（一对多，多对多）</li><li>利用几种常用模型来比较：（最为流行的）关系模型，（树状的）文档模型，（极大自由度的）图模型。</li><li>schema 模式：强 Schema（写时约束）；弱 Schema（读时解析）</li></ol><p>如何考量<strong>查询语言</strong>：</p><ol><li>如何与数据模型关联、匹配</li><li>声明式（declarative）和命令式（imperative）</li></ol><h3 id="1-1-数据模型"><a href="#1-1-数据模型" class="headerlink" title="1.1 数据模型"></a>1.1 数据模型</h3><blockquote><p>A data model is an abstract model that organizes elements of data and standardizes how they relate to one another and to the properties of real-world entities. —<a href="https://en.wikipedia.org/wiki/Data_model">https://en.wikipedia.org/wiki/Data_model</a></p></blockquote><p><strong>数据模型</strong>：如何组织数据，如何标准化关系，如何关联现实。</p><ol><li>作为<strong>应用开发者，</strong> 你将现实中的具体问题抽象为一组对象、<strong>数据结构（data structure）</strong> 以及作用于其上的 API。</li><li>作为<strong>数据库管理员（DBA）</strong>，为了持久化上述数据结构，你需要将他们表达为通用的<strong>数据模型（data model）</strong>，如文档数据库中的 XML/JSON、关系数据库中的表、图数据库中的图。</li><li>作为<strong>数据库系统开发者</strong>，你需要将上述数据模型组织为内存中、硬盘中或者网络中的<strong>字节（Bytes）</strong> 流，并提供多种操作数据集合的方法。</li><li>作为<strong>硬件工程师</strong>，你需要将字节流表示为二极管的电位（内存）、磁场中的磁极（磁盘）、光纤中的光信号（网络）。</li></ol><h2 id="2-关系模型与文档模型"><a href="#2-关系模型与文档模型" class="headerlink" title="2 关系模型与文档模型"></a>2 关系模型与文档模型</h2><h3 id="2-1-关系模型"><a href="#2-1-关系模型" class="headerlink" title="2.1 关系模型"></a>2.1 关系模型</h3><p>特点如下：</p><ol><li>将数据以<strong>关系</strong>呈现给用户（比如：一组包含行列的二维表）。</li><li><p>提供操作数据集合的<strong>关系算子</strong>。<br><strong>常见分类</strong></p></li><li><p>事务型（TP）：银行交易、火车票</p></li><li>分析型（AP）：数据报表、监控表盘</li><li>混合型（HTAP）：</li></ol><h3 id="2-2-NoSQL"><a href="#2-2-NoSQL" class="headerlink" title="2.2 NoSQL"></a>2.2 NoSQL</h3><ol><li>处理更大数据集：更强伸缩性、更高吞吐量</li><li>开源免费的兴起：冲击了原来把握在厂商的标准</li><li>特化的查询操作：关系数据库难以支持的，比如图中的多跳分析</li><li>表达能力更强：关系模型约束太严，限制太多<h3 id="2-3-面向对象和关系模型的不匹配"><a href="#2-3-面向对象和关系模型的不匹配" class="headerlink" title="2.3 面向对象和关系模型的不匹配"></a>2.3 面向对象和关系模型的不匹配</h3>核心冲突在于面向对象的<strong>嵌套性</strong>和关系模型的<strong>平铺性</strong><br>关系模型很难直观的表示<strong>一对多</strong>的关系。比如简历上，一个人可能有多段教育经历和多段工作经历。<br><strong>文档模型</strong>：使用 Json 和 XML 的天然嵌套。<br><strong>关系模型</strong>：使用 SQL 模型就得将职位、教育单拎一张表，然后在用户表中使用外键关联。<br>在简历的例子中，文档模型还有几个优势：</li><li><strong>模式灵活</strong>：可以动态增删字段，如工作经历。</li><li><strong>更好的局部性</strong>：一个人的所有属性被集中访问的同时，也被集中存储。</li><li><strong>结构表达语义</strong>：简历与联系信息、教育经历、职业信息等隐含一对多的树状关系可以被 JSON 的树状结构明确表达出来。</li></ol><h3 id="2-4-文档模型"><a href="#2-4-文档模型" class="headerlink" title="2.4 文档模型"></a>2.4 文档模型</h3><p>文档型数据库使用场景特点：</p><ol><li>有多种类型的数据，但每个放一张表又不合适。</li><li>数据类型和结构由外部决定，你没办法控制数据的变化。</li></ol><h2 id="3-图模型"><a href="#3-图模型" class="headerlink" title="3 图模型"></a>3 图模型</h2><ul><li>文档模型的适用场景？ 你的建模场景中存在着大量<strong>一对多</strong>（one-to-many）的关系。</li><li>图模型的适用场景？ 你的建模场景中存在大量的<strong>多对多</strong>（many-to-many）的关系。</li><li>图数据模型（属性图）的基本概念一般有三个：<strong>点</strong>，<strong>边</strong>和附着于两者之上的<strong>属性</strong>。</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;如何分析一个数据模型 &amp;amp; 如何考量查询语言&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="阅读笔记" scheme="https://stardustorz.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DDIA" scheme="https://stardustorz.github.io/categories/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/DDIA/"/>
    
    
    <category term="DDIA" scheme="https://stardustorz.github.io/tags/DDIA/"/>
    
  </entry>
  
  <entry>
    <title>[Go] 垃圾回收</title>
    <link href="https://stardustorz.github.io/2022/09/12/Golang/2%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>https://stardustorz.github.io/2022/09/12/Golang/2%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2022-09-11T16:00:00.000Z</published>
    <updated>2025-03-11T16:24:38.999Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>垃圾回收（Garbage Collection，简称 GC）是一种内存管理策略，由垃圾收集器以类似守护协程的方式在后台运作，按照既定的策略为用户回收那些不再被使用的对象，释放对应的内存空间.</p></blockquote><span id="more"></span><h2 id="1-垃圾回收算法"><a href="#1-垃圾回收算法" class="headerlink" title="1 垃圾回收算法"></a>1 垃圾回收算法</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p><strong>GC 带来的优势</strong></p><ul><li>屏蔽内存回收的细节, 使用户更好地聚焦于核心的业务逻辑</li><li>以全局视野执行任务</li></ul><p><strong>GC 带来的劣势</strong></p><ul><li>提高了下限但降低了上限</li><li>增加了额外的成本</li></ul><h3 id="1-2-标记清扫"><a href="#1-2-标记清扫" class="headerlink" title="1.2 标记清扫"></a>1.2 标记清扫</h3><p>标记清扫（Mark-Sweep）算法, 分为两步实现:</p><ul><li>标记：标记出当前还存活的对象</li><li>清扫：清扫掉未被标记到的垃圾对象</li></ul><p>标记清扫通过标记存活对象，从而取补集推断出垃圾对象, 它的缺点在于会产生内存碎片, 这些碎片分散分布的话, 会影响大对象的内存分配.</p><h3 id="1-3-标记压缩"><a href="#1-3-标记压缩" class="headerlink" title="1.3 标记压缩"></a>1.3 标记压缩</h3><p>标记压缩（Mark-Compact）算法，是在标记清扫算法的基础上做了升级，在第二步”清扫“的同时还会对存活对象进行压缩整合，使得整体空间更为紧凑，从而解决内存碎片问题<br>缺陷在于实现时会有很高的复杂度.</p><h3 id="1-4-半空间复制"><a href="#1-4-半空间复制" class="headerlink" title="1.4 半空间复制"></a>1.4 半空间复制</h3><p><strong>半空间复制（Semispace Copy）算法主要实现如下:</strong></p><ul><li>分配两片相等大小的空间，称为 fromspace 和 tospace</li><li>每轮只使用 fromspace 空间，以GC作为分水岭划分轮次</li><li>GC时，将fromspace存活对象转移到tospace中，并以此为契机对空间进行压缩整合</li><li>GC后，交换fromspace和tospace，开启新的轮次</li></ul><p>半空间复制算法应用了以空间换取时间的优化策略，解决了内存碎片的问题，也在一定程度上降低了压缩空间的复杂度. 但其缺点也同样很明显——比较浪费空间<br>Java 所采用的就是半空间复制的升级版</p><h3 id="1-5-引用计数"><a href="#1-5-引用计数" class="headerlink" title="1.5 引用计数"></a>1.5 引用计数</h3><p><strong>引用计数（Reference Counting）主要实现如下:</strong></p><ul><li>对象每被引用一次，计数器加1</li><li>对象每被删除引用一次，计数器减1</li><li>GC时，把计数器等于 0 的对象删除</li></ul><p>缺陷在于无法解决循环引用和自引用的问题</p><h2 id="2-Golang-中的垃圾回收"><a href="#2-Golang-中的垃圾回收" class="headerlink" title="2 Golang 中的垃圾回收"></a>2 Golang 中的垃圾回收</h2><blockquote><p>在 1.8版本之后，Golang 的 GC 策略主要为并发三色标记法+混合写屏障机制</p></blockquote><h3 id="2-1-三色标记法"><a href="#2-1-三色标记法" class="headerlink" title="2.1 三色标记法"></a>2.1 三色标记法</h3><p>Golang GC 中用到的三色标记法属于标记清扫-算法下的一种实现, 主要思路如下:</p><ul><li>对象分为三种颜色标记：黑、灰、白</li><li>黑对象代表，对象自身存活，且其指向对象都已标记完成</li><li>灰对象代表，对象自身存活，但其指向对象还未标记完成</li><li>白对象代表，对象尙未被标记到，可能是垃圾对象</li><li>标记开始前，将根对象（全局对象、栈上局部变量等）置黑，将其所指向的对象置灰</li><li>标记规则是: 从灰对象出发，将其所指向的对象都置灰. 所有指向对象都置灰后，当前灰对象置黑</li><li>标记结束后，白色对象就是不可达的垃圾对象，需要进行清扫</li></ul><h3 id="2-2-并发垃圾回收"><a href="#2-2-并发垃圾回收" class="headerlink" title="2.2 并发垃圾回收"></a>2.2 并发垃圾回收</h3><ul><li>Golang 1.5 版本是个分水岭，在此之前，GC时需要停止全局的用户协程，专注完成GC工作后，再恢复用户协程，这样做在实现上简单直观，但是会对用户造成不好的体验</li><li>自1.5版本以来，Golang引入了并发垃圾回收机制，允许用户协程和后台的GC协程并发运行，大大地提高了用户体验. 但用户协程并发运行时可能对对象间的引用关系进行调整，这会严重打乱GC三色标记时的标记秩序</li></ul><h3 id="2-3-可能的问题"><a href="#2-3-可能的问题" class="headerlink" title="2.3 可能的问题"></a>2.3 可能的问题</h3><ul><li><strong>漏标问题</strong><ul><li>假设只有对象 B 持有对象 C 的引用,如果 GC 协程在 B 删除 C 的引用后才开始扫描 B，就会无法到达 C.  此时从扫描结果上看，C 是不可达的</li><li>针对漏标问题，Golang 给出的解决方案是屏障机制</li></ul></li><li><strong>多标问题</strong><ul><li>假设对象 A 持有对象 B 的引用</li><li>GC协程下，对象 A 被扫描完成，置黑；对象 B 被对象 A 引用，因此被置灰</li><li>用户协程下，对象 A 删除指向对象 B 的引用</li><li>B 在被 A 删除引用后，已成为垃圾对象，但由于其事先已被置灰，因此最终会更新为黑色，不会被 GC 删除</li><li>错标问题对比于漏标问题而言，是相对可以接受的, 至多到下一轮 GC，这部分对象就会被 GC 回收</li></ul></li><li><strong>内存碎片问题</strong><ul><li>Golang采用 TCMalloc 机制，依据对象的大小将其归属为到事先划分好的spanClass当中，这样能够消解外部碎片的问题，将问题限制在相对可控的内部碎片当中</li></ul></li><li><strong>为什么不学 Java 用分代?</strong><ul><li>分代算法指的是，将对象分为年轻代和老年代两部分（或者更多），采用不同的GC策略进行分类管理. 分代GC算法有效的前提是，绝大多数年轻代对象都是朝生夕死，拥有更高的GC回收率，因此适合采用特别的策略进行处理.</li><li>Golang中存在内存逃逸机制，会在编译过程中将生命周期更长的对象转移到堆中，将生命周期短的对象分配在栈上，并以栈为单位对这部分对象进行回收</li><li>综上，内存逃逸机制减弱了分代算法对Golang GC所带来的优势，考虑分代算法需要产生额外的成本（如不同年代的规则映射、状态管理以及额外的写屏障），Golang 选择不采用分代GC算法</li></ul></li></ul><h2 id="3-屏障机制"><a href="#3-屏障机制" class="headerlink" title="3 屏障机制"></a>3 屏障机制</h2><blockquote><p>主要是为了解决2.3小节中提及的并发GC下的漏标问题</p></blockquote><h3 id="3-1-强弱三色不变式"><a href="#3-1-强弱三色不变式" class="headerlink" title="3.1 强弱三色不变式"></a>3.1 强弱三色不变式</h3><p>漏标问题的本质就是，一个已经扫描完成的黑对象指向了一个被灰\白对象删除引用的白色对象. 构成这一场景的要素拆分如下：</p><ol><li>黑色对象指向了白色对象</li><li>灰、白对象删除了白色对象</li><li>（1）、（2）步中谈及的白色对象是同一个对象</li><li>（1）发生在（2）之前</li></ol><p>通过破坏这些要素,可以解决漏标问题, 称为强弱三色不变式:</p><ul><li>强三色不变式：白色对象不能被黑色对象直接引用（直接破坏（1））</li><li>弱三色不变式：白色对象可以被黑色对象引用，但要从某个灰对象出发仍然可达该白对象（间接破坏了（1）、（2）的联动）</li></ul><h3 id="3-2-插入写屏障"><a href="#3-2-插入写屏障" class="headerlink" title="3.2 插入写屏障"></a>3.2 插入写屏障</h3><ul><li>屏障机制类似于一个回调保护机制，指的是在完成某个特定动作前，会先完成屏障成设置的内容</li><li>插入写屏障（Dijkstra）的目标是实现<strong>强三色不变式</strong>，保证当一个黑色对象指向一个白色对象前，会先触发屏障将白色对象置为灰色，再建立引用</li></ul><h3 id="3-3-删除写屏障"><a href="#3-3-删除写屏障" class="headerlink" title="3.3 删除写屏障"></a>3.3 删除写屏障</h3><ul><li>删除写屏障（Yuasa barrier）的目标是实现<strong>弱三色不变式</strong>，保证当一个白色对象即将被上游删除引用前，会触发屏障将其置灰，之后再删除上游指向其的引用</li><li>也就是保证在删除到这个对象 A 的引用后,  对象 A对于 GC 来说依旧是可见的</li></ul><h3 id="3-4-混合写屏障"><a href="#3-4-混合写屏障" class="headerlink" title="3.4 混合写屏障"></a>3.4 混合写屏障</h3><ul><li>插入写屏障、删除写屏障二者择其一，即可解决并发GC的漏标问题，至于错标问题，则采用容忍态度，放到下一轮GC中进行延后处理即可</li><li>但是, 屏障机制无法作用于栈对象, 因为栈对象可能涉及频繁的轻量操作，高频率的触发屏障机制，带来的成本将是无法接受的.</li><li>在 Go1.8 前, 栈上的垃圾对象通过引入额外的Stop the world（STW）阶段解决, 1.18 后,  引入了混合写屏障机制来消除 STW 成本, 主要思路如下:<ul><li>GC 开始前，以栈为单位分批扫描，将栈中所有对象置黑</li><li>GC 期间，栈上新创建对象直接置黑</li><li>堆对象正常启用插入写屏障</li><li>堆对象正常启用删除写屏障</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;垃圾回收（Garbage Collection，简称 GC）是一种内存管理策略，由垃圾收集器以类似守护协程的方式在后台运作，按照既定的策略为用户回收那些不再被使用的对象，释放对应的内存空间.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="内存管理" scheme="https://stardustorz.github.io/categories/Golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Go] 内存分配</title>
    <link href="https://stardustorz.github.io/2022/09/08/Golang/2%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>https://stardustorz.github.io/2022/09/08/Golang/2%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</id>
    <published>2022-09-07T16:00:00.000Z</published>
    <updated>2025-03-11T16:28:30.740Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Golang的内存管理是基于TCMalloc的核心思想来构建的，内存管理本质上是一个<strong>内存池和多级对象管理</strong></p></blockquote><span id="more"></span><h2 id="1-内存模型"><a href="#1-内存模型" class="headerlink" title="1 内存模型"></a>1 内存模型</h2><h3 id="1-1-操作系统存储模型"><a href="#1-1-操作系统存储模型" class="headerlink" title="1.1 操作系统存储模型"></a>1.1 操作系统存储模型</h3><p><strong>多级存储模型</strong></p><ul><li>寄存器      1ns</li><li>高速缓存   2ns</li><li>内存           10ns</li><li>磁盘            10ms</li></ul><p>速度越快, 空间越小, 价格越贵</p><h3 id="1-2-虚拟内存与物理内存"><a href="#1-2-虚拟内存与物理内存" class="headerlink" title="1.2 虚拟内存与物理内存"></a>1.2 虚拟内存与物理内存</h3><p>虚拟内存作用如下：</p><ul><li>在用户与硬件间添加中间代理层</li><li>优化用户体验（进程感知到获得的内存空间是“连续”的）</li><li>“放大”可用内存（虚拟内存可以由物理内存+磁盘补足，并根据冷热动态置换，用户无感知）</li></ul><h3 id="1-3-分页管理"><a href="#1-3-分页管理" class="headerlink" title="1.3 分页管理"></a>1.3 分页管理</h3><p>操作系统中通常会将虚拟内存和物理内存切割成固定的尺寸，于虚拟内存而言叫作“页”，于物理内存而言叫作“帧”，原因如下：</p><ul><li>提高内存空间利用（以页为粒度后，消灭了不稳定的外部碎片，取而代之的是相对可控的内部碎片）</li><li>提高内外存交换效率（更细的粒度带来了更高的灵活度）</li><li>与虚拟内存机制呼应，便于建立虚拟地址-&gt;物理地址的映射关系（聚合映射关系的数据结构，称为页表）</li><li>linux 页/帧的大小固定，为 4KB（这实际是由实践推动的经验值，太粗会增加碎片率，太细会增加分配频率影响效率）</li></ul><h3 id="1-4-Golang-内存模型"><a href="#1-4-Golang-内存模型" class="headerlink" title="1.4 Golang 内存模型"></a>1.4 Golang 内存模型</h3><p><strong>Golang 的内存模型设计的思路：</strong></p><ul><li>以空间换时间，一次缓存，多次复用<ul><li>由于每次向操作系统申请内存的操作很重，那么不妨一次多申请一些，以备后用, 因此产生了堆 mheap<ul><li>对操作系统而言，这是用户进程中缓存的内存</li><li>对于 Go 进程内部，堆是所有对象的内存起源</li></ul></li></ul></li><li><strong>多级缓存，实现无/细锁化</strong><ul><li>堆是 Go 运行时中最大的临界共享资源，这意味着每次存取都要加锁，在性能层面是一件很可怕的事情.</li><li>因此 Golang 在堆 mheap 之上，依次细化粒度，建立了 mcentral、mcache 的模型:<ul><li>mheap：全局的内存起源，访问要加全局锁</li><li>mcentral：每种对象大小规格（全局共划分为 68 种）对应的缓存，锁的粒度也仅限于同一种规格以内</li><li>mcache：每个 P（正是 GMP 中的 P）持有一份的内存缓存，访问时无锁</li></ul></li></ul></li><li>多级规格，提高利用率<ul><li>page：最小的存储单元, Golang 借鉴操作系统分页管理的思想，每个最小的存储单元也称之为页 page，但大小为 8 KB</li><li>mspan：最小的管理单元. mspan 大小为 page 的整数倍，且从 8B 到 80 KB 被划分为 67 种不同的规格，分配对象时，会根据大小映射到不同规格的 mspan，从中获取空间, 多规格 mspan 特点如下:<ul><li>根据规格大小，产生了等级的制度</li><li>消除了外部碎片，但不可避免会有内部碎片</li><li>宏观上能提高整体空间利用率</li><li>正是因为有了规格等级的概念，才支持 mcentral 实现细锁化</li></ul></li></ul></li></ul><h2 id="2-核心概念"><a href="#2-核心概念" class="headerlink" title="2 核心概念"></a>2 核心概念</h2><h3 id="2-1-内存单元-mspan"><a href="#2-1-内存单元-mspan" class="headerlink" title="2.1 内存单元 mspan"></a>2.1 内存单元 mspan</h3><p><strong>mspan 的特质</strong>:</p><ul><li>mspan 是 Golang 内存管理的最小单元</li><li>mspan 大小是 page 的整数倍（Go 中的 page 大小为 8KB），且内部的页是连续的（至少在虚拟内存的视角中是这样）</li><li>每个 mspan 根据空间大小以及面向分配对象的大小，会被划分为不同的等级</li><li>同等级的 mspan 会从属同一个 mcentral，最终会被组织成链表，因此带有前后指针（prev、next）</li><li>同等级的 mspan 内聚于同一个 mcentral，所以会基于同一把互斥锁管理</li><li>mspan 会基于 bitMap 辅助快速找到空闲内存块（块大小为对应等级下的 object 大小），此时需要使用到 Ctz64 算法</li></ul><h3 id="2-2-内存单元等级-spanClass"><a href="#2-2-内存单元等级-spanClass" class="headerlink" title="2.2 内存单元等级 spanClass"></a>2.2 内存单元等级 spanClass</h3><p>mspan 根据空间大小和面向分配对象的大小，被划分为 67 种等级（1-67，实际上还有一种隐藏的 0 级，用于处理更大的对象，上不封顶）</p><div class="table-container"><table><thead><tr><th><strong>class</strong></th><th><strong>bytes/obj</strong></th><th><strong>bytes/span</strong></th><th><strong>objects</strong></th><th><strong>tail waste</strong></th><th><strong>max waste</strong></th></tr></thead><tbody><tr><td>1</td><td>8</td><td>8192</td><td>1024</td><td>0</td><td>87.50%</td></tr><tr><td>2</td><td>16</td><td>8192</td><td>512</td><td>0</td><td>43.75%</td></tr><tr><td>3</td><td>24</td><td>8192</td><td>341</td><td>8</td><td>29.24%</td></tr><tr><td>4</td><td>32</td><td>8192</td><td>256</td><td>0</td><td>21.88%</td></tr><tr><td>…</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>66</td><td>28672</td><td>57344</td><td>2</td><td>0</td><td>4.91%</td></tr><tr><td>67</td><td>32768</td><td>32768</td><td>1</td><td>0</td><td>12.50%</td></tr></tbody></table></div><ul><li>class：mspan 等级标识，1-67</li><li>bytes/obj：该大小规格的对象会从这一 mspan 中获取空间. 创建对象过程中，大小会向上取整为 8B 的整数倍，因此该表可以直接实现 object 到 mspan 等级 的映射</li><li>bytes/span：该等级的 mspan 的总空间大小</li><li>object：该等级的 mspan 最多可以 new 多少个对象，结果等于 （3）/（2）</li><li>tail waste：（3）/（2）可能除不尽，于是该项值为（3）%（2）</li><li>max waste：最不利的情况下浪费的空间比例</li></ul><h3 id="2-3-线程缓存-mcache"><a href="#2-3-线程缓存-mcache" class="headerlink" title="2.3 线程缓存 mcache"></a>2.3 线程缓存 mcache</h3><p><strong>特点</strong></p><ul><li>mcache 是每个 P 独有的缓存，因此交互无锁</li><li>mcache 将每种 spanClass 等级的 mspan 各缓存了一个，总数为 2（nocan 维度） * 68（大小维度）= 136</li><li>mcache 中还有一个为对象分配器 tiny allocator，用于处理小于 16B 对象的内存分配</li></ul><h3 id="2-4-中心缓存-mcentral"><a href="#2-4-中心缓存-mcentral" class="headerlink" title="2.4 中心缓存 mcentral"></a>2.4 中心缓存 mcentral</h3><p><strong>特点:</strong></p><ul><li>每个 mcentral 对应一种 spanClass</li><li>每个 mcentral 下聚合了该 spanClass 下的 mspan</li><li>mcentral 下的 mspan 分为两个链表，分别为有空间 mspan 链表 partial 和满空间 mspan 链表 full</li><li>每个 mcentral 一把锁</li></ul><h3 id="2-5-全局堆缓存-mheap"><a href="#2-5-全局堆缓存-mheap" class="headerlink" title="2.5 全局堆缓存 mheap"></a>2.5 全局堆缓存 mheap</h3><p><strong>特点:</strong></p><ul><li>对于 Golang 上层应用而言，堆是操作系统虚拟内存的抽象</li><li>以页（8KB）为单位，作为最小内存存储单元</li><li>负责将连续页组装成 mspan</li><li>全局内存基于 bitMap 标识其使用情况，每个 bit 对应一页，为 0 则自由，为 1 则已被 mspan 组装</li><li>通过 heapArena 聚合页，记录了页到 mspan 的映射信息</li><li>建立空闲页基数树索引 radix tree index，辅助快速寻找空闲页</li><li>是 mcentral 的持有者，持有所有 spanClass 下的 mcentral，作为自身的缓存</li><li>内存不够时，向操作系统申请，申请单位为 heapArena（64M）</li></ul><h3 id="2-6-空闲页索引-pageAlloc"><a href="#2-6-空闲页索引-pageAlloc" class="headerlink" title="2.6 空闲页索引 pageAlloc"></a>2.6 空闲页索引 pageAlloc</h3><ul><li>mheap 会基于 bitMap 标识内存中各页的使用情况，bit 位为 0 代表该页是空闲的，为 1 代表该页已被 mspan 占用</li><li>每棵基数树聚合了 16 GB 内存空间中各页使用情况的索引信息，用于帮助 mheap 快速找到指定长度的连续空闲页的所在位置</li><li>mheap 持有 2^14 棵基数树，因此索引全面覆盖到 2^14 * 16 GB = 256 T 的内存空间</li><li>基数树中，每个节点称之为 PallocSum，是一个 uint64 类型，体现了索引的聚合信息，包含以下四部分：<ul><li>start：最右侧 21 个 bit，标识了当前节点映射的 bitMap 范围中首端有多少个连续的 0 bit（空闲页），称之为 start；</li><li>max：中间 21 个 bit，标识了当前节点映射的 bitMap 范围中最多有多少个连续的 0 bit（空闲页），称之为 max；</li><li>end：左侧 21 个 bit，标识了当前节点映射的 bitMap 范围中最末端有多少个连续的 0 bit（空闲页），称之为 end.</li><li>最左侧一个 bit，弃置不用</li></ul></li><li>基数树父子关系<ul><li>每个父 pallocSum 有 8 个子 pallocSum</li><li>根 pallocSum 总览全局，映射的 bitMap 范围为全局的 16 GB 空间（其 max 最大值为 2^21，因此总空间大小为 2^21*8KB=16GB）</li><li>从首层向下是一个依次八等分的过程，每一个 pallocSum 映射其父节点 bitMap 范围的八分之一，因此第二层 pallocSum 的 bitMap 范围为 16GB/8 = 2GB，以此类推，第五层节点的范围为 16GB / (8^4) = 4 MB，已经很小</li><li>聚合信息时，自底向上. 每个父 pallocSum 聚合 8 个子 pallocSum 的 start、max、end 信息，形成自己的信息，直到根 pallocSum，坐拥全局 16 GB 的 start、max、end 信息</li><li>mheap 寻页时，自顶向下. 对于遍历到的每个 pallocSum，先看起 start 是否符合，是则寻页成功；再看 max 是否符合，是则进入其下层孩子 pallocSum 中进一步寻访；最后看 end 和下一个同辈 pallocSum 的 start 聚合后是否满足，是则寻页成功</li></ul></li></ul><h3 id="2-7-heapArena"><a href="#2-7-heapArena" class="headerlink" title="2.7 heapArena"></a>2.7 heapArena</h3><ul><li>每个 heapArena 包含 8192 个页，大小为 8192 * 8KB = 64 MB</li><li>heapArena 记录了页到 mspan 的映射. 因为 GC 时，通过地址偏移找到页很方便，但找到其所属的 mspan 不容易. 因此需要通过这个映射信息进行辅助.</li><li>heapArena 是 mheap 向操作系统申请内存的单位（64MB）</li></ul><h2 id="3-对象分配流程"><a href="#3-对象分配流程" class="headerlink" title="3 对象分配流程"></a>3 对象分配流程</h2><p>串联 Golang 中分配对象的流程，不论是以下哪种方式，最终都会殊途同归步入 mallocgc 方法中，并且根据 3.1 小节中的策略执行分配流程:</p><ul><li>new(T)</li><li>&amp;T{}</li><li>make(xxxx)</li></ul><h3 id="3-1-分配流程总览"><a href="#3-1-分配流程总览" class="headerlink" title="3.1 分配流程总览"></a>3.1 分配流程总览</h3><p>Golang 中，依据 object 的大小，会将其分为下述三类:</p><ul><li>tiny 微对象 0-16B</li><li>small 小对象 16B-32KB</li><li>large 大对象 32KB+</li></ul><p>不同类型的对象，会有着不同的分配策略, 核心流程类似于读多级缓存的过程，由上而下，每一步只要成功则直接返回. 若失败，则由下层方法兜底.</p><p><strong>微对象的分配流程：</strong></p><ol><li>从 P 专属 mcache 的 tiny 分配器取内存（无锁）</li><li>根据所属的 spanClass，从 P 专属 mcache 缓存的 mspan 中取内存（无锁）</li><li>根据所属的 spanClass 从对应的 mcentral 中取 mspan 填充到 mcache，然后从 mspan 中取内存（spanClass 粒度锁）</li><li>根据所属的 spanClass，从 mheap 的页分配器 pageAlloc 取得足够数量空闲页组装成 mspan 填充到 mcache，然后从 mspan 中取内存（全局锁）</li><li>mheap 向操作系统申请内存，更新页分配器的索引信息，然后重复 4</li></ol><p>对于小对象的分配流程是跳过（1）步，执行上述流程的（2）-（5）步<br>对于大对象的分配流程是跳过（1）-（3）步，执行上述流程的（4）-（5）步</p><h3 id="3-2-主干方法-mallocgc"><a href="#3-2-主干方法-mallocgc" class="headerlink" title="3.2 主干方法 mallocgc"></a>3.2 主干方法 mallocgc</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">    <span class="comment">// 获取 m</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// 获取当前 p 对应的 mcache</span></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line">    <span class="keyword">var</span> span *mspan</span><br><span class="line">    <span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">    <span class="comment">// 根据当前对象是否包含指针，标识 gc 时是否需要展开扫描</span></span><br><span class="line">    noscan := typ == <span class="literal">nil</span> || typ.ptrdata == <span class="number">0</span></span><br><span class="line">    <span class="comment">// 是否是小于 32KB 的微、小对象</span></span><br><span class="line">    <span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line">    <span class="comment">// 小于 16 B 且无指针，则视为微对象</span></span><br><span class="line">        <span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">        <span class="comment">// tiny 内存块中，从 offset 往后有空闲位置</span></span><br><span class="line">          off := c.tinyoffset</span><br><span class="line">          <span class="comment">// 如果大小为 5 ~ 8 B，size 会被调整为 8 B，此时 8 &amp; 7 == 0，会走进此分支</span></span><br><span class="line">          <span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 将 offset 补齐到 8 B 倍数的位置</span></span><br><span class="line">                off = alignUp(off, <span class="number">8</span>)</span><br><span class="line">                <span class="comment">// 如果大小为 3 ~ 4 B，size 会被调整为 4 B，此时 4 &amp; 3 == 0，会走进此分支  </span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">           <span class="comment">// 将 offset 补齐到 4 B 倍数的位置</span></span><br><span class="line">                off = alignUp(off, <span class="number">4</span>)</span><br><span class="line">                <span class="comment">// 如果大小为 1 ~ 2 B，size 会被调整为 2 B，此时 2 &amp; 1 == 0，会走进此分支  </span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 将 offset 补齐到 2 B 倍数的位置</span></span><br><span class="line">                off = alignUp(off, <span class="number">2</span>)</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">// 如果当前 tiny 内存块空间还够用，则直接分配并返回</span></span><br><span class="line">            <span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 分配空间</span></span><br><span class="line">                x = unsafe.Pointer(c.tiny + off)</span><br><span class="line">                c.tinyoffset = off + size</span><br><span class="line">                c.tinyAllocs++</span><br><span class="line">                mp.mallocing = <span class="number">0</span></span><br><span class="line">                releasem(mp)  </span><br><span class="line">                <span class="keyword">return</span> x</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 分配一个新的 tiny 内存块</span></span><br><span class="line">            span = c.alloc[tinySpanClass]    </span><br><span class="line">            <span class="comment">// 从 mCache 中获取</span></span><br><span class="line">            v := nextFreeFast(span)        </span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 从 mCache 中获取失败，则从 mCentral 或者 mHeap 中获取进行兜底</span></span><br><span class="line">                v, span, shouldhelpgc = c.nextFree(tinySpanClass)</span><br><span class="line">            &#125;   </span><br><span class="line"><span class="comment">// 分配空间      </span></span><br><span class="line">            x = unsafe.Pointer(v)</span><br><span class="line">           (*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">           (*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">           size = maxTinySize</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 根据对象大小，映射到其所属的 span 的等级(0~66）</span></span><br><span class="line">          <span class="keyword">var</span> sizeclass <span class="type">uint8</span></span><br><span class="line">          <span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">              sizeclass = size_to_class8[divRoundUp(size, smallSizeDiv)]</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              sizeclass = size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]</span><br><span class="line">          &#125;        </span><br><span class="line">          <span class="comment">// 对应 span 等级下，分配给每个对象的空间大小(0~32KB)</span></span><br><span class="line">          size = <span class="type">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">          <span class="comment">// 创建 spanClass 标识，其中前 7 位对应为 span 的等级(0~66)，最后标识表示了这个对象 gc 时是否需要扫描</span></span><br><span class="line">          spc := makeSpanClass(sizeclass, noscan) </span><br><span class="line">          <span class="comment">// 获取 mcache 中的 span</span></span><br><span class="line">          span = c.alloc[spc]  </span><br><span class="line">          <span class="comment">// 从 mcache 的 span 中尝试获取空间        </span></span><br><span class="line">          v := nextFreeFast(span)</span><br><span class="line">          <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">          <span class="comment">// mcache 分配空间失败，则通过 mcentral、mheap 兜底            </span></span><br><span class="line">             v, span, shouldhelpgc = c.nextFree(spc)</span><br><span class="line">          &#125;     </span><br><span class="line">          <span class="comment">// 分配空间  </span></span><br><span class="line">          x = unsafe.Pointer(v)</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">       &#125;      </span><br><span class="line">       <span class="comment">// 大于 32KB 的大对象      </span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 从 mheap 中获取 0 号 span</span></span><br><span class="line">       span = c.allocLarge(size, noscan)</span><br><span class="line">       span.freeindex = <span class="number">1</span></span><br><span class="line">       span.allocCount = <span class="number">1</span></span><br><span class="line">       size = span.elemsize         </span><br><span class="line">       <span class="comment">// 分配空间   </span></span><br><span class="line">        x = unsafe.Pointer(span.base())</span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">return</span> x</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure><h3 id="3-3-步骤（1）：tiny-分配"><a href="#3-3-步骤（1）：tiny-分配" class="headerlink" title="3.3 步骤（1）：tiny 分配"></a>3.3 步骤（1）：tiny 分配</h3><p>每个 P 独有的 mcache 会有个微对象分配器，基于 offset 线性移动的方式对微对象进行分配，每 16B 成块，对象依据其大小，会向上取整为 2 的整数次幂进行空间补齐，然后进入分配流程</p><h3 id="3-4-步骤（2）：mcache-分配"><a href="#3-4-步骤（2）：mcache-分配" class="headerlink" title="3.4 步骤（2）：mcache 分配"></a>3.4 步骤（2）：mcache 分配</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据对象大小，映射到其所属的 span 的等级(0~66）</span></span><br><span class="line"><span class="keyword">var</span> sizeclass <span class="type">uint8</span></span><br><span class="line"><span class="comment">// get size class ....     </span></span><br><span class="line"><span class="comment">// 对应 span 等级下，分配给每个对象的空间大小(0~32KB)</span></span><br><span class="line"><span class="comment">// get span class</span></span><br><span class="line">spc := makeSpanClass(sizeclass, noscan) </span><br><span class="line"><span class="comment">// 获取 mcache 中的 span</span></span><br><span class="line">span = c.alloc[spc]  </span><br><span class="line"><span class="comment">// 从 mcache 的 span 中尝试获取空间        </span></span><br><span class="line">v := nextFreeFast(span)</span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// mcache 分配空间失败，则通过 mcentral、mheap 兜底            </span></span><br><span class="line">   v, span, shouldhelpgc = c.nextFree(spc)</span><br><span class="line">&#125;     </span><br><span class="line"><span class="comment">// 分配空间  </span></span><br><span class="line">x = unsafe.Pointer(v)</span><br></pre></td></tr></table></figure><h3 id="3-5-步骤（3）：mcentral-分配"><a href="#3-5-步骤（3）：mcentral-分配" class="headerlink" title="3.5 步骤（3）：mcentral 分配"></a>3.5 步骤（3）：mcentral 分配</h3><ul><li>当 mspan 无可用的 object 内存块时，会步入 mcache.nextFree 方法进行兜底.</li><li>倘若 mcache 中，对应的 mspan 空间不足，则会在 mcache.refill 方法中，向更上层的 mcentral 乃至 mheap 获取 mspan，填充到 mache 中</li><li>mcentral.cacheSpan 方法中，会加锁（spanClass 级别的 sweepLocker），分别从 partial 和 full 中尝试获取有空间的 mspan</li></ul><h3 id="3-6-步骤（4）：mheap-分配"><a href="#3-6-步骤（4）：mheap-分配" class="headerlink" title="3.6 步骤（4）：mheap 分配"></a>3.6 步骤（4）：mheap 分配</h3><p>在 mcentral.cacheSpan 方法中，倘若从 partial 和 full 中都找不到合适的 mspan 了，则会调用 mcentral 的 grow 方法，将事态继续升级<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> cacheSpan() *mspan &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// mcentral 中也没有可用的 mspan 了，则需要从 mheap 中获取，最终会调用 mheap_.alloc 方法</span></span><br><span class="line">    s = c.grow()</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行到此处时，s 已经指向一个存在 object 空位的 mspan 了</span></span><br><span class="line">havespan:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>经由 mcentral.grow 方法和 mheap.alloc 方法的周转，最终会步入 mheap.allocSpan 方法中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> grow() *mspan &#123;</span><br><span class="line">    npages := <span class="type">uintptr</span>(class_to_allocnpages[c.spanclass.sizeclass()])</span><br><span class="line">    size := <span class="type">uintptr</span>(class_to_size[c.spanclass.sizeclass()])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    s := mheap_.alloc(npages, c.spanclass)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> alloc(npages <span class="type">uintptr</span>, spanclass spanClass) *mspan &#123;</span><br><span class="line">    <span class="keyword">var</span> s *mspan</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        s = h.allocSpan(npages, spanAllocHeap, spanclass)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> allocSpan(npages <span class="type">uintptr</span>, typ spanAllocType, spanclass spanClass) (s *mspan) &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    base, scav := <span class="type">uintptr</span>(<span class="number">0</span>), <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...此处实际上还有一阶缓存，是从每个 P 的页缓存 pageCache 中获取空闲页组装 mspan，此处先略去了...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加上堆全局锁</span></span><br><span class="line">    lock(&amp;h.lock)</span><br><span class="line">    <span class="keyword">if</span> base == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 通过基数树索引快速寻找满足条件的连续空闲页</span></span><br><span class="line">        base, scav = h.pages.alloc(npages)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    unlock(&amp;h.lock)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HaveSpan:</span><br><span class="line">    <span class="comment">// 把空闲页组装成 mspan</span></span><br><span class="line">    s.init(base, npages)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将这批页添加到 heapArena 中，建立由页指向 mspan 的映射</span></span><br><span class="line">    h.setSpans(s.base(), npages, s)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-步骤（5）：向操作系统申请"><a href="#3-7-步骤（5）：向操作系统申请" class="headerlink" title="3.7 步骤（5）：向操作系统申请"></a>3.7 步骤（5）：向操作系统申请</h3><p>倘若 mheap 中没有足够多的空闲页了，会发起 mmap 系统调用，向操作系统申请额外的内存空间</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Golang的内存管理是基于TCMalloc的核心思想来构建的，内存管理本质上是一个&lt;strong&gt;内存池和多级对象管理&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="内存管理" scheme="https://stardustorz.github.io/categories/Golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Go] Channel</title>
    <link href="https://stardustorz.github.io/2022/07/14/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Channel/"/>
    <id>https://stardustorz.github.io/2022/07/14/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Channel/</id>
    <published>2022-07-13T16:00:00.000Z</published>
    <updated>2025-03-08T15:38:21.903Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习 golang 中的 chan，并分析其具体实现，包括创建 channel，发送数据，接收数据以及相关调度等。</p></blockquote><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><blockquote><p>A channel provides a mechanism for concurrently executing functions to communicate by sending and receiving values of a specified element type. The value of an uninitialized channel is nil.</p></blockquote><p>chan 提供了一种并发通信机制，用于生产和消费某一指定类型数据，未初始化的 chan 的值是nil。</p><p> <strong>使用场景：</strong> 消息传递、消息过滤，信号广播，事件订阅与广播，请求、响应转发，任务分发，结果汇总，并发控制，限流，同步与异步</p><h2 id="2-特性与实现"><a href="#2-特性与实现" class="headerlink" title="2 特性与实现"></a>2 特性与实现</h2><p>Chan 是 Go 里面的一种数据结构，具有以下特性：</p><ul><li>goroutine-safe，多个 goroutine 可以同时访问一个 channel 而不会出现并发问题</li><li>可以用于在 goroutine 之间存储和传递值</li><li>先入先出（FIFO）</li><li>可以导致 goroutine 的 block 和 unblock<h3 id="2-1-内部结构"><a href="#2-1-内部结构" class="headerlink" title="2.1 内部结构"></a>2.1 内部结构</h3></li></ul><p>主要包含以下几个部分：</p><ul><li>circular queue：循环队列，用于存储数据</li><li>send index 记录发送的位置</li><li>receive index 记录接收的位置</li><li>mutex 锁，用于实现 goroutine safe。</li></ul><p>元素队列的具体实现很简单，就是一个环形队列，使用 sendx 和 recvx 分别用来记录发送、接收的 offset，然后通过 mutex 互斥锁来保证并发安全。</p><h3 id="2-2-创建-chan"><a href="#2-2-创建-chan" class="headerlink" title="2.2 创建 chan"></a>2.2 创建 chan</h3><p>chan 使用 make 进行初始化，第一个参数指定 chan 中的元素类型，第二个参数用于指定 chan 的缓冲区大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>make 返回的 ch 实际上是一个指向 heap 中真正的 chan 对象的指针。<br><strong>chan（即 hchan 结构体） 默认会被分配在堆上，make 返回的只是一个指向该对象的指针</strong>。</p><blockquote><p>可以在函数之间传递 chan，而不是 chan 的指针。 因为 chan 本身就是指针</p></blockquote><h3 id="2-3-发送、接收与关闭"><a href="#2-3-发送、接收与关闭" class="headerlink" title="2.3 发送、接收与关闭"></a>2.3 发送、接收与关闭</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Task, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> _,task := <span class="keyword">range</span> helloTasks &#123;</span><br><span class="line">    taskCh &lt;- task <span class="comment">// 发送</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(tashCh) <span class="comment">// 关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ch)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        task:= &lt;-taskCh <span class="comment">// 接收</span></span><br><span class="line">        process(task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main goroutine 发送 task 到 chan，然后 worker goroutine 从 chan 中接收 task 并处理，最后 main goroutine 发送完成后关闭 chan。<br>具体<strong>发送过程</strong>如下：</p><ul><li>acquire 加锁</li><li>enqueue，将 task 对象<strong>拷贝</strong>到数组里</li><li>release 释放锁</li></ul><p>对于 chan 的关闭，最佳实践是由发送方进行关闭。<br><strong>接收过程</strong>：</p><ul><li>acquire 加锁</li><li>dequeue<ul><li>将 task 对象从 数组 中 <strong>拷贝</strong>出来赋值给用户用于接收的对象</li><li><code>task:= &lt;-taskCh</code>,比如这里就是拷贝出来赋值给 task</li></ul></li><li>release 释放锁</li></ul><p>整个过程中没有任何共享内存，数据都是通过 copy 进行传递,这遵循了 Go 并发设计中很核心的一个理念：</p><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating.</p></blockquote><h3 id="2-4-阻塞与唤醒"><a href="#2-4-阻塞与唤醒" class="headerlink" title="2.4 阻塞与唤醒"></a>2.4 阻塞与唤醒</h3><p>hchan 中的 buf 数组大小就是 make chan 时指定的大小。<br>当 buf 满之后再往 chan 中发送值就会阻塞。</p><blockquote><p>goroutine 调度：G 阻塞之后并不会阻塞 M。M 会先把这个 G 暂停(gopark)，然后把执行栈切换到 g0，g0 会执行 schedule() 函数，从当前 M 绑定的 P 中查找有没有可以执行的G，有就捞出来继续执行。</p></blockquote><h4 id="2-4-1-先发后收"><a href="#2-4-1-先发后收" class="headerlink" title="2.4.1 先发后收"></a>2.4.1 先发后收</h4><p>假设 chan 中已经有 3 个 task 了,然后再往里面发送一个</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskCh &lt;- task </span><br></pre></td></tr></table></figure><p>runtime 会调用 gopark 将这个 goroutine(姑且称作G1) 切换到 wait 状态。<br><em>什么时候会被唤醒呢？</em><br>hchan 结构体中还有 sendq、recvq 两个列表，分别记录了等待发送或者接收的 goroutine：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog</span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>比如前面被阻塞的 G1 就会存入 sendq</p></blockquote><p>假设此时 G2 从 chan 中取走一个消息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task:= &lt;-taskCh </span><br></pre></td></tr></table></figure><p>G2 取走一个消息后就会找到 sendq 中的第一个对象，把待发送的 elem 直接写入 buf 数组。然后 调用 goready 把对应的 goroutine  G1 设置为 runnable 状态。</p><h4 id="2-4-2-先收后发"><a href="#2-4-2-先收后发" class="headerlink" title="2.4.2 先收后发"></a>2.4.2 先收后发</h4><p>之前是先发送，后接收。现在看一下先接收后发送的情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task:= &lt;-taskCh </span><br></pre></td></tr></table></figure><p>G2 直接从空的 chan 中取消息，同样会被阻塞,然后被写入到 hchan 的 recqv 中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskCh &lt;- task </span><br></pre></td></tr></table></figure><p>按照上面的逻辑应该是，将 task 写入 buf 数组后，，再把 recvq 中的第一个 goroutine G2 唤醒。</p><p>但是 Go 官方这里进行了优化。因为 recvq 里的 elem 对象 t 存的就是<strong>接收者的内存地址</strong>。</p><p>所以我们可以直接把 G1 发送来的 task 写入 elem 对应的 t 里，即在 G1 里修改 G2 的栈对象。</p><blockquote><p>因为这个时候 G2 还是 gopark，处于 waiting 状态，所以不会出问题。</p><p>正常情况下因为不知道两个线程谁先谁后，这样改肯定会出问题。但是在 go runtime 这里，肯定是 G2 先执行，满足 happen-before 所以不存在问题。</p></blockquote><p>省去了发送和接收时的两次加解锁和内存拷贝。</p><h3 id="2-5-特性实现原理"><a href="#2-5-特性实现原理" class="headerlink" title="2.5 特性实现原理"></a>2.5 特性实现原理</h3><ul><li><strong>goroutine-safe</strong>.<ul><li>hchan <strong>mutex</strong>，通过加锁来避免数据竞争。</li></ul></li><li>可以用于在 goroutine 之间存储和传递值，以及先入先出（FIFO）语义。<ul><li>copying into and out of hchan <strong>buffer</strong></li></ul></li><li>可以导致 goroutine 的 block 和 unblock<ul><li>通过 <strong>sudog queues</strong> 来记录阻塞的 goroutine。</li><li>通过 <strong>runtime scheduler</strong>(gopark, goready)来实现阻塞与唤醒。</li></ul></li></ul><h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3 源码分析"></a>3 源码分析</h2><p><code>runtime/chan.go</code></p><h3 id="3-1-内部结构"><a href="#3-1-内部结构" class="headerlink" title="3.1 内部结构"></a>3.1 内部结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="type">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">dataqsiz <span class="type">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">elemsize <span class="type">uint16</span></span><br><span class="line">closed   <span class="type">uint32</span></span><br><span class="line">elemtype *_type <span class="comment">// element type</span></span><br><span class="line">sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line">recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog</span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">    g *g</span><br><span class="line">    next *sudog</span><br><span class="line">    prev *sudog</span><br><span class="line">    elem unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line">    isSelect <span class="type">bool</span></span><br><span class="line">    c        *hchan </span><br><span class="line">&#125;<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- qcount：当前 channel 中存在多少个元素；</span></span><br><span class="line"><span class="string">- dataqsize: 当前 channel 能存放的元素容量；</span></span><br><span class="line"><span class="string">- buf：channel 中用于存放元素的环形缓冲区；</span></span><br><span class="line"><span class="string">- elemsize：channel 元素类型的大小；</span></span><br><span class="line"><span class="string">- closed：标识 channel 是否关闭；</span></span><br><span class="line"><span class="string">- elemtype：channel 元素类型；</span></span><br><span class="line"><span class="string">- sendx：发送元素进入环形缓冲区的 index；</span></span><br><span class="line"><span class="string">- recvx：接收元素所处的环形缓冲区的 index；</span></span><br><span class="line"><span class="string">- recvq：因接收而陷入阻塞的协程队列；</span></span><br><span class="line"><span class="string">- sendq：因发送而陷入阻塞的协程队列；</span></span><br><span class="line"><span class="string">- waitq：阻塞的协程队列</span></span><br><span class="line"><span class="string">- first：队列头部</span></span><br><span class="line"><span class="string">- last：队列尾部</span></span><br><span class="line"><span class="string">- sudog：用于包装协程的节点</span></span><br><span class="line"><span class="string">- g：goroutine，协程；</span></span><br><span class="line"><span class="string">- next：队列中的下一个节点；</span></span><br><span class="line"><span class="string">- prev：队列中的前一个节点；</span></span><br><span class="line"><span class="string">- elem: 读取/写入 channel 的数据的容器;</span></span><br><span class="line"><span class="string">- isSelect：标识当前协程是否处在 select 多路复用的流程中；</span></span><br><span class="line"><span class="string">- c：标识与当前 sudog 交互的 chan.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 3.2 构造器函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在源码中通道的创建由 makechan 方法实现：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;&#125;</span><br></pre></td></tr></table></figure><p>然后还有两个包装方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname reflect_makechan reflect.makechan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line"><span class="keyword">return</span> makechan(t, size)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan64</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="type">int64</span>(<span class="type">int</span>(size)) != size &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> makechan(t, <span class="type">int</span>(size))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部都是调用的 makechan 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">elem := t.elem</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器检查 typesize 和 align</span></span><br><span class="line"><span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算存放数据元素的内存大小以及是否溢出</span></span><br><span class="line">mem, overflow := math.MulUintptr(elem.size, <span class="type">uintptr</span>(size))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c *hchan</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line">c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">c.buf = c.raceaddr()</span><br><span class="line"><span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>:</span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">c = <span class="built_in">new</span>(hchan)</span><br><span class="line">c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">c.elemsize = <span class="type">uint16</span>(elem.size)</span><br><span class="line">c.elemtype = elem</span><br><span class="line">c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line">lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体流程如下：</p><ul><li>判断申请内存空间大小是否越界，mem 大小为 element 类型大小与 element 个数相乘后得到，仅当无缓冲型 channel 时，因个数为 0 导致大小为 0；</li><li>根据类型，初始 channel，分为 无缓冲型、有缓冲元素为 struct 型、有缓冲元素为 pointer 型 channel;</li><li>倘若为无缓冲型，则仅申请一个大小为默认值 96 的空间；</li><li>如若有缓冲的 struct 型，则一次性分配好 96 + mem 大小的空间，并且调整 chan 的 buf 指向 mem 的起始位置；</li><li>倘若为有缓冲的 pointer 型，则分别申请 chan 和 buf 的空间，两者无需连续；</li><li>对 channel 的其余字段进行初始化，包括元素类型大小、元素类型、容量以及锁的初始化.</li></ul><h3 id="3-2-写流程"><a href="#3-2-写流程" class="headerlink" title="3.2 写流程"></a>3.2 写流程</h3><p>发送数据到channel时：</p><ul><li>先判断是否有等待接收数据的 groutine，如果有，直接将数据发给 groutine，唤醒 groutine，就不放入队列中了。省去了两次内存拷贝和加锁的开销</li><li>另外一种情况：队列如果满了，那就只能放到队列中等待，直到有数据被取走才能发送。<h4 id="3-2-1-调用链"><a href="#3-2-1-调用链" class="headerlink" title="3.2.1 调用链"></a>3.2.1 调用链</h4></li></ul><p>chan 的发送逻辑涉及到5个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendDirect</span><span class="params">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;…&#125;</span><br></pre></td></tr></table></figure><p>chansend1 方法是 go编译代码中<code>c &lt;- x</code>这种写法的入口点，即当我们编写代码<code>c &lt;- x</code>其实就是调用此方法。<br>这四个方法的调用关系：<code>chansend1 -&gt; chansend -&gt; send -&gt; sendDirect</code><br>具体发送逻辑在<code>chansend</code>这个方法里，然后真正使用的方法其实是对该方法的一层包装。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">chansend(c, elem, <span class="literal">true</span>, getcallerpc())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> chansend(c, elem, <span class="literal">false</span>, getcallerpc())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-chansend"><a href="#3-2-2-chansend" class="headerlink" title="3.2.2 chansend"></a>3.2.2 chansend</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 channel 是否为 nil</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !block &#123;<span class="comment">// 如果非阻塞，直接返回 false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 当向 nil channel 发送数据时，会调用 gopark</span></span><br><span class="line"><span class="comment">// 而 gopark 会将当前的 goroutine 休眠，并用过第一个参数的 unlockf 来回调唤醒</span></span><br><span class="line"><span class="comment">// 但此处传递的参数为 nil，因此向 channel 发送数据的 goroutine 和接收数据的 goroutine 都会阻塞，进而死锁</span></span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racereadpc(c.raceaddr(), callerpc, funcPC(chansend))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于不阻塞的 send，快速检测失败场景</span></span><br><span class="line"><span class="comment">// 如果 channel 未关闭且 channel 没有多余的缓冲空间。这可能是：</span></span><br><span class="line"><span class="comment">// 1. channel 是非缓冲型的，且等待接收队列里没有 goroutine</span></span><br><span class="line"><span class="comment">// 2. channel 是缓冲型的，但循环数组已经装满了元素</span></span><br><span class="line"><span class="comment">// 主要用于 select 语句中，涉及到指令重排队+可观测性</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; full(c) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加锁,避免竞争</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"><span class="comment">// 检查 channel 是否已关闭，不允许向关闭的 channel 发送数据</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>)) <span class="comment">// 直接panic</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从 recvq 队首取出一个接收者，如果存在接收者，就绕过环形队列（buf）直接把 ep 拷贝给 sg，并释放锁</span></span><br><span class="line">    <span class="comment">// 这就是前面提到的，官方做的一个优化，如果有goroutine在等待就直接把数据给该goroutine，没必要在写到buf，然后接收者又从buf中拷贝出来</span></span><br><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 到这里说明当前没有等待状态的接收者</span></span><br><span class="line"><span class="comment">// 如果环形队列还未满</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="comment">// 拿到 sendx 索引的位置</span></span><br><span class="line">qp := chanbuf(c, c.sendx)</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racenotify(c, c.sendx, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 直接把数据从 qp 拷贝到 qp，就是把数据拷贝到环形队列中</span></span><br><span class="line">typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        <span class="comment">// 维护 snedx 的值，因为是环形队列，所以到最大值时就重置为0</span></span><br><span class="line">c.sendx++</span><br><span class="line"><span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">c.sendx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//qcount即当前chan中的元素个数</span></span><br><span class="line">c.qcount++</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 到这里说明环形队列已经满了</span></span><br><span class="line"><span class="comment">// 如果还是要非阻塞的方式发送，就只能返回错误了</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 到这里说明缓存队列满了，然后调用法指定是阻塞方式进行发送</span></span><br><span class="line"><span class="comment">// channel 满了，发送方会被阻塞。接下来会构造一个 sudog</span></span><br><span class="line">gp := getg()<span class="comment">// 获取当前 goroutine</span></span><br><span class="line">mysg := acquireSudog()<span class="comment">// 从对象池获取 sudog</span></span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 把发送的数据(ep)、当前g(gp)、已经当前这个chan(c)都存到sudog中</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">    <span class="comment">// 保存当前 sudog，下面要用到做校验</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">     <span class="comment">// 把这个sudog存入sendq队列</span></span><br><span class="line">c.sendq.enqueue(mysg)</span><br><span class="line">atomic.Store8(&amp;gp.parkingOnChan, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 调用gopark，挂起当前的 g，将当前的 g 移出调度器的队列</span></span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 等到有接收者从chan中取值的时候，这个发送的g又会被重新调度，然后从这里开始继续执行</span></span><br><span class="line">KeepAlive(ep)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检验是否为当前的 sudog</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">gp.activeStackChans = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 这里sudog中的success表示的是当前这个通道上是否进行过通信</span></span><br><span class="line">    <span class="comment">// 为 true 则说明是真正的唤醒，chan上有活动（有数据写进来，或者有数据被读取出去）</span></span><br><span class="line">    <span class="comment">// 为 false 则说明是假的唤醒，即当前唤醒是否关闭chan导致的</span></span><br><span class="line">    <span class="comment">// 这里主要根据这个值判断chan是否被关闭了</span></span><br><span class="line">closed := !mysg.success</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 将 sudog 放回对象池</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">if</span> closed &#123;</span><br><span class="line">        <span class="comment">// 如果chan被关闭了也是直接panic</span></span><br><span class="line"><span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;chansend: spurious wakeup&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心逻辑</p><ul><li>如果recvq不为空，从recvq中取出一个等待接收数据的Groutine，直接将数据发送给该Groutine</li><li>如果recvq为空，才将数据放入buf中</li><li>如果buf已满，则将要发送的数据和当前的Groutine打包成Sudog对象放入sendq，并将groutine置为等待状态</li><li>等goroutine再次被调度时程序继续执行</li></ul><h4 id="3-2-3-send"><a href="#3-2-3-send" class="headerlink" title="3.2.3 send"></a>3.2.3 send</h4><p>然后追踪一下 send 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 忽略 race 检查..</span></span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 直接拷贝到接受者内存，使用写屏障</span></span><br><span class="line">sendDirect(c.elemtype, sg, ep)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g <span class="comment">// 取出sudog中记录的g，这里的g就是被阻塞接收者</span></span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg) <span class="comment">// 更新接收者g的param字段，在recv方法中会用到</span></span><br><span class="line">sg.success = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 最后把被阻塞的接收者g唤醒</span></span><br><span class="line">goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-4-sendDirect"><a href="#3-2-4-sendDirect" class="headerlink" title="3.2.4 sendDirect"></a>3.2.4 sendDirect</h4><p>继续看sendDirect 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendDirect</span><span class="params">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;</span><br><span class="line"><span class="comment">// src 在当前 goroutine 的栈上，dst 是另一个 goroutine 的栈</span></span><br><span class="line">    <span class="comment">// 直接进行内存&quot;搬迁&quot;</span></span><br><span class="line"><span class="comment">// 如果目标地址的栈发生了栈收缩，当我们读出了 sg.elem 后</span></span><br><span class="line"><span class="comment">// 就不能修改真正的 dst 位置的值了</span></span><br><span class="line"><span class="comment">// 因此需要在读和写之前加上一个屏障</span></span><br><span class="line">dst := sg.elem</span><br><span class="line">typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.size)</span><br><span class="line"> <span class="comment">// 拷贝内存</span></span><br><span class="line">memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到一个 goroutine 直接写另一个 goroutine 栈的操作，一般而言，不同 goroutine 的栈是各自独有的。而这也违反了 GC 的一些假设。为了不出问题，写的过程中增加了写屏障，保证正确地完成写操作。这样做的好处是减少了一次内存 copy：不用先拷贝到 channel 的 buf，直接由发送者到接收者。</p><h3 id="3-3-读流程"><a href="#3-3-读流程" class="headerlink" title="3.3 读流程"></a>3.3 读流程</h3><p>从channel读取数据的流程和发送的类似，基本是发送操作的逆操作。<br>这里同样存在和send一样的优化：从channel读取数据时，不是直接去环形队列中去数据，而是先判断是否有等待发送数据的groutine。如果有，直接将groutine出队列，取出数据返回，并唤醒groutine。如果没有等待发送数据的groutine，再从环形队列中取数据。</p><h4 id="3-3-1-调用链"><a href="#3-3-1-调用链" class="headerlink" title="3.3.1 调用链"></a>3.3.1 调用链</h4><p>chan的接收涉及到7个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_chanrecv</span><span class="params">(c *hchan, nb <span class="type">bool</span>, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>, received <span class="type">bool</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span></span> (selected, received <span class="type">bool</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;…&#125;，</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvDirect</span><span class="params">(t *_type, sg *sudog, dst unsafe.Pointer)</span></span> &#123;…&#125;</span><br></pre></td></tr></table></figure><p>按照发送时的套路可知，只有 chanrecv 是具体逻辑，上面几个都是包装方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname reflect_chanrecv reflect.chanrecv</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_chanrecv</span><span class="params">(c *hchan, nb <span class="type">bool</span>, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>, received <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> chanrecv(c, elem, !nb)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) &#123;</span><br><span class="line">_, received = chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收操作有两种写法，一种带 “ok”，反应 channel 是否关闭；</p><p>一种不带 “ok”，这种写法，当接收到相应类型的零值时无法知道是真实的发送者发送过来的值，还是 channel 被关闭后，返回给接收者的默认类型的零值。</p><p>两种写法，都有各自的应用场景。</p><p>经过编译器的处理后，这两种写法最后对应源码里的就是不带<code>ok</code>的<code>chanrecv1</code>和带<code>ok</code>的<code>chanrecv2</code>这两个函数。</p><h4 id="3-3-2-chanrecv"><a href="#3-3-2-chanrecv" class="headerlink" title="3.3.2 chanrecv"></a>3.3.2 chanrecv</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chanrecv 函数接收 channel c 的元素并将其写入 ep 所指向的内存地址。</span></span><br><span class="line"><span class="comment">// 如果 ep 是 nil，说明忽略了接收值。比如 &lt;-ch 这样，没有接收取到的值</span></span><br><span class="line"><span class="comment">// 如果 block == false，即非阻塞型接收，在没有数据可接收的情况下，返回 (false, false)</span></span><br><span class="line"><span class="comment">// 否则，如果 c 处于关闭状态，将 ep 指向的地址清零，返回 (true, false)</span></span><br><span class="line"><span class="comment">// 否则，用返回值填充 ep 指向的内存地址。返回 (true, true)</span></span><br><span class="line"><span class="comment">// 如果 ep 非空，则应该指向堆或者函数调用者的栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="comment">// 如果是一个 nil 的 channel</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不阻塞，直接返回 (false, false)</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 否则，接收一个 nil 的 channel，调用gopark将goroutine 挂起</span></span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>) <span class="comment">// 被挂起之后不会执行到这一句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这块主要用在 select 语句中，先大概了解下，比较难懂。。。</span></span><br><span class="line"><span class="comment">// 快速路径: 在不需要锁的情况下检查失败的非阻塞操作</span></span><br><span class="line"><span class="comment">// 注意到 channel 不能由已关闭转换为未关闭，则失败的条件是：</span></span><br><span class="line"><span class="comment">// 1. channel 是非缓冲型的，recvq 队列为空</span></span><br><span class="line"><span class="comment">// 2. channel 是缓冲型的，buf 为空</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; empty(c) &#123;</span><br><span class="line"><span class="comment">// 此处的 c.closed 必须在条件判断之后进行验证，</span></span><br><span class="line">        <span class="comment">// 因为指令重排后，如果先判断 c.closed，得出 channel 未关闭，无法判断失败条件中channel 是已关闭还是未关闭（从而需要 atomic 操作）</span></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再次检查 channel 是否为空</span></span><br><span class="line"><span class="keyword">if</span> empty(c) &#123;</span><br><span class="line"><span class="comment">// 接收者不为 nil 时返回该类型的零值</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// typedmemclr 逻辑是根据类型清理相应地址的内存</span></span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 返回（true,fasle）</span></span><br><span class="line">            <span class="comment">// 返回值1--true：表示被 select case 选中，</span></span><br><span class="line">            <span class="comment">// 返回值2--fasle 表示是否正常收到数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加锁，保证并发安全</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"><span class="comment">// channel 已关闭，并且循环数组 buf 里没有元素</span></span><br><span class="line"><span class="comment">// 这里可以处理非缓冲型关闭 和 缓冲型关闭但 buf 无元素的情况</span></span><br><span class="line"><span class="comment">// 也就是说即使是关闭状态，但在缓冲型的 channel，</span></span><br><span class="line"><span class="comment">// buf 里有元素的情况下还能接收到元素</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待发送队列里有 goroutine 存在，说明 buf 是满的</span></span><br><span class="line"><span class="comment">// 这有可能是：</span></span><br><span class="line"><span class="comment">// 1. 非缓冲型的 channel</span></span><br><span class="line"><span class="comment">// 2. 缓冲型的 channel，但 buf 满了</span></span><br><span class="line"><span class="comment">// 针对 1，直接进行内存拷贝（从 sender goroutine -&gt; receiver goroutine）</span></span><br><span class="line"><span class="comment">// 针对 2，接收到循环数组头部的元素，并将发送者的元素放到循环数组尾部</span></span><br><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// chan的buf 里有元素，可以正常接收</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 直接从循环数组里找到要接收的元素</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line">        <span class="comment">// ep != nil表示代码里，没有忽略要接收的值</span></span><br><span class="line">        <span class="comment">// 即接收的代码不是 &quot;&lt;- ch&quot;，而是 &quot;val &lt;- ch&quot;这种，ep 指向 val</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 清理掉循环数组里相应位置的值</span></span><br><span class="line">typedmemclr(c.elemtype, qp)</span><br><span class="line">        <span class="comment">// 维护接收游标</span></span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// buf 数组里的元素个数减 1</span></span><br><span class="line">c.qcount--</span><br><span class="line">        <span class="comment">// 处理完成，解锁返回</span></span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 到这里说明chan的buf里没有数据了，如果是非阻塞接收就直接返回了</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来就是要被阻塞的情况了</span></span><br><span class="line">    <span class="comment">// 和发送类似的，构造一个 sudog</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 这里需要注意一下，ep就是我们用来接收值得对象</span></span><br><span class="line">    <span class="comment">// 这里把ep直接存到sudog.elem字段上</span></span><br><span class="line">mysg.elem = ep </span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg <span class="comment">// 这个waiting同样是用来唤醒后做校验的</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 加入到chan的recvq队列里</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line">atomic.Store8(&amp;gp.parkingOnChan, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 将当前 goroutine 挂起</span></span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒后，继续往下执行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同样是进行数据校验</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">gp.activeStackChans = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 又是mysg.success，如果chan活动过就是true，否则是false</span></span><br><span class="line">success := mysg.success</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)<span class="comment">// 将 sudog 放回对象池</span></span><br><span class="line">    <span class="comment">// 到这里如果goroutine被正常唤醒肯定是可以取到数据的</span></span><br><span class="line">    <span class="comment">// 因为recvq的数据是由发送的时候直接copy过来了</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, success</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-3-3-recv"><a href="#3-3-3-recv" class="headerlink" title="3.3.3 recv"></a>3.3.3 recv</h4><p>继续追踪一下 recv 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 非缓冲型的 channel</span></span><br><span class="line"><span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 并且需要接收值</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 直接进行内存拷贝</span></span><br><span class="line">recvDirect(c.elemtype, sg, ep)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 需要注意：进入recv方法说明sendq队列里是有值的</span></span><br><span class="line"><span class="comment">// 那么对缓冲型的 channel来说，sendq有值就意味着buf满了</span></span><br><span class="line">        <span class="comment">// 也就是 recvx和sendx重合了都</span></span><br><span class="line">        <span class="comment">// 这里要做的就是先从buf中读一个数据出来，然后再把发送者发送的数据写入buf</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"><span class="comment">// 将接收游标处的数据拷贝给接收者</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从发送者把数据写入 recvx</span></span><br><span class="line">typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">        <span class="comment">// 然后修改 recvx和sendx 的位置</span></span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">gp := sg.g</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 最后唤醒发送的 goroutine</span></span><br><span class="line">goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-4-recvDirect"><a href="#3-3-4-recvDirect" class="headerlink" title="3.3.4 recvDirect"></a>3.3.4 recvDirect</h4><p>再看一下 recvDirect：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvDirect</span><span class="params">(t *_type, sg *sudog, dst unsafe.Pointer)</span></span> &#123;</span><br><span class="line"><span class="comment">// 如果是非缓冲型的，就直接从发送者的栈拷贝到接收者的栈。</span></span><br><span class="line">    <span class="comment">// 和sendDirect一样的需要加内存屏障</span></span><br><span class="line">src := sg.elem</span><br><span class="line">typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.size)</span><br><span class="line">memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-5-小结"><a href="#3-3-5-小结" class="headerlink" title="3.3.5 小结"></a>3.3.5 小结</h4><ul><li>不管是接收还是发送只要被阻塞了，加入到了 sendq 或者 recvq 之后，那么后续的发送或者接收都是由对方进行处理了。</li><li>比如接收被阻塞了，当前 g 构成一个 sudog 然后加入到 recvq ，接着调用了 gopark 就已经阻塞,只能等到有发送者来的时候直接从 recvq 里把这个 sudog 取出来，并且直接把要他发送的值拷贝到这个 sudog.elem 字段上，也就是调用chan接收方法是传进来的哪个值.</li><li>最后发送方再调用 goready 把这个 g 给唤醒，这样再把剩下的逻辑走完，这个被阻塞了一会的接收者就可以拿着数据返回了。</li></ul><p>核心逻辑：</p><ul><li>如果有等待发送数据的 groutine，从 sendq 中取出一个等待发送数据的 groutine，取出数据</li><li>如果没有等待的 groutine，且环形队列中有数据，从队列中取出数据</li><li>如果没有等待的 groutine，且环形队列中也没有数据，则阻塞该 Groutine，并将 groutine 打包为 sudog 加入到 recevq 等待队列中</li></ul><h3 id="3-4-关闭"><a href="#3-4-关闭" class="headerlink" title="3.4 关闭"></a>3.4 关闭</h3><h4 id="3-4-1-调用链"><a href="#3-4-1-调用链" class="headerlink" title="3.4.1 调用链"></a>3.4.1 调用链</h4><p>close 就比较简单了，相关方法就两个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname reflect_chanclose reflect.chanclose</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_chanclose</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">closechan(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>其中一个还是包装方法，真正逻辑就在 clsoechan 里。</p><blockquote><p>每个逻辑都有一个 reflect_xxx 的方法，根据名字猜测是反射的时候用的。</p></blockquote><h4 id="3-4-2-closechan"><a href="#3-4-2-closechan" class="headerlink" title="3.4.2 closechan"></a>3.4.2 closechan</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 关闭一个nil的chan直接panic</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同样是先加锁</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// 判断一下是否被关闭过了，关闭一个已经关闭的chan也是直接panic</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改closed标记为，表示chan已经被关闭了</span></span><br><span class="line">c.closed = <span class="number">1</span></span><br><span class="line"><span class="comment">// gList 是通过 g.schedlink 链接 G 的列表，一个 G 只能是一次在一个 gQueue 或 gList 上</span></span><br><span class="line"><span class="comment">// gList 模拟的是栈操作（FILO）</span></span><br><span class="line"><span class="comment">// gQueue 模拟的是队列操作（FIFO）</span></span><br><span class="line"><span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放所有的接收者</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.recvq.dequeue()</span><br><span class="line">        <span class="comment">// sg == nil，表示接收队列已为空，跳出循环</span></span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 如果 elem 不为空说明未忽略接收值，赋值为该类型的零值</span></span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放所有的发送者</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.sendq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环读取 glist 里面的数据，挨个唤醒</span></span><br><span class="line"><span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">gp := glist.pop()</span><br><span class="line">gp.schedlink = <span class="number">0</span></span><br><span class="line">goready(gp, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心流程：</p><ul><li>设置关闭状态</li><li>唤醒所有等待读取chanel的协程</li><li>所有等待写入channel的协程，抛出异常</li></ul><h4 id="3-4-3-优雅关闭"><a href="#3-4-3-优雅关闭" class="headerlink" title="3.4.3 优雅关闭"></a>3.4.3 优雅关闭</h4><ul><li>只在发送端关闭 channel。（防止关闭后继续发送）</li><li>存在多个发送者时不要关闭发送者 channel，而是使用专门的 stop channel。 sync.Once，来保证关闭channel的操作只执行一次</li><li>作为函数参数的channel最好带方向</li></ul><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h2><h3 id="4-1-存储实现"><a href="#4-1-存储实现" class="headerlink" title="4.1 存储实现"></a>4.1 存储实现</h3><p>chan 内部使用一个环形队列实现存储，使用 sendx或recvx进行发送或读取。</p><h3 id="4-2-并发安全"><a href="#4-2-并发安全" class="headerlink" title="4.2 并发安全"></a>4.2 并发安全</h3><p>使用 mutex 保证并发安全。</p><h3 id="4-3-调度"><a href="#4-3-调度" class="headerlink" title="4.3 调度"></a>4.3 调度</h3><p>使用 sendq 和 recvq来暂存由于发送或接收而被阻塞的goroutine。<br>send/recv的时候都会判断recvq/sendq是否有goroutine正在等待，有则优先处理。</p><h4 id="4-3-1-发送"><a href="#4-3-1-发送" class="headerlink" title="4.3.1 发送"></a>4.3.1 发送</h4><p><strong>发送</strong>的时候发现recvq有goroutine正在等待，说明此时chan的buf是空的，或者chan是个非缓存chan，根本没有buf。<br>对于发送来说，不管是buf为空还是chan没有buf都是一样的处理逻辑。<br>此时会直接从recvq中取出第一个g，然后把本次要发送的数据直接写给这个接收者g，并调用goready把这个g唤醒。</p><h4 id="4-3-2-接收"><a href="#4-3-2-接收" class="headerlink" title="4.3.2 接收"></a>4.3.2 接收</h4><p>如果接收的时候发现sendq有goroutine正在等待，说明buf满了，或者chan是个非缓存chan，根本没有buf。<br>对于接收来说buf满了或者chan没有buf二者的处理逻辑就不太一样了。</p><blockquote><p>因为需要保证顺序,buf满了就不能直接去读sender的数据了，只能从buf中去。</p></blockquote><p>如果是buf满了：那么会先从buf中读一个值出来(腾一个位置出来)，然后把sender发送的值写入buf，并唤醒这个sender g。<br>如果是没有buf的无缓存chan：那就直接把sender要发送的数据取出来，作为本次取到的数据，然后唤醒sender g。</p><h3 id="4-4-读写特点"><a href="#4-4-读写特点" class="headerlink" title="4.4 读写特点"></a>4.4 读写特点</h3><p>空读写阻塞，写关闭异常，读关闭空零</p><ul><li>读写值 nil 管道会永久阻塞</li><li>关闭的管道读数据仍然可以读数据</li><li>往关闭的管道写数据会 panic</li><li>关闭为 nil 的管道 panic</li><li>关闭已经关闭的管道 panic<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2></li></ul><p><a href="https://about.sourcegraph.com/go/understanding-channels-kavya-joshi/">understanding-channels-kavya-joshi</a><br><a href="https://juejin.cn/post/6875325172249788429">图解Golang channel源码</a><br><a href="https://github.com/talkgo/night/issues/450">Go夜读-第 56 期 channel &amp; select 源码分析</a><br><a href="https://maratrix.cn/post/2020/08/25/go-channel-source-read/">Go源码阅读 | channel 设计与实现</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习 golang 中的 chan，并分析其具体实现，包括创建 channel，发送数据，接收数据以及相关调度等。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="并发编程" scheme="https://stardustorz.github.io/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Go] sync.Cond</title>
    <link href="https://stardustorz.github.io/2022/07/14/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.Cond/"/>
    <id>https://stardustorz.github.io/2022/07/14/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.Cond/</id>
    <published>2022-07-13T16:00:00.000Z</published>
    <updated>2025-05-12T14:01:47.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>Golang 的 sync 包中的 Cond 实现了一种条件变量，可以使用在<strong>多个Reader</strong>等待共享资源 ready 的场景（如果只有一读一写，一个锁或者channel就搞定了）。<br>Cond的汇合点：多个goroutines等待、1个goroutine通知事件发生。<br>比较适合任务调用场景，一个 Master goroutine 通知事件发生，多个 Worker goroutine 在资源没准备好的时候就挂起，等待通知。<br><strong>使用方法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Cond</span></span><br><span class="line">cond := sync.NewCond(<span class="built_in">new</span>(sync.Mutex))</span><br><span class="line"><span class="comment">// 挂起goroutine</span></span><br><span class="line">cond.L.Lock()</span><br><span class="line">cond.Wait()</span><br><span class="line"><span class="comment">// 唤醒一个</span></span><br><span class="line">cond.Signal()</span><br><span class="line"><span class="comment">// 唤醒所有</span></span><br><span class="line">cond.Broadcast()</span><br></pre></td></tr></table></figure><blockquote><p>基本使用大概是需要等待的时候通过 Wait() 将 Goroutine 挂起，资源准备好的时候再通过 Signal() 或者 Broadcast() 将挂起中的 Goroutine 唤醒。</p></blockquote><p>一个简单的 Demo<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">locker sync.Mutex</span><br><span class="line">cond   = sync.NewCond(&amp;locker)</span><br><span class="line">wg     sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(number <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// wait()方法内部是先释放锁 然后在加锁 所以这里需要先 Lock()</span></span><br><span class="line">cond.L.Lock()</span><br><span class="line"><span class="keyword">defer</span> cond.L.Unlock()</span><br><span class="line">cond.Wait() <span class="comment">// 等待通知,阻塞当前 goroutine</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;g %v ok~ \n&quot;</span>, number)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 每过 50毫秒 唤醒一个 goroutine</span></span><br><span class="line">cond.Signal()</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line"><span class="comment">// 剩下5个 goroutine 一起唤醒</span></span><br><span class="line">cond.Broadcast()</span><br><span class="line">fmt.Println(<span class="string">&quot;Broadcast...&quot;</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><blockquote><p>go version 1.14.7</p></blockquote><h3 id="2-1-Cond"><a href="#2-1-Cond" class="headerlink" title="2.1 Cond"></a>2.1 Cond</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 21</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line">    L Locker</span><br><span class="line">    notify  notifyList</span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCond() 返回指针，保证多 goroutine 获取到的是同一个实例。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span></span> *Cond &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Cond&#123;L: l&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>noCopy</strong>：noCopy对象，实现了<code>sync.Locker</code>接口，使得内嵌 noCopy 的对象在进行 go vet 静态检查的时候，可以检查出是否被复制。</p><blockquote><p>noCopy 具体见 <a href="https://github.com/golang/go/issues/8005">Go issues 8005</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 94</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> noCopy <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*noCopy)</span></span> Lock()   &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*noCopy)</span></span> Unlock() &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>L</strong>：实现了 <code>sync.Locker</code> 接口的锁对象，通常使用 Mutex 或 RWMutex 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： mutex.go</span></span><br><span class="line"><span class="comment">line: 31</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">     Lock()</span><br><span class="line">     Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>notify</strong>：notifyList 对象，维护等待唤醒的 goroutine 队列,使用链表实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： runtime.go</span></span><br><span class="line"><span class="comment">line: 33    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">wait   <span class="type">uint32</span></span><br><span class="line">notify <span class="type">uint32</span></span><br><span class="line">lock   <span class="type">uintptr</span></span><br><span class="line">head   unsafe.Pointer</span><br><span class="line">tail   unsafe.Pointer</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>checker</strong>：copyChecker 对象，实际上是 uintptr 对象，保存自身对象地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 79    </span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="keyword">type</span> copyChecker <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *copyChecker)</span></span> check() &#123;</span><br><span class="line">     <span class="keyword">if</span> <span class="type">uintptr</span>(*c) != <span class="type">uintptr</span>(unsafe.Pointer(c)) &amp;&amp;</span><br><span class="line">            !atomic.CompareAndSwapUintptr((*<span class="type">uintptr</span>)(c), <span class="number">0</span>, <span class="type">uintptr</span>(unsafe.Pointer(c))) &amp;&amp;</span><br><span class="line">            <span class="type">uintptr</span>(*c) != <span class="type">uintptr</span>(unsafe.Pointer(c)) &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;sync.Cond is copied&quot;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>1）检查当前 checker 对象的地址是否等于保存在 checker 中的地址</p><ul><li>由于第一次比较的时候 checker 中没有存地址所以第一次比较肯定是不相等的，于是有了后续 2 3步。</li></ul></li><li><p>2）对 checker 进行 CAS 操作，如果 checker 中存储的地址值为空（就是0）就把当前 checker 对象的地址值存进去</p></li><li>3）第三步和第一步一样，再比较一下。<ul><li>主要是防止在第一步比较发现不相等之后，第二步 CAS 之前，其他 goroutine 也在执行这个方法，并发的将 checker 赋值了，导致这里判定的时候第二步 CAS 失败，返回 false，然后错误的抛出一个 panic，所以执行第三步在比较一下是否相等。如果其他 goroutine 抢先执行 CAS 修改了 checker 中的值导致这里第二步也返回 false 的话，第三步的判定也会是相等的，不会抛出 panic</li></ul></li><li>4）如果 3 个条件都成立，那 checker 肯定是被复制了，就是由于 cond 被复制引起的。</li></ul><blockquote><p>check 方法在第一次调用的时候，会将 checker 对象地址赋值给 checker，也就是将自身内存地址赋值给自身。<br>再次调用 checker 方法的时候，会将当前 checker 对象地址值与 checker 中保存的地址值（原始地址）进行比较，若不相同则表示当前 checker 的地址不是第一次调用 check 方法时候的地址，即 cond 对象被复制了，导致checker 被重新分配了内存地址。</p></blockquote><h3 id="2-2-Wait"><a href="#2-2-Wait" class="headerlink" title="2.2 Wait"></a>2.2 Wait</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 52    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait() &#123;</span><br><span class="line">    <span class="comment">// 1.每次操作之前都要检测一下 cond 是否被复制了。</span></span><br><span class="line">    c.checker.check() </span><br><span class="line">    <span class="comment">// 2.将 notifyList 中的 wait 值加1并返回之前的值</span></span><br><span class="line">    t := runtime_notifyListAdd(&amp;c.notify) </span><br><span class="line">    <span class="comment">// 3.释放锁，因此在调用Wait方法前，必须保证获取到了cond的锁，否则会报错</span></span><br><span class="line">    c.L.Unlock()</span><br><span class="line">    <span class="comment">// 4.将当前goroutine挂起，等待唤醒信号</span></span><br><span class="line">    runtime_notifyListWait(&amp;c.notify, t) </span><br><span class="line">    <span class="comment">// 5.gorountine被唤醒，重新获取锁</span></span><br><span class="line">    c.L.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> package: runtime</span></span><br><span class="line"><span class="comment"> file： sema.go</span></span><br><span class="line"><span class="comment"> line: 479  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListAdd</span><span class="params">(l *notifyList)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> atomic.Xadd(&amp;l.wait, <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: runtime</span></span><br><span class="line"><span class="comment">file： sema.go</span></span><br><span class="line"><span class="comment">line: 488  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 获取当前 goroutine 添加到链表末端，然后 goparkunlock 函数休眠阻塞当前 goroutine</span></span><br><span class="line"><span class="comment">// goparkunlock 函数会让出当前处理器的使用权并等待调度器的唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListWait</span><span class="params">(l *notifyList, t <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.锁住 notify 队列</span></span><br><span class="line">    lock(&amp;l.lock)</span><br><span class="line">    <span class="comment">// 2.判断传入的等待序号t是否小于当前已经唤醒的序号notify</span></span><br><span class="line">    <span class="comment">// 如果是则说明当前 goroutine 不需要阻塞了 直接解锁并返回</span></span><br><span class="line">    <span class="comment">// 有可能执行这步之前 goroutine 就已经被唤醒了</span></span><br><span class="line">    <span class="keyword">if</span> less(t, l.notify) &#123;</span><br><span class="line">        unlock(&amp;l.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.获取当前 goroutine，设置相关参数，将当前等待数赋值给 ticket</span></span><br><span class="line">    s := acquireSudog()</span><br><span class="line">    s.g = getg()</span><br><span class="line">    s.ticket = t</span><br><span class="line">    s.releasetime = <span class="number">0</span></span><br><span class="line">    t0 := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">        s.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.将当前 goroutine 写入到链表尾部</span></span><br><span class="line">    <span class="keyword">if</span> l.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">        l.head = s</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l.tail.next = s</span><br><span class="line">    &#125;</span><br><span class="line">    l.tail = s</span><br><span class="line">    <span class="comment">// 5. 调用 goparkunlock 函数将当前 goroutine 挂起，等待唤醒信号</span></span><br><span class="line">    goparkunlock(&amp;l.lock, <span class="string">&quot;semacquire&quot;</span>, traceEvGoBlockCond, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(s.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-Signal"><a href="#2-3-Signal" class="headerlink" title="2.3 Signal"></a>2.3 Signal</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 64  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal() &#123;</span><br><span class="line">    <span class="comment">// 1.复制检查</span></span><br><span class="line">    c.checker.check() </span><br><span class="line">    <span class="comment">// 2.顺序唤醒一个等待的gorountine</span></span><br><span class="line">    runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: runtime</span></span><br><span class="line"><span class="comment">file： sema.go</span></span><br><span class="line"><span class="comment">line: 554  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyOne</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 1.等待序号和唤醒序号相同则说明没有需要唤醒的 goroutine 直接返回</span></span><br><span class="line">   <span class="keyword">if</span> atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 2.锁住队列后再检查一遍等待序号和唤醒序号是否相同即判断有没有需要唤醒的 goroutine，没有则解锁后直接返回</span></span><br><span class="line">   lock(&amp;l.lock) </span><br><span class="line">   t := l.notify</span><br><span class="line">   <span class="keyword">if</span> t == atomic.Load(&amp;l.wait) &#123;</span><br><span class="line">        unlock(&amp;l.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 3.到这里就说明有需要唤醒的 goroutine，于是先将 notify序号+1</span></span><br><span class="line">   atomic.Store(&amp;l.notify, t+<span class="number">1</span>)  </span><br><span class="line">   <span class="comment">// 4.然后就开始唤醒 goroutine 了</span></span><br><span class="line">   <span class="keyword">for</span> p, s := (*sudog)(<span class="literal">nil</span>), l.head; s != <span class="literal">nil</span>; p, s = s, s.next &#123;</span><br><span class="line">        <span class="comment">// 4.1 找到 ticket等于当前唤醒序号的 goroutine</span></span><br><span class="line">        <span class="keyword">if</span> s.ticket == t &#123;</span><br><span class="line">           <span class="comment">// 4.2 然后将其从等待唤醒链表中移除（因为这个 goroutine 马上就要被唤醒了）</span></span><br><span class="line">           n := s.next</span><br><span class="line">           <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">               p.next = n</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               l.head = n</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">               l.tail = p</span><br><span class="line">           &#125;</span><br><span class="line">           unlock(&amp;l.lock)</span><br><span class="line">           s.next = <span class="literal">nil</span></span><br><span class="line">           <span class="comment">// 4.3 然后唤醒这个 goroutine </span></span><br><span class="line">           readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">           <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 4.4 最后解锁队列 </span></span><br><span class="line">   unlock(&amp;l.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-Broadcast"><a href="#2-4-Broadcast" class="headerlink" title="2.4 Broadcast"></a>2.4 Broadcast</h3><p>唤醒链表中所有的阻塞中的goroutine，还是使用readyWithTime来实现这个功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 73  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast() &#123;</span><br><span class="line">    <span class="comment">// 1.复制检查</span></span><br><span class="line">    c.checker.check()</span><br><span class="line">    <span class="comment">// 2.唤醒所有在等待的 goroutine</span></span><br><span class="line">    runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里和 <code>notifyListNotifyOne()</code>差不多，只是一次性唤醒所有 goroutine。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: runtime</span></span><br><span class="line"><span class="comment">file： sema.go</span></span><br><span class="line"><span class="comment">line: 522 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyAll</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.等待序号和唤醒序号相同则说明没有需要唤醒的 goroutine 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将链表头尾指针置为空（可以看做是清空整个等待队列）</span></span><br><span class="line">    <span class="comment">// 但是需要将当前的链表头保存下来，不然等会找不到链表中的数据了</span></span><br><span class="line">    lock(&amp;l.lock)</span><br><span class="line">    s := l.head</span><br><span class="line">    l.head = <span class="literal">nil</span></span><br><span class="line">    l.tail = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.直接将notify需要赋值成等待序号（这样表示当前没有需要唤醒的 goroutine 了）</span></span><br><span class="line">    <span class="comment">// 前面唤醒一个的时候这里是+1</span></span><br><span class="line">    atomic.Store(&amp;l.notify, atomic.Load(&amp;l.wait))</span><br><span class="line">    unlock(&amp;l.lock)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4.最后 for 循环唤醒链表中所有等待状态的 goroutine</span></span><br><span class="line">    <span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">        next := s.next</span><br><span class="line">        s.next = <span class="literal">nil</span></span><br><span class="line">        readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">        s = next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p><strong>基本使用</strong></p><ul><li>1）资源未准备好时，使用 Wait() 方法将 goroutine 挂起，由底层实现，会让出 CPU 时间片，从而避免使用无意义的循环浪费系统资源。</li><li>2）资源准备好时通过 Signal() 或者 Broadcast() 方法唤醒一个或多个被挂起的 goroutine。</li></ul><p><strong>等待唤醒流程</strong></p><ul><li>1）所有相关数据都是存在 notifyList 中的，包括 goroutine 和一些计数信息。</li><li>2）其中的 wait 和 notify 可以理解为等待序号和唤醒序号，都是自增值，wait 在有新 goroutine 等待时+1，notify 则在唤醒一个 goroutine 时+1。</li><li>3）等待状态的 goroutine 信息则存放在链表中，等待时加入链表尾部，唤醒时移除。</li><li>4）每个等待链表的 goroutine  都会将当前的 wait（等待序号）赋值给 ticket 字段，唤醒的时候会将 ticket=唤醒序号的 goroutine 唤醒。</li><li>5）当 wait==notify 时表示没有 goroutine 需要被唤醒，wait&gt;notify 时表示有 goroutine 需要被唤醒，wait 恒大于等于 notify。</li></ul><p><strong>noCopy</strong><br>Cond在内部持有一个等待队列 notifyList ，这个队列维护所有等待在这个 Cond 的 goroutine。如果 Cond 被复制则会导致其中的等待队列也被复制，最终可能会导致在唤醒 goroutine 的时候出现错误。<br>Kubernetes 的调度中也用到了 sync.Cond 有兴趣的可以研究一下。</p><blockquote><p><a href="https://mp.weixin.qq.com/s/rKLiazgWzneJfpfgHay8cA">https://mp.weixin.qq.com/s/rKLiazgWzneJfpfgHay8cA</a><br><a href="https://github.com/kubernetes/kubernetes/blob/0599ca2bcfcae7d702f95284f3c2e2c2978c7772/pkg/scheduler/internal/queue/scheduling_queue.go">https://github.com/kubernetes/kubernetes/blob/0599ca2bcfcae7d702f95284f3c2e2c2978c7772/pkg/scheduler/internal/queue/scheduling_queue.go</a></p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><code>https://ieevee.com/tech/2019/06/15/cond.html</code></p></blockquote><p><code>https://segmentfault.com/a/1190000019957459</code></p><p><code>https://www.jianshu.com/p/7b59d1d92a95</code></p><p><code>http://www.pydevops.com/2016/12/04/go-cond源码剖析-3/</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h2&gt;&lt;p&gt;Golang 的 sync 包中的 Cond 实现了一种条件变量，可以使用在&lt;strong&gt;多个Reader&lt;/strong</summary>
      
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="并发编程" scheme="https://stardustorz.github.io/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Go] Context</title>
    <link href="https://stardustorz.github.io/2022/07/10/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Context/"/>
    <id>https://stardustorz.github.io/2022/07/10/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Context/</id>
    <published>2022-07-09T16:00:00.000Z</published>
    <updated>2025-03-08T15:40:39.791Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Context 主要用于在异步场景中用于实现并发协调以及对 goroutine 的生命周期控制. 除此之外，context 还兼有一定的数据存储能力.</p></blockquote><span id="more"></span><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h2><h3 id="1-1-context-Context"><a href="#1-1-context-Context" class="headerlink" title="1.1 context.Context"></a>1.1 context.Context</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Context 包提供暴露 Context 接口; </li><li>可以在多个 Goroutine 共享数据，实现多 Goroutine 管理机制; </li><li>Context 是协程安全的；</li></ul><p>Context 接口定义了四个核心 api :</p><ul><li>Deadline 方法返回第一个参数是设置的截止时间，到时间Context会自动发起取消请求； 第二个参数是bool值，为false时表示没有设置截止时间，如果要取消需要调用取消函数;</li><li>Done 方法返回一个只读 Channel，类型为 struct{}, 这个 Channel 会在当前工作完成或者上下文被取消之后关闭， 多次调用 Done 方法会返回同一个 Channel；</li><li>Err 方法会返回当前 Context 结束的原因，它只会在 Done 返回的 Channel 被关闭时才会返回非空的值；<ul><li>如果当前 Context 被取消就会返回 Canceled 错误；</li><li>如果当前 Context 超时就会返回 DeadlineExceeded 错误；</li></ul></li><li>Value 方法会从 Context 中返回键对应的值，对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果，这个功能可以用来传递请求特定的数据；获取Value值时是线程安全的； key 必须为非空，且可比较;</li></ul><h3 id="1-2-标准-error"><a href="#1-2-标准-error" class="headerlink" title="1.2 标准 error"></a>1.2 标准 error</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Canceled = errors.New(<span class="string">&quot;context canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DeadlineExceeded <span class="type">error</span> = deadlineExceededError&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> deadlineExceededError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Error() <span class="type">string</span>   &#123; <span class="keyword">return</span> <span class="string">&quot;context deadline exceeded&quot;</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Timeout() <span class="type">bool</span>   &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Temporary() <span class="type">bool</span> &#123; <span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>Canceled：context 被 cancel 时会报此错误；</li><li>DeadlineExceeded：context 超时时会报此错误.</li></ul><h2 id="2-emptyCtx"><a href="#2-emptyCtx" class="headerlink" title="2 emptyCtx"></a>2 emptyCtx</h2><h3 id="2-1-类实现"><a href="#2-1-类实现" class="headerlink" title="2.1 类实现"></a>2.1 类实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>emptyCtx 是一个不可取消，没有设置截止时间，没有携带任何值的Context;</li><li>emptyCtx 是一个空的 context，本质上类型为一个整型；</li><li>Deadline 方法会返回一个公元元年时间以及 false 的 flag，标识当前 context 不存在过期时间；</li><li>Done 方法返回一个 nil 值，用户无论往 nil 中写入或者读取数据，均会陷入阻塞；</li><li>Err 方法返回的错误永远为 nil；</li><li>Value 方法返回的 value 同样永远为 nil.</li></ul><h3 id="2-2-context-Background-amp-context-TODO"><a href="#2-2-context-Background-amp-context-TODO" class="headerlink" title="2.2 context.Background() &amp; context.TODO()"></a>2.2 context.Background() &amp; context.TODO()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">    todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>内置2个Context实现,通常用来做顶层的parent context; TODO一般在不知道使用什么Context时使用；</li><li>todo 和 background 两者本质上只有名字区别，在按 string 输出的时候会有区别; </li><li>context.Background() 和 context.TODO() 方法返回的均是 emptyCtx 类型的一个实例</li></ul><h2 id="3-cancelCtx"><a href="#3-cancelCtx" class="headerlink" title="3  cancelCtx"></a>3  cancelCtx</h2><h3 id="3-1-cancelCtx-数据结构"><a href="#3-1-cancelCtx-数据结构" class="headerlink" title="3.1 cancelCtx 数据结构"></a>3.1 cancelCtx 数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line"></span><br><span class="line">    mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">    done     atomic.Value          <span class="comment">// of chan struct&#123;&#125;, created lazily, closed by first cancel call</span></span><br><span class="line">    children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">    err      <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">    cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• embed 了一个 context 作为其父 context. cancelCtx 必然为某个 context 的子 context；<br>• 内置了一把锁，用以协调并发场景下的资源获取；<br>• done：实际类型为 chan struct{}，即用以反映 cancelCtx 生命周期的通道；<br>• children：一个 set，指向 cancelCtx 的所有子 context；<br>• err：记录了当前 cancelCtx 的错误. 必然为某个 context 的子 context；</p><h3 id="3-2-Deadline-方法"><a href="#3-2-Deadline-方法" class="headerlink" title="3.2 Deadline 方法"></a>3.2 Deadline 方法</h3><p>cancelCtx 未实现该方法，仅是 embed 了一个带有 Deadline 方法的 Context interface，因此直接调用会报错.</p><h3 id="3-3-Done-方法"><a href="#3-3-Done-方法" class="headerlink" title="3.3 Done 方法"></a>3.3 Done 方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">    d := c.done.Load()</span><br><span class="line">    <span class="keyword">if</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    d = c.done.Load()</span><br><span class="line">    <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">        d = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        c.done.Store(d)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 基于 atomic 包，读取 cancelCtx 中的 chan；倘若已存在，则直接返回；<br>• 加锁后，在此检查 chan 是否存在，若存在则返回；（double check）<br>• 初始化 chan 存储到 aotmic.Value 当中，并返回.（懒加载机制）</p><h3 id="3-4-Err-方法"><a href="#3-4-Err-方法" class="headerlink" title="3.4 Err 方法"></a>3.4 Err 方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    err := c.err</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 加锁；<br>• 读取 cancelCtx.err；<br>• 解锁；<br>• 返回结果.</p><h3 id="3-5-Value-方法"><a href="#3-5-Value-方法" class="headerlink" title="3.5  Value 方法"></a>3.5  Value 方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">    <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 倘若 key 特定值 &amp;cancelCtxKey，则返回 cancelCtx 自身的指针；<br>• 否则遵循 valueCtx 的思路取值返回</p><h3 id="3-6-context-WithCancel"><a href="#3-6-context-WithCancel" class="headerlink" title="3.6 context.WithCancel()"></a>3.6 context.WithCancel()</h3><h4 id="3-6-1-context-WithCancel"><a href="#3-6-1-context-WithCancel" class="headerlink" title="3.6.1 context.WithCancel()"></a>3.6.1 context.WithCancel()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c := newCancelCtx(parent)</span><br><span class="line">    propagateCancel(parent, &amp;c)</span><br><span class="line">    <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 校验父 context 非空；<br>• 注入父 context 构造好一个新的 cancelCtx；<br>• 在 propagateCancel 方法内启动一个守护协程，以保证父 context 终止时，该 cancelCtx 也会被终止；<br>• 将 cancelCtx 返回，连带返回一个用以终止该 cancelCtx 的闭包函数.</p><h4 id="3-6-2-newCancelCtx"><a href="#3-6-2-newCancelCtx" class="headerlink" title="3.6.2 newCancelCtx"></a>3.6.2 newCancelCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span></span> cancelCtx &#123;</span><br><span class="line">    <span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 注入父 context 后，返回一个新的 cancelCtx.</p><h4 id="3-6-3-propagateCancel"><a href="#3-6-3-propagateCancel" class="headerlink" title="3.6.3 propagateCancel"></a>3.6.3 propagateCancel</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">    done := parent.Done()</span><br><span class="line">    <span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        <span class="comment">// parent is already canceled</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">        p.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// parent has already been canceled</span></span><br><span class="line">            child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">                p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.mu.Unlock()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        atomic.AddInt32(&amp;goroutines, +<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">                child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">            <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>propagateCancel 方法传递父子 context 之间的 cancel 事件：<br>• 倘若 parent 是不会被 cancel 的类型（如 emptyCtx），则直接返回；<br>• 倘若 parent 已经被 cancel，则直接终止子 context，并以 parent 的 err 作为子 context 的 err；<br>• 假如 parent 是 cancelCtx 的类型，则加锁，并将子 context 添加到 parent 的 children map 当中；<br>• 假如 parent 不是 cancelCtx 类型，但又存在 cancel 的能力（比如用户自定义实现的 context），则启动一个协程，通过多路复用的方式监控 parent 状态，倘若其终止，则同时终止子 context，并透传 parent 的 err.</p><p><strong>校验 parent 是否为 cancelCtx 的类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span></span> (*cancelCtx, <span class="type">bool</span>) &#123;</span><br><span class="line">    done := parent.Done()</span><br><span class="line">    <span class="keyword">if</span> done == closedchan || done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    pdone, _ := p.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> pdone != done &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 倘若 parent 的 channel 已关闭或者是不会被 cancel 的类型，则返回 false；<br>• 倘若以特定的 cancelCtxKey 从 parent 中取值，取得的 value 是 parent 本身，则返回 true. （基于 cancelCtxKey 为 key 取值时返回 cancelCtx 自身，是 cancelCtx 特有的协议）.</p><h2 id="4-timerCtx"><a href="#4-timerCtx" class="headerlink" title="4 timerCtx"></a>4 timerCtx</h2><h3 id="4-1-类实现"><a href="#4-1-类实现" class="headerlink" title="4.1 类实现"></a>4.1 类实现</h3><ul><li>timerCtx 内部不仅通过嵌入 cancelCtx 的方式承了相关的变量和方法，还通过持有的定时器 <code>timer</code> 和截止时间 <code>deadline</code> 实现了定时取消的功能：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">cancelCtx</span><br><span class="line">timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-timerCtx-Deadline"><a href="#4-2-timerCtx-Deadline" class="headerlink" title="4.2 timerCtx.Deadline()"></a>4.2 timerCtx.Deadline()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.deadline, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>context.Context interface 下的 Deadline api 仅在 timerCtx 中有效，由于展示其过期时间.<h3 id="4-3-timerCtx-cancel"><a href="#4-3-timerCtx-cancel" class="headerlink" title="4.3 timerCtx.cancel"></a>4.3 timerCtx.cancel</h3></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line"><span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">removeChild(c.cancelCtx.Context, c)</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">c.timer.Stop()</span><br><span class="line">c.timer = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>timerCtx.cancel 不仅调用了 cancelCtx.cancel 方法，还会停止持有的定时器减少不必要的资源浪费。</li><li>实际上对外提供了 WithTimeout 方法只是 WithDeadline 的封装</li></ul><h3 id="4-4-context-WithTimeout-amp-context-WithDeadline"><a href="#4-4-context-WithTimeout-amp-context-WithDeadline" class="headerlink" title="4.4 context.WithTimeout &amp; context.WithDeadline"></a>4.4 context.WithTimeout &amp; context.WithDeadline</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line"><span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line"><span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line"><span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">&#125;</span><br><span class="line">c := &amp;timerCtx&#123;</span><br><span class="line">cancelCtx: newCancelCtx(parent),</span><br><span class="line">deadline:  d,</span><br><span class="line">&#125;</span><br><span class="line">propagateCancel(parent, c)</span><br><span class="line">dur := time.Until(d)</span><br><span class="line"><span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line"><span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 校验 parent context 非空；<br>• 校验 parent 的过期时间是否早于自己，若是，则构造一个 cancelCtx 返回即可；<br>• 构造出一个新的 timerCtx；<br>• 启动守护方法，同步 parent 的 cancel 事件到子 context；<br>• 判断过期时间是否已到，若是，直接 cancel timerCtx，并返回 DeadlineExceeded 的错误；<br>• 加锁；<br>• 启动 time.Timer，设定一个延时时间，即达到过期时间后会终止该 timerCtx，并返回 DeadlineExceeded 的错误；<br>• 解锁；<br>• 返回 timerCtx，已经一个封装了 cancel 逻辑的闭包 cancel 函数.</p><h2 id="5-valueCtx"><a href="#5-valueCtx" class="headerlink" title="5 valueCtx"></a>5 valueCtx</h2><h3 id="5-1-类实现"><a href="#5-1-类实现" class="headerlink" title="5.1 类实现"></a>5.1 类实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context</span><br><span class="line">key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• valueCtx 同样继承了一个 parent context；<br>• 一个 valueCtx 中仅有一组 kv 对.</p><h3 id="5-2-valueCtx-Value"><a href="#5-2-valueCtx-Value" class="headerlink" title="5.2 valueCtx.Value()"></a>5.2 valueCtx.Value()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">    <span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">        <span class="keyword">return</span> c.val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 假如当前 valueCtx 的 key 等于用户传入的 key，则直接返回其 value；<br>• 假如不等，则从 parent context 中依次向上寻找.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(c Context, key any)</span></span> any &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> ctx := c.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> *valueCtx:</span><br><span class="line">            <span class="keyword">if</span> key == ctx.key &#123;</span><br><span class="line">                <span class="keyword">return</span> ctx.val</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctx.Context</span><br><span class="line">        <span class="keyword">case</span> *cancelCtx:</span><br><span class="line">            <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">                <span class="keyword">return</span> c</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctx.Context</span><br><span class="line">        <span class="keyword">case</span> *timerCtx:</span><br><span class="line">            <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">                <span class="keyword">return</span> &amp;ctx.cancelCtx</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctx.Context</span><br><span class="line">        <span class="keyword">case</span> *emptyCtx:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> c.Value(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动一个 for 循环，由下而上，由子及父，依次对 key 进行匹配；</li><li>其中 cancelCtx、timerCtx、emptyCtx 类型会有特殊的处理方式；</li><li>找到匹配的 key，则将该组 value 进行返回.</li><li>最终找到根节点（一般是 emptyCtx），直接返回一个 nil。所以用 Value 方法的时候要判断结果是否为 nil。</li></ul><h3 id="5-3-valueCtx-用法小结"><a href="#5-3-valueCtx-用法小结" class="headerlink" title="5.3 valueCtx 用法小结"></a>5.3 valueCtx 用法小结</h3><p>valueCtx 不适合视为存储介质，存放大量的 kv 数据</p><ul><li>一个 valueCtx 实例只能存一个 kv 对，因此 n 个 kv 对会嵌套 n 个 valueCtx，造成空间浪费；</li><li>基于 k 寻找 v 的过程是线性的，时间复杂度 O(N)；</li><li>不支持基于 k 的去重，相同 k 可能重复存在，并基于起点的不同，返回不同的 v. 由此得知，valueContext 的定位类似于请求头，只适合存放少量作用域较大的全局 meta 数据.</li></ul><h3 id="5-4-context-WithValue"><a href="#5-4-context-WithValue" class="headerlink" title="5.4 context.WithValue()"></a>5.4 context.WithValue()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val any)</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>parent context 为空，panic；</li><li>key 为空 panic；</li><li>key 的类型不可比较，panic；</li><li>包括 parent context 以及 kv对，返回一个新的 valueCtx.</li></ul><h2 id="6-使用原则"><a href="#6-使用原则" class="headerlink" title="6 使用原则"></a>6 使用原则</h2><ol><li>不要把 Context 放在结构体中，要以参数的方式传递</li><li>以 Context 作为参数的函数方法，应该把 Context 作为第一个参数，放在第一位。</li><li>给一个函数方法传递 Context 的时候，不要传递 nil，如果不知道传递什么，就使用 context.TODO</li><li>Context 的 Value 相关方法应该传递必须的数据，不要什么数据都使用这个传递</li><li>Context 是线程安全的，可以放心的在多个 goroutine 中传递</li><li>在子 Context 被传递到的 goroutine 中，应该对该子 Context 的 Done（channel）进行监控</li></ol><h2 id="7-Context-Demo"><a href="#7-Context-Demo" class="headerlink" title="7 Context Demo"></a>7 Context Demo</h2><h3 id="7-1-Context控制多个goroutine"><a href="#7-1-Context控制多个goroutine" class="headerlink" title="7.1 Context控制多个goroutine"></a>7.1 Context控制多个goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    valueCtx1 := context.WithValue(ctx, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;goroutine 1&quot;</span>)</span><br><span class="line">    valueCtx2 := context.WithValue(ctx, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;goroutine 2&quot;</span>)</span><br><span class="line">    valueCtx3 := context.WithValue(ctx, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;goroutine 3&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> watch(valueCtx1)</span><br><span class="line">    <span class="keyword">go</span> watch(valueCtx2)</span><br><span class="line">    <span class="keyword">go</span> watch(valueCtx3)</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;cancel &quot;</span>, ctx.String())</span><br><span class="line">    cancel()</span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(ctx.String() ,<span class="string">&quot; done&quot;</span>, ctx.Err())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(ctx.Value(<span class="string">&quot;key&quot;</span>), <span class="string">&quot;wait...&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-Context-http请求超时"><a href="#7-2-Context-http请求超时" class="headerlink" title="7.2 Context http请求超时"></a>7.2 Context http请求超时</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个超时时间为100毫秒的上下文</span></span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    ctx, _ = context.WithTimeout(ctx, <span class="number">100</span>*time.Millisecond)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个访问Google主页的请求</span></span><br><span class="line">    req, _ := http.NewRequest(http.MethodGet, <span class="string">&quot;http://google.com&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 将超时上下文关联到创建的请求上</span></span><br><span class="line">    req = req.WithContext(ctx)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个HTTP客户端并执行请求</span></span><br><span class="line">    client := &amp;http.Client&#123;&#125;</span><br><span class="line">    res, err := client.Do(req)</span><br><span class="line">    <span class="comment">// 如果请求失败了，记录到STDOUT</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Request failed:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求成功后打印状态码</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Response received, status code:&quot;</span>, res.StatusCode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-Context-http服务器"><a href="#7-3-Context-http服务器" class="headerlink" title="7.3 Context http服务器"></a>7.3 Context http服务器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个监听8000端口的服务器</span></span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    ctx := r.Context()</span><br><span class="line">    <span class="comment">// 输出到STDOUT展示处理已经开始</span></span><br><span class="line">    fmt.Fprint(os.Stdout, <span class="string">&quot;processing request\n&quot;</span>)</span><br><span class="line">    <span class="comment">// 通过select监听多个channel</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">        <span class="comment">// 如果两秒后接受到了一个消息后，意味请求已经处理完成</span></span><br><span class="line">        <span class="comment">// 我们写入&quot;request processed&quot;作为响应</span></span><br><span class="line">        w.Write([]<span class="type">byte</span>(<span class="string">&quot;request processed&quot;</span>))</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        <span class="comment">// 如果处理完成前取消了，在STDERR中记录请求被取消的消息</span></span><br><span class="line">        fmt.Fprint(os.Stderr, <span class="string">&quot;request cancelled\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-Context-超时控制多个goroutine"><a href="#7-4-Context-超时控制多个goroutine" class="headerlink" title="7.4 Context 超时控制多个goroutine"></a>7.4 Context 超时控制多个goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ctx context.Context, wg *sync.WaitGroup)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;Timeout &quot;</span>, ctx.Err())</span><br><span class="line">            <span class="keyword">return</span> ctx.Err()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">100</span>*time.Millisecond)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> worker(ctx, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    cancel()</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-Context-取消控制多个goroutine"><a href="#7-5-Context-取消控制多个goroutine" class="headerlink" title="7.5 Context 取消控制多个goroutine"></a>7.5 Context 取消控制多个goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work1</span><span class="params">(ctx context.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 假设这个操作会因为某种原因失败</span></span><br><span class="line">    <span class="comment">// 使用time.Sleep来模拟一个资源密集型操作</span></span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work2</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">500</span> * time.Millisecond):</span><br><span class="line">        fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(<span class="string">&quot;halted work2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    <span class="comment">// cancel context</span></span><br><span class="line">    ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">    <span class="comment">// 在不同的goroutine中运行work2</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        work2(ctx)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        work2(ctx)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    err := work1(ctx)</span><br><span class="line">    <span class="comment">// 如果这个操作返回错误，取消所有使用相同Context的操作</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//发出取消事件</span></span><br><span class="line">        cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-6-Context-控制后台goroutine-生成素数"><a href="#7-6-Context-控制后台goroutine-生成素数" class="headerlink" title="7.6 Context 控制后台goroutine 生成素数"></a>7.6 Context 控制后台goroutine 生成素数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回生成自然数序列的管道: 2, 3, 4, ...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateNatural</span><span class="params">(ctx context.Context)</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">2</span>; ; i++ &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 结束生成自然数</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道过滤器: 删除能被素数整除的数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrimeFilter</span><span class="params">(ctx context.Context, in &lt;-<span class="keyword">chan</span> <span class="type">int</span>, prime <span class="type">int</span>)</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> i := &lt;-in; i%prime != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 结束过滤器</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> out &lt;- i:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通过 Context 控制后台Goroutine状态</span></span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">    ch := GenerateNatural(ctx) <span class="comment">// 自然数序列: 2, 3, 4, ...</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        prime := &lt;-ch <span class="comment">// 新出现的素数</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v: %v\n&quot;</span>, i+<span class="number">1</span>, prime)</span><br><span class="line">        ch = PrimeFilter(ctx, ch, prime) <span class="comment">// 基于新素数构造的过滤器</span></span><br><span class="line">    &#125;</span><br><span class="line">    cancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-参考"><a href="#8-参考" class="headerlink" title="8 参考"></a>8 参考</h2><ul><li><a href="https://pkg.go.dev/context">https://pkg.go.dev/context</a></li><li><a href="https://faiface.github.io/post/context-should-go-away-go2/">https://faiface.github.io/post/context-should-go-away-go2/</a></li><li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/</a></li><li><a href="https://blog.csdn.net/qq_36183935/article/details/81137834">https://blog.csdn.net/qq_36183935/article/details/81137834</a></li><li><a href="https://blog.csdn.net/u011957758/article/details/82948750">https://blog.csdn.net/u011957758/article/details/82948750</a></li><li><a href="https://www.jianshu.com/p/e5df3cd0708bhttps://zhuanlan.zhihu.com/p/68792989">https://www.jianshu.com/p/e5df3cd0708bhttps://zhuanlan.zhihu.com/p/68792989</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Context 主要用于在异步场景中用于实现并发协调以及对 goroutine 的生命周期控制. 除此之外，context 还兼有一定的数据存储能力.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="并发编程" scheme="https://stardustorz.github.io/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Go] sync.Mutex</title>
    <link href="https://stardustorz.github.io/2022/07/09/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.Mutex/"/>
    <id>https://stardustorz.github.io/2022/07/09/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.Mutex/</id>
    <published>2022-07-08T16:00:00.000Z</published>
    <updated>2025-05-12T14:00:40.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="1 基本结构"></a>1 基本结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/mutex.go 25行</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">state <span class="type">int32</span>      <span class="comment">// 当前互斥锁的状态</span></span><br><span class="line">sema  <span class="type">uint32</span>     <span class="comment">// 控制锁状态的信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-state字段"><a href="#1-1-state字段" class="headerlink" title="1.1 state字段"></a>1.1 state字段</h3><p>![[Pasted image 20230901043018.png]]<br>低三位分别标识</p><ul><li>mutexLocked（是否上锁）</li><li>mutexWoken（是否有协程在抢锁）</li><li>mutexStarving（是否处于饥饿模式）</li><li>高 29 位的值聚合为一个范围为 0~2^29-1 的整数，表示在阻塞队列中等待的协程个数.</li></ul><h3 id="1-2-正常模式和饥饿模式"><a href="#1-2-正常模式和饥饿模式" class="headerlink" title="1.2 正常模式和饥饿模式"></a>1.2 正常模式和饥饿模式</h3><blockquote><p>mutex 是公平锁</p></blockquote><p><code>正常模式</code>：锁的等待者会按照<code>先进先出</code>的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine <code>超过 1ms</code> 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被<strong>饿死</strong>。<br><code>饥饿模式</code>：互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间<code>少于 1ms</code>，那么当前的互斥锁就会切换回正常模式。</p><h2 id="2-加解锁过程"><a href="#2-加解锁过程" class="headerlink" title="2 加解锁过程"></a>2 加解锁过程</h2><h3 id="2-1-加锁"><a href="#2-1-加锁" class="headerlink" title="2.1 加锁"></a>2.1 加锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/mutex.go 72 行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line"><span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Slow path (outlined so that the fast path can be inlined)</span></span><br><span class="line">m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-1-Fast-path"><a href="#2-1-1-Fast-path" class="headerlink" title="2.1.1 Fast path"></a>2.1.1 Fast path</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先进行 <code>CAS</code> 操作，假如当前未上锁且锁内不存在阻塞协程，则直接 CAS 抢锁成功返回</p></blockquote><h4 id="2-1-2-Slow-Path"><a href="#2-1-2-Slow-Path" class="headerlink" title="2.1.2 Slow Path"></a>2.1.2 Slow Path</h4><p>如果互斥锁的状态不是 0 时就会进入 Slow Path。尝试通过自旋（Spinnig）等方式等待锁的释放，该方法的主体是一个非常大 for 循环，这里将它分成几个部分介绍获取锁的过程：</p><h5 id="2-1-2-1-判断当前-Goroutine-能否进入自旋"><a href="#2-1-2-1-判断当前-Goroutine-能否进入自旋" class="headerlink" title="2.1.2.1 判断当前 Goroutine 能否进入自旋"></a>2.1.2.1 判断当前 Goroutine 能否进入自旋</h5><p><strong>自旋是一种多线程同步机制</strong>，当前的进程在进入自旋的过程中会一直保持 CPU 的占用，持续检查某个条件是否为真。<strong>在多核的 CPU 上，自旋可以避免 Goroutine 的切换</strong>，使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 Goroutine 进入自旋的条件非常苛刻：</p><ul><li>互斥锁只有在普通模式才能进入自旋；</li><li><code>runtime.sync_runtime_canSpin</code>需要返回 true<ul><li>运行在多 CPU 的机器上；</li></ul><ul><li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li><li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li></ul></li></ul><h5 id="2-1-2-2-通过自旋等待互斥锁的释放"><a href="#2-1-2-2-通过自旋等待互斥锁的释放" class="headerlink" title="2.1.2.2 通过自旋等待互斥锁的释放"></a>2.1.2.2 通过自旋等待互斥锁的释放</h5><p>一旦当前 Goroutine 能够进入自旋就会调用<code>runtime.sync_runtime_doSpin</code>和<code>runtime.procyield</code>执行 30 次的 <code>PAUSE</code> 指令，该指令只会占用 CPU 并消耗 CPU 时间：</p><h5 id="2-1-2-3-计算互斥锁的最新状态"><a href="#2-1-2-3-计算互斥锁的最新状态" class="headerlink" title="2.1.2.3 计算互斥锁的最新状态"></a>2.1.2.3 计算互斥锁的最新状态</h5><p>处理了自旋相关的特殊逻辑之后，互斥锁会根据上下文计算当前互斥锁最新的状态。几个不同的条件分别会更新 <code>state</code> 字段中存储的不同信息 — <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 和 <code>mutexWaiterShift</code>：</p><h5 id="2-1-2-4-更新互斥锁的状态并获取锁"><a href="#2-1-2-4-更新互斥锁的状态并获取锁" class="headerlink" title="2.1.2.4 更新互斥锁的状态并获取锁"></a>2.1.2.4 更新互斥锁的状态并获取锁</h5><p>计算了新的互斥锁状态之后，会使用 CAS 函数更新状态<br>如果没有通过 CAS 获得锁，会调用 <code>runtime.sync_runtime_SemacquireMutex</code> 通过信号量保证资源不会被两个 Goroutine 获取。<br><code>runtime.sync_runtime_SemacquireMutex</code> 会在方法中不断尝试获取锁并陷入休眠等待信号量的释放，一旦当前 Goroutine 可以获取信号量，它就会立刻返回，<code>sync.Mutex.Lock</code>的剩余代码也会继续执行。</p><ul><li>在正常模式下，这段代码会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环；</li><li>在饥饿模式下，当前 Goroutine 会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出；</li></ul><h3 id="2-2-解锁"><a href="#2-2-解锁" class="headerlink" title="2.2 解锁"></a>2.2 解锁</h3><h4 id="2-2-1-Fast-path"><a href="#2-2-1-Fast-path" class="headerlink" title="2.2.1 Fast path"></a>2.2.1 Fast path</h4><p>该过程会先使用<code>atomic.AddInt32函数快速解锁，这时会发生下面的两种情况：</code></p><ul><li>如果该函数返回的新状态等于 0，当前 Goroutine 就成功解锁了互斥锁；</li><li>如果该函数返回的新状态不等于 0，则进入 Slow path。<h4 id="2-2-2-Slow-path"><a href="#2-2-2-Slow-path" class="headerlink" title="2.2.2 Slow path"></a>2.2.2 Slow path</h4>先校验锁状态的<code>合法性</code> — 如果当前互斥锁已经被解锁过了会直接抛出异常 “sync: unlock of unlocked mutex” 中止当前程序。<br>在正常模式下，上述代码会使用如下所示的处理过程：</li><li>如果互斥锁不存在等待者或者互斥锁的 <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 状态不都为 0，那么当前方法可以直接返回，不需要唤醒其他等待者；</li><li>如果互斥锁存在等待者，会通过<code>runtime_Semrelease</code>唤醒等待者并移交锁的所有权；<br>在饥饿模式下，上述代码会直接调用<code>runtime_Semrelease</code>将当前锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁，在这时互斥锁还不会退出饥饿状态；</li></ul><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p>互斥锁的<strong>加锁过程</strong>比较复杂，它涉及自旋、信号量以及调度等概念：</p><ul><li>如果互斥锁处于初始化状态，会通过置位 <code>mutexLocked</code> 加锁；</li><li>如果互斥锁处于 <code>mutexLocked</code> 状态并且在普通模式下工作，会进入自旋，执行 30 次 <code>PAUSE</code> 指令消耗 CPU 时间等待锁的释放；</li><li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li><li>互斥锁在正常情况下会通过<code>sync_runtime_SemacquireMutex</code>将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；</li><li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式；</li></ul><p>互斥锁的<strong>解锁过程</strong>与之相比就比较简单：</p><ul><li>当互斥锁已经被解锁时，调用 Mutex.Lock 会直接抛出异常；</li><li>当互斥锁处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 <code>mutexLocked</code> 标志位；</li><li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，会直接返回；在其他情况下会通过<code>sync.runtime_Semrelease</code> 唤醒对应的 Goroutine；</li></ul><h2 id="4-Sync-RWMutex"><a href="#4-Sync-RWMutex" class="headerlink" title="4 Sync.RWMutex"></a>4 Sync.RWMutex</h2><blockquote><p>从逻辑上，可以把 RWMutex 理解为一把读锁加一把写锁；<br>写锁具有<code>严格的排他性</code>，当其被占用，其他试图取写锁或者读锁的 goroutine 均阻塞；<br>读锁具有<code>有限的共享性</code>，当其被占用，试图取写锁的 goroutine 会阻塞，试图取读锁的 goroutine 可与当前 goroutine 共享读锁；<br>RWMutex 适用于<code>读多写少</code>的场景，最理想化的情况，当所有操作均使用读锁，则可实现无锁化；最悲观的情况，倘若所有操作均使用写锁，则 RWMutex 退化为普通的 Mutex.</p></blockquote><h3 id="4-1-数据结构"><a href="#4-1-数据结构" class="headerlink" title="4.1 数据结构"></a>4.1 数据结构</h3><p>![[Pasted image 20230901163649.png]]<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span>   <span class="comment">// 共享读锁的 goroutine 数量上限，值为 2^29；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w           Mutex  <span class="comment">// 内置的一把普通互斥锁 sync.Mutex；</span></span><br><span class="line">    writerSem   <span class="type">uint32</span> <span class="comment">// 关联写锁阻塞队列的信号量；</span></span><br><span class="line">    readerSem   <span class="type">uint32</span> <span class="comment">// 关联读锁阻塞队列的信号量；</span></span><br><span class="line">    readerCount <span class="type">int32</span>  <span class="comment">// 正常情况下等于介入读锁流程的 goroutine 数量；当 goroutine 接入写锁流程时，该值为实际介入读锁流程的 goroutine 数量减 rwmutexMaxReaders.</span></span><br><span class="line">    readerWait  <span class="type">int32</span>  <span class="comment">// 记录在当前 goroutine 获取写锁前，还需要等待多少个 goroutine 释放读锁.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-2-读锁流程"><a href="#4-2-读锁流程" class="headerlink" title="4.2 读锁流程"></a>4.2 读锁流程</h3><h4 id="4-2-1-RLock"><a href="#4-2-1-RLock" class="headerlink" title="4.2.1 RLock"></a>4.2.1 RLock</h4><p>• 基于原子操作，将 RWMutex 的 readCount 变量加一，表示占用或等待读锁的 goroutine 数加一；<br>• 倘若 RWMutex.readCount 的新值仍小于 0，说明有 goroutine 未释放写锁，因此将当前 goroutine 添加到读锁的阻塞队列中并阻塞挂起.</p><h4 id="4-2-2-RUnlock"><a href="#4-2-2-RUnlock" class="headerlink" title="4.2.2 RUnlock"></a>4.2.2 RUnlock</h4><p>• 基于原子操作，将 RWMutex 的 readCount 变量加一，表示占用或等待读锁的 goroutine 数减一；<br>• 倘若 RWMutex.readCount 的新值小于 0，说明有 goroutine 在等待获取写锁，则走入 RWMutex.rUnlockSlow 的流程中.</p><h4 id="4-2-3-rUnlockSlow"><a href="#4-2-3-rUnlockSlow" class="headerlink" title="4.2.3 rUnlockSlow"></a>4.2.3 rUnlockSlow</h4><p>• 对 RWMutex.readerCount 进行校验，倘若发现当前协程此前未抢占过读锁，或者介入读锁流程的 goroutine 数量达到上限，则抛出 fatal；<br>(倘若 r+1 == -rwmutexMaxReaders，说明此时有 goroutine 介入写锁流程，但当前此前未加过读锁，具体原因见 2.3 小节；倘若 r+1=0，则要么此前未加过读锁，要么介入读锁流程的 goroutine 数量达到上限</p><p>• 基于原子操作，对 RWMutex.readerWait 进行减一操作，倘若其新值为 0，说明当前 goroutine 是最后一个介入读锁流程的协程，因此需要唤醒一个等待写锁的阻塞队列的 goroutine.（综合 RWMutex.readerCount 为负值，可以确定存在等待写锁的 goroutine，具体原因见 2.3 小节.）</p><h3 id="4-3-写锁流程"><a href="#4-3-写锁流程" class="headerlink" title="4.3 写锁流程"></a>4.3 写锁流程</h3><h4 id="4-3-1-Lock"><a href="#4-3-1-Lock" class="headerlink" title="4.3.1 Lock"></a>4.3.1 Lock</h4><p>• 对 RWMutex 内置的互斥锁进行加锁操作；<br>• 基于原子操作，对 RWMutex.readerCount 进行减少 -rwmutexMaxReaders 的操作；<br>• 倘若此时存在未释放读锁的 gouroutine，则基于原子操作在 RWMutex.readerWait 的基础上加上介入读锁流程的 goroutine 数量，并将当前 goroutine 添加到写锁的阻塞队列中挂起.</p><h4 id="4-3-2-Unlock"><a href="#4-3-2-Unlock" class="headerlink" title="4.3.2 Unlock"></a>4.3.2 Unlock</h4><p>• 基于原子操作，将 RWMutex.readerCount 的值加上 rwmutexMaxReaders；<br>• 倘若发现 RWMutex.readerCount 的新值大于 rwmutexMaxReaders，则说明要么当前 RWMutex 未上过写锁，要么介入读锁流程的 goroutine 数量已经超限，因此直接抛出 fatal；<br>• 因此唤醒读锁阻塞队列中的所有 goroutine；(可见，竞争读锁的 goroutine 更具备优势)<br>• 解开 RWMutex 内置的互斥锁.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-基本结构&quot;&gt;&lt;a href=&quot;#1-基本结构&quot; class=&quot;headerlink&quot; title=&quot;1 基本结构&quot;&gt;&lt;/a&gt;1 基本结构&lt;/h2&gt;&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter</summary>
      
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="并发编程" scheme="https://stardustorz.github.io/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Go] sync.WaitGroup</title>
    <link href="https://stardustorz.github.io/2022/07/09/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.WaitGroup/"/>
    <id>https://stardustorz.github.io/2022/07/09/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.WaitGroup/</id>
    <published>2022-07-08T16:00:00.000Z</published>
    <updated>2025-05-12T14:00:27.979Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Golang 调度方式：<code>主动让渡</code>和<code>被动调度</code><br>   被动调度: <code>通道 channel</code> 、<code>单机锁 sync.Mutex</code>、<code>并发等待组 sync.WaitGroup</code><br>当 goroutine 之间需要建立明确的<code>层级关系</code>. 倘若父 goroutine 希望持有子 goroutine 的生杀大权，并且保证父 goroutine 消亡时能连带回收其创建的所有子 goroutine ，此时可以使用到 Golang 上下文工具 context，完成父 goroutine 对 子 goroutine 的<code>生命周期控制</code></p><p>多个协程等待一个协程执行完，除了WaitGroup 还有什么方式？  写入channel，for循环读</p><h2 id="1-How-to-use？"><a href="#1-How-to-use？" class="headerlink" title="1 How to use？"></a>1 How to use？</h2><h3 id="1-1-核心方法"><a href="#1-1-核心方法" class="headerlink" title="1.1 核心方法"></a>1.1 核心方法</h3><p>• <code>WaitGroup.Add(n)</code>：完成一次登记操作，使得 WaitGroup 中并发计数器的数值加上 n. 在使用场景中，WaitGroup.Add(n) 背后的含义是，注册并启动了 n 个子 goroutine<br>• <code>WaitGroup.Done()</code>：完成一次上报操作，使得 WaitGroup 中并发计数器的数值减 1. 在使用场景中，通常会在一个子 goroutine 退出前，会执行一次 WaitGroup.Done 方法<br>• <code>WaitGroup.Wait()</code>：完成聚合操作. 通常由主 goroutine 调用该方法，主 goroutine 会因此陷入阻塞，直到所有子 goroutine 都已经执行完成，使得 WaitGroup 并发计数器数值清零时，主 goroutine 才得以继续往下执行</p></blockquote><h3 id="1-2-案例"><a href="#1-2-案例" class="headerlink" title="1.2 案例"></a>1.2 案例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_waitGroup</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup   <span class="comment">// 声明等待组 wg</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;   <span class="comment">// 循环开启十个子 Goroutine</span></span><br><span class="line">        wg.Add(<span class="number">1</span>)               <span class="comment">// 登记子 Goroutine</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()     <span class="comment">// 保证退出前会调用一次，完成上报</span></span><br><span class="line">            &lt;-time.After(time.Second)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()                   <span class="comment">// 阻塞等待，直到等待组全部完成后才往下走</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：子 goroutine 是异步启动的，所以有可能出现 Wait 方法先于 Add 方法执行，此时由于计数器值为 0，Wait 方法会被直接放行，导致产生预期之外的执行流程；因此要保证 add 在 done 之前。</p></blockquote><h3 id="1-3-WaitGroup-channel-完成数据聚合"><a href="#1-3-WaitGroup-channel-完成数据聚合" class="headerlink" title="1.3 WaitGroup + channel 完成数据聚合"></a>1.3 WaitGroup + channel 完成数据聚合</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_waitGroup</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tasksNum := <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据缓存 channel</span></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    <span class="comment">// 数据结果 slice</span></span><br><span class="line">    resp := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, tasksNum)</span><br><span class="line">    <span class="comment">// 控制管道</span></span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 启动读 goroutine</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> data := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">            resp = <span class="built_in">append</span>(resp, data)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标识数据读取完成</span></span><br><span class="line">        stopCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证获取到所有数据后，通过 channel 传递到读协程手中</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; tasksNum; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            ch &lt;- time.Now().UnixNano()</span><br><span class="line">        &#125;(dataCh)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确保所有取数据的协程都完成了工作，才关闭 ch</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(dataCh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保读协程处理完成</span></span><br><span class="line">    &lt;-stopCh</span><br><span class="line"></span><br><span class="line">    t.Logf(<span class="string">&quot;resp: %+v&quot;</span>, resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-源码走读"><a href="#2-源码走读" class="headerlink" title="2 源码走读"></a>2 源码走读</h2><h3 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h3><p>WaitGroup 位于 golang sync 包下，对应的类声明中包含了几个核心字段：</p><ul><li><code>noCopy</code>：这是防拷贝标识，标记了 WaitGroup 不应该用于值传递</li><li><code>state1</code>：这是 WaitGroup 的核心字段，是一个无符号的64位整数，高32位是 WaitGroup 中并发计数器的数值，即当前 WaitGroup.Add 与 WaitGroup.Done 之间的差值；低 32 位标识了，当前有多少 goroutine 因 WaitGroup.Wait 操作而处于阻塞态，陷入阻塞态的原因是因为计数器的值没有清零，即 state1 字段高 32 位是一个正值</li><li><code>state2</code>：用于阻塞和唤醒 goroutine 的信号量</li></ul><p><code>WaitGroup.Add</code> 方法会给 WaitGroup 的计数器累加上一定的值，背后的含义是标识出当前有多少 goroutine 正在运行，需要由 WaitGroup.Done 操作完成数值的抵扣：</p><ul><li>首先通过 WaitGroup.state 方法，获取到 WaitGroup 的 state1 和 state2 字段，分别将字段对应的地址赋给临时变量 statep 和 semap</li><li>调用 atomic.AddUint64，直接通过指针的方式直接在 WaitGroup.state1 的高 32 位基础上累加上 delta 的值</li><li>获取到 state1 高 32 位的值，赋值给局部变量 v，其含义是并发计数器的数值，即 WaitGroup.Add 和 WaitGroup.Done 之间的差值</li><li>获取到 state1 低 32 位的值，赋值给局部变量 w. 其含义是因执行 WaitGroup.Wait 操作而陷入阻塞态的 goroutine 数量</li><li>倘若 WaitGroup 计数器出现负值，直接 panic（ Done 不应该多于 Add ）</li><li>倘若首次 Add 操作是在有 goroutine 因 Wait 操作而陷入阻塞时才执行，抛出 panic（if w != 0 &amp;&amp; delta &gt; 0 &amp;&amp; v == int32(delta) ）</li><li>倘若执行完 Add 操作后，WaitGroup 的计数器还是正值，则直接返回</li><li>倘若发现本次 Add 操作后， WaitGroup 计数器被清零了，则接下来需要依次把因 Wait 操作而陷入阻塞的 goroutine 唤醒. 在这期间，不允许再并发执行 Add 操作，否则会 panic</li><li>唤醒 goroutine 使用的方法是 runtime_Semrelease 方法，底层会执行 goready 操作，属于 goroutine 的被动调度模式</li></ul><p>执行 WaitGroup.Wait 方法，会判断 WaitGroup 中的并发计数器数值是否为 0，如果不等于0，则当前 goroutine 会陷入阻塞态，直到计数器数值清零之后，才会被唤醒. 具体的执行流程如下：</p><ul><li>执行 WaitGroup.state 方法，获取到 state1 和 state2 字段</li><li>走进 for 循环开启自旋流程</li><li>将 state1 高 32 位所存储的计数器数值赋给局部变量 v</li><li>将 state1 低 32 位所存储的阻塞 goroutine 数量赋给局部变量 w</li><li>倘若计数器数值 v 已经是 0 了，则无需阻塞 goroutine，直接返回即可</li><li>倘若计数器数值 v 大于 0，代表当前 goroutine 需要被阻塞挂起.</li><li>基于 cas，将 state1 低 32 位的数值加 1，标识有一个额外的 goroutine 需要阻塞挂起了</li><li>调用 runtime_Semacquire 方法，内部会通过 go park 操作，将当前 goroutine 阻塞挂起，属于被动调度模式</li><li>当 goroutine 从 runtime_Semacquire 方法走出来时，说明 WaitGroup 计数器已经被清零了.</li><li>在被唤醒的 goroutine 返回前，WaitGroup 不能被并发执行 Add 操作，否则会陷入 panic</li><li>被唤醒的 goroutine 正常返回，Wait 流程结束</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Golang 调度方式：&lt;code&gt;主动让渡&lt;/code&gt;和&lt;code&gt;被动调度&lt;/code&gt;&lt;br&gt;   被动调度: &lt;code&gt;通道 channel&lt;/code&gt; 、&lt;code&gt;单机锁 sync.Mutex&lt;/code&gt;、&lt;code&gt;并发等待组</summary>
      
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="并发编程" scheme="https://stardustorz.github.io/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Go] sync.Map</title>
    <link href="https://stardustorz.github.io/2022/07/09/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Map/"/>
    <id>https://stardustorz.github.io/2022/07/09/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Map/</id>
    <published>2022-07-08T16:00:00.000Z</published>
    <updated>2025-03-10T14:26:25.406Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在 golang 中, map 并不保证并发安全的安全性, 对 map 进行并发读写会导致严重的错误, sync 标准包下的 sync.Map 解决了这一问题.</p></blockquote><span id="more"></span><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h2><h3 id="1-1-sync-Map"><a href="#1-1-sync-Map" class="headerlink" title="1.1 sync.Map"></a>1.1 sync.Map</h3><p><img src="file-20250307231828243.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu Mutex</span><br><span class="line">    read atomic.Value </span><br><span class="line">    dirty <span class="keyword">map</span>[any]*entry</span><br><span class="line">    misses <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>read：无锁化的只读 map，实际类型为 readOnly</li><li>dirty：加锁处理的读写 map</li><li>misses：记录访问 read 的失效次数，累计达到阈值时，会进行 read map/dirty map 的更新轮换</li><li>mu：一把互斥锁，实现 dirty 和 misses 的并发管理</li><li>sync.Map 的特点是冗余了两份 map：read map 和 dirty map</li></ul><h3 id="1-2-entry-及对应的几种状态"><a href="#1-2-entry-及对应的几种状态" class="headerlink" title="1.2 entry 及对应的几种状态"></a>1.2 entry 及对应的几种状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type entry struct &#123;</span><br><span class="line">p unsafe.Pointer </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>kv 对中的 value，统一采用 unsafe.Pointer 的形式进行存储，通过 entry.p 的指针进行链接</li><li>entry.p 的指向分为三种情况：<ul><li>存活态：正常指向元素</li><li>软删除态：指向 nil, nil 态表示软删除，read map 和 dirty map 底层的 map 结构仍存在 key-entry 对，但在逻辑上该 key-entry 对已经被删除，因此无法被用户查询到</li><li>硬删除态：指向固定的全局变量 expunged, expunged 态表示硬删除，dirty map 中已不存在该 key-entry 对</li></ul></li></ul><h3 id="1-3-readOnly"><a href="#1-3-readOnly" class="headerlink" title="1.3 readOnly"></a>1.3 readOnly</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">    m       <span class="keyword">map</span>[any]*entry</span><br><span class="line">    amended <span class="type">bool</span> <span class="comment">// true if the dirty map contains some key not in m.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync.Map 中的只读 map：read 内部包含两个成员属性：</p><ul><li>m：真正意义上的 read map，实现从 key 到 entry 的映射；</li><li>amended：标识 read map 中的 key-entry 对是否存在缺失，需要通过 dirty map 兜底.</li></ul><h2 id="2-读流程"><a href="#2-读流程" class="headerlink" title="2 读流程"></a>2 读流程</h2><h3 id="2-1-sync-Map-Load"><a href="#2-1-sync-Map-Load" class="headerlink" title="2.1 sync.Map.Load()"></a>2.1 sync.Map.Load()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Load(key any) (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        read, _ = m.read.Load().(readOnly)</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检查  read map 中是否存在 key-entry 对，若存在，则直接读取 entry 返回</li><li>如果第一轮 read map 查询 miss，且 read map 不全，则需要加锁 double check</li><li>如果第二轮 read map 查询仍 miss（加锁后），且 read map 不全，则查询 dirty map 兜底</li><li>查询操作涉及到与 dirty map 的交互，misses 加一</li><li>解锁，返回查得的结果</li></ul><h3 id="2-2-entry-load"><a href="#2-2-entry-load" class="headerlink" title="2.2 entry.load()"></a>2.2 entry.load()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> load() (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *(*any)(p), <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sync.Map 中，kv 对的 value 是基于 entry 指针封装的形式；</li><li>从 map 取得 entry 后，最终需要调用 entry.load 方法读取指针指向的内容；</li><li>如果 entry 的指针状态为 nil 或者 expunged，说明 key-entry 对已被删除，则返回 nil；</li><li>如果 entry 未被删除，则读取指针内容，并且转为 any 的形式进行返回.</li></ul><h3 id="2-3-sync-Map-missLocked"><a href="#2-3-sync-Map-missLocked" class="headerlink" title="2.3 sync.Map.missLocked()"></a>2.3 sync.Map.missLocked()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> missLocked() &#123;</span><br><span class="line">    m.misses++</span><br><span class="line">    <span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.read.Store(readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">    m.dirty = <span class="literal">nil</span></span><br><span class="line">    m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在读流程中，倘若未命中 read map，且由于 read map 内容存在缺失需要和 dirty map 交互时，会走进 missLocked 流程；</li><li>在 missLocked 流程中，首先 misses 计数器累加 1；</li><li>如果 miss 次数小于 dirty map 中存在的 key-entry 对数量，直接返回即可；</li><li>如果 miss 次数大于等于 dirty map 中存在的 key-entry 对数量，则使用 dirty map 覆盖 read map，并将 read map 的 amended flag 置为 false；</li><li>新的 dirty map 置为 nil，misses 计数器清零.</li></ul><h2 id="3-写流程"><a href="#3-写流程" class="headerlink" title="3 写流程"></a>3 写流程</h2><h3 id="3-1-sync-Map-Store"><a href="#3-1-sync-Map-Store" class="headerlink" title="3.1 sync.Map.Store()"></a>3.1 sync.Map.Store()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value any) &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    read, _ = m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">            m.dirty[key] = e</span><br><span class="line">        &#125;</span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">            m.dirtyLocked()</span><br><span class="line">            m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        m.dirty[key] = newEntry(value)</span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> storeLocked(i *any) &#123;</span><br><span class="line">    atomic.StorePointer(&amp;e.p, unsafe.Pointe</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 read map 存在拟写入的 key，且 entry 不为 expunged 状态，说明这次操作属于更新而非插入，直接基于 CAS 操作进行 entry 值的更新，并直接返回（存活态或者软删除，直接覆盖更新）</li><li>如果未命中，则需要加锁 double check</li><li>如果第二轮检查中发现 read map 或者 dirty map 中存在 key-entry 对，则直接将 entry 更新为新值即可（存活态或者软删除，直接覆盖更新）</li><li>如果发现 read map 中该 key-entry 为 expunged 态，需要在 dirty map 先补齐 key-entry 对，再更新 entry 值（从硬删除中恢复，然后覆盖更新）</li><li>如果 read map 和 dirty map 均不存在，则在 dirty map 中插入新 key-entry 对，并且保证 read map 的 amended flag 为 true.（插入）</li><li>如果发现 dirty map 未初始化，需要前置执行 dirtyLocked 流程</li><li>解锁返回</li></ul><h3 id="3-2-entry-tryStore"><a href="#3-2-entry-tryStore" class="headerlink" title="3.2 entry.tryStore()"></a>3.2 entry.tryStore()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value any) &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryStore(i *any) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">        <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在写流程中，如果发现 read map 中已存在对应的 key-entry 对，则会对调用 tryStore 方法尝试进行更新；</li><li>如果 entry 为 expunged 态，说明已被硬删除，dirty 中缺失该项数据，因此 tryStore 执行失败，回归主干流程；</li><li>如果 entry 非 expunged 态，则直接执行 CAS 操作完成值的更新即可.</li></ul><h3 id="3-3-entry-unexpungeLocked"><a href="#3-3-entry-unexpungeLocked" class="headerlink" title="3.3 entry.unexpungeLocked()"></a>3.3 entry.unexpungeLocked()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value any) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    read, _ = m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">            m.dirty[key] = e</span><br><span class="line">        &#125;</span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> unexpungeLocked() (wasExpunged <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> atomic.CompareAndSwapPointer(&amp;e.p, expunged, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在写流程加锁 double check 的过程中，如果发现 read map 中存在对应的 key-entry 对，会执行该方法；</li><li>如果 key-entry 为硬删除 expunged 态，该方法会基于 CAS 操作将其更新为软删除 nil 态，然后进一步在 dirty map 中补齐该 key-entry 对，实现从硬删除到软删除的恢复.</li></ul><h3 id="3-4-entry-storeLocked"><a href="#3-4-entry-storeLocked" class="headerlink" title="3.4 entry.storeLocked()"></a>3.4 entry.storeLocked()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value any) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    read, _ = m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> storeLocked(i *any) &#123;</span><br><span class="line">    atomic.StorePointer(&amp;e.p, unsafe.Pointer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>写流程中，如果 read map 或者 dirty map 存在对应 key-entry，最终会通过原子操作，将新值的指针存储到 entry.p 当中.</li></ul><h3 id="3-5-sync-Map-dirtyLocked"><a href="#3-5-sync-Map-dirtyLocked" class="headerlink" title="3.5 sync.Map.dirtyLocked()"></a>3.5 sync.Map.dirtyLocked()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> dirtyLocked() &#123;</span><br><span class="line">    <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[any]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">    <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">        <span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">            m.dirty[k] = e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryExpungeLocked() (isExpunged <span class="type">bool</span>) &#123;</span><br><span class="line">    p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    <span class="keyword">for</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, <span class="literal">nil</span>, expunged) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在写流程中，如果需要将 key-entry 插入到兜底的 dirty map 中，并且此时 dirty map 为空（从未写入过数据或者刚发生过 missLocked），会进入 dirtyLocked 流程；</li><li>此时会遍历一轮 read map ，将未删除的 key-entry 对拷贝到 dirty map 当中；</li><li>在遍历时，还会将 read map 中软删除 nil 态的 entry 更新为硬删除 expunged 态，因为在此流程中，不会将其拷贝到 dirty map.</li></ul><h2 id="4-删流程"><a href="#4-删流程" class="headerlink" title="4 删流程"></a>4 删流程</h2><h3 id="4-1-sync-Map-Delete"><a href="#4-1-sync-Map-Delete" class="headerlink" title="4.1 sync.Map.Delete()"></a>4.1 sync.Map.Delete()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(key any) &#123;</span><br><span class="line">    m.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadAndDelete(key any) (value any, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        read, _ = m.read.Load().(readOnly)</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            <span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">delete</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 read map 中存在 key，则直接基于 cas 操作将其删除；</li><li>如果 read map 不存在 key，且 read map 有缺失（amended flag 为 true），则加锁 double check；</li><li>如果加锁 double check 时，read map 仍不存在 key 且 read map 有缺失，则从 dirty map 中取元素，并且将 key-entry 对从 dirty map 中物理删除；</li><li>删操作需要和 dirty map 交互，需要 missLocked 流程；</li><li>解锁；</li><li>如果从 read map 或 dirty map 中获取到了 key 对应的 entry，则走入 entry.delete() 方法逻辑删除 entry；</li><li>如果 read map 和 dirty map 中均不存在 key，返回 false 标识删除失败</li></ul><h3 id="4-2-entry-delete"><a href="#4-2-entry-delete" class="headerlink" title="4.2 entry.delete()"></a>4.2 entry.delete()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> <span class="built_in">delete</span>() (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> *(*any)(p), <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 entry 此前已被删除，则直接返回 false 标识删除失败</li><li>如果 entry 当前仍存在，则通过 CAS 将 entry.p 指向 nil，标识其已进入软删除状态</li></ul><h2 id="5-遍历流程"><a href="#5-遍历流程" class="headerlink" title="5 遍历流程"></a>5 遍历流程</h2><ul><li>在遍历过程中，如果发现 read map 数据不全（amended flag 为 true），会额外加一次锁，并使用 dirty map 覆盖 read map</li><li>遍历 read map（通过上个步骤保证 read map 有全量数据），执行用户传入的回调函数，如果某次回调时返回值为 false，则会终止全流程</li></ul><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><h3 id="6-1-entry-的-expunged-态"><a href="#6-1-entry-的-expunged-态" class="headerlink" title="6.1 entry 的 expunged 态"></a>6.1 entry 的 expunged 态</h3><p><strong>为什么需要使用 expunged 态来区分软硬删除？</strong></p><ul><li>无论是软删除(nil)还是硬删除(expunged),都表示在逻辑意义上 key-entry 对已经从 sync.Map 中删除，nil 和 expunged 的区别在于<ul><li>软删除态（nil）：read map 和 dirty map 在物理上仍保有该 key-entry 对，因此如果此时需要对该 entry 执行写操作，可以直接 CAS 操作</li><li>硬删除态（expunged）：dirty map 中已经没有该 key-entry 对，如果执行写操作，必须加锁（dirty map 必须含有全量 key-entry 对数据）</li></ul></li><li>设计 expunged 和 nil 两种状态的原因，就是为了优化在 dirtyLocked 前，针对同一个 key <strong>先删后写</strong>的场景. 通过 expunged 态额外标识出 dirty map 中是否仍具有指向该 entry 的能力，这样能够实现对一部分 nil 态 key-entry 对的解放，能够基于 CAS 完成这部分内容写入操作而无需加锁</li></ul><h3 id="6-2-read-map-和-dirty-map-的数据流转"><a href="#6-2-read-map-和-dirty-map-的数据流转" class="headerlink" title="6.2 read map 和 dirty map 的数据流转"></a>6.2 read map 和 dirty map 的数据流转</h3><p>sync.Map 由两个 map 构成：</p><ul><li>read map：访问时全程无锁；</li><li>dirty map：是兜底的读写 map，访问时需要加锁</li></ul><p>希望能根据对读、删、更新、写操作频次的探测，来实时动态地调整操作方式，希望在读、更新、删频次较高时，更多地采用 CAS 的方式无锁化地完成操作；在写操作频次较高时，则直接了当地采用加锁操作完成.</p><p><strong>两个 map</strong></p><ul><li>总体思想，希望能多用 read map，少用 dirty map，因为操作前者无锁，后者需要加锁</li><li>除了 expunged 态的 entry 之外，read map 的内容为 dirty map 的子集</li></ul><p><strong>dirty map -&gt; read map</strong></p><ul><li>记录读/删流程中，通过 misses 记录访问 read map miss 由 dirty 兜底处理的次数，当 miss 次数达到阈值，则进入 missLocked 流程，进行新老 read/dirty 替换流程；此时将老 dirty 作为新 read，新 dirty map 则暂时为空，直到 dirtyLocked 流程完成对 dirty 的初始化</li></ul><p><strong>read map -&gt; dirty map</strong></p><ul><li>发生 dirtyLocked 的前置条件：I dirty 暂时为空（此前没有写操作或者近期进行过 missLocked 流程）；II 接下来一次写操作访问 read 时 miss，需要由 dirty 兜底</li><li>在 dirtyLocked 流程中，需要对 read 内的元素进行状态更新，因此需要遍历，是一个线性时间复杂度的过程，可能存在性能抖动</li><li>dirtyLocked 遍历中，会将 read 中未被删除的元素（非 nil 非 expunged）拷贝到 dirty 中；会将 read 中所有此前被删的元素统一置为 expunged 态</li></ul><h3 id="6-3-适用场景与注意问题"><a href="#6-3-适用场景与注意问题" class="headerlink" title="6.3 适用场景与注意问题"></a>6.3 适用场景与注意问题</h3><ul><li>sync.Map 适用于读多、更新多、删多、写少的场景；</li><li>如果写操作过多，sync.Map 基本等价于互斥锁 + map；</li><li>sync.Map 可能存在性能抖动问题，主要发生于在读/删流程 miss 只读 map 次数过多时（触发 missLocked 流程），下一次插入操作的过程当中（dirtyLocked 流程）</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;在 golang 中, map 并不保证并发安全的安全性, 对 map 进行并发读写会导致严重的错误, sync 标准包下的 sync.Map 解决了这一问题.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="并发编程" scheme="https://stardustorz.github.io/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Go] sync.pool</title>
    <link href="https://stardustorz.github.io/2022/07/09/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.pool/"/>
    <id>https://stardustorz.github.io/2022/07/09/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.pool/</id>
    <published>2022-07-08T16:00:00.000Z</published>
    <updated>2025-05-12T14:01:00.052Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了Go语言(golang)中的<code>sync.pool</code>包。给出了 sync.pool 的基本用法，以及各大框架中的使用案例。并从源码层面对其底层结构和具体实现原理进行分析。</p><blockquote><p>以下分析基于 Go 1.17.1</p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><h3 id="1-1-大致理念"><a href="#1-1-大致理念" class="headerlink" title="1.1 大致理念"></a>1.1 大致理念</h3><p><code>sync.Pool</code> 是 sync 包下的一个组件，可以作为保存临时取还对象的一个“池子”，可以缓存暂时不用的对象，下次需要时直接使用（无需重新分配）。</p><blockquote><p>因为频繁的内存分配和回收会对性能产生影响，通过复用临时对象就可以避免改问题。</p></blockquote><p>下面是 2018 年的时候，《Go 夜读》上关于 <code>sync.Pool</code> 的分享，关于适用场景：</p><blockquote><p>当多个 goroutine 都需要创建同⼀个对象的时候，如果 goroutine 数过多，导致对象的创建数⽬剧增，进⽽导致 GC 压⼒增大。形成 “并发⼤－占⽤内存⼤－GC 缓慢－处理并发能⼒降低－并发更⼤”这样的恶性循环。 在这个时候，需要有⼀个对象池，每个 goroutine 不再⾃⼰单独创建对象，⽽是从对象池中获取出⼀个对象（如果池中已经有的话）。</p></blockquote><p>因此关键思想就是对象的复用，避免重复创建、销毁，下面我们来看看如何使用。</p><p>所以，sync.pool 的作用一句话描述就是，<strong>复用临时对象，以避免频繁的内存分配和回收，从而减少 GC 压力</strong>。</p><h3 id="1-2-基本使用"><a href="#1-2-基本使用" class="headerlink" title="1.2 基本使用"></a>1.2 基本使用</h3><p>首先，<code>sync.Pool</code> 是协程安全的，这对于使用者来说是极其方便的。使用前，设置好对象的 <code>New</code> 函数，用于在 <code>Pool</code> 里没有缓存的对象时，创建一个。之后，在程序的任何地方、任何时候仅通过 <code>Get()</code>、<code>Put()</code> 方法就可以取、还对象了。</p><p>以下为基本使用 demo：</p><blockquote><p>完整代码见 <a href="#">Github</a><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> main  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">   <span class="string">&quot;sync&quot;</span>  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;  </span><br><span class="line">   Name   <span class="type">string</span>  </span><br><span class="line">   Remark [<span class="number">1024</span>]<span class="type">byte</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Gopher)</span></span> Reset() &#123;  </span><br><span class="line">   s.Name = <span class="string">&quot;&quot;</span>  </span><br><span class="line">   s.Remark = [<span class="number">1024</span>]<span class="type">byte</span>&#123;&#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">var</span> gopherPool = sync.Pool&#123;  </span><br><span class="line">   New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">new</span>(Gopher)  </span><br><span class="line">   &#125;,  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   g := gopherPool.Get().(*Gopher)  </span><br><span class="line">   fmt.Println(<span class="string">&quot;首次从 pool 里获取：&quot;</span>, g.Name)  </span><br><span class="line"> ​  </span><br><span class="line">   g.Name = <span class="string">&quot;first&quot;</span>  </span><br><span class="line">   fmt.Printf(<span class="string">&quot;设置 p.Name = %s\n&quot;</span>, g.Name)  </span><br><span class="line">   gopherPool.Put(g)  </span><br><span class="line"> ​  </span><br><span class="line">   fmt.Println(<span class="string">&quot;Pool 里已有一个对象：&amp;&#123;first&#125;，调用 Get: &quot;</span>, gopherPool.Get().(*Gopher).Name)  </span><br><span class="line">   fmt.Println(<span class="string">&quot;Pool 没有对象了，调用 Get: &quot;</span>, gopherPool.Get().(*Gopher).Name)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>运行结果：<br> 首次从 pool 里获取：<br> 设置 p.Name = first<br> Pool 里已有一个对象：&amp;{first}，调用 Get:  first<br> Pool 没有对象了，调用 Get:<br>首先，需要初始化 <code>Pool</code>，唯一需要的就是设置好 <code>New</code> 函数。当调用 Get 方法时，如果池子里缓存了对象，就直接返回缓存的对象。如果没有存货，则调用 New 函数创建一个新的对象。</p></blockquote><p>另外，我们发现 Get 方法取出来的对象和上次 Put 进去的对象实际上是同一个，Pool 没有做任何“清空”的处理。但我们不应当对此有任何假设，因为在实际的并发使用场景中，无法保证这种顺序，<strong>最好的做法是在 Put 前，将对象清空</strong>。</p><p><strong>Benchmark</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> defaultGopher, _ = json.Marshal(Gopher&#123;Name: <span class="string">&quot;17x&quot;</span>&#125;)  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">BenchmarkUnmarshal</span><span class="params">(b *testing.B)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">var</span> g *Gopher  </span><br><span class="line">   <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;  </span><br><span class="line">     g = <span class="built_in">new</span>(Gopher)  </span><br><span class="line">     json.Unmarshal(defaultGopher, g)  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">BenchmarkUnmarshalWithPool</span><span class="params">(b *testing.B)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">var</span> g *Gopher  </span><br><span class="line">   <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;  </span><br><span class="line">     g = gopherPool.Get().(*Gopher)  </span><br><span class="line">     json.Unmarshal(defaultGopher, g)  </span><br><span class="line">     g.Reset() <span class="comment">// 重置后在放进去  </span></span><br><span class="line">     gopherPool.Put(g)  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure><br> ​<br>运行结果：</p><p> BenchmarkUnmarshal-6                9518            124806 ns/op            1280 B/op          6 allocs/op<br> BenchmarkUnmarshalWithPool-6       10000            124350 ns/op             128 B/op          5 allocs/op<br> <code>3287449 357 ns/op</code> 表示单位时间内（默认是1s）被测函数运行了 3287449 次，每次运行耗时 357ns，<br> <code>B/op</code> 是每个操作分配的字节数<br> <code>allocs/op</code> 表示每个操作(单次迭代)发生了多少不同的内存分配。</p><p>功能比较简单，其中 json 反序列化占用了大量时间，因此两种方式最终的执行时间几乎没什么变化。但是内存占用差了一个数量级，使用了 <code>sync.Pool</code> 后，内存占用仅为未使用的 128/1280=1/10，对 GC 的影响就很大了。</p><h3 id="1-3-使用案例"><a href="#1-3-使用案例" class="headerlink" title="1.3 使用案例"></a>1.3 使用案例</h3><h4 id="1-3-1-fmt-包"><a href="#1-3-1-fmt-包" class="headerlink" title="1.3.1 fmt 包"></a>1.3.1 fmt 包</h4><p>这部分主要看 <code>fmt.Printf</code> 如何使用：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;  </span><br><span class="line">   <span class="keyword">return</span> Fprintf(os.Stdout, format, a...)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>继续看 <code>Fprintf</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;  </span><br><span class="line">   p := newPrinter()  </span><br><span class="line">   p.doPrintf(format, a)  </span><br><span class="line">   n, err = w.Write(p.buf)  </span><br><span class="line">   p.free()  </span><br><span class="line">   <span class="keyword">return</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br><code>Fprintf</code> 函数的参数是一个 <code>io.Writer</code>，<code>Printf</code> 传的是 <code>os.Stdout</code>，相当于直接输出到标准输出。这里的 <code>newPrinter</code> 用的就是 Pool：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> ppFree = sync.Pool&#123;  </span><br><span class="line">   New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123; <span class="keyword">return</span> <span class="built_in">new</span>(pp) &#125;,  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">newPrinter</span><span class="params">()</span></span> *pp &#123;  </span><br><span class="line">   p := ppFree.Get().(*pp)  </span><br><span class="line">   p.panicking = <span class="literal">false</span>  </span><br><span class="line">   p.erroring = <span class="literal">false</span>  </span><br><span class="line">   p.wrapErrs = <span class="literal">false</span>  </span><br><span class="line">   p.fmt.init(&amp;p.buf)  </span><br><span class="line">   <span class="keyword">return</span> p  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>回到 <code>Fprintf</code> 函数，拿到 pp 指针后，会做一些 format 的操作，并且将 p.buf 里面的内容写入 w。最后，调用 free 函数，将 pp 指针归还到 Pool 中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(p *pp)</span></span> free() &#123;  </span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">cap</span>(p.buf) &gt; <span class="number">64</span>&lt;&lt;<span class="number">10</span> &#123;  </span><br><span class="line">     <span class="keyword">return</span>  </span><br><span class="line">   &#125;  </span><br><span class="line"> ​  </span><br><span class="line">   p.buf = p.buf[:<span class="number">0</span>]  </span><br><span class="line">   p.arg = <span class="literal">nil</span>  </span><br><span class="line">   p.value = reflect.Value&#123;&#125;  </span><br><span class="line">   p.wrappedErr = <span class="literal">nil</span>  </span><br><span class="line">   ppFree.Put(p)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>归还到 Pool 前还进行了<strong>字段清零</strong>，这样，通过 Get 拿到缓存的对象时，就可以安全地使用了。</p><h4 id="1-3-2-gin-框架"><a href="#1-3-2-gin-框架" class="headerlink" title="1.3.2 gin 框架"></a>1.3.2 gin 框架</h4><p>gin 框架会给每个请求分配一个 Context 用以进行追踪，这就是典型的 sync.pool 使用场景：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Engine &#123;  </span><br><span class="line">engine := &amp;Engine&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">engine.pool.New = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line"><span class="keyword">return</span> engine.allocateContext()  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> engine  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> allocateContext() *Context &#123;  </span><br><span class="line"><span class="keyword">return</span> &amp;Context&#123;engine: engine&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;  </span><br><span class="line">c := engine.pool.Get().(*Context)  </span><br><span class="line">c.writermem.reset(w)  </span><br><span class="line">c.Request = req  </span><br><span class="line">c.reset()  </span><br><span class="line">  </span><br><span class="line">engine.handleHTTPRequest(c)  </span><br><span class="line">  </span><br><span class="line">engine.pool.Put(c)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从 pool 中获取 Context 对象，用完后又还回去，注意 还回去之前这里也调用了 reset() 方法进行<strong>字段清空</strong>。</p><h3 id="1-4-正确姿势"><a href="#1-4-正确姿势" class="headerlink" title="1.4 正确姿势"></a>1.4 正确姿势</h3><p>根据以上几个案例，可以看出正确使用姿势就是：</p><ul><li><p>1）设置 New 方法</p></li><li><p>2）使用时直接 Get</p></li><li><p>3）使用完成后先进行<strong>字段清空</strong>,然后在 Put 回去。</p></li></ul><blockquote><p>一定要进行 Reset，不然会出现意想不到的问题。分享一个<a href="https://github.com/lixd/daily-notes/blob/master/Golang/FAQ/mongodb%E9%87%87%E5%9D%91.md">类似的坑</a></p></blockquote><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><blockquote><p>一下分析基于 Go 1.17.1</p></blockquote><h3 id="2-1-Pool-结构体"><a href="#2-1-Pool-结构体" class="headerlink" title="2.1 Pool 结构体"></a>2.1 Pool 结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;  </span><br><span class="line">noCopy noCopy  </span><br><span class="line">local     unsafe.Pointer <span class="comment">// local fixed-size per-P pool, actual type is [P]poolLocal  </span></span><br><span class="line">localSize <span class="type">uintptr</span>        <span class="comment">// size of the local array  </span></span><br><span class="line">victim     unsafe.Pointer <span class="comment">// local from previous cycle  </span></span><br><span class="line">victimSize <span class="type">uintptr</span>        <span class="comment">// size of victims array  </span></span><br><span class="line">New <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段详解：</p><ul><li><code>noCopy</code>对象，实现了<code>sync.Locker</code>接口，使得内嵌了 noCopy 的对象在进行 go vet 静态检查的时候，可以检查出是否被复制。<ul><li>具体见 <a href="https://github.com/golang/go/issues/8005">Go issues 8005</a></li><li>说明 Pool 对象也是不允许复制的。</li></ul></li><li><code>local</code> 字段存储指向 <code>[P]poolLocal</code> 数组（严格来说，它是一个切片）的指针。<code>localSize</code> 则表示 local 数组的大小。<ul><li>访问时，根据 P 的 id 去访问对应下标的 <code>local[pid]</code></li><li>通过这样的设计，多个 goroutine 使用同一个 Pool 时，减少了竞争，提升了性能。</li><li>有点类似于降低锁粒度，分段锁的思想。</li></ul></li><li><code>victim</code> 和 <code>victimSize</code> 则会在在一轮 GC 到来时，分别“接管” local 和 localSize。<ul><li>victim cache 是一种提高缓存性能的硬件技术;</li><li><code>victim</code> 的机制用于减少 GC 后冷启动导致的性能抖动，让分配对象更平滑;</li></ul></li><li><code>New</code>就是我们指定的新建对象的方法。</li></ul><blockquote><p><a href="https://en.wikipedia.org/wiki/Victim_cache">Victim Cache</a> 是一种提高缓存性能的硬件技术，主要用于提升缓存命令率。<br>所谓受害者缓存（Victim Cache），是一个与直接匹配或低相联缓存并用的、容量很小的全相联缓存。当一个数据块被逐出缓存时，并不直接丢弃，而是暂先进入受害者缓存。如果受害者缓存已满，就替换掉其中一项。当进行缓存标签匹配时，在与索引指向标签匹配的同时，并行查看受害者缓存，如果在受害者缓存发现匹配，就将其此数据块与缓存中的不匹配数据块做交换，同时返回给处理器。</p></blockquote><h4 id="2-1-1-local"><a href="#2-1-1-local" class="headerlink" title="2.1.1 local"></a>2.1.1 local</h4><p>local 具体结构如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> &#123;  </span><br><span class="line">poolLocalInternal  </span><br><span class="line">    <span class="comment">// 将 poolLocal 补齐至128字节(即两个cache line)的倍数，防止 false sharing,  </span></span><br><span class="line">    <span class="comment">// 伪共享，仅占位用，防止在 cache line 上分配多个 poolLocalInternal  </span></span><br><span class="line">pad [<span class="number">128</span> - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%<span class="number">128</span>]<span class="type">byte</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">type</span> poolLocalInternal <span class="keyword">struct</span> &#123;  </span><br><span class="line">private <span class="keyword">interface</span>&#123;&#125; <span class="comment">// Can be used only by the respective P.  </span></span><br><span class="line">shared  poolChain   <span class="comment">// Local P can pushHead/popHead; any P can popTail.  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>poolLocalInternal</code>对象 中包含一个 <code>private</code> 和 <code>shared</code>。其中 private 只有当前 p 能用，shared 则是其他 p 都可以用。</p><h4 id="2-1-2-cpu-cache-amp-false-sharing"><a href="#2-1-2-cpu-cache-amp-false-sharing" class="headerlink" title="2.1.2 cpu cache &amp; false sharing"></a>2.1.2 cpu cache &amp; false sharing</h4><p><strong>cpu cache</strong><br>现代 cpu 中，cache 都划分成以 cache line (cache block) 为单位，在 x86_64 体系下一般都是 64 字节，cache line 是操作的最小单元。 程序即使只想读内存中的 1 个字节数据，也要同时把附近 63 节字加载到 cache 中，如果读取超个 64 字节，那么就要加载到多个 cache line 中。<br>这样，访问后续 63 字节数据时就可以直接从 cache line 中读取，性能有很大提升。</p><p><strong><a href="https://en.wikipedia.org/wiki/False_sharing">false sharing</a></strong></p><blockquote><p>伪共享的非标准定义为：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会令整个 cache line 失效，无意中影响彼此的性能，这就是伪共享。</p></blockquote><p>简单来说，如果没有 pad 字段，那么当需要访问 0 号索引的 poolLocal 时，CPU 同时会把 0 号和 1 号索引同时加载到 cpu cache。在只修改 0 号索引的情况下，会让 1 号索引的 poolLocal 失效。这样，当其他线程想要读取 1 号索引时，发生 cache miss，还得重新再加载，对性能有损。增加一个 <code>pad</code>，补齐缓存行，让相关的字段能独立地加载到缓存行就不会出现 <code>false sharding</code> 了。</p><h4 id="2-1-3-poolChain"><a href="#2-1-3-poolChain" class="headerlink" title="2.1.3 poolChain"></a>2.1.3 poolChain</h4><p><code>poolChain</code> 是一个双端队列的实现<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolChain <span class="keyword">struct</span> &#123;  </span><br><span class="line">  </span><br><span class="line">   head *poolChainElt  </span><br><span class="line">  </span><br><span class="line">   tail *poolChainElt  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> poolChainElt <span class="keyword">struct</span> &#123;  </span><br><span class="line">poolDequeue  </span><br><span class="line">  </span><br><span class="line">next, prev *poolChainElt  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> poolDequeue <span class="keyword">struct</span> &#123;  </span><br><span class="line">  </span><br><span class="line">headTail <span class="type">uint64</span>  </span><br><span class="line">  </span><br><span class="line">vals []eface  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>poolDequeue</code> 被实现为单生产者、多消费者的固定大小的无锁（atomic 实现） Ring 式队列（底层存储使用数组，使用两个指针标记 head、tail）。生产者可以从 head 插入、head 删除，而消费者仅可从 tail 删除。 <code>headTail</code> 指向队列的头和尾，通过位运算将 head 和 tail 存入 headTail 变量中。</p><p>我们用一幅图来完整地描述 Pool 结构体：</p><p>![[pool-structure.png]]</p><blockquote><p>图源：<a href="https://zhuanlan.zhihu.com/p/133638023">码农桃花源</a></p><h3 id="2-2-大致流程"><a href="#2-2-大致流程" class="headerlink" title="2.2 大致流程"></a>2.2 大致流程</h3></blockquote><p>分析完 Pool 结构体之后，先提前说明一下大致的流程，后续分析时便于理解。</p><p><strong>存储</strong></p><p>为每个 P 开辟了一个 Local 用于数据，降低竞争。</p><p>Local 中包含 private 和 shared。</p><ul><li><p>private ：只有当前 P 能使用</p></li><li><p>shared：所有 P 共享，当 private 没有时优先去当前 P 的 local.shared 中取，如果还没有就去其他 P 中 local.shared 中窃取一个来用。</p></li></ul><p><strong>Get</strong></p><p>优先从当前P 的 local.private 中取，没有则从当前 P 的 local.shared 中取，还没有则去其他 P 中 local.shared 中窃取一个。</p><p><strong>Put</strong></p><p>优先存放到当前 P 的 local.private，local.private 已经有值了就往 shared 中放。</p><h3 id="2-3-Get"><a href="#2-3-Get" class="headerlink" title="2.3 Get"></a>2.3 Get</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Get() <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">l, pid := p.pin()  </span><br><span class="line">x := l.private  </span><br><span class="line">l.private = <span class="literal">nil</span>  </span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;  </span><br><span class="line">x, _ = l.shared.popHead()  </span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;  </span><br><span class="line">x = p.getSlow(pid)  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">runtime_procUnpin()  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;  </span><br><span class="line">x = p.New()  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> x  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程如下：</p><ol><li><p>首先，调用 <code>p.pin()</code> 函数将当前的 goroutine 和 P 绑定，禁止被抢占，返回当前 P 对应的 poolLocal，以及 pid。</p></li><li><p>然后直接取 l.private，赋值给 x，并置 l.private 为 nil。</p></li><li><p>判断 x 是否为空，若为空，则尝试从 l.shared 的头部 pop 一个对象出来，同时赋值给 x。</p></li><li><p>如果 x 仍然为空，则调用 getSlow 尝试从其他 P 的 shared 双端队列尾部“偷”一个对象出来。</p></li><li><p>Pool 的相关操作做完了，调用 <code>runtime_procUnpin()</code> 解除禁止抢占。</p></li><li><p>最后如果还是没有取到缓存的对象，那就直接调用预先设置好的 New 函数，创建一个出来。</p></li></ol><h4 id="2-3-1-pin"><a href="#2-3-1-pin" class="headerlink" title="2.3.1 pin"></a>2.3.1 pin</h4><p>首先，调用 <code>p.pin()</code> 函数将当前的 goroutine 和 P 绑定，禁止被抢占，返回当前 P 对应的 poolLocal，以及 pid。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pin() (*poolLocal, <span class="type">int</span>) &#123;  </span><br><span class="line">   <span class="comment">// pin 具体逻辑由 runtime_procPin 实现  </span></span><br><span class="line">   pid :=  runtime_procPin()  </span><br><span class="line">   <span class="comment">// 原子操作取出 p.localSize 和 p.local  </span></span><br><span class="line">   s := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire  </span></span><br><span class="line">   l := p.local                              <span class="comment">// load-consume  </span></span><br><span class="line">   <span class="comment">// 因为是把 pid 做下标从 pool.local 中取得 p 对应的 local 的，  </span></span><br><span class="line">   <span class="comment">// 所以如果 pid 小于 pool.local size 的时候才有可能取到对应的 local  </span></span><br><span class="line">   <span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;  </span><br><span class="line">      <span class="keyword">return</span> indexLocal(l, pid), pid  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// 正常情况下会一直满足该条件，  </span></span><br><span class="line">   <span class="comment">// 只有刚开始  pool.local 还没创建或者动态调整了 P 的数量这两种情况  </span></span><br><span class="line">   <span class="comment">// 会进入到下面的逻辑 去创建 pool.local  </span></span><br><span class="line">   <span class="keyword">return</span> p.pinSlow()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-3-2-pinSlow"><a href="#2-3-2-pinSlow" class="headerlink" title="2.3.2 pinSlow"></a>2.3.2 pinSlow</h4><p>pinSlow 主要是完成 pool.local 的创建。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pinSlow() (*poolLocal, <span class="type">int</span>) &#123;  </span><br><span class="line">    <span class="comment">// 这里先取消绑定，然后加锁，最后有绑定上  </span></span><br><span class="line">runtime_procUnpin()  </span><br><span class="line">allPoolsMu.Lock()  </span><br><span class="line"><span class="keyword">defer</span> allPoolsMu.Unlock()  </span><br><span class="line">pid := runtime_procPin()  </span><br><span class="line"><span class="comment">// doubleCheck 因为在执行上述命令过程中 pinSlow 可能已经被其他的线程调用，因此这时候需要再次对 pid 进行检查  </span></span><br><span class="line">s := p.localSize  </span><br><span class="line">l := p.local  </span><br><span class="line"><span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;  </span><br><span class="line"><span class="keyword">return</span> indexLocal(l, pid), pid  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> p.local == <span class="literal">nil</span> &#123;  </span><br><span class="line">allPools = <span class="built_in">append</span>(allPools, p)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 根据当前 P 的数量创建 pool.local并更新pool.localSize  </span></span><br><span class="line">size := runtime.GOMAXPROCS(<span class="number">0</span>)  </span><br><span class="line">local := <span class="built_in">make</span>([]poolLocal, size)  </span><br><span class="line">atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="number">0</span>])) <span class="comment">// store-release  </span></span><br><span class="line">runtime_StoreReluintptr(&amp;p.localSize, <span class="type">uintptr</span>(size))     <span class="comment">// store-release  </span></span><br><span class="line">    <span class="comment">// 最后根据 pid 返回当前 P 对应的 local  </span></span><br><span class="line"><span class="keyword">return</span> &amp;local[pid], pid  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### popHead</span><br><span class="line"></span><br><span class="line">然后回到 Get 方法</span><br><span class="line">```go</span><br><span class="line">x := l.private  </span><br><span class="line">l.private = nil  </span><br><span class="line">if x == nil &#123;  </span><br><span class="line">x, _ = l.shared.popHead()  </span><br><span class="line">if x == nil &#123;  </span><br><span class="line">x = p.getSlow(pid)  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">优先从 local.private 中取，如果没有就调用`poolChain.popHead()`去 local.shared 中取一个。</span><br><span class="line">```go</span><br><span class="line">func (c *poolChain) popHead() (interface&#123;&#125;, bool) &#123;  </span><br><span class="line">d := c.head  </span><br><span class="line">for d != nil &#123;  </span><br><span class="line">if val, ok := d.popHead(); ok &#123;  </span><br><span class="line">return val, ok  </span><br><span class="line">&#125;  </span><br><span class="line">d = loadPoolChainElt(&amp;d.prev)  </span><br><span class="line">&#125;  </span><br><span class="line">return nil, false  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`popHead` 函数只会被 producer 调用。首先拿到头节点：c.head，如果头节点不为空的话，尝试调用头节点的 `poolDequeue.popHead` 方法。</span><br><span class="line">```go</span><br><span class="line">func (d *poolDequeue) popHead() (interface&#123;&#125;, bool) &#123;  </span><br><span class="line">var slot *eface  </span><br><span class="line">for &#123;  </span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">head, tail := d.unpack(ptrs)  </span><br><span class="line">        // 收尾相连则说明队列是空的  </span><br><span class="line">if tail == head &#123;  </span><br><span class="line">return nil, false  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// head 位置是队头的前一个位置，所以此处要先退一位。  </span><br><span class="line">        // 在读出 slot 的 value 之前就把 head 值减 1，取消对这个 slot 的控制  </span><br><span class="line">head--  </span><br><span class="line">ptrs2 := d.pack(head, tail)  </span><br><span class="line">        // 通过 CAS 操作更新头部的位置 这样当前头部第一个元素就算是被移除了  </span><br><span class="line">if atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;  </span><br><span class="line">slot = &amp;d.vals[head&amp;uint32(len(d.vals)-1)]  </span><br><span class="line">break  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">    // 类型转换与 nil 判断  </span><br><span class="line">val := *(*interface&#123;&#125;)(unsafe.Pointer(slot))  </span><br><span class="line">if val == dequeueNil(nil) &#123;  </span><br><span class="line">val = nil  </span><br><span class="line">&#125;  </span><br><span class="line">    // 然后把这个 slot 置空，因为现在这个 slot 已经是队列的 head 了，置空便于前一个 head 被回收。  </span><br><span class="line">*slot = eface&#123;&#125;  </span><br><span class="line">return val, true  </span><br><span class="line">&#125;```</span><br></pre></td></tr></table></figure><p>此函数会删掉并且返回 <code>queue</code> 的头节点。但如果 <code>queue</code> 为空的话，返回 false。这里的 <code>queue</code> 存储的实际上就是 Pool 里缓存的对象。</p><p>整个函数的核心是一个无限循环，这是 Go 中常用的无锁化编程形式。</p><p>首先调用 unpack 函数分离出 head 和 tail 指针，如果 head 和 tail 相等，即首尾相等，那么这个队列就是空的，直接就返回 nil，false。</p><p>否则，将 head 指针后移一位，即 head 值减 1，然后调用 pack 打包 head 和 tail 指针。使用 CAS 更新 headTail 的值，并且把 vals 相应索引处的元素赋值给 slot。</p><blockquote><p>因为 <code>vals</code> 长度实际是只能是 2 的 n 次幂，因此 <code>len(d.vals)-1</code> 实际上得到的值的低 n 位是全 1，它再与 head 进行与运算，实际就是取 head 低 n 位的值作为下标。</p></blockquote><p>得到相应 slot 的元素后，经过类型转换并判断是否是 <code>dequeueNil</code>，如果是，说明没取到缓存的对象，返回 nil。</p><p>type dequeueNil *struct{}</p><p>最后，返回 val 之前，将 slot “归零”，移除和上一个 head 的关联，便于回收上一个 Head。</p><p>*slot = eface{}</p><p>结束后回到 <code>poolChain.popHead()</code>，如果调用 <code>poolDequeue.popHead()</code> 拿到了缓存的对象，就直接返回。否则，将 <code>d</code> 重新指向 <code>d.prev</code>，继续尝试获取缓存的对象。</p><h4 id="2-3-3-getSlow"><a href="#2-3-3-getSlow" class="headerlink" title="2.3.3 getSlow"></a>2.3.3 getSlow</h4><p>如果在 shared 里没有获取到缓存对象，则继续调用 <code>Pool.getSlow()</code>，尝试从其他 P 的 poolLocal 偷取：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> getSlow(pid <span class="type">int</span>) <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line">size := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire  </span></span><br><span class="line">locals := p.local                            <span class="comment">// load-consume  </span></span><br><span class="line">    <span class="comment">// 尝试从其他 p 中窃取一个对象  </span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;  </span><br><span class="line">        <span class="comment">// (pid+i+1)%int(size) 保证每次都可以从 当前pid+1 这个位置开始尝试窃取。  </span></span><br><span class="line">l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="type">int</span>(size))  </span><br><span class="line">        <span class="comment">// 如果能取到就直接返回  </span></span><br><span class="line"><span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> x  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 尝试从其他 P 的 poolLocal 窃取失败后，再尝试从victim cache中取对象  </span></span><br><span class="line">    <span class="comment">// 这样可以使 victim 中的对象更容易被回收。  </span></span><br><span class="line">size = atomic.LoadUintptr(&amp;p.victimSize)  </span><br><span class="line"><span class="keyword">if</span> <span class="type">uintptr</span>(pid) &gt;= size &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">locals = p.victim  </span><br><span class="line">l := indexLocal(locals, pid)  </span><br><span class="line"><span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123;  </span><br><span class="line">l.private = <span class="literal">nil</span>  </span><br><span class="line"><span class="keyword">return</span> x  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;  </span><br><span class="line">l := indexLocal(locals, (pid+i)%<span class="type">int</span>(size))  </span><br><span class="line"><span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> x  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 清空 victim cache。下次就不用再从这里找了  </span></span><br><span class="line">atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;<span class="string">``</span><span class="string">`</span></span><br></pre></td></tr></table></figure></p><p>从索引为 pid+1 的 poolLocal 处开始，尝试调用 <code>shared.popTail()</code> 获取缓存对象。如果没有拿到，则从 victim 里找，和 poolLocal 的逻辑类似。</p><p>最后，实在没找到，就把 victimSize 置 0，防止后来的“人”再到 victim 里找。</p><p>在 Get 函数的最后，经过这一番操作还是没找到缓存的对象，就调用 New 函数创建一个新的对象。</p><h4 id="2-3-4-popTail"><a href="#2-3-4-popTail" class="headerlink" title="2.3.4 popTail"></a>2.3.4 popTail</h4><p>最后，还剩一个 popTail 函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> popTail() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;  </span><br><span class="line">    <span class="comment">// tail 指针为空直接返回 这里的 tail 是一个双端队列  </span></span><br><span class="line">d := loadPoolChainElt(&amp;c.tail)  </span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> &#123;  </span><br><span class="line"><span class="comment">// It&#x27;s important that we load the next pointer  </span></span><br><span class="line"><span class="comment">// *before* popping the tail. In general, d may be  </span></span><br><span class="line"><span class="comment">// transiently empty, but if next is non-nil before  </span></span><br><span class="line"><span class="comment">// the pop and the pop fails, then d is permanently  </span></span><br><span class="line"><span class="comment">// empty, which is the only condition under which it&#x27;s  </span></span><br><span class="line"><span class="comment">// safe to drop d from the chain.  </span></span><br><span class="line">        <span class="comment">// 在 for 循环的一开始，就把 d.next 加载到了 d2。因为 d 可能会短暂为空，但如果 d2 在 pop 或者 pop fails 之前就不为空的话，说明 d 就会永久为空了。在这种情况下，可以安全地将 d 这个结点“甩掉”。  </span></span><br><span class="line">d2 := loadPoolChainElt(&amp;d.next)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> val, ok := d.popTail(); ok &#123;  </span><br><span class="line"><span class="keyword">return</span> val, ok  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> d2 == <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="comment">// This is the only dequeue. It&#x27;s empty right  </span></span><br><span class="line"><span class="comment">// now, but could be pushed to in the future.  </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 同样的通过 CAS 来更新 tail 的值为 d2  </span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) &#123;  </span><br><span class="line">storePoolChainElt(&amp;d2.prev, <span class="literal">nil</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">        <span class="comment">// 最后将d2赋值给d便于进行下一轮循环。  </span></span><br><span class="line">d = d2  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p><p>在 for 循环的一开始，就把 d.next 加载到了 d2。因为 d 可能会短暂为空，但如果 d2 在 pop 或者 pop fails 之前就不为空的话，说明 d 就会永久为空了。在这种情况下，可以安全地将 d 这个结点“甩掉”。</p><p>最后，将 c.tail 更新为 d2，可以防止下次 popTail 的时候查看一个空的 dequeue；而将 d2.prev 设置为 nil，可以防止下次 popHead 时查看一个空的 dequeue。</p><p>我们再看一下核心的 <code>poolDequeue.popTail</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popTail() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;  </span><br><span class="line"><span class="keyword">var</span> slot *eface  </span><br><span class="line"><span class="keyword">for</span> &#123;  </span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">head, tail := d.unpack(ptrs)  </span><br><span class="line">        <span class="comment">// 同样的 head=tail 说明队列为空  </span></span><br><span class="line"><span class="keyword">if</span> tail == head &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 同样是 CAS 更新 headTail 以移除 tail 元素  </span></span><br><span class="line">ptrs2 := d.pack(head, tail+<span class="number">1</span>)  </span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;  </span><br><span class="line"><span class="comment">// Success.  </span></span><br><span class="line">slot = &amp;d.vals[tail&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]  </span><br><span class="line"><span class="keyword">break</span>  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 类型转换和 nil 判断  </span></span><br><span class="line">val := *(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot))  </span><br><span class="line"><span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;  </span><br><span class="line">val = <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 最后也是将这个 slot 置空  </span></span><br><span class="line">    <span class="comment">// 先清空 val 再清空 typ 操作顺序和 pushHead 正好相反  </span></span><br><span class="line">slot.val = <span class="literal">nil</span>  </span><br><span class="line">atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">true</span>  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popTail() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;  </span><br><span class="line"><span class="keyword">var</span> slot *eface  </span><br><span class="line"><span class="keyword">for</span> &#123;  </span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">head, tail := d.unpack(ptrs)  </span><br><span class="line">        <span class="comment">// 同样的 head=tail 说明队列为空  </span></span><br><span class="line"><span class="keyword">if</span> tail == head &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 同样是 CAS 更新 headTail 以移除 tail 元素  </span></span><br><span class="line">ptrs2 := d.pack(head, tail+<span class="number">1</span>)  </span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;  </span><br><span class="line"><span class="comment">// Success.  </span></span><br><span class="line">slot = &amp;d.vals[tail&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]  </span><br><span class="line"><span class="keyword">break</span>  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 类型转换和 nil 判断  </span></span><br><span class="line">val := *(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot))  </span><br><span class="line"><span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;  </span><br><span class="line">val = <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 最后也是将这个 slot 置空  </span></span><br><span class="line">    <span class="comment">// 先清空 val 再清空 typ 操作顺序和 pushHead 正好相反  </span></span><br><span class="line">slot.val = <span class="literal">nil</span>  </span><br><span class="line">atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>)  </span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整体逻辑和 popHead 差不多。</p><h4 id="2-3-5-小结"><a href="#2-3-5-小结" class="headerlink" title="2.3.5 小结"></a>2.3.5 小结</h4><p>首先从 当前 p 对应的 local.private 上取，没有就从 local.shared 里取，还没有就去其他 p 的 local.shared 里取，都没有就 new 一个返回。</p><h3 id="2-4-Put"><a href="#2-4-Put" class="headerlink" title="2.4 Put"></a>2.4 Put</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Put(x <span class="keyword">interface</span>&#123;&#125;) &#123;  </span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">return</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">l, _ := p.pin()  </span><br><span class="line"><span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123;  </span><br><span class="line">l.private = x  </span><br><span class="line">x = <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> x != <span class="literal">nil</span> &#123;  </span><br><span class="line">l.shared.pushHead(x)  </span><br><span class="line">&#125;  </span><br><span class="line">runtime_procUnpin()  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程也比较简单：</p><ol><li>先绑定 g 和 P，然后尝试将 x 赋值给 private 字段。</li><li>如果失败，就调用 <code>pushHead</code> 方法尝试将其放入 shared 字段所维护的双端队列中。<h4 id="2-4-1-pushHead"><a href="#2-4-1-pushHead" class="headerlink" title="2.4.1 pushHead"></a>2.4.1 pushHead</h4></li></ol><p>p.pin() 和之前是一样的，就不分析了，主要看一下 pushHead()<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> pushHead(val <span class="keyword">interface</span>&#123;&#125;) &#123;  </span><br><span class="line">d := c.head  </span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="comment">// 第一次写入，队列为空则进行初始化 默认长度为8  </span></span><br><span class="line"><span class="keyword">const</span> initSize = <span class="number">8</span> <span class="comment">// Must be a power of 2  </span></span><br><span class="line">d = <span class="built_in">new</span>(poolChainElt)  </span><br><span class="line">d.vals = <span class="built_in">make</span>([]eface, initSize)  </span><br><span class="line">c.head = d  </span><br><span class="line">storePoolChainElt(&amp;c.tail, d)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 存储元素 存储成功直接返回  </span></span><br><span class="line"><span class="keyword">if</span> d.pushHead(val) &#123;  </span><br><span class="line"><span class="keyword">return</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// The current dequeue is full. Allocate a new one of twice  </span></span><br><span class="line"><span class="comment">// the size.  </span></span><br><span class="line">    <span class="comment">// 存储失败说明队列满了 进行扩容  </span></span><br><span class="line">newSize := <span class="built_in">len</span>(d.vals) * <span class="number">2</span>  </span><br><span class="line"><span class="keyword">if</span> newSize &gt;= dequeueLimit &#123; <span class="comment">// 限制一下，不能无限扩容  </span></span><br><span class="line">newSize = dequeueLimit  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 扩容逻辑也比较简单，就是首尾相连，构成链表  </span></span><br><span class="line">d2 := &amp;poolChainElt&#123;prev: d&#125;  </span><br><span class="line">d2.vals = <span class="built_in">make</span>([]eface, newSize)  </span><br><span class="line">c.head = d2  </span><br><span class="line">storePoolChainElt(&amp;d.next, d2)  </span><br><span class="line">d2.pushHead(val)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果 <code>c.head</code> 为空，就要创建一个 poolChainElt，作为首结点，当然也是尾节点。它管理的双端队列的长度，初始为 8，放满之后，再创建一个 poolChainElt 节点时，双端队列的长度就要翻倍。当然，有一个最大长度限制（2^30）：</p><p>const dequeueBits = 32  </p><p>const dequeueLimit = (1 &lt;&lt; dequeueBits) / 4</p><p>调用 <code>poolDequeue.pushHead</code> 尝试将对象放到 poolDeque 里去：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> pushHead(val <span class="keyword">interface</span>&#123;&#125;) <span class="type">bool</span> &#123;  </span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">head, tail := d.unpack(ptrs)  </span><br><span class="line">    <span class="comment">// 首先判断队列是否已满： 也就是将尾部指针加上 d.vals 的长度，再取低 31 位，看它是否和 head 相等  </span></span><br><span class="line"><span class="keyword">if</span> (tail+<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)))&amp;(<span class="number">1</span>&lt;&lt;dequeueBits<span class="number">-1</span>) == head &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">slot := &amp;d.vals[head&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Check if the head slot has been released by popTail.  </span></span><br><span class="line">typ := atomic.LoadPointer(&amp;slot.typ)  </span><br><span class="line"><span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="comment">// Another goroutine is still cleaning up the tail, so  </span></span><br><span class="line"><span class="comment">// the queue is actually still full.  </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// slot占位，将val存入vals中  </span></span><br><span class="line"><span class="keyword">if</span> val == <span class="literal">nil</span> &#123;  </span><br><span class="line">val = dequeueNil(<span class="literal">nil</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">*(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot)) = val  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// head 增加 1  </span></span><br><span class="line">atomic.AddUint64(&amp;d.headTail, <span class="number">1</span>&lt;&lt;dequeueBits)  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先判断队列是否已满：</p><pre><code>if (tail+uint32(len(d.vals)))&amp;(1&lt;&lt;dequeueBits-1) == head &#123;      return false  &#125;</code></pre><p>队列没满，通过 head 指针找到即将填充的 slot 位置：取 head 指针的低 31 位。</p><pre><code>slot := &amp;d.vals[head&amp;uint32(len(d.vals)-1)]  // Check if the head slot has been released by popTail.  typ := atomic.LoadPointer(&amp;slot.typ)  if typ != nil &#123;      // Another goroutine is still cleaning up the tail, so      // the queue is actually still full.      return false  &#125;</code></pre><p>这里还判断了当前 slot 是否正在被 popTail 释放，popTail 相关语句如下：</p><pre><code>// 最后也是将这个 slot 置空  // 先清空 val 再清空 typ 操作顺序和 pushHead 正好相反  slot.val = nil  atomic.StorePointer(&amp;slot.typ, nil)</code></pre><p>所以如果 slot.typ==nil 就说明这个 slot 正在被 popTail 释放，说明队列其实还是满的，直接返回 false，走后续的扩容逻辑。</p><p>最后，将 val 赋值到 slot，并将 head 指针值加 1。</p><p>// slot占位，将val存入vals中<br><em>(</em>interface{})(unsafe.Pointer(slot)) = val</p><blockquote><p>这里的实现比较巧妙，slot 是 eface 类型，即空接口，将 slot 转为 interface{} 类型，这样 val 能以 interface{} 赋值给 slot 让 slot.typ 和 slot.val 指向其内存块，于是 slot.typ 和 slot.val 均不为空。</p></blockquote><h4 id="2-4-2-pack-unpack"><a href="#2-4-2-pack-unpack" class="headerlink" title="2.4.2 pack/unpack"></a>2.4.2 pack/unpack</h4><p>最后我们再来看一下 pack 和 unpack 函数，它们实际上是一组绑定、解绑 head 和 tail 指针的两个函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> pack(head, tail <span class="type">uint32</span>) <span class="type">uint64</span> &#123;  </span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span>  </span><br><span class="line"><span class="keyword">return</span> (<span class="type">uint64</span>(head) &lt;&lt; dequeueBits) |  </span><br><span class="line"><span class="type">uint64</span>(tail&amp;mask)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`mask`</span> 的低 <span class="number">31</span> 位为全 <span class="number">1</span>，其他位为 <span class="number">0</span>，它和 tail 相与，就是只看 tail 的低 <span class="number">31</span> 位。而 head 向左移 <span class="number">32</span> 位之后，低 <span class="number">32</span> 位为全 <span class="number">0</span>。最后把两部分“或”起来，head 和 tail 就“绑定”在一起了。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> unpack(ptrs <span class="type">uint64</span>) (head, tail <span class="type">uint32</span>) &#123;  </span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span>  </span><br><span class="line">head = <span class="type">uint32</span>((ptrs &gt;&gt; dequeueBits) &amp; mask)  </span><br><span class="line">tail = <span class="type">uint32</span>(ptrs &amp; mask)  </span><br><span class="line"><span class="keyword">return</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>unpack 则是相反的逻辑，取出 head 指针的方法就是将 ptrs 右移 32 位，再与 mask 相与，同样只看 head 的低 31 位。而 tail 实际上更简单，直接将 ptrs 与 mask 相与就可以了。</p><h4 id="2-4-3-小结"><a href="#2-4-3-小结" class="headerlink" title="2.4.3 小结"></a>2.4.3 小结</h4><p>Put 和 Get 类似，首先尝试将放到当前 p 的 local.private 上，已经有了就放到 local.shared。</p><h3 id="2-5-GC"><a href="#2-5-GC" class="headerlink" title="2.5 GC"></a>2.5 GC</h3><p>对于 Pool 而言，并不能无限扩展，否则对象占用内存太多了，会引起内存溢出。<br>sync.pool 选择了在 GC 时进行清理。<br>在 pool.go 文件的 init 函数里，注册了 GC 发生时，如何清理 Pool 的函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/pool.go  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;  </span><br><span class="line">runtime_registerPoolCleanup(poolCleanup)  </span><br><span class="line">&#125;</span><br><span class="line">编译器在编译时将其注册到运行时：</span><br><span class="line"><span class="comment">// src/runtime/mgc.go  </span></span><br><span class="line"><span class="comment">// Hooks for other packages  </span></span><br><span class="line"><span class="keyword">var</span> poolcleanup <span class="function"><span class="keyword">func</span><span class="params">()</span></span>  </span><br><span class="line"><span class="comment">// 利用编译器标志将 sync 包中的清理注册到运行时  </span></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_registerPoolCleanup sync.runtime_registerPoolCleanup  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_registerPoolCleanup</span><span class="params">(f <span class="keyword">func</span>()</span></span>) &#123;  </span><br><span class="line">  poolcleanup = f  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">具体的 poolCleanup() 函数如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolCleanup</span><span class="params">()</span></span> &#123;  </span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> oldPools &#123;  </span><br><span class="line">p.victim = <span class="literal">nil</span>  </span><br><span class="line">p.victimSize = <span class="number">0</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> allPools &#123;  </span><br><span class="line">p.victim = p.local  </span><br><span class="line">p.victimSize = p.localSize  </span><br><span class="line">p.local = <span class="literal">nil</span>  </span><br><span class="line">p.localSize = <span class="number">0</span>  </span><br><span class="line">&#125;  </span><br><span class="line">oldPools, allPools = allPools, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整体看起来，比较简洁。主要是将 local 和 victim 作交换，这样也就不致于让 GC 把所有的 Pool 都清空了，有 victim 在“兜底”。</p><ol><li>初始状态下，oldPools 和 allPools 均为 nil。</li><li>第 1 次调用 Get，由于 p.local 为 nil，将会在 pinSlow 中创建 p.local，然后将 p 放入 allPools，此时 allPools 长度为 1，oldPools 为 nil。</li><li>对象使用完毕，第 1 次调用 Put 放回对象。</li><li>第 1 次GC STW 阶段，allPools 中所有 p.local 将值赋值给 victim 并置为 nil。allPools 赋值给 oldPools，最后 allPools 为 nil，oldPools 长度为 1。</li><li>第 2 次调用 Get，由于 p.local 为 nil，此时会从 p.victim 里面尝试取对象。</li><li>对象使用完毕，第 2 次调用 Put 放回对象，但由于 p.local 为 nil，重新创建 p.local，并将对象放回，此时 allPools 长度为 1，oldPools 长度为 1。</li><li>第 2 次 GC STW 阶段，oldPools 中所有 p.victim 置 nil，前一次的 cache 在本次 GC 时被回收，allPools 所有 p.local 将值赋值给 victim 并置为nil，最后 allPools 为 nil，oldPools 长度为 1。<br>简单来说就是清理时，先清理 oldPools 的 local.victim,然后把 allPools 中的 local 赋值给 victim，最后再把 allPools 赋值给 oldPools，把 allPools 置空。<blockquote><p>GC 时只会清理 oldPools，allPools 只会先把数据转移到 victim，然后把 allPools 变成 oldPools，如果从 oldPools 中读取出来的数据进行 Put 也会直接放到 allPools 中，相当于要两次 GC 都没有被访问到并且Put回来才会被移除。</p></blockquote></li></ol><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><ul><li><p>1）关键思想是对象的复用，避免重复创建、销毁。将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力。</p></li><li><p>2）<code>sync.Pool</code> 是协程安全的，使用起来非常方便。设置好 New 函数后，调用 Get 获取，调用 Put 归还对象。</p></li><li><p>3）不要对 Get 得到的对象有任何假设，更好的做法是归还对象时，将对象“清空”。</p></li><li><p>4）Pool 里对象的生命周期受 GC 影响，不适合于做连接池，因为连接池需要自己管理对象的生命周期。</p></li></ul><p>一些设计思想或者相关知识点：</p><ul><li><p>lock free：无锁编程是很多编程语言里逃离不了的话题。<code>sync.Pool</code>的无锁是在<code>poolDequeue</code>和<code>poolChain</code>层面实现的。</p></li><li><p>原子操作代替锁：<code>poolDequeue</code>对一些关键变量采用了CAS操作，比如<code>poolDequeue.headTail</code>，既可完整保证并发又能降低相比锁而言的开销。</p></li><li><p>cacheline false sharing 问题</p></li><li><p>noCopy 禁止复制</p></li><li><p>分段锁，降低锁粒度</p></li><li><p>victim cache</p></li><li><p>常见优化手段：复用</p></li></ul><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><code>https://golang.org/src/sync/pool.go</code></p><p><code>https://en.wikipedia.org/wiki/False_sharing</code></p><p><code>https://en.wikipedia.org/wiki/Victim_cache</code></p><p><code>https://zhuanlan.zhihu.com/p/110140126</code></p><p><code>https://medium.com/swlh/go-the-idea-behind-sync-pool-32da5089df72</code></p><p><code>https://zhuanlan.zhihu.com/p/133638023</code></p><p><code>https://www.jianshu.com/p/dc4b5562aad2</code></p><p><code>https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/</code></p><p>[Github]  <a href="https://github.com/lixd/i-go/blob/master/a-tutorials/lib/sync_pool/main.go">https://github.com/lixd/i-go/blob/master/a-tutorials/lib/sync_pool/main.go</a> </p><p>[pool-structure]  <a href="https://github.com/lixd/blog/raw/master/images/golang/lib/sync-pool/pool-structure.png">https://github.com/lixd/blog/raw/master/images/golang/lib/sync-pool/pool-structure.png</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要介绍了Go语言(golang)中的&lt;code&gt;sync.pool&lt;/code&gt;包。给出了 sync.pool 的基本用法，以及各大框架中的使用案例。并从源码层面对其底层结构和具体实现原理进行分析。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以下分析基于 Go 1.17</summary>
      
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="并发编程" scheme="https://stardustorz.github.io/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Go] GMP</title>
    <link href="https://stardustorz.github.io/2022/07/03/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP/"/>
    <id>https://stardustorz.github.io/2022/07/03/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP/</id>
    <published>2022-07-02T16:00:00.000Z</published>
    <updated>2025-03-08T15:42:05.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>gmp = goroutine + machine + processor</p></blockquote><span id="more"></span><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><h3 id="1-1-线程"><a href="#1-1-线程" class="headerlink" title="1.1 线程"></a>1.1 线程</h3><p>通常指的是内核级线程，核心点如下：</p><ul><li>是操作系统最小调度单元；</li><li>创建、销毁、调度交由内核完成，cpu 需完成用户态与内核态间的切换；</li><li>可充分利用多核，实现并行.<h3 id="1-2-协程"><a href="#1-2-协程" class="headerlink" title="1.2 协程"></a>1.2 协程</h3></li></ul><p>协程，又称为用户级线程，核心点如下：</p><ul><li>与线程存在映射关系，为 M：1；</li><li>创建、销毁、调度在用户态完成，对内核透明，所以更轻；</li><li>从属同一个内核级线程，无法并行；一个协程阻塞会导致从属同一线程的所有协程无法执行.</li></ul><h3 id="1-3-Goroutine"><a href="#1-3-Goroutine" class="headerlink" title="1.3 Goroutine"></a>1.3 Goroutine</h3><p>Goroutine，经 Golang 优化后的特殊“协程”，特点如下：</p><ul><li>与线程存在映射关系，为 M：N；</li><li>创建、销毁、调度在用户态完成，对内核透明，足够轻便；</li><li>可利用多个线程，实现并行；</li><li>通过调度器的，实现和线程间的动态绑定和灵活调度；</li><li>栈空间大小可动态扩缩.</li></ul><h3 id="1-4-对比"><a href="#1-4-对比" class="headerlink" title="1.4 对比"></a>1.4 对比</h3><div class="table-container"><table><thead><tr><th><strong>模型</strong></th><th><strong>弱依赖内核</strong></th><th><strong>可并行</strong></th><th><strong>可应对阻塞</strong></th><th><strong>栈可动态扩缩</strong></th></tr></thead><tbody><tr><td>线程</td><td>❎</td><td>✅</td><td>✅</td><td>❎</td></tr><tr><td>协程</td><td>✅</td><td>❎</td><td>❎</td><td>❎</td></tr><tr><td>goroutine</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table></div><h2 id="2-GMP-模型"><a href="#2-GMP-模型" class="headerlink" title="2 GMP 模型"></a>2 GMP 模型</h2><h3 id="2-1-g"><a href="#2-1-g" class="headerlink" title="2.1 g"></a>2.1 g</h3><ul><li>g 即goroutine，是 golang 中对协程的抽象</li><li>g 有自己的运行栈、状态、以及执行的任务函数（用户通过 go func 指定）</li><li>g 需要绑定到 p 才能执行，在 g 的视角中，p 就是它的 cpu</li></ul><h3 id="2-2-m"><a href="#2-2-m" class="headerlink" title="2.2 m"></a>2.2 m</h3><ul><li>m 即 machine，是 golang 中对线程的抽象</li><li>m 不直接执行 g，而是先和 p 绑定，由其实现代理</li><li>借由 p 的存在，m 无需和 g 绑死，也无需记录 g 的状态信息，因此 g 在全生命周期中可以实现跨 m 执行.</li></ul><h3 id="2-3-p"><a href="#2-3-p" class="headerlink" title="2.3 p"></a>2.3 p</h3><ul><li>p 即 processor，是 golang 中的调度器</li><li>p 是 gmp 的中枢，借由 p 承上启下，实现 g 和 m 之间的动态有机结合</li><li>对 g 而言，p 是其 cpu，g 只有被 p 调度，才得以执行</li><li>对 m 而言，p 是其执行代理，为其提供必要信息的同时（可执行的 g、内存分配情况等），并隐藏了繁杂的调度细节</li><li>p 的数量决定了 g 最大并行数量，可由用户通过 GOMAXPROCS 进行设定（超过 CPU 核数时无意义）</li></ul><h3 id="2-4-GMP"><a href="#2-4-GMP" class="headerlink" title="2.4 GMP"></a>2.4 GMP</h3><ul><li>M 是线程的抽象；G 是 goroutine；P 是承上启下的调度器；</li><li>M调度G前，需要和P绑定；</li><li>全局有多个M和多个P，但同时并行的G的最大数量等于P的数量；</li><li>G的存放队列有三类：P的本地队列；全局队列；和wait队列（图中未展示，为io阻塞就绪态goroutine队列）；</li><li>M调度G时，优先取P本地队列，其次取全局队列，最后取wait队列；这样的好处是，取本地队列时，可以接近于无锁化，减少全局锁竞争；</li><li>为防止不同P的闲忙差异过大，设立work-stealing机制，本地队列为空的P可以尝试从其他P本地队列偷取一半的G补充到自身队列.</li></ul><h2 id="3-核心数据结构"><a href="#3-核心数据结构" class="headerlink" title="3 核心数据结构"></a>3 核心数据结构</h2><blockquote><p>gmp 数据结构定义在 runtime/runtime2.go 文件中</p></blockquote><h3 id="3-1-g"><a href="#3-1-g" class="headerlink" title="3.1 g"></a>3.1 g</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    m         *m      </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sched     gobuf</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    sp   <span class="type">uintptr</span></span><br><span class="line">    pc   <span class="type">uintptr</span></span><br><span class="line">    ret  <span class="type">uintptr</span></span><br><span class="line">    bp   <span class="type">uintptr</span> <span class="comment">// for framepointer-enabled architectures</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>m：在 p 的代理，负责执行当前 g 的 m；</li><li>sched.sp：保存 CPU 的 rsp 寄存器的值，指向函数调用栈栈顶；</li><li>sched.pc：保存 CPU 的 rip 寄存器的值，指向程序下一条执行指令的地址；</li><li>sched.ret：保存系统调用的返回值；</li><li>sched.bp：保存 CPU 的 rbp 寄存器的值，存储函数栈帧的起始位置.</li></ul><p>g的生命周期:未初始化完成 等待被执行  执行  执行系统调用  挂起态  被销毁  栈扩容 被抢占</p><h3 id="3-2-m"><a href="#3-2-m" class="headerlink" title="3.2 m"></a>3.2 m</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    g0      *g     <span class="comment">// goroutine with scheduling stack</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    tls           [tlsSlots]<span class="type">uintptr</span> <span class="comment">// thread-local storage (for x86 extern register)</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>g0：一类特殊的调度协程，不用于执行用户函数，负责执行 g 之间的切换调度. 与 m 的关系为 1:1；</li><li>tls：thread-local storage，线程本地存储，存储内容只对当前线程可见. 线程本地存储的是 m.tls 的地址，m.tls[0] 存储的是当前运行的 g，因此线程可以通过 g 找到当前的 m、p、g0 等信息.<h3 id="3-3-p"><a href="#3-3-p" class="headerlink" title="3.3 p"></a>3.3 p</h3></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    runqhead <span class="type">uint32</span></span><br><span class="line">    runqtail <span class="type">uint32</span></span><br><span class="line">    runq     [<span class="number">256</span>]guintptr</span><br><span class="line">    </span><br><span class="line">    runnext guintptr</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>runq：本地 goroutine 队列，最大长度为 256.</li><li>runqhead：队列头部；</li><li>runqtail：队列尾部；</li><li>runnext：下一个可执行的 goroutine.</li></ul><h3 id="3-4-schedt"><a href="#3-4-schedt" class="headerlink" title="3.4 schedt"></a>3.4 schedt</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lock mutex</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    runq     gQueue</span><br><span class="line">    runqsize <span class="type">int32</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sched 是全局 goroutine 队列的封装：</p><ul><li>lock：一把操作全局队列时使用的锁；</li><li>runq：全局 goroutine 队列；</li><li>runqsize：全局 goroutine 队列的容量.</li></ul><h2 id="4-调度流程"><a href="#4-调度流程" class="headerlink" title="4 调度流程"></a>4 调度流程</h2><h3 id="4-1-g0-和-g-的转换"><a href="#4-1-g0-和-g-的转换" class="headerlink" title="4.1 g0 和 g 的转换"></a>4.1 g0 和 g 的转换</h3><p><strong>goroutine 的类型可分为两类：</strong></p><ul><li>负责调度普通 g 的 g0，执行固定的调度流程，与 m 的关系为一对一</li><li>负责执行用户函数的普通 g<br>m 通过 p 调度执行的 goroutine 永远在普通 g 和 g0 之间进行切换，当 g0 找到可执行的 g 时，会调用 gogo 方法，调度 g 执行用户定义的任务；当 g 需要主动让渡或被动调度时，会触发 mcall 方法，将执行权重新交还给 g0.</li></ul><h3 id="4-2-调度类型"><a href="#4-2-调度类型" class="headerlink" title="4.2 调度类型"></a>4.2 调度类型</h3><blockquote><p>调度器 p 实现从执行一个 g 切换到另一个 g 的过程.</p></blockquote><h4 id="4-2-1-主动调度"><a href="#4-2-1-主动调度" class="headerlink" title="4.2.1 主动调度"></a>4.2.1 主动调度</h4><ul><li>用户主动执行让渡的方式，主要方式是，用户在执行代码中调用了 runtime.Gosched 方法，此时当前 g 会当让出执行权，主动进行队列等待下次被调度执行.</li></ul><h4 id="4-2-2-被动调度"><a href="#4-2-2-被动调度" class="headerlink" title="4.2.2 被动调度"></a>4.2.2 被动调度</h4><ul><li>因当前不满足某种执行条件，g 可能会陷入阻塞态无法被调度，直到关注的条件达成后，g才从阻塞中被唤醒，重新进入可执行队列等待被调度.</li><li><p>常见的被动调度触发方式为因 channel 操作或互斥锁操作陷入阻塞等操作，底层会走进 gopark 方法.</p><h4 id="4-2-3-正常调度"><a href="#4-2-3-正常调度" class="headerlink" title="4.2.3 正常调度"></a>4.2.3 正常调度</h4></li><li><p>g 中的执行任务已完成，g0 会将当前 g 置为死亡状态，发起新一轮调度.</p><h4 id="4-2-4-抢占调度"><a href="#4-2-4-抢占调度" class="headerlink" title="4.2.4 抢占调度"></a>4.2.4 抢占调度</h4></li><li><p>如果 g 执行系统调用超过指定的时长，且全局的 p 资源比较紧缺，此时将 p 和 g 解绑，抢占出来用于其他 g 的调度. 等 g 完成系统调用后，会重新进入可执行队列中等待被调度.</p></li><li>前 3 种调度方式都由 m 下的 g0 完成，唯独抢占调度不同.</li><li>因为发起系统调用时需要打破用户态的边界进入内核态，此时 m 也会因系统调用而陷入僵直，无法主动完成抢占调度的行为.</li><li>因此，在 Golang 进程会有一个全局监控协程 monitor g 的存在，这个 g 会越过 p 直接与一个 m 进行绑定，不断轮询对所有 p 的执行状况进行监控. 倘若发现满足抢占调度的条件，则会从第三方的角度出手干预，主动发起该动作.</li></ul><h3 id="4-3-宏观调度流程"><a href="#4-3-宏观调度流程" class="headerlink" title="4.3 宏观调度流程"></a>4.3 宏观调度流程</h3><ul><li>g0 执行 schedule() 函数，寻找到用于执行的 g</li><li>g0 执行 execute() 方法，更新当前 g、p 的状态信息，并调用 gogo() 方法，将执行权交给 g</li><li>g 因主动让渡( gosche_m() )、被动调度( park_m() )、正常结束( goexit0() )等原因，调用 m_call 函数，执行权重新回到 g0 手中</li><li>g0 执行 schedule() 函数，开启新一轮循环</li></ul><h3 id="4-4-schedule"><a href="#4-4-schedule" class="headerlink" title="4.4 schedule"></a>4.4 schedule</h3><p>调度流程的主干方法是位于 runtime/proc.go 中的 schedule 函数，此时的执行权位于 g0 手中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    gp, inheritTime, tryWakeP := findRunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>寻找到下一个执行的 goroutine</li><li>执行该 goroutine</li></ul><h3 id="4-5-findRunnable"><a href="#4-5-findRunnable" class="headerlink" title="4.5 findRunnable"></a>4.5 findRunnable</h3><p><img src="file-20250303232645826.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRunnable</span><span class="params">()</span></span> (gp *g, inheritTime, tryWakeP <span class="type">bool</span>) &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    _p_ := _g_.m.p.ptr()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> _p_.schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        gp = globrunqget(_p_, <span class="number">1</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> gp, inheritTime := runqget(_p_); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gp, inheritTime, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> list := netpoll(<span class="number">0</span>); !list.empty() &#123; <span class="comment">// non-blocking</span></span><br><span class="line">            gp := list.pop()</span><br><span class="line">            injectglist(&amp;list)</span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    procs := <span class="type">uint32</span>(gomaxprocs)</span><br><span class="line">    <span class="keyword">if</span> _g_.m.spinning || <span class="number">2</span>*atomic.Load(&amp;sched.nmspinning) &lt; procs-atomic.Load(&amp;sched.npidle) &#123;</span><br><span class="line">        <span class="keyword">if</span> !_g_.m.spinning &#123;</span><br><span class="line">            _g_.m.spinning = <span class="literal">true</span></span><br><span class="line">            atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gp, inheritTime, tnow, w, newWork := stealWork(now)</span><br><span class="line">        now = tnow</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// Successfully stole.</span></span><br><span class="line">            <span class="keyword">return</span> gp, inheritTime, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> newWork &#123;</span><br><span class="line">            <span class="comment">// There may be new timer or GC work; restart to</span></span><br><span class="line">            <span class="comment">// discover.</span></span><br><span class="line">            <span class="keyword">goto</span> top</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; (pollUntil == <span class="number">0</span> || w &lt; pollUntil) &#123;</span><br><span class="line">            <span class="comment">// Earlier timer to wait for.</span></span><br><span class="line">            pollUntil = w</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>p 每执行 61 次调度，会从全局队列中获取一个 goroutine 进行执行，并将一个全局队列中的 goroutine 填充到当前 p 的本地队列中<ul><li>取得 p 本地队列队首的索引，同时对本地队列加锁</li><li>倘若 p 的局部队列未满，则成功转移 g，将 p 的对尾索引 runqtail 值加 1 并解锁队列.</li><li>倘若发现本地队列 runq 已经满了，则会返回来将本地队列中一半的 g 放回全局队列中，帮助当前 p 缓解执行压力，这部分内容位于 runqputslow 方法中</li></ul></li><li>尝试从 p 本地队列中获取一个可执行的 goroutine，核心逻辑位于 runqget 方法中<ul><li>倘若当前 p 的 runnext 非空，直接获取即可</li><li>加锁从 p 的本地队列中获取 g, 虽然本地队列是属于 p 独有的，但是由于 work-stealing 机制的存在，其他 p 可能会前来执行窃取动作，因此操作仍需加锁.</li><li>倘若本地队列为空，直接终止并返回</li><li>倘若本地队列存在 g，则取得队首的 g，解锁并返回</li></ul></li><li>倘若本地队列没有可执行的 g，会从全局队列中获取</li><li>倘若本地队列和全局队列都没有 g，则会获取准备就绪的网络协程</li><li>work-stealing: 从其他 p 中偷取 g<ul><li>偷取操作至多会遍历全局的 p 队列 4 次，过程中只要找到可窃取的 p 则会立即返回.</li><li>为保证窃取行为的公平性，遍历的起点是随机的. 窃取动作的核心逻辑位于 runqgrab 方法当中</li><li>每次对一个 p 尝试窃取前，会对其局部队列加锁</li><li>尝试偷取其现有的一半 g，并且返回实际偷取的数量</li></ul></li></ul><h3 id="4-6-execute"><a href="#4-6-execute" class="headerlink" title="4.6 execute"></a>4.6 execute</h3><p>当 g0 为 m 寻找到可执行的 g 之后，接下来就开始执行 g. 这部分内容位于 runtime/proc.go 的 execute 方法中</p><ul><li>更新 g 的状态信息，建立 g 与 m 之间的绑定关系</li><li>更新 p 的总调度次数</li><li>调用 gogo 方法，执行 goroutine 中的任务</li></ul><h3 id="4-7-gosched-m"><a href="#4-7-gosched-m" class="headerlink" title="4.7 gosched_m"></a>4.7 gosched_m</h3><p>g 执行主动让渡时，会调用 mcall 方法将执行权归还给 g0，并由 g0 调用 gosched_m 方法，位于 runtime/proc.go 文件中</p><p><img src="file-20250303234355218.png" alt=""></p><ul><li>将当前 g 的状态由执行中切换为待执行 <code>_Grunnable</code></li><li>调用 dropg() 方法，将当前的 m 和 g 解绑</li><li>将 g 添加到全局队列当中</li><li>开启新一轮的调度</li></ul><h3 id="4-8-park-m-与-ready"><a href="#4-8-park-m-与-ready" class="headerlink" title="4.8 park_m 与 ready"></a>4.8 park_m 与 ready</h3><ul><li>g 需要被动调度时，会调用 mcall 方法切换至 g0，并调用 park_m 方法将 g 置为阻塞态，执行流程位于 runtime/proc.go 的 gopark 方法当中<ul><li>将当前 g 的状态由 running 改为 waiting</li><li>将 g 与 m 解绑</li><li>执行新一轮的调度 schedule</li></ul></li><li>当因被动调度陷入阻塞态的 g 需要被唤醒时，会由其他协程执行 goready 方法将 g 重新置为可执行的状态，方法位于 runtime/proc.go<ul><li>先将 g 的状态从阻塞态改为可执行的状态</li><li>调用 runqput 将当前 g 添加到唤醒者 p 的本地队列中，如果队列满了，会连带 g 一起将一半的元素转移到全局队列</li></ul></li></ul><h3 id="4-9-goexit0"><a href="#4-9-goexit0" class="headerlink" title="4.9 goexit0"></a>4.9 goexit0</h3><ul><li>当 g 执行完成时，会先执行 mcall 方法切换至 g0，然后调用 goexit0 方法<ul><li>将 g 状态置为 dead</li><li>解绑 g 和 m</li><li>开启新一轮的调度</li></ul></li></ul><h3 id="4-10-retake"><a href="#4-10-retake" class="headerlink" title="4.10 retake"></a>4.10 retake</h3><p>抢占调度的执行者不是 g0，而是一个全局的 monitor g，代码位于 runtime/proc.go 的 retake 方法中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retake</span><span class="params">(now <span class="type">int64</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    lock(&amp;allpLock)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(allp); i++ &#123;</span><br><span class="line">        _p_ := allp[i]</span><br><span class="line">        <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// This can happen if procresize has grown</span></span><br><span class="line">            <span class="comment">// allp but not yet created new Ps.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        pd := &amp;_p_.sysmontick</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> s == _Psyscall &#123;            </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">if</span> runqempty(_p_) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; <span class="number">0</span> &amp;&amp; pd.syscallwhen+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &gt; now &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            unlock(&amp;allpLock)</span><br><span class="line">            <span class="keyword">if</span> atomic.Cas(&amp;_p_.status, s, _Pidle) &#123;</span><br><span class="line">                n++</span><br><span class="line">                _p_.syscalltick++</span><br><span class="line">                handoffp(_p_)</span><br><span class="line">            &#125;</span><br><span class="line">            incidlelocked(<span class="number">1</span>)</span><br><span class="line">            lock(&amp;allpLock)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;allpLock)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">uint32</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>加锁后，遍历全局的 p 队列，寻找需要被抢占的目标</li><li>倘若某个 p 同时满足下述条件，则会进行抢占调度<ul><li>执行系统调用超过 10 ms</li><li>p 本地队列有等待执行的 g</li><li>或者当前没有空闲的 p 和 m</li></ul></li><li>抢占调度的步骤是，先将当前 p 的状态更新为 idle，然后步入 handoffp 方法中，判断是否需要为 p 寻找接管的 m（因为其原本绑定的 m 正在执行系统调用）</li><li>当以下条件满足其一时，则需要为 p 获取新的 m<ul><li>当前 p 本地队列还有待执行的 g</li><li>全局繁忙（没有空闲的 p 和 m，全局 g 队列为空）</li><li>需要处理网络 socket 读写请求</li></ul></li><li>获取 m 时，会先尝试获取已有的空闲的 m，若不存在，则会创建一个新的 m</li></ul><h3 id="4-11-reentersyscall-和-exitsyscall"><a href="#4-11-reentersyscall-和-exitsyscall" class="headerlink" title="4.11 reentersyscall 和 exitsyscall"></a>4.11 reentersyscall 和 exitsyscall</h3><p>在 m 需要执行系统调用前，会先执行位于 runtime/proc.go 的 reentersyscall 的方法</p><ul><li>此时执行权同样位于 m 的 g0 手中</li><li>保存当前 g 的执行环境</li><li>将 g 和 p 的状态更新为 syscall</li><li>解除 p 和 当前 m 之间的绑定，因为 m 即将进入系统调用而导致短暂不可用</li><li>将 p 添加到 当前 m 的 oldP 容器当中，后续 m 恢复后，会优先寻找旧的 p 重新建立绑定关系</li></ul><p>当 m 完成了内核态的系统调用之后，此时会步入位于 runtime/proc.go 的 exitsyscall 函数中，尝试寻找 p 重新开始运作</p><ul><li>方法执行之初，此时的执行权是普通 g.倘若此前设置的 oldp 仍然可用，则重新和 oldP 绑定，将当前 g 重新置为 running 状态，然后开始执行后续的用户函数</li><li>old 绑定失败，则调用 mcall 方法切换到 m 的 g0，并执行 exitsyscall0 方法</li><li>将 g 由系统调用状态切换为可运行态，并解绑 g 和 m 的关系</li><li>从全局 p 队列获取可用的 p，如果获取到了，则执行 g</li><li>如若无 p 可用，则将 g 添加到全局队列，当前 m 陷入沉睡. 直到被唤醒后才会继续发起调度.</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;gmp = goroutine + machine + processor&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="并发编程" scheme="https://stardustorz.github.io/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
</feed>
