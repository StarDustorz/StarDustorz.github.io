<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Draco&#39;s Blog</title>
  
  <subtitle>拨雪寻春 烧灯续昼</subtitle>
  <link href="https://stardustorz.github.io/atom.xml" rel="self"/>
  
  <link href="https://stardustorz.github.io/"/>
  <updated>2025-04-15T16:05:23.855Z</updated>
  <id>https://stardustorz.github.io/</id>
  
  <author>
    <name>draco</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://stardustorz.github.io/2025/04/16/LLM/Agent/"/>
    <id>https://stardustorz.github.io/2025/04/16/LLM/Agent/</id>
    <published>2025-04-15T16:05:23.855Z</published>
    <updated>2025-04-15T16:05:23.855Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://stardustorz.github.io/2025/04/16/LLM/RAG/"/>
    <id>https://stardustorz.github.io/2025/04/16/LLM/RAG/</id>
    <published>2025-04-15T16:05:18.937Z</published>
    <updated>2025-04-15T16:05:18.937Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://stardustorz.github.io/2025/04/16/LLM/Prompt%20Engineering/"/>
    <id>https://stardustorz.github.io/2025/04/16/LLM/Prompt%20Engineering/</id>
    <published>2025-04-15T16:04:42.367Z</published>
    <updated>2025-04-15T16:04:42.367Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://stardustorz.github.io/2023/10/09/Algorithm/%E8%B7%B3%E8%A1%A8/"/>
    <id>https://stardustorz.github.io/2023/10/09/Algorithm/%E8%B7%B3%E8%A1%A8/</id>
    <published>2023-10-09T15:19:16.000Z</published>
    <updated>2025-05-24T09:24:45.069Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">![图片](file:///Users/caotianlong/Documents/%E5%88%B7%E9%A2%98/%E7%83%AD%E9%97%A8%E5%AE%9E%E7%8E%B0/img/640-20230911011754301.png?lastModify=1694370430)</span><br><span class="line"></span><br><span class="line">## 1 核心性质</span><br><span class="line"></span><br><span class="line">- 跳表由多层索引结构组成</span><br><span class="line">- 每次节点个数接近于相邻下层节点数的一半</span><br><span class="line">- 对于一个 m 层存在的节点，在 1~m-1层中这个节点也一定存在</span><br><span class="line">- 为保证连贯性，跳表额外补充了本身不存储数据的头节点和尾节点，作为起点和终点</span><br><span class="line">- 头节点和尾节点的高度是动态扩缩的，其高度取决于当前跳表内数据节点的最大高度</span><br><span class="line">- 跳表的”跳“字体现在，在高层检索时，每跳过一个节点，实际上都过滤跳过了底层的大量数据，从而实现检索加速</span><br><span class="line">## 2 数据结构定义</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line"> // 跳表的数据结构 Skiplist  </span><br><span class="line"> type Skiplist struct &#123;  </span><br><span class="line">     head *node  </span><br><span class="line"> &#125;  </span><br><span class="line"> // 节点定义  </span><br><span class="line"> type node struct &#123;  </span><br><span class="line">     // 长度为当前节点的高度  </span><br><span class="line">     nexts    []*node  </span><br><span class="line">     key, val int  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="3-读流程"><a href="#3-读流程" class="headerlink" title="3 读流程"></a>3 读流程</h2><ul><li>以 head 节点作为起点</li><li>从当前跳表存在的最大高度出发</li><li>倘若右侧节点 key 值小于 target，则持续向右遍历</li><li>倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回</li><li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li><li>重复（3）-（5）步</li><li>倘若已经抵达第1层仍然找到不到 target，则返回 key 不存在的信息</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 根据 key 读取 val，第二个 bool flag 反映 key 在 skiplist 中是否存在  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Get(key <span class="type">int</span>) (<span class="type">int</span>, <span class="type">bool</span>) &#123;  </span><br><span class="line">     <span class="comment">// 根据 key 尝试检索对应的 node，如果 node 存在，则返回对应的 val  </span></span><br><span class="line">     <span class="keyword">if</span> _node := s.search(key); _node != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> _node.val, <span class="literal">true</span>  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">false</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 从跳表中检索 key 对应的 node  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> search(key <span class="type">int</span>) *node &#123;  </span><br><span class="line">     <span class="comment">// 每次检索从头部出发  </span></span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="comment">// 每次检索从最大高度出发，直到来到首层  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="comment">// 在每一层中持续向右遍历，直到下一个节点不存在或者 key 值大于等于 key  </span></span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; key &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 如果 key 值相等，则找到了目标直接返回  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key == key &#123;  </span><br><span class="line">             <span class="keyword">return</span> move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 当前层没找到目标，则层数减 1，继续向下  </span></span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">// 遍历完所有层数，都没有找到目标，返回 nil  </span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="4-写流程"><a href="#4-写流程" class="headerlink" title="4 写流程"></a>4 写流程</h2><ul><li>首先基于读流程检索出 key 对应的节点是否存在，倘若存在，则对值进行更新并直接返回</li><li>随机出新插入节点的高度；倘若新插入节点的高度大于当前跳表的最大高度，则需要对起点和终点的高度进行扩容</li><li>以 head 节点作为起点，从当前跳表存在的最大高度出发</li><li>倘若右侧节点 key 值小于 target，则持续向右遍历</li><li>倘若右侧节点为终点（nil）或者 key 值大于 target，则在该空隙插入新节点，并降低高度进入下一层</li><li>重复（4）-（5）步</li><li>倘若已经进入第 1 层，插入新节点后即可返回<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> (<span class="string">&quot;math/rand&quot;</span>)  </span><br><span class="line"> roll 骰子，决定一个待插入的新节点在 skiplist 中最高层对应的 index  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> roll() <span class="type">int</span> &#123;  </span><br><span class="line">     <span class="keyword">var</span> level <span class="type">int</span>  </span><br><span class="line">     <span class="comment">// 每次投出 1，则层数加 1  </span></span><br><span class="line">     <span class="keyword">for</span> rand.Int() &gt; <span class="number">0</span> &#123;  </span><br><span class="line">         level++  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> level  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 将 key-val 对加入 skiplist  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Put(key, val <span class="type">int</span>) &#123;  </span><br><span class="line">     <span class="comment">// 假如 kv对已存在，则直接对值进行更新并返回  </span></span><br><span class="line">     <span class="keyword">if</span> _node := s.search(key); _node != <span class="literal">nil</span> &#123;  </span><br><span class="line">         _node.val = val  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// roll 出新节点的高度  </span></span><br><span class="line">     level := s.roll()  </span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 新节点高度超出跳表最大高度，则需要对高度进行补齐  </span></span><br><span class="line">     <span class="keyword">for</span> <span class="built_in">len</span>(s.head.nexts)<span class="number">-1</span> &lt; level &#123;  </span><br><span class="line">         s.head.nexts = <span class="built_in">append</span>(s.head.nexts, <span class="literal">nil</span>)  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 创建出新的节点  </span></span><br><span class="line">     newNode := node&#123;  </span><br><span class="line">         key:   key,  </span><br><span class="line">         val:   val,  </span><br><span class="line">         nexts: <span class="built_in">make</span>([]*node, level+<span class="number">1</span>),  </span><br><span class="line">     &#125;  </span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 从头节点的最高层出发  </span></span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="keyword">for</span> level := level; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="comment">// 向右遍历，直到右侧节点不存在或者 key 值大于 key  </span></span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; key &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 调整指针关系，完成新节点的插入  </span></span><br><span class="line">         newNode.nexts[level] = move.nexts[level]  </span><br><span class="line">         move.nexts[level] = &amp;newNode  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure></li></ul><h2 id="删流程"><a href="#删流程" class="headerlink" title="删流程"></a>删流程</h2><ul><li>以 head 节点作为起点，从当前跳表存在的最大高度出发</li><li>倘若右侧节点 key 值小于 target，则持续向右遍历</li><li>倘若右侧节点为终点（nil）或者 key 值大于 target，则在该空隙插入新节点，并降低高度进入下一层</li><li>倘若右侧节点 key 值等于 target，则代表找到目标</li><li>找到目标值后，沿当前节点层层向下，依次将每层中的目标节点删除</li><li>倘若已经进入第 1 层仍然没有找到节点，说明节点不存在，删除失败</li><li><p>倘若删除成功，需要尝试对跳表的整体高度进行缩容，即需要对高度递减，直到确定最大高度对应的层数上至少存在一个有效的数据节点为止</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 key 从跳表中删除对应的节点  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Del(key <span class="type">int</span>) &#123;  </span><br><span class="line">     <span class="comment">// 如果 kv 对不存在，则无需删除直接返回  </span></span><br><span class="line">     <span class="keyword">if</span> _node := s.search(key); _node == <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 从头节点的最高层出发      </span></span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="comment">// 向右遍历，直到右侧节点不存在或者 key 值大于等于 key  </span></span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; key &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">           </span><br><span class="line">         <span class="comment">// 右侧节点不存在或者 key 值大于 target，则直接跳过  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] == <span class="literal">nil</span> || move.nexts[level].key &gt; key&#123;  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">         &#125;      </span><br><span class="line">         <span class="comment">// 走到此处意味着右侧节点的 key 值必然等于 key，则调整指针引用  </span></span><br><span class="line">         move.nexts[level] = move.nexts[level].nexts[level]  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 对跳表的最大高度进行更新  </span></span><br><span class="line">     <span class="keyword">var</span> dif <span class="type">int</span>  </span><br><span class="line">     <span class="comment">// 倘若某一层已经不存在数据节点，高度需要递减  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt; <span class="number">0</span> &amp;&amp; s.head.nexts[level] == <span class="literal">nil</span>; level-- &#123;  </span><br><span class="line">         dif++  </span><br><span class="line">     &#125;  </span><br><span class="line">     s.head.nexts = s.head.nexts[:<span class="built_in">len</span>(s.head.nexts)-dif]  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="5-RANGE-流程"><a href="#5-RANGE-流程" class="headerlink" title="5 RANGE 流程"></a>5 RANGE 流程</h2></li><li>以 head 节点作为起点</li><li>从当前跳表存在的最大高度出发</li><li>倘若右侧节点 key 值小于 target，则持续向右遍历</li><li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li><li>倘若右侧节点 key 值等于 target，则代表找到目标，直接沿该节点向下来到第1层</li><li><p>重复（3）-（5）步，直到来到第1层，接下来从首个大于等于 target 的节点出发，向右依次遍历，直到取满 range 区间的数据后返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到 skiplist 当中 ≥ start，且 ≤ end 的 kv 对  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Range(start, end <span class="type">int</span>) [][<span class="number">2</span>]<span class="type">int</span> &#123;  </span><br><span class="line">     <span class="comment">// 首先通过 ceiling 方法，找到 skiplist 中 key 值大于等于 start 且最接近于 start 的节点 ceilNode  </span></span><br><span class="line">     ceilNode := s.ceiling(start)  </span><br><span class="line">     <span class="comment">// 如果不存在，直接返回  </span></span><br><span class="line">     <span class="keyword">if</span> ceilNode == <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> [][<span class="number">2</span>]<span class="type">int</span>&#123;&#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 从 ceilNode 首层出发向右遍历，把所有位于 [start,end] 区间内的节点统统返回  </span></span><br><span class="line">     <span class="keyword">var</span> res [][<span class="number">2</span>]<span class="type">int</span>  </span><br><span class="line">     <span class="keyword">for</span> move := ceilNode; move != <span class="literal">nil</span> &amp;&amp; move.key &lt;= end; move = move.nexts[<span class="number">0</span>] &#123;  </span><br><span class="line">         res = <span class="built_in">append</span>(res, [<span class="number">2</span>]<span class="type">int</span>&#123;move.key, move.val&#125;)  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> res  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 找到 key 值大于等于 target 且 key 值最接近于 target 的节点  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> ceiling(target <span class="type">int</span>) *node &#123;  </span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="comment">// 自上而下，找到 key 值小于 target 且最接近 target 的 kv 对  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; target &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 如果 key 值等于 targe 的 kv 对存在，则直接返回  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key == target &#123;  </span><br><span class="line">             <span class="keyword">return</span> move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">// 此时 move 已经对应于在首层 key 值小于 key 且最接近于 key 的节点，其右侧第一个节点即为所寻找的目标节点  </span></span><br><span class="line">     <span class="keyword">return</span> move.nexts[<span class="number">0</span>]  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="CEILING-流程"><a href="#CEILING-流程" class="headerlink" title="CEILING 流程"></a>CEILING 流程</h2><ul><li>以 head 节点作为起点</li><li>从当前跳表存在的最大高度出发</li><li>倘若右侧节点 key 值小于 target，则持续向右遍历</li><li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li><li>倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回</li><li>重复（3）-（5）步，直到找到 key 值等于 target 的节点或者来到第1层，接下来获取到首个大于等于 target 的节点并返回</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 找到 skiplist 中，key 值大于等于 target 且最接近于 target 的 key-value 对  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Ceiling(target <span class="type">int</span>) ([<span class="number">2</span>]<span class="type">int</span>, <span class="type">bool</span>) &#123;  </span><br><span class="line">     <span class="keyword">if</span> ceilNode := s.ceiling(target); ceilNode != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;ceilNode.key, ceilNode.val&#125;, <span class="literal">true</span>  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;&#125;, <span class="literal">false</span>  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure><p> ​</p><h2 id="6-FLOOR-流程"><a href="#6-FLOOR-流程" class="headerlink" title="6 FLOOR 流程"></a>6 FLOOR 流程</h2><ul><li>以 head 节点作为起点</li><li>从当前跳表存在的最大高度出发</li><li>倘若右侧节点 key 值小于 target，则持续向右遍历</li><li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li><li>倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回</li><li><p>重复（3）-（5）步，直到找到 key 值等于 target 的节点或者来到第1层，接下来获取到首个小于等于 target 的节点并返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到 skiplist 中，key 值小于等于 target 且最接近于 target 的 key-value 对  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Floor(target <span class="type">int</span>) ([<span class="number">2</span>]<span class="type">int</span>, <span class="type">bool</span>) &#123;  </span><br><span class="line">     <span class="comment">// 引用 floor 方法，取 floorNode 值进行返回  </span></span><br><span class="line">     <span class="keyword">if</span> floorNode := s.floor(target); floorNode != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;floorNode.key, floorNode.val&#125;, <span class="literal">true</span>  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;&#125;, <span class="literal">false</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 找到 key 值小于等于 target 且 key 值最接近于 target 的节点  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> floor(target <span class="type">int</span>) *node &#123;  </span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="comment">// 自上而下，找到 key 值小于 target 且最接近 target 的 kv 对  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; target &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 如果 key 值等于 targe 的 kv对存在，则直接返回  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key == target &#123;  </span><br><span class="line">             <span class="keyword">return</span> move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// move 是首层中 key 值小于 target 且最接近 target 的节点，直接返回 move 即可  </span></span><br><span class="line">     <span class="keyword">return</span> move  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure><p>​<br>​</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://stardustorz.github.io/2023/10/09/System-Design/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%BD%92%E7%BA%B3/"/>
    <id>https://stardustorz.github.io/2023/10/09/System-Design/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%BD%92%E7%BA%B3/</id>
    <published>2023-10-09T15:19:16.000Z</published>
    <updated>2025-05-24T09:24:45.092Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现令牌桶"><a href="#实现令牌桶" class="headerlink" title="实现令牌桶"></a>实现令牌桶</h2><p>“HMSET” 是 Redis 的哈希表命令，用于设置哈希表中的多个字段及其对应的值。<br>通过将获取锁封装到lua脚本中，提交给redis进行eval和evalsha操作来完成lua脚本的执行，由于lua脚本在redis中天然的原子性，我们的需求能够比较好的满足，问题是将业务逻辑封装在lua中，对于开发人员自身的能力和调试存在一定的问题。<br>限流器在每次请求令牌和放入令牌操作中，存在一个协同的问题，即获取令牌操作要尽可能保证原子性，否则无法保证限流器是否能正常工作。在RateLimiter的实现中使用了mutex作为互斥锁来保证操作的原子性，那么在redis中就需要一个类似于事务的机制来保证获取令牌中多重操作的原子性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">-- 返回码 1:操作成功 0:未配置 -1: 获取失败 -2:修改错误，建议重新初始化 -500:不支持的操作</span><br><span class="line">-- redis hashmap 中存放的内容:</span><br><span class="line">-- last_mill_second 上次放入令牌或者初始化的时间</span><br><span class="line">-- stored_permits 目前令牌桶中的令牌数量</span><br><span class="line">-- max_permits 令牌桶容量</span><br><span class="line">-- interval 放令牌间隔</span><br><span class="line">-- app 一个标志位，表示对于当前key有没有限流存在</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> SUCCESS = 1</span><br><span class="line"><span class="built_in">local</span> NO_LIMIT = 0</span><br><span class="line"><span class="built_in">local</span> ACQUIRE_FAIL = -1</span><br><span class="line"><span class="built_in">local</span> MODIFY_ERROR = -2</span><br><span class="line"><span class="built_in">local</span> UNSUPPORT_METHOD = -500</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> ratelimit_info = redis.pcall(<span class="string">&quot;HMGET&quot;</span>,KEYS[1], <span class="string">&quot;last_mill_second&quot;</span>, <span class="string">&quot;stored_permits&quot;</span>, <span class="string">&quot;max_permits&quot;</span>, <span class="string">&quot;interval&quot;</span>, <span class="string">&quot;app&quot;</span>)</span><br><span class="line"><span class="built_in">local</span> last_mill_second = ratelimit_info[1]</span><br><span class="line"><span class="built_in">local</span> stored_permits = tonumber(ratelimit_info[2])</span><br><span class="line"><span class="built_in">local</span> max_permits = tonumber(ratelimit_info[3])</span><br><span class="line"><span class="built_in">local</span> interval = tonumber(ratelimit_info[4])</span><br><span class="line"><span class="built_in">local</span> app = ratelimit_info[5]</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> method = ARGV[1]</span><br><span class="line"></span><br><span class="line">--获取当前毫秒</span><br><span class="line">--考虑主从策略和脚本回放机制，这个time由客户端获取传入</span><br><span class="line">--<span class="built_in">local</span> curr_time_arr = redis.call(<span class="string">&#x27;TIME&#x27;</span>)</span><br><span class="line">--<span class="built_in">local</span> curr_timestamp = curr_time_arr[1] * 1000 + curr_time_arr[2]/1000</span><br><span class="line"><span class="built_in">local</span> curr_timestamp = tonumber(ARGV[2])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 当前方法为初始化</span><br><span class="line"><span class="keyword">if</span> method == <span class="string">&#x27;init&#x27;</span> <span class="keyword">then</span></span><br><span class="line">    --如果app不为null说明已经初始化过，不要重复初始化</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>(app) ~=<span class="string">&#x27;boolean&#x27;</span> and app ~=nil) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> SUCCESS</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    redis.pcall(<span class="string">&quot;HMSET&quot;</span>, KEYS[1],</span><br><span class="line">        <span class="string">&quot;last_mill_second&quot;</span>, curr_timestamp,</span><br><span class="line">        <span class="string">&quot;stored_permits&quot;</span>, ARGV[3],</span><br><span class="line">        <span class="string">&quot;max_permits&quot;</span>, ARGV[4],</span><br><span class="line">        <span class="string">&quot;interval&quot;</span>, ARGV[5],</span><br><span class="line">        <span class="string">&quot;app&quot;</span>, ARGV[6])</span><br><span class="line">    --始终返回成功</span><br><span class="line">    <span class="built_in">return</span> SUCCESS</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 当前方法为修改配置</span><br><span class="line"><span class="keyword">if</span> method == <span class="string">&quot;modify&quot;</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>(app) ==<span class="string">&#x27;boolean&#x27;</span> or app ==nil) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> MODIFY_ERROR</span><br><span class="line">    end</span><br><span class="line">    --只能修改max_permits和interval</span><br><span class="line">    redis.pcall(<span class="string">&quot;HMSET&quot;</span>, KEYS[1],</span><br><span class="line">        <span class="string">&quot;max_permits&quot;</span>, ARGV[3],</span><br><span class="line">        <span class="string">&quot;interval&quot;</span>, ARGV[4])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> SUCCESS</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 当前方法为删除</span><br><span class="line"><span class="keyword">if</span> method == <span class="string">&quot;delete&quot;</span> <span class="keyword">then</span></span><br><span class="line">    --已经清除完毕</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>(app) ==<span class="string">&#x27;boolean&#x27;</span> or app ==nil) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> SUCCESS</span><br><span class="line">    end</span><br><span class="line">    redis.pcall(<span class="string">&quot;DEL&quot;</span>, KEYS[1])</span><br><span class="line">    <span class="built_in">return</span> SUCCESS</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 尝试获取permits</span><br><span class="line"><span class="keyword">if</span> method == <span class="string">&quot;acquire&quot;</span> <span class="keyword">then</span></span><br><span class="line">    -- 如果app为null说明没有对这个进行任何配置，返回0代表不限流</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>(app) ==<span class="string">&#x27;boolean&#x27;</span> or app ==nil) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> NO_LIMIT</span><br><span class="line">    end</span><br><span class="line">    --需要获取令牌数量</span><br><span class="line">    <span class="built_in">local</span> acquire_permits = tonumber(ARGV[3])</span><br><span class="line">    --计算上一次放令牌到现在的时间间隔中，一共应该放入多少令牌</span><br><span class="line">    <span class="built_in">local</span> reserve_permits = math.max(0, math.floor((curr_timestamp - last_mill_second) / interval))</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">local</span> new_permits = math.min(max_permits, stored_permits + reserve_permits)</span><br><span class="line">    <span class="built_in">local</span> result = ACQUIRE_FAIL</span><br><span class="line">    --如果桶中令牌数量够则放行</span><br><span class="line">    <span class="keyword">if</span> new_permits &gt;= acquire_permits <span class="keyword">then</span></span><br><span class="line">        result = SUCCESS</span><br><span class="line">        new_permits = new_permits - acquire_permits</span><br><span class="line">    end</span><br><span class="line">    --更新当前桶中的令牌数量 </span><br><span class="line">    redis.pcall(<span class="string">&quot;HSET&quot;</span>, KEYS[1], <span class="string">&quot;stored_permits&quot;</span>, new_permits)</span><br><span class="line">    --如果这次有放入令牌，则更新时间</span><br><span class="line">    <span class="keyword">if</span> reserve_permits &gt; 0 <span class="keyword">then</span></span><br><span class="line">        redis.pcall(<span class="string">&quot;HSET&quot;</span>, KEYS[1], <span class="string">&quot;last_mill_second&quot;</span>, curr_timestamp)</span><br><span class="line">    end</span><br><span class="line">    <span class="built_in">return</span> result</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> UNSUPPORT_METHOD</span><br></pre></td></tr></table></figure><h2 id="实现-set"><a href="#实现-set" class="headerlink" title="实现 set"></a>实现 set</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 是一个使用 map 实现的集合</span></span><br><span class="line"><span class="keyword">type</span> Set <span class="keyword">struct</span> &#123;</span><br><span class="line">    m <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSet 创建一个新的空集合</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSet</span><span class="params">()</span></span> *Set &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Set&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 向集合中添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Add(value <span class="type">string</span>) &#123;</span><br><span class="line">    s.m[value] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove 从集合中删除一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Remove(value <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="built_in">delete</span>(s.m, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Contains 检查集合中是否包含某个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Contains(value <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    _, ok := s.m[value]</span><br><span class="line">    <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len 返回集合的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s.m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear 清空集合</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Clear() &#123;</span><br><span class="line">    s.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Values 返回集合中的所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Values() []<span class="type">string</span> &#123;</span><br><span class="line">    values := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(s.m))</span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> s.m &#123;</span><br><span class="line">        values = <span class="built_in">append</span>(values, k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    set := NewSet()</span><br><span class="line">    set.Add(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    set.Add(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    set.Add(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;Set contains &#x27;a&#x27;:&quot;</span>, set.Contains(<span class="string">&quot;a&quot;</span>)) <span class="comment">// true</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Set contains &#x27;d&#x27;:&quot;</span>, set.Contains(<span class="string">&quot;d&quot;</span>)) <span class="comment">// false</span></span><br><span class="line">    </span><br><span class="line">    set.Remove(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Set contains &#x27;a&#x27;:&quot;</span>, set.Contains(<span class="string">&quot;a&quot;</span>)) <span class="comment">// false</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;Set length:&quot;</span>, set.Len()) <span class="comment">// 2</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;Set values:&quot;</span>, set.Values()) <span class="comment">// [b c]</span></span><br><span class="line">    </span><br><span class="line">    set.Clear()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Set length after clear:&quot;</span>, set.Len()) <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现协程交替打印"><a href="#实现协程交替打印" class="headerlink" title="实现协程交替打印"></a>实现协程交替打印</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> countNum = <span class="number">100</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//3个函数分别打印cat、dog、fish，要求每个函数都要起一个goroutine，按照cat、dog、fish顺序打印在屏幕上10次</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"> </span><br><span class="line">    dogCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(dogCh)</span><br><span class="line">    catCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(catCh)</span><br><span class="line">    fishCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(fishCh)</span><br><span class="line"> </span><br><span class="line">    wg.Add(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">go</span> catPrint(&amp;wg, &amp;catCh, &amp;dogCh)</span><br><span class="line">    <span class="keyword">go</span> dogPrint(&amp;wg, &amp;dogCh, &amp;fishCh)</span><br><span class="line">    <span class="keyword">go</span> fishPrint(&amp;wg, &amp;fishCh, &amp;catCh)</span><br><span class="line"> </span><br><span class="line">    catCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">catPrint</span><span class="params">(wg *sync.WaitGroup, catCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, dogCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> count &gt;= countNum &#123;</span><br><span class="line">            wg.Done()</span><br><span class="line">            <span class="comment">//fmt.Println(&quot;cat quit&quot;)</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        &lt;-*catCh</span><br><span class="line">        fmt.Println(<span class="string">&quot;cat&quot;</span>, count+<span class="number">1</span>)</span><br><span class="line">        count++</span><br><span class="line">        *dogCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dogPrint</span><span class="params">(wg *sync.WaitGroup, dogCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, fishCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> count &gt;= countNum &#123;</span><br><span class="line">            wg.Done()</span><br><span class="line">            <span class="comment">//fmt.Println(&quot;dog quit&quot;)</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        &lt;-*dogCh</span><br><span class="line">        fmt.Println(<span class="string">&quot;dog&quot;</span>)</span><br><span class="line">        count++</span><br><span class="line">        *fishCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fishPrint</span><span class="params">(wg *sync.WaitGroup, dogCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, catCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> count &gt;= countNum &#123;</span><br><span class="line">            wg.Done()</span><br><span class="line">            <span class="comment">//fmt.Println(&quot;fish quit&quot;)</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        &lt;-*dogCh</span><br><span class="line">        fmt.Println(<span class="string">&quot;fish&quot;</span>)</span><br><span class="line">        count++</span><br><span class="line">        *catCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;实现令牌桶&quot;&gt;&lt;a href=&quot;#实现令牌桶&quot; class=&quot;headerlink&quot; title=&quot;实现令牌桶&quot;&gt;&lt;/a&gt;实现令牌桶&lt;/h2&gt;&lt;p&gt;“HMSET” 是 Redis 的哈希表命令，用于设置哈希表中的多个字段及其对应的值。&lt;br&gt;通过将获取锁封装到lu</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://stardustorz.github.io/2023/10/09/System-Design/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
    <id>https://stardustorz.github.io/2023/10/09/System-Design/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</id>
    <published>2023-10-09T15:19:16.000Z</published>
    <updated>2025-04-29T14:51:09.812Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://stardustorz.github.io/2023/09/11/System-Design/Raft/"/>
    <id>https://stardustorz.github.io/2023/09/11/System-Design/Raft/</id>
    <published>2023-09-10T16:48:57.000Z</published>
    <updated>2025-05-24T09:24:45.085Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h2><div class="table-container"><table><thead><tr><th><strong>中文术语</strong></th><th><strong>英文术语</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>领导者</td><td>leader</td><td>节点的三种角色之一. 集群的首脑，负责发起”提议“、”提交“被多数派认可的决断.</td></tr><tr><td>跟随者</td><td>follower</td><td>节点的三种角色之一. 需要对 leader 的 ”提议“ 、”提交“和 candidate 的 ”竞选“ 进行响应.</td></tr><tr><td>候选人</td><td>candidate</td><td>节点的三种角色之一. 是一种处于竞选流程中的临时状态，根据多数派投票的结果会切为 leader 或 follower 的稳定态.</td></tr><tr><td>最终一致性</td><td>finnal consistency</td><td>中强一致性. 对于写请求，服务端保证最终一定能提供出正确的结果，但需要同步时间. 同步期间，可能被读到不一致的老数据.</td></tr><tr><td>即时一次性</td><td>immediate consistency</td><td>强一致性. 服务端要求做到写入立即可读.</td></tr><tr><td>预写日志</td><td>write ahead log</td><td>记录写请求明细的日志.（单指 raft 算法下狭义的预写日志）</td></tr><tr><td>状态机</td><td>state machine</td><td>节点内存储数据的介质.</td></tr><tr><td>提议</td><td>proposal</td><td>两阶段提交的第一个阶段. 指的是 leader 向所有节点发起日志同步请求的过程.</td></tr><tr><td>提交</td><td>commit</td><td>两阶段提交的第二个阶段. 指的是 leader 认可一笔写请求已经被系统采纳的动作.</td></tr><tr><td>应用</td><td>apply</td><td>指的是将预写日志记录内记录的写操作应用到状态机的过程.</td></tr><tr><td>任期</td><td>term</td><td>任期是用于标识 leader 更迭的概念. 每个任期内至多只允许有一个 leader.</td></tr><tr><td>日志索引</td><td>index</td><td>日志在预写日志数组中的位置.</td></tr><tr><td>脑裂</td><td>brain split</td><td>同一任期内，集群出现两个 leader，导致秩序崩盘.</td></tr></tbody></table></div><h3 id="1-1-多数派原则"><a href="#1-1-多数派原则" class="headerlink" title="1.1 多数派原则"></a>1.1 多数派原则</h3><blockquote><p>系统的决断无需全员参与,多数派达成的共识即可视为整个系统的答复</p><ul><li>以集群存在 5 个节点为例，多数派则需要集齐 3 个及 3 个以上节点，至多可以允许 2 个节点存在开小差背离主流的情况. 同理，倘若集群 6 个节点，则多数派需要集齐 4 个及 4 个以上节点，因此同样至多允许 2 个节点开小差. 综上，这是奉行多数派原则的集群通常将节点个数设置为奇数的原因之一.</li><li>多数派原则是提高分布式系统可用性 A 的关键. 对于整个系统而言，执行一项操作要求全员共同响应以实现强 C 的保证是过于苛刻的，因为我们无法保证所有节点都能健康运作，这种底线思维是研发人员所必须具备的素养. 但是倘若退而求其次，只要多数派达成共识即可正常决断和响应，这样下限就提高很多了. 由全员响应进化为多数派共识，这将把一种底线思维下的随机性问题进化为一个数学期望问题.</li></ul></blockquote><h3 id="1-2-一主多从、读写分离"><a href="#1-2-一主多从、读写分离" class="headerlink" title="1.2 一主多从、读写分离"></a>1.2 一主多从、读写分离</h3><ul><li>raft 算法下系统中的节点分为领导者 leader 和跟随者 follower 两类角色;leader拥有更广阔的视野，需要总览全局，领导一些日常事务的推进；follower 职责相对简单但同样重要，因为这是一个基于多数派原则运作的民众团体，所有角色只要拧成一股绳，聚成了多数派，就能代表整个系统进行决断，甚至包括推翻 leader.</li><li>读操作可以由集群的任意节点提供服务；写操作统一需要由 leader 收口处理，并向 follower 同步. 倘若 follower 率先收到了来自客户端的写请求，也需要转发给 leader 进行处理.</li></ul><h3 id="1-3-状态机与预写日志"><a href="#1-3-状态机与预写日志" class="headerlink" title="1.3  状态机与预写日志"></a>1.3  状态机与预写日志</h3><ul><li>状态机 （state machine）是节点实际存储数据的容器,写请求的最后一步是将结果写入状态机，而读请求也需要从状态机中获取数据进行响应.</li><li>预写日志（write ahead log，简称 wal）是通过日志的方式记录下每一笔写请求的明细（例如 set x = 3 这样一笔记录），使得变更历史有迹可循. 在 raft 算法中，写请求会先组织成预写日志的形式添加到日志数组中，当一个日志（写请求）达到集群多数派的认可后，才能够被提交，将变更应用到状态机当中.<h3 id="1-4-两阶段提交"><a href="#1-4-两阶段提交" class="headerlink" title="1.4  两阶段提交"></a>1.4  两阶段提交</h3>（1）leader 接收到来自客户端的一笔写请求；<br>（2）leader 将写请求添加到本地的预写日志中，并向集群中其他节点广播同步这笔写请求. 这个过程可以称之为“提议”（proposal）；<br>（3）集群中各节点接收到同步请求后，会一套检验机制判断是否能执行同步（添加到预写日志），校验机制这里不细述，留待 4.1 小节细说；<br>（4）倘若集群总计半数以上的节点（包括 leader 自身）都将这笔请求添加预写日志，并给予了 leader 肯定的答复（ack），那么 leader 此时会“提交”这个请求，并给予客户端写请求已成功处理的响应；<br>（5）其他节点在随后的时段中，会通过与 leader 的交互（心跳或其他同步数据的请求）感知到这个“提交”动作，最终也在预写日志中提交这笔请求；<br>（6）被提交的预写日志具备了被应用到状态机的资格. 但应用的时机取决于实现方式，倘若只追求最终一致性，可以选择异步应用；倘若追求立即一致性，则会要求 leader 先应用到状态机，才能给予客户端 ack.<h3 id="1-5-Leader选举"><a href="#1-5-Leader选举" class="headerlink" title="1.5  Leader选举"></a>1.5  Leader选举</h3></li><li>leader 需要定期向 follower 发送心跳，证明自己仍然健在. 与之对应的，follower 会建立一个心跳检测定时器，当超过指定时长未收到 leader 的心跳，则认为 leader 已死，会切换成候选人（candidate）发起竞选，尝试补位成为新的 leader.</li><li>follower 成为 candidate 后,会广播向所有节点拉票，当投赞同票的节点数（包括candidate 本身）达到多数派的时候，该 candidate 会胜任，成为新的 leader.</li></ul><h3 id="1-6-任期与日志索引"><a href="#1-6-任期与日志索引" class="headerlink" title="1.6  任期与日志索引"></a>1.6  任期与日志索引</h3><ul><li>每当一个 candidate 发起一轮竞选时，会将当前 term 在旧任期的基础上加1，倘若胜任成为新的 leader，这就将成为自己的“国号”.</li><li>值得一提的是，不是每个 term 都有 leader，因为可能在 candidate 未胜出的前提下，term 又进一步进行了累加，从而实现朝代的跨越.</li><li>但能够保证的是，<code>每个 term 至多只会有一个 leader</code></li><li>节点中的预写日志存放在一个数组中，每则日志在数组中的位置称之为索引 index.</li><li>于是，每一则预写日志会有两个核心的标识属性：<ul><li>term：标志了这则日志是哪个任期的 leader 在位时同步写入的；</li><li>index：标志了这则日志在预写日志数组的位置.</li></ul></li><li>通过 {term , index} 二元组可以组成一个全局唯一键，定位到一则日志，并且能够保证位于不同节点中日志，只要其 term 和 index 均相同，其内容一定完全一致</li></ul><h2 id="2-角色流转"><a href="#2-角色流转" class="headerlink" title="2. 角色流转"></a>2. 角色流转</h2><h3 id="2-1-角色定义及切换"><a href="#2-1-角色定义及切换" class="headerlink" title="2.1 角色定义及切换"></a>2.1 角色定义及切换</h3><ul><li><code>leader -&gt; follower</code><ul><li>倘若 leader 发现当前系统中出现了更大的任期，则会进行“禅让”，主动退位成 follower.</li><li>这里 leader 发现更大任期的方式包括：I 向 follower 提交日志同步请求时,从 follower 的响应参数中获得; II 收到了来自新任 leader 的心跳或者同步日志请求；III 收到了任期更大的 candidate 的拉票请求.</li></ul></li><li><code>follower -&gt; candidate</code><ul><li>leader 需要定期向 follower 发送心跳，告知自己仍健在的消息.</li><li>倘若 follower 超过一定时长没收到 leader 心跳时，会将状态切换为 candidate ，在当前任期的基础上加 1 作为竞选任期，发起竞选尝试补位.</li></ul></li><li><code>candidate -&gt; follower</code><ul><li>candidate 参与竞选过程中，出现以下两种情形时会退回 follower：<ul><li>多数派投了反对票；</li><li>竞选期间，收到了任期大于等于自身竞选任期的 leader 传来的请求.</li></ul></li></ul></li><li><code>candidate -&gt; leader</code><ul><li>candidate 竞选时，倘若多数派投了赞同票，则切换为 leader.</li></ul></li><li><code>candidate -&gt; candidate</code><ul><li>candidate 的竞选流程有一个时间阈值. 倘若超时仍未形成有效结论（多数派赞同或拒绝），则会维持 candidate 身份，将竞选任期加1，发起新一轮竞选.<h3 id="2-2-领导者"><a href="#2-2-领导者" class="headerlink" title="2.2 领导者"></a>2.2 领导者</h3>领导者是写请求的统一入口，在接收到来自客户端的写请求时，会开启“两阶段提交”的流程：</li></ul></li><li>广播 proposal，向所有节点同步这一请求；</li><li>当请求得到多数派的赞同后，才会提交这一请求.</li><li>leader 还需要周期性地向集群中所有节点发送自己的心跳，告知自己的健康状况，用途包括：</li><li>让 follower 重置心跳检测定时器，避免其切换成 candidate 发起竞选；</li><li>在心跳请求中携带上 leader 最新已提交日志的标识 id（term + index），推动 follower 更新日志提交进度.<h3 id="2-3-跟随者"><a href="#2-3-跟随者" class="headerlink" title="2.3 跟随者"></a>2.3 跟随者</h3></li><li>负责同步 leader 传来的写请求，此时也有一个参与民主反馈的过程，倘若同步成功，会给予 leader 正向反馈，当 leader 的同步请求收到半数以上的认可时，会提交日志；</li><li>通过接收 leader 心跳的方式，获取到携带的 commitIndex 信息，及时完成已被多数派认可的预写日志的提交，以推进其写入状态机的进度. 这一项相当于做到了数据的备份，也被读请求最终一致性提供了保证;</li><li>负责为参与竞选 candidate 的投票</li><li>通过心跳检测定时器时时关注 leader 的健康状态，当超时未收到心跳时，会切换为 candidate 发起竞选.<h3 id="2-4-候选人"><a href="#2-4-候选人" class="headerlink" title="2.4 候选人"></a>2.4 候选人</h3></li><li>倘若 follower 切为 candidate，会将当前任期加1，作为竞选任期；</li><li>会将自身的一票投给自己；</li><li>广播向所有节点拉票；</li><li>倘若拉票请求超时前，得到多数派认可，则上位为 leader；</li><li>倘若拉票请求超时前，遭到多数派拒绝，则老实退回 follower；</li><li>倘若拉票请求超时前，收到了任期大于等于自身竞选任期的 leader 的请求，则老实退回 follower；</li><li>倘若拉票请求超时，则竞选任期加 1，发起新一轮竞选拉票请求.</li></ul><h2 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3. 常见问题"></a>3. 常见问题</h2><h3 id="3-1-为什么能保证一个任期内至多只有一个领导者？"><a href="#3-1-为什么能保证一个任期内至多只有一个领导者？" class="headerlink" title="3.1 为什么能保证一个任期内至多只有一个领导者？"></a>3.1 为什么能保证一个任期内至多只有一个领导者？</h3><p>可以，通过选举的机制可以保证.</p><ul><li>首先，candidate 竞选前会自增 term，因此 term 在总体上为单调递增趋势；</li><li>其次，在选举机制上，一个 term 内，一个 follower 只有一票，因此只能投票给一个 candidate；</li><li>最后，基于多数派原则，一个 candidate 只有拿到半数以上的赞同票才能当选 leader.</li><li>因此，同一个 term 内，不可能出现有两个 candidate 同时获得半数以上的赞同票，因此一个 term 至多只有一个 leader.<h3 id="3-2-为什么能保证通过任期和索引相同的日志内容一定相同？"><a href="#3-2-为什么能保证通过任期和索引相同的日志内容一定相同？" class="headerlink" title="3.2 为什么能保证通过任期和索引相同的日志内容一定相同？"></a>3.2 为什么能保证通过任期和索引相同的日志内容一定相同？</h3></li><li>首先，预写日志具有 append-only 的性质，只作追加，不存在更新和删除操作；</li><li>其次，同一个 term 只有一个 leader；</li><li>因此，在 term 相同的情况下，所有节点在同一个 index 上的日志都会与 term 内 leader 对应 index 位置的日志保持一致；</li><li>综上，term 和 index 共同组成了一个全局唯一标识键. 只要term 和 index 均相同，日志内容一定相同<h3 id="3-3-关于选举机制方面，如何解决选票瓜分引发的问题？"><a href="#3-3-关于选举机制方面，如何解决选票瓜分引发的问题？" class="headerlink" title="3.3 关于选举机制方面，如何解决选票瓜分引发的问题？"></a>3.3 关于选举机制方面，如何解决选票瓜分引发的问题？</h3></li><li>每个节点在心跳超时阈值和竞选超时阈值上添加一个随机扰动值，通过这一扰动，避免多个节点在进入完全相同的竞选节奏. 于是进入 candidate 状态的节点有了先后之分，胜负自然就可见分晓.<h3 id="3-4-为什么新任-leader-一定拥有旧-leader-已提交的日志？"><a href="#3-4-为什么新任-leader-一定拥有旧-leader-已提交的日志？" class="headerlink" title="3.4 为什么新任 leader 一定拥有旧 leader 已提交的日志？"></a>3.4 为什么新任 leader 一定拥有旧 leader 已提交的日志？</h3>由两阶段提交和选举流程中的多数派原则保证的：</li><li>只有被集群多数派完成同步的日志才会被 leader 提交；</li><li>在选举流程中，节点只会把票投给日志进度不滞后于自身的 candidate；</li><li>在竞选流程，candidate 需要获取多数派的赞同票才能胜任，成为新任 leader.</li><li>可知，新任 leader 的日志进度一定能在竞选流程的多数派中出于不滞后的地位.</li><li>而在集群节点个数固定的情况下，本轮竞选流程的多数派和认可前任 leader 同步日志请求的多数派至少存在一个重复的节点，否则就违背了多数派的语义（集群半数以上），因此可以得知，新任 leader 一定拥有前任 leader 那笔被多数派认可的日志，即旧 leader 提交的日志.</li></ul><h3 id="3-5-leader-向-follower-同步日志时，如何保证不出现乱序、丢失、重复的问题？"><a href="#3-5-leader-向-follower-同步日志时，如何保证不出现乱序、丢失、重复的问题？" class="headerlink" title="3.5 leader 向 follower 同步日志时，如何保证不出现乱序、丢失、重复的问题？"></a>3.5 leader 向 follower 同步日志时，如何保证不出现乱序、丢失、重复的问题？</h3><ul><li>不乱序、不重复：follower 同步日志前，会校验上一笔日志是否和 leader 的上一笔完全一致，只有这样才会执行同步动作.</li><li>不丢失：基于 ack 机制保证. 倘若 leader 超时未收到 follower 同步日志的 ack，会重发同步日志请求.</li></ul><h3 id="3-6-如何保证各节点已提交的预写日志顺序和内容都完全一致？"><a href="#3-6-如何保证各节点已提交的预写日志顺序和内容都完全一致？" class="headerlink" title="3.6 如何保证各节点已提交的预写日志顺序和内容都完全一致？"></a>3.6 如何保证各节点已提交的预写日志顺序和内容都完全一致？</h3><ul><li>假设节点 a 最后一笔已提交的预写日志的 term = x、index = y，这说明集群中有多数派认同了 term 为 x 的 leader 同步该笔日志的请求.</li><li>首先证明：倘若其他节点在 index = y 位置的日志已提交了，则这笔日志的 term 一定也为 x.</li><li>证明思路：倘若节点 b 在 index = y 处的日志已提交，且任期为 z，那么就说明集群中有多数派认可了任期为 z 的 leader 同步的 term = z、index = y 的日志的请求. 由于集群不可能存在两个对立的多数派，因此唯一的可能性就是 z = x，原题得证.</li><li>接下来基于 7.2 小节的证明结论，我们可以得知各节点在 term = x、index = y 前面部分的日志也都完全一致，即各节点已提交的预写日志顺序和内容都完全一致.</li></ul><h3 id="3-7-如何保证状态机数据的最终一致性？"><a href="#3-7-如何保证状态机数据的最终一致性？" class="headerlink" title="3.7 如何保证状态机数据的最终一致性？"></a>3.7 如何保证状态机数据的最终一致性？</h3><ul><li>被提交的预写日志顺序和内容都必然是完全一致的.</li><li>又由于只有被提交的预写日志才能被应用到状态机，因此状态机的数据必然会按照正确的顺序和请求内容被依次更新，最终一致性得以保证.</li></ul><h3 id="3-8-如何解决网络分区引发的无意义选举问题？"><a href="#3-8-如何解决网络分区引发的无意义选举问题？" class="headerlink" title="3.8 如何解决网络分区引发的无意义选举问题？"></a>3.8 如何解决网络分区引发的无意义选举问题？</h3><ul><li>倘若集群产生网络分区，部分处于小分区的节点由于无法接收到 leader 的心跳，导致进入选举流程. 又因为网络分区问题，导致选举始终无法获得多数派的响应，最终 candidate 会无限自增 term. 直到网络恢复的那一刻，由于 candidate 异常的高 term，导致 leader 退位，集群进入新一轮的选举流程.</li><li>尽管小分区中的节点由于数据的滞后不可能在选举中胜出，最后必然是大分区中的节点胜任，节点数据的一致性依然可以得到保证. 但是这个无意义的选举过程同样会导致集群陷入暂不可用的阶段. 因此，我们可以通过这样的措施来避免这类无意义的选举：</li><li>每个 candidate 发起真实选举之前，会有一个提前试探的过程，试探机制是向集群所有节点发送请求，只有得到多数派的响应，证明自己不存在网络环境问题时，才会将竞选任期自增，并且发起真实的选举流程.</li></ul><h3 id="3-9-如果保证客户端提交写请求不丢失、不重复？"><a href="#3-9-如果保证客户端提交写请求不丢失、不重复？" class="headerlink" title="3.9 如果保证客户端提交写请求不丢失、不重复？"></a>3.9 如果保证客户端提交写请求不丢失、不重复？</h3><ul><li>不丢失：通过 ack 机制保证. 客户端超时未收到服务端的 ack，则会重发请求.</li><li>不重复：客户端记录写请求的序列号，与服务端交互时透传这个序列号. 最终由服务端的 leader 实现对相同序列号写请求的幂等去重.</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://stardustorz.github.io/2023/09/10/System-Design/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/"/>
    <id>https://stardustorz.github.io/2023/09/10/System-Design/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/</id>
    <published>2023-09-09T19:21:12.000Z</published>
    <updated>2025-05-25T10:25:10.708Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>分布式实际上就是单一的本地一体解决方案，在硬件或者资源上不够业务需求，而采取的一种分散式多节点，可以扩容资源的一种解决思路。</p><h2 id="1-一、从本地事务到分布式理论"><a href="#1-一、从本地事务到分布式理论" class="headerlink" title="1 一、从本地事务到分布式理论"></a>1 一、从本地事务到分布式理论</h2><p>事务提供一种机制将一个活动涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作只有在所有操作均能正常执行的情况下方能提交，只要其中任一操作执行失败，都将导致整个事务的回滚。</p><h3 id="1-1-1、ACID理论"><a href="#1-1-1、ACID理论" class="headerlink" title="1.1 1、ACID理论"></a>1.1 1、ACID理论</h3><ul><li><strong>原子性（Atomicity）</strong> 所有操作，要么全部完成，要么全部不完成</li><li><strong>一致性（Consistency）</strong> 在事务开始之前和事务结束以后，数据库数据的一致性约束没有被破坏。 不能说凭空多了 100 块钱</li><li><strong>隔离性（Isolation）</strong> 不受未提交事务的影响。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</li><li><strong>持久性（Durability</strong>   事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。<h3 id="1-2-2、CAP-理论"><a href="#1-2-2、CAP-理论" class="headerlink" title="1.2 2、CAP 理论"></a>1.2 2、CAP 理论</h3>一个分布式系统最多只能同时满足<code>一致性（Consistency）</code>、<code>可用性（Availability）</code>和<code>分区容忍性（Partition Tolerance）</code>这三项中的两项。</li><li><strong><em>一致性</em></strong>   指“所有节点同时看到相同的数据”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，等同于所有节点拥有数据的最新版本。</li><li><strong><em>可用性</em></strong>   指“任何时候，读写都是成功的”，即服务一直可用，而且是正常响应时间。</li><li><strong><em>分区容忍性</em></strong> 指“当部分节点出现消息丢失或者分区故障的时候，分布式系统仍然能够继续运行”，即系统容忍网络出现分区，并且在遇到某节点或网络分区之间网络不可达的情况下，仍然能够对外提供满足一致性和可用性的服务。</li><li>其中，<code>P 是确定的</code>，因为网络断开是客观存在的，因此就是选择 <strong>AP 架构</strong>还是 <strong>CP 架构</strong>的问题，实现更好的<strong>一致性和可用性</strong>。</li></ul></blockquote><pre><code>CP、AP 架构的取舍案例。Zookeeper用来解决分布式集群中应用系统的协调和一致性问题，因此是 CP。 Eureka等服务发现组件是为了保证可用性，因此是 AP。</code></pre><h3 id="1-3-3、Base-理论"><a href="#1-3-3、Base-理论" class="headerlink" title="1.3 3、Base 理论"></a>1.3 3、Base 理论</h3><blockquote><p>BASE是 <code>Basically Available(基本可用）</code>、<code>Soft state(软状态）</code>和 <code>Eventually consistent(最终一致性）</code>三个短语的简写。核心思想是<code>最终一致性</code>。</p><ul><li><em>基本可用</em>： 允许损失部分可用性，延长响应时间，降级服务，限流等时段。</li><li><em>软状态</em>： 允许系统在多个不同节点的数据副本存在数据延时。</li><li><em>最终一致性</em>： 数据不能一直处于软状态，在一个时间期限后保证所有副本的数据一致性。</li><li>Base 是对 CAP 的实际应用，放弃强一致性，实现基本可用。</li></ul></blockquote><h2 id="2-二、分布式事务解决方案"><a href="#2-二、分布式事务解决方案" class="headerlink" title="2 二、分布式事务解决方案"></a>2 二、分布式事务解决方案</h2><blockquote><p>两阶段和三阶段提交协议、 TCC 分段提交，和基于消息队列的最终一致性设计。</p><h3 id="2-1-1、2PC-两阶段提交"><a href="#2-1-1、2PC-两阶段提交" class="headerlink" title="2.1 1、2PC 两阶段提交"></a>2.1 1、2PC 两阶段提交</h3><p>Two-phase Commit Protocol  一致性、中心化的原子提交协议</p><ul><li><strong>提交请求阶段</strong>：协调者将通知事务参与者准备提交事务，然后进入表决过程。在表决过程中，参与者将告知协调者自己的决策。</li><li><strong>提交阶段</strong>：协调者基于投票结果进行决策，所有参与者同意则提交事务。</li><li><strong>问题</strong>：资源阻塞，协调者单点故障，通知丢失造成数据不一致。<h3 id="2-2-2、3PC-三阶段提交"><a href="#2-2-2、3PC-三阶段提交" class="headerlink" title="2.2 2、3PC 三阶段提交"></a>2.2 2、3PC 三阶段提交</h3>在 2PC 之上扩展的提交协议，主要是为了解决两阶段提交协议的阻塞问题，从原来的两个阶段扩展为三个阶段，增加了超时机制。</li><li>CanCommit 阶段：协调者向参与者发送 Can-Commit 请求</li><li>PreCommit 阶段：协调者发送预提交请求，全部通过则进入 Prepared 阶段。</li><li>DoCommit 阶段：进行事务提交和没收到通知后进行超时提交。</li><li>优点和问题：引入超时机制和预提交阶段，保证在最后提交前各节点状态一致<h3 id="2-3-3、TCC-分段提交"><a href="#2-3-3、TCC-分段提交" class="headerlink" title="2.3 3、TCC 分段提交"></a>2.3 3、TCC 分段提交</h3>分布式事务的处理模型，将事务过程拆分为 Try、Confirm、Cancel 三个步骤，在保证强一致性的同时，最大限度提高系统的可伸缩性与可用性。</li><li><strong><em>Try 阶段</em></strong>：先对资源进行锁定，资源处于中间态但不处于最终态</li><li><strong><em>Confirm 或 Cancel 阶段</em></strong>：在 Try 操作的基础上，真正提交这次修改操作还是回滚这次变更操作</li><li><code>事务协调器 TX Manager</code>：负责统筹分布式事务的执行，串联 Try -&gt; Confirm/Cancel 的两阶段流程. 在第一阶段中批量调用 TCC Component 的 Try 接口，根据其结果，决定第二阶段是批量调用 TCC Component 的 Confirm 接口还是 Cancel 接口<h3 id="2-4-4、基于消息补偿的最终一致性"><a href="#2-4-4、基于消息补偿的最终一致性" class="headerlink" title="2.4 4、基于消息补偿的最终一致性"></a>2.4 4、基于消息补偿的最终一致性</h3>具体实现上，基于消息补偿的一致性主要有本地消息表和第三方可靠消息队列等。<h4 id="2-4-1-基于-MQ-实现分布式事务"><a href="#2-4-1-基于-MQ-实现分布式事务" class="headerlink" title="2.4.1 基于 MQ 实现分布式事务"></a>2.4.1 基于 MQ 实现分布式事务</h4></li><li>MQ可以保证至少被消费一次，但是不能解决消息的重复性问题</li><li>消费者需要基于消息的唯一键执行幂等去重操作<h2 id="3-三、Paxos-算法"><a href="#3-三、Paxos-算法" class="headerlink" title="3 三、Paxos 算法"></a>3 三、Paxos 算法</h2><h3 id="3-1-1、Quorum-机制"><a href="#3-1-1、Quorum-机制" class="headerlink" title="3.1 1、Quorum 机制"></a>3.1 1、Quorum 机制</h3>在 N 个副本中，一次更新成功的如果有 W 个，那么我在读取数据时是要从大于 N－W 个副本中读取，这样就能至少读到一个更新的数据了。<br>  WARO：全部更新完成才能写，保证所有副本一致</li><li>定义： 限定一次最少要读的副本数，如共 N 个副本，更新了 W 个，则要读取 N-W+1 个，保证读的数据是最新的。</li><li>需要配合版本号机制来确认。<h3 id="3-2-2、Paxos-节点构成"><a href="#3-2-2、Paxos-节点构成" class="headerlink" title="3.2 2、Paxos 节点构成"></a>3.2 2、Paxos 节点构成</h3>  角色有三种，一个节点可以同时成为这三者</li><li>提案者（Proposer）：提出议案value，比如修改某个变量，一轮只批准一个 value。</li><li>批准者 （Acceptor）：value 超过半数（N/2+1）的 Acceptor 批准后才能通过</li><li>学习者（Learner）： 学习被批准的 value，参考 Quorum机制，至少读 N/2+1 个 Accpetor来学习到通过的 value。</li><li>Client 产生议题者<h3 id="3-3-3、选举过程"><a href="#3-3-3、选举过程" class="headerlink" title="3.3 3、选举过程"></a>3.3 3、选举过程</h3></li><li>准备阶段：Proposer生成唯一的 ProposalID，发送 Prepare 请求。Acceptor 收到后，本地持久化并返回已经接收的提案。</li><li>选举阶段：<ul><li>Proposer 发送 Accept，回复大于一半，发出accept 请求，并带上自己指定的 value。</li><li>Acceptor 应答 Accept，回复提交结果。</li><li>Proposer 统计投票，过半数回复成功，广播结果。失败则回到准备阶段。<h2 id="4-四、Raft-算法"><a href="#4-四、Raft-算法" class="headerlink" title="4 四、Raft 算法"></a>4 四、Raft 算法</h2><h3 id="4-1-1、-概念介绍"><a href="#4-1-1、-概念介绍" class="headerlink" title="4.1 1、 概念介绍"></a>4.1 1、 概念介绍</h3>使用了分治思想把算法流程分为三个子问题：选举（Leader election）、日志复制（Log replication）、安全性（Safety）三个子问题</li></ul></li><li>节点被分为 Leader Follower Cabdidate 三种角色：<ul><li><strong>Leader</strong>：处理与客户端的交互和与 follower 的日志复制等，一般只有一个 Leader；</li><li><strong>Follower</strong>：被动学习 Leader 的日志同步，同时也会在 leader 超时后转变为 Candidate 参与竞选；</li><li><strong>Candidate</strong>：在竞选期间参与竞选；</li></ul></li><li><strong><em>Term</em></strong>：<strong>Raft 算法将时间划分成为任意不同长度的任期（term）</strong>。任期用连续的数字进行表示。<strong>每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人</strong>。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。<strong>Raft 算法保证在给定的一个任期最多只有一个领导人</strong>。</li><li><strong><em>随机超时时间</em></strong>：Follower 节点每次收到 Leader 的心跳请求后，会设置一个随机的，区间位于（150ms, 300ms)的超时时间。如果超过超时时间，还没有收到 Leader 的下一条请求，则认为 Leader 过期/故障了。</li><li><strong>心跳续命</strong>：Leader 在当选期间，会以一定时间间隔向其他节点发送心跳请求，以维护自己的 Leader 地位。</li><li>Raft 算法中服务器节点之间通信使用远程过程调用（RPC）<ul><li>RequestVote RPC：候选人在选举期间发起。</li><li>AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成。</li><li>installSnapshot RPC: 领导者使用该RPC来发送快照给太落后的追随者。<h3 id="4-2-2、协议流程"><a href="#4-2-2、协议流程" class="headerlink" title="4.2 2、协议流程"></a>4.2 2、协议流程</h3></li></ul></li><li><em>选举流程</em><ul><li>当某个 follower 节点在超时时间内未收到 Leader 的请求，将发起选举， 从一个 Follower 变成 Candidate</li><li>如果一个 Candidate 收到了超过半数的投票，则该节点晋升为 Leader，会广播给所有节点；开始进行日志同步、处理客户端请求等</li><li>term用来保证请求的合法性</li></ul></li><li><em>日志复制</em><ul><li><code>复制状态机</code>：不同节点从相同的初始状态出发，执行相同顺序的输入指令集后，会得到相同的结束状态。</li><li>节点初始化后具有相同初始状态，将一个客户端请求（command）封装到一个<code>log entry</code> 中。Leader 负责将这些 log entries 复制到所有的 Follower 节点，然后节点按照相同的顺序应用 commands，达到<code>最终的一致状态</code></li><li>Leader执行请求过程：<ul><li>本地追加日志信息；</li><li>并行发出 AppendEntries RPC 请求；</li><li>等待大多数 Follower 的回应。收到查过半数节点的成功提交回应，代表该日志被复制到了大多数节点中(committed)；</li><li>在状态机上执行 entry command。既将该日志应用到状态机，真正影响到节点状态(applied)；</li><li>回应 Client 执行结果；</li><li>确认 Follower 也执行了这条 command；如果 Follower 崩溃、运行缓慢或者网络丢包，Leader 将无限期地重试 AppendEntries RPC，直到所有 Followers 应用了所有日志条目。<h3 id="4-3-3、安全性及约束"><a href="#4-3-3、安全性及约束" class="headerlink" title="4.3 3、安全性及约束"></a>4.3 3、安全性及约束</h3><h4 id="4-3-1-选举安全性"><a href="#4-3-1-选举安全性" class="headerlink" title="4.3.1 选举安全性"></a>4.3.1 选举安全性</h4></li></ul></li></ul></li><li>任一任期内最多一个 leader 被选出，有多余的 Leader就是脑裂了<ul><li>一个节点某一任期内最多只能投一票；而节点 B 的 term 必须比 A 的新，A 才能给 B 投票</li><li>只有获得多数投票的节点才会成为 leader<h4 id="4-3-2-日志-append-only"><a href="#4-3-2-日志-append-only" class="headerlink" title="4.3.2 日志 append only"></a>4.3.2 日志 append only</h4></li></ul></li><li>leader 在某一 term 的任一位置只会创建一个 log entry，且 log entry 是 append-only</li><li>一致性检查，请求中会包含最新 log entry 的前一个 log 的 term 和 index，如果 follower 在对应的 term index 找不到日志就会重新进行同步<h4 id="4-3-3-日志匹配特性"><a href="#4-3-3-日志匹配特性" class="headerlink" title="4.3.3 日志匹配特性"></a>4.3.3 日志匹配特性</h4></li><li>如果两个节点上的某个 log entry 的 log index 相同且 term 相同，那么在该 index 之前的所有 log entry 应该都是相同的。<h4 id="4-3-4-Leader-完备性"><a href="#4-3-4-Leader-完备性" class="headerlink" title="4.3.4 Leader 完备性"></a>4.3.4 Leader 完备性</h4></li><li>被选举人必须比自己知道的更多（比较 term 、log index）<h4 id="4-3-5-状态机安全性"><a href="#4-3-5-状态机安全性" class="headerlink" title="4.3.5 状态机安全性"></a>4.3.5 状态机安全性</h4></li><li>状态机安全性由日志的一致来保证。在算法中，一个日志被复制到多数节点才算 committed， 如果一个 log entry 在某个任期被提交（committed），那么这条日志一定会出现在所有更高 term 的 leader 的日志里面</li></ul></blockquote><h2 id="5-五、ZooKeeper"><a href="#5-五、ZooKeeper" class="headerlink" title="5 五、ZooKeeper"></a>5 五、ZooKeeper</h2><pre><code>ZooKeeper 提供了一个类似于 Linux 文件系统的数据模型，和基于 Watcher 机制的分布式事件通知。</code></pre><h3 id="5-1-1、Zab-一致性协议"><a href="#5-1-1、Zab-一致性协议" class="headerlink" title="5.1 1、Zab 一致性协议"></a>5.1 1、Zab 一致性协议</h3><pre><code>ZooKeeper Atomic Broadcast，ZooKeeper 原子广播协议，保证分布式事务的最终一致性。具体实现</code></pre><ul><li>消息广播阶段，Leader 节点接受事务提交并将请求广播给 Follower 节点，根据反馈决定是否 Commit。</li><li>崩溃恢复阶段，Leader 宕机，重新进行 Leader 选举并进行数据同步。</li><li>Zxid: 事务编号，有一个新的 Leader 选举出现时，就会从这个 Leader 服务器上取出其本地日志中最大事务的 Zxid，并从中读取 epoch 值，然后加 1，以此作为新的周期 ID。高 32 位代表了每代 Leader 的唯一性，低 32 位则代表了每代 Leader 中事务的唯一性。</li></ul><h2 id="6-六、分布式锁"><a href="#6-六、分布式锁" class="headerlink" title="6 六、分布式锁"></a>6 六、分布式锁</h2><pre><code>分布式锁的目的是保证在分布式部署的应用集群中，多个服务在请求同一个方法或者同一个业务操作的情况下，对应业务逻辑只能被一台机器上的一个线程执行，避免出现并发问题。</code></pre><ul><li><strong>互斥性</strong>: 任意时刻，只有一个客户端能持有锁。</li><li><strong>锁超时释放</strong>：持有锁超时，可以释放，防止不必要的资源浪费，也可以防止死锁。</li><li><strong>可重入性</strong>:一个线程如果获取了锁之后,可以再次对其请求加锁。</li><li><strong>高性能和高可用</strong>：加锁和解锁需要开销尽可能低，同时也要保证高可用，避免分布式锁失效。</li><li><strong>安全性</strong>：锁只能被持有的客户端删除，不能被其他客户端删除<h3 id="6-1-1、基于数据库"><a href="#6-1-1、基于数据库" class="headerlink" title="6.1 1、基于数据库"></a>6.1 1、基于数据库</h3>  基于关系型数据库实现分布式锁，是依赖数据库的唯一性来实现资源锁定，比如主键和唯一索引等。<br>  问题：单点故障，超时无法失效，不可重入，不能阻塞。<h3 id="6-2-2、基于缓存-Redis"><a href="#6-2-2、基于缓存-Redis" class="headerlink" title="6.2 2、基于缓存 Redis"></a>6.2 2、基于缓存 Redis</h3></li><li>SETNX + EXPIRE：不是原子操作</li><li>SETNX + value值是(系统时间+过期时间)：要求时间同步，没有持有者的标识</li><li>使用Lua脚本(包含SETNX + EXPIRE两条指令)：原子性</li><li>SET的扩展命令（SET EX PX NX）：误删，过期还没执行完</li><li>SET EX PX NX + 校验唯一随机值,再删除：设置 value 标记线程</li><li>Redisson框架：开启一个定时守护线程，延长过期时间</li><li>setnx 是「set if not exists」</li></ul><blockquote><p>高可用，Redlock算法，基于 N 个完全独立的 Redis 节点，一般是大于 3 的奇数个</p><ul><li>客户端记录当前系统时间，以毫秒为单位；</li><li>依次尝试从 5 个 Redis 实例中，使用相同的 key 获取锁，当向 Redis 请求获取锁时，客户端应该设置一个网络连接和响应超时时间，超时时间应该小于锁的失效时间，避免因为网络故障出现的问题；</li><li>客户端使用当前时间减去开始获取锁时间就得到了获取锁使用的时间，当且仅当从半数以上的 Redis 节点获取到锁，并且当使用的时间小于锁失效时间时，锁才算获取成功；</li><li>如果获取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间，减少超时的几率；</li><li>如果获取锁失败，客户端应该在所有的 Redis 实例上进行解锁，即使是上一步操作请求失败的节点，防止因为服务端响应消息丢失，但是实际数据添加成功导致的不一致。</li></ul></blockquote><h3 id="6-3-3、基于Zookeeper"><a href="#6-3-3、基于Zookeeper" class="headerlink" title="6.3 3、基于Zookeeper"></a>6.3 3、基于Zookeeper</h3><ul><li>利用 ZooKeeper 支持临时顺序节点的特性，实现分布式锁。</li><li>当客户端对某个方法加锁时，在 ZooKeeper 中该方法对应的指定节点目录下，生成一个唯一的临时有序节点。</li><li>判断是否获取锁，只需要判断持有的节点是否是有序节点中序号最小的一个，当释放锁的时候，将这个临时节点删除即可，这种方式可以避免服务宕机导致的锁无法释放而产生的死锁问题。<ul><li>客户端连接 ZooKeeper，并在 /lock 下创建临时有序子节点，第一个客户端对应的子节点为 /lock/lock01/00000001，第二个为 /lock/lock01/00000002；</li><li>其他客户端获取 /lock01 下的子节点列表，判断自己创建的子节点是否为当前列表中序号最小的子节点；</li><li>如果是则认为获得锁，执行业务代码，否则通过 watch 事件监听 /lock01 的子节点变更消息，获得变更通知后重复此步骤直至获得锁；</li><li>完成业务流程后，删除对应的子节点，释放分布式锁。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;分布式实际上就是单一的本地一体解决方案，在硬件或者资源上不够业务需求，而采取的一种分散式多节点，可以扩容资源的一种解决思路。&lt;/p&gt;
&lt;h2 id=&quot;1-一、从本地事务到分布式理论&quot;&gt;&lt;a href=&quot;#1-一、从本地事务到分布式理论&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>[Go] 垃圾回收</title>
    <link href="https://stardustorz.github.io/2022/09/12/Golang/2%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>https://stardustorz.github.io/2022/09/12/Golang/2%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</id>
    <published>2022-09-11T16:00:00.000Z</published>
    <updated>2025-03-11T16:24:38.999Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>垃圾回收（Garbage Collection，简称 GC）是一种内存管理策略，由垃圾收集器以类似守护协程的方式在后台运作，按照既定的策略为用户回收那些不再被使用的对象，释放对应的内存空间.</p></blockquote><span id="more"></span><h2 id="1-垃圾回收算法"><a href="#1-垃圾回收算法" class="headerlink" title="1 垃圾回收算法"></a>1 垃圾回收算法</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p><strong>GC 带来的优势</strong></p><ul><li>屏蔽内存回收的细节, 使用户更好地聚焦于核心的业务逻辑</li><li>以全局视野执行任务</li></ul><p><strong>GC 带来的劣势</strong></p><ul><li>提高了下限但降低了上限</li><li>增加了额外的成本</li></ul><h3 id="1-2-标记清扫"><a href="#1-2-标记清扫" class="headerlink" title="1.2 标记清扫"></a>1.2 标记清扫</h3><p>标记清扫（Mark-Sweep）算法, 分为两步实现:</p><ul><li>标记：标记出当前还存活的对象</li><li>清扫：清扫掉未被标记到的垃圾对象</li></ul><p>标记清扫通过标记存活对象，从而取补集推断出垃圾对象, 它的缺点在于会产生内存碎片, 这些碎片分散分布的话, 会影响大对象的内存分配.</p><h3 id="1-3-标记压缩"><a href="#1-3-标记压缩" class="headerlink" title="1.3 标记压缩"></a>1.3 标记压缩</h3><p>标记压缩（Mark-Compact）算法，是在标记清扫算法的基础上做了升级，在第二步”清扫“的同时还会对存活对象进行压缩整合，使得整体空间更为紧凑，从而解决内存碎片问题<br>缺陷在于实现时会有很高的复杂度.</p><h3 id="1-4-半空间复制"><a href="#1-4-半空间复制" class="headerlink" title="1.4 半空间复制"></a>1.4 半空间复制</h3><p><strong>半空间复制（Semispace Copy）算法主要实现如下:</strong></p><ul><li>分配两片相等大小的空间，称为 fromspace 和 tospace</li><li>每轮只使用 fromspace 空间，以GC作为分水岭划分轮次</li><li>GC时，将fromspace存活对象转移到tospace中，并以此为契机对空间进行压缩整合</li><li>GC后，交换fromspace和tospace，开启新的轮次</li></ul><p>半空间复制算法应用了以空间换取时间的优化策略，解决了内存碎片的问题，也在一定程度上降低了压缩空间的复杂度. 但其缺点也同样很明显——比较浪费空间<br>Java 所采用的就是半空间复制的升级版</p><h3 id="1-5-引用计数"><a href="#1-5-引用计数" class="headerlink" title="1.5 引用计数"></a>1.5 引用计数</h3><p><strong>引用计数（Reference Counting）主要实现如下:</strong></p><ul><li>对象每被引用一次，计数器加1</li><li>对象每被删除引用一次，计数器减1</li><li>GC时，把计数器等于 0 的对象删除</li></ul><p>缺陷在于无法解决循环引用和自引用的问题</p><h2 id="2-Golang-中的垃圾回收"><a href="#2-Golang-中的垃圾回收" class="headerlink" title="2 Golang 中的垃圾回收"></a>2 Golang 中的垃圾回收</h2><blockquote><p>在 1.8版本之后，Golang 的 GC 策略主要为并发三色标记法+混合写屏障机制</p></blockquote><h3 id="2-1-三色标记法"><a href="#2-1-三色标记法" class="headerlink" title="2.1 三色标记法"></a>2.1 三色标记法</h3><p>Golang GC 中用到的三色标记法属于标记清扫-算法下的一种实现, 主要思路如下:</p><ul><li>对象分为三种颜色标记：黑、灰、白</li><li>黑对象代表，对象自身存活，且其指向对象都已标记完成</li><li>灰对象代表，对象自身存活，但其指向对象还未标记完成</li><li>白对象代表，对象尙未被标记到，可能是垃圾对象</li><li>标记开始前，将根对象（全局对象、栈上局部变量等）置黑，将其所指向的对象置灰</li><li>标记规则是: 从灰对象出发，将其所指向的对象都置灰. 所有指向对象都置灰后，当前灰对象置黑</li><li>标记结束后，白色对象就是不可达的垃圾对象，需要进行清扫</li></ul><h3 id="2-2-并发垃圾回收"><a href="#2-2-并发垃圾回收" class="headerlink" title="2.2 并发垃圾回收"></a>2.2 并发垃圾回收</h3><ul><li>Golang 1.5 版本是个分水岭，在此之前，GC时需要停止全局的用户协程，专注完成GC工作后，再恢复用户协程，这样做在实现上简单直观，但是会对用户造成不好的体验</li><li>自1.5版本以来，Golang引入了并发垃圾回收机制，允许用户协程和后台的GC协程并发运行，大大地提高了用户体验. 但用户协程并发运行时可能对对象间的引用关系进行调整，这会严重打乱GC三色标记时的标记秩序</li></ul><h3 id="2-3-可能的问题"><a href="#2-3-可能的问题" class="headerlink" title="2.3 可能的问题"></a>2.3 可能的问题</h3><ul><li><strong>漏标问题</strong><ul><li>假设只有对象 B 持有对象 C 的引用,如果 GC 协程在 B 删除 C 的引用后才开始扫描 B，就会无法到达 C.  此时从扫描结果上看，C 是不可达的</li><li>针对漏标问题，Golang 给出的解决方案是屏障机制</li></ul></li><li><strong>多标问题</strong><ul><li>假设对象 A 持有对象 B 的引用</li><li>GC协程下，对象 A 被扫描完成，置黑；对象 B 被对象 A 引用，因此被置灰</li><li>用户协程下，对象 A 删除指向对象 B 的引用</li><li>B 在被 A 删除引用后，已成为垃圾对象，但由于其事先已被置灰，因此最终会更新为黑色，不会被 GC 删除</li><li>错标问题对比于漏标问题而言，是相对可以接受的, 至多到下一轮 GC，这部分对象就会被 GC 回收</li></ul></li><li><strong>内存碎片问题</strong><ul><li>Golang采用 TCMalloc 机制，依据对象的大小将其归属为到事先划分好的spanClass当中，这样能够消解外部碎片的问题，将问题限制在相对可控的内部碎片当中</li></ul></li><li><strong>为什么不学 Java 用分代?</strong><ul><li>分代算法指的是，将对象分为年轻代和老年代两部分（或者更多），采用不同的GC策略进行分类管理. 分代GC算法有效的前提是，绝大多数年轻代对象都是朝生夕死，拥有更高的GC回收率，因此适合采用特别的策略进行处理.</li><li>Golang中存在内存逃逸机制，会在编译过程中将生命周期更长的对象转移到堆中，将生命周期短的对象分配在栈上，并以栈为单位对这部分对象进行回收</li><li>综上，内存逃逸机制减弱了分代算法对Golang GC所带来的优势，考虑分代算法需要产生额外的成本（如不同年代的规则映射、状态管理以及额外的写屏障），Golang 选择不采用分代GC算法</li></ul></li></ul><h2 id="3-屏障机制"><a href="#3-屏障机制" class="headerlink" title="3 屏障机制"></a>3 屏障机制</h2><blockquote><p>主要是为了解决2.3小节中提及的并发GC下的漏标问题</p></blockquote><h3 id="3-1-强弱三色不变式"><a href="#3-1-强弱三色不变式" class="headerlink" title="3.1 强弱三色不变式"></a>3.1 强弱三色不变式</h3><p>漏标问题的本质就是，一个已经扫描完成的黑对象指向了一个被灰\白对象删除引用的白色对象. 构成这一场景的要素拆分如下：</p><ol><li>黑色对象指向了白色对象</li><li>灰、白对象删除了白色对象</li><li>（1）、（2）步中谈及的白色对象是同一个对象</li><li>（1）发生在（2）之前</li></ol><p>通过破坏这些要素,可以解决漏标问题, 称为强弱三色不变式:</p><ul><li>强三色不变式：白色对象不能被黑色对象直接引用（直接破坏（1））</li><li>弱三色不变式：白色对象可以被黑色对象引用，但要从某个灰对象出发仍然可达该白对象（间接破坏了（1）、（2）的联动）</li></ul><h3 id="3-2-插入写屏障"><a href="#3-2-插入写屏障" class="headerlink" title="3.2 插入写屏障"></a>3.2 插入写屏障</h3><ul><li>屏障机制类似于一个回调保护机制，指的是在完成某个特定动作前，会先完成屏障成设置的内容</li><li>插入写屏障（Dijkstra）的目标是实现<strong>强三色不变式</strong>，保证当一个黑色对象指向一个白色对象前，会先触发屏障将白色对象置为灰色，再建立引用</li></ul><h3 id="3-3-删除写屏障"><a href="#3-3-删除写屏障" class="headerlink" title="3.3 删除写屏障"></a>3.3 删除写屏障</h3><ul><li>删除写屏障（Yuasa barrier）的目标是实现<strong>弱三色不变式</strong>，保证当一个白色对象即将被上游删除引用前，会触发屏障将其置灰，之后再删除上游指向其的引用</li><li>也就是保证在删除到这个对象 A 的引用后,  对象 A对于 GC 来说依旧是可见的</li></ul><h3 id="3-4-混合写屏障"><a href="#3-4-混合写屏障" class="headerlink" title="3.4 混合写屏障"></a>3.4 混合写屏障</h3><ul><li>插入写屏障、删除写屏障二者择其一，即可解决并发GC的漏标问题，至于错标问题，则采用容忍态度，放到下一轮GC中进行延后处理即可</li><li>但是, 屏障机制无法作用于栈对象, 因为栈对象可能涉及频繁的轻量操作，高频率的触发屏障机制，带来的成本将是无法接受的.</li><li>在 Go1.8 前, 栈上的垃圾对象通过引入额外的Stop the world（STW）阶段解决, 1.18 后,  引入了混合写屏障机制来消除 STW 成本, 主要思路如下:<ul><li>GC 开始前，以栈为单位分批扫描，将栈中所有对象置黑</li><li>GC 期间，栈上新创建对象直接置黑</li><li>堆对象正常启用插入写屏障</li><li>堆对象正常启用删除写屏障</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;垃圾回收（Garbage Collection，简称 GC）是一种内存管理策略，由垃圾收集器以类似守护协程的方式在后台运作，按照既定的策略为用户回收那些不再被使用的对象，释放对应的内存空间.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="内存管理" scheme="https://stardustorz.github.io/categories/Golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Go] 内存分配</title>
    <link href="https://stardustorz.github.io/2022/09/08/Golang/2%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>https://stardustorz.github.io/2022/09/08/Golang/2%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</id>
    <published>2022-09-07T16:00:00.000Z</published>
    <updated>2025-03-11T16:28:30.740Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Golang的内存管理是基于TCMalloc的核心思想来构建的，内存管理本质上是一个<strong>内存池和多级对象管理</strong></p></blockquote><span id="more"></span><h2 id="1-内存模型"><a href="#1-内存模型" class="headerlink" title="1 内存模型"></a>1 内存模型</h2><h3 id="1-1-操作系统存储模型"><a href="#1-1-操作系统存储模型" class="headerlink" title="1.1 操作系统存储模型"></a>1.1 操作系统存储模型</h3><p><strong>多级存储模型</strong></p><ul><li>寄存器      1ns</li><li>高速缓存   2ns</li><li>内存           10ns</li><li>磁盘            10ms</li></ul><p>速度越快, 空间越小, 价格越贵</p><h3 id="1-2-虚拟内存与物理内存"><a href="#1-2-虚拟内存与物理内存" class="headerlink" title="1.2 虚拟内存与物理内存"></a>1.2 虚拟内存与物理内存</h3><p>虚拟内存作用如下：</p><ul><li>在用户与硬件间添加中间代理层</li><li>优化用户体验（进程感知到获得的内存空间是“连续”的）</li><li>“放大”可用内存（虚拟内存可以由物理内存+磁盘补足，并根据冷热动态置换，用户无感知）</li></ul><h3 id="1-3-分页管理"><a href="#1-3-分页管理" class="headerlink" title="1.3 分页管理"></a>1.3 分页管理</h3><p>操作系统中通常会将虚拟内存和物理内存切割成固定的尺寸，于虚拟内存而言叫作“页”，于物理内存而言叫作“帧”，原因如下：</p><ul><li>提高内存空间利用（以页为粒度后，消灭了不稳定的外部碎片，取而代之的是相对可控的内部碎片）</li><li>提高内外存交换效率（更细的粒度带来了更高的灵活度）</li><li>与虚拟内存机制呼应，便于建立虚拟地址-&gt;物理地址的映射关系（聚合映射关系的数据结构，称为页表）</li><li>linux 页/帧的大小固定，为 4KB（这实际是由实践推动的经验值，太粗会增加碎片率，太细会增加分配频率影响效率）</li></ul><h3 id="1-4-Golang-内存模型"><a href="#1-4-Golang-内存模型" class="headerlink" title="1.4 Golang 内存模型"></a>1.4 Golang 内存模型</h3><p><strong>Golang 的内存模型设计的思路：</strong></p><ul><li>以空间换时间，一次缓存，多次复用<ul><li>由于每次向操作系统申请内存的操作很重，那么不妨一次多申请一些，以备后用, 因此产生了堆 mheap<ul><li>对操作系统而言，这是用户进程中缓存的内存</li><li>对于 Go 进程内部，堆是所有对象的内存起源</li></ul></li></ul></li><li><strong>多级缓存，实现无/细锁化</strong><ul><li>堆是 Go 运行时中最大的临界共享资源，这意味着每次存取都要加锁，在性能层面是一件很可怕的事情.</li><li>因此 Golang 在堆 mheap 之上，依次细化粒度，建立了 mcentral、mcache 的模型:<ul><li>mheap：全局的内存起源，访问要加全局锁</li><li>mcentral：每种对象大小规格（全局共划分为 68 种）对应的缓存，锁的粒度也仅限于同一种规格以内</li><li>mcache：每个 P（正是 GMP 中的 P）持有一份的内存缓存，访问时无锁</li></ul></li></ul></li><li>多级规格，提高利用率<ul><li>page：最小的存储单元, Golang 借鉴操作系统分页管理的思想，每个最小的存储单元也称之为页 page，但大小为 8 KB</li><li>mspan：最小的管理单元. mspan 大小为 page 的整数倍，且从 8B 到 80 KB 被划分为 67 种不同的规格，分配对象时，会根据大小映射到不同规格的 mspan，从中获取空间, 多规格 mspan 特点如下:<ul><li>根据规格大小，产生了等级的制度</li><li>消除了外部碎片，但不可避免会有内部碎片</li><li>宏观上能提高整体空间利用率</li><li>正是因为有了规格等级的概念，才支持 mcentral 实现细锁化</li></ul></li></ul></li></ul><h2 id="2-核心概念"><a href="#2-核心概念" class="headerlink" title="2 核心概念"></a>2 核心概念</h2><h3 id="2-1-内存单元-mspan"><a href="#2-1-内存单元-mspan" class="headerlink" title="2.1 内存单元 mspan"></a>2.1 内存单元 mspan</h3><p><strong>mspan 的特质</strong>:</p><ul><li>mspan 是 Golang 内存管理的最小单元</li><li>mspan 大小是 page 的整数倍（Go 中的 page 大小为 8KB），且内部的页是连续的（至少在虚拟内存的视角中是这样）</li><li>每个 mspan 根据空间大小以及面向分配对象的大小，会被划分为不同的等级</li><li>同等级的 mspan 会从属同一个 mcentral，最终会被组织成链表，因此带有前后指针（prev、next）</li><li>同等级的 mspan 内聚于同一个 mcentral，所以会基于同一把互斥锁管理</li><li>mspan 会基于 bitMap 辅助快速找到空闲内存块（块大小为对应等级下的 object 大小），此时需要使用到 Ctz64 算法</li></ul><h3 id="2-2-内存单元等级-spanClass"><a href="#2-2-内存单元等级-spanClass" class="headerlink" title="2.2 内存单元等级 spanClass"></a>2.2 内存单元等级 spanClass</h3><p>mspan 根据空间大小和面向分配对象的大小，被划分为 67 种等级（1-67，实际上还有一种隐藏的 0 级，用于处理更大的对象，上不封顶）</p><div class="table-container"><table><thead><tr><th><strong>class</strong></th><th><strong>bytes/obj</strong></th><th><strong>bytes/span</strong></th><th><strong>objects</strong></th><th><strong>tail waste</strong></th><th><strong>max waste</strong></th></tr></thead><tbody><tr><td>1</td><td>8</td><td>8192</td><td>1024</td><td>0</td><td>87.50%</td></tr><tr><td>2</td><td>16</td><td>8192</td><td>512</td><td>0</td><td>43.75%</td></tr><tr><td>3</td><td>24</td><td>8192</td><td>341</td><td>8</td><td>29.24%</td></tr><tr><td>4</td><td>32</td><td>8192</td><td>256</td><td>0</td><td>21.88%</td></tr><tr><td>…</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>66</td><td>28672</td><td>57344</td><td>2</td><td>0</td><td>4.91%</td></tr><tr><td>67</td><td>32768</td><td>32768</td><td>1</td><td>0</td><td>12.50%</td></tr></tbody></table></div><ul><li>class：mspan 等级标识，1-67</li><li>bytes/obj：该大小规格的对象会从这一 mspan 中获取空间. 创建对象过程中，大小会向上取整为 8B 的整数倍，因此该表可以直接实现 object 到 mspan 等级 的映射</li><li>bytes/span：该等级的 mspan 的总空间大小</li><li>object：该等级的 mspan 最多可以 new 多少个对象，结果等于 （3）/（2）</li><li>tail waste：（3）/（2）可能除不尽，于是该项值为（3）%（2）</li><li>max waste：最不利的情况下浪费的空间比例</li></ul><h3 id="2-3-线程缓存-mcache"><a href="#2-3-线程缓存-mcache" class="headerlink" title="2.3 线程缓存 mcache"></a>2.3 线程缓存 mcache</h3><p><strong>特点</strong></p><ul><li>mcache 是每个 P 独有的缓存，因此交互无锁</li><li>mcache 将每种 spanClass 等级的 mspan 各缓存了一个，总数为 2（nocan 维度） * 68（大小维度）= 136</li><li>mcache 中还有一个为对象分配器 tiny allocator，用于处理小于 16B 对象的内存分配</li></ul><h3 id="2-4-中心缓存-mcentral"><a href="#2-4-中心缓存-mcentral" class="headerlink" title="2.4 中心缓存 mcentral"></a>2.4 中心缓存 mcentral</h3><p><strong>特点:</strong></p><ul><li>每个 mcentral 对应一种 spanClass</li><li>每个 mcentral 下聚合了该 spanClass 下的 mspan</li><li>mcentral 下的 mspan 分为两个链表，分别为有空间 mspan 链表 partial 和满空间 mspan 链表 full</li><li>每个 mcentral 一把锁</li></ul><h3 id="2-5-全局堆缓存-mheap"><a href="#2-5-全局堆缓存-mheap" class="headerlink" title="2.5 全局堆缓存 mheap"></a>2.5 全局堆缓存 mheap</h3><p><strong>特点:</strong></p><ul><li>对于 Golang 上层应用而言，堆是操作系统虚拟内存的抽象</li><li>以页（8KB）为单位，作为最小内存存储单元</li><li>负责将连续页组装成 mspan</li><li>全局内存基于 bitMap 标识其使用情况，每个 bit 对应一页，为 0 则自由，为 1 则已被 mspan 组装</li><li>通过 heapArena 聚合页，记录了页到 mspan 的映射信息</li><li>建立空闲页基数树索引 radix tree index，辅助快速寻找空闲页</li><li>是 mcentral 的持有者，持有所有 spanClass 下的 mcentral，作为自身的缓存</li><li>内存不够时，向操作系统申请，申请单位为 heapArena（64M）</li></ul><h3 id="2-6-空闲页索引-pageAlloc"><a href="#2-6-空闲页索引-pageAlloc" class="headerlink" title="2.6 空闲页索引 pageAlloc"></a>2.6 空闲页索引 pageAlloc</h3><ul><li>mheap 会基于 bitMap 标识内存中各页的使用情况，bit 位为 0 代表该页是空闲的，为 1 代表该页已被 mspan 占用</li><li>每棵基数树聚合了 16 GB 内存空间中各页使用情况的索引信息，用于帮助 mheap 快速找到指定长度的连续空闲页的所在位置</li><li>mheap 持有 2^14 棵基数树，因此索引全面覆盖到 2^14 * 16 GB = 256 T 的内存空间</li><li>基数树中，每个节点称之为 PallocSum，是一个 uint64 类型，体现了索引的聚合信息，包含以下四部分：<ul><li>start：最右侧 21 个 bit，标识了当前节点映射的 bitMap 范围中首端有多少个连续的 0 bit（空闲页），称之为 start；</li><li>max：中间 21 个 bit，标识了当前节点映射的 bitMap 范围中最多有多少个连续的 0 bit（空闲页），称之为 max；</li><li>end：左侧 21 个 bit，标识了当前节点映射的 bitMap 范围中最末端有多少个连续的 0 bit（空闲页），称之为 end.</li><li>最左侧一个 bit，弃置不用</li></ul></li><li>基数树父子关系<ul><li>每个父 pallocSum 有 8 个子 pallocSum</li><li>根 pallocSum 总览全局，映射的 bitMap 范围为全局的 16 GB 空间（其 max 最大值为 2^21，因此总空间大小为 2^21*8KB=16GB）</li><li>从首层向下是一个依次八等分的过程，每一个 pallocSum 映射其父节点 bitMap 范围的八分之一，因此第二层 pallocSum 的 bitMap 范围为 16GB/8 = 2GB，以此类推，第五层节点的范围为 16GB / (8^4) = 4 MB，已经很小</li><li>聚合信息时，自底向上. 每个父 pallocSum 聚合 8 个子 pallocSum 的 start、max、end 信息，形成自己的信息，直到根 pallocSum，坐拥全局 16 GB 的 start、max、end 信息</li><li>mheap 寻页时，自顶向下. 对于遍历到的每个 pallocSum，先看起 start 是否符合，是则寻页成功；再看 max 是否符合，是则进入其下层孩子 pallocSum 中进一步寻访；最后看 end 和下一个同辈 pallocSum 的 start 聚合后是否满足，是则寻页成功</li></ul></li></ul><h3 id="2-7-heapArena"><a href="#2-7-heapArena" class="headerlink" title="2.7 heapArena"></a>2.7 heapArena</h3><ul><li>每个 heapArena 包含 8192 个页，大小为 8192 * 8KB = 64 MB</li><li>heapArena 记录了页到 mspan 的映射. 因为 GC 时，通过地址偏移找到页很方便，但找到其所属的 mspan 不容易. 因此需要通过这个映射信息进行辅助.</li><li>heapArena 是 mheap 向操作系统申请内存的单位（64MB）</li></ul><h2 id="3-对象分配流程"><a href="#3-对象分配流程" class="headerlink" title="3 对象分配流程"></a>3 对象分配流程</h2><p>串联 Golang 中分配对象的流程，不论是以下哪种方式，最终都会殊途同归步入 mallocgc 方法中，并且根据 3.1 小节中的策略执行分配流程:</p><ul><li>new(T)</li><li>&amp;T{}</li><li>make(xxxx)</li></ul><h3 id="3-1-分配流程总览"><a href="#3-1-分配流程总览" class="headerlink" title="3.1 分配流程总览"></a>3.1 分配流程总览</h3><p>Golang 中，依据 object 的大小，会将其分为下述三类:</p><ul><li>tiny 微对象 0-16B</li><li>small 小对象 16B-32KB</li><li>large 大对象 32KB+</li></ul><p>不同类型的对象，会有着不同的分配策略, 核心流程类似于读多级缓存的过程，由上而下，每一步只要成功则直接返回. 若失败，则由下层方法兜底.</p><p><strong>微对象的分配流程：</strong></p><ol><li>从 P 专属 mcache 的 tiny 分配器取内存（无锁）</li><li>根据所属的 spanClass，从 P 专属 mcache 缓存的 mspan 中取内存（无锁）</li><li>根据所属的 spanClass 从对应的 mcentral 中取 mspan 填充到 mcache，然后从 mspan 中取内存（spanClass 粒度锁）</li><li>根据所属的 spanClass，从 mheap 的页分配器 pageAlloc 取得足够数量空闲页组装成 mspan 填充到 mcache，然后从 mspan 中取内存（全局锁）</li><li>mheap 向操作系统申请内存，更新页分配器的索引信息，然后重复 4</li></ol><p>对于小对象的分配流程是跳过（1）步，执行上述流程的（2）-（5）步<br>对于大对象的分配流程是跳过（1）-（3）步，执行上述流程的（4）-（5）步</p><h3 id="3-2-主干方法-mallocgc"><a href="#3-2-主干方法-mallocgc" class="headerlink" title="3.2 主干方法 mallocgc"></a>3.2 主干方法 mallocgc</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">    <span class="comment">// 获取 m</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// 获取当前 p 对应的 mcache</span></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line">    <span class="keyword">var</span> span *mspan</span><br><span class="line">    <span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">    <span class="comment">// 根据当前对象是否包含指针，标识 gc 时是否需要展开扫描</span></span><br><span class="line">    noscan := typ == <span class="literal">nil</span> || typ.ptrdata == <span class="number">0</span></span><br><span class="line">    <span class="comment">// 是否是小于 32KB 的微、小对象</span></span><br><span class="line">    <span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line">    <span class="comment">// 小于 16 B 且无指针，则视为微对象</span></span><br><span class="line">        <span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">        <span class="comment">// tiny 内存块中，从 offset 往后有空闲位置</span></span><br><span class="line">          off := c.tinyoffset</span><br><span class="line">          <span class="comment">// 如果大小为 5 ~ 8 B，size 会被调整为 8 B，此时 8 &amp; 7 == 0，会走进此分支</span></span><br><span class="line">          <span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 将 offset 补齐到 8 B 倍数的位置</span></span><br><span class="line">                off = alignUp(off, <span class="number">8</span>)</span><br><span class="line">                <span class="comment">// 如果大小为 3 ~ 4 B，size 会被调整为 4 B，此时 4 &amp; 3 == 0，会走进此分支  </span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">           <span class="comment">// 将 offset 补齐到 4 B 倍数的位置</span></span><br><span class="line">                off = alignUp(off, <span class="number">4</span>)</span><br><span class="line">                <span class="comment">// 如果大小为 1 ~ 2 B，size 会被调整为 2 B，此时 2 &amp; 1 == 0，会走进此分支  </span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 将 offset 补齐到 2 B 倍数的位置</span></span><br><span class="line">                off = alignUp(off, <span class="number">2</span>)</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">// 如果当前 tiny 内存块空间还够用，则直接分配并返回</span></span><br><span class="line">            <span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 分配空间</span></span><br><span class="line">                x = unsafe.Pointer(c.tiny + off)</span><br><span class="line">                c.tinyoffset = off + size</span><br><span class="line">                c.tinyAllocs++</span><br><span class="line">                mp.mallocing = <span class="number">0</span></span><br><span class="line">                releasem(mp)  </span><br><span class="line">                <span class="keyword">return</span> x</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 分配一个新的 tiny 内存块</span></span><br><span class="line">            span = c.alloc[tinySpanClass]    </span><br><span class="line">            <span class="comment">// 从 mCache 中获取</span></span><br><span class="line">            v := nextFreeFast(span)        </span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 从 mCache 中获取失败，则从 mCentral 或者 mHeap 中获取进行兜底</span></span><br><span class="line">                v, span, shouldhelpgc = c.nextFree(tinySpanClass)</span><br><span class="line">            &#125;   </span><br><span class="line"><span class="comment">// 分配空间      </span></span><br><span class="line">            x = unsafe.Pointer(v)</span><br><span class="line">           (*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">           (*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">           size = maxTinySize</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 根据对象大小，映射到其所属的 span 的等级(0~66）</span></span><br><span class="line">          <span class="keyword">var</span> sizeclass <span class="type">uint8</span></span><br><span class="line">          <span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">              sizeclass = size_to_class8[divRoundUp(size, smallSizeDiv)]</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              sizeclass = size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]</span><br><span class="line">          &#125;        </span><br><span class="line">          <span class="comment">// 对应 span 等级下，分配给每个对象的空间大小(0~32KB)</span></span><br><span class="line">          size = <span class="type">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">          <span class="comment">// 创建 spanClass 标识，其中前 7 位对应为 span 的等级(0~66)，最后标识表示了这个对象 gc 时是否需要扫描</span></span><br><span class="line">          spc := makeSpanClass(sizeclass, noscan) </span><br><span class="line">          <span class="comment">// 获取 mcache 中的 span</span></span><br><span class="line">          span = c.alloc[spc]  </span><br><span class="line">          <span class="comment">// 从 mcache 的 span 中尝试获取空间        </span></span><br><span class="line">          v := nextFreeFast(span)</span><br><span class="line">          <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">          <span class="comment">// mcache 分配空间失败，则通过 mcentral、mheap 兜底            </span></span><br><span class="line">             v, span, shouldhelpgc = c.nextFree(spc)</span><br><span class="line">          &#125;     </span><br><span class="line">          <span class="comment">// 分配空间  </span></span><br><span class="line">          x = unsafe.Pointer(v)</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">       &#125;      </span><br><span class="line">       <span class="comment">// 大于 32KB 的大对象      </span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 从 mheap 中获取 0 号 span</span></span><br><span class="line">       span = c.allocLarge(size, noscan)</span><br><span class="line">       span.freeindex = <span class="number">1</span></span><br><span class="line">       span.allocCount = <span class="number">1</span></span><br><span class="line">       size = span.elemsize         </span><br><span class="line">       <span class="comment">// 分配空间   </span></span><br><span class="line">        x = unsafe.Pointer(span.base())</span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">return</span> x</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure><h3 id="3-3-步骤（1）：tiny-分配"><a href="#3-3-步骤（1）：tiny-分配" class="headerlink" title="3.3 步骤（1）：tiny 分配"></a>3.3 步骤（1）：tiny 分配</h3><p>每个 P 独有的 mcache 会有个微对象分配器，基于 offset 线性移动的方式对微对象进行分配，每 16B 成块，对象依据其大小，会向上取整为 2 的整数次幂进行空间补齐，然后进入分配流程</p><h3 id="3-4-步骤（2）：mcache-分配"><a href="#3-4-步骤（2）：mcache-分配" class="headerlink" title="3.4 步骤（2）：mcache 分配"></a>3.4 步骤（2）：mcache 分配</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据对象大小，映射到其所属的 span 的等级(0~66）</span></span><br><span class="line"><span class="keyword">var</span> sizeclass <span class="type">uint8</span></span><br><span class="line"><span class="comment">// get size class ....     </span></span><br><span class="line"><span class="comment">// 对应 span 等级下，分配给每个对象的空间大小(0~32KB)</span></span><br><span class="line"><span class="comment">// get span class</span></span><br><span class="line">spc := makeSpanClass(sizeclass, noscan) </span><br><span class="line"><span class="comment">// 获取 mcache 中的 span</span></span><br><span class="line">span = c.alloc[spc]  </span><br><span class="line"><span class="comment">// 从 mcache 的 span 中尝试获取空间        </span></span><br><span class="line">v := nextFreeFast(span)</span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// mcache 分配空间失败，则通过 mcentral、mheap 兜底            </span></span><br><span class="line">   v, span, shouldhelpgc = c.nextFree(spc)</span><br><span class="line">&#125;     </span><br><span class="line"><span class="comment">// 分配空间  </span></span><br><span class="line">x = unsafe.Pointer(v)</span><br></pre></td></tr></table></figure><h3 id="3-5-步骤（3）：mcentral-分配"><a href="#3-5-步骤（3）：mcentral-分配" class="headerlink" title="3.5 步骤（3）：mcentral 分配"></a>3.5 步骤（3）：mcentral 分配</h3><ul><li>当 mspan 无可用的 object 内存块时，会步入 mcache.nextFree 方法进行兜底.</li><li>倘若 mcache 中，对应的 mspan 空间不足，则会在 mcache.refill 方法中，向更上层的 mcentral 乃至 mheap 获取 mspan，填充到 mache 中</li><li>mcentral.cacheSpan 方法中，会加锁（spanClass 级别的 sweepLocker），分别从 partial 和 full 中尝试获取有空间的 mspan</li></ul><h3 id="3-6-步骤（4）：mheap-分配"><a href="#3-6-步骤（4）：mheap-分配" class="headerlink" title="3.6 步骤（4）：mheap 分配"></a>3.6 步骤（4）：mheap 分配</h3><p>在 mcentral.cacheSpan 方法中，倘若从 partial 和 full 中都找不到合适的 mspan 了，则会调用 mcentral 的 grow 方法，将事态继续升级<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> cacheSpan() *mspan &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// mcentral 中也没有可用的 mspan 了，则需要从 mheap 中获取，最终会调用 mheap_.alloc 方法</span></span><br><span class="line">    s = c.grow()</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行到此处时，s 已经指向一个存在 object 空位的 mspan 了</span></span><br><span class="line">havespan:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>经由 mcentral.grow 方法和 mheap.alloc 方法的周转，最终会步入 mheap.allocSpan 方法中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> grow() *mspan &#123;</span><br><span class="line">    npages := <span class="type">uintptr</span>(class_to_allocnpages[c.spanclass.sizeclass()])</span><br><span class="line">    size := <span class="type">uintptr</span>(class_to_size[c.spanclass.sizeclass()])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    s := mheap_.alloc(npages, c.spanclass)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> alloc(npages <span class="type">uintptr</span>, spanclass spanClass) *mspan &#123;</span><br><span class="line">    <span class="keyword">var</span> s *mspan</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        s = h.allocSpan(npages, spanAllocHeap, spanclass)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> allocSpan(npages <span class="type">uintptr</span>, typ spanAllocType, spanclass spanClass) (s *mspan) &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    base, scav := <span class="type">uintptr</span>(<span class="number">0</span>), <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...此处实际上还有一阶缓存，是从每个 P 的页缓存 pageCache 中获取空闲页组装 mspan，此处先略去了...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加上堆全局锁</span></span><br><span class="line">    lock(&amp;h.lock)</span><br><span class="line">    <span class="keyword">if</span> base == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 通过基数树索引快速寻找满足条件的连续空闲页</span></span><br><span class="line">        base, scav = h.pages.alloc(npages)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    unlock(&amp;h.lock)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HaveSpan:</span><br><span class="line">    <span class="comment">// 把空闲页组装成 mspan</span></span><br><span class="line">    s.init(base, npages)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将这批页添加到 heapArena 中，建立由页指向 mspan 的映射</span></span><br><span class="line">    h.setSpans(s.base(), npages, s)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-步骤（5）：向操作系统申请"><a href="#3-7-步骤（5）：向操作系统申请" class="headerlink" title="3.7 步骤（5）：向操作系统申请"></a>3.7 步骤（5）：向操作系统申请</h3><p>倘若 mheap 中没有足够多的空闲页了，会发起 mmap 系统调用，向操作系统申请额外的内存空间</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Golang的内存管理是基于TCMalloc的核心思想来构建的，内存管理本质上是一个&lt;strong&gt;内存池和多级对象管理&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="内存管理" scheme="https://stardustorz.github.io/categories/Golang/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Go] Channel</title>
    <link href="https://stardustorz.github.io/2022/07/14/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Channel/"/>
    <id>https://stardustorz.github.io/2022/07/14/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Channel/</id>
    <published>2022-07-13T16:00:00.000Z</published>
    <updated>2025-05-25T10:29:22.935Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习 golang 中的 chan，并分析其具体实现，包括创建 channel，发送数据，接收数据以及相关调度等。</p></blockquote><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><blockquote><p>A channel provides a mechanism for concurrently executing functions to communicate by sending and receiving values of a specified element type. The value of an uninitialized channel is nil.</p></blockquote><p>chan 提供了一种并发通信机制，用于生产和消费某一指定类型数据，未初始化的 chan 的值是nil。</p><p> <strong>使用场景：</strong> 消息传递、消息过滤，信号广播，事件订阅与广播，请求、响应转发，任务分发，结果汇总，并发控制，限流，同步与异步</p><h2 id="2-特性与实现"><a href="#2-特性与实现" class="headerlink" title="2 特性与实现"></a>2 特性与实现</h2><p>Chan 是 Go 里面的一种数据结构，具有以下特性：</p><ul><li>goroutine-safe，多个 goroutine 可以同时访问一个 channel 而不会出现并发问题</li><li>可以用于在 goroutine 之间存储和传递值</li><li>先入先出（FIFO）</li><li>可以导致 goroutine 的 block 和 unblock<h3 id="2-1-内部结构"><a href="#2-1-内部结构" class="headerlink" title="2.1 内部结构"></a>2.1 内部结构</h3></li></ul><p>主要包含以下几个部分：</p><ul><li>circular queue：循环队列，用于存储数据</li><li>send index 记录发送的位置</li><li>receive index 记录接收的位置</li><li>mutex 锁，用于实现 goroutine safe。</li></ul><p>元素队列的具体实现很简单，就是一个环形队列，使用 sendx 和 recvx 分别用来记录发送、接收的 offset，然后通过 mutex 互斥锁来保证并发安全。</p><h3 id="2-2-创建-chan"><a href="#2-2-创建-chan" class="headerlink" title="2.2 创建 chan"></a>2.2 创建 chan</h3><p>chan 使用 make 进行初始化，第一个参数指定 chan 中的元素类型，第二个参数用于指定 chan 的缓冲区大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>make 返回的 ch 实际上是一个指向 heap 中真正的 chan 对象的指针。<br><strong>chan（即 hchan 结构体） 默认会被分配在堆上，make 返回的只是一个指向该对象的指针</strong>。</p><blockquote><p>可以在函数之间传递 chan，而不是 chan 的指针。 因为 chan 本身就是指针</p></blockquote><h3 id="2-3-发送、接收与关闭"><a href="#2-3-发送、接收与关闭" class="headerlink" title="2.3 发送、接收与关闭"></a>2.3 发送、接收与关闭</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Task, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> _,task := <span class="keyword">range</span> helloTasks &#123;</span><br><span class="line">    taskCh &lt;- task <span class="comment">// 发送</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(tashCh) <span class="comment">// 关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ch)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        task:= &lt;-taskCh <span class="comment">// 接收</span></span><br><span class="line">        process(task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main goroutine 发送 task 到 chan，然后 worker goroutine 从 chan 中接收 task 并处理，最后 main goroutine 发送完成后关闭 chan。<br>具体<strong>发送过程</strong>如下：</p><ul><li>acquire 加锁</li><li>enqueue，将 task 对象<strong>拷贝</strong>到数组里</li><li>release 释放锁</li></ul><p>对于 chan 的关闭，最佳实践是由发送方进行关闭。<br><strong>接收过程</strong>：</p><ul><li>acquire 加锁</li><li>dequeue<ul><li>将 task 对象从 数组 中 <strong>拷贝</strong>出来赋值给用户用于接收的对象</li><li><code>task:= &lt;-taskCh</code>,比如这里就是拷贝出来赋值给 task</li></ul></li><li>release 释放锁</li></ul><p>整个过程中没有任何共享内存，数据都是通过 copy 进行传递,这遵循了 Go 并发设计中很核心的一个理念：</p><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating.</p></blockquote><h3 id="2-4-阻塞与唤醒"><a href="#2-4-阻塞与唤醒" class="headerlink" title="2.4 阻塞与唤醒"></a>2.4 阻塞与唤醒</h3><p>hchan 中的 buf 数组大小就是 make chan 时指定的大小。<br>当 buf 满之后再往 chan 中发送值就会阻塞。</p><blockquote><p>goroutine 调度：G 阻塞之后并不会阻塞 M。M 会先把这个 G 暂停(gopark)，然后把执行栈切换到 g0，g0 会执行 schedule() 函数，从当前 M 绑定的 P 中查找有没有可以执行的G，有就捞出来继续执行。</p></blockquote><h4 id="2-4-1-先发后收"><a href="#2-4-1-先发后收" class="headerlink" title="2.4.1 先发后收"></a>2.4.1 先发后收</h4><p>假设 chan 中已经有 3 个 task 了,然后再往里面发送一个</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskCh &lt;- task </span><br></pre></td></tr></table></figure><p>runtime 会调用 gopark 将这个 goroutine(姑且称作G1) 切换到 wait 状态。<br><em>什么时候会被唤醒呢？</em><br>hchan 结构体中还有 sendq、recvq 两个列表，分别记录了等待发送或者接收的 goroutine：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog</span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>比如前面被阻塞的 G1 就会存入 sendq</p></blockquote><p>假设此时 G2 从 chan 中取走一个消息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task:= &lt;-taskCh </span><br></pre></td></tr></table></figure><p>G2 取走一个消息后就会找到 sendq 中的第一个对象，把待发送的 elem 直接写入 buf 数组。然后 调用 goready 把对应的 goroutine  G1 设置为 runnable 状态。</p><h4 id="2-4-2-先收后发"><a href="#2-4-2-先收后发" class="headerlink" title="2.4.2 先收后发"></a>2.4.2 先收后发</h4><p>之前是先发送，后接收。现在看一下先接收后发送的情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task:= &lt;-taskCh </span><br></pre></td></tr></table></figure><p>G2 直接从空的 chan 中取消息，同样会被阻塞,然后被写入到 hchan 的 recqv 中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskCh &lt;- task </span><br></pre></td></tr></table></figure><p>按照上面的逻辑应该是，将 task 写入 buf 数组后，，再把 recvq 中的第一个 goroutine G2 唤醒。</p><p>但是 Go 官方这里进行了优化。因为 recvq 里的 elem 对象 t 存的就是<strong>接收者的内存地址</strong>。</p><p>所以我们可以直接把 G1 发送来的 task 写入 elem 对应的 t 里，即在 G1 里修改 G2 的栈对象。</p><blockquote><p>因为这个时候 G2 还是 gopark，处于 waiting 状态，所以不会出问题。</p><p>正常情况下因为不知道两个线程谁先谁后，这样改肯定会出问题。但是在 go runtime 这里，肯定是 G2 先执行，满足 happen-before 所以不存在问题。</p></blockquote><p>省去了发送和接收时的两次加解锁和内存拷贝。</p><h3 id="2-5-特性实现原理"><a href="#2-5-特性实现原理" class="headerlink" title="2.5 特性实现原理"></a>2.5 特性实现原理</h3><ul><li><strong>goroutine-safe</strong>.<ul><li>hchan <strong>mutex</strong>，通过加锁来避免数据竞争。</li></ul></li><li>可以用于在 goroutine 之间存储和传递值，以及先入先出（FIFO）语义。<ul><li>copying into and out of hchan <strong>buffer</strong></li></ul></li><li>可以导致 goroutine 的 block 和 unblock<ul><li>通过 <strong>sudog queues</strong> 来记录阻塞的 goroutine。</li><li>通过 <strong>runtime scheduler</strong>(gopark, goready)来实现阻塞与唤醒。</li></ul></li></ul><h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3 源码分析"></a>3 源码分析</h2><p><code>runtime/chan.go</code></p><h3 id="3-1-内部结构"><a href="#3-1-内部结构" class="headerlink" title="3.1 内部结构"></a>3.1 内部结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="type">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">dataqsiz <span class="type">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">elemsize <span class="type">uint16</span></span><br><span class="line">closed   <span class="type">uint32</span></span><br><span class="line">elemtype *_type <span class="comment">// element type</span></span><br><span class="line">sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line">recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog</span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">    g *g</span><br><span class="line">    next *sudog</span><br><span class="line">    prev *sudog</span><br><span class="line">    elem unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line">    isSelect <span class="type">bool</span></span><br><span class="line">    c        *hchan </span><br><span class="line">&#125;<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- qcount：当前 channel 中存在多少个元素；</span></span><br><span class="line"><span class="string">- dataqsize: 当前 channel 能存放的元素容量；</span></span><br><span class="line"><span class="string">- buf：channel 中用于存放元素的环形缓冲区；</span></span><br><span class="line"><span class="string">- elemsize：channel 元素类型的大小；</span></span><br><span class="line"><span class="string">- closed：标识 channel 是否关闭；</span></span><br><span class="line"><span class="string">- elemtype：channel 元素类型；</span></span><br><span class="line"><span class="string">- sendx：发送元素进入环形缓冲区的 index；</span></span><br><span class="line"><span class="string">- recvx：接收元素所处的环形缓冲区的 index；</span></span><br><span class="line"><span class="string">- recvq：因接收而陷入阻塞的协程队列；</span></span><br><span class="line"><span class="string">- sendq：因发送而陷入阻塞的协程队列；</span></span><br><span class="line"><span class="string">- waitq：阻塞的协程队列</span></span><br><span class="line"><span class="string">- first：队列头部</span></span><br><span class="line"><span class="string">- last：队列尾部</span></span><br><span class="line"><span class="string">- sudog：用于包装协程的节点</span></span><br><span class="line"><span class="string">- g：goroutine，协程；</span></span><br><span class="line"><span class="string">- next：队列中的下一个节点；</span></span><br><span class="line"><span class="string">- prev：队列中的前一个节点；</span></span><br><span class="line"><span class="string">- elem: 读取/写入 channel 的数据的容器;</span></span><br><span class="line"><span class="string">- isSelect：标识当前协程是否处在 select 多路复用的流程中；</span></span><br><span class="line"><span class="string">- c：标识与当前 sudog 交互的 chan.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 3.2 构造器函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在源码中通道的创建由 makechan 方法实现：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;&#125;</span><br></pre></td></tr></table></figure><p>然后还有两个包装方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname reflect_makechan reflect.makechan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line"><span class="keyword">return</span> makechan(t, size)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan64</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="type">int64</span>(<span class="type">int</span>(size)) != size &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> makechan(t, <span class="type">int</span>(size))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部都是调用的 makechan 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">elem := t.elem</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器检查 typesize 和 align</span></span><br><span class="line"><span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算存放数据元素的内存大小以及是否溢出</span></span><br><span class="line">mem, overflow := math.MulUintptr(elem.size, <span class="type">uintptr</span>(size))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c *hchan</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line">c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">c.buf = c.raceaddr()</span><br><span class="line"><span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>:</span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">c = <span class="built_in">new</span>(hchan)</span><br><span class="line">c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">c.elemsize = <span class="type">uint16</span>(elem.size)</span><br><span class="line">c.elemtype = elem</span><br><span class="line">c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line">lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体流程如下：</p><ul><li>判断申请内存空间大小是否越界，mem 大小为 element 类型大小与 element 个数相乘后得到，仅当无缓冲型 channel 时，因个数为 0 导致大小为 0；</li><li>根据类型，初始 channel，分为 无缓冲型、有缓冲元素为 struct 型、有缓冲元素为 pointer 型 channel;</li><li>倘若为无缓冲型，则仅申请一个大小为默认值 96 的空间；</li><li>如若有缓冲的 struct 型，则一次性分配好 96 + mem 大小的空间，并且调整 chan 的 buf 指向 mem 的起始位置；</li><li>倘若为有缓冲的 pointer 型，则分别申请 chan 和 buf 的空间，两者无需连续；</li><li>对 channel 的其余字段进行初始化，包括元素类型大小、元素类型、容量以及锁的初始化.</li></ul><h3 id="3-2-写流程"><a href="#3-2-写流程" class="headerlink" title="3.2 写流程"></a>3.2 写流程</h3><p>发送数据到channel时：</p><ul><li>先判断是否有等待接收数据的 groutine，如果有，直接将数据发给 groutine，唤醒 groutine，就不放入队列中了。省去了两次内存拷贝和加锁的开销</li><li>另外一种情况：队列如果满了，那就只能放到队列中等待，直到有数据被取走才能发送。<h4 id="3-2-1-调用链"><a href="#3-2-1-调用链" class="headerlink" title="3.2.1 调用链"></a>3.2.1 调用链</h4></li></ul><p>chan 的发送逻辑涉及到5个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendDirect</span><span class="params">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;…&#125;</span><br></pre></td></tr></table></figure><p>chansend1 方法是 go编译代码中<code>c &lt;- x</code>这种写法的入口点，即当我们编写代码<code>c &lt;- x</code>其实就是调用此方法。<br>这四个方法的调用关系：<code>chansend1 -&gt; chansend -&gt; send -&gt; sendDirect</code><br>具体发送逻辑在<code>chansend</code>这个方法里，然后真正使用的方法其实是对该方法的一层包装。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">chansend(c, elem, <span class="literal">true</span>, getcallerpc())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> chansend(c, elem, <span class="literal">false</span>, getcallerpc())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-chansend"><a href="#3-2-2-chansend" class="headerlink" title="3.2.2 chansend"></a>3.2.2 chansend</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 channel 是否为 nil</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !block &#123;<span class="comment">// 如果非阻塞，直接返回 false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 当向 nil channel 发送数据时，会调用 gopark</span></span><br><span class="line"><span class="comment">// 而 gopark 会将当前的 goroutine 休眠，并用过第一个参数的 unlockf 来回调唤醒</span></span><br><span class="line"><span class="comment">// 但此处传递的参数为 nil，因此向 channel 发送数据的 goroutine 和接收数据的 goroutine 都会阻塞，进而死锁</span></span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racereadpc(c.raceaddr(), callerpc, funcPC(chansend))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于不阻塞的 send，快速检测失败场景</span></span><br><span class="line"><span class="comment">// 如果 channel 未关闭且 channel 没有多余的缓冲空间。这可能是：</span></span><br><span class="line"><span class="comment">// 1. channel 是非缓冲型的，且等待接收队列里没有 goroutine</span></span><br><span class="line"><span class="comment">// 2. channel 是缓冲型的，但循环数组已经装满了元素</span></span><br><span class="line"><span class="comment">// 主要用于 select 语句中，涉及到指令重排队+可观测性</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; full(c) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加锁,避免竞争</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"><span class="comment">// 检查 channel 是否已关闭，不允许向关闭的 channel 发送数据</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>)) <span class="comment">// 直接panic</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从 recvq 队首取出一个接收者，如果存在接收者，就绕过环形队列（buf）直接把 ep 拷贝给 sg，并释放锁</span></span><br><span class="line">    <span class="comment">// 这就是前面提到的，官方做的一个优化，如果有goroutine在等待就直接把数据给该goroutine，没必要在写到buf，然后接收者又从buf中拷贝出来</span></span><br><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 到这里说明当前没有等待状态的接收者</span></span><br><span class="line"><span class="comment">// 如果环形队列还未满</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="comment">// 拿到 sendx 索引的位置</span></span><br><span class="line">qp := chanbuf(c, c.sendx)</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racenotify(c, c.sendx, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 直接把数据从 qp 拷贝到 qp，就是把数据拷贝到环形队列中</span></span><br><span class="line">typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        <span class="comment">// 维护 snedx 的值，因为是环形队列，所以到最大值时就重置为0</span></span><br><span class="line">c.sendx++</span><br><span class="line"><span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">c.sendx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//qcount即当前chan中的元素个数</span></span><br><span class="line">c.qcount++</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 到这里说明环形队列已经满了</span></span><br><span class="line"><span class="comment">// 如果还是要非阻塞的方式发送，就只能返回错误了</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 到这里说明缓存队列满了，然后调用法指定是阻塞方式进行发送</span></span><br><span class="line"><span class="comment">// channel 满了，发送方会被阻塞。接下来会构造一个 sudog</span></span><br><span class="line">gp := getg()<span class="comment">// 获取当前 goroutine</span></span><br><span class="line">mysg := acquireSudog()<span class="comment">// 从对象池获取 sudog</span></span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 把发送的数据(ep)、当前g(gp)、已经当前这个chan(c)都存到sudog中</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">    <span class="comment">// 保存当前 sudog，下面要用到做校验</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">     <span class="comment">// 把这个sudog存入sendq队列</span></span><br><span class="line">c.sendq.enqueue(mysg)</span><br><span class="line">atomic.Store8(&amp;gp.parkingOnChan, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 调用gopark，挂起当前的 g，将当前的 g 移出调度器的队列</span></span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 等到有接收者从chan中取值的时候，这个发送的g又会被重新调度，然后从这里开始继续执行</span></span><br><span class="line">KeepAlive(ep)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检验是否为当前的 sudog</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">gp.activeStackChans = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 这里sudog中的success表示的是当前这个通道上是否进行过通信</span></span><br><span class="line">    <span class="comment">// 为 true 则说明是真正的唤醒，chan上有活动（有数据写进来，或者有数据被读取出去）</span></span><br><span class="line">    <span class="comment">// 为 false 则说明是假的唤醒，即当前唤醒是否关闭chan导致的</span></span><br><span class="line">    <span class="comment">// 这里主要根据这个值判断chan是否被关闭了</span></span><br><span class="line">closed := !mysg.success</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 将 sudog 放回对象池</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">if</span> closed &#123;</span><br><span class="line">        <span class="comment">// 如果chan被关闭了也是直接panic</span></span><br><span class="line"><span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;chansend: spurious wakeup&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心逻辑</p><ul><li>如果recvq不为空，从recvq中取出一个等待接收数据的Groutine，直接将数据发送给该Groutine</li><li>如果recvq为空，才将数据放入buf中</li><li>如果buf已满，则将要发送的数据和当前的Groutine打包成Sudog对象放入sendq，并将groutine置为等待状态</li><li>等goroutine再次被调度时程序继续执行</li></ul><h4 id="3-2-3-send"><a href="#3-2-3-send" class="headerlink" title="3.2.3 send"></a>3.2.3 send</h4><p>然后追踪一下 send 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 忽略 race 检查..</span></span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 直接拷贝到接受者内存，使用写屏障</span></span><br><span class="line">sendDirect(c.elemtype, sg, ep)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g <span class="comment">// 取出sudog中记录的g，这里的g就是被阻塞接收者</span></span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg) <span class="comment">// 更新接收者g的param字段，在recv方法中会用到</span></span><br><span class="line">sg.success = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 最后把被阻塞的接收者g唤醒</span></span><br><span class="line">goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-4-sendDirect"><a href="#3-2-4-sendDirect" class="headerlink" title="3.2.4 sendDirect"></a>3.2.4 sendDirect</h4><p>继续看sendDirect 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendDirect</span><span class="params">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;</span><br><span class="line"><span class="comment">// src 在当前 goroutine 的栈上，dst 是另一个 goroutine 的栈</span></span><br><span class="line">    <span class="comment">// 直接进行内存&quot;搬迁&quot;</span></span><br><span class="line"><span class="comment">// 如果目标地址的栈发生了栈收缩，当我们读出了 sg.elem 后</span></span><br><span class="line"><span class="comment">// 就不能修改真正的 dst 位置的值了</span></span><br><span class="line"><span class="comment">// 因此需要在读和写之前加上一个屏障</span></span><br><span class="line">dst := sg.elem</span><br><span class="line">typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.size)</span><br><span class="line"> <span class="comment">// 拷贝内存</span></span><br><span class="line">memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到一个 goroutine 直接写另一个 goroutine 栈的操作，一般而言，不同 goroutine 的栈是各自独有的。而这也违反了 GC 的一些假设。为了不出问题，写的过程中增加了写屏障，保证正确地完成写操作。这样做的好处是减少了一次内存 copy：不用先拷贝到 channel 的 buf，直接由发送者到接收者。</p><h3 id="3-3-读流程"><a href="#3-3-读流程" class="headerlink" title="3.3 读流程"></a>3.3 读流程</h3><p>从channel读取数据的流程和发送的类似，基本是发送操作的逆操作。<br>这里同样存在和send一样的优化：从channel读取数据时，不是直接去环形队列中去数据，而是先判断是否有等待发送数据的groutine。如果有，直接将groutine出队列，取出数据返回，并唤醒groutine。如果没有等待发送数据的groutine，再从环形队列中取数据。</p><h4 id="3-3-1-调用链"><a href="#3-3-1-调用链" class="headerlink" title="3.3.1 调用链"></a>3.3.1 调用链</h4><p>chan的接收涉及到7个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_chanrecv</span><span class="params">(c *hchan, nb <span class="type">bool</span>, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>, received <span class="type">bool</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span></span> (selected, received <span class="type">bool</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;…&#125;，</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvDirect</span><span class="params">(t *_type, sg *sudog, dst unsafe.Pointer)</span></span> &#123;…&#125;</span><br></pre></td></tr></table></figure><p>按照发送时的套路可知，只有 chanrecv 是具体逻辑，上面几个都是包装方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname reflect_chanrecv reflect.chanrecv</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_chanrecv</span><span class="params">(c *hchan, nb <span class="type">bool</span>, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>, received <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> chanrecv(c, elem, !nb)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) &#123;</span><br><span class="line">_, received = chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收操作有两种写法，一种带 “ok”，反应 channel 是否关闭；</p><p>一种不带 “ok”，这种写法，当接收到相应类型的零值时无法知道是真实的发送者发送过来的值，还是 channel 被关闭后，返回给接收者的默认类型的零值。</p><p>两种写法，都有各自的应用场景。</p><p>经过编译器的处理后，这两种写法最后对应源码里的就是不带<code>ok</code>的<code>chanrecv1</code>和带<code>ok</code>的<code>chanrecv2</code>这两个函数。</p><h4 id="3-3-2-chanrecv"><a href="#3-3-2-chanrecv" class="headerlink" title="3.3.2 chanrecv"></a>3.3.2 chanrecv</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chanrecv 函数接收 channel c 的元素并将其写入 ep 所指向的内存地址。</span></span><br><span class="line"><span class="comment">// 如果 ep 是 nil，说明忽略了接收值。比如 &lt;-ch 这样，没有接收取到的值</span></span><br><span class="line"><span class="comment">// 如果 block == false，即非阻塞型接收，在没有数据可接收的情况下，返回 (false, false)</span></span><br><span class="line"><span class="comment">// 否则，如果 c 处于关闭状态，将 ep 指向的地址清零，返回 (true, false)</span></span><br><span class="line"><span class="comment">// 否则，用返回值填充 ep 指向的内存地址。返回 (true, true)</span></span><br><span class="line"><span class="comment">// 如果 ep 非空，则应该指向堆或者函数调用者的栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="comment">// 如果是一个 nil 的 channel</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不阻塞，直接返回 (false, false)</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 否则，接收一个 nil 的 channel，调用gopark将goroutine 挂起</span></span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>) <span class="comment">// 被挂起之后不会执行到这一句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这块主要用在 select 语句中，先大概了解下，比较难懂。。。</span></span><br><span class="line"><span class="comment">// 快速路径: 在不需要锁的情况下检查失败的非阻塞操作</span></span><br><span class="line"><span class="comment">// 注意到 channel 不能由已关闭转换为未关闭，则失败的条件是：</span></span><br><span class="line"><span class="comment">// 1. channel 是非缓冲型的，recvq 队列为空</span></span><br><span class="line"><span class="comment">// 2. channel 是缓冲型的，buf 为空</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; empty(c) &#123;</span><br><span class="line"><span class="comment">// 此处的 c.closed 必须在条件判断之后进行验证，</span></span><br><span class="line">        <span class="comment">// 因为指令重排后，如果先判断 c.closed，得出 channel 未关闭，无法判断失败条件中channel 是已关闭还是未关闭（从而需要 atomic 操作）</span></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再次检查 channel 是否为空</span></span><br><span class="line"><span class="keyword">if</span> empty(c) &#123;</span><br><span class="line"><span class="comment">// 接收者不为 nil 时返回该类型的零值</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// typedmemclr 逻辑是根据类型清理相应地址的内存</span></span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 返回（true,fasle）</span></span><br><span class="line">            <span class="comment">// 返回值1--true：表示被 select case 选中，</span></span><br><span class="line">            <span class="comment">// 返回值2--fasle 表示是否正常收到数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加锁，保证并发安全</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"><span class="comment">// channel 已关闭，并且循环数组 buf 里没有元素</span></span><br><span class="line"><span class="comment">// 这里可以处理非缓冲型关闭 和 缓冲型关闭但 buf 无元素的情况</span></span><br><span class="line"><span class="comment">// 也就是说即使是关闭状态，但在缓冲型的 channel，</span></span><br><span class="line"><span class="comment">// buf 里有元素的情况下还能接收到元素</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待发送队列里有 goroutine 存在，说明 buf 是满的</span></span><br><span class="line"><span class="comment">// 这有可能是：</span></span><br><span class="line"><span class="comment">// 1. 非缓冲型的 channel</span></span><br><span class="line"><span class="comment">// 2. 缓冲型的 channel，但 buf 满了</span></span><br><span class="line"><span class="comment">// 针对 1，直接进行内存拷贝（从 sender goroutine -&gt; receiver goroutine）</span></span><br><span class="line"><span class="comment">// 针对 2，接收到循环数组头部的元素，并将发送者的元素放到循环数组尾部</span></span><br><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// chan的buf 里有元素，可以正常接收</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 直接从循环数组里找到要接收的元素</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line">        <span class="comment">// ep != nil表示代码里，没有忽略要接收的值</span></span><br><span class="line">        <span class="comment">// 即接收的代码不是 &quot;&lt;- ch&quot;，而是 &quot;val &lt;- ch&quot;这种，ep 指向 val</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 清理掉循环数组里相应位置的值</span></span><br><span class="line">typedmemclr(c.elemtype, qp)</span><br><span class="line">        <span class="comment">// 维护接收游标</span></span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// buf 数组里的元素个数减 1</span></span><br><span class="line">c.qcount--</span><br><span class="line">        <span class="comment">// 处理完成，解锁返回</span></span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 到这里说明chan的buf里没有数据了，如果是非阻塞接收就直接返回了</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来就是要被阻塞的情况了</span></span><br><span class="line">    <span class="comment">// 和发送类似的，构造一个 sudog</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 这里需要注意一下，ep就是我们用来接收值得对象</span></span><br><span class="line">    <span class="comment">// 这里把ep直接存到sudog.elem字段上</span></span><br><span class="line">mysg.elem = ep </span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg <span class="comment">// 这个waiting同样是用来唤醒后做校验的</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 加入到chan的recvq队列里</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line">atomic.Store8(&amp;gp.parkingOnChan, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 将当前 goroutine 挂起</span></span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒后，继续往下执行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同样是进行数据校验</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">gp.activeStackChans = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 又是mysg.success，如果chan活动过就是true，否则是false</span></span><br><span class="line">success := mysg.success</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)<span class="comment">// 将 sudog 放回对象池</span></span><br><span class="line">    <span class="comment">// 到这里如果goroutine被正常唤醒肯定是可以取到数据的</span></span><br><span class="line">    <span class="comment">// 因为recvq的数据是由发送的时候直接copy过来了</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, success</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-3-3-recv"><a href="#3-3-3-recv" class="headerlink" title="3.3.3 recv"></a>3.3.3 recv</h4><p>继续追踪一下 recv 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 非缓冲型的 channel</span></span><br><span class="line"><span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 并且需要接收值</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 直接进行内存拷贝</span></span><br><span class="line">recvDirect(c.elemtype, sg, ep)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 需要注意：进入recv方法说明sendq队列里是有值的</span></span><br><span class="line"><span class="comment">// 那么对缓冲型的 channel来说，sendq有值就意味着buf满了</span></span><br><span class="line">        <span class="comment">// 也就是 recvx和sendx重合了都</span></span><br><span class="line">        <span class="comment">// 这里要做的就是先从buf中读一个数据出来，然后再把发送者发送的数据写入buf</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"><span class="comment">// 将接收游标处的数据拷贝给接收者</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从发送者把数据写入 recvx</span></span><br><span class="line">typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">        <span class="comment">// 然后修改 recvx和sendx 的位置</span></span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">gp := sg.g</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 最后唤醒发送的 goroutine</span></span><br><span class="line">goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-4-recvDirect"><a href="#3-3-4-recvDirect" class="headerlink" title="3.3.4 recvDirect"></a>3.3.4 recvDirect</h4><p>再看一下 recvDirect：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvDirect</span><span class="params">(t *_type, sg *sudog, dst unsafe.Pointer)</span></span> &#123;</span><br><span class="line"><span class="comment">// 如果是非缓冲型的，就直接从发送者的栈拷贝到接收者的栈。</span></span><br><span class="line">    <span class="comment">// 和sendDirect一样的需要加内存屏障</span></span><br><span class="line">src := sg.elem</span><br><span class="line">typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.size)</span><br><span class="line">memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-5-小结"><a href="#3-3-5-小结" class="headerlink" title="3.3.5 小结"></a>3.3.5 小结</h4><ul><li>不管是接收还是发送只要被阻塞了，加入到了 sendq 或者 recvq 之后，那么后续的发送或者接收都是由对方进行处理了。</li><li>比如接收被阻塞了，当前 g 构成一个 sudog 然后加入到 recvq ，接着调用了 gopark 就已经阻塞,只能等到有发送者来的时候直接从 recvq 里把这个 sudog 取出来，并且直接把要他发送的值拷贝到这个 sudog.elem 字段上，也就是调用chan接收方法是传进来的哪个值.</li><li>最后发送方再调用 goready 把这个 g 给唤醒，这样再把剩下的逻辑走完，这个被阻塞了一会的接收者就可以拿着数据返回了。</li></ul><p>核心逻辑：</p><ul><li>如果有等待发送数据的 groutine，从 sendq 中取出一个等待发送数据的 groutine，取出数据</li><li>如果没有等待的 groutine，且环形队列中有数据，从队列中取出数据</li><li>如果没有等待的 groutine，且环形队列中也没有数据，则阻塞该 Groutine，并将 groutine 打包为 sudog 加入到 recevq 等待队列中</li></ul><h3 id="3-4-关闭"><a href="#3-4-关闭" class="headerlink" title="3.4 关闭"></a>3.4 关闭</h3><h4 id="3-4-1-调用链"><a href="#3-4-1-调用链" class="headerlink" title="3.4.1 调用链"></a>3.4.1 调用链</h4><p>close 就比较简单了，相关方法就两个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname reflect_chanclose reflect.chanclose</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_chanclose</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">closechan(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>其中一个还是包装方法，真正逻辑就在 clsoechan 里。</p><blockquote><p>每个逻辑都有一个 reflect_xxx 的方法，根据名字猜测是反射的时候用的。</p></blockquote><h4 id="3-4-2-closechan"><a href="#3-4-2-closechan" class="headerlink" title="3.4.2 closechan"></a>3.4.2 closechan</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 关闭一个nil的chan直接panic</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同样是先加锁</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// 判断一下是否被关闭过了，关闭一个已经关闭的chan也是直接panic</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改closed标记为，表示chan已经被关闭了</span></span><br><span class="line">c.closed = <span class="number">1</span></span><br><span class="line"><span class="comment">// gList 是通过 g.schedlink 链接 G 的列表，一个 G 只能是一次在一个 gQueue 或 gList 上</span></span><br><span class="line"><span class="comment">// gList 模拟的是栈操作（FILO）</span></span><br><span class="line"><span class="comment">// gQueue 模拟的是队列操作（FIFO）</span></span><br><span class="line"><span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放所有的接收者</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.recvq.dequeue()</span><br><span class="line">        <span class="comment">// sg == nil，表示接收队列已为空，跳出循环</span></span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 如果 elem 不为空说明未忽略接收值，赋值为该类型的零值</span></span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放所有的发送者</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.sendq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环读取 glist 里面的数据，挨个唤醒</span></span><br><span class="line"><span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">gp := glist.pop()</span><br><span class="line">gp.schedlink = <span class="number">0</span></span><br><span class="line">goready(gp, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心流程：</p><ul><li>设置关闭状态</li><li>唤醒所有等待读取chanel的协程</li><li>所有等待写入channel的协程，抛出异常</li></ul><h4 id="3-4-3-优雅关闭"><a href="#3-4-3-优雅关闭" class="headerlink" title="3.4.3 优雅关闭"></a>3.4.3 优雅关闭</h4><ul><li>只在发送端关闭 channel。（防止关闭后继续发送）</li><li>存在多个发送者时不要关闭发送者 channel，而是使用专门的 stop channel。 sync.Once，来保证关闭channel的操作只执行一次</li><li>作为函数参数的channel最好带方向</li></ul><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h2><h3 id="4-1-存储实现"><a href="#4-1-存储实现" class="headerlink" title="4.1 存储实现"></a>4.1 存储实现</h3><p>chan 内部使用一个环形队列实现存储，使用 sendx或recvx进行发送或读取。</p><h3 id="4-2-并发安全"><a href="#4-2-并发安全" class="headerlink" title="4.2 并发安全"></a>4.2 并发安全</h3><p>使用 mutex 保证并发安全。</p><h3 id="4-3-调度"><a href="#4-3-调度" class="headerlink" title="4.3 调度"></a>4.3 调度</h3><p>使用 sendq 和 recvq来暂存由于发送或接收而被阻塞的goroutine。<br>send/recv的时候都会判断recvq/sendq是否有goroutine正在等待，有则优先处理。</p><h4 id="4-3-1-发送"><a href="#4-3-1-发送" class="headerlink" title="4.3.1 发送"></a>4.3.1 发送</h4><p><strong>发送</strong>的时候发现recvq有goroutine正在等待，说明此时chan的buf是空的，或者chan是个非缓存chan，根本没有buf。<br>对于发送来说，不管是buf为空还是chan没有buf都是一样的处理逻辑。<br>此时会直接从recvq中取出第一个g，然后把本次要发送的数据直接写给这个接收者g，并调用goready把这个g唤醒。</p><h4 id="4-3-2-接收"><a href="#4-3-2-接收" class="headerlink" title="4.3.2 接收"></a>4.3.2 接收</h4><p>如果接收的时候发现sendq有goroutine正在等待，说明buf满了，或者chan是个非缓存chan，根本没有buf。<br>对于接收来说buf满了或者chan没有buf二者的处理逻辑就不太一样了。</p><blockquote><p>因为需要保证顺序,buf满了就不能直接去读sender的数据了，只能从buf中去。</p></blockquote><p>如果是buf满了：那么会先从buf中读一个值出来(腾一个位置出来)，然后把sender发送的值写入buf，并唤醒这个sender g。<br>如果是没有buf的无缓存chan：那就直接把sender要发送的数据取出来，作为本次取到的数据，然后唤醒sender g。</p><h3 id="4-4-读写特点"><a href="#4-4-读写特点" class="headerlink" title="4.4 读写特点"></a>4.4 读写特点</h3><p>空读写阻塞，写关闭异常，读关闭空零</p><ul><li>读写值 nil 管道会永久阻塞</li><li>关闭的管道读数据仍然可以读数据</li><li>往关闭的管道写数据会 panic</li><li>关闭为 nil 的管道 panic</li><li>关闭已经关闭的管道 panic<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2></li></ul><p><a href="https://about.sourcegraph.com/go/understanding-channels-kavya-joshi/">understanding-channels-kavya-joshi</a><br><a href="https://juejin.cn/post/6875325172249788429">图解Golang channel源码</a><br><a href="https://github.com/talkgo/night/issues/450">Go夜读-第 56 期 channel &amp; select 源码分析</a><br><a href="https://maratrix.cn/post/2020/08/25/go-channel-source-read/">Go源码阅读 | channel 设计与实现</a></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习 golang 中的 chan，并分析其具体实现，包括创建 channel，发送数据，接收数据以及相关调度等。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="并发编程" scheme="https://stardustorz.github.io/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Go] sync.Cond</title>
    <link href="https://stardustorz.github.io/2022/07/14/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Cond/"/>
    <id>https://stardustorz.github.io/2022/07/14/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Cond/</id>
    <published>2022-07-13T16:00:00.000Z</published>
    <updated>2025-05-25T10:29:40.141Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>Golang 的 sync 包中的 Cond 实现了一种条件变量，可以使用在<strong>多个Reader</strong>等待共享资源 ready 的场景（如果只有一读一写，一个锁或者channel就搞定了）。<br>Cond的汇合点：多个goroutines等待、1个goroutine通知事件发生。<br>比较适合任务调用场景，一个 Master goroutine 通知事件发生，多个 Worker goroutine 在资源没准备好的时候就挂起，等待通知。<br><strong>使用方法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Cond</span></span><br><span class="line">cond := sync.NewCond(<span class="built_in">new</span>(sync.Mutex))</span><br><span class="line"><span class="comment">// 挂起goroutine</span></span><br><span class="line">cond.L.Lock()</span><br><span class="line">cond.Wait()</span><br><span class="line"><span class="comment">// 唤醒一个</span></span><br><span class="line">cond.Signal()</span><br><span class="line"><span class="comment">// 唤醒所有</span></span><br><span class="line">cond.Broadcast()</span><br></pre></td></tr></table></figure><blockquote><p>基本使用大概是需要等待的时候通过 Wait() 将 Goroutine 挂起，资源准备好的时候再通过 Signal() 或者 Broadcast() 将挂起中的 Goroutine 唤醒。</p></blockquote><p>一个简单的 Demo<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">locker sync.Mutex</span><br><span class="line">cond   = sync.NewCond(&amp;locker)</span><br><span class="line">wg     sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(number <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// wait()方法内部是先释放锁 然后在加锁 所以这里需要先 Lock()</span></span><br><span class="line">cond.L.Lock()</span><br><span class="line"><span class="keyword">defer</span> cond.L.Unlock()</span><br><span class="line">cond.Wait() <span class="comment">// 等待通知,阻塞当前 goroutine</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;g %v ok~ \n&quot;</span>, number)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 每过 50毫秒 唤醒一个 goroutine</span></span><br><span class="line">cond.Signal()</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line"><span class="comment">// 剩下5个 goroutine 一起唤醒</span></span><br><span class="line">cond.Broadcast()</span><br><span class="line">fmt.Println(<span class="string">&quot;Broadcast...&quot;</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><blockquote><p>go version 1.14.7</p></blockquote><h3 id="2-1-Cond"><a href="#2-1-Cond" class="headerlink" title="2.1 Cond"></a>2.1 Cond</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 21</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line">    L Locker</span><br><span class="line">    notify  notifyList</span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCond() 返回指针，保证多 goroutine 获取到的是同一个实例。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span></span> *Cond &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Cond&#123;L: l&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>noCopy</strong>：noCopy对象，实现了<code>sync.Locker</code>接口，使得内嵌 noCopy 的对象在进行 go vet 静态检查的时候，可以检查出是否被复制。</p><blockquote><p>noCopy 具体见 <a href="https://github.com/golang/go/issues/8005">Go issues 8005</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 94</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> noCopy <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*noCopy)</span></span> Lock()   &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*noCopy)</span></span> Unlock() &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>L</strong>：实现了 <code>sync.Locker</code> 接口的锁对象，通常使用 Mutex 或 RWMutex 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： mutex.go</span></span><br><span class="line"><span class="comment">line: 31</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">     Lock()</span><br><span class="line">     Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>notify</strong>：notifyList 对象，维护等待唤醒的 goroutine 队列,使用链表实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： runtime.go</span></span><br><span class="line"><span class="comment">line: 33    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">wait   <span class="type">uint32</span></span><br><span class="line">notify <span class="type">uint32</span></span><br><span class="line">lock   <span class="type">uintptr</span></span><br><span class="line">head   unsafe.Pointer</span><br><span class="line">tail   unsafe.Pointer</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>checker</strong>：copyChecker 对象，实际上是 uintptr 对象，保存自身对象地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 79    </span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="keyword">type</span> copyChecker <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *copyChecker)</span></span> check() &#123;</span><br><span class="line">     <span class="keyword">if</span> <span class="type">uintptr</span>(*c) != <span class="type">uintptr</span>(unsafe.Pointer(c)) &amp;&amp;</span><br><span class="line">            !atomic.CompareAndSwapUintptr((*<span class="type">uintptr</span>)(c), <span class="number">0</span>, <span class="type">uintptr</span>(unsafe.Pointer(c))) &amp;&amp;</span><br><span class="line">            <span class="type">uintptr</span>(*c) != <span class="type">uintptr</span>(unsafe.Pointer(c)) &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;sync.Cond is copied&quot;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>1）检查当前 checker 对象的地址是否等于保存在 checker 中的地址</p><ul><li>由于第一次比较的时候 checker 中没有存地址所以第一次比较肯定是不相等的，于是有了后续 2 3步。</li></ul></li><li><p>2）对 checker 进行 CAS 操作，如果 checker 中存储的地址值为空（就是0）就把当前 checker 对象的地址值存进去</p></li><li>3）第三步和第一步一样，再比较一下。<ul><li>主要是防止在第一步比较发现不相等之后，第二步 CAS 之前，其他 goroutine 也在执行这个方法，并发的将 checker 赋值了，导致这里判定的时候第二步 CAS 失败，返回 false，然后错误的抛出一个 panic，所以执行第三步在比较一下是否相等。如果其他 goroutine 抢先执行 CAS 修改了 checker 中的值导致这里第二步也返回 false 的话，第三步的判定也会是相等的，不会抛出 panic</li></ul></li><li>4）如果 3 个条件都成立，那 checker 肯定是被复制了，就是由于 cond 被复制引起的。</li></ul><blockquote><p>check 方法在第一次调用的时候，会将 checker 对象地址赋值给 checker，也就是将自身内存地址赋值给自身。<br>再次调用 checker 方法的时候，会将当前 checker 对象地址值与 checker 中保存的地址值（原始地址）进行比较，若不相同则表示当前 checker 的地址不是第一次调用 check 方法时候的地址，即 cond 对象被复制了，导致checker 被重新分配了内存地址。</p></blockquote><h3 id="2-2-Wait"><a href="#2-2-Wait" class="headerlink" title="2.2 Wait"></a>2.2 Wait</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 52    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait() &#123;</span><br><span class="line">    <span class="comment">// 1.每次操作之前都要检测一下 cond 是否被复制了。</span></span><br><span class="line">    c.checker.check() </span><br><span class="line">    <span class="comment">// 2.将 notifyList 中的 wait 值加1并返回之前的值</span></span><br><span class="line">    t := runtime_notifyListAdd(&amp;c.notify) </span><br><span class="line">    <span class="comment">// 3.释放锁，因此在调用Wait方法前，必须保证获取到了cond的锁，否则会报错</span></span><br><span class="line">    c.L.Unlock()</span><br><span class="line">    <span class="comment">// 4.将当前goroutine挂起，等待唤醒信号</span></span><br><span class="line">    runtime_notifyListWait(&amp;c.notify, t) </span><br><span class="line">    <span class="comment">// 5.gorountine被唤醒，重新获取锁</span></span><br><span class="line">    c.L.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> package: runtime</span></span><br><span class="line"><span class="comment"> file： sema.go</span></span><br><span class="line"><span class="comment"> line: 479  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListAdd</span><span class="params">(l *notifyList)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> atomic.Xadd(&amp;l.wait, <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: runtime</span></span><br><span class="line"><span class="comment">file： sema.go</span></span><br><span class="line"><span class="comment">line: 488  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 获取当前 goroutine 添加到链表末端，然后 goparkunlock 函数休眠阻塞当前 goroutine</span></span><br><span class="line"><span class="comment">// goparkunlock 函数会让出当前处理器的使用权并等待调度器的唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListWait</span><span class="params">(l *notifyList, t <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.锁住 notify 队列</span></span><br><span class="line">    lock(&amp;l.lock)</span><br><span class="line">    <span class="comment">// 2.判断传入的等待序号t是否小于当前已经唤醒的序号notify</span></span><br><span class="line">    <span class="comment">// 如果是则说明当前 goroutine 不需要阻塞了 直接解锁并返回</span></span><br><span class="line">    <span class="comment">// 有可能执行这步之前 goroutine 就已经被唤醒了</span></span><br><span class="line">    <span class="keyword">if</span> less(t, l.notify) &#123;</span><br><span class="line">        unlock(&amp;l.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.获取当前 goroutine，设置相关参数，将当前等待数赋值给 ticket</span></span><br><span class="line">    s := acquireSudog()</span><br><span class="line">    s.g = getg()</span><br><span class="line">    s.ticket = t</span><br><span class="line">    s.releasetime = <span class="number">0</span></span><br><span class="line">    t0 := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">        s.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.将当前 goroutine 写入到链表尾部</span></span><br><span class="line">    <span class="keyword">if</span> l.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">        l.head = s</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l.tail.next = s</span><br><span class="line">    &#125;</span><br><span class="line">    l.tail = s</span><br><span class="line">    <span class="comment">// 5. 调用 goparkunlock 函数将当前 goroutine 挂起，等待唤醒信号</span></span><br><span class="line">    goparkunlock(&amp;l.lock, <span class="string">&quot;semacquire&quot;</span>, traceEvGoBlockCond, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(s.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-Signal"><a href="#2-3-Signal" class="headerlink" title="2.3 Signal"></a>2.3 Signal</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 64  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal() &#123;</span><br><span class="line">    <span class="comment">// 1.复制检查</span></span><br><span class="line">    c.checker.check() </span><br><span class="line">    <span class="comment">// 2.顺序唤醒一个等待的gorountine</span></span><br><span class="line">    runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: runtime</span></span><br><span class="line"><span class="comment">file： sema.go</span></span><br><span class="line"><span class="comment">line: 554  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyOne</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 1.等待序号和唤醒序号相同则说明没有需要唤醒的 goroutine 直接返回</span></span><br><span class="line">   <span class="keyword">if</span> atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 2.锁住队列后再检查一遍等待序号和唤醒序号是否相同即判断有没有需要唤醒的 goroutine，没有则解锁后直接返回</span></span><br><span class="line">   lock(&amp;l.lock) </span><br><span class="line">   t := l.notify</span><br><span class="line">   <span class="keyword">if</span> t == atomic.Load(&amp;l.wait) &#123;</span><br><span class="line">        unlock(&amp;l.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 3.到这里就说明有需要唤醒的 goroutine，于是先将 notify序号+1</span></span><br><span class="line">   atomic.Store(&amp;l.notify, t+<span class="number">1</span>)  </span><br><span class="line">   <span class="comment">// 4.然后就开始唤醒 goroutine 了</span></span><br><span class="line">   <span class="keyword">for</span> p, s := (*sudog)(<span class="literal">nil</span>), l.head; s != <span class="literal">nil</span>; p, s = s, s.next &#123;</span><br><span class="line">        <span class="comment">// 4.1 找到 ticket等于当前唤醒序号的 goroutine</span></span><br><span class="line">        <span class="keyword">if</span> s.ticket == t &#123;</span><br><span class="line">           <span class="comment">// 4.2 然后将其从等待唤醒链表中移除（因为这个 goroutine 马上就要被唤醒了）</span></span><br><span class="line">           n := s.next</span><br><span class="line">           <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">               p.next = n</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               l.head = n</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">               l.tail = p</span><br><span class="line">           &#125;</span><br><span class="line">           unlock(&amp;l.lock)</span><br><span class="line">           s.next = <span class="literal">nil</span></span><br><span class="line">           <span class="comment">// 4.3 然后唤醒这个 goroutine </span></span><br><span class="line">           readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">           <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 4.4 最后解锁队列 </span></span><br><span class="line">   unlock(&amp;l.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-Broadcast"><a href="#2-4-Broadcast" class="headerlink" title="2.4 Broadcast"></a>2.4 Broadcast</h3><p>唤醒链表中所有的阻塞中的goroutine，还是使用readyWithTime来实现这个功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 73  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast() &#123;</span><br><span class="line">    <span class="comment">// 1.复制检查</span></span><br><span class="line">    c.checker.check()</span><br><span class="line">    <span class="comment">// 2.唤醒所有在等待的 goroutine</span></span><br><span class="line">    runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里和 <code>notifyListNotifyOne()</code>差不多，只是一次性唤醒所有 goroutine。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: runtime</span></span><br><span class="line"><span class="comment">file： sema.go</span></span><br><span class="line"><span class="comment">line: 522 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyAll</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.等待序号和唤醒序号相同则说明没有需要唤醒的 goroutine 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将链表头尾指针置为空（可以看做是清空整个等待队列）</span></span><br><span class="line">    <span class="comment">// 但是需要将当前的链表头保存下来，不然等会找不到链表中的数据了</span></span><br><span class="line">    lock(&amp;l.lock)</span><br><span class="line">    s := l.head</span><br><span class="line">    l.head = <span class="literal">nil</span></span><br><span class="line">    l.tail = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.直接将notify需要赋值成等待序号（这样表示当前没有需要唤醒的 goroutine 了）</span></span><br><span class="line">    <span class="comment">// 前面唤醒一个的时候这里是+1</span></span><br><span class="line">    atomic.Store(&amp;l.notify, atomic.Load(&amp;l.wait))</span><br><span class="line">    unlock(&amp;l.lock)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4.最后 for 循环唤醒链表中所有等待状态的 goroutine</span></span><br><span class="line">    <span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">        next := s.next</span><br><span class="line">        s.next = <span class="literal">nil</span></span><br><span class="line">        readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">        s = next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p><strong>基本使用</strong></p><ul><li>1）资源未准备好时，使用 Wait() 方法将 goroutine 挂起，由底层实现，会让出 CPU 时间片，从而避免使用无意义的循环浪费系统资源。</li><li>2）资源准备好时通过 Signal() 或者 Broadcast() 方法唤醒一个或多个被挂起的 goroutine。</li></ul><p><strong>等待唤醒流程</strong></p><ul><li>1）所有相关数据都是存在 notifyList 中的，包括 goroutine 和一些计数信息。</li><li>2）其中的 wait 和 notify 可以理解为等待序号和唤醒序号，都是自增值，wait 在有新 goroutine 等待时+1，notify 则在唤醒一个 goroutine 时+1。</li><li>3）等待状态的 goroutine 信息则存放在链表中，等待时加入链表尾部，唤醒时移除。</li><li>4）每个等待链表的 goroutine  都会将当前的 wait（等待序号）赋值给 ticket 字段，唤醒的时候会将 ticket=唤醒序号的 goroutine 唤醒。</li><li>5）当 wait==notify 时表示没有 goroutine 需要被唤醒，wait&gt;notify 时表示有 goroutine 需要被唤醒，wait 恒大于等于 notify。</li></ul><p><strong>noCopy</strong><br>Cond在内部持有一个等待队列 notifyList ，这个队列维护所有等待在这个 Cond 的 goroutine。如果 Cond 被复制则会导致其中的等待队列也被复制，最终可能会导致在唤醒 goroutine 的时候出现错误。<br>Kubernetes 的调度中也用到了 sync.Cond 有兴趣的可以研究一下。</p><blockquote><p><a href="https://mp.weixin.qq.com/s/rKLiazgWzneJfpfgHay8cA">https://mp.weixin.qq.com/s/rKLiazgWzneJfpfgHay8cA</a><br><a href="https://github.com/kubernetes/kubernetes/blob/0599ca2bcfcae7d702f95284f3c2e2c2978c7772/pkg/scheduler/internal/queue/scheduling_queue.go">https://github.com/kubernetes/kubernetes/blob/0599ca2bcfcae7d702f95284f3c2e2c2978c7772/pkg/scheduler/internal/queue/scheduling_queue.go</a></p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><code>https://ieevee.com/tech/2019/06/15/cond.html</code></p></blockquote><p><code>https://segmentfault.com/a/1190000019957459</code></p><p><code>https://www.jianshu.com/p/7b59d1d92a95</code></p><p><code>http://www.pydevops.com/2016/12/04/go-cond源码剖析-3/</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h2&gt;&lt;p&gt;Golang 的 sync 包中的 Cond 实现了一种条件变量，可以使用在&lt;strong&gt;多个Reader&lt;/strong</summary>
      
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="并发编程" scheme="https://stardustorz.github.io/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Go] sync.Mutex</title>
    <link href="https://stardustorz.github.io/2022/07/14/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Mutex/"/>
    <id>https://stardustorz.github.io/2022/07/14/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Mutex/</id>
    <published>2022-07-13T16:00:00.000Z</published>
    <updated>2025-05-25T10:29:01.037Z</updated>
    
    <content type="html"><![CDATA[<p>Go 语言在 <code>sync</code> 包中提供了用于同步的一些基本原语,<code>sync.Mutex</code> 就是其中最常用的一个。</p><blockquote><p>本文基于 Go 1.17.1</p><h2 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="1 基本结构"></a>1 基本结构</h2><p>Go 语言的 <code>sync.Mutex</code>由两个字段 <code>state</code> 和 <code>sema</code> 组成。其中 <code>state</code> 表示当前互斥锁的状态，而 <code>sema</code> 是用于控制锁状态的信号量。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/mutex.go 25行</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">state <span class="type">int32</span></span><br><span class="line">sema  <span class="type">uint32</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两个字段加起来只占 8 字节空间的结构体表示了 Go 语言中的互斥锁。</p><h3 id="1-1-状态"><a href="#1-1-状态" class="headerlink" title="1.1 状态"></a>1.1 状态</h3><p>互斥锁的状态比较复杂，如下图所示，最低三位分别表示 <code>mutexLocked</code>、<code>mutexWoken</code> 和 <code>mutexStarving</code>，剩下的位置用来表示当前有多少个 Goroutine 在等待互斥锁的释放：<br>![[mutex-state.png]]<br><code>int32</code> 中的不同位分别表示了不同的状态：</p><ul><li><code>mutexLocked</code> — 表示互斥锁的锁定状态；</li><li><code>mutexWoken</code> — 表示从正常模式被从唤醒；</li><li><code>mutexStarving</code> — 当前的互斥锁进入饥饿状态；</li><li><code>waitersCount</code> — 当前互斥锁上等待的 Goroutine 个数</li></ul><p>在默认情况下，互斥锁的所有状态位都是 0，即默认为未锁定状态。</p><blockquote><p>同时也表明 Mutex 是不需要初始化的</p></blockquote><p>源码中也提供了相关常量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/mutex.go 36</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"></span><br><span class="line">    mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 1 0001 含义：用最后一位表示当前对象锁的状态，0-未锁住 1-已锁住</span></span><br><span class="line"></span><br><span class="line">    mutexWoken <span class="comment">// 2 0010 含义：用倒数第二位表示当前对象是否被唤醒 0-唤醒 1-未唤醒</span></span><br><span class="line"></span><br><span class="line">    mutexStarving <span class="comment">// 4 0100 含义：用倒数第三位表示当前对象是否为饥饿模式，0为正常模式，1为饥饿模式。</span></span><br><span class="line"></span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span> <span class="comment">// 3，从倒数第四位往前的bit位表示在排队等待的goroutine数</span></span><br><span class="line"></span><br><span class="line">    starvationThresholdNs = <span class="number">1e6</span> <span class="comment">// 1ms 切换到饥饿模式的阈值</span></span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="1-2-正常模式和饥饿模式"><a href="#1-2-正常模式和饥饿模式" class="headerlink" title="1.2 正常模式和饥饿模式"></a>1.2 正常模式和饥饿模式</h3><p>Mutex 有两种模式：</p><ul><li>正常模式；</li><li>饥饿模式。</li></ul><p><strong>在正常模式下</strong>，锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被<strong>饿死</strong>。</p><blockquote><p><strong>引入饥饿模式的目的是保证互斥锁的公平性。</strong></p><p>说明 Mutex 是公平锁。</p></blockquote><p><strong>在饥饿模式中</strong>，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。</p><blockquote><p>与饥饿模式相比，正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时。</p></blockquote><p>这里贴一下源码中的注释</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Mutex fairness.</span><br><span class="line"></span><br><span class="line">Mutex can be in 2 modes of operations: normal and starvation.</span><br><span class="line">In normal mode waiters are queued in FIFO order, but a woken up waiter</span><br><span class="line">does not own the mutex and competes with new arriving goroutines over</span><br><span class="line">the ownership. New arriving goroutines have an advantage -- they are</span><br><span class="line">already running on CPU and there can be lots of them, so a woken up</span><br><span class="line">waiter has good chances of losing. In such case it is queued at front</span><br><span class="line">of the wait queue. If a waiter fails to acquire the mutex for more than 1ms,</span><br><span class="line">it switches mutex to the starvation mode.</span><br><span class="line"></span><br><span class="line">In starvation mode ownership of the mutex is directly handed off from</span><br><span class="line">the unlocking goroutine to the waiter at the front of the queue.</span><br><span class="line">New arriving goroutines don&#x27;t try to acquire the mutex even if it appears</span><br><span class="line">to be unlocked, and don&#x27;t try to spin. Instead they queue themselves at</span><br><span class="line">the tail of the wait queue.</span><br><span class="line"></span><br><span class="line">If a waiter receives ownership of the mutex and sees that either</span><br><span class="line">(1) it is the last waiter in the queue, or (2) it waited for less than 1 ms,</span><br><span class="line">it switches mutex back to normal operation mode.</span><br><span class="line"></span><br><span class="line">Normal mode has considerably better performance as a goroutine can acquire</span><br><span class="line">a mutex several times in a row even if there are blocked waiters.</span><br><span class="line">Starvation mode is important to prevent pathological cases of tail latency.</span><br></pre></td></tr></table></figure><h2 id="2-加解锁过程"><a href="#2-加解锁过程" class="headerlink" title="2 加解锁过程"></a>2 加解锁过程</h2><p>在<code>sync</code>包中 中定义了 Locker 接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/mutex.go 31 行</span></span><br><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">        Lock()</span><br><span class="line">        Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mutex 实现了 Locker 接口。除了互斥锁 Mutex 之外读写锁 RWMutex，也实现了 Locker 接口。</p><h3 id="2-1-Lock"><a href="#2-1-Lock" class="headerlink" title="2.1 Lock"></a>2.1 Lock</h3><p>互斥锁的加锁是靠 Mutex.Lock 方法完成的，以下代码进行了简化，省略了 race 相关代码，只保留主干部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/mutex.go 72 行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line"><span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Slow path (outlined so that the fast path can be inlined)</span></span><br><span class="line">m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，整个加锁过程分为 Fast path 和 Slow Path。</p><h4 id="2-1-1-Fast-path"><a href="#2-1-1-Fast-path" class="headerlink" title="2.1.1 Fast path"></a>2.1.1 Fast path</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 m.state 为 0,说明当前锁为未锁定状态，将其设置为 1。</p><p>这也是最简单的部分，直接通过一个 CAS 操作，尝试获取锁。</p><h4 id="2-1-2-Slow-Path"><a href="#2-1-2-Slow-Path" class="headerlink" title="2.1.2 Slow Path"></a>2.1.2 Slow Path</h4><p>如果互斥锁的状态不是 0 时就会进入 Slow Path。尝试通过自旋（Spinnig）等方式等待锁的释放，该方法的主体是一个非常大 for 循环，这里将它分成几个部分介绍获取锁的过程：</p><ul><li>1）判断当前 Goroutine 能否进入自旋；</li><li>2）通过自旋等待互斥锁的释放；</li><li>3）计算互斥锁的最新状态；</li><li>4）更新互斥锁的状态并获取锁；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> lockSlow() &#123;</span><br><span class="line">   <span class="keyword">var</span> waitStartTime <span class="type">int64</span></span><br><span class="line">   starving := <span class="literal">false</span></span><br><span class="line">   awoke := <span class="literal">false</span></span><br><span class="line">   iter := <span class="number">0</span></span><br><span class="line">   old := m.state</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">         <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">            awoke = <span class="literal">true</span></span><br><span class="line">         &#125;</span><br><span class="line">         runtime_doSpin()</span><br><span class="line">         iter++</span><br><span class="line">         old = m.state</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">new</span> := old</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">         <span class="built_in">new</span> |= mutexLocked</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">         <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">         <span class="built_in">new</span> |= mutexStarving</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> awoke &#123;</span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">         &#125;</span><br><span class="line">         queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">         <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">            waitStartTime = runtime_nanotime()</span><br><span class="line">         &#125;</span><br><span class="line">         runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">         starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">         old = m.state</span><br><span class="line">         <span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">               throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">            <span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">               delta -= mutexStarving</span><br><span class="line">            &#125;</span><br><span class="line">            atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         awoke = <span class="literal">true</span></span><br><span class="line">         iter = <span class="number">0</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         old = m.state</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1）判断当前 Goroutine 能否进入自旋；</strong></p><p><strong>自旋是一种多线程同步机制</strong>，当前的进程在进入自旋的过程中会一直保持 CPU 的占用，持续检查某个条件是否为真。<strong>在多核的 CPU 上，自旋可以避免 Goroutine 的切换</strong>，使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 Goroutine 进入自旋的条件非常苛刻：</p><ul><li>1）互斥锁只有在普通模式才能进入自旋；</li><li>2）<code>runtime.sync_runtime_canSpin</code>需要返回 true<ul><li>运行在多 CPU 的机器上；</li><li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li><li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/proc.go 6364 行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_canSpin</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt;= active_spin || ncpu &lt;= <span class="number">1</span> || gomaxprocs &lt;= <span class="type">int32</span>(sched.npidle+sched.nmspinning)+<span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p := getg().m.p.ptr(); !runqempty(p) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）通过自旋等待互斥锁的释放；</strong></p><p>一旦当前 Goroutine 能够进入自旋就会调用<code>runtime.sync_runtime_doSpin</code>和<code>runtime.procyield</code>执行 30 次的 <code>PAUSE</code> 指令，该指令只会占用 CPU 并消耗 CPU 时间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/proc.go 6381 行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_doSpin</span><span class="params">()</span></span> &#123;</span><br><span class="line">procyield(active_spin_cnt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// runtime/asm_386.s 574 行</span><br><span class="line">TEXT runtime·procyield(SB),NOSPLIT,$0-0</span><br><span class="line">MOVLcycles+0(FP), AX</span><br><span class="line">again:</span><br><span class="line">PAUSE</span><br><span class="line">SUBL$1, AX</span><br><span class="line">JNZagain</span><br><span class="line">RET</span><br></pre></td></tr></table></figure><p><strong>3）计算互斥锁的最新状态；</strong></p><p> 处理了自旋相关的特殊逻辑之后，互斥锁会根据上下文计算当前互斥锁最新的状态。几个不同的条件分别会更新 <code>state</code> 字段中存储的不同信息 — <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 和 <code>mutexWaiterShift</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">new</span> := old</span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">new</span> |= mutexLocked</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">new</span> |= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> awoke &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4）更新互斥锁的状态并获取锁；</strong></p><p>计算了新的互斥锁状态之后，会使用 CAS 函数更新状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">    queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">        waitStartTime = runtime_nanotime()</span><br><span class="line">    &#125;</span><br><span class="line">    runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">    starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">    old = m.state</span><br><span class="line">    <span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">        <span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">            delta -= mutexStarving</span><br><span class="line">        &#125;</span><br><span class="line">        atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    awoke = <span class="literal">true</span></span><br><span class="line">    iter = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    old = m.state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有通过 CAS 获得锁，会调用 <code>runtime.sync_runtime_SemacquireMutex</code> 通过信号量保证资源不会被两个 Goroutine 获取。</p><p><code>runtime.sync_runtime_SemacquireMutex</code> 会在方法中不断尝试获取锁并陷入休眠等待信号量的释放，一旦当前 Goroutine 可以获取信号量，它就会立刻返回，<code>sync.Mutex.Lock</code>的剩余代码也会继续执行。</p><ul><li>在正常模式下，这段代码会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环；</li><li>在饥饿模式下，当前 Goroutine 会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出；</li></ul><p>其中还包含了状态切换的部分逻辑:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> waitStartTime <span class="type">int64</span></span><br><span class="line"><span class="keyword">for</span>&#123; <span class="comment">// for 循环里尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123; <span class="comment">// waitStartTime 只有第一次执行时才会赋值</span></span><br><span class="line">        waitStartTime = runtime_nanotime()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果等待时间超过 1ms 则切换到饥饿模式</span></span><br><span class="line">    starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Unlock"><a href="#2-2-Unlock" class="headerlink" title="2.2 Unlock"></a>2.2 Unlock</h3><p>相比之下互斥锁的解锁过程就比较简单,同样分为 Fast path 和 Slow path。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123;</span><br><span class="line"><span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line"><span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Outlined slow path to allow inlining the fast path.</span></span><br><span class="line"><span class="comment">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.</span></span><br><span class="line">m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-1-Fast-path"><a href="#2-2-1-Fast-path" class="headerlink" title="2.2.1 Fast path"></a>2.2.1 Fast path</h4><p>该过程会先使用<code>atomic.AddInt32函数快速解锁，这时会发生下面的两种情况：</code></p><ul><li>如果该函数返回的新状态等于 0，当前 Goroutine 就成功解锁了互斥锁；</li><li>如果该函数返回的新状态不等于 0，则进入 Slow path。</li></ul><h4 id="2-2-2-Slow-path"><a href="#2-2-2-Slow-path" class="headerlink" title="2.2.2 Slow path"></a>2.2.2 Slow path</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> unlockSlow(<span class="built_in">new</span> <span class="type">int32</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">      throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">      old := <span class="built_in">new</span></span><br><span class="line">      <span class="keyword">for</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">         <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         old = m.state</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先校验锁状态的合法性 — 如果当前互斥锁已经被解锁过了会直接抛出异常 “sync: unlock of unlocked mutex” 中止当前程序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后根据当前锁模式分别处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123; <span class="comment">// 正常模式</span></span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123; <span class="comment">// 饥饿模式</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在正常模式下，上述代码会使用如下所示的处理过程：</p><ul><li>如果互斥锁不存在等待者或者互斥锁的 <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 状态不都为 0，那么当前方法可以直接返回，不需要唤醒其他等待者；</li><li>如果互斥锁存在等待者，会通过<code>runtime_Semrelease</code>唤醒等待者并移交锁的所有权；</li></ul><p>在饥饿模式下，上述代码会直接调用<code>runtime_Semrelease</code>将当前锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁，在这时互斥锁还不会退出饥饿状态；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/sema.go 65行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_Semrelease</span><span class="params">(addr *<span class="type">uint32</span>, handoff <span class="type">bool</span>, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">semrelease1(addr, handoff, skipframes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semrelease1</span><span class="params">(addr *<span class="type">uint32</span>, handoff <span class="type">bool</span>, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">root := semroot(addr)</span><br><span class="line">atomic.Xadd(addr, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;root.nwait) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Harder case: search for a waiter and wake it.</span></span><br><span class="line">lockWithRank(&amp;root.lock, lockRankRoot)</span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;root.nwait) == <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;root.lock)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">s, t0 := root.dequeue(addr)</span><br><span class="line"><span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">atomic.Xadd(&amp;root.nwait, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;root.lock)</span><br><span class="line"><span class="keyword">if</span> s != <span class="literal">nil</span> &#123; <span class="comment">// May be slow or even yield, so unlock first</span></span><br><span class="line">acquiretime := s.acquiretime</span><br><span class="line"><span class="keyword">if</span> acquiretime != <span class="number">0</span> &#123;</span><br><span class="line">mutexevent(t0-acquiretime, <span class="number">3</span>+skipframes)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> s.ticket != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;corrupted semaphore ticket&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> handoff &amp;&amp; cansemacquire(addr) &#123;</span><br><span class="line">s.ticket = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">readyWithTime(s, <span class="number">5</span>+skipframes)</span><br><span class="line"><span class="keyword">if</span> s.ticket == <span class="number">1</span> &amp;&amp; getg().m.locks == <span class="number">0</span> &#123;</span><br><span class="line">goyield()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p>互斥锁的<strong>加锁过程</strong>比较复杂，它涉及自旋、信号量以及调度等概念：</p><ul><li>如果互斥锁处于初始化状态，会通过置位 <code>mutexLocked</code> 加锁；</li><li>如果互斥锁处于 <code>mutexLocked</code> 状态并且在普通模式下工作，会进入自旋，执行 30 次 <code>PAUSE</code> 指令消耗 CPU 时间等待锁的释放；</li><li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li><li>互斥锁在正常情况下会通过<code>sync_runtime_SemacquireMutex</code>将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；</li><li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式；</li></ul><p>互斥锁的<strong>解锁过程</strong>与之相比就比较简单：</p><ul><li>当互斥锁已经被解锁时，调用 Mutex.Lock 会直接抛出异常；</li><li>当互斥锁处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 <code>mutexLocked</code> 标志位；</li><li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，会直接返回；在其他情况下会通过<code>sync.runtime_Semrelease</code> 唤醒对应的 Goroutine；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Go 语言在 &lt;code&gt;sync&lt;/code&gt; 包中提供了用于同步的一些基本原语,&lt;code&gt;sync.Mutex&lt;/code&gt; 就是其中最常用的一个。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文基于 Go 1.17.1&lt;/p&gt;
&lt;h2 id=&quot;1-基本结构&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="并发编程" scheme="https://stardustorz.github.io/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Go] Context</title>
    <link href="https://stardustorz.github.io/2022/07/10/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Context/"/>
    <id>https://stardustorz.github.io/2022/07/10/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Context/</id>
    <published>2022-07-09T16:00:00.000Z</published>
    <updated>2025-03-08T15:40:39.791Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Context 主要用于在异步场景中用于实现并发协调以及对 goroutine 的生命周期控制. 除此之外，context 还兼有一定的数据存储能力.</p></blockquote><span id="more"></span><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h2><h3 id="1-1-context-Context"><a href="#1-1-context-Context" class="headerlink" title="1.1 context.Context"></a>1.1 context.Context</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Context 包提供暴露 Context 接口; </li><li>可以在多个 Goroutine 共享数据，实现多 Goroutine 管理机制; </li><li>Context 是协程安全的；</li></ul><p>Context 接口定义了四个核心 api :</p><ul><li>Deadline 方法返回第一个参数是设置的截止时间，到时间Context会自动发起取消请求； 第二个参数是bool值，为false时表示没有设置截止时间，如果要取消需要调用取消函数;</li><li>Done 方法返回一个只读 Channel，类型为 struct{}, 这个 Channel 会在当前工作完成或者上下文被取消之后关闭， 多次调用 Done 方法会返回同一个 Channel；</li><li>Err 方法会返回当前 Context 结束的原因，它只会在 Done 返回的 Channel 被关闭时才会返回非空的值；<ul><li>如果当前 Context 被取消就会返回 Canceled 错误；</li><li>如果当前 Context 超时就会返回 DeadlineExceeded 错误；</li></ul></li><li>Value 方法会从 Context 中返回键对应的值，对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果，这个功能可以用来传递请求特定的数据；获取Value值时是线程安全的； key 必须为非空，且可比较;</li></ul><h3 id="1-2-标准-error"><a href="#1-2-标准-error" class="headerlink" title="1.2 标准 error"></a>1.2 标准 error</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Canceled = errors.New(<span class="string">&quot;context canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DeadlineExceeded <span class="type">error</span> = deadlineExceededError&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> deadlineExceededError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Error() <span class="type">string</span>   &#123; <span class="keyword">return</span> <span class="string">&quot;context deadline exceeded&quot;</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Timeout() <span class="type">bool</span>   &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Temporary() <span class="type">bool</span> &#123; <span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>Canceled：context 被 cancel 时会报此错误；</li><li>DeadlineExceeded：context 超时时会报此错误.</li></ul><h2 id="2-emptyCtx"><a href="#2-emptyCtx" class="headerlink" title="2 emptyCtx"></a>2 emptyCtx</h2><h3 id="2-1-类实现"><a href="#2-1-类实现" class="headerlink" title="2.1 类实现"></a>2.1 类实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>emptyCtx 是一个不可取消，没有设置截止时间，没有携带任何值的Context;</li><li>emptyCtx 是一个空的 context，本质上类型为一个整型；</li><li>Deadline 方法会返回一个公元元年时间以及 false 的 flag，标识当前 context 不存在过期时间；</li><li>Done 方法返回一个 nil 值，用户无论往 nil 中写入或者读取数据，均会陷入阻塞；</li><li>Err 方法返回的错误永远为 nil；</li><li>Value 方法返回的 value 同样永远为 nil.</li></ul><h3 id="2-2-context-Background-amp-context-TODO"><a href="#2-2-context-Background-amp-context-TODO" class="headerlink" title="2.2 context.Background() &amp; context.TODO()"></a>2.2 context.Background() &amp; context.TODO()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">    todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>内置2个Context实现,通常用来做顶层的parent context; TODO一般在不知道使用什么Context时使用；</li><li>todo 和 background 两者本质上只有名字区别，在按 string 输出的时候会有区别; </li><li>context.Background() 和 context.TODO() 方法返回的均是 emptyCtx 类型的一个实例</li></ul><h2 id="3-cancelCtx"><a href="#3-cancelCtx" class="headerlink" title="3  cancelCtx"></a>3  cancelCtx</h2><h3 id="3-1-cancelCtx-数据结构"><a href="#3-1-cancelCtx-数据结构" class="headerlink" title="3.1 cancelCtx 数据结构"></a>3.1 cancelCtx 数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line"></span><br><span class="line">    mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">    done     atomic.Value          <span class="comment">// of chan struct&#123;&#125;, created lazily, closed by first cancel call</span></span><br><span class="line">    children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">    err      <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">    cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• embed 了一个 context 作为其父 context. cancelCtx 必然为某个 context 的子 context；<br>• 内置了一把锁，用以协调并发场景下的资源获取；<br>• done：实际类型为 chan struct{}，即用以反映 cancelCtx 生命周期的通道；<br>• children：一个 set，指向 cancelCtx 的所有子 context；<br>• err：记录了当前 cancelCtx 的错误. 必然为某个 context 的子 context；</p><h3 id="3-2-Deadline-方法"><a href="#3-2-Deadline-方法" class="headerlink" title="3.2 Deadline 方法"></a>3.2 Deadline 方法</h3><p>cancelCtx 未实现该方法，仅是 embed 了一个带有 Deadline 方法的 Context interface，因此直接调用会报错.</p><h3 id="3-3-Done-方法"><a href="#3-3-Done-方法" class="headerlink" title="3.3 Done 方法"></a>3.3 Done 方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">    d := c.done.Load()</span><br><span class="line">    <span class="keyword">if</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    d = c.done.Load()</span><br><span class="line">    <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">        d = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        c.done.Store(d)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 基于 atomic 包，读取 cancelCtx 中的 chan；倘若已存在，则直接返回；<br>• 加锁后，在此检查 chan 是否存在，若存在则返回；（double check）<br>• 初始化 chan 存储到 aotmic.Value 当中，并返回.（懒加载机制）</p><h3 id="3-4-Err-方法"><a href="#3-4-Err-方法" class="headerlink" title="3.4 Err 方法"></a>3.4 Err 方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    err := c.err</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 加锁；<br>• 读取 cancelCtx.err；<br>• 解锁；<br>• 返回结果.</p><h3 id="3-5-Value-方法"><a href="#3-5-Value-方法" class="headerlink" title="3.5  Value 方法"></a>3.5  Value 方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">    <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 倘若 key 特定值 &amp;cancelCtxKey，则返回 cancelCtx 自身的指针；<br>• 否则遵循 valueCtx 的思路取值返回</p><h3 id="3-6-context-WithCancel"><a href="#3-6-context-WithCancel" class="headerlink" title="3.6 context.WithCancel()"></a>3.6 context.WithCancel()</h3><h4 id="3-6-1-context-WithCancel"><a href="#3-6-1-context-WithCancel" class="headerlink" title="3.6.1 context.WithCancel()"></a>3.6.1 context.WithCancel()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c := newCancelCtx(parent)</span><br><span class="line">    propagateCancel(parent, &amp;c)</span><br><span class="line">    <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 校验父 context 非空；<br>• 注入父 context 构造好一个新的 cancelCtx；<br>• 在 propagateCancel 方法内启动一个守护协程，以保证父 context 终止时，该 cancelCtx 也会被终止；<br>• 将 cancelCtx 返回，连带返回一个用以终止该 cancelCtx 的闭包函数.</p><h4 id="3-6-2-newCancelCtx"><a href="#3-6-2-newCancelCtx" class="headerlink" title="3.6.2 newCancelCtx"></a>3.6.2 newCancelCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span></span> cancelCtx &#123;</span><br><span class="line">    <span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 注入父 context 后，返回一个新的 cancelCtx.</p><h4 id="3-6-3-propagateCancel"><a href="#3-6-3-propagateCancel" class="headerlink" title="3.6.3 propagateCancel"></a>3.6.3 propagateCancel</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">    done := parent.Done()</span><br><span class="line">    <span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        <span class="comment">// parent is already canceled</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">        p.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// parent has already been canceled</span></span><br><span class="line">            child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">                p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.mu.Unlock()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        atomic.AddInt32(&amp;goroutines, +<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">                child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">            <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>propagateCancel 方法传递父子 context 之间的 cancel 事件：<br>• 倘若 parent 是不会被 cancel 的类型（如 emptyCtx），则直接返回；<br>• 倘若 parent 已经被 cancel，则直接终止子 context，并以 parent 的 err 作为子 context 的 err；<br>• 假如 parent 是 cancelCtx 的类型，则加锁，并将子 context 添加到 parent 的 children map 当中；<br>• 假如 parent 不是 cancelCtx 类型，但又存在 cancel 的能力（比如用户自定义实现的 context），则启动一个协程，通过多路复用的方式监控 parent 状态，倘若其终止，则同时终止子 context，并透传 parent 的 err.</p><p><strong>校验 parent 是否为 cancelCtx 的类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span></span> (*cancelCtx, <span class="type">bool</span>) &#123;</span><br><span class="line">    done := parent.Done()</span><br><span class="line">    <span class="keyword">if</span> done == closedchan || done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    pdone, _ := p.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> pdone != done &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 倘若 parent 的 channel 已关闭或者是不会被 cancel 的类型，则返回 false；<br>• 倘若以特定的 cancelCtxKey 从 parent 中取值，取得的 value 是 parent 本身，则返回 true. （基于 cancelCtxKey 为 key 取值时返回 cancelCtx 自身，是 cancelCtx 特有的协议）.</p><h2 id="4-timerCtx"><a href="#4-timerCtx" class="headerlink" title="4 timerCtx"></a>4 timerCtx</h2><h3 id="4-1-类实现"><a href="#4-1-类实现" class="headerlink" title="4.1 类实现"></a>4.1 类实现</h3><ul><li>timerCtx 内部不仅通过嵌入 cancelCtx 的方式承了相关的变量和方法，还通过持有的定时器 <code>timer</code> 和截止时间 <code>deadline</code> 实现了定时取消的功能：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">cancelCtx</span><br><span class="line">timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-timerCtx-Deadline"><a href="#4-2-timerCtx-Deadline" class="headerlink" title="4.2 timerCtx.Deadline()"></a>4.2 timerCtx.Deadline()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.deadline, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>context.Context interface 下的 Deadline api 仅在 timerCtx 中有效，由于展示其过期时间.<h3 id="4-3-timerCtx-cancel"><a href="#4-3-timerCtx-cancel" class="headerlink" title="4.3 timerCtx.cancel"></a>4.3 timerCtx.cancel</h3></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line"><span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">removeChild(c.cancelCtx.Context, c)</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">c.timer.Stop()</span><br><span class="line">c.timer = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>timerCtx.cancel 不仅调用了 cancelCtx.cancel 方法，还会停止持有的定时器减少不必要的资源浪费。</li><li>实际上对外提供了 WithTimeout 方法只是 WithDeadline 的封装</li></ul><h3 id="4-4-context-WithTimeout-amp-context-WithDeadline"><a href="#4-4-context-WithTimeout-amp-context-WithDeadline" class="headerlink" title="4.4 context.WithTimeout &amp; context.WithDeadline"></a>4.4 context.WithTimeout &amp; context.WithDeadline</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line"><span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line"><span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line"><span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">&#125;</span><br><span class="line">c := &amp;timerCtx&#123;</span><br><span class="line">cancelCtx: newCancelCtx(parent),</span><br><span class="line">deadline:  d,</span><br><span class="line">&#125;</span><br><span class="line">propagateCancel(parent, c)</span><br><span class="line">dur := time.Until(d)</span><br><span class="line"><span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line"><span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 校验 parent context 非空；<br>• 校验 parent 的过期时间是否早于自己，若是，则构造一个 cancelCtx 返回即可；<br>• 构造出一个新的 timerCtx；<br>• 启动守护方法，同步 parent 的 cancel 事件到子 context；<br>• 判断过期时间是否已到，若是，直接 cancel timerCtx，并返回 DeadlineExceeded 的错误；<br>• 加锁；<br>• 启动 time.Timer，设定一个延时时间，即达到过期时间后会终止该 timerCtx，并返回 DeadlineExceeded 的错误；<br>• 解锁；<br>• 返回 timerCtx，已经一个封装了 cancel 逻辑的闭包 cancel 函数.</p><h2 id="5-valueCtx"><a href="#5-valueCtx" class="headerlink" title="5 valueCtx"></a>5 valueCtx</h2><h3 id="5-1-类实现"><a href="#5-1-类实现" class="headerlink" title="5.1 类实现"></a>5.1 类实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context</span><br><span class="line">key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• valueCtx 同样继承了一个 parent context；<br>• 一个 valueCtx 中仅有一组 kv 对.</p><h3 id="5-2-valueCtx-Value"><a href="#5-2-valueCtx-Value" class="headerlink" title="5.2 valueCtx.Value()"></a>5.2 valueCtx.Value()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">    <span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">        <span class="keyword">return</span> c.val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 假如当前 valueCtx 的 key 等于用户传入的 key，则直接返回其 value；<br>• 假如不等，则从 parent context 中依次向上寻找.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(c Context, key any)</span></span> any &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> ctx := c.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> *valueCtx:</span><br><span class="line">            <span class="keyword">if</span> key == ctx.key &#123;</span><br><span class="line">                <span class="keyword">return</span> ctx.val</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctx.Context</span><br><span class="line">        <span class="keyword">case</span> *cancelCtx:</span><br><span class="line">            <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">                <span class="keyword">return</span> c</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctx.Context</span><br><span class="line">        <span class="keyword">case</span> *timerCtx:</span><br><span class="line">            <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">                <span class="keyword">return</span> &amp;ctx.cancelCtx</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctx.Context</span><br><span class="line">        <span class="keyword">case</span> *emptyCtx:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> c.Value(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动一个 for 循环，由下而上，由子及父，依次对 key 进行匹配；</li><li>其中 cancelCtx、timerCtx、emptyCtx 类型会有特殊的处理方式；</li><li>找到匹配的 key，则将该组 value 进行返回.</li><li>最终找到根节点（一般是 emptyCtx），直接返回一个 nil。所以用 Value 方法的时候要判断结果是否为 nil。</li></ul><h3 id="5-3-valueCtx-用法小结"><a href="#5-3-valueCtx-用法小结" class="headerlink" title="5.3 valueCtx 用法小结"></a>5.3 valueCtx 用法小结</h3><p>valueCtx 不适合视为存储介质，存放大量的 kv 数据</p><ul><li>一个 valueCtx 实例只能存一个 kv 对，因此 n 个 kv 对会嵌套 n 个 valueCtx，造成空间浪费；</li><li>基于 k 寻找 v 的过程是线性的，时间复杂度 O(N)；</li><li>不支持基于 k 的去重，相同 k 可能重复存在，并基于起点的不同，返回不同的 v. 由此得知，valueContext 的定位类似于请求头，只适合存放少量作用域较大的全局 meta 数据.</li></ul><h3 id="5-4-context-WithValue"><a href="#5-4-context-WithValue" class="headerlink" title="5.4 context.WithValue()"></a>5.4 context.WithValue()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val any)</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>parent context 为空，panic；</li><li>key 为空 panic；</li><li>key 的类型不可比较，panic；</li><li>包括 parent context 以及 kv对，返回一个新的 valueCtx.</li></ul><h2 id="6-使用原则"><a href="#6-使用原则" class="headerlink" title="6 使用原则"></a>6 使用原则</h2><ol><li>不要把 Context 放在结构体中，要以参数的方式传递</li><li>以 Context 作为参数的函数方法，应该把 Context 作为第一个参数，放在第一位。</li><li>给一个函数方法传递 Context 的时候，不要传递 nil，如果不知道传递什么，就使用 context.TODO</li><li>Context 的 Value 相关方法应该传递必须的数据，不要什么数据都使用这个传递</li><li>Context 是线程安全的，可以放心的在多个 goroutine 中传递</li><li>在子 Context 被传递到的 goroutine 中，应该对该子 Context 的 Done（channel）进行监控</li></ol><h2 id="7-Context-Demo"><a href="#7-Context-Demo" class="headerlink" title="7 Context Demo"></a>7 Context Demo</h2><h3 id="7-1-Context控制多个goroutine"><a href="#7-1-Context控制多个goroutine" class="headerlink" title="7.1 Context控制多个goroutine"></a>7.1 Context控制多个goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    valueCtx1 := context.WithValue(ctx, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;goroutine 1&quot;</span>)</span><br><span class="line">    valueCtx2 := context.WithValue(ctx, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;goroutine 2&quot;</span>)</span><br><span class="line">    valueCtx3 := context.WithValue(ctx, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;goroutine 3&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> watch(valueCtx1)</span><br><span class="line">    <span class="keyword">go</span> watch(valueCtx2)</span><br><span class="line">    <span class="keyword">go</span> watch(valueCtx3)</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;cancel &quot;</span>, ctx.String())</span><br><span class="line">    cancel()</span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(ctx.String() ,<span class="string">&quot; done&quot;</span>, ctx.Err())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(ctx.Value(<span class="string">&quot;key&quot;</span>), <span class="string">&quot;wait...&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-Context-http请求超时"><a href="#7-2-Context-http请求超时" class="headerlink" title="7.2 Context http请求超时"></a>7.2 Context http请求超时</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个超时时间为100毫秒的上下文</span></span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    ctx, _ = context.WithTimeout(ctx, <span class="number">100</span>*time.Millisecond)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个访问Google主页的请求</span></span><br><span class="line">    req, _ := http.NewRequest(http.MethodGet, <span class="string">&quot;http://google.com&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 将超时上下文关联到创建的请求上</span></span><br><span class="line">    req = req.WithContext(ctx)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个HTTP客户端并执行请求</span></span><br><span class="line">    client := &amp;http.Client&#123;&#125;</span><br><span class="line">    res, err := client.Do(req)</span><br><span class="line">    <span class="comment">// 如果请求失败了，记录到STDOUT</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Request failed:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求成功后打印状态码</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Response received, status code:&quot;</span>, res.StatusCode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-Context-http服务器"><a href="#7-3-Context-http服务器" class="headerlink" title="7.3 Context http服务器"></a>7.3 Context http服务器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个监听8000端口的服务器</span></span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    ctx := r.Context()</span><br><span class="line">    <span class="comment">// 输出到STDOUT展示处理已经开始</span></span><br><span class="line">    fmt.Fprint(os.Stdout, <span class="string">&quot;processing request\n&quot;</span>)</span><br><span class="line">    <span class="comment">// 通过select监听多个channel</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">        <span class="comment">// 如果两秒后接受到了一个消息后，意味请求已经处理完成</span></span><br><span class="line">        <span class="comment">// 我们写入&quot;request processed&quot;作为响应</span></span><br><span class="line">        w.Write([]<span class="type">byte</span>(<span class="string">&quot;request processed&quot;</span>))</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        <span class="comment">// 如果处理完成前取消了，在STDERR中记录请求被取消的消息</span></span><br><span class="line">        fmt.Fprint(os.Stderr, <span class="string">&quot;request cancelled\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-Context-超时控制多个goroutine"><a href="#7-4-Context-超时控制多个goroutine" class="headerlink" title="7.4 Context 超时控制多个goroutine"></a>7.4 Context 超时控制多个goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ctx context.Context, wg *sync.WaitGroup)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;Timeout &quot;</span>, ctx.Err())</span><br><span class="line">            <span class="keyword">return</span> ctx.Err()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">100</span>*time.Millisecond)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> worker(ctx, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    cancel()</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-Context-取消控制多个goroutine"><a href="#7-5-Context-取消控制多个goroutine" class="headerlink" title="7.5 Context 取消控制多个goroutine"></a>7.5 Context 取消控制多个goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work1</span><span class="params">(ctx context.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 假设这个操作会因为某种原因失败</span></span><br><span class="line">    <span class="comment">// 使用time.Sleep来模拟一个资源密集型操作</span></span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work2</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">500</span> * time.Millisecond):</span><br><span class="line">        fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(<span class="string">&quot;halted work2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    <span class="comment">// cancel context</span></span><br><span class="line">    ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">    <span class="comment">// 在不同的goroutine中运行work2</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        work2(ctx)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        work2(ctx)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    err := work1(ctx)</span><br><span class="line">    <span class="comment">// 如果这个操作返回错误，取消所有使用相同Context的操作</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//发出取消事件</span></span><br><span class="line">        cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-6-Context-控制后台goroutine-生成素数"><a href="#7-6-Context-控制后台goroutine-生成素数" class="headerlink" title="7.6 Context 控制后台goroutine 生成素数"></a>7.6 Context 控制后台goroutine 生成素数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回生成自然数序列的管道: 2, 3, 4, ...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateNatural</span><span class="params">(ctx context.Context)</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">2</span>; ; i++ &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 结束生成自然数</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道过滤器: 删除能被素数整除的数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrimeFilter</span><span class="params">(ctx context.Context, in &lt;-<span class="keyword">chan</span> <span class="type">int</span>, prime <span class="type">int</span>)</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> i := &lt;-in; i%prime != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 结束过滤器</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> out &lt;- i:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通过 Context 控制后台Goroutine状态</span></span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">    ch := GenerateNatural(ctx) <span class="comment">// 自然数序列: 2, 3, 4, ...</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        prime := &lt;-ch <span class="comment">// 新出现的素数</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v: %v\n&quot;</span>, i+<span class="number">1</span>, prime)</span><br><span class="line">        ch = PrimeFilter(ctx, ch, prime) <span class="comment">// 基于新素数构造的过滤器</span></span><br><span class="line">    &#125;</span><br><span class="line">    cancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-参考"><a href="#8-参考" class="headerlink" title="8 参考"></a>8 参考</h2><ul><li><a href="https://pkg.go.dev/context">https://pkg.go.dev/context</a></li><li><a href="https://faiface.github.io/post/context-should-go-away-go2/">https://faiface.github.io/post/context-should-go-away-go2/</a></li><li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/</a></li><li><a href="https://blog.csdn.net/qq_36183935/article/details/81137834">https://blog.csdn.net/qq_36183935/article/details/81137834</a></li><li><a href="https://blog.csdn.net/u011957758/article/details/82948750">https://blog.csdn.net/u011957758/article/details/82948750</a></li><li><a href="https://www.jianshu.com/p/e5df3cd0708bhttps://zhuanlan.zhihu.com/p/68792989">https://www.jianshu.com/p/e5df3cd0708bhttps://zhuanlan.zhihu.com/p/68792989</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Context 主要用于在异步场景中用于实现并发协调以及对 goroutine 的生命周期控制. 除此之外，context 还兼有一定的数据存储能力.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="并发编程" scheme="https://stardustorz.github.io/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Go] GMP</title>
    <link href="https://stardustorz.github.io/2022/07/03/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP/"/>
    <id>https://stardustorz.github.io/2022/07/03/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP/</id>
    <published>2022-07-02T16:00:00.000Z</published>
    <updated>2025-03-08T15:42:05.292Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>gmp = goroutine + machine + processor</p></blockquote><span id="more"></span><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><h3 id="1-1-线程"><a href="#1-1-线程" class="headerlink" title="1.1 线程"></a>1.1 线程</h3><p>通常指的是内核级线程，核心点如下：</p><ul><li>是操作系统最小调度单元；</li><li>创建、销毁、调度交由内核完成，cpu 需完成用户态与内核态间的切换；</li><li>可充分利用多核，实现并行.<h3 id="1-2-协程"><a href="#1-2-协程" class="headerlink" title="1.2 协程"></a>1.2 协程</h3></li></ul><p>协程，又称为用户级线程，核心点如下：</p><ul><li>与线程存在映射关系，为 M：1；</li><li>创建、销毁、调度在用户态完成，对内核透明，所以更轻；</li><li>从属同一个内核级线程，无法并行；一个协程阻塞会导致从属同一线程的所有协程无法执行.</li></ul><h3 id="1-3-Goroutine"><a href="#1-3-Goroutine" class="headerlink" title="1.3 Goroutine"></a>1.3 Goroutine</h3><p>Goroutine，经 Golang 优化后的特殊“协程”，特点如下：</p><ul><li>与线程存在映射关系，为 M：N；</li><li>创建、销毁、调度在用户态完成，对内核透明，足够轻便；</li><li>可利用多个线程，实现并行；</li><li>通过调度器的，实现和线程间的动态绑定和灵活调度；</li><li>栈空间大小可动态扩缩.</li></ul><h3 id="1-4-对比"><a href="#1-4-对比" class="headerlink" title="1.4 对比"></a>1.4 对比</h3><div class="table-container"><table><thead><tr><th><strong>模型</strong></th><th><strong>弱依赖内核</strong></th><th><strong>可并行</strong></th><th><strong>可应对阻塞</strong></th><th><strong>栈可动态扩缩</strong></th></tr></thead><tbody><tr><td>线程</td><td>❎</td><td>✅</td><td>✅</td><td>❎</td></tr><tr><td>协程</td><td>✅</td><td>❎</td><td>❎</td><td>❎</td></tr><tr><td>goroutine</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table></div><h2 id="2-GMP-模型"><a href="#2-GMP-模型" class="headerlink" title="2 GMP 模型"></a>2 GMP 模型</h2><h3 id="2-1-g"><a href="#2-1-g" class="headerlink" title="2.1 g"></a>2.1 g</h3><ul><li>g 即goroutine，是 golang 中对协程的抽象</li><li>g 有自己的运行栈、状态、以及执行的任务函数（用户通过 go func 指定）</li><li>g 需要绑定到 p 才能执行，在 g 的视角中，p 就是它的 cpu</li></ul><h3 id="2-2-m"><a href="#2-2-m" class="headerlink" title="2.2 m"></a>2.2 m</h3><ul><li>m 即 machine，是 golang 中对线程的抽象</li><li>m 不直接执行 g，而是先和 p 绑定，由其实现代理</li><li>借由 p 的存在，m 无需和 g 绑死，也无需记录 g 的状态信息，因此 g 在全生命周期中可以实现跨 m 执行.</li></ul><h3 id="2-3-p"><a href="#2-3-p" class="headerlink" title="2.3 p"></a>2.3 p</h3><ul><li>p 即 processor，是 golang 中的调度器</li><li>p 是 gmp 的中枢，借由 p 承上启下，实现 g 和 m 之间的动态有机结合</li><li>对 g 而言，p 是其 cpu，g 只有被 p 调度，才得以执行</li><li>对 m 而言，p 是其执行代理，为其提供必要信息的同时（可执行的 g、内存分配情况等），并隐藏了繁杂的调度细节</li><li>p 的数量决定了 g 最大并行数量，可由用户通过 GOMAXPROCS 进行设定（超过 CPU 核数时无意义）</li></ul><h3 id="2-4-GMP"><a href="#2-4-GMP" class="headerlink" title="2.4 GMP"></a>2.4 GMP</h3><ul><li>M 是线程的抽象；G 是 goroutine；P 是承上启下的调度器；</li><li>M调度G前，需要和P绑定；</li><li>全局有多个M和多个P，但同时并行的G的最大数量等于P的数量；</li><li>G的存放队列有三类：P的本地队列；全局队列；和wait队列（图中未展示，为io阻塞就绪态goroutine队列）；</li><li>M调度G时，优先取P本地队列，其次取全局队列，最后取wait队列；这样的好处是，取本地队列时，可以接近于无锁化，减少全局锁竞争；</li><li>为防止不同P的闲忙差异过大，设立work-stealing机制，本地队列为空的P可以尝试从其他P本地队列偷取一半的G补充到自身队列.</li></ul><h2 id="3-核心数据结构"><a href="#3-核心数据结构" class="headerlink" title="3 核心数据结构"></a>3 核心数据结构</h2><blockquote><p>gmp 数据结构定义在 runtime/runtime2.go 文件中</p></blockquote><h3 id="3-1-g"><a href="#3-1-g" class="headerlink" title="3.1 g"></a>3.1 g</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    m         *m      </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sched     gobuf</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    sp   <span class="type">uintptr</span></span><br><span class="line">    pc   <span class="type">uintptr</span></span><br><span class="line">    ret  <span class="type">uintptr</span></span><br><span class="line">    bp   <span class="type">uintptr</span> <span class="comment">// for framepointer-enabled architectures</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>m：在 p 的代理，负责执行当前 g 的 m；</li><li>sched.sp：保存 CPU 的 rsp 寄存器的值，指向函数调用栈栈顶；</li><li>sched.pc：保存 CPU 的 rip 寄存器的值，指向程序下一条执行指令的地址；</li><li>sched.ret：保存系统调用的返回值；</li><li>sched.bp：保存 CPU 的 rbp 寄存器的值，存储函数栈帧的起始位置.</li></ul><p>g的生命周期:未初始化完成 等待被执行  执行  执行系统调用  挂起态  被销毁  栈扩容 被抢占</p><h3 id="3-2-m"><a href="#3-2-m" class="headerlink" title="3.2 m"></a>3.2 m</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    g0      *g     <span class="comment">// goroutine with scheduling stack</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    tls           [tlsSlots]<span class="type">uintptr</span> <span class="comment">// thread-local storage (for x86 extern register)</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>g0：一类特殊的调度协程，不用于执行用户函数，负责执行 g 之间的切换调度. 与 m 的关系为 1:1；</li><li>tls：thread-local storage，线程本地存储，存储内容只对当前线程可见. 线程本地存储的是 m.tls 的地址，m.tls[0] 存储的是当前运行的 g，因此线程可以通过 g 找到当前的 m、p、g0 等信息.<h3 id="3-3-p"><a href="#3-3-p" class="headerlink" title="3.3 p"></a>3.3 p</h3></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    runqhead <span class="type">uint32</span></span><br><span class="line">    runqtail <span class="type">uint32</span></span><br><span class="line">    runq     [<span class="number">256</span>]guintptr</span><br><span class="line">    </span><br><span class="line">    runnext guintptr</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>runq：本地 goroutine 队列，最大长度为 256.</li><li>runqhead：队列头部；</li><li>runqtail：队列尾部；</li><li>runnext：下一个可执行的 goroutine.</li></ul><h3 id="3-4-schedt"><a href="#3-4-schedt" class="headerlink" title="3.4 schedt"></a>3.4 schedt</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lock mutex</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    runq     gQueue</span><br><span class="line">    runqsize <span class="type">int32</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sched 是全局 goroutine 队列的封装：</p><ul><li>lock：一把操作全局队列时使用的锁；</li><li>runq：全局 goroutine 队列；</li><li>runqsize：全局 goroutine 队列的容量.</li></ul><h2 id="4-调度流程"><a href="#4-调度流程" class="headerlink" title="4 调度流程"></a>4 调度流程</h2><h3 id="4-1-g0-和-g-的转换"><a href="#4-1-g0-和-g-的转换" class="headerlink" title="4.1 g0 和 g 的转换"></a>4.1 g0 和 g 的转换</h3><p><strong>goroutine 的类型可分为两类：</strong></p><ul><li>负责调度普通 g 的 g0，执行固定的调度流程，与 m 的关系为一对一</li><li>负责执行用户函数的普通 g<br>m 通过 p 调度执行的 goroutine 永远在普通 g 和 g0 之间进行切换，当 g0 找到可执行的 g 时，会调用 gogo 方法，调度 g 执行用户定义的任务；当 g 需要主动让渡或被动调度时，会触发 mcall 方法，将执行权重新交还给 g0.</li></ul><h3 id="4-2-调度类型"><a href="#4-2-调度类型" class="headerlink" title="4.2 调度类型"></a>4.2 调度类型</h3><blockquote><p>调度器 p 实现从执行一个 g 切换到另一个 g 的过程.</p></blockquote><h4 id="4-2-1-主动调度"><a href="#4-2-1-主动调度" class="headerlink" title="4.2.1 主动调度"></a>4.2.1 主动调度</h4><ul><li>用户主动执行让渡的方式，主要方式是，用户在执行代码中调用了 runtime.Gosched 方法，此时当前 g 会当让出执行权，主动进行队列等待下次被调度执行.</li></ul><h4 id="4-2-2-被动调度"><a href="#4-2-2-被动调度" class="headerlink" title="4.2.2 被动调度"></a>4.2.2 被动调度</h4><ul><li>因当前不满足某种执行条件，g 可能会陷入阻塞态无法被调度，直到关注的条件达成后，g才从阻塞中被唤醒，重新进入可执行队列等待被调度.</li><li><p>常见的被动调度触发方式为因 channel 操作或互斥锁操作陷入阻塞等操作，底层会走进 gopark 方法.</p><h4 id="4-2-3-正常调度"><a href="#4-2-3-正常调度" class="headerlink" title="4.2.3 正常调度"></a>4.2.3 正常调度</h4></li><li><p>g 中的执行任务已完成，g0 会将当前 g 置为死亡状态，发起新一轮调度.</p><h4 id="4-2-4-抢占调度"><a href="#4-2-4-抢占调度" class="headerlink" title="4.2.4 抢占调度"></a>4.2.4 抢占调度</h4></li><li><p>如果 g 执行系统调用超过指定的时长，且全局的 p 资源比较紧缺，此时将 p 和 g 解绑，抢占出来用于其他 g 的调度. 等 g 完成系统调用后，会重新进入可执行队列中等待被调度.</p></li><li>前 3 种调度方式都由 m 下的 g0 完成，唯独抢占调度不同.</li><li>因为发起系统调用时需要打破用户态的边界进入内核态，此时 m 也会因系统调用而陷入僵直，无法主动完成抢占调度的行为.</li><li>因此，在 Golang 进程会有一个全局监控协程 monitor g 的存在，这个 g 会越过 p 直接与一个 m 进行绑定，不断轮询对所有 p 的执行状况进行监控. 倘若发现满足抢占调度的条件，则会从第三方的角度出手干预，主动发起该动作.</li></ul><h3 id="4-3-宏观调度流程"><a href="#4-3-宏观调度流程" class="headerlink" title="4.3 宏观调度流程"></a>4.3 宏观调度流程</h3><ul><li>g0 执行 schedule() 函数，寻找到用于执行的 g</li><li>g0 执行 execute() 方法，更新当前 g、p 的状态信息，并调用 gogo() 方法，将执行权交给 g</li><li>g 因主动让渡( gosche_m() )、被动调度( park_m() )、正常结束( goexit0() )等原因，调用 m_call 函数，执行权重新回到 g0 手中</li><li>g0 执行 schedule() 函数，开启新一轮循环</li></ul><h3 id="4-4-schedule"><a href="#4-4-schedule" class="headerlink" title="4.4 schedule"></a>4.4 schedule</h3><p>调度流程的主干方法是位于 runtime/proc.go 中的 schedule 函数，此时的执行权位于 g0 手中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    gp, inheritTime, tryWakeP := findRunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>寻找到下一个执行的 goroutine</li><li>执行该 goroutine</li></ul><h3 id="4-5-findRunnable"><a href="#4-5-findRunnable" class="headerlink" title="4.5 findRunnable"></a>4.5 findRunnable</h3><p><img src="file-20250303232645826.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRunnable</span><span class="params">()</span></span> (gp *g, inheritTime, tryWakeP <span class="type">bool</span>) &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    _p_ := _g_.m.p.ptr()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> _p_.schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        gp = globrunqget(_p_, <span class="number">1</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> gp, inheritTime := runqget(_p_); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gp, inheritTime, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> list := netpoll(<span class="number">0</span>); !list.empty() &#123; <span class="comment">// non-blocking</span></span><br><span class="line">            gp := list.pop()</span><br><span class="line">            injectglist(&amp;list)</span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    procs := <span class="type">uint32</span>(gomaxprocs)</span><br><span class="line">    <span class="keyword">if</span> _g_.m.spinning || <span class="number">2</span>*atomic.Load(&amp;sched.nmspinning) &lt; procs-atomic.Load(&amp;sched.npidle) &#123;</span><br><span class="line">        <span class="keyword">if</span> !_g_.m.spinning &#123;</span><br><span class="line">            _g_.m.spinning = <span class="literal">true</span></span><br><span class="line">            atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gp, inheritTime, tnow, w, newWork := stealWork(now)</span><br><span class="line">        now = tnow</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// Successfully stole.</span></span><br><span class="line">            <span class="keyword">return</span> gp, inheritTime, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> newWork &#123;</span><br><span class="line">            <span class="comment">// There may be new timer or GC work; restart to</span></span><br><span class="line">            <span class="comment">// discover.</span></span><br><span class="line">            <span class="keyword">goto</span> top</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; (pollUntil == <span class="number">0</span> || w &lt; pollUntil) &#123;</span><br><span class="line">            <span class="comment">// Earlier timer to wait for.</span></span><br><span class="line">            pollUntil = w</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>p 每执行 61 次调度，会从全局队列中获取一个 goroutine 进行执行，并将一个全局队列中的 goroutine 填充到当前 p 的本地队列中<ul><li>取得 p 本地队列队首的索引，同时对本地队列加锁</li><li>倘若 p 的局部队列未满，则成功转移 g，将 p 的对尾索引 runqtail 值加 1 并解锁队列.</li><li>倘若发现本地队列 runq 已经满了，则会返回来将本地队列中一半的 g 放回全局队列中，帮助当前 p 缓解执行压力，这部分内容位于 runqputslow 方法中</li></ul></li><li>尝试从 p 本地队列中获取一个可执行的 goroutine，核心逻辑位于 runqget 方法中<ul><li>倘若当前 p 的 runnext 非空，直接获取即可</li><li>加锁从 p 的本地队列中获取 g, 虽然本地队列是属于 p 独有的，但是由于 work-stealing 机制的存在，其他 p 可能会前来执行窃取动作，因此操作仍需加锁.</li><li>倘若本地队列为空，直接终止并返回</li><li>倘若本地队列存在 g，则取得队首的 g，解锁并返回</li></ul></li><li>倘若本地队列没有可执行的 g，会从全局队列中获取</li><li>倘若本地队列和全局队列都没有 g，则会获取准备就绪的网络协程</li><li>work-stealing: 从其他 p 中偷取 g<ul><li>偷取操作至多会遍历全局的 p 队列 4 次，过程中只要找到可窃取的 p 则会立即返回.</li><li>为保证窃取行为的公平性，遍历的起点是随机的. 窃取动作的核心逻辑位于 runqgrab 方法当中</li><li>每次对一个 p 尝试窃取前，会对其局部队列加锁</li><li>尝试偷取其现有的一半 g，并且返回实际偷取的数量</li></ul></li></ul><h3 id="4-6-execute"><a href="#4-6-execute" class="headerlink" title="4.6 execute"></a>4.6 execute</h3><p>当 g0 为 m 寻找到可执行的 g 之后，接下来就开始执行 g. 这部分内容位于 runtime/proc.go 的 execute 方法中</p><ul><li>更新 g 的状态信息，建立 g 与 m 之间的绑定关系</li><li>更新 p 的总调度次数</li><li>调用 gogo 方法，执行 goroutine 中的任务</li></ul><h3 id="4-7-gosched-m"><a href="#4-7-gosched-m" class="headerlink" title="4.7 gosched_m"></a>4.7 gosched_m</h3><p>g 执行主动让渡时，会调用 mcall 方法将执行权归还给 g0，并由 g0 调用 gosched_m 方法，位于 runtime/proc.go 文件中</p><p><img src="file-20250303234355218.png" alt=""></p><ul><li>将当前 g 的状态由执行中切换为待执行 <code>_Grunnable</code></li><li>调用 dropg() 方法，将当前的 m 和 g 解绑</li><li>将 g 添加到全局队列当中</li><li>开启新一轮的调度</li></ul><h3 id="4-8-park-m-与-ready"><a href="#4-8-park-m-与-ready" class="headerlink" title="4.8 park_m 与 ready"></a>4.8 park_m 与 ready</h3><ul><li>g 需要被动调度时，会调用 mcall 方法切换至 g0，并调用 park_m 方法将 g 置为阻塞态，执行流程位于 runtime/proc.go 的 gopark 方法当中<ul><li>将当前 g 的状态由 running 改为 waiting</li><li>将 g 与 m 解绑</li><li>执行新一轮的调度 schedule</li></ul></li><li>当因被动调度陷入阻塞态的 g 需要被唤醒时，会由其他协程执行 goready 方法将 g 重新置为可执行的状态，方法位于 runtime/proc.go<ul><li>先将 g 的状态从阻塞态改为可执行的状态</li><li>调用 runqput 将当前 g 添加到唤醒者 p 的本地队列中，如果队列满了，会连带 g 一起将一半的元素转移到全局队列</li></ul></li></ul><h3 id="4-9-goexit0"><a href="#4-9-goexit0" class="headerlink" title="4.9 goexit0"></a>4.9 goexit0</h3><ul><li>当 g 执行完成时，会先执行 mcall 方法切换至 g0，然后调用 goexit0 方法<ul><li>将 g 状态置为 dead</li><li>解绑 g 和 m</li><li>开启新一轮的调度</li></ul></li></ul><h3 id="4-10-retake"><a href="#4-10-retake" class="headerlink" title="4.10 retake"></a>4.10 retake</h3><p>抢占调度的执行者不是 g0，而是一个全局的 monitor g，代码位于 runtime/proc.go 的 retake 方法中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retake</span><span class="params">(now <span class="type">int64</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    lock(&amp;allpLock)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(allp); i++ &#123;</span><br><span class="line">        _p_ := allp[i]</span><br><span class="line">        <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// This can happen if procresize has grown</span></span><br><span class="line">            <span class="comment">// allp but not yet created new Ps.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        pd := &amp;_p_.sysmontick</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> s == _Psyscall &#123;            </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">if</span> runqempty(_p_) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; <span class="number">0</span> &amp;&amp; pd.syscallwhen+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &gt; now &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            unlock(&amp;allpLock)</span><br><span class="line">            <span class="keyword">if</span> atomic.Cas(&amp;_p_.status, s, _Pidle) &#123;</span><br><span class="line">                n++</span><br><span class="line">                _p_.syscalltick++</span><br><span class="line">                handoffp(_p_)</span><br><span class="line">            &#125;</span><br><span class="line">            incidlelocked(<span class="number">1</span>)</span><br><span class="line">            lock(&amp;allpLock)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;allpLock)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">uint32</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>加锁后，遍历全局的 p 队列，寻找需要被抢占的目标</li><li>倘若某个 p 同时满足下述条件，则会进行抢占调度<ul><li>执行系统调用超过 10 ms</li><li>p 本地队列有等待执行的 g</li><li>或者当前没有空闲的 p 和 m</li></ul></li><li>抢占调度的步骤是，先将当前 p 的状态更新为 idle，然后步入 handoffp 方法中，判断是否需要为 p 寻找接管的 m（因为其原本绑定的 m 正在执行系统调用）</li><li>当以下条件满足其一时，则需要为 p 获取新的 m<ul><li>当前 p 本地队列还有待执行的 g</li><li>全局繁忙（没有空闲的 p 和 m，全局 g 队列为空）</li><li>需要处理网络 socket 读写请求</li></ul></li><li>获取 m 时，会先尝试获取已有的空闲的 m，若不存在，则会创建一个新的 m</li></ul><h3 id="4-11-reentersyscall-和-exitsyscall"><a href="#4-11-reentersyscall-和-exitsyscall" class="headerlink" title="4.11 reentersyscall 和 exitsyscall"></a>4.11 reentersyscall 和 exitsyscall</h3><p>在 m 需要执行系统调用前，会先执行位于 runtime/proc.go 的 reentersyscall 的方法</p><ul><li>此时执行权同样位于 m 的 g0 手中</li><li>保存当前 g 的执行环境</li><li>将 g 和 p 的状态更新为 syscall</li><li>解除 p 和 当前 m 之间的绑定，因为 m 即将进入系统调用而导致短暂不可用</li><li>将 p 添加到 当前 m 的 oldP 容器当中，后续 m 恢复后，会优先寻找旧的 p 重新建立绑定关系</li></ul><p>当 m 完成了内核态的系统调用之后，此时会步入位于 runtime/proc.go 的 exitsyscall 函数中，尝试寻找 p 重新开始运作</p><ul><li>方法执行之初，此时的执行权是普通 g.倘若此前设置的 oldp 仍然可用，则重新和 oldP 绑定，将当前 g 重新置为 running 状态，然后开始执行后续的用户函数</li><li>old 绑定失败，则调用 mcall 方法切换到 m 的 g0，并执行 exitsyscall0 方法</li><li>将 g 由系统调用状态切换为可运行态，并解绑 g 和 m 的关系</li><li>从全局 p 队列获取可用的 p，如果获取到了，则执行 g</li><li>如若无 p 可用，则将 g 添加到全局队列，当前 m 陷入沉睡. 直到被唤醒后才会继续发起调度.</li></ul>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;gmp = goroutine + machine + processor&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="并发编程" scheme="https://stardustorz.github.io/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Go] 类型断言</title>
    <link href="https://stardustorz.github.io/2021/12/13/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/"/>
    <id>https://stardustorz.github.io/2021/12/13/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/</id>
    <published>2021-12-12T16:00:00.000Z</published>
    <updated>2025-03-09T15:13:13.152Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>类型断言的关键是明确接口的动态类型以及对应的类型实现了哪些方法</p></blockquote><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>类型分类：</p><ul><li>抽象类型：空接口、非空接口</li><li>具体类型：int、string、slice、map ….</li></ul><p>断言表达式：</p><ul><li>类型断言作用在接口值之上，可以是空接口或非空接口；</li><li>而断言的目标类型可以是具体类型或非空接口类型。</li></ul><p>这样一共就有4种断言组合。</p><h2 id="2-具体分析"><a href="#2-具体分析" class="headerlink" title="2 具体分析"></a>2 具体分析</h2><h3 id="2-1-空接口-具体类型"><a href="#2-1-空接口-具体类型" class="headerlink" title="2.1 空接口.(具体类型)"></a>2.1 空接口.(具体类型)</h3><p><strong>空接口只有动态类型，所以只要动态类型相同就能断言成功</strong>。<br><img src="file-20250119063246346.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">r,ok := e.(*os.File)</span><br></pre></td></tr></table></figure><p>这里只需要判定 e 的 _type 是否执行 *os.File 的类型元数据即可。</p><blockquote><p> Go 语言里面每种类型的类型元数据都是唯一的，如果类型元数据相同那就是同一种类型。</p></blockquote><p>如果这样赋值就能断言成功, ok 为 true，r 被赋值为 e 的动态值 f。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eface2Specific</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">f, _ := os.Open(<span class="string">&quot;17x.txt&quot;</span>)</span><br><span class="line">e = f</span><br><span class="line">r, ok := e.(*os.File)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反之则不行，ok 为 false，<strong>r 被赋值为 *os.File 类型(断言的目标类型)的零值 nil</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">f, _ := os.Open(<span class="string">&quot;17x.txt&quot;</span>)</span><br><span class="line">e = <span class="string">&quot;17x&quot;</span></span><br><span class="line">r, ok := e.(*os.File)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-非空接口-具体类型"><a href="#2-2-非空接口-具体类型" class="headerlink" title="2.2 非空接口.(具体类型)"></a>2.2 非空接口.(具体类型)</h3><p><strong>这里需要判断非空接口的动态类型是否等于断言目标类型</strong>。</p><p><img src="file-20250119063407429.png" alt=""></p><p>下面的断言，要求 rw 接口类型为 io.ReadWriter，动态类型为*os.File。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rw io.ReadWriter</span><br><span class="line">r, ok := rw.(*os.File)</span><br></pre></td></tr></table></figure><p>只需要判定非空接口的 itab 是否指向 io.ReadWriter 的 itab 结构体即可。</p><p>这样赋值就能断言成功：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> rw io.ReadWriter</span><br><span class="line">f, _ := os.Open(<span class="string">&quot;17x.txt&quot;</span>)</span><br><span class="line">rw = f</span><br><span class="line">r, ok := rw.(*os.File)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样则不行,接口类型对上了，但是 rw 的动态类型是  <em>MyRW，不是断言目标类型 </em>os.File。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> rw io.ReadWriter</span><br><span class="line">rw = &amp;MyRW&#123;&#125;</span><br><span class="line">r, ok := rw.(*os.File)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyRW <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *MyRW)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)  &#123; <span class="keyword">return</span> <span class="number">0</span>, err &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *MyRW)</span></span> Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>, err &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-空接口-非空接口"><a href="#2-3-空接口-非空接口" class="headerlink" title="2.3 空接口.(非空接口)"></a>2.3 空接口.(非空接口)</h3><p><strong>这里需要判断空接口的动态类型是否实现了非空接口</strong>。<br><img src="file-20250119063351822.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">r, ok := e.(io.ReadWriter)</span><br></pre></td></tr></table></figure><ul><li>1）先去 itab 缓存中找 <strong>&lt;断言目标值接口类型，空接口动态类型&gt;</strong> 这个 Key 对应的 itab 结构体；</li><li>2）如果存在则再次判断 itab.fun[0] 是否等于0<ul><li>等于 0 则断言失败</li><li>不等于 0则断言成功</li></ul></li><li>3）如果不存在则通过 _type 找到方法元数据，校验是否实现了接口类型，且把 itab 添加到哈希表，方便下次断言是比对。<ul><li>如果没有实现该接口类型还要把  itab.fun[0] 置为0</li></ul></li></ul><p><strong>为什么需要判断  itab.fun[0] 是否等于0？</strong></p><p>因为 Go 语言会把断言失败的类型组合也存到哈希表，同时把  itab.fun[0] 置为0，用以标识这里的动态类型并没有实现对应的接口。</p><p><strong>这样下次断言的时候找到 itab 发现  itab.fun[0]=0，就直接返回断言失败</strong>。</p><h3 id="2-4-非空接口-非空接口"><a href="#2-4-非空接口-非空接口" class="headerlink" title="2.4 非空接口.(非空接口)"></a>2.4 非空接口.(非空接口)</h3><p><strong>这里同样是判断非空接口的动态类型是否实现了非空接口</strong>。<br><img src="file-20250119063336492.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">iface2iface</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> w io.Writer</span><br><span class="line">   f, _ := os.Open(<span class="string">&quot;17x.txt&quot;</span>)</span><br><span class="line">   w = f</span><br><span class="line">   r, ok := w.(io.ReadWriter)</span><br><span class="line">   <span class="keyword">if</span> ok &#123;</span><br><span class="line">      fmt.Println(r)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><ul><li>1）空接口.(具体类型)：动态类型等于目标类型的动态类型。</li><li>2）非空接口.(具体类型)：动态类型等于目标类型的动态类型。</li><li>3）空接口.(非空接口)：动态类型是否实现了非空接口的接口类型。</li><li>4）非空接口.(非空接口)：动态类型是否实现了非空接口的接口类型。</li></ul><p>一句话总结：</p><p><strong>断言为具体类型则看动态类型是否相同，断言为非空接口则看是否实现了非空接口的接口类型。</strong></p><p><strong>类型断言的关键是明确接口的动态类型以及对应的类型实现了哪些方法</strong>，明确这些的关键就是<code>类型元数据</code>以及空接口与非空接口的<code>数据结构</code>。</p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;类型断言的关键是明确接口的动态类型以及对应的类型实现了哪些方法&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="关键字" scheme="https://stardustorz.github.io/categories/Golang/%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Go] 反射</title>
    <link href="https://stardustorz.github.io/2021/12/04/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/"/>
    <id>https://stardustorz.github.io/2021/12/04/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/</id>
    <published>2021-12-03T16:00:00.000Z</published>
    <updated>2025-03-09T15:12:52.003Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>反射的作用就是将类型元数据暴露给用户使用</p></blockquote><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p> runtime 包中的类型元数据、空接口、非空接口等数据类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_type</span><br><span class="line">typeAlg</span><br><span class="line">uncommontype</span><br><span class="line">interfacetype</span><br><span class="line">eface</span><br><span class="line">iface</span><br><span class="line">slicetype</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但是这些都是未导出的,于是 reflect 包中由定义了一套，这些类型定义在两个包中是保持一致的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rtype</span><br><span class="line">typeAlg</span><br><span class="line">uncommontype</span><br><span class="line">interfaceType</span><br><span class="line">emptyInterface</span><br><span class="line">noneEmptyInterface</span><br><span class="line">sliceType</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>reflect 包提供了 TypeOf 函数用于获取一个变量的类型信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type &#123;</span><br><span class="line">eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line"><span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反射三大法则：</p><ol><li>从 <code>interface&#123;&#125;</code> 变量可以反射出反射对象；</li><li>从反射对象可以获取 <code>interface&#123;&#125;</code> 变量；</li><li>要修改反射对象，其值必须可设置；</li></ol><h2 id="2-反射获取类型信息"><a href="#2-反射获取类型信息" class="headerlink" title="2 反射获取类型信息"></a>2 反射获取类型信息</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> i17x <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i i17x)</span></span> A() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := i17x&#123;Name: <span class="string">&quot;17x&quot;</span>&#125;</span><br><span class="line">t := reflect.TypeOf(i)</span><br><span class="line"><span class="built_in">println</span>(t.Name(), t.NumMethod())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们想要获取这个结构体的类型信息，调用 TypeOf 方法。</p><p><strong>然而 TypeOf 方法的参数是一个空接口，需要的是一个地址</strong>。</p><p>但是我们这里传递的是一个值类型，难道函数里面用的是 i 的地址？</p><p>并不是，因为这样就违反了传参值拷贝的语义，实际上这里是在<strong>编译期生成了临时变量作为 a 的拷贝</strong>，然后参数就用的这个临时变量的地址。</p><p>这样即符合传参值拷贝的语义又满足了空接口类型的参数只能是地址的需求。</p><p><strong>所有参数为空接口类型的情况，都要像这样。通过传递拷贝后临时变量的地址来实现传值的语义。</strong></p><p>然后 TypeOf 函数会把传进去的 eface 类型的参数转换成 reflect.emptyInterface 类型。</p><blockquote><p>这两个类型定义是一致的，转换后方便 reflect 包操作内部元素。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">_type *_type</span><br><span class="line">data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">typ  *rtype</span><br><span class="line">word unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emptyInterface 中的字段 typ 实现了 reflect.Type 接口，所以接下来只需要将 eface 包装成reflect.Type 类型的返回值即可。</p><p>所以 TypeOf 最终返回值就是一个 非空接口 iface，具体如下：</p><ul><li>1）接口类型 reflect.Type，动态类型为 *rtype</li><li>2）Data 指向我们传入的参数 i 。</li></ul><h2 id="3-反射修改值"><a href="#3-反射修改值" class="headerlink" title="3 反射修改值"></a>3 反射修改值</h2><p>修改变量值就要用到 reflect.Value 类型了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">typ *rtype</span><br><span class="line">ptr unsafe.Pointer</span><br><span class="line">flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1）typ：类型元数据指针</li><li>2）ptr：数据地址</li><li>3）flag：位标识符，存储反射值的一些描述信息<ul><li>是否为指针</li><li>是否为方法</li><li>是否只读</li><li>……</li></ul></li></ul><p>通常会使用 reflect.ValueOf 函数来获取reflect.Value，这里参数也是空接口，所以需要和 TypeOf 函数一样处理，唯一不同的是 <strong>这个临时变量会被显式逃逸到堆上</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">escapes(i)</span><br><span class="line"><span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以最后该函数返回的非空接口中的 data 其实指向的堆上的临时变量。</strong></p><p>例如下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a:=<span class="string">&quot;17x&quot;</span></span><br><span class="line">v := reflect.ValueOf(a)</span><br><span class="line">v.SetString(<span class="string">&quot;i17x&quot;</span>)</span><br><span class="line"><span class="built_in">println</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 v 指向的是堆上的临时变量，所以通过 v 直接修改这样一个用户都不知道的临时变量是行不通的，所以会发生 panic。</p><p><strong>既然有临时变量存在，那怎么才能拿到a的指针？</strong></p><p>为了解决这个问题，就只能在 ValueOf 函数的时候传指针进去，就像这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a:=<span class="string">&quot;17x&quot;</span></span><br><span class="line">v := reflect.ValueOf(a)</span><br><span class="line">v=v.Elem()</span><br><span class="line">v.SetString(<span class="string">&quot;i17x&quot;</span>)</span><br><span class="line"><span class="built_in">println</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样执行传入 a 的地址，虽然还是会创建临时变量，然后逃逸到堆上，最后返回的也是指向的临时变量，但是变量中存放的是a的地址，所以我们可以通过<code>v.Elem()</code> 拿到变量a就可以修改了。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><code>https://www.bilibili.com/video/BV1hv411x7we?p=16</code></p><p><code>https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/</code></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;反射的作用就是将类型元数据暴露给用户使用&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="语言基础" scheme="https://stardustorz.github.io/categories/Golang/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Go] 闭包</title>
    <link href="https://stardustorz.github.io/2021/12/04/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E9%97%AD%E5%8C%85/"/>
    <id>https://stardustorz.github.io/2021/12/04/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E9%97%AD%E5%8C%85/</id>
    <published>2021-12-03T16:00:00.000Z</published>
    <updated>2025-03-09T15:12:39.286Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>闭包是有状态函数</p></blockquote><span id="more"></span><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="1-function-value"><a href="#1-function-value" class="headerlink" title="1 function value"></a>1 function value</h2><p>Go 语言中的函数是头等公民。可以做为参数传递，可以做函数返回值、也可以绑定到变量。</p><p>Go 语言称这样的参数、返回值或变量为<strong>function value</strong>。</p><p>function value 不直接指向函数指令入口，而是指向一个 <code>runtime.funcval</code>结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/runtime2.go</span></span><br><span class="line"><span class="keyword">type</span> funcval <span class="keyword">struct</span> &#123;</span><br><span class="line">fn <span class="type">uintptr</span></span><br><span class="line"><span class="comment">// variable-size, fn-specific data here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 funcval 只有一个字段 fn，存储的就是函数指令入口地址。</p><h2 id="2-闭包-Closure"><a href="#2-闭包-Closure" class="headerlink" title="2 闭包 Closure"></a>2 闭包 Closure</h2><p><strong>为什么要用 funcval 结构体来包装函数指令入口地址，然后使用二级指针来调用？</strong></p><p>主要是为了处理闭包的情况。</p><p>维基百科上的<a href="[https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">闭包</a>](<a href="https://zh.wikipedia.org/wiki/闭包_(计算机科学)))定义如下：">https://zh.wikipedia.org/wiki/闭包_(计算机科学)))定义如下：</a></p><ul><li>1）必须要有在函数外部定义但在函数内部引用的<code>自由变量</code></li><li>2）脱离了形成闭包的上下文，闭包也能照常使用这些自由变量。</li></ul><p>就向下面这个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1 := create()</span><br><span class="line">f2 := create()</span><br><span class="line">fmt.Println(f1())</span><br><span class="line">fmt.Println(f2())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">i := <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create() 函数执行结束后，通过 f1()，f2() 依然可以正常调用这个闭包函数，并使用定义在 create() 函数内部的局部变量 i，所以这符合闭包的定义。</p><p>通常称这个变量 i 为<strong>捕获变量</strong>。</p><p><strong>闭包函数的指令在编译阶段生成，但是闭包对象要到执行阶段才创建，因为每个闭包对象都要保存自己的捕获变量</strong>。</p><p>闭包函数指令存放在栈中的代码段上。</p><p>闭包对象则会分配到堆上，闭包对象具体组成如下：</p><ul><li>1）funcval 结构体</li><li>2）捕获变量列表</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1 := create()</span><br><span class="line">f2 := create()</span><br></pre></td></tr></table></figure><p>这里创建了两个闭包对象，其中的 funcval 都指向同一个函数指令入口，但是捕获变量则需要各自维护。</p><p>然后把这两个闭包对象的地址赋值给接收者，即这里的 f1,f2。</p><p>通过f1、f2调用闭包函数会找到各自对应的 funcval 结构体，拿到同一个函数入口，但是却使用的是各自的捕获变量列表。</p><p><strong>这就是称闭包为有状态函数的原因。</strong></p><h2 id="3-获取捕获列表"><a href="#3-获取捕获列表" class="headerlink" title="3 获取捕获列表"></a>3 获取捕获列表</h2><p><strong>闭包函数是如何找到对应的捕获列表呢？</strong></p><p>Go语言中通过一个 function value 调用函数时，会把对应的<strong>funcval 结构体地址</strong>存入特定寄存器。例如 amd64 平台使用的是 DX 寄存器。</p><p>这样在闭包函数中就可以通过寄存器取出 funcval 结构体的地址，然后加上相应的<strong>偏移量</strong>来找到每一个被捕获的变量。</p><p>所以<strong>Go 语言中闭包就是有捕获列表的 function value</strong>，而没有捕获列表的 function value 直接忽略这个寄存器的值就好了。</p><h2 id="4-捕获变量"><a href="#4-捕获变量" class="headerlink" title="4 捕获变量"></a>4 捕获变量</h2><p>被闭包捕获的变量，要在外层函数闭包函数中表现一致，好像它们在使用同一个变量。为此 Go 语言编译器针对不同情况做了不同的处理。</p><blockquote><p>变量逃逸、参数堆分配、返回值</p></blockquote><h3 id="4-1-没有修改"><a href="#4-1-没有修改" class="headerlink" title="4.1 没有修改"></a>4.1 没有修改</h3><p>被捕获变量 i 除了赋值之外没有被其他地方修改，所以直接拷贝到捕获列表即可。</p><p>就像下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementer</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">i := <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-有修改"><a href="#4-2-有修改" class="headerlink" title="4.2 有修改"></a>4.2 有修改</h3><p>除了初始化赋值外还被修改过，则需要进一步细分。</p><p><strong>捕获的是局部变量</strong></p><p>被闭包捕获的局部变量如果除了初始化赋值外还被修改过，就会分配到堆上。</p><p>闭包导致的局部变量堆分配，也是变量逃逸的一种。</p><p>例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fs := create()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(fs); i++ &#123;</span><br><span class="line">fs[i]()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> (fs [<span class="number">2</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">fs[i] = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create() 函数中的局部变量 i 除了初始化之外，还被修改过(i++)，同时还被闭包捕获，所以会分配到堆上，然后栈上只存储该变量的地址。</p><p>每次 i++ 自增的是堆上的变量 i，而闭包捕获的都是变量 i 的地址，都指向堆上的变量 i。</p><p>最后 i 会自增到 2 ，所以最终闭包打印出来的i值都为2。</p><p><strong>捕获的是参数</strong></p><p>由于参数设计到函数原型，就不能像局部变量这样处理了。</p><p>参数依然通过调用者栈帧传入，但是编译器会把栈上参数拷贝一份到堆上。然后外层函数和闭包函数都使用堆上分配的这个。</p><p><strong>捕获的是返回值</strong></p><p>如果捕获的是返回值，则处理又不同。</p><p>调用者栈帧上依然会分配返回值空间，不过闭包的外层函数会在堆上也分配一个，外层函数和闭包函数都使用堆上分配的这个。</p><p>但是在外层函数返回前，需要把堆上的返回值拷贝到栈上的返回值空间。</p><h3 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3 小结"></a>4.3 小结</h3><p>处理方式虽然多种多样，但是目标只有一个，那就是<strong>保持捕获变量在外层函数和闭包函数中的一致性</strong>。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h2><ul><li><strong>闭包由 funcval 结构体和捕获变量组成</strong>。<pre><code>* funcval 结构体中的 fn 字段指向闭包函数的函数入口* 捕获变量则是当前闭包对象的参数，每个闭包对象维护各种的参数列表。</code></pre></li><li>除初始化外还被修改过的局部变量被闭包捕获后会<strong>分配到堆上，栈上保存的是指向堆上变量的指针</strong>。<pre><code>* 局部变量堆分配，变量逃逸的一种。* 所以这个时候闭包中的局部变量其实就是一个地址，都指向堆上的同一个变量。* 这也是为什么各种 for 循环最后打印出的 i 都是一个值</code></pre></li></ul><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6 参考"></a>6 参考</h2><p><code>https://zh.wikipedia.org/wiki/闭包_(计算机科学)</code></p>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;闭包是有状态函数&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="语言基础" scheme="https://stardustorz.github.io/categories/Golang/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Go] sync.Pool</title>
    <link href="https://stardustorz.github.io/2021/12/04/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Pool/"/>
    <id>https://stardustorz.github.io/2021/12/04/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Pool/</id>
    <published>2021-12-03T16:00:00.000Z</published>
    <updated>2025-05-25T10:28:27.760Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了Go语言(golang)中的<code>sync.pool</code>包。给出了 sync.pool 的基本用法，以及各大框架中的使用案例。并从源码层面对其底层结构和具体实现原理进行分析。</p><blockquote><p>以下分析基于 Go 1.17.1</p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><h3 id="1-1-大致理念"><a href="#1-1-大致理念" class="headerlink" title="1.1 大致理念"></a>1.1 大致理念</h3><p><code>sync.Pool</code> 是 sync 包下的一个组件，可以作为保存临时取还对象的一个“池子”，可以缓存暂时不用的对象，下次需要时直接使用（无需重新分配）。</p><blockquote><p>因为频繁的内存分配和回收会对性能产生影响，通过复用临时对象就可以避免改问题。</p></blockquote><p>下面是 2018 年的时候，《Go 夜读》上关于 <code>sync.Pool</code> 的分享，关于适用场景：</p><blockquote><p>当多个 goroutine 都需要创建同⼀个对象的时候，如果 goroutine 数过多，导致对象的创建数⽬剧增，进⽽导致 GC 压⼒增大。形成 “并发⼤－占⽤内存⼤－GC 缓慢－处理并发能⼒降低－并发更⼤”这样的恶性循环。 在这个时候，需要有⼀个对象池，每个 goroutine 不再⾃⼰单独创建对象，⽽是从对象池中获取出⼀个对象（如果池中已经有的话）。</p></blockquote><p>因此关键思想就是对象的复用，避免重复创建、销毁，下面我们来看看如何使用。</p><p>所以，sync.pool 的作用一句话描述就是，<strong>复用临时对象，以避免频繁的内存分配和回收，从而减少 GC 压力</strong>。</p><h3 id="1-2-基本使用"><a href="#1-2-基本使用" class="headerlink" title="1.2 基本使用"></a>1.2 基本使用</h3><p>首先，<code>sync.Pool</code> 是协程安全的，这对于使用者来说是极其方便的。使用前，设置好对象的 <code>New</code> 函数，用于在 <code>Pool</code> 里没有缓存的对象时，创建一个。之后，在程序的任何地方、任何时候仅通过 <code>Get()</code>、<code>Put()</code> 方法就可以取、还对象了。</p><p>以下为基本使用 demo：</p><blockquote><p>完整代码见 <a href="#">Github</a><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> main  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">   <span class="string">&quot;sync&quot;</span>  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;  </span><br><span class="line">   Name   <span class="type">string</span>  </span><br><span class="line">   Remark [<span class="number">1024</span>]<span class="type">byte</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Gopher)</span></span> Reset() &#123;  </span><br><span class="line">   s.Name = <span class="string">&quot;&quot;</span>  </span><br><span class="line">   s.Remark = [<span class="number">1024</span>]<span class="type">byte</span>&#123;&#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">var</span> gopherPool = sync.Pool&#123;  </span><br><span class="line">   New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">new</span>(Gopher)  </span><br><span class="line">   &#125;,  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   g := gopherPool.Get().(*Gopher)  </span><br><span class="line">   fmt.Println(<span class="string">&quot;首次从 pool 里获取：&quot;</span>, g.Name)  </span><br><span class="line"> ​  </span><br><span class="line">   g.Name = <span class="string">&quot;first&quot;</span>  </span><br><span class="line">   fmt.Printf(<span class="string">&quot;设置 p.Name = %s\n&quot;</span>, g.Name)  </span><br><span class="line">   gopherPool.Put(g)  </span><br><span class="line"> ​  </span><br><span class="line">   fmt.Println(<span class="string">&quot;Pool 里已有一个对象：&amp;&#123;first&#125;，调用 Get: &quot;</span>, gopherPool.Get().(*Gopher).Name)  </span><br><span class="line">   fmt.Println(<span class="string">&quot;Pool 没有对象了，调用 Get: &quot;</span>, gopherPool.Get().(*Gopher).Name)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>运行结果：<br> 首次从 pool 里获取：<br> 设置 p.Name = first<br> Pool 里已有一个对象：&amp;{first}，调用 Get:  first<br> Pool 没有对象了，调用 Get:<br>首先，需要初始化 <code>Pool</code>，唯一需要的就是设置好 <code>New</code> 函数。当调用 Get 方法时，如果池子里缓存了对象，就直接返回缓存的对象。如果没有存货，则调用 New 函数创建一个新的对象。</p></blockquote><p>另外，我们发现 Get 方法取出来的对象和上次 Put 进去的对象实际上是同一个，Pool 没有做任何“清空”的处理。但我们不应当对此有任何假设，因为在实际的并发使用场景中，无法保证这种顺序，<strong>最好的做法是在 Put 前，将对象清空</strong>。</p><p><strong>Benchmark</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> defaultGopher, _ = json.Marshal(Gopher&#123;Name: <span class="string">&quot;17x&quot;</span>&#125;)  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">BenchmarkUnmarshal</span><span class="params">(b *testing.B)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">var</span> g *Gopher  </span><br><span class="line">   <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;  </span><br><span class="line">     g = <span class="built_in">new</span>(Gopher)  </span><br><span class="line">     json.Unmarshal(defaultGopher, g)  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">BenchmarkUnmarshalWithPool</span><span class="params">(b *testing.B)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">var</span> g *Gopher  </span><br><span class="line">   <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;  </span><br><span class="line">     g = gopherPool.Get().(*Gopher)  </span><br><span class="line">     json.Unmarshal(defaultGopher, g)  </span><br><span class="line">     g.Reset() <span class="comment">// 重置后在放进去  </span></span><br><span class="line">     gopherPool.Put(g)  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure><br> ​<br>运行结果：</p><p> BenchmarkUnmarshal-6                9518            124806 ns/op            1280 B/op          6 allocs/op<br> BenchmarkUnmarshalWithPool-6       10000            124350 ns/op             128 B/op          5 allocs/op<br> <code>3287449 357 ns/op</code> 表示单位时间内（默认是1s）被测函数运行了 3287449 次，每次运行耗时 357ns，<br> <code>B/op</code> 是每个操作分配的字节数<br> <code>allocs/op</code> 表示每个操作(单次迭代)发生了多少不同的内存分配。</p><p>功能比较简单，其中 json 反序列化占用了大量时间，因此两种方式最终的执行时间几乎没什么变化。但是内存占用差了一个数量级，使用了 <code>sync.Pool</code> 后，内存占用仅为未使用的 128/1280=1/10，对 GC 的影响就很大了。</p><h3 id="1-3-使用案例"><a href="#1-3-使用案例" class="headerlink" title="1.3 使用案例"></a>1.3 使用案例</h3><h4 id="1-3-1-fmt-包"><a href="#1-3-1-fmt-包" class="headerlink" title="1.3.1 fmt 包"></a>1.3.1 fmt 包</h4><p>这部分主要看 <code>fmt.Printf</code> 如何使用：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;  </span><br><span class="line">   <span class="keyword">return</span> Fprintf(os.Stdout, format, a...)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>继续看 <code>Fprintf</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;  </span><br><span class="line">   p := newPrinter()  </span><br><span class="line">   p.doPrintf(format, a)  </span><br><span class="line">   n, err = w.Write(p.buf)  </span><br><span class="line">   p.free()  </span><br><span class="line">   <span class="keyword">return</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br><code>Fprintf</code> 函数的参数是一个 <code>io.Writer</code>，<code>Printf</code> 传的是 <code>os.Stdout</code>，相当于直接输出到标准输出。这里的 <code>newPrinter</code> 用的就是 Pool：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> ppFree = sync.Pool&#123;  </span><br><span class="line">   New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123; <span class="keyword">return</span> <span class="built_in">new</span>(pp) &#125;,  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">newPrinter</span><span class="params">()</span></span> *pp &#123;  </span><br><span class="line">   p := ppFree.Get().(*pp)  </span><br><span class="line">   p.panicking = <span class="literal">false</span>  </span><br><span class="line">   p.erroring = <span class="literal">false</span>  </span><br><span class="line">   p.wrapErrs = <span class="literal">false</span>  </span><br><span class="line">   p.fmt.init(&amp;p.buf)  </span><br><span class="line">   <span class="keyword">return</span> p  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>回到 <code>Fprintf</code> 函数，拿到 pp 指针后，会做一些 format 的操作，并且将 p.buf 里面的内容写入 w。最后，调用 free 函数，将 pp 指针归还到 Pool 中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(p *pp)</span></span> free() &#123;  </span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">cap</span>(p.buf) &gt; <span class="number">64</span>&lt;&lt;<span class="number">10</span> &#123;  </span><br><span class="line">     <span class="keyword">return</span>  </span><br><span class="line">   &#125;  </span><br><span class="line"> ​  </span><br><span class="line">   p.buf = p.buf[:<span class="number">0</span>]  </span><br><span class="line">   p.arg = <span class="literal">nil</span>  </span><br><span class="line">   p.value = reflect.Value&#123;&#125;  </span><br><span class="line">   p.wrappedErr = <span class="literal">nil</span>  </span><br><span class="line">   ppFree.Put(p)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>归还到 Pool 前还进行了<strong>字段清零</strong>，这样，通过 Get 拿到缓存的对象时，就可以安全地使用了。</p><h4 id="1-3-2-gin-框架"><a href="#1-3-2-gin-框架" class="headerlink" title="1.3.2 gin 框架"></a>1.3.2 gin 框架</h4><p>gin 框架会给每个请求分配一个 Context 用以进行追踪，这就是典型的 sync.pool 使用场景：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Engine &#123;  </span><br><span class="line">engine := &amp;Engine&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">engine.pool.New = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line"><span class="keyword">return</span> engine.allocateContext()  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> engine  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> allocateContext() *Context &#123;  </span><br><span class="line"><span class="keyword">return</span> &amp;Context&#123;engine: engine&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;  </span><br><span class="line">c := engine.pool.Get().(*Context)  </span><br><span class="line">c.writermem.reset(w)  </span><br><span class="line">c.Request = req  </span><br><span class="line">c.reset()  </span><br><span class="line">  </span><br><span class="line">engine.handleHTTPRequest(c)  </span><br><span class="line">  </span><br><span class="line">engine.pool.Put(c)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从 pool 中获取 Context 对象，用完后又还回去，注意 还回去之前这里也调用了 reset() 方法进行<strong>字段清空</strong>。</p><h3 id="1-4-正确姿势"><a href="#1-4-正确姿势" class="headerlink" title="1.4 正确姿势"></a>1.4 正确姿势</h3><p>根据以上几个案例，可以看出正确使用姿势就是：</p><ul><li><p>1）设置 New 方法</p></li><li><p>2）使用时直接 Get</p></li><li><p>3）使用完成后先进行<strong>字段清空</strong>,然后在 Put 回去。</p></li></ul><blockquote><p>一定要进行 Reset，不然会出现意想不到的问题。分享一个<a href="https://github.com/lixd/daily-notes/blob/master/Golang/FAQ/mongodb%E9%87%87%E5%9D%91.md">类似的坑</a></p></blockquote><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><blockquote><p>一下分析基于 Go 1.17.1</p></blockquote><h3 id="2-1-Pool-结构体"><a href="#2-1-Pool-结构体" class="headerlink" title="2.1 Pool 结构体"></a>2.1 Pool 结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;  </span><br><span class="line">noCopy noCopy  </span><br><span class="line">local     unsafe.Pointer <span class="comment">// local fixed-size per-P pool, actual type is [P]poolLocal  </span></span><br><span class="line">localSize <span class="type">uintptr</span>        <span class="comment">// size of the local array  </span></span><br><span class="line">victim     unsafe.Pointer <span class="comment">// local from previous cycle  </span></span><br><span class="line">victimSize <span class="type">uintptr</span>        <span class="comment">// size of victims array  </span></span><br><span class="line">New <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段详解：</p><ul><li><code>noCopy</code>对象，实现了<code>sync.Locker</code>接口，使得内嵌了 noCopy 的对象在进行 go vet 静态检查的时候，可以检查出是否被复制。<ul><li>具体见 <a href="https://github.com/golang/go/issues/8005">Go issues 8005</a></li><li>说明 Pool 对象也是不允许复制的。</li></ul></li><li><code>local</code> 字段存储指向 <code>[P]poolLocal</code> 数组（严格来说，它是一个切片）的指针。<code>localSize</code> 则表示 local 数组的大小。<ul><li>访问时，根据 P 的 id 去访问对应下标的 <code>local[pid]</code></li><li>通过这样的设计，多个 goroutine 使用同一个 Pool 时，减少了竞争，提升了性能。</li><li>有点类似于降低锁粒度，分段锁的思想。</li></ul></li><li><code>victim</code> 和 <code>victimSize</code> 则会在在一轮 GC 到来时，分别“接管” local 和 localSize。<ul><li>victim cache 是一种提高缓存性能的硬件技术;</li><li><code>victim</code> 的机制用于减少 GC 后冷启动导致的性能抖动，让分配对象更平滑;</li></ul></li><li><code>New</code>就是我们指定的新建对象的方法。</li></ul><blockquote><p><a href="https://en.wikipedia.org/wiki/Victim_cache">Victim Cache</a> 是一种提高缓存性能的硬件技术，主要用于提升缓存命令率。<br>所谓受害者缓存（Victim Cache），是一个与直接匹配或低相联缓存并用的、容量很小的全相联缓存。当一个数据块被逐出缓存时，并不直接丢弃，而是暂先进入受害者缓存。如果受害者缓存已满，就替换掉其中一项。当进行缓存标签匹配时，在与索引指向标签匹配的同时，并行查看受害者缓存，如果在受害者缓存发现匹配，就将其此数据块与缓存中的不匹配数据块做交换，同时返回给处理器。</p></blockquote><h4 id="2-1-1-local"><a href="#2-1-1-local" class="headerlink" title="2.1.1 local"></a>2.1.1 local</h4><p>local 具体结构如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> &#123;  </span><br><span class="line">poolLocalInternal  </span><br><span class="line">    <span class="comment">// 将 poolLocal 补齐至128字节(即两个cache line)的倍数，防止 false sharing,  </span></span><br><span class="line">    <span class="comment">// 伪共享，仅占位用，防止在 cache line 上分配多个 poolLocalInternal  </span></span><br><span class="line">pad [<span class="number">128</span> - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%<span class="number">128</span>]<span class="type">byte</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">type</span> poolLocalInternal <span class="keyword">struct</span> &#123;  </span><br><span class="line">private <span class="keyword">interface</span>&#123;&#125; <span class="comment">// Can be used only by the respective P.  </span></span><br><span class="line">shared  poolChain   <span class="comment">// Local P can pushHead/popHead; any P can popTail.  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>poolLocalInternal</code>对象 中包含一个 <code>private</code> 和 <code>shared</code>。其中 private 只有当前 p 能用，shared 则是其他 p 都可以用。</p><h4 id="2-1-2-cpu-cache-amp-false-sharing"><a href="#2-1-2-cpu-cache-amp-false-sharing" class="headerlink" title="2.1.2 cpu cache &amp; false sharing"></a>2.1.2 cpu cache &amp; false sharing</h4><p><strong>cpu cache</strong><br>现代 cpu 中，cache 都划分成以 cache line (cache block) 为单位，在 x86_64 体系下一般都是 64 字节，cache line 是操作的最小单元。 程序即使只想读内存中的 1 个字节数据，也要同时把附近 63 节字加载到 cache 中，如果读取超个 64 字节，那么就要加载到多个 cache line 中。<br>这样，访问后续 63 字节数据时就可以直接从 cache line 中读取，性能有很大提升。</p><p><strong><a href="https://en.wikipedia.org/wiki/False_sharing">false sharing</a></strong></p><blockquote><p>伪共享的非标准定义为：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会令整个 cache line 失效，无意中影响彼此的性能，这就是伪共享。</p></blockquote><p>简单来说，如果没有 pad 字段，那么当需要访问 0 号索引的 poolLocal 时，CPU 同时会把 0 号和 1 号索引同时加载到 cpu cache。在只修改 0 号索引的情况下，会让 1 号索引的 poolLocal 失效。这样，当其他线程想要读取 1 号索引时，发生 cache miss，还得重新再加载，对性能有损。增加一个 <code>pad</code>，补齐缓存行，让相关的字段能独立地加载到缓存行就不会出现 <code>false sharding</code> 了。</p><h4 id="2-1-3-poolChain"><a href="#2-1-3-poolChain" class="headerlink" title="2.1.3 poolChain"></a>2.1.3 poolChain</h4><p><code>poolChain</code> 是一个双端队列的实现<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolChain <span class="keyword">struct</span> &#123;  </span><br><span class="line">  </span><br><span class="line">   head *poolChainElt  </span><br><span class="line">  </span><br><span class="line">   tail *poolChainElt  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> poolChainElt <span class="keyword">struct</span> &#123;  </span><br><span class="line">poolDequeue  </span><br><span class="line">  </span><br><span class="line">next, prev *poolChainElt  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> poolDequeue <span class="keyword">struct</span> &#123;  </span><br><span class="line">  </span><br><span class="line">headTail <span class="type">uint64</span>  </span><br><span class="line">  </span><br><span class="line">vals []eface  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>poolDequeue</code> 被实现为单生产者、多消费者的固定大小的无锁（atomic 实现） Ring 式队列（底层存储使用数组，使用两个指针标记 head、tail）。生产者可以从 head 插入、head 删除，而消费者仅可从 tail 删除。 <code>headTail</code> 指向队列的头和尾，通过位运算将 head 和 tail 存入 headTail 变量中。</p><p>我们用一幅图来完整地描述 Pool 结构体：</p><p>![[pool-structure.png]]</p><blockquote><p>图源：<a href="https://zhuanlan.zhihu.com/p/133638023">码农桃花源</a></p><h3 id="2-2-大致流程"><a href="#2-2-大致流程" class="headerlink" title="2.2 大致流程"></a>2.2 大致流程</h3></blockquote><p>分析完 Pool 结构体之后，先提前说明一下大致的流程，后续分析时便于理解。</p><p><strong>存储</strong></p><p>为每个 P 开辟了一个 Local 用于数据，降低竞争。</p><p>Local 中包含 private 和 shared。</p><ul><li><p>private ：只有当前 P 能使用</p></li><li><p>shared：所有 P 共享，当 private 没有时优先去当前 P 的 local.shared 中取，如果还没有就去其他 P 中 local.shared 中窃取一个来用。</p></li></ul><p><strong>Get</strong></p><p>优先从当前P 的 local.private 中取，没有则从当前 P 的 local.shared 中取，还没有则去其他 P 中 local.shared 中窃取一个。</p><p><strong>Put</strong></p><p>优先存放到当前 P 的 local.private，local.private 已经有值了就往 shared 中放。</p><h3 id="2-3-Get"><a href="#2-3-Get" class="headerlink" title="2.3 Get"></a>2.3 Get</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Get() <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">l, pid := p.pin()  </span><br><span class="line">x := l.private  </span><br><span class="line">l.private = <span class="literal">nil</span>  </span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;  </span><br><span class="line">x, _ = l.shared.popHead()  </span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;  </span><br><span class="line">x = p.getSlow(pid)  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">runtime_procUnpin()  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;  </span><br><span class="line">x = p.New()  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> x  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程如下：</p><ol><li><p>首先，调用 <code>p.pin()</code> 函数将当前的 goroutine 和 P 绑定，禁止被抢占，返回当前 P 对应的 poolLocal，以及 pid。</p></li><li><p>然后直接取 l.private，赋值给 x，并置 l.private 为 nil。</p></li><li><p>判断 x 是否为空，若为空，则尝试从 l.shared 的头部 pop 一个对象出来，同时赋值给 x。</p></li><li><p>如果 x 仍然为空，则调用 getSlow 尝试从其他 P 的 shared 双端队列尾部“偷”一个对象出来。</p></li><li><p>Pool 的相关操作做完了，调用 <code>runtime_procUnpin()</code> 解除禁止抢占。</p></li><li><p>最后如果还是没有取到缓存的对象，那就直接调用预先设置好的 New 函数，创建一个出来。</p></li></ol><h4 id="2-3-1-pin"><a href="#2-3-1-pin" class="headerlink" title="2.3.1 pin"></a>2.3.1 pin</h4><p>首先，调用 <code>p.pin()</code> 函数将当前的 goroutine 和 P 绑定，禁止被抢占，返回当前 P 对应的 poolLocal，以及 pid。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pin() (*poolLocal, <span class="type">int</span>) &#123;  </span><br><span class="line">   <span class="comment">// pin 具体逻辑由 runtime_procPin 实现  </span></span><br><span class="line">   pid :=  runtime_procPin()  </span><br><span class="line">   <span class="comment">// 原子操作取出 p.localSize 和 p.local  </span></span><br><span class="line">   s := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire  </span></span><br><span class="line">   l := p.local                              <span class="comment">// load-consume  </span></span><br><span class="line">   <span class="comment">// 因为是把 pid 做下标从 pool.local 中取得 p 对应的 local 的，  </span></span><br><span class="line">   <span class="comment">// 所以如果 pid 小于 pool.local size 的时候才有可能取到对应的 local  </span></span><br><span class="line">   <span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;  </span><br><span class="line">      <span class="keyword">return</span> indexLocal(l, pid), pid  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// 正常情况下会一直满足该条件，  </span></span><br><span class="line">   <span class="comment">// 只有刚开始  pool.local 还没创建或者动态调整了 P 的数量这两种情况  </span></span><br><span class="line">   <span class="comment">// 会进入到下面的逻辑 去创建 pool.local  </span></span><br><span class="line">   <span class="keyword">return</span> p.pinSlow()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-3-2-pinSlow"><a href="#2-3-2-pinSlow" class="headerlink" title="2.3.2 pinSlow"></a>2.3.2 pinSlow</h4><p>pinSlow 主要是完成 pool.local 的创建。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pinSlow() (*poolLocal, <span class="type">int</span>) &#123;  </span><br><span class="line">    <span class="comment">// 这里先取消绑定，然后加锁，最后有绑定上  </span></span><br><span class="line">runtime_procUnpin()  </span><br><span class="line">allPoolsMu.Lock()  </span><br><span class="line"><span class="keyword">defer</span> allPoolsMu.Unlock()  </span><br><span class="line">pid := runtime_procPin()  </span><br><span class="line"><span class="comment">// doubleCheck 因为在执行上述命令过程中 pinSlow 可能已经被其他的线程调用，因此这时候需要再次对 pid 进行检查  </span></span><br><span class="line">s := p.localSize  </span><br><span class="line">l := p.local  </span><br><span class="line"><span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;  </span><br><span class="line"><span class="keyword">return</span> indexLocal(l, pid), pid  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> p.local == <span class="literal">nil</span> &#123;  </span><br><span class="line">allPools = <span class="built_in">append</span>(allPools, p)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 根据当前 P 的数量创建 pool.local并更新pool.localSize  </span></span><br><span class="line">size := runtime.GOMAXPROCS(<span class="number">0</span>)  </span><br><span class="line">local := <span class="built_in">make</span>([]poolLocal, size)  </span><br><span class="line">atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="number">0</span>])) <span class="comment">// store-release  </span></span><br><span class="line">runtime_StoreReluintptr(&amp;p.localSize, <span class="type">uintptr</span>(size))     <span class="comment">// store-release  </span></span><br><span class="line">    <span class="comment">// 最后根据 pid 返回当前 P 对应的 local  </span></span><br><span class="line"><span class="keyword">return</span> &amp;local[pid], pid  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### popHead</span><br><span class="line"></span><br><span class="line">然后回到 Get 方法</span><br><span class="line">```go</span><br><span class="line">x := l.private  </span><br><span class="line">l.private = nil  </span><br><span class="line">if x == nil &#123;  </span><br><span class="line">x, _ = l.shared.popHead()  </span><br><span class="line">if x == nil &#123;  </span><br><span class="line">x = p.getSlow(pid)  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">优先从 local.private 中取，如果没有就调用`poolChain.popHead()`去 local.shared 中取一个。</span><br><span class="line">```go</span><br><span class="line">func (c *poolChain) popHead() (interface&#123;&#125;, bool) &#123;  </span><br><span class="line">d := c.head  </span><br><span class="line">for d != nil &#123;  </span><br><span class="line">if val, ok := d.popHead(); ok &#123;  </span><br><span class="line">return val, ok  </span><br><span class="line">&#125;  </span><br><span class="line">d = loadPoolChainElt(&amp;d.prev)  </span><br><span class="line">&#125;  </span><br><span class="line">return nil, false  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`popHead` 函数只会被 producer 调用。首先拿到头节点：c.head，如果头节点不为空的话，尝试调用头节点的 `poolDequeue.popHead` 方法。</span><br><span class="line">```go</span><br><span class="line">func (d *poolDequeue) popHead() (interface&#123;&#125;, bool) &#123;  </span><br><span class="line">var slot *eface  </span><br><span class="line">for &#123;  </span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">head, tail := d.unpack(ptrs)  </span><br><span class="line">        // 收尾相连则说明队列是空的  </span><br><span class="line">if tail == head &#123;  </span><br><span class="line">return nil, false  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// head 位置是队头的前一个位置，所以此处要先退一位。  </span><br><span class="line">        // 在读出 slot 的 value 之前就把 head 值减 1，取消对这个 slot 的控制  </span><br><span class="line">head--  </span><br><span class="line">ptrs2 := d.pack(head, tail)  </span><br><span class="line">        // 通过 CAS 操作更新头部的位置 这样当前头部第一个元素就算是被移除了  </span><br><span class="line">if atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;  </span><br><span class="line">slot = &amp;d.vals[head&amp;uint32(len(d.vals)-1)]  </span><br><span class="line">break  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">    // 类型转换与 nil 判断  </span><br><span class="line">val := *(*interface&#123;&#125;)(unsafe.Pointer(slot))  </span><br><span class="line">if val == dequeueNil(nil) &#123;  </span><br><span class="line">val = nil  </span><br><span class="line">&#125;  </span><br><span class="line">    // 然后把这个 slot 置空，因为现在这个 slot 已经是队列的 head 了，置空便于前一个 head 被回收。  </span><br><span class="line">*slot = eface&#123;&#125;  </span><br><span class="line">return val, true  </span><br><span class="line">&#125;```</span><br></pre></td></tr></table></figure><p>此函数会删掉并且返回 <code>queue</code> 的头节点。但如果 <code>queue</code> 为空的话，返回 false。这里的 <code>queue</code> 存储的实际上就是 Pool 里缓存的对象。</p><p>整个函数的核心是一个无限循环，这是 Go 中常用的无锁化编程形式。</p><p>首先调用 unpack 函数分离出 head 和 tail 指针，如果 head 和 tail 相等，即首尾相等，那么这个队列就是空的，直接就返回 nil，false。</p><p>否则，将 head 指针后移一位，即 head 值减 1，然后调用 pack 打包 head 和 tail 指针。使用 CAS 更新 headTail 的值，并且把 vals 相应索引处的元素赋值给 slot。</p><blockquote><p>因为 <code>vals</code> 长度实际是只能是 2 的 n 次幂，因此 <code>len(d.vals)-1</code> 实际上得到的值的低 n 位是全 1，它再与 head 进行与运算，实际就是取 head 低 n 位的值作为下标。</p></blockquote><p>得到相应 slot 的元素后，经过类型转换并判断是否是 <code>dequeueNil</code>，如果是，说明没取到缓存的对象，返回 nil。</p><p>type dequeueNil *struct{}</p><p>最后，返回 val 之前，将 slot “归零”，移除和上一个 head 的关联，便于回收上一个 Head。</p><p>*slot = eface{}</p><p>结束后回到 <code>poolChain.popHead()</code>，如果调用 <code>poolDequeue.popHead()</code> 拿到了缓存的对象，就直接返回。否则，将 <code>d</code> 重新指向 <code>d.prev</code>，继续尝试获取缓存的对象。</p><h4 id="2-3-3-getSlow"><a href="#2-3-3-getSlow" class="headerlink" title="2.3.3 getSlow"></a>2.3.3 getSlow</h4><p>如果在 shared 里没有获取到缓存对象，则继续调用 <code>Pool.getSlow()</code>，尝试从其他 P 的 poolLocal 偷取：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> getSlow(pid <span class="type">int</span>) <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line">size := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire  </span></span><br><span class="line">locals := p.local                            <span class="comment">// load-consume  </span></span><br><span class="line">    <span class="comment">// 尝试从其他 p 中窃取一个对象  </span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;  </span><br><span class="line">        <span class="comment">// (pid+i+1)%int(size) 保证每次都可以从 当前pid+1 这个位置开始尝试窃取。  </span></span><br><span class="line">l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="type">int</span>(size))  </span><br><span class="line">        <span class="comment">// 如果能取到就直接返回  </span></span><br><span class="line"><span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> x  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 尝试从其他 P 的 poolLocal 窃取失败后，再尝试从victim cache中取对象  </span></span><br><span class="line">    <span class="comment">// 这样可以使 victim 中的对象更容易被回收。  </span></span><br><span class="line">size = atomic.LoadUintptr(&amp;p.victimSize)  </span><br><span class="line"><span class="keyword">if</span> <span class="type">uintptr</span>(pid) &gt;= size &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">locals = p.victim  </span><br><span class="line">l := indexLocal(locals, pid)  </span><br><span class="line"><span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123;  </span><br><span class="line">l.private = <span class="literal">nil</span>  </span><br><span class="line"><span class="keyword">return</span> x  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;  </span><br><span class="line">l := indexLocal(locals, (pid+i)%<span class="type">int</span>(size))  </span><br><span class="line"><span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> x  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 清空 victim cache。下次就不用再从这里找了  </span></span><br><span class="line">atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;<span class="string">``</span><span class="string">`</span></span><br></pre></td></tr></table></figure></p><p>从索引为 pid+1 的 poolLocal 处开始，尝试调用 <code>shared.popTail()</code> 获取缓存对象。如果没有拿到，则从 victim 里找，和 poolLocal 的逻辑类似。</p><p>最后，实在没找到，就把 victimSize 置 0，防止后来的“人”再到 victim 里找。</p><p>在 Get 函数的最后，经过这一番操作还是没找到缓存的对象，就调用 New 函数创建一个新的对象。</p><h4 id="2-3-4-popTail"><a href="#2-3-4-popTail" class="headerlink" title="2.3.4 popTail"></a>2.3.4 popTail</h4><p>最后，还剩一个 popTail 函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> popTail() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;  </span><br><span class="line">    <span class="comment">// tail 指针为空直接返回 这里的 tail 是一个双端队列  </span></span><br><span class="line">d := loadPoolChainElt(&amp;c.tail)  </span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> &#123;  </span><br><span class="line"><span class="comment">// It&#x27;s important that we load the next pointer  </span></span><br><span class="line"><span class="comment">// *before* popping the tail. In general, d may be  </span></span><br><span class="line"><span class="comment">// transiently empty, but if next is non-nil before  </span></span><br><span class="line"><span class="comment">// the pop and the pop fails, then d is permanently  </span></span><br><span class="line"><span class="comment">// empty, which is the only condition under which it&#x27;s  </span></span><br><span class="line"><span class="comment">// safe to drop d from the chain.  </span></span><br><span class="line">        <span class="comment">// 在 for 循环的一开始，就把 d.next 加载到了 d2。因为 d 可能会短暂为空，但如果 d2 在 pop 或者 pop fails 之前就不为空的话，说明 d 就会永久为空了。在这种情况下，可以安全地将 d 这个结点“甩掉”。  </span></span><br><span class="line">d2 := loadPoolChainElt(&amp;d.next)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> val, ok := d.popTail(); ok &#123;  </span><br><span class="line"><span class="keyword">return</span> val, ok  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> d2 == <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="comment">// This is the only dequeue. It&#x27;s empty right  </span></span><br><span class="line"><span class="comment">// now, but could be pushed to in the future.  </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 同样的通过 CAS 来更新 tail 的值为 d2  </span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) &#123;  </span><br><span class="line">storePoolChainElt(&amp;d2.prev, <span class="literal">nil</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">        <span class="comment">// 最后将d2赋值给d便于进行下一轮循环。  </span></span><br><span class="line">d = d2  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p><p>在 for 循环的一开始，就把 d.next 加载到了 d2。因为 d 可能会短暂为空，但如果 d2 在 pop 或者 pop fails 之前就不为空的话，说明 d 就会永久为空了。在这种情况下，可以安全地将 d 这个结点“甩掉”。</p><p>最后，将 c.tail 更新为 d2，可以防止下次 popTail 的时候查看一个空的 dequeue；而将 d2.prev 设置为 nil，可以防止下次 popHead 时查看一个空的 dequeue。</p><p>我们再看一下核心的 <code>poolDequeue.popTail</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popTail() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;  </span><br><span class="line"><span class="keyword">var</span> slot *eface  </span><br><span class="line"><span class="keyword">for</span> &#123;  </span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">head, tail := d.unpack(ptrs)  </span><br><span class="line">        <span class="comment">// 同样的 head=tail 说明队列为空  </span></span><br><span class="line"><span class="keyword">if</span> tail == head &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 同样是 CAS 更新 headTail 以移除 tail 元素  </span></span><br><span class="line">ptrs2 := d.pack(head, tail+<span class="number">1</span>)  </span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;  </span><br><span class="line"><span class="comment">// Success.  </span></span><br><span class="line">slot = &amp;d.vals[tail&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]  </span><br><span class="line"><span class="keyword">break</span>  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 类型转换和 nil 判断  </span></span><br><span class="line">val := *(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot))  </span><br><span class="line"><span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;  </span><br><span class="line">val = <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 最后也是将这个 slot 置空  </span></span><br><span class="line">    <span class="comment">// 先清空 val 再清空 typ 操作顺序和 pushHead 正好相反  </span></span><br><span class="line">slot.val = <span class="literal">nil</span>  </span><br><span class="line">atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">true</span>  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popTail() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;  </span><br><span class="line"><span class="keyword">var</span> slot *eface  </span><br><span class="line"><span class="keyword">for</span> &#123;  </span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">head, tail := d.unpack(ptrs)  </span><br><span class="line">        <span class="comment">// 同样的 head=tail 说明队列为空  </span></span><br><span class="line"><span class="keyword">if</span> tail == head &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 同样是 CAS 更新 headTail 以移除 tail 元素  </span></span><br><span class="line">ptrs2 := d.pack(head, tail+<span class="number">1</span>)  </span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;  </span><br><span class="line"><span class="comment">// Success.  </span></span><br><span class="line">slot = &amp;d.vals[tail&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]  </span><br><span class="line"><span class="keyword">break</span>  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 类型转换和 nil 判断  </span></span><br><span class="line">val := *(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot))  </span><br><span class="line"><span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;  </span><br><span class="line">val = <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 最后也是将这个 slot 置空  </span></span><br><span class="line">    <span class="comment">// 先清空 val 再清空 typ 操作顺序和 pushHead 正好相反  </span></span><br><span class="line">slot.val = <span class="literal">nil</span>  </span><br><span class="line">atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>)  </span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整体逻辑和 popHead 差不多。</p><h4 id="2-3-5-小结"><a href="#2-3-5-小结" class="headerlink" title="2.3.5 小结"></a>2.3.5 小结</h4><p>首先从 当前 p 对应的 local.private 上取，没有就从 local.shared 里取，还没有就去其他 p 的 local.shared 里取，都没有就 new 一个返回。</p><h3 id="2-4-Put"><a href="#2-4-Put" class="headerlink" title="2.4 Put"></a>2.4 Put</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Put(x <span class="keyword">interface</span>&#123;&#125;) &#123;  </span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">return</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">l, _ := p.pin()  </span><br><span class="line"><span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123;  </span><br><span class="line">l.private = x  </span><br><span class="line">x = <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> x != <span class="literal">nil</span> &#123;  </span><br><span class="line">l.shared.pushHead(x)  </span><br><span class="line">&#125;  </span><br><span class="line">runtime_procUnpin()  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程也比较简单：</p><ol><li>先绑定 g 和 P，然后尝试将 x 赋值给 private 字段。</li><li>如果失败，就调用 <code>pushHead</code> 方法尝试将其放入 shared 字段所维护的双端队列中。<h4 id="2-4-1-pushHead"><a href="#2-4-1-pushHead" class="headerlink" title="2.4.1 pushHead"></a>2.4.1 pushHead</h4></li></ol><p>p.pin() 和之前是一样的，就不分析了，主要看一下 pushHead()<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> pushHead(val <span class="keyword">interface</span>&#123;&#125;) &#123;  </span><br><span class="line">d := c.head  </span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="comment">// 第一次写入，队列为空则进行初始化 默认长度为8  </span></span><br><span class="line"><span class="keyword">const</span> initSize = <span class="number">8</span> <span class="comment">// Must be a power of 2  </span></span><br><span class="line">d = <span class="built_in">new</span>(poolChainElt)  </span><br><span class="line">d.vals = <span class="built_in">make</span>([]eface, initSize)  </span><br><span class="line">c.head = d  </span><br><span class="line">storePoolChainElt(&amp;c.tail, d)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 存储元素 存储成功直接返回  </span></span><br><span class="line"><span class="keyword">if</span> d.pushHead(val) &#123;  </span><br><span class="line"><span class="keyword">return</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// The current dequeue is full. Allocate a new one of twice  </span></span><br><span class="line"><span class="comment">// the size.  </span></span><br><span class="line">    <span class="comment">// 存储失败说明队列满了 进行扩容  </span></span><br><span class="line">newSize := <span class="built_in">len</span>(d.vals) * <span class="number">2</span>  </span><br><span class="line"><span class="keyword">if</span> newSize &gt;= dequeueLimit &#123; <span class="comment">// 限制一下，不能无限扩容  </span></span><br><span class="line">newSize = dequeueLimit  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 扩容逻辑也比较简单，就是首尾相连，构成链表  </span></span><br><span class="line">d2 := &amp;poolChainElt&#123;prev: d&#125;  </span><br><span class="line">d2.vals = <span class="built_in">make</span>([]eface, newSize)  </span><br><span class="line">c.head = d2  </span><br><span class="line">storePoolChainElt(&amp;d.next, d2)  </span><br><span class="line">d2.pushHead(val)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果 <code>c.head</code> 为空，就要创建一个 poolChainElt，作为首结点，当然也是尾节点。它管理的双端队列的长度，初始为 8，放满之后，再创建一个 poolChainElt 节点时，双端队列的长度就要翻倍。当然，有一个最大长度限制（2^30）：</p><p>const dequeueBits = 32  </p><p>const dequeueLimit = (1 &lt;&lt; dequeueBits) / 4</p><p>调用 <code>poolDequeue.pushHead</code> 尝试将对象放到 poolDeque 里去：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> pushHead(val <span class="keyword">interface</span>&#123;&#125;) <span class="type">bool</span> &#123;  </span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">head, tail := d.unpack(ptrs)  </span><br><span class="line">    <span class="comment">// 首先判断队列是否已满： 也就是将尾部指针加上 d.vals 的长度，再取低 31 位，看它是否和 head 相等  </span></span><br><span class="line"><span class="keyword">if</span> (tail+<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)))&amp;(<span class="number">1</span>&lt;&lt;dequeueBits<span class="number">-1</span>) == head &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">slot := &amp;d.vals[head&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Check if the head slot has been released by popTail.  </span></span><br><span class="line">typ := atomic.LoadPointer(&amp;slot.typ)  </span><br><span class="line"><span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="comment">// Another goroutine is still cleaning up the tail, so  </span></span><br><span class="line"><span class="comment">// the queue is actually still full.  </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// slot占位，将val存入vals中  </span></span><br><span class="line"><span class="keyword">if</span> val == <span class="literal">nil</span> &#123;  </span><br><span class="line">val = dequeueNil(<span class="literal">nil</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">*(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot)) = val  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// head 增加 1  </span></span><br><span class="line">atomic.AddUint64(&amp;d.headTail, <span class="number">1</span>&lt;&lt;dequeueBits)  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先判断队列是否已满：</p><pre><code>if (tail+uint32(len(d.vals)))&amp;(1&lt;&lt;dequeueBits-1) == head &#123;      return false  &#125;</code></pre><p>队列没满，通过 head 指针找到即将填充的 slot 位置：取 head 指针的低 31 位。</p><pre><code>slot := &amp;d.vals[head&amp;uint32(len(d.vals)-1)]  // Check if the head slot has been released by popTail.  typ := atomic.LoadPointer(&amp;slot.typ)  if typ != nil &#123;      // Another goroutine is still cleaning up the tail, so      // the queue is actually still full.      return false  &#125;</code></pre><p>这里还判断了当前 slot 是否正在被 popTail 释放，popTail 相关语句如下：</p><pre><code>// 最后也是将这个 slot 置空  // 先清空 val 再清空 typ 操作顺序和 pushHead 正好相反  slot.val = nil  atomic.StorePointer(&amp;slot.typ, nil)</code></pre><p>所以如果 slot.typ==nil 就说明这个 slot 正在被 popTail 释放，说明队列其实还是满的，直接返回 false，走后续的扩容逻辑。</p><p>最后，将 val 赋值到 slot，并将 head 指针值加 1。</p><p>// slot占位，将val存入vals中<br><em>(</em>interface{})(unsafe.Pointer(slot)) = val</p><blockquote><p>这里的实现比较巧妙，slot 是 eface 类型，即空接口，将 slot 转为 interface{} 类型，这样 val 能以 interface{} 赋值给 slot 让 slot.typ 和 slot.val 指向其内存块，于是 slot.typ 和 slot.val 均不为空。</p></blockquote><h4 id="2-4-2-pack-unpack"><a href="#2-4-2-pack-unpack" class="headerlink" title="2.4.2 pack/unpack"></a>2.4.2 pack/unpack</h4><p>最后我们再来看一下 pack 和 unpack 函数，它们实际上是一组绑定、解绑 head 和 tail 指针的两个函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> pack(head, tail <span class="type">uint32</span>) <span class="type">uint64</span> &#123;  </span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span>  </span><br><span class="line"><span class="keyword">return</span> (<span class="type">uint64</span>(head) &lt;&lt; dequeueBits) |  </span><br><span class="line"><span class="type">uint64</span>(tail&amp;mask)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`mask`</span> 的低 <span class="number">31</span> 位为全 <span class="number">1</span>，其他位为 <span class="number">0</span>，它和 tail 相与，就是只看 tail 的低 <span class="number">31</span> 位。而 head 向左移 <span class="number">32</span> 位之后，低 <span class="number">32</span> 位为全 <span class="number">0</span>。最后把两部分“或”起来，head 和 tail 就“绑定”在一起了。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> unpack(ptrs <span class="type">uint64</span>) (head, tail <span class="type">uint32</span>) &#123;  </span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span>  </span><br><span class="line">head = <span class="type">uint32</span>((ptrs &gt;&gt; dequeueBits) &amp; mask)  </span><br><span class="line">tail = <span class="type">uint32</span>(ptrs &amp; mask)  </span><br><span class="line"><span class="keyword">return</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>unpack 则是相反的逻辑，取出 head 指针的方法就是将 ptrs 右移 32 位，再与 mask 相与，同样只看 head 的低 31 位。而 tail 实际上更简单，直接将 ptrs 与 mask 相与就可以了。</p><h4 id="2-4-3-小结"><a href="#2-4-3-小结" class="headerlink" title="2.4.3 小结"></a>2.4.3 小结</h4><p>Put 和 Get 类似，首先尝试将放到当前 p 的 local.private 上，已经有了就放到 local.shared。</p><h3 id="2-5-GC"><a href="#2-5-GC" class="headerlink" title="2.5 GC"></a>2.5 GC</h3><p>对于 Pool 而言，并不能无限扩展，否则对象占用内存太多了，会引起内存溢出。<br>sync.pool 选择了在 GC 时进行清理。<br>在 pool.go 文件的 init 函数里，注册了 GC 发生时，如何清理 Pool 的函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/pool.go  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;  </span><br><span class="line">runtime_registerPoolCleanup(poolCleanup)  </span><br><span class="line">&#125;</span><br><span class="line">编译器在编译时将其注册到运行时：</span><br><span class="line"><span class="comment">// src/runtime/mgc.go  </span></span><br><span class="line"><span class="comment">// Hooks for other packages  </span></span><br><span class="line"><span class="keyword">var</span> poolcleanup <span class="function"><span class="keyword">func</span><span class="params">()</span></span>  </span><br><span class="line"><span class="comment">// 利用编译器标志将 sync 包中的清理注册到运行时  </span></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_registerPoolCleanup sync.runtime_registerPoolCleanup  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_registerPoolCleanup</span><span class="params">(f <span class="keyword">func</span>()</span></span>) &#123;  </span><br><span class="line">  poolcleanup = f  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">具体的 poolCleanup() 函数如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolCleanup</span><span class="params">()</span></span> &#123;  </span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> oldPools &#123;  </span><br><span class="line">p.victim = <span class="literal">nil</span>  </span><br><span class="line">p.victimSize = <span class="number">0</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> allPools &#123;  </span><br><span class="line">p.victim = p.local  </span><br><span class="line">p.victimSize = p.localSize  </span><br><span class="line">p.local = <span class="literal">nil</span>  </span><br><span class="line">p.localSize = <span class="number">0</span>  </span><br><span class="line">&#125;  </span><br><span class="line">oldPools, allPools = allPools, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整体看起来，比较简洁。主要是将 local 和 victim 作交换，这样也就不致于让 GC 把所有的 Pool 都清空了，有 victim 在“兜底”。</p><ol><li>初始状态下，oldPools 和 allPools 均为 nil。</li><li>第 1 次调用 Get，由于 p.local 为 nil，将会在 pinSlow 中创建 p.local，然后将 p 放入 allPools，此时 allPools 长度为 1，oldPools 为 nil。</li><li>对象使用完毕，第 1 次调用 Put 放回对象。</li><li>第 1 次GC STW 阶段，allPools 中所有 p.local 将值赋值给 victim 并置为 nil。allPools 赋值给 oldPools，最后 allPools 为 nil，oldPools 长度为 1。</li><li>第 2 次调用 Get，由于 p.local 为 nil，此时会从 p.victim 里面尝试取对象。</li><li>对象使用完毕，第 2 次调用 Put 放回对象，但由于 p.local 为 nil，重新创建 p.local，并将对象放回，此时 allPools 长度为 1，oldPools 长度为 1。</li><li>第 2 次 GC STW 阶段，oldPools 中所有 p.victim 置 nil，前一次的 cache 在本次 GC 时被回收，allPools 所有 p.local 将值赋值给 victim 并置为nil，最后 allPools 为 nil，oldPools 长度为 1。<br>简单来说就是清理时，先清理 oldPools 的 local.victim,然后把 allPools 中的 local 赋值给 victim，最后再把 allPools 赋值给 oldPools，把 allPools 置空。<blockquote><p>GC 时只会清理 oldPools，allPools 只会先把数据转移到 victim，然后把 allPools 变成 oldPools，如果从 oldPools 中读取出来的数据进行 Put 也会直接放到 allPools 中，相当于要两次 GC 都没有被访问到并且Put回来才会被移除。</p></blockquote></li></ol><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><ul><li><p>1）关键思想是对象的复用，避免重复创建、销毁。将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力。</p></li><li><p>2）<code>sync.Pool</code> 是协程安全的，使用起来非常方便。设置好 New 函数后，调用 Get 获取，调用 Put 归还对象。</p></li><li><p>3）不要对 Get 得到的对象有任何假设，更好的做法是归还对象时，将对象“清空”。</p></li><li><p>4）Pool 里对象的生命周期受 GC 影响，不适合于做连接池，因为连接池需要自己管理对象的生命周期。</p></li></ul><p>一些设计思想或者相关知识点：</p><ul><li><p>lock free：无锁编程是很多编程语言里逃离不了的话题。<code>sync.Pool</code>的无锁是在<code>poolDequeue</code>和<code>poolChain</code>层面实现的。</p></li><li><p>原子操作代替锁：<code>poolDequeue</code>对一些关键变量采用了CAS操作，比如<code>poolDequeue.headTail</code>，既可完整保证并发又能降低相比锁而言的开销。</p></li><li><p>cacheline false sharing 问题</p></li><li><p>noCopy 禁止复制</p></li><li><p>分段锁，降低锁粒度</p></li><li><p>victim cache</p></li><li><p>常见优化手段：复用</p></li></ul><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><code>https://golang.org/src/sync/pool.go</code></p><p><code>https://en.wikipedia.org/wiki/False_sharing</code></p><p><code>https://en.wikipedia.org/wiki/Victim_cache</code></p><p><code>https://zhuanlan.zhihu.com/p/110140126</code></p><p><code>https://medium.com/swlh/go-the-idea-behind-sync-pool-32da5089df72</code></p><p><code>https://zhuanlan.zhihu.com/p/133638023</code></p><p><code>https://www.jianshu.com/p/dc4b5562aad2</code></p><p><code>https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/</code></p><p>[Github]  <a href="https://github.com/lixd/i-go/blob/master/a-tutorials/lib/sync_pool/main.go">https://github.com/lixd/i-go/blob/master/a-tutorials/lib/sync_pool/main.go</a> </p><p>[pool-structure]  <a href="https://github.com/lixd/blog/raw/master/images/golang/lib/sync-pool/pool-structure.png">https://github.com/lixd/blog/raw/master/images/golang/lib/sync-pool/pool-structure.png</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要介绍了Go语言(golang)中的&lt;code&gt;sync.pool&lt;/code&gt;包。给出了 sync.pool 的基本用法，以及各大框架中的使用案例。并从源码层面对其底层结构和具体实现原理进行分析。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以下分析基于 Go 1.17</summary>
      
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="并发编程" scheme="https://stardustorz.github.io/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>[Go] sync.WaitGroup</title>
    <link href="https://stardustorz.github.io/2021/12/04/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.WaitGroup/"/>
    <id>https://stardustorz.github.io/2021/12/04/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.WaitGroup/</id>
    <published>2021-12-03T16:00:00.000Z</published>
    <updated>2025-05-25T10:27:11.092Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Golang 调度方式：<code>主动让渡</code>和<code>被动调度</code><br>   被动调度: <code>通道 channel</code> 、<code>单机锁 sync.Mutex</code>、<code>并发等待组 sync.WaitGroup</code><br>当 goroutine 之间需要建立明确的<code>层级关系</code>. 倘若父 goroutine 希望持有子 goroutine 的生杀大权，并且保证父 goroutine 消亡时能连带回收其创建的所有子 goroutine ，此时可以使用到 Golang 上下文工具 context，完成父 goroutine 对 子 goroutine 的<code>生命周期控制</code></p><p>多个协程等待一个协程执行完，除了WaitGroup 还有什么方式？  写入channel，for循环读</p><h2 id="1-How-to-use？"><a href="#1-How-to-use？" class="headerlink" title="1 How to use？"></a>1 How to use？</h2><h3 id="1-1-核心方法"><a href="#1-1-核心方法" class="headerlink" title="1.1 核心方法"></a>1.1 核心方法</h3><p>• <code>WaitGroup.Add(n)</code>：完成一次登记操作，使得 WaitGroup 中并发计数器的数值加上 n. 在使用场景中，WaitGroup.Add(n) 背后的含义是，注册并启动了 n 个子 goroutine<br>• <code>WaitGroup.Done()</code>：完成一次上报操作，使得 WaitGroup 中并发计数器的数值减 1. 在使用场景中，通常会在一个子 goroutine 退出前，会执行一次 WaitGroup.Done 方法<br>• <code>WaitGroup.Wait()</code>：完成聚合操作. 通常由主 goroutine 调用该方法，主 goroutine 会因此陷入阻塞，直到所有子 goroutine 都已经执行完成，使得 WaitGroup 并发计数器数值清零时，主 goroutine 才得以继续往下执行</p></blockquote><h3 id="1-2-案例"><a href="#1-2-案例" class="headerlink" title="1.2 案例"></a>1.2 案例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_waitGroup</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup   <span class="comment">// 声明等待组 wg</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;   <span class="comment">// 循环开启十个子 Goroutine</span></span><br><span class="line">        wg.Add(<span class="number">1</span>)               <span class="comment">// 登记子 Goroutine</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()     <span class="comment">// 保证退出前会调用一次，完成上报</span></span><br><span class="line">            &lt;-time.After(time.Second)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()                   <span class="comment">// 阻塞等待，直到等待组全部完成后才往下走</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：子 goroutine 是异步启动的，所以有可能出现 Wait 方法先于 Add 方法执行，此时由于计数器值为 0，Wait 方法会被直接放行，导致产生预期之外的执行流程；因此要保证 add 在 done 之前。</p></blockquote><h3 id="1-3-WaitGroup-channel-完成数据聚合"><a href="#1-3-WaitGroup-channel-完成数据聚合" class="headerlink" title="1.3 WaitGroup + channel 完成数据聚合"></a>1.3 WaitGroup + channel 完成数据聚合</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_waitGroup</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tasksNum := <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据缓存 channel</span></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    <span class="comment">// 数据结果 slice</span></span><br><span class="line">    resp := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, tasksNum)</span><br><span class="line">    <span class="comment">// 控制管道</span></span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 启动读 goroutine</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> data := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">            resp = <span class="built_in">append</span>(resp, data)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标识数据读取完成</span></span><br><span class="line">        stopCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证获取到所有数据后，通过 channel 传递到读协程手中</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; tasksNum; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            ch &lt;- time.Now().UnixNano()</span><br><span class="line">        &#125;(dataCh)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确保所有取数据的协程都完成了工作，才关闭 ch</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(dataCh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保读协程处理完成</span></span><br><span class="line">    &lt;-stopCh</span><br><span class="line"></span><br><span class="line">    t.Logf(<span class="string">&quot;resp: %+v&quot;</span>, resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-源码走读"><a href="#2-源码走读" class="headerlink" title="2 源码走读"></a>2 源码走读</h2><h3 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h3><p>WaitGroup 位于 golang sync 包下，对应的类声明中包含了几个核心字段：</p><ul><li><code>noCopy</code>：这是防拷贝标识，标记了 WaitGroup 不应该用于值传递</li><li><code>state1</code>：这是 WaitGroup 的核心字段，是一个无符号的64位整数，高32位是 WaitGroup 中并发计数器的数值，即当前 WaitGroup.Add 与 WaitGroup.Done 之间的差值；低 32 位标识了，当前有多少 goroutine 因 WaitGroup.Wait 操作而处于阻塞态，陷入阻塞态的原因是因为计数器的值没有清零，即 state1 字段高 32 位是一个正值</li><li><code>state2</code>：用于阻塞和唤醒 goroutine 的信号量</li></ul><p><code>WaitGroup.Add</code> 方法会给 WaitGroup 的计数器累加上一定的值，背后的含义是标识出当前有多少 goroutine 正在运行，需要由 WaitGroup.Done 操作完成数值的抵扣：</p><ul><li>首先通过 WaitGroup.state 方法，获取到 WaitGroup 的 state1 和 state2 字段，分别将字段对应的地址赋给临时变量 statep 和 semap</li><li>调用 atomic.AddUint64，直接通过指针的方式直接在 WaitGroup.state1 的高 32 位基础上累加上 delta 的值</li><li>获取到 state1 高 32 位的值，赋值给局部变量 v，其含义是并发计数器的数值，即 WaitGroup.Add 和 WaitGroup.Done 之间的差值</li><li>获取到 state1 低 32 位的值，赋值给局部变量 w. 其含义是因执行 WaitGroup.Wait 操作而陷入阻塞态的 goroutine 数量</li><li>倘若 WaitGroup 计数器出现负值，直接 panic（ Done 不应该多于 Add ）</li><li>倘若首次 Add 操作是在有 goroutine 因 Wait 操作而陷入阻塞时才执行，抛出 panic（if w != 0 &amp;&amp; delta &gt; 0 &amp;&amp; v == int32(delta) ）</li><li>倘若执行完 Add 操作后，WaitGroup 的计数器还是正值，则直接返回</li><li>倘若发现本次 Add 操作后， WaitGroup 计数器被清零了，则接下来需要依次把因 Wait 操作而陷入阻塞的 goroutine 唤醒. 在这期间，不允许再并发执行 Add 操作，否则会 panic</li><li>唤醒 goroutine 使用的方法是 runtime_Semrelease 方法，底层会执行 goready 操作，属于 goroutine 的被动调度模式</li></ul><p>执行 WaitGroup.Wait 方法，会判断 WaitGroup 中的并发计数器数值是否为 0，如果不等于0，则当前 goroutine 会陷入阻塞态，直到计数器数值清零之后，才会被唤醒. 具体的执行流程如下：</p><ul><li>执行 WaitGroup.state 方法，获取到 state1 和 state2 字段</li><li>走进 for 循环开启自旋流程</li><li>将 state1 高 32 位所存储的计数器数值赋给局部变量 v</li><li>将 state1 低 32 位所存储的阻塞 goroutine 数量赋给局部变量 w</li><li>倘若计数器数值 v 已经是 0 了，则无需阻塞 goroutine，直接返回即可</li><li>倘若计数器数值 v 大于 0，代表当前 goroutine 需要被阻塞挂起.</li><li>基于 cas，将 state1 低 32 位的数值加 1，标识有一个额外的 goroutine 需要阻塞挂起了</li><li>调用 runtime_Semacquire 方法，内部会通过 go park 操作，将当前 goroutine 阻塞挂起，属于被动调度模式</li><li>当 goroutine 从 runtime_Semacquire 方法走出来时，说明 WaitGroup 计数器已经被清零了.</li><li>在被唤醒的 goroutine 返回前，WaitGroup 不能被并发执行 Add 操作，否则会陷入 panic</li><li>被唤醒的 goroutine 正常返回，Wait 流程结束</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Golang 调度方式：&lt;code&gt;主动让渡&lt;/code&gt;和&lt;code&gt;被动调度&lt;/code&gt;&lt;br&gt;   被动调度: &lt;code&gt;通道 channel&lt;/code&gt; 、&lt;code&gt;单机锁 sync.Mutex&lt;/code&gt;、&lt;code&gt;并发等待组</summary>
      
    
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/categories/Golang/"/>
    
    <category term="并发编程" scheme="https://stardustorz.github.io/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="Golang" scheme="https://stardustorz.github.io/tags/Golang/"/>
    
  </entry>
  
</feed>
