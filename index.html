<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->


<!-- Website keywords -->




<!-- Website rss -->

<link rel="alternate" href="/default" title="Draco's Blog" >


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://stardustorz.github.io/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":false};
</script>
  
  <title>Draco&#39;s Blog</title>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Draco&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        Home              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        Archives              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        Tags              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        Categories              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        About              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">Draco's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              Home  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              Archives  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              Tags  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              Categories  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              About  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <section id="posts" class="posts">
  
  
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/05/07/Basic/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"></a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-05-07
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="1-一、文件和目录"><a href="#1-一、文件和目录" class="headerlink" title="1 一、文件和目录"></a>1 一、文件和目录</h2><blockquote>
<p>查看路径</p>
</blockquote>
<h3 id="1-1-pwd"><a href="#1-1-pwd" class="headerlink" title="1.1 pwd"></a>1.1 <strong>pwd</strong></h3><p><strong>显示当前目录的路径</strong></p>
<h3 id="1-2-which"><a href="#1-2-which" class="headerlink" title="1.2 which"></a>1.2 <strong>which</strong></h3><p>查看命令的可执行文件所在路径， Linux 下，每一条命令其实都对应一个可执行程序，在终端中输入命令，按回车的时候，就是执行了对应的那个程序， which 命令本身对应的程序也存在于 Linux 中。</p>
<p>总的来说一个命令就是一个可执行程序。</p>
<blockquote>
<p><em>浏览和切换目录</em></p>
</blockquote>
<h3 id="1-3-ls"><a href="#1-3-ls" class="headerlink" title="1.3 ls"></a>1.3 <strong>ls</strong></h3><p><strong>列出文件和目录，它是 Linux 最常用的命令之一。</strong></p>
<p>【常用参数】</p>
<ul>
<li>-a 显示所有文件和目录包括隐藏的</li>
<li>-l 显示详细列表</li>
<li>-h 适合人类阅读的</li>
<li>-t 按文件最近一次修改时间排序</li>
<li>-i 显示文件的 inode （ inode 是文件内容的标识）</li>
</ul>
<h3 id="1-4-cd"><a href="#1-4-cd" class="headerlink" title="1.4 cd"></a>1.4 <strong>cd</strong></h3><p><strong>cd 是英语 change directory 的缩写，表示切换目录。</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd / --&gt; 跳转到根目录</span><br><span class="line">cd ~ --&gt; 跳转到家目录</span><br><span class="line">cd .. --&gt; 跳转到上级目录</span><br><span class="line">cd ./home --&gt; 跳转到当前目录的home目录下</span><br><span class="line">cd /home/lion --&gt; 跳转到根目录下的home目录下的lion目录</span><br><span class="line">cd --&gt; 不添加任何参数，也是回到家目录</span><br></pre></td></tr></table></figure>
<p>[注意] 输入cd /ho + 单次 tab 键会自动补全路径 + 两次 tab 键会列出所有可能的目录列表。</p>
<h3 id="1-5-du"><a href="#1-5-du" class="headerlink" title="1.5 du"></a>1.5 <strong>du</strong></h3><p><strong>列举目录大小信息。</strong></p>
<p>【常用参数】</p>
<ul>
<li>-h 适合人类阅读的；</li>
<li>-a 同时列举出目录下文件的大小信息；</li>
<li>-s 只显示总计大小，不显示具体信息。</li>
</ul>
<h3 id="1-6-浏览和创建文件"><a href="#1-6-浏览和创建文件" class="headerlink" title="1.6 浏览和创建文件"></a>1.6 浏览和创建文件</h3><h3 id="1-7-cat"><a href="#1-7-cat" class="headerlink" title="1.7 cat"></a>1.7 <strong>cat</strong></h3><p><strong>一次性显示文件所有内容，更适合查看小的文件。</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat cloud-init.log</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>【常用参数】</p>
<ul>
<li>-n 显示行号。  </li>
</ul>
<h3 id="1-8-less"><a href="#1-8-less" class="headerlink" title="1.8 less"></a>1.8 <strong>less</strong></h3><p><strong>分页显示文件内容，更适合查看大的文件。</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">less cloud-init.log</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>【快捷操作】</p>
<ul>
<li>空格键：前进一页（一个屏幕）；</li>
<li>b 键：后退一页；</li>
<li>回车键：前进一行；</li>
<li>y 键：后退一行；</li>
<li>上下键：回退或前进一行；</li>
<li>d 键：前进半页；</li>
<li>u 键：后退半页；</li>
<li>q 键：停止读取文件，中止 less 命令；</li>
<li>= 键：显示当前页面的内容是文件中的第几行到第几行以及一些其它关于本页内容的详细信息；</li>
<li>h 键：显示帮助文档；</li>
<li>/ 键：进入搜索模式后，按 n 键跳到一个符合项目，按 N 键跳到上一个符合项目，同时也可以输入<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">正则表达式</a>匹配。</li>
</ul>
<h3 id="1-9-head"><a href="#1-9-head" class="headerlink" title="1.9 head"></a>1.9 <strong>head</strong></h3><p><strong>显示文件的开头几行（默认是10行）</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head cloud-init.log</span><br></pre></td></tr></table></figure>
<p>【参数】</p>
<ul>
<li>-n 指定行数 head cloud-init.log -n 2  </li>
</ul>
<h3 id="1-10-tail"><a href="#1-10-tail" class="headerlink" title="1.10 tail"></a>1.10 <strong>tail</strong></h3><p><strong>显示文件的结尾几行（默认是10行）</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail cloud-init.log复制代码</span><br></pre></td></tr></table></figure>
<p>【参数】</p>
<ul>
<li>-n 指定行数 tail cloud-init.log -n 2</li>
<li>-f 会每过1秒检查下文件是否有更新内容，也可以用 -s 参数指定间隔时间 tail -f -s 4 xxx.log</li>
</ul>
<h3 id="1-11-touch"><a href="#1-11-touch" class="headerlink" title="1.11 touch"></a>1.11 <strong>touch</strong></h3><p><strong>创建一个文件</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch new_file复制代码</span><br></pre></td></tr></table></figure>
<h3 id="1-12-mkdir"><a href="#1-12-mkdir" class="headerlink" title="1.12 mkdir"></a>1.12 <strong>mkdir</strong></h3><p><strong>创建一个目录</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir new_folder复制代码</span><br></pre></td></tr></table></figure>
<p>【常用参数】</p>
<ul>
<li>-p 递归的创建目录结构 mkdir -p one/two/three  </li>
</ul>
<blockquote>
<p>文件的复制和移动</p>
</blockquote>
<h3 id="1-13-cp"><a href="#1-13-cp" class="headerlink" title="1.13 cp"></a>1.13 <strong>cp</strong></h3><p><strong>拷贝文件和目录</strong></p>
<p>cp file file_copy —&gt; file 是目标文件，file_copy 是拷贝出来的文件cp file one —&gt; 把 file 文件拷贝到 one 目录下，并且文件名依然为 file</p>
<p>cp file one/file_copy —&gt; 把 file 文件拷贝到 one 目录下，文件名为file_copy</p>
<p>cp *.txt folder —&gt; 把当前目录下所有 txt 文件拷贝到 folder 目录下</p>
<p>【常用参数】</p>
<ul>
<li>-r 递归的拷贝，常用来拷贝一整个目录  </li>
</ul>
<h3 id="1-14-mv"><a href="#1-14-mv" class="headerlink" title="1.14 mv"></a>1.14 <strong>mv</strong></h3><p><strong>移动（重命名）文件或目录，与cp命令用法相似。</strong></p>
<p>mv file one —&gt; 将 file 文件移动到 one 目录下</p>
<p>mv new_folder one —&gt; 将 new_folder 文件夹移动到one目录下mv *.txt folder —&gt; 把当前目录下所有 txt 文件移动到 folder 目录下mv file new_file —&gt; file 文件重命名为 new_file</p>
<blockquote>
<p>文件的删除和链接</p>
</blockquote>
<h3 id="1-15-rm"><a href="#1-15-rm" class="headerlink" title="1.15 rm"></a>1.15 <strong>rm</strong></h3><p><strong>删除文件和目录，由于 Linux 下没有回收站，一旦删除非常难恢复，因此需要谨慎操作</strong></p>
<p>rm new_file —&gt; 删除 new_file 文件</p>
<p>rm f1 f2 f3 —&gt; 同时删除 f1 f2 f3 3个文件</p>
<p>【常用参数】</p>
<ul>
<li>-i 向用户确认是否删除；</li>
<li>-f 文件强制删除；</li>
<li>-r 递归删除文件夹，著名的删除操作 rm -rf 。  </li>
</ul>
<h3 id="1-16-ln"><a href="#1-16-ln" class="headerlink" title="1.16 ln"></a>1.16 <strong>ln</strong></h3><p><strong>英文 Link 的缩写，表示创建链接。</strong></p>
<p>学习创建链接之前，首先要理解链接是什么，我们先来看看 Linux 的文件是如何存储的：</p>
<p>Linux 文件的存储方式分为3个部分，文件名、文件内容以及权限，其中文件名的列表是存储在硬盘的其它地方和文件内容是分开存放的，每个文件名通过 inode 标识绑定到文件内容。</p>
<p>Linux 下有两种链接类型：硬链接和软链接。</p>
<h3 id="1-17-硬链接"><a href="#1-17-硬链接" class="headerlink" title="1.17 硬链接"></a>1.17 硬链接</h3><p>使链接的两个文件共享同样文件内容，就是同样的 inode ，一旦文件1和文件2之间有了硬链接，那么修改任何一个文件，修改的都是同一块内容，它的缺点是，只能创建指向文件的硬链接，不能创建指向目录的（其实也可以，但比较复杂）而软链接都可以，<strong>因此软链接使用更加广泛</strong>。</p>
<p>这个部分暂时不展开。  </p>
<h2 id="2-二、用户与权限"><a href="#2-二、用户与权限" class="headerlink" title="2 二、用户与权限"></a>2 二、用户与权限</h2><blockquote>
<p>用户</p>
</blockquote>
<p>Linux 是一个多用户的操作系统。在 Linux 中，理论上来说，我们可以创建无数个用户，但是这些用户是被划分到不同的群组里面的，有一个用户，名叫 root ，是一个很特殊的用户，它是超级用户，拥有最高权限。</p>
<h3 id="2-1-sudo"><a href="#2-1-sudo" class="headerlink" title="2.1 sudo"></a>2.1 <strong>sudo</strong></h3><p><strong>以 root 身份运行命令</strong></p>
<h3 id="2-2-useradd-passwd"><a href="#2-2-useradd-passwd" class="headerlink" title="2.2 useradd + passwd"></a>2.2 <strong>useradd + passwd</strong></h3><ul>
<li>useradd 添加新用户</li>
<li>passwd 修改用户密码</li>
</ul>
<p>这两个命令需要 root 用户权限</p>
<h3 id="2-3-userdel"><a href="#2-3-userdel" class="headerlink" title="2.3 userdel"></a>2.3 <strong>userdel</strong></h3><p><strong>删除用户，需要 root 用户权限</strong></p>
<h3 id="2-4-su"><a href="#2-4-su" class="headerlink" title="2.4 su"></a>2.4 <strong>su</strong></h3><p><strong>切换用户</strong>，需要 root 用户权限</p>
<blockquote>
<p>群组的管理</p>
</blockquote>
<p>Linux 中每个用户都属于一个特定的群组，如果你不设置用户的群组，默认会创建一个和它的用户名一样的群组，并且把用户划归到这个群组。</p>
<h3 id="2-5-groupadd"><a href="#2-5-groupadd" class="headerlink" title="2.5 groupadd"></a>2.5 <strong>groupadd</strong></h3><p><strong>创建群组，</strong>用法和 useradd 类似</p>
<h3 id="2-6-groupdel"><a href="#2-6-groupdel" class="headerlink" title="2.6 groupdel"></a>2.6 <strong>groupdel</strong></h3><p><strong>删除一个已存在的群组</strong></p>
<h3 id="2-7-groups"><a href="#2-7-groups" class="headerlink" title="2.7 groups"></a>2.7 <strong>groups</strong></h3><p><strong>查看用户所在群组</strong></p>
<h3 id="2-8-usermod"><a href="#2-8-usermod" class="headerlink" title="2.8 usermod"></a>2.8 <strong>usermod</strong></h3><p><strong>用于修改用户的账户。</strong></p>
<p>【常用参数】</p>
<ul>
<li>-l 对用户重命名。需要注意的是 /home 中的用户家目录的名字不会改变，需要手动修改。</li>
<li>-g 修改用户所在的群组，例如 usermod -g friends lion修改 lion 用户的群组为 friends 。</li>
<li>-G 一次性让用户添加多个群组，例如 usermod -G friends,foo,bar lion 。</li>
<li>-a -G 会让你离开原先的群组，如果你不想这样做的话，就得再添加 -a 参数，意味着append 追加的意思。  </li>
</ul>
<h3 id="2-9-chgrp"><a href="#2-9-chgrp" class="headerlink" title="2.9 chgrp"></a>2.9 <strong>chgrp</strong></h3><p><strong>用于修改文件的群组。</strong></p>
<h3 id="2-10-chown"><a href="#2-10-chown" class="headerlink" title="2.10 chown"></a>2.10 <strong>chown</strong></h3><p><strong>改变文件的所有者</strong>，需要 root 身份才能运行。</p>
<p>【常用参数】</p>
<ul>
<li>-R 递归设置子目录和子文件， chown -R lion:lion /home/frank 把 frank 文件夹的用户和群组都改为 lion 。</li>
</ul>
<blockquote>
<p>文件权限管理</p>
</blockquote>
<h3 id="2-11-chmod"><a href="#2-11-chmod" class="headerlink" title="2.11 chmod"></a>2.11 <strong>chmod</strong></h3><p><strong>修改访问权限。</strong></p>
<p>【常用参数】</p>
<ul>
<li>-R 可以递归地修改文件访问权限，例如 chmod -R 777 /home/lion</li>
</ul>
<p>其中 drwxr-xr-x 表示文件或目录的权限。让我们一起来解读它具体代表什么？</p>
<ul>
<li>d ：表示目录，就是说这是一个目录，普通文件是 - ，链接是 l 。</li>
<li>r ：read 表示文件可读。</li>
<li>w ：write 表示文件可写，一般有写的权限，就有删除的权限。</li>
<li>x ：execute 表示文件可执行。</li>
<li><ul>
<li>：表示没有相应权限。</li>
</ul>
</li>
</ul>
<p>现在再来理解这句权限 drwxr-xr-x 的意思：</p>
<ul>
<li>它是一个文件夹；</li>
<li>它的所有者具有：读、写、执行权限；</li>
<li>它的群组用户具有：读、执行的权限，没有写的权限；</li>
<li>它的其它用户具有：读、执行的权限，没有写的权限。  </li>
</ul>
<p>现在理解了权限，我们使用 chmod 来尝试修改权限。chmod 它不需要是 root 用户才能运行的，只要你是此文件所有者，就可以用 chmod 来修改文件的访问权限。</p>
<p><img src="https://pic1.zhimg.com/80/v2-419fd37f2018837b1ffd75925e24901e_1440w.webp?source=1940ef5c" alt=""></p>
<p>chmod 640 hello.c</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>6 = 4 + 2 + 0 表示所有者具有 rw 权限</p>
<p>4 = 4 + 0 + 0 表示群组用户具有 r 权限</p>
<p>0 = 0 + 0 + 0 表示其它用户没有权限</p>
<p>对应文字权限为：-rw-r——-</p>
<h3 id="0-1-用字母来分配权限"><a href="#0-1-用字母来分配权限" class="headerlink" title="0.1 用字母来分配权限"></a>0.1 用字母来分配权限</h3><ul>
<li>u ：user 的缩写，用户的意思，表示所有者。</li>
<li>g ：group 的缩写，群组的意思，表示群组用户。</li>
<li>o ：other 的缩写，其它的意思，表示其它用户。</li>
<li>a ：all 的缩写，所有的意思，表示所有用户。</li>
<li><ul>
<li>：加号，表示添加权限。</li>
</ul>
</li>
<li><ul>
<li>：减号，表示去除权限。</li>
</ul>
</li>
<li>= ：等于号，表示分配权限。</li>
</ul>
<p>chmod u+rx file —&gt; 文件file的所有者增加读和运行的权限</p>
<p>chmod g+r file —&gt; 文件file的群组用户增加读的权限</p>
<p>chmod o-r file—&gt; 文件file的其它用户移除读的权限</p>
<p>chmod g+r file —&gt; 文件file的群组用户增加读的权限，其它用户移除读的权限</p>
<p>chmod go-r file —&gt; 文件file的群组和其他用户移除读的权限</p>
<p>chmod +x file —&gt; 文件file的所有用户增加运行的权限</p>
<p>chmod u=rwx,g=r,o=- file —&gt; 文件file的所有者分配读写和执行的权限，群组其它用户分配读的权限，其他用户没有任何权限</p>
<h2 id="1-三、查找文件"><a href="#1-三、查找文件" class="headerlink" title="1 三、查找文件"></a>1 三、查找文件</h2><h3 id="1-1-locate"><a href="#1-1-locate" class="headerlink" title="1.1 locate"></a>1.1 <strong>locate</strong></h3><p><strong>搜索包含关键字的所有文件和目录。后接需要查找的文件名，也可以用正则表达式。</strong></p>
<h3 id="1-2-安装-locate"><a href="#1-2-安装-locate" class="headerlink" title="1.2 安装 locate"></a>1.2 安装 locate</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mlocate --&gt; 安装包updatedb --&gt; 更新数据库复制代码locate file.txtlocate fil*.txt</span><br></pre></td></tr></table></figure>
<p>[注意] locate 命令会去<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%BA%93&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">文件数据库</a>中查找命令，而不是全磁盘查找，因此刚创建的文件并不会更新到数据库中，所以无法被查找到，可以执行 updatedb 命令去更新数据库。</p>
<blockquote>
<p>find</p>
</blockquote>
<p>用于查找文件，它会去遍历你的实际硬盘进行查找，而且它允许我们对每个找到的文件进行后续操作，功能非常强大。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &lt;何处&gt; &lt;何物&gt; &lt;做什么&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>何处：指定在哪个目录查找，此目录的所有子目录也会被查找。</li>
<li>何物：查找什么，可以根据文件的名字来查找，也可以根据其大小来查找，还可以根据其最近访问时间来查找。</li>
<li>做什么：找到文件后，可以进行后续处理，如果不指定这个参数， find 命令只会显示找到的文件。  </li>
</ul>
<h3 id="1-3-根据文件名查找"><a href="#1-3-根据文件名查找" class="headerlink" title="1.3 根据文件名查找"></a>1.3 <strong>根据文件名查找</strong></h3><p>find -name “file.txt” —&gt; 当前目录以及子目录下通过名称查找文件</p>
<p>find . -name “syslog” —&gt; 当前目录以及子目录下通过名称查找文件</p>
<p>find / -name “syslog” —&gt; 整个硬盘下查找syslog</p>
<p>find /var/log -name “syslog” —&gt; 在指定的目录/var/log下查找syslog文件find /var/log -name “syslog*” —&gt; 查找syslog1、syslog2 … 等文件，通配符表示所有</p>
<p>find /var/log -name “<em>syslog</em>“ —&gt; 查找包含syslog的文件</p>
<p>[注意] find 命令只会查找完全符合 “何物” 字符串的文件，而 locate 会查找所有包含关键字的文件。</p>
<h3 id="1-4-根据文件大小查找"><a href="#1-4-根据文件大小查找" class="headerlink" title="1.4 根据文件大小查找"></a>1.4 <strong>根据文件大小查找</strong></h3><p>find /var -size +10M —&gt; /var 目录下查找文件大小超过 10M 的文件</p>
<p>find /var -size -50k —&gt; /var 目录下查找文件大小小于 50k 的文件</p>
<p>find /var -size +1G —&gt; /var 目录下查找文件大小查过 1G 的文件</p>
<p>find /var -size 1M —&gt; /var 目录下查找文件大小等于 1M 的文件</p>
<h3 id="1-5-根据文件最近访问时间查找"><a href="#1-5-根据文件最近访问时间查找" class="headerlink" title="1.5 根据文件最近访问时间查找"></a>1.5 <strong>根据文件最近访问时间查找</strong></h3><p>find -name “*.txt” -atime -7</p>
<p>—&gt; 近 7天内访问过的.txt结尾的文件</p>
<h3 id="1-6-仅查找目录或文件-根据类型查找"><a href="#1-6-仅查找目录或文件-根据类型查找" class="headerlink" title="1.6 仅查找目录或文件,根据类型查找"></a>1.6 <strong>仅查找目录或文件,根据类型查找</strong></h3><p>find . -name “file” -type f</p>
<p>—&gt; 只查找当前目录下的file文件</p>
<p>find . -name “file” -type d</p>
<p>—&gt; 只查找当前目录下的file目录</p>
<blockquote>
<p>软件仓库</p>
</blockquote>
<p>Linux 下软件是以包的形式存在，一个软件包其实就是软件的所有文件的压缩包，是二进制的形式，包含了安装软件的所有指令。Red Hat 家族的软件包后缀名一般为 .rpm ，Debian 家族的软件包后缀是 .deb 。</p>
<p>Linux 的包都存在一个仓库，叫做软件仓库，它可以使用 yum 来管理软件包， yum 是 CentOS 中默认的包管理工具，适用于 Red Hat 一族。可以理解成 Node.js 的 npm 。</p>
<blockquote>
<p>yum 常用命令</p>
</blockquote>
<ul>
<li>yum update | yum upgrade 更新软件包</li>
<li>yum search xxx 搜索相应的软件包</li>
<li>yum install xxx 安装软件包</li>
<li>yum remove xxx 删除软件包</li>
</ul>
<h2 id="2-四、文本操作"><a href="#2-四、文本操作" class="headerlink" title="2 四、文本操作"></a>2 四、文本操作</h2><blockquote>
<p>grep</p>
</blockquote>
<p><strong>全局搜索一个正则表达式，并且打印到屏幕。简单来说就是，在文件中查找关键字，并显示关键字所在行。</strong></p>
<h3 id="2-1-基础语法"><a href="#2-1-基础语法" class="headerlink" title="2.1 基础语法"></a>2.1 基础语法</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep text file # text代表要搜索的文本，file代表供搜索的文件</span><br></pre></td></tr></table></figure>
<h3 id="2-2-常用参数"><a href="#2-2-常用参数" class="headerlink" title="2.2 常用参数"></a>2.2 常用参数</h3><ul>
<li>-i 忽略大小写， grep -i path /etc/profile</li>
<li>-n 显示行号，grep -n path /etc/profile</li>
<li>-v 只显示搜索文本不在的那些行，grep -v path /etc/profile</li>
<li>-r 递归查找， grep -r hello /etc ，Linux 中还有一个 rgrep 命令，作用相当于 grep -r</li>
</ul>
<h3 id="2-3-sort"><a href="#2-3-sort" class="headerlink" title="2.3 sort"></a>2.3 sort</h3><p><strong>对文件的行进行排序。</strong></p>
<h3 id="2-4-基础语法"><a href="#2-4-基础语法" class="headerlink" title="2.4 基础语法"></a>2.4 基础语法</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort name.txt # 对name.txt文件进行排序</span><br></pre></td></tr></table></figure>
<h3 id="2-5-实例用法"><a href="#2-5-实例用法" class="headerlink" title="2.5 实例用法"></a>2.5 实例用法</h3><p>为了演示方便，我们首先创建一个文件 name.txt ，放入以下内容：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChristopherShawnTedRockNoahZacharyBella</span><br></pre></td></tr></table></figure>
<p>执行 sort name.txt 命令，会对文本内容进行排序。</p>
<h3 id="2-6-常用参数"><a href="#2-6-常用参数" class="headerlink" title="2.6 常用参数"></a>2.6 常用参数</h3><ul>
<li>-o 将排序后的文件写入新文件， sort -o name_sorted.txt name.txt ；</li>
<li>-r 倒序排序， sort -r name.txt ；</li>
<li>-R 随机排序， sort -R name.txt ；</li>
<li>-n 对数字进行排序，默认是把数字识别成字符串的，因此 138 会排在 25 前面，如果添加了 -n 数字排序的话，则 25 会在 138 前面。</li>
</ul>
<h3 id="2-7-wc"><a href="#2-7-wc" class="headerlink" title="2.7 wc"></a>2.7 wc</h3><p><strong>word count 的缩写，用于文件的统计。它可以统计单词数目、行数、字符数，字节数等。</strong></p>
<h3 id="2-8-基础语法"><a href="#2-8-基础语法" class="headerlink" title="2.8 基础语法"></a>2.8 基础语法</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc name.txt # 统计name.txt</span><br></pre></td></tr></table></figure>
<h3 id="2-9-实例用法"><a href="#2-9-实例用法" class="headerlink" title="2.9 实例用法"></a>2.9 实例用法</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lion ~]# wc name.txt 13 13 91 name.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个13，表示行数；</li>
<li>第二个13，表示单词数；</li>
<li>第三个91，表示字节数。</li>
</ul>
<h3 id="2-10-常用参数"><a href="#2-10-常用参数" class="headerlink" title="2.10 常用参数"></a>2.10 常用参数</h3><ul>
<li>-l 只统计行数， wc -l name.txt ；</li>
<li>-w 只统计单词数， wc -w name.txt ；</li>
<li>-c 只统计字节数， wc -c name.txt ；</li>
<li>-m 只统计字符数， wc -m name.txt 。  </li>
</ul>
<h3 id="2-11-uniq"><a href="#2-11-uniq" class="headerlink" title="2.11 uniq"></a>2.11 uniq</h3><p><strong>删除文件中的重复内容。</strong></p>
<h3 id="2-12-基础语法"><a href="#2-12-基础语法" class="headerlink" title="2.12 基础语法"></a>2.12 基础语法</h3><p>uniq name.txt # 去除name.txt重复的行数，并打印到屏幕上</p>
<p>【注意】它只能去除连续重复的行数。</p>
<h3 id="2-13-常用参数"><a href="#2-13-常用参数" class="headerlink" title="2.13 常用参数"></a>2.13 常用参数</h3><ul>
<li>-c 统计重复行数， uniq -c name.txt ；</li>
<li>-d 只显示重复的行数， uniq -d name.txt 。  </li>
</ul>
<h3 id="2-14-cut"><a href="#2-14-cut" class="headerlink" title="2.14 cut"></a>2.14 <strong>cut</strong></h3><p><strong>剪切文件的一部分内容。</strong></p>
<h3 id="2-15-基础语法"><a href="#2-15-基础语法" class="headerlink" title="2.15 基础语法"></a>2.15 基础语法</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -c 2-4 name.txt # 剪切每一行第二到第四个字符</span><br></pre></td></tr></table></figure>
<h3 id="2-16-常用参数"><a href="#2-16-常用参数" class="headerlink" title="2.16 常用参数"></a>2.16 常用参数</h3><ul>
<li>-d 用于指定用什么分隔符（比如逗号、分号、双引号等等） cut -d , name.txt ；</li>
<li>-f 表示剪切下用分隔符分割的哪一块或哪几块区域， cut -d , -f 1 name.txt 。  </li>
</ul>
<h2 id="3-五、重定向-管道-流"><a href="#3-五、重定向-管道-流" class="headerlink" title="3 五、重定向 管道 流"></a>3 五、重定向 管道 流</h2><p>在 Linux 中一个命令的去向可以有3个地方：终端、文件、作为另外一个命令的入参。</p>
<p>命令一般都是通过键盘输入，然后输出到终端、文件等地方，它的标准用语是 stdin 、 stdout 以及 stderr 。</p>
<ul>
<li>标准输入 stdin ，终端接收键盘输入的命令，会产生两种输出；</li>
<li>标准输出 stdout ，终端输出的信息（不包含错误信息）；</li>
<li>标准错误输出 stderr ，终端输出的错误信息。</li>
</ul>
<h3 id="3-1-重定向"><a href="#3-1-重定向" class="headerlink" title="3.1 重定向"></a>3.1 重定向</h3><p>把本来要显示在终端的命令结果，输送到别的地方（到文件中或者作为其他命令的输入）。</p>
<h3 id="3-2-输出重定向-gt"><a href="#3-2-输出重定向-gt" class="headerlink" title="3.2 输出重定向 &gt;"></a>3.2 <strong>输出重定向 &gt;</strong></h3><blockquote>
<p>表示重定向到新的文件， cut -d , -f 1 notes.csv &gt; name.csv ，它表示通过逗号剪切notes.csv 文件（剪切完有3个部分）获取第一个部分，重定向到 name.csv 文件。</p>
</blockquote>
<p>我们来看一个具体示例，学习它的使用，假设我们有一个文件 notes.csv ，文件内容如下：</p>
<p>Mark1,951/100,很不错1Mark2,952/100,很不错2Mark3,</p>
<p>953/100,很不错3Mark4,954/100,很不错4Mark5,955/100,很不错5Mark6,956/100,很不错6</p>
<p>执行命令：cut -d , -f 1 notes.csv &gt; name.csv 最后输出如下内容：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mark1Mark2Mark3Mark4Mark5Mark6</span><br></pre></td></tr></table></figure>
<p>【注意】使用 &gt; 要注意，如果输出的文件不存在它会新建一个，如果输出的文件已经存在，则会覆盖。因此执行这个操作要非常小心，以免覆盖其它重要文件。</p>
<h3 id="3-3-输出重定向-gt-gt"><a href="#3-3-输出重定向-gt-gt" class="headerlink" title="3.3 输出重定向 &gt;&gt;"></a>3.3 <strong>输出重定向 &gt;&gt;</strong></h3><p>表示重定向到文件末尾，因此它不会像 &gt; 命令这么危险，它是追加到文件的末尾（当然如果文件不存在，也会被创建）。</p>
<p>再次执行 cut -d , -f 1 notes.csv &gt;&gt; name.csv ，则会把名字追加到 name.csv 里面。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mark1Mark2Mark3Mark4Mark5Mark6Mark1Mark2Mark3Mark4Mark5Mark6</span><br></pre></td></tr></table></figure>
<p>我们平时读的 log 日志文件其实都是用这个命令输出的。</p>
<h3 id="3-4-输出重定向-2-gt"><a href="#3-4-输出重定向-2-gt" class="headerlink" title="3.4 输出重定向 2&gt;"></a>3.4 <strong>输出重定向 2&gt;</strong></h3><p>标准错误输出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat not_exist_file.csv &gt; res.txt 2&gt; errors.log</span><br></pre></td></tr></table></figure>
<ul>
<li>当我们 cat 一个文件时，会把文件内容打印到屏幕上，这个是标准输出；</li>
<li>当使用了 &gt; res.txt 时，则不会打印到屏幕，会把标准输出写入文件 res.txt 文件中；</li>
<li>2&gt; errors.log 当发生错误时会写入 errors.log 文件中。  </li>
</ul>
<h3 id="3-5-输出重定向-2-gt-gt"><a href="#3-5-输出重定向-2-gt-gt" class="headerlink" title="3.5 输出重定向 2&gt;&gt;"></a>3.5 <strong>输出重定向 2&gt;&gt;</strong></h3><p>标准错误输出（追加到文件末尾）同 &gt;&gt; 相似。</p>
<h3 id="3-6-输入重定向-lt"><a href="#3-6-输入重定向-lt" class="headerlink" title="3.6 输入重定向 &lt;"></a>3.6 <strong>输入重定向 &lt;</strong></h3><p>&lt; 符号用于指定命令的输入。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &lt; name.csv # 指定命令的输入为 name.csv</span><br></pre></td></tr></table></figure>
<p>虽然它的运行结果与 cat name.csv 一样，但是它们的原理却完全不同。</p>
<ul>
<li>cat name.csv 表示 cat 命令接收的输入是 notes.csv 文件名，那么要先打开这个文件，然后打印出文件内容。</li>
<li>cat &lt; name.csv 表示 cat 命令接收的输入直接是 notes.csv 这个文件的内容， cat命令只负责将其内容打印，打开文件并将文件内容传递给 cat 命令的工作则交给终端完成。  </li>
</ul>
<h3 id="3-7-输入重定向-lt-lt"><a href="#3-7-输入重定向-lt-lt" class="headerlink" title="3.7 输入重定向 &lt;&lt;"></a>3.7 <strong>输入重定向 &lt;&lt;</strong></h3><p>将键盘的输入重定向为某个命令的输入。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort -n &lt;&lt; END # 输入这个命令之后，按下回车，终端就进入键盘输入模式，其中END为结束命令（这个可以自定义）wc -m &lt;&lt; END # 统计输入的单词复</span><br></pre></td></tr></table></figure>
<h3 id="3-8-管道"><a href="#3-8-管道" class="headerlink" title="3.8 管道 |"></a>3.8 管道 |</h3><p>把两个命令连起来使用，一个命令的输出作为另外一个命令的输入，英文是 pipeline ，可以想象一个个水管连接起来，管道算是重定向流的一种。</p>
<p>举几个实际用法案例：</p>
<p>cut -d , -f 1 name.csv | sort &gt; sorted_name.txt</p>
<h1 id="第一步获取到的-name-列表，通过管道符再进行排序，最后输出到sorted-name-txt"><a href="#第一步获取到的-name-列表，通过管道符再进行排序，最后输出到sorted-name-txt" class="headerlink" title="第一步获取到的 name 列表，通过管道符再进行排序，最后输出到sorted_name.txt"></a>第一步获取到的 name 列表，通过管道符再进行排序，最后输出到sorted_name.txt</h1><p>du | sort -nr | head</p>
<h1 id="du-表示列举目录大小信息-sort-进行排序-n-表示按数字排序，-r-表示倒序-head-前10行文件"><a href="#du-表示列举目录大小信息-sort-进行排序-n-表示按数字排序，-r-表示倒序-head-前10行文件" class="headerlink" title="du 表示列举目录大小信息# sort 进行排序,-n 表示按数字排序，-r 表示倒序# head 前10行文件"></a>du 表示列举目录大小信息# sort 进行排序,-n 表示按数字排序，-r 表示倒序# head 前10行文件</h1><p>grep log -Ir /var/log | cut -d : -f 1 | sort | uniq</p>
<h1 id="grep-log-Ir-var-log-表示在log文件夹下搜索-var-log-文本，-r-表示递归，-I-用于排除二进制文件-cut-d-f-1-表示通过冒号进行剪切，获取剪切的第一部分-sort-进行排序-uniq-进行去重复制代码"><a href="#grep-log-Ir-var-log-表示在log文件夹下搜索-var-log-文本，-r-表示递归，-I-用于排除二进制文件-cut-d-f-1-表示通过冒号进行剪切，获取剪切的第一部分-sort-进行排序-uniq-进行去重复制代码" class="headerlink" title="grep log -Ir /var/log 表示在log文件夹下搜索 /var/log 文本，-r 表示递归，-I 用于排除二进制文件# cut -d : -f 1 表示通过冒号进行剪切，获取剪切的第一部分# sort 进行排序# uniq 进行去重复制代码"></a>grep log -Ir /var/log 表示在log文件夹下搜索 /var/log 文本，-r 表示递归，-I 用于排除二进制文件# cut -d : -f 1 表示通过冒号进行剪切，获取剪切的第一部分# sort 进行排序# uniq 进行去重复制代码</h1><h2 id="1-六、查看进程"><a href="#1-六、查看进程" class="headerlink" title="1 六、查看进程"></a>1 六、查看进程</h2><p>在 Windows 中通过 Ctrl + Alt + Delete 快捷键查看软件进程。</p>
<h3 id="1-1-w"><a href="#1-1-w" class="headerlink" title="1.1 w"></a>1.1 <strong>w</strong></h3><p><strong>帮助我们快速了解系统中目前有哪些用户登录着，以及他们在干什么。</strong></p>
<h3 id="1-2-ps"><a href="#1-2-ps" class="headerlink" title="1.2 ps"></a>1.2 <strong>ps</strong></h3><p><strong>用于显示当前系统中的进程， ps 命令显示的进程列表不会随时间而更新，是静态的，是运行 ps 命令那个时刻的状态或者说是一个进程快照。</strong></p>
<h3 id="1-3-常用参数"><a href="#1-3-常用参数" class="headerlink" title="1.3 常用参数"></a>1.3 常用参数</h3><ul>
<li>-ef 列出所有进程;</li>
<li>-efH 以乔木状列举出所有进程;</li>
<li>-u 列出此用户运行的进程;</li>
<li>-aux 通过 CPU 和内存使用来过滤进程 ps -aux | less ;</li>
<li>-aux —sort -pcpu 按 CPU 使用降序排列， -aux —sort -pmem 表示按内存使用降序排列;</li>
<li>-axjf 以树形结构显示进程， ps -axjf 它和 pstree 效果类似。  </li>
</ul>
<h3 id="1-4-top"><a href="#1-4-top" class="headerlink" title="1.4 top"></a>1.4 top</h3><p><strong>获取进程的动态列表。</strong></p>
<h3 id="1-5-kill"><a href="#1-5-kill" class="headerlink" title="1.5 kill"></a>1.5 <strong>kill</strong></h3><p><strong>结束一个进程， kill + PID 。</strong></p>
<h2 id="2-七、管理进程"><a href="#2-七、管理进程" class="headerlink" title="2 七、管理进程"></a>2 七、管理进程</h2><h3 id="2-1-进程状态"><a href="#2-1-进程状态" class="headerlink" title="2.1 进程状态"></a>2.1 进程状态</h3><p>主要是切换进程的状态。我们先了解下 Linux 下进程的五种状态：</p>
<ol>
<li>状态码 R ：表示正在运行的状态；</li>
<li>状态码 S ：表示中断（休眠中，受阻，当某个条件形成后或接受到信号时，则脱离该状态）；</li>
<li>状态码 D ：表示不可中断（进程不响应系统异步信号，即使用kill命令也不能使其中断）；</li>
<li>状态码 Z ：表示僵死（进程已终止，但进程描述符依然存在，直到父进程调用 wait4()<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">系统函数</a>后将进程释放）；</li>
<li>状态码 T ：表示停止（进程收到 SIGSTOP 、 SIGSTP 、 SIGTIN 、 SIGTOU 等停止信号后停止运行）。  </li>
</ol>
<h3 id="2-2-前台进程-amp-后台进程"><a href="#2-2-前台进程-amp-后台进程" class="headerlink" title="2.2 前台进程 &amp; 后台进程"></a>2.2 前台进程 &amp; 后台进程</h3><p>默认情况下，用户创建的进程都是前台进程，前台进程从键盘读取数据，并把处理结果输出到显示器。例如运行 top 命令，这就是一个一直运行的前台进程。</p>
<p>后台进程的优点是不必等待程序运行结束，就可以输入其它命令。在需要执行的命令后面添加&amp; 符号，就表示启动一个后台进程。</p>
<h3 id="2-3-amp"><a href="#2-3-amp" class="headerlink" title="2.3 &amp;"></a>2.3 &amp;</h3><p>启动后台进程，它的缺点是后台进程与终端相关联，一旦关闭终端，进程就自动结束了。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp name.csv name-copy.csv &amp;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-nohup"><a href="#2-4-nohup" class="headerlink" title="2.4 nohup"></a>2.4 nohup</h3><p>使进程不受挂断（关闭终端等动作）的影响。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup cp name.csv name-copy.csv</span><br></pre></td></tr></table></figure>
<p>nohup 命令也可以和 &amp; 结合使用。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup cp name.csv name-copy.csv &amp;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-bg"><a href="#2-5-bg" class="headerlink" title="2.5 bg"></a>2.5 bg</h3><p>使一个”后台暂停运行”的进程，状态改为”后台运行”。</p>
<h3 id="2-6-jobs"><a href="#2-6-jobs" class="headerlink" title="2.6 jobs"></a>2.6 jobs</h3><p>显示当前终端后台进程状态。</p>
<h3 id="2-7-fg"><a href="#2-7-fg" class="headerlink" title="2.7 fg"></a>2.7 fg</h3><p>fg 使进程转为前台运行，用法和 bg 命令类似。</p>
<p>我们用一张图来表示前后台进程切换：</p>
<p><img src="https://pic1.zhimg.com/80/v2-fda7a2872cecb93215a9b88f9ae71a29_1440w.webp?source=1940ef5c" alt=""></p>
<p>我们可以使程序在后台运行，成为后台进程，这样在当前终端中我们就可以做其他事情了，而不必等待此进程运行结束。</p>
<h2 id="3-八、文件压缩解压"><a href="#3-八、文件压缩解压" class="headerlink" title="3 八、文件压缩解压"></a>3 八、文件压缩解压</h2><ul>
<li>打包：是将多个文件变成一个总的文件，它的学名叫存档、归档。</li>
<li>压缩：是将一个大文件（通常指归档）压缩变成一个小文件。  </li>
</ul>
<p>我们常常使用 tar 将多个文件归档为一个总的文件，称为 archive 。然后用 gzip 或 bzip2 命令将 archive 压缩为更小的文件。</p>
<h3 id="3-1-tar"><a href="#3-1-tar" class="headerlink" title="3.1 tar"></a>3.1 <strong>tar</strong></h3><p><strong>创建一个 tar 归档。</strong></p>
<h3 id="3-2-基础用法"><a href="#3-2-基础用法" class="headerlink" title="3.2 基础用法"></a>3.2 基础用法</h3><p>tar -cvf sort.tar sort/</p>
<h1 id="将sort文件夹归档为sort-tar"><a href="#将sort文件夹归档为sort-tar" class="headerlink" title="将sort文件夹归档为sort.tar"></a>将sort文件夹归档为sort.tar</h1><p>tar -cvf archive.tar file1 file2 file3</p>
<h1 id="将-file1-file2-file3-归档为archive-tar复制代码"><a href="#将-file1-file2-file3-归档为archive-tar复制代码" class="headerlink" title="将 file1 file2 file3 归档为archive.tar复制代码"></a>将 file1 file2 file3 归档为archive.tar复制代码</h1><h3 id="0-1-常用参数"><a href="#0-1-常用参数" class="headerlink" title="0.1 常用参数"></a>0.1 常用参数</h3><ul>
<li>-cvf 表示 create（创建）+ verbose（细节）+ file（文件），创建归档文件并显示操作细节；</li>
<li>-tf 显示归档里的内容，并不解开归档；</li>
<li>-rvf 追加文件到归档， tar -rvf archive.tar file.txt ；</li>
<li>-xvf 解开归档， tar -xvf archive.tar 。</li>
</ul>
<h3 id="0-2-gzip-gunzip"><a href="#0-2-gzip-gunzip" class="headerlink" title="0.2 gzip / gunzip"></a>0.2 gzip / gunzip</h3><p>“压缩/解压”归档，默认用 gzip 命令，压缩后的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">文件后缀名</a>为 .tar.gz 。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip archive.tar # 压缩gunzip archive.tar.gz # 解压</span><br></pre></td></tr></table></figure>
<h3 id="0-3-tar-归档-压缩"><a href="#0-3-tar-归档-压缩" class="headerlink" title="0.3 tar 归档+压缩"></a>0.3 tar 归档+压缩</h3><p>可以用 tar 命令同时完成归档和压缩的操作，就是给 tar 命令多加一个选项参数，使之完成归档操作后，还是调用 gzip 或 bzip2 命令来完成压缩操作。</p>
<p>tar -zcvf archive.tar.gz archive/ # 将archive文件夹归档并压缩</p>
<p>tar -zxvf archive.tar.gz # 将archive.tar.gz归档压缩文件解压</p>
<h3 id="0-4-zcat、zless、zmore"><a href="#0-4-zcat、zless、zmore" class="headerlink" title="0.4 zcat、zless、zmore"></a>0.4 zcat、zless、zmore</h3><p>之前讲过使用 cat less more 可以查看文件内容，但是压缩文件的内容是不能使用这些命令进行查看的，而要使用 zcat、zless、zmore 进行查看。</p>
<p>zcat archive.tar.gz</p>
<h3 id="0-5-zip-unzip"><a href="#0-5-zip-unzip" class="headerlink" title="0.5 zip/unzip"></a>0.5 zip/unzip</h3><p>“压缩/解压” zip 文件（ zip 压缩文件一般来自 windows 操作系统）。</p>
<h3 id="0-6-命令安装"><a href="#0-6-命令安装" class="headerlink" title="0.6 命令安装"></a>0.6 命令安装</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Red Hat 一族中的安装方式yum install zip yum install unzip 复制代码</span><br></pre></td></tr></table></figure>
<h3 id="0-7-基础用法"><a href="#0-7-基础用法" class="headerlink" title="0.7 基础用法"></a>0.7 基础用法</h3><p>unzip archive.zip</p>
<h1 id="解压-zip-文件"><a href="#解压-zip-文件" class="headerlink" title="解压 .zip 文件"></a>解压 .zip 文件</h1><p>unzip -l archive.zip</p>
<h1 id="不解开-zip-文件，只看其中内容"><a href="#不解开-zip-文件，只看其中内容" class="headerlink" title="不解开 .zip 文件，只看其中内容"></a>不解开 .zip 文件，只看其中内容</h1><p>zip -r sort.zip sort/</p>
<h1 id="将sort文件夹压缩为-sort-zip，其中-r表示递归"><a href="#将sort文件夹压缩为-sort-zip，其中-r表示递归" class="headerlink" title="将sort文件夹压缩为 sort.zip，其中-r表示递归"></a>将sort文件夹压缩为 sort.zip，其中-r表示递归</h1><h3 id="0-1-编译安装"><a href="#0-1-编译安装" class="headerlink" title="0.1 编译安装"></a>0.1 编译安装</h3><p>简单来说，编译就是将程序的源代码转换成可执行文件的过程。大多数 Linux 的程序都是开放源码的，可以编译成适合我们的电脑和操纵系统属性的可执行文件。</p>
<p>基本步骤如下：</p>
<ol>
<li>下载源代码</li>
<li>解压压缩包</li>
<li>配置</li>
<li>编译</li>
<li>安装  </li>
</ol>
<h3 id="0-2-实际案例"><a href="#0-2-实际案例" class="headerlink" title="0.2 实际案例"></a>0.2 实际案例</h3><h3 id="0-3-1、下载"><a href="#0-3-1、下载" class="headerlink" title="0.3 1、下载"></a>0.3 1、下载</h3><p>我们来编译安装 htop 软件，首先在它的官网下载源码：<strong><a href="https://link.zhihu.com/?target=http%3A//bintray.com/htop/source">http://bintray.com/htop/source</a>…</strong>[1]</p>
<p>下载好的源码在本机电脑上使用如下命令同步到服务器上：</p>
<p>scp 文件名 用户名@服务器ip:目标路径</p>
<p>scp ~/Desktop/htop-3.0.0.tar.gz root@121.42.11.34:.</p>
<p>也可以使用 wegt 进行下载：</p>
<p>wegt+下载地址</p>
<p>wegt <a href="https://link.zhihu.com/?target=https%3A//bintray.com/htop/source/download_file%3Ffile_path%3Dhtop-3.0.0.tar.gz">https://bintray.com/htop/source/download_file?file_path=htop-3.0.0.tar.gz</a></p>
<h3 id="0-4-2、解压文件"><a href="#0-4-2、解压文件" class="headerlink" title="0.4 2、解压文件"></a>0.4 2、解压文件</h3><p>tar -zxvf htop-3.0.0.tar.gz</p>
<h1 id="解压cd-htop-3-0-0-进入目录"><a href="#解压cd-htop-3-0-0-进入目录" class="headerlink" title="解压cd htop-3.0.0 # 进入目录"></a>解压cd htop-3.0.0 # 进入目录</h1><h3 id="0-1-3、配置"><a href="#0-1-3、配置" class="headerlink" title="0.1 3、配置"></a>0.1 3、配置</h3><p>执行 ./configure ，它会分析你的电脑去确认编译所需的工具是否都已经安装了。</p>
<h3 id="0-2-4、编译"><a href="#0-2-4、编译" class="headerlink" title="0.2 4、编译"></a>0.2 4、编译</h3><p>执行 make 命令</p>
<h3 id="0-3-5、安装"><a href="#0-3-5、安装" class="headerlink" title="0.3 5、安装"></a>0.3 5、安装</h3><p>执行 make install 命令，安装完成后执行 ls /usr/local/bin/ 查看是否有 htop 命令。如果有就可以执行 htop 命令查看系统进程了。</p>
<h2 id="1-九、网络"><a href="#1-九、网络" class="headerlink" title="1 九、网络"></a>1 九、网络</h2><h3 id="1-1-ifconfig"><a href="#1-1-ifconfig" class="headerlink" title="1.1 ifconfig"></a>1.1 <strong>ifconfig</strong></h3><p><strong>查看 ip 网络相关信息，如果命令不存在的话， 执行命令 yum install net-tools 安装。</strong></p>
<p>参数解析：</p>
<ul>
<li><p>eth0 对应有线连接（对应你的有线网卡），就是用网线来连接的上网。eth 是 Ethernet 的缩写，表示”<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BB%A5%E5%A4%AA%E7%BD%91&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">以太网</a>“。有些电脑可能同时有好几条网线连着，例如服务器，那么除了eht0 ，你还会看到 eth1 、 eth2 等。  </p>
</li>
<li><p>lo 表示本地回环（ Local Loopback 的缩写，对应一个<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">虚拟网卡</a>）可以看到它的 ip 地址是 127.0.0.1 。每台电脑都应该有这个接口，因为它对应着”连向自己的链接”。这也是被称之为”本地回环”的原因。所有经由这个接口发送的东西都会回到你自己的电脑。看起来好像并没有什么用，但有时为了某些缘故，我们需要连接自己。例如用来测试一个网络程序，但又不想让局域网或外网的用户查看，只能在此台主机上运行和查看所有的网络接口。例如在我们启动一个前端工程时，在浏览器输入 127.0.0.1:3000 启动项目就能查看到自己的 web 网站，并且它只有你能看到。  </p>
</li>
<li><p>wlan0 表示无线局域网</p>
</li>
</ul>
<h3 id="1-2-host"><a href="#1-2-host" class="headerlink" title="1.2 host"></a>1.2 <strong>host</strong></h3><p><strong>ip 地址和主机名的互相转换。</strong></p>
<h3 id="1-3-ssh-连接远程服务器"><a href="#1-3-ssh-连接远程服务器" class="headerlink" title="1.3 ssh 连接远程服务器"></a>1.3 <strong>ssh 连接远程服务器</strong></h3><p><strong>通过<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">非对称加密</a>以及对称加密的方式（同 HTTPS 安全连接原理相似）连接到远端服务器。</strong></p>
<h3 id="1-4-h"><a href="#1-4-h" class="headerlink" title="1.4 *h"></a>1.4 <em>*</em>h</h3><p>config 文件可以<em>*</em>h ，方便批量管理多个 ssh 连接。</p>
<p>配置文件分为以下几种：</p>
<ul>
<li>全局 ssh 服务端的配置：/etc/ssh/sshd_config ；</li>
<li>全局 ssh 客户端的配置：/etc/ssh/ssh_config（很少修改）；</li>
<li>当前用户 ssh 客户端的<em>*</em>h/config 。</li>
</ul>
<p><img src="https://pica.zhimg.com/80/v2-6822a5b5868d9e08fb6d9fbae94b6661_1440w.webp?source=1940ef5c" alt=""></p>
<p>配置当前用户的 config ：</p>
<h1 id="创建config"><a href="#创建config" class="headerlink" title="创建config"></a>创建config</h1><p>vim ~/.ssh/config</p>
<h1 id="填写一下内容"><a href="#填写一下内容" class="headerlink" title="填写一下内容"></a>填写一下内容</h1><p>Host lion # 别名 HostName 172.x.x.x # ip 地址 Port 22 # 端口 User root # 用户</p>
<p>这样配置完成后，下次登录时，可以这样登录 ssh lion 会自动识别为 root 用户。</p>
<p>[注意] 这段配置不是在服务器上，而是你自己的机器上，它仅仅是设置了一个别名。</p>
<h3 id="0-1-wget"><a href="#0-1-wget" class="headerlink" title="0.1 wget"></a>0.1 wget</h3><p>可以使我们直接从终端控制台下载文件，只需要给出文件的HTTP或FTP地址。</p>
<h2 id="1-十-备份"><a href="#1-十-备份" class="headerlink" title="1 十 备份"></a>1 十 备份</h2><h3 id="1-1-scp"><a href="#1-1-scp" class="headerlink" title="1.1 scp"></a>1.1 scp</h3><p><strong>它是 Secure Copy 的缩写，表示安全拷贝。scp 可以使我们通过网络，把文件从一台电脑拷贝到另一台电脑。</strong></p>
<p>scp 是基于 ssh 的原理来运作的， ssh 会在两台通过网络连接的电脑之间创建一条安全通信的管道， scp 就利用这条管道安全地拷贝文件。</p>
<p>scp source_file destination_file</p>
<h1 id="source-file-表示源文件，destination-file-表示目标文件"><a href="#source-file-表示源文件，destination-file-表示目标文件" class="headerlink" title="source_file 表示源文件，destination_file 表示目标文件"></a>source_file 表示源文件，destination_file 表示目标文件</h1><p>其中 source_file 和 destination_file 都可以这样表示：user@ip:file_name ， user 是登录名， ip 是域名或 ip 地址。file_name 是文件路径。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp root@192.168.1.5:/root/file.txt file.txt # 表示把远程电脑上的 file.txt 文件拷贝到本机</span><br><span class="line">scp file.txt root@192.168.1.5:/root # 表示把我的电脑中当前文件夹下的 file.txt 文件拷贝到远程电脑</span><br></pre></td></tr></table></figure>
<h3 id="0-1-rsync"><a href="#0-1-rsync" class="headerlink" title="0.1 rsync"></a>0.1 rsync</h3><p>rsync 命令主要用于远程同步文件。它可以同步两个目录，不管它们是否处于同一台电脑。它应该是最常用于”<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">增量备份</a>“的命令了。它就是智能版的 scp 命令。</p>
<h3 id="0-2-软件安装"><a href="#0-2-软件安装" class="headerlink" title="0.2 软件安装"></a>0.2 软件安装</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install rsync复制代码</span><br></pre></td></tr></table></figure>
<h3 id="0-3-基础用法"><a href="#0-3-基础用法" class="headerlink" title="0.3 基础用法"></a>0.3 基础用法</h3><p>rsync -arv Images/ backups/</p>
<h1 id="将Images-目录下的所有文件备份到-backups-目录下"><a href="#将Images-目录下的所有文件备份到-backups-目录下" class="headerlink" title="将Images 目录下的所有文件备份到 backups 目录下"></a>将Images 目录下的所有文件备份到 backups 目录下</h1><p>rsync -arv Images/ root@192.x.x.x:backups/</p>
<h1 id="同步到服务器的backups目录下"><a href="#同步到服务器的backups目录下" class="headerlink" title="同步到服务器的backups目录下"></a>同步到服务器的backups目录下</h1><h3 id="0-1-常用参数-1"><a href="#0-1-常用参数-1" class="headerlink" title="0.1 常用参数"></a>0.1 常用参数</h3><ul>
<li>-a 保留文件的所有信息，包括权限，修改日期等；</li>
<li>-r 递归调用，表示子目录的所有文件也都包括；</li>
<li>-v 冗余模式，输出详细操作信息。</li>
</ul>
<p>默认地， rsync 在同步时并不会删除目标目录的文件，例如你在源目录中删除一个文件，但是用 rsync 同步时，它并不会删除同步目录中的相同文件。如果向删除也可以这么做：rsync -arv —delete Images/ backups/ 。</p>
<h2 id="1-十一-系统"><a href="#1-十一-系统" class="headerlink" title="1 十一 系统"></a>1 十一 系统</h2><h3 id="1-1-halt"><a href="#1-1-halt" class="headerlink" title="1.1 halt"></a>1.1 halt</h3><p>关闭系统，需要 root 身份。</p>
<h3 id="1-2-reboot"><a href="#1-2-reboot" class="headerlink" title="1.2 reboot"></a>1.2 reboot</h3><p>重启系统，需要 root 身份。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>
<h3 id="1-3-poweroff"><a href="#1-3-poweroff" class="headerlink" title="1.3 poweroff"></a>1.3 poweroff</h3><p>直接运行即可关机，不需要 root 身份。</p>
<h2 id="2-十二-Vim-编辑器"><a href="#2-十二-Vim-编辑器" class="headerlink" title="2 十二 Vim 编辑器"></a>2 十二 Vim 编辑器</h2><h2 id="3-Vim-是什么？"><a href="#3-Vim-是什么？" class="headerlink" title="3 Vim 是什么？"></a>3 Vim 是什么？</h2><p>Vim 是从 vi 发展出来的一个<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">文本编辑器</a>。其代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和 Emacs 并列成为类 Unix 系统用户最喜欢的编辑器。</p>
<h2 id="4-Vim-常用模式"><a href="#4-Vim-常用模式" class="headerlink" title="4 Vim 常用模式"></a>4 Vim 常用模式</h2><ul>
<li>交互模式</li>
<li>插入模式</li>
<li>命令模式</li>
<li>可视模式  </li>
</ul>
<h3 id="4-1-交互模式"><a href="#4-1-交互模式" class="headerlink" title="4.1 交互模式"></a>4.1 交互模式</h3><p>也成为正常模式，这是 Vim 的默认模式，每次运行 Vim 程序的时候，就会进入这个模式。</p>
<p>例如执行 vim name.txt 则会进入交互模式。</p>
<p>交互模式特征：</p>
<ul>
<li>在这个模式下，你不能输入文本；</li>
<li>它可以让我们在文本间移动，删除一行文本，复制黏贴文本，跳转到指定行，撤销操作，等等  </li>
</ul>
<h3 id="4-2-插入模式"><a href="#4-2-插入模式" class="headerlink" title="4.2 插入模式"></a>4.2 插入模式</h3><p>这个模式是我们熟悉的文本编辑器的模式，就是可以输入任何你想输入的内容。进入这个模式有几种方法，最常用的方法是按字母键 i （ i、I、a、A、o、O 都可以进入插入模式，只是所处的位置不同），退出这种模式，只需要按下 Esc 键。</p>
<ul>
<li>i, I 进入输入模式 Insert mode ：i 为”从目前光标所在处输入”， I 为”在目前所在行的第一个非空格符处开始输入”；</li>
<li>a, A 进入输入模式 Insert mode ：a 为”从目前光标所在的下一个字符处开始输入”，A 为”从光标所在行的最后一个字符处开始输入”；</li>
<li>o, O 进入输入模式 Insert mode ：o 为”在目前光标所在的下一行处输入新的一行”；O 为在目前光标所在处的上一行输入新的一行。</li>
</ul>
<h3 id="4-3"><a href="#4-3" class="headerlink" title="4.3"></a>4.3</h3><h3 id="4-4-命令模式"><a href="#4-4-命令模式" class="headerlink" title="4.4 命令模式"></a>4.4 命令模式</h3><p>命令模式也称为底线命令模式，这个模式下可以运行一些命令例如”退出”，”保存”，等动作。</p>
<p>也可以用这个模式来激活一些 Vim 配置，例如语法高亮，显示行号，等。甚至还可以发送一些命令给终端命令行，例如 ls、cp 。</p>
<p>为了进入命令模式，首先要进入交互模式，再按下冒号键。</p>
<p>用一张图表示三种模式如何切换：</p>
<p><img src="https://picx.zhimg.com/80/v2-ba2da86f7f9e710f75d2b52449458f07_1440w.webp?source=1940ef5c" alt=""></p>
<p>基本操作</p>
<h3 id="4-5-打开-Vim"><a href="#4-5-打开-Vim" class="headerlink" title="4.5 打开 Vim"></a>4.5 打开 Vim</h3><p>在终端命令行中输入 vim 回车后 Vim 就会被运行起来，也可以用 Vim 来打开一个文件，只需要在 vim 后面再加文件名。如 vim file.name ，如果文件不存在，那么会被创建。  </p>
<h3 id="4-6-插入"><a href="#4-6-插入" class="headerlink" title="4.6 插入"></a>4.6 插入</h3><p>进入文件之后，此时处于交互模式，可以通过输入 i 进入插入模式  </p>
<h3 id="4-7-移动"><a href="#4-7-移动" class="headerlink" title="4.7 移动"></a>4.7 移动</h3><p>在 Vim 的交互模式下，我们可以在文本中移动光标。</p>
<ul>
<li>h 向左移动一个字符</li>
<li>j 向下移动一个字符</li>
<li>k 向上移动一个字符</li>
<li>i 向右移动一个字符</li>
</ul>
<p>当然也可以使用四个方向键进行移动，效果是一样的。  </p>
<h3 id="4-8-跳至行首和行末"><a href="#4-8-跳至行首和行末" class="headerlink" title="4.8 跳至行首和行末"></a>4.8 跳至行首和行末</h3><ul>
<li>行首：在交互模式下，为了将光标定位到一行的开始位置，只需要按下数字键 0 即可，键盘上的 Home 键也有相同效果。</li>
<li>行末：在交互模式下，为了将光标定位到一行的末尾，只需要按下美元符号键 $ 即可，键盘上的 End 键也有相同效果。</li>
</ul>
<h3 id="4-9-按单词移动"><a href="#4-9-按单词移动" class="headerlink" title="4.9 按单词移动"></a>4.9 按单词移动</h3><p>在交互模式下，按字母键 w 可以一个单词一个单词的移动。</p>
<h3 id="4-10-退出文件"><a href="#4-10-退出文件" class="headerlink" title="4.10 退出文件"></a>4.10 退出文件</h3><p>在交互模式下，按下冒号键 : 进入命令模式，再按下 q 键，就可以退出了。</p>
<p>如果在退出之前又修改了文件，就直接想用 :q 退出 Vim ，那么 Vim 会显示一个红字标明错误信息。此时我们有两个选择：</p>
<ol>
<li>保存并退出 :wq 或 :x ；</li>
<li>不保存且退出 :q! 。</li>
</ol>
<h2 id="5-标准操作"><a href="#5-标准操作" class="headerlink" title="5 标准操作"></a>5 标准操作</h2><h3 id="5-1-删除字符"><a href="#5-1-删除字符" class="headerlink" title="5.1 删除字符"></a>5.1 删除字符</h3><p>在交互模式下，将光标定位到一个你想要删除的字符上，按下字母键 x 你会发现这个字符被删除了。</p>
<p>也可以一次性删除多个字符，只需要在按 x 键之前输入数字即可。  </p>
<h3 id="5-2-删除（剪切）单词，行"><a href="#5-2-删除（剪切）单词，行" class="headerlink" title="5.2 删除（剪切）单词，行"></a>5.2 删除（剪切）单词，行</h3><ul>
<li>删除一行：连按两次 d 来删除光标所在的那一行。</li>
<li>删除多行：例如先输入数字 2 ，再按下 dd ，就会删除从光标所在行开始的两行。</li>
<li>删除一个单词：将光标置于一个单词的首字母处，然后按下 dw 。</li>
<li>删除多个单词：例如先按数字键 2 再按 dw 就可以删除两个单词了。</li>
<li>从光标所在位置删除至行首：d0 。</li>
<li>从光标所在位置删除至行末：d$ 。</li>
</ul>
<h3 id="5-3-复制单词，行"><a href="#5-3-复制单词，行" class="headerlink" title="5.3 复制单词，行"></a>5.3 复制单词，行</h3><ul>
<li>复制行：按两次 y 会把光标所在行复制到内存中，和 dd 类似， dd 用于”剪切”光标所在行。</li>
<li>复制单词：yw 会复制一个单词。</li>
<li>复制到行末：y$ 是复制从光标所在处到行末的所有字符。</li>
<li>复制到行首：y0 是复制光标所在处到行首的所有字符。  </li>
</ul>
<h3 id="5-4-粘贴"><a href="#5-4-粘贴" class="headerlink" title="5.4 粘贴"></a>5.4 粘贴</h3><p>如果之前用 dd 或者 yy 剪切复制过来的，可以使用 p 来粘贴。同样也可以使用 数字+p来表示复制多次。  </p>
<h3 id="5-5-替换一个字符"><a href="#5-5-替换一个字符" class="headerlink" title="5.5 替换一个字符"></a>5.5 替换一个字符</h3><p>在交互模式下，将光标置于想要替换的字符上。按下 r 键，接着输入你要替换的字符即可。  </p>
<h3 id="5-6-撤销操作"><a href="#5-6-撤销操作" class="headerlink" title="5.6 撤销操作"></a>5.6 撤销操作</h3><p>如果要撤销最近的修改，只需要按下 u 键，如果想要撤销最近四次修改，可以按下4，再按下 u 。  </p>
<h3 id="5-7-重做"><a href="#5-7-重做" class="headerlink" title="5.7 重做"></a>5.7 重做</h3><p>取消撤销，也就是重做之前的修改使用 ctrl + r 。  </p>
<h3 id="5-8-跳转到指定行"><a href="#5-8-跳转到指定行" class="headerlink" title="5.8 跳转到指定行"></a>5.8 跳转到指定行</h3><p>Vim 编辑的文件中，每一行都有一个行号，行号从1开始，逐一递增。</p>
<p>行号默认是不显示，如果需要它显示的话，可以进入命令模式，然后输入 set nu ，如果要隐藏行号的话，使用 set nonu 。</p>
<ul>
<li>跳转到指定行：数字+gg ，例如 7gg ，表示跳转到第7行。</li>
<li>要跳转到最后一行，按下 G 。</li>
<li>要跳转到第一行，按下 gg 。</li>
</ul>
<h2 id="6-高级操作"><a href="#6-高级操作" class="headerlink" title="6 高级操作"></a>6 高级操作</h2><h3 id="6-1-查找"><a href="#6-1-查找" class="headerlink" title="6.1 查找"></a>6.1 查找</h3><p>处于交互模式下，按下 / 键，那么就进入查找模式，输入你要查找的字符串，然后按下回车。光标就会跳转到文件中下一个查找到的匹配处。如果字符串不存在，那么会显示 “pattern not found” 。</p>
<ul>
<li>n 跳转到下一个匹配项；</li>
<li>N 跳转到上一个匹配项。</li>
</ul>
<p>[注意] 用斜杠来进行的查找是从当前光标处开始向文件尾搜索，如果你要从当前光标处开始，向文件头搜索则使用 ? ，当然也可以先按下 gg 跳转到第一行在进行全文搜索。  </p>
<h3 id="6-2-查找并替换"><a href="#6-2-查找并替换" class="headerlink" title="6.2 查找并替换"></a>6.2 查找并替换</h3><p>替换光标所在行第一个匹配的字符串：</p>
<h1 id="语法-s-旧字符串-新字符串-实例-s-one-two"><a href="#语法-s-旧字符串-新字符串-实例-s-one-two" class="headerlink" title="语法:s/旧字符串/新字符串# 实例:s/one/two"></a>语法:s/旧字符串/新字符串# 实例:s/one/two</h1><p>替换光标所在行所有旧字符串为新字符串：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 语法:s/旧字符串/新字符串/g</span><br></pre></td></tr></table></figure>
<p>替换第几行到第几行中所有字符串：</p>
<h1 id="语法-n-m-s-旧字符串-新字符串-g"><a href="#语法-n-m-s-旧字符串-新字符串-g" class="headerlink" title="语法:n,m s/旧字符串/新字符串/g"></a>语法:n,m s/旧字符串/新字符串/g</h1><h1 id="实例-2-4-s-one-two-g"><a href="#实例-2-4-s-one-two-g" class="headerlink" title="实例:2,4 s/one/two/g"></a>实例:2,4 s/one/two/g</h1><p>最常用的就是全文替换了：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 语法:%s/旧字符串/新字符串/g</span><br></pre></td></tr></table></figure>
<h3 id="0-1-合并文件"><a href="#0-1-合并文件" class="headerlink" title="0.1 合并文件"></a>0.1 合并文件</h3><p>可以用冒号 +r ( :r ) 实现在光标处插入一个文件的内容。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r filename # 可以用Tab键来自动补全另外一个文件的路径</span><br></pre></td></tr></table></figure>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/05/07/Basic/Linux/"></a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-05-07
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1 常用命令"></a>1 常用命令</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">查看进程  ps -ef| grep A</span><br><span class="line">复制文件  scp -r /home/a.txt root@B_ip:/home  <span class="comment">//将A服务器中/home/a.txt 复制到B服务器的/home中</span></span><br><span class="line">动态查看命令执行结果  watch</span><br><span class="line">网络相关  tcpdump</span><br><span class="line">列出当前系统打开的文件描述符  lsof</span><br><span class="line">网络信息统计    netstat</span><br><span class="line">系统的进程信息，内存使用等资源使用情况   vmstat</span><br><span class="line">cpu的使用情况   mpstat</span><br><span class="line"> </span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 2 升级 openssh</span></span><br><span class="line"><span class="string">一、升级背景：</span></span><br><span class="line"><span class="string">漏洞扫描显示linux服务器openssh有高危漏洞，需要进行修复。openssh是远程登录到linux服务器</span></span><br><span class="line"><span class="string">的重要工具，要修复此漏洞需升级到最高版本（2021年5月中旬最新版本为8.6p1）。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">二、升级说明：</span></span><br><span class="line"><span class="string">1、所有升级文件均从官网下载。</span></span><br><span class="line"><span class="string">2、linux服务器系统为Centos7可适用此方案。</span></span><br><span class="line"><span class="string">3、Centos7系统需要有yum源，方便解决依赖关系问题。如无法实现，则需上传同系统版本安装映</span></span><br><span class="line"><span class="string">像文件，作为本地yum源。</span></span><br><span class="line"><span class="string">4、安装过程受网络影响极大，一旦出现不可抗因素致网络断开，可能会导致升级中断，无法远程</span></span><br><span class="line"><span class="string">连接，出现此情况需现场人员配合解决。</span></span><br><span class="line"><span class="string">5、升级过程出现问题需现场人员根据回退方案进行恢复操作。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">三、升级过程：</span></span><br><span class="line"><span class="string">（0）安装并启用telnet</span></span><br><span class="line"><span class="string">1、安装telnet</span></span><br><span class="line"><span class="string">`</span>yum install telnet-server telnet xinet</span><br><span class="line"><span class="number">2</span>、修改配置文件</span><br><span class="line"><span class="string">`vi /etc/xinetd.d/telnet</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span>disable= no       <span class="comment">//将yes改为no</span></span><br><span class="line"><span class="string">``</span>#让root可以登录</span><br><span class="line"><span class="string">``</span>#mv /etc/securetty /etc/securetty.bak</span><br><span class="line">重启服务</span><br><span class="line"><span class="string">`service xinetd restart</span></span><br><span class="line"><span class="string">3、启动相应服务，然后使用telnet登录到服务器</span></span><br><span class="line"><span class="string">`</span>systemctl start telnet.socket</span><br><span class="line"><span class="string">`systemctl start xinetd</span></span><br><span class="line"><span class="string">`</span>chkconfig --list</span><br><span class="line">（一）配置yum源</span><br><span class="line"><span class="number">1</span>、上传与生产环境相同的centos7版本的iso和openssh8<span class="number">.6</span>p1的安装包到服务器。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、挂载iso</span><br><span class="line">创建iso存放目录和挂载目录，并上传iso镜像文件到iso存放目录/mnt/iso下</span><br><span class="line"><span class="string">`mkdir /mnt/iso </span></span><br><span class="line"><span class="string">`</span>mkdir /mnt/cdrom</span><br><span class="line"><span class="string">`mv CentOS-7.6-x86_64-DVD-1810.iso /mnt/iso/</span></span><br><span class="line"><span class="string">挂载iso镜像到挂载目录/mnt/cdrom下</span></span><br><span class="line"><span class="string">`</span>mount -o loop /mnt/iso/CentOS<span class="number">-7.6</span>-x86_64-DVD<span class="number">-1810.i</span>so /mnt/cdrom</span><br><span class="line">使用df -h命令查询挂载是否成功</span><br><span class="line"><span class="string">`df -h</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3、备份原本地源</span></span><br><span class="line"><span class="string">进入repos配置目录</span></span><br><span class="line"><span class="string">`</span>cd /etc/yum.repos.d/</span><br><span class="line">创建备份文件夹</span><br><span class="line"><span class="string">`mkdir repobak</span></span><br><span class="line"><span class="string">移动配置文件到repobak文件夹中</span></span><br><span class="line"><span class="string">`</span>mv *.repo repobak/</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、新建光盘源配置文件</span><br><span class="line"><span class="string">`vi CentOS-Media.repo</span></span><br><span class="line"><span class="string">输入下列内容</span></span><br></pre></td></tr></table></figure>
<p>[c7-media]<br>name=CentOS-$releasever - Media<br>baseurl=file:///mnt/cdrom/</p>
<p>gpgcheck=0<br>enabled=1<br><code>``
5、测试安装源</code>yum clean all<br><code>yum makecache
（二）升级openssh版本到8.6p1
1、下载或上传安装包openssh-8.6p1.tar.gz到/root目录下
进入安装包所在文件夹</code>cd /root/linshi</p>
<p>2、关闭Selinux<br><code>setenforce 0</code>sed -i “s/SELINUX=enforcing/SELINUX=disabled/g” /etc/selinux/config</p>
<p>3、安装依赖关系<br><code>yum install -y gcc pam-devel rpm-build wget zlib-devel openssl-devel net-tools</code>tar -xvf openssh-8.6p1.tar.gz<br>`cd openssh-8.6p1</p>
<p>4、卸载旧版openssh<br><code>rpm -qa |grep openssh
ps:下一步骤为删除原有ssh，但不会影响现在进行的ssh会话，所以整个操作过程不要断开ssh会话，
否则无法再次连接，只能由现场人员进行回退后重新操作（推荐使用telnet进行升级）。</code>for i in $(rpm -qa |grep openssh);do rpm -e $i —nodeps;done</p>
<p>5、设置、编译、安装<br><code>`./configure --prefix=/usr --sysconfdir=/etc/ssh --with-md5-passwords --with-pam --with-tcp-wrappers  --with-ssl-dir=/usr/local/ssl/lib --without-hardening</code>mv /etc/ssh /etc/ssh.old<br>`cp contrib/redhat/sshd.pam /etc/pam.d/sshd</p>
<h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>`make</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>`make install</p>
<p>6、设置自启动<br><code>复制启动脚本到/etc/init.d</code>cp contrib/redhat/sshd.init /etc/init.d/sshd<br><code>chkconfig --add sshd</code>chkconfig sshd on<br><code>chkconfig --list|grep sshd</code>sed -i “32a PermitRootLogin yes” /etc/ssh/sshd_config<br><code>`重启ssh服务</code>service sshd restart</p>
<p>7、检查升级情况<br>`ssh -V<br>输出版本号为“OpenSSH_8.6p1”，说明更新成功</p>
<p>(三)关闭telnet<br>关闭服务<br><code>systemctl stop telnet.socket</code>systemctl stop xinetd<br><code>#root可以登录</code>#mv /etc/securetty.bak /etc/securetty</p>
<p>卸载telnet<br>`yum remove telnet-server  xinetd</p>
<p>ps：此时ssh是可以连接状态，不要断开连接防止修改出错无法连接服务器。测试新端口是否打开<br>`telnet 127.0.0.1 22</p>
<h1 id="出现如下显示表示端口正常打开"><a href="#出现如下显示表示端口正常打开" class="headerlink" title="出现如下显示表示端口正常打开"></a>出现如下显示表示端口正常打开</h1><p><code>Trying 127.0.0.1...</code>Connected to 127.0.0.1.<br><code>Escape character is &#39;^]&#39;.</code>SSH-2.0-OpenSSH_8.6<br>使用远程工具新开窗口，连接新端口测试修改是否成功，如有问题马上使用之前的连接进行检查修改。</p>
<p>（四）回退方案<br>1、挂载iso文件作为yum源<br><code>mount -o loop /mnt/iso/CentOS-7.6-x86_64-DVD-1810.iso /mnt/cdrom
2、安装openssh</code>yum install openssh*<br>3、启动ssh<br>`service sshd start<br>4、重新连接ssh，然后从（二）4开始做。</p>
<h2 id="3-查看CPU信息："><a href="#3-查看CPU信息：" class="headerlink" title="3 查看CPU信息："></a>3 查看CPU信息：</h2><p>内存文件：</p>
<p>/proc/meminfo</p>
<p>/proc/cpuinfo</p>
<p>命令：</p>
<p>lscpu lsmem</p>
<p>查看CPU使用最高的进程：</p>
<p>ps -aux | sort -k3nr | head -n</p>
<h2 id="4-查看端口："><a href="#4-查看端口：" class="headerlink" title="4 查看端口："></a>4 查看端口：</h2><p>netstat -anp | grep port_number</p>
<h2 id="5-查看硬盘空间："><a href="#5-查看硬盘空间：" class="headerlink" title="5 查看硬盘空间："></a>5 查看硬盘空间：</h2><p>df -aTh</p>
<p>du -h -d 1</p>
<p>作者：赵先生<br>链接：<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/483668258/answer/3048322619">https://www.zhihu.com/question/483668258/answer/3048322619</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/05/07/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-cond/"></a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-05-07
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>Golang 的 sync 包中的 Cond 实现了一种条件变量，可以使用在<strong>多个Reader</strong>等待共享资源 ready 的场景（如果只有一读一写，一个锁或者channel就搞定了）。<br>Cond的汇合点：多个goroutines等待、1个goroutine通知事件发生。<br>比较适合任务调用场景，一个 Master goroutine 通知事件发生，多个 Worker goroutine 在资源没准备好的时候就挂起，等待通知。<br><strong>使用方法</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Cond</span></span><br><span class="line">cond := sync.NewCond(<span class="built_in">new</span>(sync.Mutex))</span><br><span class="line"><span class="comment">// 挂起goroutine</span></span><br><span class="line">cond.L.Lock()</span><br><span class="line">cond.Wait()</span><br><span class="line"><span class="comment">// 唤醒一个</span></span><br><span class="line">cond.Signal()</span><br><span class="line"><span class="comment">// 唤醒所有</span></span><br><span class="line">cond.Broadcast()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>基本使用大概是需要等待的时候通过 Wait() 将 Goroutine 挂起，资源准备好的时候再通过 Signal() 或者 Broadcast() 将挂起中的 Goroutine 唤醒。</p>
</blockquote>
<p>一个简单的 Demo<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		locker sync.Mutex</span><br><span class="line">		cond   = sync.NewCond(&amp;locker)</span><br><span class="line">		wg     sync.WaitGroup</span><br><span class="line">	)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		wg.Add(<span class="number">1</span>)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(number <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">			<span class="comment">// wait()方法内部是先释放锁 然后在加锁 所以这里需要先 Lock()</span></span><br><span class="line">			cond.L.Lock()</span><br><span class="line">			<span class="keyword">defer</span> cond.L.Unlock()</span><br><span class="line">			cond.Wait() <span class="comment">// 等待通知,阻塞当前 goroutine</span></span><br><span class="line">			fmt.Printf(<span class="string">&quot;g %v ok~ \n&quot;</span>, number)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">		<span class="comment">// 每过 50毫秒 唤醒一个 goroutine</span></span><br><span class="line">		cond.Signal()</span><br><span class="line">		time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">	<span class="comment">// 剩下5个 goroutine 一起唤醒</span></span><br><span class="line">	cond.Broadcast()</span><br><span class="line">	fmt.Println(<span class="string">&quot;Broadcast...&quot;</span>)</span><br><span class="line">	wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><blockquote>
<p>go version 1.14.7</p>
</blockquote>
<h3 id="2-1-Cond"><a href="#2-1-Cond" class="headerlink" title="2.1 Cond"></a>2.1 Cond</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 21</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line">    L Locker</span><br><span class="line">    notify  notifyList</span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCond() 返回指针，保证多 goroutine 获取到的是同一个实例。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span></span> *Cond &#123;</span><br><span class="line">	<span class="keyword">return</span> &amp;Cond&#123;L: l&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>noCopy</strong>：noCopy对象，实现了<code>sync.Locker</code>接口，使得内嵌 noCopy 的对象在进行 go vet 静态检查的时候，可以检查出是否被复制。</p>
<blockquote>
<p>noCopy 具体见 <a target="_blank" rel="noopener" href="https://github.com/golang/go/issues/8005">Go issues 8005</a></p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 94</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> noCopy <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*noCopy)</span></span> Lock()   &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*noCopy)</span></span> Unlock() &#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>L</strong>：实现了 <code>sync.Locker</code> 接口的锁对象，通常使用 Mutex 或 RWMutex 。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： mutex.go</span></span><br><span class="line"><span class="comment">line: 31</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">     Lock()</span><br><span class="line">     Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>notify</strong>：notifyList 对象，维护等待唤醒的 goroutine 队列,使用链表实现。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： runtime.go</span></span><br><span class="line"><span class="comment">line: 33    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">	wait   <span class="type">uint32</span></span><br><span class="line">	notify <span class="type">uint32</span></span><br><span class="line">	lock   <span class="type">uintptr</span></span><br><span class="line">	head   unsafe.Pointer</span><br><span class="line">	tail   unsafe.Pointer</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p><strong>checker</strong>：copyChecker 对象，实际上是 uintptr 对象，保存自身对象地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 79    </span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="keyword">type</span> copyChecker <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *copyChecker)</span></span> check() &#123;</span><br><span class="line">     <span class="keyword">if</span> <span class="type">uintptr</span>(*c) != <span class="type">uintptr</span>(unsafe.Pointer(c)) &amp;&amp;</span><br><span class="line">            !atomic.CompareAndSwapUintptr((*<span class="type">uintptr</span>)(c), <span class="number">0</span>, <span class="type">uintptr</span>(unsafe.Pointer(c))) &amp;&amp;</span><br><span class="line">            <span class="type">uintptr</span>(*c) != <span class="type">uintptr</span>(unsafe.Pointer(c)) &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;sync.Cond is copied&quot;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>1）检查当前 checker 对象的地址是否等于保存在 checker 中的地址</p>
<ul>
<li>由于第一次比较的时候 checker 中没有存地址所以第一次比较肯定是不相等的，于是有了后续 2 3步。</li>
</ul>
</li>
<li><p>2）对 checker 进行 CAS 操作，如果 checker 中存储的地址值为空（就是0）就把当前 checker 对象的地址值存进去</p>
</li>
<li>3）第三步和第一步一样，再比较一下。<ul>
<li>主要是防止在第一步比较发现不相等之后，第二步 CAS 之前，其他 goroutine 也在执行这个方法，并发的将 checker 赋值了，导致这里判定的时候第二步 CAS 失败，返回 false，然后错误的抛出一个 panic，所以执行第三步在比较一下是否相等。如果其他 goroutine 抢先执行 CAS 修改了 checker 中的值导致这里第二步也返回 false 的话，第三步的判定也会是相等的，不会抛出 panic</li>
</ul>
</li>
<li>4）如果 3 个条件都成立，那 checker 肯定是被复制了，就是由于 cond 被复制引起的。</li>
</ul>
<blockquote>
<p>check 方法在第一次调用的时候，会将 checker 对象地址赋值给 checker，也就是将自身内存地址赋值给自身。<br>再次调用 checker 方法的时候，会将当前 checker 对象地址值与 checker 中保存的地址值（原始地址）进行比较，若不相同则表示当前 checker 的地址不是第一次调用 check 方法时候的地址，即 cond 对象被复制了，导致checker 被重新分配了内存地址。</p>
</blockquote>
<h3 id="2-2-Wait"><a href="#2-2-Wait" class="headerlink" title="2.2 Wait"></a>2.2 Wait</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 52    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait() &#123;</span><br><span class="line">    <span class="comment">// 1.每次操作之前都要检测一下 cond 是否被复制了。</span></span><br><span class="line">    c.checker.check() </span><br><span class="line">    <span class="comment">// 2.将 notifyList 中的 wait 值加1并返回之前的值</span></span><br><span class="line">    t := runtime_notifyListAdd(&amp;c.notify) </span><br><span class="line">    <span class="comment">// 3.释放锁，因此在调用Wait方法前，必须保证获取到了cond的锁，否则会报错</span></span><br><span class="line">    c.L.Unlock()</span><br><span class="line">    <span class="comment">// 4.将当前goroutine挂起，等待唤醒信号</span></span><br><span class="line">    runtime_notifyListWait(&amp;c.notify, t) </span><br><span class="line">    <span class="comment">// 5.gorountine被唤醒，重新获取锁</span></span><br><span class="line">    c.L.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> package: runtime</span></span><br><span class="line"><span class="comment"> file： sema.go</span></span><br><span class="line"><span class="comment"> line: 479  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListAdd</span><span class="params">(l *notifyList)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> atomic.Xadd(&amp;l.wait, <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四步代码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: runtime</span></span><br><span class="line"><span class="comment">file： sema.go</span></span><br><span class="line"><span class="comment">line: 488  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 获取当前 goroutine 添加到链表末端，然后 goparkunlock 函数休眠阻塞当前 goroutine</span></span><br><span class="line"><span class="comment">// goparkunlock 函数会让出当前处理器的使用权并等待调度器的唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListWait</span><span class="params">(l *notifyList, t <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.锁住 notify 队列</span></span><br><span class="line">    lock(&amp;l.lock)</span><br><span class="line">    <span class="comment">// 2.判断传入的等待序号t是否小于当前已经唤醒的序号notify</span></span><br><span class="line">    <span class="comment">// 如果是则说明当前 goroutine 不需要阻塞了 直接解锁并返回</span></span><br><span class="line">    <span class="comment">// 有可能执行这步之前 goroutine 就已经被唤醒了</span></span><br><span class="line">    <span class="keyword">if</span> less(t, l.notify) &#123;</span><br><span class="line">        unlock(&amp;l.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.获取当前 goroutine，设置相关参数，将当前等待数赋值给 ticket</span></span><br><span class="line">    s := acquireSudog()</span><br><span class="line">    s.g = getg()</span><br><span class="line">    s.ticket = t</span><br><span class="line">    s.releasetime = <span class="number">0</span></span><br><span class="line">    t0 := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">        s.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.将当前 goroutine 写入到链表尾部</span></span><br><span class="line">    <span class="keyword">if</span> l.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">        l.head = s</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l.tail.next = s</span><br><span class="line">    &#125;</span><br><span class="line">    l.tail = s</span><br><span class="line">    <span class="comment">// 5. 调用 goparkunlock 函数将当前 goroutine 挂起，等待唤醒信号</span></span><br><span class="line">    goparkunlock(&amp;l.lock, <span class="string">&quot;semacquire&quot;</span>, traceEvGoBlockCond, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(s.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-Signal"><a href="#2-3-Signal" class="headerlink" title="2.3 Signal"></a>2.3 Signal</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 64  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal() &#123;</span><br><span class="line">    <span class="comment">// 1.复制检查</span></span><br><span class="line">    c.checker.check() </span><br><span class="line">    <span class="comment">// 2.顺序唤醒一个等待的gorountine</span></span><br><span class="line">    runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: runtime</span></span><br><span class="line"><span class="comment">file： sema.go</span></span><br><span class="line"><span class="comment">line: 554  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyOne</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 1.等待序号和唤醒序号相同则说明没有需要唤醒的 goroutine 直接返回</span></span><br><span class="line">   <span class="keyword">if</span> atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 2.锁住队列后再检查一遍等待序号和唤醒序号是否相同即判断有没有需要唤醒的 goroutine，没有则解锁后直接返回</span></span><br><span class="line">   lock(&amp;l.lock) </span><br><span class="line">   t := l.notify</span><br><span class="line">   <span class="keyword">if</span> t == atomic.Load(&amp;l.wait) &#123;</span><br><span class="line">        unlock(&amp;l.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 3.到这里就说明有需要唤醒的 goroutine，于是先将 notify序号+1</span></span><br><span class="line">   atomic.Store(&amp;l.notify, t+<span class="number">1</span>)  </span><br><span class="line">   <span class="comment">// 4.然后就开始唤醒 goroutine 了</span></span><br><span class="line">   <span class="keyword">for</span> p, s := (*sudog)(<span class="literal">nil</span>), l.head; s != <span class="literal">nil</span>; p, s = s, s.next &#123;</span><br><span class="line">        <span class="comment">// 4.1 找到 ticket等于当前唤醒序号的 goroutine</span></span><br><span class="line">        <span class="keyword">if</span> s.ticket == t &#123;</span><br><span class="line">           <span class="comment">// 4.2 然后将其从等待唤醒链表中移除（因为这个 goroutine 马上就要被唤醒了）</span></span><br><span class="line">           n := s.next</span><br><span class="line">           <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">               p.next = n</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               l.head = n</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">               l.tail = p</span><br><span class="line">           &#125;</span><br><span class="line">           unlock(&amp;l.lock)</span><br><span class="line">           s.next = <span class="literal">nil</span></span><br><span class="line">           <span class="comment">// 4.3 然后唤醒这个 goroutine </span></span><br><span class="line">           readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">           <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 4.4 最后解锁队列 </span></span><br><span class="line">   unlock(&amp;l.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-Broadcast"><a href="#2-4-Broadcast" class="headerlink" title="2.4 Broadcast"></a>2.4 Broadcast</h3><p>唤醒链表中所有的阻塞中的goroutine，还是使用readyWithTime来实现这个功能</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 73  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast() &#123;</span><br><span class="line">    <span class="comment">// 1.复制检查</span></span><br><span class="line">    c.checker.check()</span><br><span class="line">    <span class="comment">// 2.唤醒所有在等待的 goroutine</span></span><br><span class="line">    runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里和 <code>notifyListNotifyOne()</code>差不多，只是一次性唤醒所有 goroutine。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: runtime</span></span><br><span class="line"><span class="comment">file： sema.go</span></span><br><span class="line"><span class="comment">line: 522 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyAll</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.等待序号和唤醒序号相同则说明没有需要唤醒的 goroutine 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将链表头尾指针置为空（可以看做是清空整个等待队列）</span></span><br><span class="line">    <span class="comment">// 但是需要将当前的链表头保存下来，不然等会找不到链表中的数据了</span></span><br><span class="line">    lock(&amp;l.lock)</span><br><span class="line">    s := l.head</span><br><span class="line">    l.head = <span class="literal">nil</span></span><br><span class="line">    l.tail = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.直接将notify需要赋值成等待序号（这样表示当前没有需要唤醒的 goroutine 了）</span></span><br><span class="line">    <span class="comment">// 前面唤醒一个的时候这里是+1</span></span><br><span class="line">    atomic.Store(&amp;l.notify, atomic.Load(&amp;l.wait))</span><br><span class="line">    unlock(&amp;l.lock)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4.最后 for 循环唤醒链表中所有等待状态的 goroutine</span></span><br><span class="line">    <span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">        next := s.next</span><br><span class="line">        s.next = <span class="literal">nil</span></span><br><span class="line">        readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">        s = next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p><strong>基本使用</strong></p>
<ul>
<li>1）资源未准备好时，使用 Wait() 方法将 goroutine 挂起，由底层实现，会让出 CPU 时间片，从而避免使用无意义的循环浪费系统资源。</li>
<li>2）资源准备好时通过 Signal() 或者 Broadcast() 方法唤醒一个或多个被挂起的 goroutine。</li>
</ul>
<p><strong>等待唤醒流程</strong></p>
<ul>
<li>1）所有相关数据都是存在 notifyList 中的，包括 goroutine 和一些计数信息。</li>
<li>2）其中的 wait 和 notify 可以理解为等待序号和唤醒序号，都是自增值，wait 在有新 goroutine 等待时+1，notify 则在唤醒一个 goroutine 时+1。</li>
<li>3）等待状态的 goroutine 信息则存放在链表中，等待时加入链表尾部，唤醒时移除。</li>
<li>4）每个等待链表的 goroutine  都会将当前的 wait（等待序号）赋值给 ticket 字段，唤醒的时候会将 ticket=唤醒序号的 goroutine 唤醒。</li>
<li>5）当 wait==notify 时表示没有 goroutine 需要被唤醒，wait&gt;notify 时表示有 goroutine 需要被唤醒，wait 恒大于等于 notify。</li>
</ul>
<p><strong>noCopy</strong><br>Cond在内部持有一个等待队列 notifyList ，这个队列维护所有等待在这个 Cond 的 goroutine。如果 Cond 被复制则会导致其中的等待队列也被复制，最终可能会导致在唤醒 goroutine 的时候出现错误。<br>Kubernetes 的调度中也用到了 sync.Cond 有兴趣的可以研究一下。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/rKLiazgWzneJfpfgHay8cA">https://mp.weixin.qq.com/s/rKLiazgWzneJfpfgHay8cA</a><br><a target="_blank" rel="noopener" href="https://github.com/kubernetes/kubernetes/blob/0599ca2bcfcae7d702f95284f3c2e2c2978c7772/pkg/scheduler/internal/queue/scheduling_queue.go">https://github.com/kubernetes/kubernetes/blob/0599ca2bcfcae7d702f95284f3c2e2c2978c7772/pkg/scheduler/internal/queue/scheduling_queue.go</a></p>
<h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><code>https://ieevee.com/tech/2019/06/15/cond.html</code></p>
</blockquote>
<p><code>https://segmentfault.com/a/1190000019957459</code></p>
<p><code>https://www.jianshu.com/p/7b59d1d92a95</code></p>
<p><code>http://www.pydevops.com/2016/12/04/go-cond源码剖析-3/</code></p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/05/07/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/04-sync.Mutex/"></a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-05-07
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">Go 语言在 `sync` 包中提供了用于同步的一些基本原语,`sync.Mutex` 就是其中最常用的一个。</span><br><span class="line"></span><br><span class="line">&gt; 本文基于 Go 1.17.1</span><br><span class="line">## 1 基本结构</span><br><span class="line">Go 语言的 `sync.Mutex`由两个字段 `state` 和 `sema` 组成。其中 `state` 表示当前互斥锁的状态，而 `sema` 是用于控制锁状态的信号量。</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">// sync/mutex.go 25行</span><br><span class="line">type Mutex struct &#123;</span><br><span class="line">	state int32</span><br><span class="line">	sema  uint32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述两个字段加起来只占 8 字节空间的结构体表示了 Go 语言中的互斥锁。</p>
<h3 id="1-1-状态"><a href="#1-1-状态" class="headerlink" title="1.1 状态"></a>1.1 状态</h3><p>互斥锁的状态比较复杂，如下图所示，最低三位分别表示 <code>mutexLocked</code>、<code>mutexWoken</code> 和 <code>mutexStarving</code>，剩下的位置用来表示当前有多少个 Goroutine 在等待互斥锁的释放：<br>![[mutex-state.png]]<br><code>int32</code> 中的不同位分别表示了不同的状态：</p>
<ul>
<li><code>mutexLocked</code> — 表示互斥锁的锁定状态；</li>
<li><code>mutexWoken</code> — 表示从正常模式被从唤醒；</li>
<li><code>mutexStarving</code> — 当前的互斥锁进入饥饿状态；</li>
<li><code>waitersCount</code> — 当前互斥锁上等待的 Goroutine 个数</li>
</ul>
<p>在默认情况下，互斥锁的所有状态位都是 0，即默认为未锁定状态。</p>
<blockquote>
<p>同时也表明 Mutex 是不需要初始化的</p>
</blockquote>
<p>源码中也提供了相关常量</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/mutex.go 36</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"></span><br><span class="line">    mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 1 0001 含义：用最后一位表示当前对象锁的状态，0-未锁住 1-已锁住</span></span><br><span class="line"></span><br><span class="line">    mutexWoken <span class="comment">// 2 0010 含义：用倒数第二位表示当前对象是否被唤醒 0-唤醒 1-未唤醒</span></span><br><span class="line"></span><br><span class="line">    mutexStarving <span class="comment">// 4 0100 含义：用倒数第三位表示当前对象是否为饥饿模式，0为正常模式，1为饥饿模式。</span></span><br><span class="line"></span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span> <span class="comment">// 3，从倒数第四位往前的bit位表示在排队等待的goroutine数</span></span><br><span class="line"></span><br><span class="line">    starvationThresholdNs = <span class="number">1e6</span> <span class="comment">// 1ms 切换到饥饿模式的阈值</span></span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="1-2-正常模式和饥饿模式"><a href="#1-2-正常模式和饥饿模式" class="headerlink" title="1.2 正常模式和饥饿模式"></a>1.2 正常模式和饥饿模式</h3><p>Mutex 有两种模式：</p>
<ul>
<li>正常模式；</li>
<li>饥饿模式。</li>
</ul>
<p><strong>在正常模式下</strong>，锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被<strong>饿死</strong>。</p>
<blockquote>
<p><strong>引入饥饿模式的目的是保证互斥锁的公平性。</strong></p>
<p>说明 Mutex 是公平锁。</p>
</blockquote>
<p><strong>在饥饿模式中</strong>，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。</p>
<blockquote>
<p>与饥饿模式相比，正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时。</p>
</blockquote>
<p>这里贴一下源码中的注释</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Mutex fairness.</span><br><span class="line"></span><br><span class="line">Mutex can be in 2 modes of operations: normal and starvation.</span><br><span class="line">In normal mode waiters are queued in FIFO order, but a woken up waiter</span><br><span class="line">does not own the mutex and competes with new arriving goroutines over</span><br><span class="line">the ownership. New arriving goroutines have an advantage -- they are</span><br><span class="line">already running on CPU and there can be lots of them, so a woken up</span><br><span class="line">waiter has good chances of losing. In such case it is queued at front</span><br><span class="line">of the wait queue. If a waiter fails to acquire the mutex for more than 1ms,</span><br><span class="line">it switches mutex to the starvation mode.</span><br><span class="line"></span><br><span class="line">In starvation mode ownership of the mutex is directly handed off from</span><br><span class="line">the unlocking goroutine to the waiter at the front of the queue.</span><br><span class="line">New arriving goroutines don&#x27;t try to acquire the mutex even if it appears</span><br><span class="line">to be unlocked, and don&#x27;t try to spin. Instead they queue themselves at</span><br><span class="line">the tail of the wait queue.</span><br><span class="line"></span><br><span class="line">If a waiter receives ownership of the mutex and sees that either</span><br><span class="line">(1) it is the last waiter in the queue, or (2) it waited for less than 1 ms,</span><br><span class="line">it switches mutex back to normal operation mode.</span><br><span class="line"></span><br><span class="line">Normal mode has considerably better performance as a goroutine can acquire</span><br><span class="line">a mutex several times in a row even if there are blocked waiters.</span><br><span class="line">Starvation mode is important to prevent pathological cases of tail latency.</span><br></pre></td></tr></table></figure>
<h2 id="2-加解锁过程"><a href="#2-加解锁过程" class="headerlink" title="2 加解锁过程"></a>2 加解锁过程</h2><p>在<code>sync</code>包中 中定义了 Locker 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/mutex.go 31 行</span></span><br><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">        Lock()</span><br><span class="line">        Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Mutex 实现了 Locker 接口。除了互斥锁 Mutex 之外读写锁 RWMutex，也实现了 Locker 接口。</p>
<h3 id="2-1-Lock"><a href="#2-1-Lock" class="headerlink" title="2.1 Lock"></a>2.1 Lock</h3><p>互斥锁的加锁是靠 Mutex.Lock 方法完成的，以下代码进行了简化，省略了 race 相关代码，只保留主干部分：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/mutex.go 72 行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line">	<span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line">	<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Slow path (outlined so that the fast path can be inlined)</span></span><br><span class="line">	m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，整个加锁过程分为 Fast path 和 Slow Path。</p>
<h4 id="2-1-1-Fast-path"><a href="#2-1-1-Fast-path" class="headerlink" title="2.1.1 Fast path"></a>2.1.1 Fast path</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 m.state 为 0,说明当前锁为未锁定状态，将其设置为 1。</p>
<p>这也是最简单的部分，直接通过一个 CAS 操作，尝试获取锁。</p>
<h4 id="2-1-2-Slow-Path"><a href="#2-1-2-Slow-Path" class="headerlink" title="2.1.2 Slow Path"></a>2.1.2 Slow Path</h4><p>如果互斥锁的状态不是 0 时就会进入 Slow Path。尝试通过自旋（Spinnig）等方式等待锁的释放，该方法的主体是一个非常大 for 循环，这里将它分成几个部分介绍获取锁的过程：</p>
<ul>
<li>1）判断当前 Goroutine 能否进入自旋；</li>
<li>2）通过自旋等待互斥锁的释放；</li>
<li>3）计算互斥锁的最新状态；</li>
<li>4）更新互斥锁的状态并获取锁；</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> lockSlow() &#123;</span><br><span class="line">   <span class="keyword">var</span> waitStartTime <span class="type">int64</span></span><br><span class="line">   starving := <span class="literal">false</span></span><br><span class="line">   awoke := <span class="literal">false</span></span><br><span class="line">   iter := <span class="number">0</span></span><br><span class="line">   old := m.state</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">         <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">            awoke = <span class="literal">true</span></span><br><span class="line">         &#125;</span><br><span class="line">         runtime_doSpin()</span><br><span class="line">         iter++</span><br><span class="line">         old = m.state</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">new</span> := old</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">         <span class="built_in">new</span> |= mutexLocked</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">         <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">         <span class="built_in">new</span> |= mutexStarving</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> awoke &#123;</span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">         &#125;</span><br><span class="line">         queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">         <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">            waitStartTime = runtime_nanotime()</span><br><span class="line">         &#125;</span><br><span class="line">         runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">         starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">         old = m.state</span><br><span class="line">         <span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">               throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">            <span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">               delta -= mutexStarving</span><br><span class="line">            &#125;</span><br><span class="line">            atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         awoke = <span class="literal">true</span></span><br><span class="line">         iter = <span class="number">0</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         old = m.state</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>1）判断当前 Goroutine 能否进入自旋；</strong></p>
<p><strong>自旋是一种多线程同步机制</strong>，当前的进程在进入自旋的过程中会一直保持 CPU 的占用，持续检查某个条件是否为真。<strong>在多核的 CPU 上，自旋可以避免 Goroutine 的切换</strong>，使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 Goroutine 进入自旋的条件非常苛刻：</p>
<ul>
<li>1）互斥锁只有在普通模式才能进入自旋；</li>
<li>2）<code>runtime.sync_runtime_canSpin</code>需要返回 true<ul>
<li>运行在多 CPU 的机器上；</li>
<li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li>
<li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/proc.go 6364 行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_canSpin</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> i &gt;= active_spin || ncpu &lt;= <span class="number">1</span> || gomaxprocs &lt;= <span class="type">int32</span>(sched.npidle+sched.nmspinning)+<span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> p := getg().m.p.ptr(); !runqempty(p) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2）通过自旋等待互斥锁的释放；</strong></p>
<p>一旦当前 Goroutine 能够进入自旋就会调用<code>runtime.sync_runtime_doSpin</code>和<code>runtime.procyield</code>执行 30 次的 <code>PAUSE</code> 指令，该指令只会占用 CPU 并消耗 CPU 时间：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/proc.go 6381 行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_doSpin</span><span class="params">()</span></span> &#123;</span><br><span class="line">	procyield(active_spin_cnt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// runtime/asm_386.s 574 行</span><br><span class="line">TEXT runtime·procyield(SB),NOSPLIT,$0-0</span><br><span class="line">	MOVL	cycles+0(FP), AX</span><br><span class="line">again:</span><br><span class="line">	PAUSE</span><br><span class="line">	SUBL	$1, AX</span><br><span class="line">	JNZ	again</span><br><span class="line">	RET</span><br></pre></td></tr></table></figure>
<p><strong>3）计算互斥锁的最新状态；</strong></p>
<p> 处理了自旋相关的特殊逻辑之后，互斥锁会根据上下文计算当前互斥锁最新的状态。几个不同的条件分别会更新 <code>state</code> 字段中存储的不同信息 — <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 和 <code>mutexWaiterShift</code>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">new</span> := old</span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">new</span> |= mutexLocked</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">new</span> |= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> awoke &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4）更新互斥锁的状态并获取锁；</strong></p>
<p>计算了新的互斥锁状态之后，会使用 CAS 函数更新状态</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">    queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">        waitStartTime = runtime_nanotime()</span><br><span class="line">    &#125;</span><br><span class="line">    runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">    starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">    old = m.state</span><br><span class="line">    <span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">        <span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">            delta -= mutexStarving</span><br><span class="line">        &#125;</span><br><span class="line">        atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    awoke = <span class="literal">true</span></span><br><span class="line">    iter = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    old = m.state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有通过 CAS 获得锁，会调用 <code>runtime.sync_runtime_SemacquireMutex</code> 通过信号量保证资源不会被两个 Goroutine 获取。</p>
<p><code>runtime.sync_runtime_SemacquireMutex</code> 会在方法中不断尝试获取锁并陷入休眠等待信号量的释放，一旦当前 Goroutine 可以获取信号量，它就会立刻返回，<code>sync.Mutex.Lock</code>的剩余代码也会继续执行。</p>
<ul>
<li>在正常模式下，这段代码会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环；</li>
<li>在饥饿模式下，当前 Goroutine 会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出；</li>
</ul>
<p>其中还包含了状态切换的部分逻辑:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> waitStartTime <span class="type">int64</span></span><br><span class="line"><span class="keyword">for</span>&#123; <span class="comment">// for 循环里尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123; <span class="comment">// waitStartTime 只有第一次执行时才会赋值</span></span><br><span class="line">        waitStartTime = runtime_nanotime()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果等待时间超过 1ms 则切换到饥饿模式</span></span><br><span class="line">    starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-Unlock"><a href="#2-2-Unlock" class="headerlink" title="2.2 Unlock"></a>2.2 Unlock</h3><p>相比之下互斥锁的解锁过程就比较简单,同样分为 Fast path 和 Slow path。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123;</span><br><span class="line">	<span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line">	<span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Outlined slow path to allow inlining the fast path.</span></span><br><span class="line">		<span class="comment">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.</span></span><br><span class="line">		m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-1-Fast-path"><a href="#2-2-1-Fast-path" class="headerlink" title="2.2.1 Fast path"></a>2.2.1 Fast path</h4><p>该过程会先使用<code>atomic.AddInt32函数快速解锁，这时会发生下面的两种情况：</code></p>
<ul>
<li>如果该函数返回的新状态等于 0，当前 Goroutine 就成功解锁了互斥锁；</li>
<li>如果该函数返回的新状态不等于 0，则进入 Slow path。</li>
</ul>
<h4 id="2-2-2-Slow-path"><a href="#2-2-2-Slow-path" class="headerlink" title="2.2.2 Slow path"></a>2.2.2 Slow path</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> unlockSlow(<span class="built_in">new</span> <span class="type">int32</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">      throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">      old := <span class="built_in">new</span></span><br><span class="line">      <span class="keyword">for</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">         <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         old = m.state</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先校验锁状态的合法性 — 如果当前互斥锁已经被解锁过了会直接抛出异常 “sync: unlock of unlocked mutex” 中止当前程序。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后根据当前锁模式分别处理</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123; <span class="comment">// 正常模式</span></span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123; <span class="comment">// 饥饿模式</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在正常模式下，上述代码会使用如下所示的处理过程：</p>
<ul>
<li>如果互斥锁不存在等待者或者互斥锁的 <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 状态不都为 0，那么当前方法可以直接返回，不需要唤醒其他等待者；</li>
<li>如果互斥锁存在等待者，会通过<code>runtime_Semrelease</code>唤醒等待者并移交锁的所有权；</li>
</ul>
<p>在饥饿模式下，上述代码会直接调用<code>runtime_Semrelease</code>将当前锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁，在这时互斥锁还不会退出饥饿状态；</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/sema.go 65行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_Semrelease</span><span class="params">(addr *<span class="type">uint32</span>, handoff <span class="type">bool</span>, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	semrelease1(addr, handoff, skipframes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semrelease1</span><span class="params">(addr *<span class="type">uint32</span>, handoff <span class="type">bool</span>, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	root := semroot(addr)</span><br><span class="line">	atomic.Xadd(addr, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;root.nwait) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Harder case: search for a waiter and wake it.</span></span><br><span class="line">	lockWithRank(&amp;root.lock, lockRankRoot)</span><br><span class="line">	<span class="keyword">if</span> atomic.Load(&amp;root.nwait) == <span class="number">0</span> &#123;</span><br><span class="line">		unlock(&amp;root.lock)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	s, t0 := root.dequeue(addr)</span><br><span class="line">	<span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">		atomic.Xadd(&amp;root.nwait, <span class="number">-1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	unlock(&amp;root.lock)</span><br><span class="line">	<span class="keyword">if</span> s != <span class="literal">nil</span> &#123; <span class="comment">// May be slow or even yield, so unlock first</span></span><br><span class="line">		acquiretime := s.acquiretime</span><br><span class="line">		<span class="keyword">if</span> acquiretime != <span class="number">0</span> &#123;</span><br><span class="line">			mutexevent(t0-acquiretime, <span class="number">3</span>+skipframes)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> s.ticket != <span class="number">0</span> &#123;</span><br><span class="line">			throw(<span class="string">&quot;corrupted semaphore ticket&quot;</span>)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> handoff &amp;&amp; cansemacquire(addr) &#123;</span><br><span class="line">			s.ticket = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">		readyWithTime(s, <span class="number">5</span>+skipframes)</span><br><span class="line">		<span class="keyword">if</span> s.ticket == <span class="number">1</span> &amp;&amp; getg().m.locks == <span class="number">0</span> &#123;</span><br><span class="line">			goyield()</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p>互斥锁的<strong>加锁过程</strong>比较复杂，它涉及自旋、信号量以及调度等概念：</p>
<ul>
<li>如果互斥锁处于初始化状态，会通过置位 <code>mutexLocked</code> 加锁；</li>
<li>如果互斥锁处于 <code>mutexLocked</code> 状态并且在普通模式下工作，会进入自旋，执行 30 次 <code>PAUSE</code> 指令消耗 CPU 时间等待锁的释放；</li>
<li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li>
<li>互斥锁在正常情况下会通过<code>sync_runtime_SemacquireMutex</code>将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；</li>
<li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式；</li>
</ul>
<p>互斥锁的<strong>解锁过程</strong>与之相比就比较简单：</p>
<ul>
<li>当互斥锁已经被解锁时，调用 Mutex.Lock 会直接抛出异常；</li>
<li>当互斥锁处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 <code>mutexLocked</code> 标志位；</li>
<li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，会直接返回；在其他情况下会通过<code>sync.runtime_Semrelease</code> 唤醒对应的 Goroutine；</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/05/07/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.WaitGroup/"></a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-05-07
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&gt;Golang 调度方式：`主动让渡`和`被动调度`</span><br><span class="line">&gt;	被动调度: `通道 channel` 、`单机锁 sync.Mutex`、`并发等待组 sync.WaitGroup`</span><br><span class="line">&gt;当 goroutine 之间需要建立明确的`层级关系`. 倘若父 goroutine 希望持有子 goroutine 的生杀大权，并且保证父 goroutine 消亡时能连带回收其创建的所有子 goroutine ，此时可以使用到 Golang 上下文工具 context，完成父 goroutine 对 子 goroutine 的`生命周期控制`</span><br><span class="line"></span><br><span class="line">&gt; 多个协程等待一个协程执行完，除了WaitGroup 还有什么方式？  写入channel，for循环读</span><br><span class="line">## 1 How to use？</span><br><span class="line">### 1.1 核心方法</span><br><span class="line">• `WaitGroup.Add(n)`：完成一次登记操作，使得 WaitGroup 中并发计数器的数值加上 n. 在使用场景中，WaitGroup.Add(n) 背后的含义是，注册并启动了 n 个子 goroutine</span><br><span class="line">• `WaitGroup.Done()`：完成一次上报操作，使得 WaitGroup 中并发计数器的数值减 1. 在使用场景中，通常会在一个子 goroutine 退出前，会执行一次 WaitGroup.Done 方法</span><br><span class="line">• `WaitGroup.Wait()`：完成聚合操作. 通常由主 goroutine 调用该方法，主 goroutine 会因此陷入阻塞，直到所有子 goroutine 都已经执行完成，使得 WaitGroup 并发计数器数值清零时，主 goroutine 才得以继续往下执行</span><br><span class="line"></span><br><span class="line">### 1.2 案例</span><br><span class="line">```go</span><br><span class="line">func Test_waitGroup(t *testing.T) &#123;</span><br><span class="line">    var wg sync.WaitGroup   // 声明等待组 wg</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;   // 循环开启十个子 Goroutine</span><br><span class="line">        wg.Add(1)               // 登记子 Goroutine</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer wg.Done()     // 保证退出前会调用一次，完成上报</span><br><span class="line">            &lt;-time.After(time.Second)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()                   // 阻塞等待，直到等待组全部完成后才往下走</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：子 goroutine 是异步启动的，所以有可能出现 Wait 方法先于 Add 方法执行，此时由于计数器值为 0，Wait 方法会被直接放行，导致产生预期之外的执行流程；因此要保证 add 在 done 之前。</p>
</blockquote>
<h3 id="1-3-WaitGroup-channel-完成数据聚合"><a href="#1-3-WaitGroup-channel-完成数据聚合" class="headerlink" title="1.3 WaitGroup + channel 完成数据聚合"></a>1.3 WaitGroup + channel 完成数据聚合</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_waitGroup</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tasksNum := <span class="number">10</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 数据缓存 channel</span></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    <span class="comment">// 数据结果 slice</span></span><br><span class="line">    resp := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, tasksNum)</span><br><span class="line">    <span class="comment">// 控制管道</span></span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 启动读 goroutine</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> data := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">            resp = <span class="built_in">append</span>(resp, data)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标识数据读取完成</span></span><br><span class="line">        stopCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证获取到所有数据后，通过 channel 传递到读协程手中</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; tasksNum; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            ch &lt;- time.Now().UnixNano()</span><br><span class="line">        &#125;(dataCh)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确保所有取数据的协程都完成了工作，才关闭 ch</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(dataCh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保读协程处理完成</span></span><br><span class="line">    &lt;-stopCh</span><br><span class="line"></span><br><span class="line">    t.Logf(<span class="string">&quot;resp: %+v&quot;</span>, resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-源码走读"><a href="#2-源码走读" class="headerlink" title="2 源码走读"></a>2 源码走读</h2><h3 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h3><p>WaitGroup 位于 golang sync 包下，对应的类声明中包含了几个核心字段：</p>
<ul>
<li><code>noCopy</code>：这是防拷贝标识，标记了 WaitGroup 不应该用于值传递</li>
<li><code>state1</code>：这是 WaitGroup 的核心字段，是一个无符号的64位整数，高32位是 WaitGroup 中并发计数器的数值，即当前 WaitGroup.Add 与 WaitGroup.Done 之间的差值；低 32 位标识了，当前有多少 goroutine 因 WaitGroup.Wait 操作而处于阻塞态，陷入阻塞态的原因是因为计数器的值没有清零，即 state1 字段高 32 位是一个正值</li>
<li><code>state2</code>：用于阻塞和唤醒 goroutine 的信号量</li>
</ul>
<p><code>WaitGroup.Add</code> 方法会给 WaitGroup 的计数器累加上一定的值，背后的含义是标识出当前有多少 goroutine 正在运行，需要由 WaitGroup.Done 操作完成数值的抵扣：</p>
<ul>
<li>首先通过 WaitGroup.state 方法，获取到 WaitGroup 的 state1 和 state2 字段，分别将字段对应的地址赋给临时变量 statep 和 semap</li>
<li>调用 atomic.AddUint64，直接通过指针的方式直接在 WaitGroup.state1 的高 32 位基础上累加上 delta 的值</li>
<li>获取到 state1 高 32 位的值，赋值给局部变量 v，其含义是并发计数器的数值，即 WaitGroup.Add 和 WaitGroup.Done 之间的差值</li>
<li>获取到 state1 低 32 位的值，赋值给局部变量 w. 其含义是因执行 WaitGroup.Wait 操作而陷入阻塞态的 goroutine 数量</li>
<li>倘若 WaitGroup 计数器出现负值，直接 panic（ Done 不应该多于 Add ）</li>
<li>倘若首次 Add 操作是在有 goroutine 因 Wait 操作而陷入阻塞时才执行，抛出 panic（if w != 0 &amp;&amp; delta &gt; 0 &amp;&amp; v == int32(delta) ）</li>
<li>倘若执行完 Add 操作后，WaitGroup 的计数器还是正值，则直接返回</li>
<li>倘若发现本次 Add 操作后， WaitGroup 计数器被清零了，则接下来需要依次把因 Wait 操作而陷入阻塞的 goroutine 唤醒. 在这期间，不允许再并发执行 Add 操作，否则会 panic</li>
<li>唤醒 goroutine 使用的方法是 runtime_Semrelease 方法，底层会执行 goready 操作，属于 goroutine 的被动调度模式</li>
</ul>
<p>执行 WaitGroup.Wait 方法，会判断 WaitGroup 中的并发计数器数值是否为 0，如果不等于0，则当前 goroutine 会陷入阻塞态，直到计数器数值清零之后，才会被唤醒. 具体的执行流程如下：</p>
<ul>
<li>执行 WaitGroup.state 方法，获取到 state1 和 state2 字段</li>
<li>走进 for 循环开启自旋流程</li>
<li>将 state1 高 32 位所存储的计数器数值赋给局部变量 v</li>
<li>将 state1 低 32 位所存储的阻塞 goroutine 数量赋给局部变量 w</li>
<li>倘若计数器数值 v 已经是 0 了，则无需阻塞 goroutine，直接返回即可</li>
<li>倘若计数器数值 v 大于 0，代表当前 goroutine 需要被阻塞挂起.</li>
<li>基于 cas，将 state1 低 32 位的数值加 1，标识有一个额外的 goroutine 需要阻塞挂起了</li>
<li>调用 runtime_Semacquire 方法，内部会通过 go park 操作，将当前 goroutine 阻塞挂起，属于被动调度模式</li>
<li>当 goroutine 从 runtime_Semacquire 方法走出来时，说明 WaitGroup 计数器已经被清零了.</li>
<li>在被唤醒的 goroutine 返回前，WaitGroup 不能被并发执行 Add 操作，否则会陷入 panic</li>
<li>被唤醒的 goroutine 正常返回，Wait 流程结束</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/05/07/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.Mutex/"></a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-05-07
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">## 1 基本结构</span><br><span class="line">```go</span><br><span class="line">// sync/mutex.go 25行</span><br><span class="line">type Mutex struct &#123;</span><br><span class="line">	state int32      // 当前互斥锁的状态</span><br><span class="line">	sema  uint32     // 控制锁状态的信号量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-1-state字段"><a href="#1-1-state字段" class="headerlink" title="1.1 state字段"></a>1.1 state字段</h3><p>![[Pasted image 20230901043018.png]]<br>低三位分别标识</p>
<ul>
<li>mutexLocked（是否上锁）</li>
<li>mutexWoken（是否有协程在抢锁）</li>
<li>mutexStarving（是否处于饥饿模式）</li>
<li>高 29 位的值聚合为一个范围为 0~2^29-1 的整数，表示在阻塞队列中等待的协程个数.</li>
</ul>
<h3 id="1-2-正常模式和饥饿模式"><a href="#1-2-正常模式和饥饿模式" class="headerlink" title="1.2 正常模式和饥饿模式"></a>1.2 正常模式和饥饿模式</h3><blockquote>
<p>mutex 是公平锁</p>
</blockquote>
<p><code>正常模式</code>：锁的等待者会按照<code>先进先出</code>的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine <code>超过 1ms</code> 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被<strong>饿死</strong>。<br><code>饥饿模式</code>：互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间<code>少于 1ms</code>，那么当前的互斥锁就会切换回正常模式。</p>
<h2 id="2-加解锁过程"><a href="#2-加解锁过程" class="headerlink" title="2 加解锁过程"></a>2 加解锁过程</h2><h3 id="2-1-加锁"><a href="#2-1-加锁" class="headerlink" title="2.1 加锁"></a>2.1 加锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/mutex.go 72 行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line">	<span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line">	<span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Slow path (outlined so that the fast path can be inlined)</span></span><br><span class="line">	m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-1-1-Fast-path"><a href="#2-1-1-Fast-path" class="headerlink" title="2.1.1 Fast path"></a>2.1.1 Fast path</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先进行 <code>CAS</code> 操作，假如当前未上锁且锁内不存在阻塞协程，则直接 CAS 抢锁成功返回</p>
</blockquote>
<h4 id="2-1-2-Slow-Path"><a href="#2-1-2-Slow-Path" class="headerlink" title="2.1.2 Slow Path"></a>2.1.2 Slow Path</h4><p>如果互斥锁的状态不是 0 时就会进入 Slow Path。尝试通过自旋（Spinnig）等方式等待锁的释放，该方法的主体是一个非常大 for 循环，这里将它分成几个部分介绍获取锁的过程：</p>
<h5 id="2-1-2-1-判断当前-Goroutine-能否进入自旋"><a href="#2-1-2-1-判断当前-Goroutine-能否进入自旋" class="headerlink" title="2.1.2.1 判断当前 Goroutine 能否进入自旋"></a>2.1.2.1 判断当前 Goroutine 能否进入自旋</h5><p><strong>自旋是一种多线程同步机制</strong>，当前的进程在进入自旋的过程中会一直保持 CPU 的占用，持续检查某个条件是否为真。<strong>在多核的 CPU 上，自旋可以避免 Goroutine 的切换</strong>，使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 Goroutine 进入自旋的条件非常苛刻：</p>
<ul>
<li>互斥锁只有在普通模式才能进入自旋；</li>
<li><code>runtime.sync_runtime_canSpin</code>需要返回 true<ul>
<li>运行在多 CPU 的机器上；</li>
</ul>
<ul>
<li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li>
<li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li>
</ul>
</li>
</ul>
<h5 id="2-1-2-2-通过自旋等待互斥锁的释放"><a href="#2-1-2-2-通过自旋等待互斥锁的释放" class="headerlink" title="2.1.2.2 通过自旋等待互斥锁的释放"></a>2.1.2.2 通过自旋等待互斥锁的释放</h5><p>一旦当前 Goroutine 能够进入自旋就会调用<code>runtime.sync_runtime_doSpin</code>和<code>runtime.procyield</code>执行 30 次的 <code>PAUSE</code> 指令，该指令只会占用 CPU 并消耗 CPU 时间：</p>
<h5 id="2-1-2-3-计算互斥锁的最新状态"><a href="#2-1-2-3-计算互斥锁的最新状态" class="headerlink" title="2.1.2.3 计算互斥锁的最新状态"></a>2.1.2.3 计算互斥锁的最新状态</h5><p>处理了自旋相关的特殊逻辑之后，互斥锁会根据上下文计算当前互斥锁最新的状态。几个不同的条件分别会更新 <code>state</code> 字段中存储的不同信息 — <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 和 <code>mutexWaiterShift</code>：</p>
<h5 id="2-1-2-4-更新互斥锁的状态并获取锁"><a href="#2-1-2-4-更新互斥锁的状态并获取锁" class="headerlink" title="2.1.2.4 更新互斥锁的状态并获取锁"></a>2.1.2.4 更新互斥锁的状态并获取锁</h5><p>计算了新的互斥锁状态之后，会使用 CAS 函数更新状态<br>如果没有通过 CAS 获得锁，会调用 <code>runtime.sync_runtime_SemacquireMutex</code> 通过信号量保证资源不会被两个 Goroutine 获取。<br><code>runtime.sync_runtime_SemacquireMutex</code> 会在方法中不断尝试获取锁并陷入休眠等待信号量的释放，一旦当前 Goroutine 可以获取信号量，它就会立刻返回，<code>sync.Mutex.Lock</code>的剩余代码也会继续执行。</p>
<ul>
<li>在正常模式下，这段代码会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环；</li>
<li>在饥饿模式下，当前 Goroutine 会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出；</li>
</ul>
<h3 id="2-2-解锁"><a href="#2-2-解锁" class="headerlink" title="2.2 解锁"></a>2.2 解锁</h3><h4 id="2-2-1-Fast-path"><a href="#2-2-1-Fast-path" class="headerlink" title="2.2.1 Fast path"></a>2.2.1 Fast path</h4><p>该过程会先使用<code>atomic.AddInt32函数快速解锁，这时会发生下面的两种情况：</code></p>
<ul>
<li>如果该函数返回的新状态等于 0，当前 Goroutine 就成功解锁了互斥锁；</li>
<li>如果该函数返回的新状态不等于 0，则进入 Slow path。<h4 id="2-2-2-Slow-path"><a href="#2-2-2-Slow-path" class="headerlink" title="2.2.2 Slow path"></a>2.2.2 Slow path</h4>先校验锁状态的<code>合法性</code> — 如果当前互斥锁已经被解锁过了会直接抛出异常 “sync: unlock of unlocked mutex” 中止当前程序。<br>在正常模式下，上述代码会使用如下所示的处理过程：</li>
<li>如果互斥锁不存在等待者或者互斥锁的 <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 状态不都为 0，那么当前方法可以直接返回，不需要唤醒其他等待者；</li>
<li>如果互斥锁存在等待者，会通过<code>runtime_Semrelease</code>唤醒等待者并移交锁的所有权；<br>在饥饿模式下，上述代码会直接调用<code>runtime_Semrelease</code>将当前锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁，在这时互斥锁还不会退出饥饿状态；</li>
</ul>
<h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p>互斥锁的<strong>加锁过程</strong>比较复杂，它涉及自旋、信号量以及调度等概念：</p>
<ul>
<li>如果互斥锁处于初始化状态，会通过置位 <code>mutexLocked</code> 加锁；</li>
<li>如果互斥锁处于 <code>mutexLocked</code> 状态并且在普通模式下工作，会进入自旋，执行 30 次 <code>PAUSE</code> 指令消耗 CPU 时间等待锁的释放；</li>
<li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li>
<li>互斥锁在正常情况下会通过<code>sync_runtime_SemacquireMutex</code>将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；</li>
<li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式；</li>
</ul>
<p>互斥锁的<strong>解锁过程</strong>与之相比就比较简单：</p>
<ul>
<li>当互斥锁已经被解锁时，调用 Mutex.Lock 会直接抛出异常；</li>
<li>当互斥锁处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 <code>mutexLocked</code> 标志位；</li>
<li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，会直接返回；在其他情况下会通过<code>sync.runtime_Semrelease</code> 唤醒对应的 Goroutine；</li>
</ul>
<h2 id="4-Sync-RWMutex"><a href="#4-Sync-RWMutex" class="headerlink" title="4 Sync.RWMutex"></a>4 Sync.RWMutex</h2><blockquote>
<p>从逻辑上，可以把 RWMutex 理解为一把读锁加一把写锁；<br>写锁具有<code>严格的排他性</code>，当其被占用，其他试图取写锁或者读锁的 goroutine 均阻塞；<br>读锁具有<code>有限的共享性</code>，当其被占用，试图取写锁的 goroutine 会阻塞，试图取读锁的 goroutine 可与当前 goroutine 共享读锁；<br>RWMutex 适用于<code>读多写少</code>的场景，最理想化的情况，当所有操作均使用读锁，则可实现无锁化；最悲观的情况，倘若所有操作均使用写锁，则 RWMutex 退化为普通的 Mutex.</p>
</blockquote>
<h3 id="4-1-数据结构"><a href="#4-1-数据结构" class="headerlink" title="4.1 数据结构"></a>4.1 数据结构</h3><p>![[Pasted image 20230901163649.png]]<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span>   <span class="comment">// 共享读锁的 goroutine 数量上限，值为 2^29；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w           Mutex  <span class="comment">// 内置的一把普通互斥锁 sync.Mutex；</span></span><br><span class="line">    writerSem   <span class="type">uint32</span> <span class="comment">// 关联写锁阻塞队列的信号量；</span></span><br><span class="line">    readerSem   <span class="type">uint32</span> <span class="comment">// 关联读锁阻塞队列的信号量；</span></span><br><span class="line">    readerCount <span class="type">int32</span>  <span class="comment">// 正常情况下等于介入读锁流程的 goroutine 数量；当 goroutine 接入写锁流程时，该值为实际介入读锁流程的 goroutine 数量减 rwmutexMaxReaders.</span></span><br><span class="line">    readerWait  <span class="type">int32</span>  <span class="comment">// 记录在当前 goroutine 获取写锁前，还需要等待多少个 goroutine 释放读锁.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-2-读锁流程"><a href="#4-2-读锁流程" class="headerlink" title="4.2 读锁流程"></a>4.2 读锁流程</h3><h4 id="4-2-1-RLock"><a href="#4-2-1-RLock" class="headerlink" title="4.2.1 RLock"></a>4.2.1 RLock</h4><p>• 基于原子操作，将 RWMutex 的 readCount 变量加一，表示占用或等待读锁的 goroutine 数加一；<br>• 倘若 RWMutex.readCount 的新值仍小于 0，说明有 goroutine 未释放写锁，因此将当前 goroutine 添加到读锁的阻塞队列中并阻塞挂起.</p>
<h4 id="4-2-2-RUnlock"><a href="#4-2-2-RUnlock" class="headerlink" title="4.2.2 RUnlock"></a>4.2.2 RUnlock</h4><p>• 基于原子操作，将 RWMutex 的 readCount 变量加一，表示占用或等待读锁的 goroutine 数减一；<br>• 倘若 RWMutex.readCount 的新值小于 0，说明有 goroutine 在等待获取写锁，则走入 RWMutex.rUnlockSlow 的流程中.</p>
<h4 id="4-2-3-rUnlockSlow"><a href="#4-2-3-rUnlockSlow" class="headerlink" title="4.2.3 rUnlockSlow"></a>4.2.3 rUnlockSlow</h4><p>• 对 RWMutex.readerCount 进行校验，倘若发现当前协程此前未抢占过读锁，或者介入读锁流程的 goroutine 数量达到上限，则抛出 fatal；<br>(倘若 r+1 == -rwmutexMaxReaders，说明此时有 goroutine 介入写锁流程，但当前此前未加过读锁，具体原因见 2.3 小节；倘若 r+1=0，则要么此前未加过读锁，要么介入读锁流程的 goroutine 数量达到上限</p>
<p>• 基于原子操作，对 RWMutex.readerWait 进行减一操作，倘若其新值为 0，说明当前 goroutine 是最后一个介入读锁流程的协程，因此需要唤醒一个等待写锁的阻塞队列的 goroutine.（综合 RWMutex.readerCount 为负值，可以确定存在等待写锁的 goroutine，具体原因见 2.3 小节.）</p>
<h3 id="4-3-写锁流程"><a href="#4-3-写锁流程" class="headerlink" title="4.3 写锁流程"></a>4.3 写锁流程</h3><h4 id="4-3-1-Lock"><a href="#4-3-1-Lock" class="headerlink" title="4.3.1 Lock"></a>4.3.1 Lock</h4><p>• 对 RWMutex 内置的互斥锁进行加锁操作；<br>• 基于原子操作，对 RWMutex.readerCount 进行减少 -rwmutexMaxReaders 的操作；<br>• 倘若此时存在未释放读锁的 gouroutine，则基于原子操作在 RWMutex.readerWait 的基础上加上介入读锁流程的 goroutine 数量，并将当前 goroutine 添加到写锁的阻塞队列中挂起.</p>
<h4 id="4-3-2-Unlock"><a href="#4-3-2-Unlock" class="headerlink" title="4.3.2 Unlock"></a>4.3.2 Unlock</h4><p>• 基于原子操作，将 RWMutex.readerCount 的值加上 rwmutexMaxReaders；<br>• 倘若发现 RWMutex.readerCount 的新值大于 rwmutexMaxReaders，则说明要么当前 RWMutex 未上过写锁，要么介入读锁流程的 goroutine 数量已经超限，因此直接抛出 fatal；<br>• 因此唤醒读锁阻塞队列中的所有 goroutine；(可见，竞争读锁的 goroutine 更具备优势)<br>• 解开 RWMutex 内置的互斥锁.</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2023/10/09/Algorithm/%E8%B7%B3%E8%A1%A8/"></a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2023-10-09
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">![图片](file:///Users/caotianlong/Documents/%E5%88%B7%E9%A2%98/%E7%83%AD%E9%97%A8%E5%AE%9E%E7%8E%B0/img/640-20230911011754301.png?lastModify=1694370430)</span><br><span class="line"></span><br><span class="line">## 1 核心性质</span><br><span class="line"></span><br><span class="line">- 跳表由多层索引结构组成</span><br><span class="line">- 每次节点个数接近于相邻下层节点数的一半</span><br><span class="line">- 对于一个 m 层存在的节点，在 1~m-1层中这个节点也一定存在</span><br><span class="line">- 为保证连贯性，跳表额外补充了本身不存储数据的头节点和尾节点，作为起点和终点</span><br><span class="line">- 头节点和尾节点的高度是动态扩缩的，其高度取决于当前跳表内数据节点的最大高度</span><br><span class="line">- 跳表的”跳“字体现在，在高层检索时，每跳过一个节点，实际上都过滤跳过了底层的大量数据，从而实现检索加速</span><br><span class="line">## 2 数据结构定义</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line"> // 跳表的数据结构 Skiplist  </span><br><span class="line"> type Skiplist struct &#123;  </span><br><span class="line">     head *node  </span><br><span class="line"> &#125;  </span><br><span class="line"> // 节点定义  </span><br><span class="line"> type node struct &#123;  </span><br><span class="line">     // 长度为当前节点的高度  </span><br><span class="line">     nexts    []*node  </span><br><span class="line">     key, val int  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-读流程"><a href="#3-读流程" class="headerlink" title="3 读流程"></a>3 读流程</h2><ul>
<li>以 head 节点作为起点</li>
<li>从当前跳表存在的最大高度出发</li>
<li>倘若右侧节点 key 值小于 target，则持续向右遍历</li>
<li>倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回</li>
<li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li>
<li>重复（3）-（5）步</li>
<li>倘若已经抵达第1层仍然找到不到 target，则返回 key 不存在的信息</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 根据 key 读取 val，第二个 bool flag 反映 key 在 skiplist 中是否存在  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Get(key <span class="type">int</span>) (<span class="type">int</span>, <span class="type">bool</span>) &#123;  </span><br><span class="line">     <span class="comment">// 根据 key 尝试检索对应的 node，如果 node 存在，则返回对应的 val  </span></span><br><span class="line">     <span class="keyword">if</span> _node := s.search(key); _node != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> _node.val, <span class="literal">true</span>  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">false</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 从跳表中检索 key 对应的 node  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> search(key <span class="type">int</span>) *node &#123;  </span><br><span class="line">     <span class="comment">// 每次检索从头部出发  </span></span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="comment">// 每次检索从最大高度出发，直到来到首层  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="comment">// 在每一层中持续向右遍历，直到下一个节点不存在或者 key 值大于等于 key  </span></span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; key &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 如果 key 值相等，则找到了目标直接返回  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key == key &#123;  </span><br><span class="line">             <span class="keyword">return</span> move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 当前层没找到目标，则层数减 1，继续向下  </span></span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">// 遍历完所有层数，都没有找到目标，返回 nil  </span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-写流程"><a href="#4-写流程" class="headerlink" title="4 写流程"></a>4 写流程</h2><ul>
<li>首先基于读流程检索出 key 对应的节点是否存在，倘若存在，则对值进行更新并直接返回</li>
<li>随机出新插入节点的高度；倘若新插入节点的高度大于当前跳表的最大高度，则需要对起点和终点的高度进行扩容</li>
<li>以 head 节点作为起点，从当前跳表存在的最大高度出发</li>
<li>倘若右侧节点 key 值小于 target，则持续向右遍历</li>
<li>倘若右侧节点为终点（nil）或者 key 值大于 target，则在该空隙插入新节点，并降低高度进入下一层</li>
<li>重复（4）-（5）步</li>
<li>倘若已经进入第 1 层，插入新节点后即可返回<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> (<span class="string">&quot;math/rand&quot;</span>)  </span><br><span class="line"> roll 骰子，决定一个待插入的新节点在 skiplist 中最高层对应的 index  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> roll() <span class="type">int</span> &#123;  </span><br><span class="line">     <span class="keyword">var</span> level <span class="type">int</span>  </span><br><span class="line">     <span class="comment">// 每次投出 1，则层数加 1  </span></span><br><span class="line">     <span class="keyword">for</span> rand.Int() &gt; <span class="number">0</span> &#123;  </span><br><span class="line">         level++  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> level  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 将 key-val 对加入 skiplist  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Put(key, val <span class="type">int</span>) &#123;  </span><br><span class="line">     <span class="comment">// 假如 kv对已存在，则直接对值进行更新并返回  </span></span><br><span class="line">     <span class="keyword">if</span> _node := s.search(key); _node != <span class="literal">nil</span> &#123;  </span><br><span class="line">         _node.val = val  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// roll 出新节点的高度  </span></span><br><span class="line">     level := s.roll()  </span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 新节点高度超出跳表最大高度，则需要对高度进行补齐  </span></span><br><span class="line">     <span class="keyword">for</span> <span class="built_in">len</span>(s.head.nexts)<span class="number">-1</span> &lt; level &#123;  </span><br><span class="line">         s.head.nexts = <span class="built_in">append</span>(s.head.nexts, <span class="literal">nil</span>)  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 创建出新的节点  </span></span><br><span class="line">     newNode := node&#123;  </span><br><span class="line">         key:   key,  </span><br><span class="line">         val:   val,  </span><br><span class="line">         nexts: <span class="built_in">make</span>([]*node, level+<span class="number">1</span>),  </span><br><span class="line">     &#125;  </span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 从头节点的最高层出发  </span></span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="keyword">for</span> level := level; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="comment">// 向右遍历，直到右侧节点不存在或者 key 值大于 key  </span></span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; key &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 调整指针关系，完成新节点的插入  </span></span><br><span class="line">         newNode.nexts[level] = move.nexts[level]  </span><br><span class="line">         move.nexts[level] = &amp;newNode  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="删流程"><a href="#删流程" class="headerlink" title="删流程"></a>删流程</h2><ul>
<li>以 head 节点作为起点，从当前跳表存在的最大高度出发</li>
<li>倘若右侧节点 key 值小于 target，则持续向右遍历</li>
<li>倘若右侧节点为终点（nil）或者 key 值大于 target，则在该空隙插入新节点，并降低高度进入下一层</li>
<li>倘若右侧节点 key 值等于 target，则代表找到目标</li>
<li>找到目标值后，沿当前节点层层向下，依次将每层中的目标节点删除</li>
<li>倘若已经进入第 1 层仍然没有找到节点，说明节点不存在，删除失败</li>
<li><p>倘若删除成功，需要尝试对跳表的整体高度进行缩容，即需要对高度递减，直到确定最大高度对应的层数上至少存在一个有效的数据节点为止</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 key 从跳表中删除对应的节点  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Del(key <span class="type">int</span>) &#123;  </span><br><span class="line">     <span class="comment">// 如果 kv 对不存在，则无需删除直接返回  </span></span><br><span class="line">     <span class="keyword">if</span> _node := s.search(key); _node == <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 从头节点的最高层出发      </span></span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="comment">// 向右遍历，直到右侧节点不存在或者 key 值大于等于 key  </span></span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; key &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">           </span><br><span class="line">         <span class="comment">// 右侧节点不存在或者 key 值大于 target，则直接跳过  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] == <span class="literal">nil</span> || move.nexts[level].key &gt; key&#123;  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">         &#125;      </span><br><span class="line">         <span class="comment">// 走到此处意味着右侧节点的 key 值必然等于 key，则调整指针引用  </span></span><br><span class="line">         move.nexts[level] = move.nexts[level].nexts[level]  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 对跳表的最大高度进行更新  </span></span><br><span class="line">     <span class="keyword">var</span> dif <span class="type">int</span>  </span><br><span class="line">     <span class="comment">// 倘若某一层已经不存在数据节点，高度需要递减  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt; <span class="number">0</span> &amp;&amp; s.head.nexts[level] == <span class="literal">nil</span>; level-- &#123;  </span><br><span class="line">         dif++  </span><br><span class="line">     &#125;  </span><br><span class="line">     s.head.nexts = s.head.nexts[:<span class="built_in">len</span>(s.head.nexts)-dif]  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-RANGE-流程"><a href="#5-RANGE-流程" class="headerlink" title="5 RANGE 流程"></a>5 RANGE 流程</h2></li>
<li>以 head 节点作为起点</li>
<li>从当前跳表存在的最大高度出发</li>
<li>倘若右侧节点 key 值小于 target，则持续向右遍历</li>
<li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li>
<li>倘若右侧节点 key 值等于 target，则代表找到目标，直接沿该节点向下来到第1层</li>
<li><p>重复（3）-（5）步，直到来到第1层，接下来从首个大于等于 target 的节点出发，向右依次遍历，直到取满 range 区间的数据后返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到 skiplist 当中 ≥ start，且 ≤ end 的 kv 对  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Range(start, end <span class="type">int</span>) [][<span class="number">2</span>]<span class="type">int</span> &#123;  </span><br><span class="line">     <span class="comment">// 首先通过 ceiling 方法，找到 skiplist 中 key 值大于等于 start 且最接近于 start 的节点 ceilNode  </span></span><br><span class="line">     ceilNode := s.ceiling(start)  </span><br><span class="line">     <span class="comment">// 如果不存在，直接返回  </span></span><br><span class="line">     <span class="keyword">if</span> ceilNode == <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> [][<span class="number">2</span>]<span class="type">int</span>&#123;&#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 从 ceilNode 首层出发向右遍历，把所有位于 [start,end] 区间内的节点统统返回  </span></span><br><span class="line">     <span class="keyword">var</span> res [][<span class="number">2</span>]<span class="type">int</span>  </span><br><span class="line">     <span class="keyword">for</span> move := ceilNode; move != <span class="literal">nil</span> &amp;&amp; move.key &lt;= end; move = move.nexts[<span class="number">0</span>] &#123;  </span><br><span class="line">         res = <span class="built_in">append</span>(res, [<span class="number">2</span>]<span class="type">int</span>&#123;move.key, move.val&#125;)  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> res  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 找到 key 值大于等于 target 且 key 值最接近于 target 的节点  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> ceiling(target <span class="type">int</span>) *node &#123;  </span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="comment">// 自上而下，找到 key 值小于 target 且最接近 target 的 kv 对  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; target &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 如果 key 值等于 targe 的 kv 对存在，则直接返回  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key == target &#123;  </span><br><span class="line">             <span class="keyword">return</span> move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">// 此时 move 已经对应于在首层 key 值小于 key 且最接近于 key 的节点，其右侧第一个节点即为所寻找的目标节点  </span></span><br><span class="line">     <span class="keyword">return</span> move.nexts[<span class="number">0</span>]  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="CEILING-流程"><a href="#CEILING-流程" class="headerlink" title="CEILING 流程"></a>CEILING 流程</h2><ul>
<li>以 head 节点作为起点</li>
<li>从当前跳表存在的最大高度出发</li>
<li>倘若右侧节点 key 值小于 target，则持续向右遍历</li>
<li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li>
<li>倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回</li>
<li>重复（3）-（5）步，直到找到 key 值等于 target 的节点或者来到第1层，接下来获取到首个大于等于 target 的节点并返回</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 找到 skiplist 中，key 值大于等于 target 且最接近于 target 的 key-value 对  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Ceiling(target <span class="type">int</span>) ([<span class="number">2</span>]<span class="type">int</span>, <span class="type">bool</span>) &#123;  </span><br><span class="line">     <span class="keyword">if</span> ceilNode := s.ceiling(target); ceilNode != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;ceilNode.key, ceilNode.val&#125;, <span class="literal">true</span>  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;&#125;, <span class="literal">false</span>  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>
<p> ​</p>
<h2 id="6-FLOOR-流程"><a href="#6-FLOOR-流程" class="headerlink" title="6 FLOOR 流程"></a>6 FLOOR 流程</h2><ul>
<li>以 head 节点作为起点</li>
<li>从当前跳表存在的最大高度出发</li>
<li>倘若右侧节点 key 值小于 target，则持续向右遍历</li>
<li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li>
<li>倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回</li>
<li><p>重复（3）-（5）步，直到找到 key 值等于 target 的节点或者来到第1层，接下来获取到首个小于等于 target 的节点并返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到 skiplist 中，key 值小于等于 target 且最接近于 target 的 key-value 对  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Floor(target <span class="type">int</span>) ([<span class="number">2</span>]<span class="type">int</span>, <span class="type">bool</span>) &#123;  </span><br><span class="line">     <span class="comment">// 引用 floor 方法，取 floorNode 值进行返回  </span></span><br><span class="line">     <span class="keyword">if</span> floorNode := s.floor(target); floorNode != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;floorNode.key, floorNode.val&#125;, <span class="literal">true</span>  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;&#125;, <span class="literal">false</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 找到 key 值小于等于 target 且 key 值最接近于 target 的节点  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> floor(target <span class="type">int</span>) *node &#123;  </span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="comment">// 自上而下，找到 key 值小于 target 且最接近 target 的 kv 对  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; target &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 如果 key 值等于 targe 的 kv对存在，则直接返回  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key == target &#123;  </span><br><span class="line">             <span class="keyword">return</span> move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// move 是首层中 key 值小于 target 且最接近 target 的节点，直接返回 move 即可  </span></span><br><span class="line">     <span class="keyword">return</span> move  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>
<p>​<br>​</p>
</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2023/10/09/Basic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"></a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2023-10-09
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="1-网络模型与协议"><a href="#1-网络模型与协议" class="headerlink" title="1 网络模型与协议"></a>1 网络模型与协议</h2><h3 id="1-1-网络模型分层解析"><a href="#1-1-网络模型分层解析" class="headerlink" title="1.1 网络模型分层解析"></a>1.1 网络模型分层解析</h3><ul>
<li><code>OSI七层模型</code>：应用（DNS，HTTP，SMTP，FTP）， 表示 ，会话，传输（TCP、UDP），网络（IP ICMP），数据链路，物理</li>
<li><code>TCP/IP</code>：<ul>
<li><code>应用层</code>：工作在用户态，往下都在内核态；主要协议有：HTTP、FTP、Telnet、DNS、SMTP等</li>
<li><code>传输层</code>：为用层提供网络支持；主要协议有 TCP&amp;UDP，加上 TCP 头部</li>
<li><code>网络层</code>：实现实际的传输功能；主要协议有 IP 协议，加上 IP 头部</li>
<li><code>网络接口层</code>：链路级别， IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上<h3 id="1-2-常见协议报文格式"><a href="#1-2-常见协议报文格式" class="headerlink" title="1.2 常见协议报文格式"></a>1.2 常见协议报文格式</h3></li>
</ul>
</li>
<li><code>TCP首部格式</code>（源/目标端口号; 序列号(随机数,避免乱序); 确认号(避免丢包); 首部长度; 关键字; 窗口; 校验和）</li>
<li><code>UDP</code>（端口号 长度 校验和） 包 最大为64k</li>
<li><code>IP报文</code>（版本 首部长度 服务类型 总长度 生存时间 校验和 ip地址</li>
<li><code>TCP</code>：TCP<code>最大报文段长度</code>（MSS，536字节），超过就分块（TCP Segment） IP：加上IP头成为IP报文，如果超过<code>MTU</code>（1500字节）就分片</li>
</ul>
<h2 id="2-HTTP-amp-HTTPS"><a href="#2-HTTP-amp-HTTPS" class="headerlink" title="2 HTTP &amp; HTTPS"></a>2 HTTP &amp; HTTPS</h2><h3 id="2-1-HTTP"><a href="#2-1-HTTP" class="headerlink" title="2.1 HTTP"></a>2.1 HTTP</h3><h4 id="2-1-1-HTTP-基本概念"><a href="#2-1-1-HTTP-基本概念" class="headerlink" title="2.1.1 HTTP 基本概念"></a>2.1.1 HTTP 基本概念</h4><h5 id="2-1-1-1-HTTP-是什么？"><a href="#2-1-1-1-HTTP-是什么？" class="headerlink" title="2.1.1.1 HTTP 是什么？"></a>2.1.1.1 HTTP 是什么？</h5><p>超文本传输协议</p>
<h5 id="2-1-1-2-HTTP-常见状态码"><a href="#2-1-1-2-HTTP-常见状态码" class="headerlink" title="2.1.1.2 HTTP 常见状态码"></a>2.1.1.2 HTTP 常见状态码</h5><ul>
<li>1xx：<strong>指示信息</strong>—表示请求已接收，继续处理；</li>
<li>2xx：<strong>成功</strong>—表示请求已被成功接收、理解、接受；200—OK 204—请求收到，但返回信息为空 206—服务器已经完成了部分用户的GET请求</li>
<li>3xx：<strong>重定向</strong>—信息不完整需要进一步补充；300 请求资源在多处可得到。301—永久重定向，隐式重定向。302 临时重定向，显示重定向。 304—请求的资源没有改变，可以使用缓存。</li>
<li>4xx：<strong>客户端错误</strong>—请求有语法错误或请求无法实现； 401—-未授权 403—禁止访问。 404 –找不到。409：对当前资源状态，请求不能完成</li>
<li>5xx：<strong>服务器端错误</strong>—服务器未能实现合法的请求；500内部服务器错误，501未实现，502网关错误，503服务不可用，504 网关超时<h5 id="2-1-1-3-HTTP-常见字段"><a href="#2-1-1-3-HTTP-常见字段" class="headerlink" title="2.1.1.3 HTTP 常见字段"></a>2.1.1.3 HTTP 常见字段</h5></li>
<li><em>Host</em> 字段：指定服务器域名</li>
<li><em>Content-Length 字段</em>：表明本次回应的数据长度</li>
<li><em>Connection 字段</em>：要求服务器使用「HTTP 长连接」机制，Keep-Alive</li>
<li><em>Content-Type 字段</em>：本次数据格式</li>
<li><em>Content-Encoding 字段</em>：数据的压缩方法<h4 id="2-1-2-GET-和-POST-有什么区别"><a href="#2-1-2-GET-和-POST-有什么区别" class="headerlink" title="2.1.2 GET 和 POST 有什么区别"></a>2.1.2 GET 和 POST 有什么区别</h4></li>
<li><code>RFC 规范</code>：GET 的语义是从服务器 <em>获取指定的资源</em>；POST 的语义是根据请求负荷（报文body）对 <em>指定的资源做出处理</em></li>
<li>GET 方法是安全、幂等、可被缓存的</li>
<li>POST 不安全，不幂等，（大部分实现）不可缓存<h4 id="2-1-3-HTTP缓存技术"><a href="#2-1-3-HTTP缓存技术" class="headerlink" title="2.1.3 HTTP缓存技术"></a>2.1.3 HTTP缓存技术</h4></li>
<li><code>强制缓存</code>：Cache-Control 和 Expires 控制资源在客户端的缓存有效期</li>
<li><code>协商缓存</code>：<em>Last-Modified</em> 资源没修改，响应 HTTP 304 走缓存 ; <em>ETag</em>,判断资源有没有变化<h4 id="2-1-4-HTTP特性"><a href="#2-1-4-HTTP特性" class="headerlink" title="2.1.4 HTTP特性"></a>2.1.4 HTTP特性</h4></li>
<li>优点：简单，灵活容易拓展，跨平台</li>
<li>缺点：明文传输，无状态，不安全</li>
<li>性能：<em>长连接</em>；<em>管道网络传输</em>：当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」<h3 id="2-2-HTTPS"><a href="#2-2-HTTPS" class="headerlink" title="2.2 HTTPS"></a>2.2 HTTPS</h3><h4 id="2-2-1-HTTPS-的区别"><a href="#2-2-1-HTTPS-的区别" class="headerlink" title="2.2.1 HTTPS 的区别"></a>2.2.1 HTTPS 的区别</h4></li>
<li><code>加密传输</code>：在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议<ul>
<li>混合加密：<strong>对称加密</strong>和<strong>非对称加密</strong>结合，非对称加密交换会话秘钥</li>
<li><em>摘要算法 + 数字签名</em>：计算内容的指纹</li>
</ul>
</li>
<li><code>连接建立</code>：需进行 SSL/TLS 的握手过程<ul>
<li>基于 RSA 的 TLS 握手过程<ul>
<li><em>ClientHello</em>：客户端发起加密通信请求，发送（一个随机数，TLS 版本，加密算法）给服务器</li>
<li><em>SeverHello</em>：服务端回应，发送随机数和数字证书</li>
<li><em>客户端回应</em>：取出公钥加密报文，再发送随机数过去，握手介绍，生成摘要</li>
<li><em>服务器的最后回应</em>： 计算出本次通话的会话秘钥，变更加密通信算法</li>
</ul>
</li>
</ul>
</li>
<li><code>默认端口</code>：HTTP 默认端口号是 <code>80</code>，HTTPS 默认端口号是 <code>443</code></li>
<li><code>可信身份</code>：向 CA（证书权威机构）申请数字证书<ul>
<li>把公钥注册到 CA，客户端拿到<code>数字证书</code>（公钥+数字签名）后用 CA 的公钥验证<h4 id="2-2-2-HTTPS-怎么保证数据完整性"><a href="#2-2-2-HTTPS-怎么保证数据完整性" class="headerlink" title="2.2.2 HTTPS 怎么保证数据完整性"></a>2.2.2 HTTPS 怎么保证数据完整性</h4></li>
</ul>
</li>
<li>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</li>
<li>TLS 握手协议负责协商加密算法和生成对称密钥</li>
<li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源<ul>
<li>消息被分割成多个较短的片段,然后分别对每个片段进行压缩</li>
<li><strong>加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证</strong>。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</li>
<li>经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。</li>
<li>经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li>
</ul>
</li>
</ul>
<h4 id="2-2-3-HTTPS-一定安全吗"><a href="#2-2-3-HTTPS-一定安全吗" class="headerlink" title="2.2.3 HTTPS 一定安全吗"></a>2.2.3 HTTPS 一定安全吗</h4><ul>
<li>中间人攻击：客户端接受了中间人服务器的证书，然后中间人分别和客户端服务器 TLS 握手并转发。</li>
<li>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。</li>
<li>抓包：使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。<h3 id="2-3-HTTP-1-1-amp-2-0-amp-3-0-演变"><a href="#2-3-HTTP-1-1-amp-2-0-amp-3-0-演变" class="headerlink" title="2.3 HTTP 1.1&amp;2.0 &amp; 3.0 演变"></a>2.3 HTTP 1.1&amp;2.0 &amp; 3.0 演变</h3><h4 id="2-3-1-HTTP-1-1-相比-HTTP-1-0"><a href="#2-3-1-HTTP-1-1-相比-HTTP-1-0" class="headerlink" title="2.3.1 HTTP/1.1 相比 HTTP/1.0"></a>2.3.1 HTTP/1.1 相比 HTTP/1.0</h4></li>
<li>优点：<ul>
<li>使用<code>长连接</code>的方式改善了 HTTP/1.0 短连接造成的性能开销。</li>
<li>支持管道（pipeline）网络传输</li>
</ul>
</li>
<li>缺点：<ul>
<li>请求 / 响应头部（Header）没压缩，造成浪费</li>
<li>队头阻塞</li>
<li>没有请求优先级控制</li>
<li>服务器只能被动响应<h4 id="2-3-2-HTTP-2-优化"><a href="#2-3-2-HTTP-2-优化" class="headerlink" title="2.3.2 HTTP/2 优化"></a>2.3.2 HTTP/2 优化</h4></li>
</ul>
</li>
<li><em>头部压缩</em>：消除重复的部分,HPACK算法维护头信息表和字段的映射</li>
<li><em>二进制格式</em>：头信息和数据体都是二进制，并且统称为帧（frame）</li>
<li><em>并发传输</em>：引入了 Stream，针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，可以并行交错地发送请求和响应</li>
<li><em>服务器推送</em>：<strong>双方都可以建立 Stream</strong>，服务器可以主动向客户端发送消息</li>
<li>问题：基于 TCP 传输数据，需要按序到达缓冲区才能从内核取数据，一旦丢包就会阻塞所有请求这就是 HTTP/2 <code>队头阻塞</code>问题。<h4 id="2-3-3-HTTP-3-优化"><a href="#2-3-3-HTTP-3-优化" class="headerlink" title="2.3.3 HTTP/3 优化"></a>2.3.3 HTTP/3 优化</h4></li>
<li><strong>把 HTTP 下层的 TCP 协议改成了 UDP</strong></li>
<li>基于 UDP 的 <strong>QUIC 协议</strong>实现可靠传输：就是把 TCP 的校验放到应用层实现</li>
</ul>
<h3 id="2-4-HTTP-amp-RPC"><a href="#2-4-HTTP-amp-RPC" class="headerlink" title="2.4 HTTP &amp; RPC"></a>2.4 HTTP &amp; RPC</h3><ul>
<li>TCP 的特点 <strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong><ul>
<li>没有消息边界，于是会加上信息头，以及包长度</li>
<li>需要协议约定消息体格式</li>
</ul>
</li>
<li>服务发现：HTTP 只要知道网址就可以 DNS 解析出 IP 地址和 80 端口；RPC 需要之间服务</li>
<li>传输的内容：RPC 定制化程度高，序列化协议多，性能稍好</li>
<li><code>gRPC</code> 底层都直接用的 <code>HTTP/2</code></li>
<li>HTTP/2 是 2015 年出来的，有惯性<h2 id="3-TCP-amp-UDP"><a href="#3-TCP-amp-UDP" class="headerlink" title="3 TCP &amp; UDP"></a>3 TCP &amp; UDP</h2><h3 id="3-1-简介与区别"><a href="#3-1-简介与区别" class="headerlink" title="3.1 简介与区别"></a>3.1 简介与区别</h3></li>
<li>TCP 头部<ul>
<li>![[Pasted image 20230904012336.png]]</li>
<li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li>
<li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li>
</ul>
</li>
<li><code>为什么需要 TCP</code>？ IP 层不可靠，需要传输层确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></li>
<li><code>什么是 TCP</code>：<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</li>
<li><p>什么是 TCP 连接？用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 <code>Socket、序列号和窗口大小</code>称为连接。</p>
<ul>
<li>连接数量限制：文件描述符限制，内存限制，单机最大 TCP 连接数，约为 <code>2</code> 的 <code>48</code> 次方</li>
</ul>
</li>
<li><p><code>UDP 和 TCP 有什么区别呢？分别的应用场景是？</code></p>
<ul>
<li><em>连接</em>：UDP 不需要连接，即刻传输数据</li>
<li><em>服务对象</em>：TCP 是一对一的两点服务；UDP 支持一对一、一对多、多对多的交互通信</li>
<li><em>可靠性</em>：UDP 尽最大努力交付，不保证可靠交付数据</li>
<li><em>拥塞控制、流量控制</em>：网络拥堵也不影响 UDP 发送速率</li>
<li><em>传输方式</em>：TCP 是流式传输，没有边界；UDP 是一个包一个包的发送</li>
<li><em>分片不同</em>：TCP 大于 MSS(536字节) 在传输层分片；UDP 大于 MTU(1500字节)在 IP 层分片</li>
<li><em>使用场景</em>：TCP 用于文件传输，HTTP 等；UDP 用于视频，广播，<code>DNS</code> 等</li>
</ul>
</li>
<li><code>有一方突然断电或者崩溃</code><ul>
<li>两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。</li>
<li>服务端是<strong>无法感知到的</strong>，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，<strong>服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态</strong>，直到服务端重启进程。</li>
<li>所以，我们可以得知一个点，在没有使用 TCP 保活机制且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED 状态，并不代表另一方的连接还一定正常。</li>
<li><strong>在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手</strong>。所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</li>
<li>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li>
<li>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li>
<li><code>在客户端主机宕机后</code>，服务端向客户端发送的报文会得不到任何的响应，在一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的报文。<ul>
<li>服务端重传报文的过程中，客户端主机重启完成后，客户端的内核就会接收重传的报文，然后根据报文的信息传递给对应的进程：</li>
<li>如果客户端主机上<strong>没有</strong>进程监听该 TCP 报文的目标端口号，那么客户端内核就会<em>*回复 RST 报文，重置该 TCP 连接</em>；</li>
<li>如果客户端主机上<strong>有</strong>进程监听该 TCP 报文的目标端口号，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会<strong>回复 RST 报文，重置该 TCP 连接</strong>。</li>
<li>所以，只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接。<h3 id="3-2-TCP"><a href="#3-2-TCP" class="headerlink" title="3.2 TCP"></a>3.2 TCP</h3><h4 id="3-2-1-如何保证可靠？"><a href="#3-2-1-如何保证可靠？" class="headerlink" title="3.2.1 如何保证可靠？"></a>3.2.1 如何保证可靠？</h4><h4 id="3-2-2-三次握手"><a href="#3-2-2-三次握手" class="headerlink" title="3.2.2 三次握手"></a>3.2.2 三次握手</h4></li>
</ul>
</li>
</ul>
</li>
<li><em>目的</em>:<ul>
<li><code>防止旧的重复连接初始化造成混乱</code>：网络阻塞重发建立连接请求</li>
<li><code>同步双方的初始序列号</code></li>
<li><code>避免资源浪费</code>：避免建立冗余链接</li>
</ul>
</li>
<li><em>过程</em>：控制位: ACK(确认应答); RST(强制断开); SYN(建立连接); FIN(断开连接)<ul>
<li>建立连接时，客户端随机初始化序列号（<strong>client-isn</strong>），<strong>SYN 标志为1</strong>，表示 SYN 报文，发送到服务器，并进入<strong>SYN-SENT状态</strong>，等待服务器确认；</li>
<li>服务器收到SYN报文，也随机初始化自己的序列号（server-isn），填入序号，然后在<strong>确认应答号字段</strong>填入 <strong>client-isn+1</strong>，然后将<strong>SYN和ACK置为1</strong>，发送给客户端。此时服务器进入<strong>SYN_RECV状态</strong>；</li>
<li>客户端收到服务器报文后，向服务器回应最后一个应答报文，ACK=1，确认应答号填入server-isn+1，发送给服务端，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<strong>此次可以携带数据</strong></li>
<li><code>netstat -napt</code> 查看连接状态</li>
</ul>
</li>
<li><em>握手丢失</em>：<ul>
<li>第一次：客户端超时重传</li>
<li>第二次：服务端超时重传</li>
<li>第三次：服务端超时重传</li>
</ul>
</li>
<li><em>SYN 攻击</em>：<ul>
<li>Linux 内核会维护两个队列:半连接队列，全连接队列</li>
<li>SYN 攻击就是打满半连接队列</li>
<li>解决：<ul>
<li>调大 netdev_max_backlog，保存数据包的队列</li>
<li>增大 TCP 半连接队列</li>
<li>开启 tcp_syncookies，绕开 SYN 半连接建立连接</li>
<li>减少 SYN+ACK 重传次数，加快处于 SYN_REVC 状态的 TCP 连接断开<h4 id="3-2-3-四次挥手"><a href="#3-2-3-四次挥手" class="headerlink" title="3.2.3 四次挥手"></a>3.2.3 四次挥手</h4></li>
</ul>
</li>
</ul>
</li>
<li><em>目的</em>：客户端发送了FIN连接释放报文后，服务器加入close-wait状态，是为了<code>让服务器发送还未传送完毕的数据</code>，传送完毕之后，服务器会发送FIN连接释放报文;</li>
<li><em>过程</em>：<ul>
<li>客户端发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li>
<li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</li>
<li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li>
<li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li>
<li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li>
</ul>
</li>
<li><em>TIME_WAIT状态</em>： <ul>
<li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li>
<li>保证「被动关闭连接」的一方，能被正确的关闭；确保最后的 ACK 到达。</li>
<li>MSL：<strong>报文最大生存时间</strong>，2MSL是允许报文丢失一次</li>
<li>过多会占用系统资源和端口资源；复用<strong>TIME_WAIT</strong>的 socket；超过 18000 直接重置；让客户端去断开，承受<strong>TIME_WAIT</strong></li>
<li>出现大量TIME_WAIT状态？ 没有用长连接；长连接超时；<h4 id="3-2-4-重传机制"><a href="#3-2-4-重传机制" class="headerlink" title="3.2.4 重传机制"></a>3.2.4 重传机制</h4></li>
</ul>
</li>
<li>TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决</li>
<li><em>超时重传</em>：<ul>
<li>触发场景：数据包丢失，确认应答丢失</li>
<li>超时时间：RTO 略大于 RTT <code>包往返时间</code></li>
<li>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送</li>
</ul>
</li>
<li><em>快速重传</em>：<code>三次重复的 ACK</code> 触发，但是不知道要重传一个还是所有</li>
<li><em>SACK 方法</em>：<code>选择性确认</code>，将已收到的数据的信息发送给「发送方」</li>
<li><em>D-ACK</em>：Duplicate 使用了 SACK 来告诉「发送方」有哪些数据被<code>重复接收</code>了，可以知道是数据包丢了还是 ACK 包丢了<h4 id="3-2-5-滑动窗口"><a href="#3-2-5-滑动窗口" class="headerlink" title="3.2.5 滑动窗口"></a>3.2.5 滑动窗口</h4></li>
<li><em>窗口</em>：一个缓存空间，是无需等待确认应答，而可以继续发送数据的<code>最大值</code></li>
<li>TCP 报文中的 Windows 字段控制</li>
<li>四部分：发送已确认，发送未确认，未发生但是在处理范围内，未发送范围外<h4 id="3-2-6-流量控制"><a href="#3-2-6-流量控制" class="headerlink" title="3.2.6 流量控制"></a>3.2.6 流量控制</h4></li>
<li>让「发送方」根据「接收方」的<code>实际接收能力</code>控制发送的数据量，让接受方处理的过来</li>
<li><em>窗口关闭</em>：可能导致死锁。收到零窗口通知，就启动<code>持续计时器</code>，如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文。</li>
<li><em>糊涂窗口综合症</em>：接收方太忙，来不及处理，窗口越来越小<ul>
<li>接收方不通告小窗口：小于 MSS 或者 缓存空间/2 ，通告窗口为 0</li>
<li>发送方避免发送小数据：Nagle 算法，除非窗口够大且数据够多并且收到 ack，否则囤积数据<h4 id="3-2-7-拥塞控制"><a href="#3-2-7-拥塞控制" class="headerlink" title="3.2.7 拥塞控制"></a>3.2.7 拥塞控制</h4></li>
</ul>
</li>
<li>避免「发送方」的数据填满整个网络。发送方维护一个叫<code>拥塞窗口</code>（cwnd）的状态变量</li>
<li><em>慢开始与拥塞避免</em>：发送的最初执行<code>慢开始</code>，令cwnd=1，发送方只能发送一个报文段，当收到确认后，将cwnd<code>加倍</code>，设置一个<code>慢开始门限</code> ssthresh，当cwnd&gt;=ssthresh时进入<code>拥塞避免</code>，按照<code>线性</code>增长方式增加，线性增长达到<code>网络拥塞</code>时，则令ssthresh=cwnd/2，然后重新执行慢开始。</li>
<li><em>快重传与快恢复</em>：每次接收到报文段都对最后一个已收到的的有序报文段进行<code>确认</code>。在发送方，如果收到<code>三个重复确认</code>，那么可以知道下一个报文段丢失，此时执行快重传，<code>立即重传下一个报文段</code>。在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行<code>快恢复</code>，令ssthresh = cwnd/2，cwnd = ssthresh 。直接进入<code>拥塞避免</code>。<h4 id="3-2-8-拾遗"><a href="#3-2-8-拾遗" class="headerlink" title="3.2.8 拾遗"></a>3.2.8 拾遗</h4></li>
<li>查看 TCP 连接信息的命令？ <code>netstat -napt</code></li>
</ul>
<h2 id="4-IP协议"><a href="#4-IP协议" class="headerlink" title="4 IP协议"></a>4 IP协议</h2><h3 id="4-1-基本认识"><a href="#4-1-基本认识" class="headerlink" title="4.1 基本认识"></a>4.1 基本认识</h3><ul>
<li>处于第三层，也就是<strong>网络层</strong>：实现主机与主机之间的通信</li>
<li>DNS：解析 IP 地址</li>
<li>ARP：获取下一跳的 MAC 地址，通过广播 ARP 请求与 ARP 响应实现</li>
<li>ICMP：<strong>互联网控制报文协议</strong>，确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等<h3 id="4-2-Ping"><a href="#4-2-Ping" class="headerlink" title="4.2 Ping"></a>4.2 Ping</h3></li>
<li><em>工作原理</em>：基于 ICMP 协议工作<ul>
<li><strong>发送ICMP请求</strong>：Ping工具向目标主机发送一个ICMP请求数据包（通常是一个特殊的Echo请求），请求目标主机进行响应。</li>
<li><strong>目标主机响应</strong>：目标主机接收到ICMP请求后，会发送一个ICMP响应数据包（Echo响应）回给Ping工具。</li>
<li><strong>测量延迟</strong>：Ping工具在发送ICMP请求和接收ICMP响应之间测量时间，从而计算出往返时间（Round-Trip Time，RTT）。RTT表示数据从Ping工具发送到目标主机并返回所需的时间，用于衡量网络的延迟。</li>
<li><strong>报告结果</strong>：Ping工具会显示目标主机的IP地址、RTT和其他统计信息，以便用户可以了解网络连接的质量和性能。</li>
</ul>
</li>
<li>ping 127.0.0.1<ul>
<li><strong>127 开头的都属于回环地址</strong>：目标 IP 是回环地址是会选择本地网卡</li>
</ul>
</li>
<li>ping 0.0.0.0<ul>
<li>会失败，因为这是无效的目标地址</li>
</ul>
</li>
</ul>
<h2 id="5-DNS协议"><a href="#5-DNS协议" class="headerlink" title="5 DNS协议"></a>5 DNS协议</h2><ol>
<li>DNS 解析过程，端口号？<ol>
<li>客户端发出 DNS 请求到<code>本地 DNS 服务器</code></li>
<li><code>本地 DNS 服务器</code>如果没有对应的缓存，就去访问<code>根域名服务器</code></li>
<li>根域名返回网址对应的<code>顶级域名服务器</code>地址</li>
<li><code>本地 DNS 服务器</code>请求<code>顶级域名服务器</code>，获得<code>权威 DNS 服务器</code>的地址</li>
<li><code>本地 DNS 服务器</code>请求<code>权威 DNS 服务器</code>，获取 IP 地址</li>
<li>返回给客户端，客户端和目标建立连接</li>
</ol>
</li>
<li>DNS 使用什么传输层协议？<ol>
<li>多数情况下使用 UDP</li>
<li>响应的大小超过UDP数据包的<code>最大限制</code>和<code>进行区域传输</code>（Zone Transfer）时 使用 TCP</li>
</ol>
</li>
</ol>
<h2 id="6-拾遗"><a href="#6-拾遗" class="headerlink" title="6 拾遗"></a>6 拾遗</h2><h3 id="6-1-键入网址到网页显示，期间发生了什么？"><a href="#6-1-键入网址到网页显示，期间发生了什么？" class="headerlink" title="6.1 键入网址到网页显示，期间发生了什么？"></a>6.1 键入网址到网页显示，期间发生了什么？</h3><ol>
<li><code>解析 URL</code>：确定了 Web 服务器和文件名，生成 HTTP 请求</li>
<li><code>查询服务器域名对应的 IP 地址</code>：按照浏览器缓存，操作系统缓存和 hosts 的顺序查询，如果没有就去请求本地 DNS 服务器，进入 <code>DNS 解析流程</code></li>
<li>应用程序（浏览器）通过调用 Socket 库，来委托<code>协议栈</code>工作<ol>
<li>TCP 可靠传输   <code>三次握手</code></li>
<li>IP 远程定位，将数据封装成<strong>网络包</strong>发送给通信对象</li>
<li>MAC 两点传输，在 IP 头部的前面加上 <strong>MAC 头部</strong>，包含接收方和发送方的 MAC 地址等信息。</li>
</ol>
</li>
<li>出口<code>网卡</code>：在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong></li>
<li>交换机：<strong>根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>  <code>MAC 层</code></li>
<li>路由器：根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作</li>
<li>拆包，获取数据内容，交给浏览器渲染页面，然后<code>四次挥手</code>断开连接</li>
</ol>
<h3 id="6-2-TCP-报文头部"><a href="#6-2-TCP-报文头部" class="headerlink" title="6.2 TCP 报文头部"></a>6.2 TCP 报文头部</h3><p>![[Pasted image 20230903203817.png]]</p>
<ul>
<li>首先，<strong>源端口号</strong>和<strong>目标端口</strong>号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</li>
<li>接下来有包的<strong>序</strong>号，这个是为了解决包乱序的问题。</li>
<li>还有应该有的是<strong>确认号</strong>，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决丢包的问题。</li>
<li>接下来还有一些<strong>状态位</strong>。例如 <code>SYN</code> 是发起一个连接，<code>ACK</code> 是回复，<code>RST</code> 是重新连接，<code>FIN</code> 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</li>
<li>还有一个重要的就是<strong>窗口大小</strong>。TCP 要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。</li>
<li>除了做流量控制以外，TCP还会做<strong>拥塞控制</strong>，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。</li>
</ul>
<h3 id="6-3-网络报文图"><a href="#6-3-网络报文图" class="headerlink" title="6.3 网络报文图"></a>6.3 网络报文图</h3><p>![[Pasted image 20230903204154.png]]</p>
<h3 id="6-4-网络攻击"><a href="#6-4-网络攻击" class="headerlink" title="6.4 网络攻击"></a>6.4 网络攻击</h3><h4 id="6-4-1-CSRF攻击"><a href="#6-4-1-CSRF攻击" class="headerlink" title="6.4.1 CSRF攻击"></a>6.4.1 CSRF攻击</h4><ul>
<li>CSRF（Cross-Site Request Forgery，跨站请求伪造）攻击，利用了用户已经在某个网站上进行了<code>身份验证</code>的情况下，对用户在另一个网站上的操作进行<code>伪造请求</code>，以执行未经授权的操作。</li>
<li>防范：<ul>
<li><strong>使用HTTP-only Cookie</strong></li>
<li><strong>使用验证码</strong>：敏感操作输入验证码</li>
<li>限制敏感操作</li>
<li><strong>使用CSRF令牌</strong>：为了确保请求是合法的，服务器可以生成一个唯一的CSRF令牌，并将其嵌入到表单或请求中</li>
<li><strong>定期审查和更新安全策略</strong></li>
<li><strong>同源策略</strong>CORS：浏览器的同源策略要求网页只能从同一来源加载资源。通过使用同源策略，浏览器可以限制对不同网站的跨站请求，从而减少CSRF攻击的可能性。</li>
</ul>
</li>
</ul>
<h4 id="6-4-2-XSS攻击"><a href="#6-4-2-XSS攻击" class="headerlink" title="6.4.2 XSS攻击"></a>6.4.2 XSS攻击</h4><ul>
<li>XSS（Cross-Site Scripting，跨站脚本攻击），将恶意脚本注入到网页中，以便在受害者的浏览器上执行恶意代码。XSS攻击可能导致盗取用户的敏感信息、劫持用户会话、操纵网页内容等恶意行为。</li>
<li>防范：<ul>
<li><strong>输入验证和过滤</strong>：在应用程序接受用户输入时，对输入数据进行验证和过滤。确保只接受预期的输入，并拒绝包含恶意脚本的输入。这可以通过编码规范、白名单过滤和黑名单过滤来实现。</li>
<li><strong>转义输出</strong>：在将用户输入插入到HTML、JavaScript或其他上下文中时，确保对用户输入进行适当的转义。这可以防止浏览器将用户输入解释为可执行的脚本。</li>
<li><strong>CORS策略</strong>：使用CORS（Cross-Origin Resource Sharing，跨源资源共享）策略来限制其他域名的网页访问您的网页，从而减少恶意脚本的机会。</li>
<li><strong>HTTP头设置</strong>：设置HTTP头中的安全标头，如Content Security Policy（CSP）和X-XSS-Protection，以帮助阻止XSS攻击。</li>
</ul>
</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2023/10/09/Basic/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"></a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2023-10-09
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1-硬件结构"><a href="#1-硬件结构" class="headerlink" title="1 硬件结构"></a>1 硬件结构</h2><ul>
<li>什么是中断？<ul>
<li>中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。</li>
</ul>
</li>
<li>什么是软中断？<ul>
<li>为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」</li>
<li><strong>上半部直接处理硬件请求，也就是硬中断</strong>，主要是负责耗时短的工作，特点是快速执行；</li>
<li><strong>下半部是由内核触发，也就说软中断</strong>，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；</li>
</ul>
</li>
</ul>
<h2 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2 内存管理"></a>2 内存管理</h2><h3 id="2-1-虚拟内存"><a href="#2-1-虚拟内存" class="headerlink" title="2.1 虚拟内存"></a>2.1 虚拟内存</h3><ul>
<li><em>虚拟地址</em>： 隔离不同进程，给每个进程独立的虚拟地址，并通过内存管理单元 MMU 映射到物理地址。</li>
<li><em>虚拟内存</em>：让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。  因为申请了不代表会用满，局部性原理<h3 id="2-2-内存分段"><a href="#2-2-内存分段" class="headerlink" title="2.2 内存分段"></a>2.2 内存分段</h3></li>
<li>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。<strong>不同的段是有不同的属性的，所以就用分段（<em>Segmentation</em>）的形式把这些段分离出来。</strong></li>
<li>分段机制下的虚拟地址由两部分组成，<strong>段选择因子</strong>和<strong>段内偏移量</strong>。<ul>
<li><strong>段选择子</strong>就保存在段寄存器里面。段选择子里面最重要的是<strong>段号</strong>，用作段表的索引。<strong>段表</strong>里面保存的是这个<strong>段的基地址、段的界限和特权等级</strong>等。</li>
<li>虚拟地址中的<strong>段内偏移量</strong>应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</li>
</ul>
</li>
<li>缺点：<strong>内存碎片</strong>，内存交换效率低<h3 id="2-3-内存分页"><a href="#2-3-内存分页" class="headerlink" title="2.3 内存分页"></a>2.3 内存分页</h3></li>
<li><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）。在 Linux 下，每一页的大小为 <code>4KB</code>。</li>
<li><strong>内存管理单元</strong> （<em>MMU</em>）将虚拟内存地址转换成物理地址</li>
<li>分页机制下，虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，<strong>页表</strong>包含物理页每页所在<strong>物理内存的基地址</strong>，这个基地址与页内偏移的组合就形成了物理内存地址</li>
<li><em>多级页表</em>：将页表（一级页表）分为 <code>1024</code> 个页表（二级页表），每个表（二级页表）中包含 <code>1024</code> 个「页表项」，形成<strong>二级分页</strong>。</li>
<li><em>快表 TLB</em>： 页表缓存、转址旁路缓存、快表; 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。<h3 id="2-4-段页式"><a href="#2-4-段页式" class="headerlink" title="2.4 段页式"></a>2.4 段页式</h3></li>
<li>先将程序划分为多个有逻辑意义的段，再把每个段划分为多个页</li>
<li>地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成</li>
<li>每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号<h3 id="2-5-Linux-内存布局"><a href="#2-5-Linux-内存布局" class="headerlink" title="2.5 Linux 内存布局"></a>2.5 Linux 内存布局</h3></li>
<li><strong>Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理</strong>。于是 Linux 就把所有段的基地址设为 <code>0</code>，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。</li>
<li>Linux 系统中虚拟空间分布可分为<strong>用户态</strong>和<strong>内核态</strong>两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。<h2 id="3-进程管理"><a href="#3-进程管理" class="headerlink" title="3 进程管理"></a>3 进程管理</h2><h3 id="3-1-进程基础知识"><a href="#3-1-进程基础知识" class="headerlink" title="3.1 进程基础知识"></a>3.1 进程基础知识</h3><blockquote>
<p><strong>进程是若干个活动的执行流以及各类相关资源的总称</strong>，这些资源包括内核结构、地址空间（内存），寄存器等<br>运行可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个<strong>运行中的程序，就被称为「进程」（Process）</strong></p>
<h4 id="3-1-1-进程的状态"><a href="#3-1-1-进程的状态" class="headerlink" title="3.1.1 进程的状态"></a>3.1.1 进程的状态</h4></blockquote>
</li>
<li>运行状态（<em>Running</em>）：该时刻进程占用 CPU；</li>
<li>就绪状态（<em>Ready</em>）：可运行，由于其他进程处于运行状态而暂时停止运行；</li>
<li>阻塞状态（<em>Blocked</em>）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；</li>
<li>创建状态（<em>new</em>）：进程正在被创建时的状态；</li>
<li>结束状态（<em>Exit</em>）：进程正在从系统中消失时的状态；<h4 id="3-1-2-进程的控制结构"><a href="#3-1-2-进程的控制结构" class="headerlink" title="3.1.2 进程的控制结构"></a>3.1.2 进程的控制结构</h4></li>
<li>用<strong>进程控制块</strong>（<em>process control block，PCB</em>）数据结构来描述进程</li>
<li><em>PCB 是进程存在的唯一标识</em><ul>
<li><code>进程描述信息</code>：<ul>
<li>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；</li>
<li>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；</li>
</ul>
</li>
<li><code>进程控制和管理信息</code>：<ul>
<li>进程当前状态，如 new、ready、running、waiting 或 blocked 等；</li>
<li>进程优先级：进程抢占 CPU 时的优先级；</li>
</ul>
</li>
<li><code>资源分配清单</code>：<ul>
<li>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。</li>
</ul>
</li>
<li><code>CPU 相关信息</code>：<ul>
<li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。<h4 id="3-1-3-进程的上下文切换"><a href="#3-1-3-进程的上下文切换" class="headerlink" title="3.1.3 进程的上下文切换"></a>3.1.3 进程的上下文切换</h4></li>
</ul>
</li>
</ul>
</li>
<li><strong>一个进程切换到另一个进程运行，称为进程的上下文切换</strong>。</li>
<li><em>CPU 上下文切换</em>：把保存前一个任务的 CPU 上下文（CPU 寄存器和程序计数器），加载新任务的上下文到这些寄存器和程序计数器，再跳转到程序计数器所指的新位置，运行新任务</li>
<li><em>进程的上下文切换</em> :不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</li>
</ul>
<h3 id="3-2-进程通信"><a href="#3-2-进程通信" class="headerlink" title="3.2 进程通信"></a>3.2 进程通信</h3><ul>
<li>每个进程的用户地址空间都是独立的，进程之间要通信必须通过内核。</li>
<li><em>管道</em>：对于匿名管道，它的通信范围是存在父子关系的进程，通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</li>
<li><em>消息队列</em>：保存在内核中的消息链表</li>
<li><em>共享内存</em>：拿出一块虚拟地址空间来，映射到相同的物理内存中</li>
<li><em>信号量</em>：主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</li>
<li><em>Socket</em>：跨网络与不同主机上的进程之间通信，针对 TCP、UDP、本机间的模型</li>
<li><em>死锁</em><ul>
<li>条件：互斥，占用和等待，不可抢占，循环等待</li>
<li>忽略；检测和恢复，预防，避免</li>
</ul>
</li>
</ul>
<h3 id="3-3-线程"><a href="#3-3-线程" class="headerlink" title="3.3 线程"></a>3.3 线程</h3><ul>
<li><em>线程是进程当中的一条执行流程。</em> 同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套<code>独立的寄存器和栈</code>，这样可以确保线程的控制流是相对独立的。</li>
<li><em>线程与进程的比较</em><ul>
<li>进程是<code>资源（包括内存、打开的文件等）分配</code>的单位，线程是<code>CPU 调度</code>的单位</li>
<li>进程拥有一个完整的<code>资源平台</code>，而线程只独享必不可少的资源，如<code>寄存器和栈</code></li>
<li>线程能减少并发执行的<code>时间和空间开销</code><ul>
<li>线程的创建时间比进程快，不涉及资源管理</li>
<li>线程的终止时间比进程快，释放的资源少</li>
<li>同一个进程内的线程切换比进程切换快，不需要切换页表</li>
<li>共享内存和文件资源，数据交互效率更高</li>
</ul>
</li>
</ul>
</li>
<li><em>线程的上下文切换</em>：两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的<code>私有数据</code>、寄存器等不共享的数据</li>
<li><em>线程的实现</em>：<ul>
<li><strong>用户线程（<em>User Thread</em>）</strong>：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；</li>
<li><strong>内核线程（<em>Kernel Thread</em>）</strong>：在内核中实现的线程，是由内核管理的线程；</li>
<li><strong>轻量级进程（<em>LightWeight Process</em>）</strong>：在内核中来支持用户线程；</li>
</ul>
</li>
<li><em>线程控制块TCB</em> ：线程状态信息（PC、栈指针、寄存器）</li>
<li><em>线程通信</em>：共享变量等，主要关注竞争共享资源的问题<h3 id="3-4-协程"><a href="#3-4-协程" class="headerlink" title="3.4 协程"></a>3.4 协程</h3></li>
<li>不是进程也不是线程，而是一个特殊的函数。协程是属于线程的。协程程序是在线程里面跑的，因此协程又称微线程和纤程等<ul>
<li>比线程更轻量级，协程完全由程序控制（也就是在用户态执行）</li>
<li>没有线程切换的开销</li>
<li>和多线程比，线程数量越多，协程的性能优势就越明显</li>
</ul>
</li>
</ul>
<h2 id="4-调度算法"><a href="#4-调度算法" class="headerlink" title="4 调度算法"></a>4 调度算法</h2><h3 id="4-1-进程调度算法"><a href="#4-1-进程调度算法" class="headerlink" title="4.1 进程调度算法"></a>4.1 进程调度算法</h3><ul>
<li><em>先来先服务调度算法</em>：每次从就绪队列选择最先进入队列的进程</li>
<li><em>最短作业优先调度算法</em>：优先选择运行时间最短的进程来运行</li>
<li><em>高响应比优先调度算法</em>：把「响应比优先级」最高的进程投入运行  服务时间+等待时间/服务时间</li>
<li><em>时间片轮转调度算法</em>：每个进程被分配一个时间段</li>
<li><em>最高优先级调度算法</em>：从就绪队列中选择最高优先级的进程进行运行</li>
<li><em>多级反馈队列调度算法</em>：设置多个优先级队列，优先级越高时间片越短，在当前队列没执行完就去下一级队尾<h3 id="4-2-内存页面置换算法"><a href="#4-2-内存页面置换算法" class="headerlink" title="4.2 内存页面置换算法"></a>4.2 内存页面置换算法</h3></li>
<li>当 CPU 访问的页面不在物理内存时，便会产生一个<code>缺页中断</code>，请求操作系统将所缺页调入到物理内存</li>
<li><em>最佳页面置换算法</em>：理想状态</li>
<li><em>先进先出置换算法</em>：置换掉在内存驻留时间很长的页面</li>
<li><em>时钟页面置换算法</em>：指到谁就替换</li>
<li><em>最不常用算法</em>：选择「访问次数」最少的那个页面，并将其淘汰<h3 id="4-3-磁盘调度算法"><a href="#4-3-磁盘调度算法" class="headerlink" title="4.3 磁盘调度算法"></a>4.3 磁盘调度算法</h3></li>
<li>_先来先服务算法</li>
<li>_最短寻道时间优先算法</li>
<li>_扫描算法</li>
<li>_循环扫描算法</li>
<li>_LOOK 与 C-LOOK 算法</li>
</ul>
<h2 id="5-网络系统"><a href="#5-网络系统" class="headerlink" title="5 网络系统"></a>5 网络系统</h2><h3 id="5-1-零拷贝"><a href="#5-1-零拷贝" class="headerlink" title="5.1 零拷贝"></a>5.1 零拷贝</h3><ul>
<li><strong>直接内存访问（<em>Direct Memory Access</em>）</strong> 技术</li>
<li>由 DMA 控制器负责进行 I/O 设备和内存的数据传输工作，CPU 不参与</li>
<li>过程：<ul>
<li>操作系统将 I/O 请求发送 DMA</li>
<li>DMA 将 I/O 请求发送给磁盘</li>
<li>磁盘把数据读取到缓冲区中，读满后，向 DMA 发起中断信号，告知缓冲区已满</li>
<li>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中</li>
<li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU</li>
<li>CPU 将数据从内核拷贝到用户空间，系统调用返回</li>
</ul>
</li>
<li>实现零拷贝？<ul>
<li>减少「上下文切换」和「数据拷贝」的次数</li>
<li>mmap + write：把内核缓冲区里的数据「<strong>映射</strong>」到用户空间</li>
<li>sendfile：替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销<h3 id="5-2-I-O-多路复用"><a href="#5-2-I-O-多路复用" class="headerlink" title="5.2 I/O 多路复用"></a>5.2 I/O 多路复用</h3></li>
</ul>
</li>
<li>多个请求复用了一个进程，这就是多路复用，<strong>程可以通过一个系统调用函数从内核中获取多个事件</strong><h4 id="5-2-1-Select"><a href="#5-2-1-Select" class="headerlink" title="5.2.1 Select"></a>5.2.1 Select</h4></li>
<li>将已连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后调用 select 函数<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合<strong>拷贝</strong>回用户态里，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket，然后再对其处理。</li>
<li>需要进行 <strong>2 次「遍历」文件描述符集合</strong></li>
<li>使用固定长度的 BitsMap，表示文件描述符集合，最多监听 1024 个</li>
</ul>
<h4 id="5-2-2-poll"><a href="#5-2-2-poll" class="headerlink" title="5.2.2 poll"></a>5.2.2 poll</h4><ul>
<li>poll 用链表形式来组织存储所关注的文件描述符，突破了 select 的文件描述符个数限制</li>
<li>和 select 并没有太大的本质区别，都是线性结构，也都需要遍历</li>
</ul>
<h4 id="5-2-3-epoll"><a href="#5-2-3-epoll" class="headerlink" title="5.2.3 epoll"></a>5.2.3 epoll</h4><ul>
<li>epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里</li>
<li>epoll 使用<code>事件驱动</code>的机制，内核里维护了一个<code>链表</code>来记录就绪事件，当某个 socket 有事件发生时，通过<code>回调函数</code>内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</li>
<li><em>事件触发模式</em><ul>
<li><strong>边缘触发</strong>：当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；   <strong>一般和非阻塞 I/O 搭配使用</strong></li>
<li><strong>水平触发</strong>：当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong>，目的是告诉我们有数据需要读取；</li>
</ul>
</li>
</ul>
<h3 id="5-3-高性能网络模式"><a href="#5-3-高性能网络模式" class="headerlink" title="5.3 高性能网络模式"></a>5.3 高性能网络模式</h3><p><strong>I/O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程</strong></p>
<h4 id="5-3-1-Reactor-模式"><a href="#5-3-1-Reactor-模式" class="headerlink" title="5.3.1 Reactor 模式"></a>5.3.1 Reactor 模式</h4><ul>
<li><strong>Reactor（监听和分发事件）、Acceptor（获取连接）、Handler（处理业务）</strong></li>
<li>单 Reactor 单进程 / 线程，不用考虑进程间通信以及数据同步的问题，因此实现起来比较简单，这种方案的缺陷在于无法充分利用多核 CPU，而且处理业务逻辑的时间不能太长，否则会延迟响应，所以不适用于计算机密集型的场景，适用于业务处理快速的场景，比如 Redis（6.0之前 ） 采用的是单 Reactor 单进程的方案。</li>
<li>单 Reactor 多线程，通过多线程的方式解决了方案一的缺陷，但它离高并发还差一点距离，差在只有一个 Reactor 对象来承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方。</li>
<li>Reactor 多进程 / 线程，通过多个 Reactor 来解决了方案二的缺陷，主 Reactor 只负责监听事件，响应事件的工作交给了从 Reactor<h4 id="5-3-2-Proactor-异步网络模式"><a href="#5-3-2-Proactor-异步网络模式" class="headerlink" title="5.3.2 Proactor 异步网络模式"></a>5.3.2 Proactor 异步网络模式</h4></li>
<li>阻塞 I/O：食堂等  ； 非阻塞 I/O： 过一段时间再去食堂； 异步 I/O： 阿姨送过来</li>
<li><strong>Proactor 是异步网络模式， 感知的是已完成的读写事件</strong>。<strong>「来了事件操作系统来处理，处理完再通知应用进程」</strong>。</li>
</ul>
<h2 id="6-Linux命令"><a href="#6-Linux命令" class="headerlink" title="6 Linux命令"></a>6 Linux命令</h2><h3 id="6-1-查看网络性能指标"><a href="#6-1-查看网络性能指标" class="headerlink" title="6.1 查看网络性能指标"></a>6.1 查看网络性能指标</h3><ul>
<li>网络的配置和状态   使用 <code>ifconfig</code> 或者 <code>ip</code> 命令来查看</li>
<li>socket 信息如何查看   使用 <code>netstat</code> 或者 <code>ss</code></li>
<li>网络吞吐率和 PPS 如何查看     使用 <code>sar</code> 命令</li>
<li>连通性和延时如何查看  ping</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2023/10/09/System-Design/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%BD%92%E7%BA%B3/"></a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2023-10-09
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="实现令牌桶"><a href="#实现令牌桶" class="headerlink" title="实现令牌桶"></a>实现令牌桶</h2><p>“HMSET” 是 Redis 的哈希表命令，用于设置哈希表中的多个字段及其对应的值。<br>通过将获取锁封装到lua脚本中，提交给redis进行eval和evalsha操作来完成lua脚本的执行，由于lua脚本在redis中天然的原子性，我们的需求能够比较好的满足，问题是将业务逻辑封装在lua中，对于开发人员自身的能力和调试存在一定的问题。<br>限流器在每次请求令牌和放入令牌操作中，存在一个协同的问题，即获取令牌操作要尽可能保证原子性，否则无法保证限流器是否能正常工作。在RateLimiter的实现中使用了mutex作为互斥锁来保证操作的原子性，那么在redis中就需要一个类似于事务的机制来保证获取令牌中多重操作的原子性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">-- 返回码 1:操作成功 0:未配置 -1: 获取失败 -2:修改错误，建议重新初始化 -500:不支持的操作</span><br><span class="line">-- redis hashmap 中存放的内容:</span><br><span class="line">-- last_mill_second 上次放入令牌或者初始化的时间</span><br><span class="line">-- stored_permits 目前令牌桶中的令牌数量</span><br><span class="line">-- max_permits 令牌桶容量</span><br><span class="line">-- interval 放令牌间隔</span><br><span class="line">-- app 一个标志位，表示对于当前key有没有限流存在</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> SUCCESS = 1</span><br><span class="line"><span class="built_in">local</span> NO_LIMIT = 0</span><br><span class="line"><span class="built_in">local</span> ACQUIRE_FAIL = -1</span><br><span class="line"><span class="built_in">local</span> MODIFY_ERROR = -2</span><br><span class="line"><span class="built_in">local</span> UNSUPPORT_METHOD = -500</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> ratelimit_info = redis.pcall(<span class="string">&quot;HMGET&quot;</span>,KEYS[1], <span class="string">&quot;last_mill_second&quot;</span>, <span class="string">&quot;stored_permits&quot;</span>, <span class="string">&quot;max_permits&quot;</span>, <span class="string">&quot;interval&quot;</span>, <span class="string">&quot;app&quot;</span>)</span><br><span class="line"><span class="built_in">local</span> last_mill_second = ratelimit_info[1]</span><br><span class="line"><span class="built_in">local</span> stored_permits = tonumber(ratelimit_info[2])</span><br><span class="line"><span class="built_in">local</span> max_permits = tonumber(ratelimit_info[3])</span><br><span class="line"><span class="built_in">local</span> interval = tonumber(ratelimit_info[4])</span><br><span class="line"><span class="built_in">local</span> app = ratelimit_info[5]</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> method = ARGV[1]</span><br><span class="line"></span><br><span class="line">--获取当前毫秒</span><br><span class="line">--考虑主从策略和脚本回放机制，这个time由客户端获取传入</span><br><span class="line">--<span class="built_in">local</span> curr_time_arr = redis.call(<span class="string">&#x27;TIME&#x27;</span>)</span><br><span class="line">--<span class="built_in">local</span> curr_timestamp = curr_time_arr[1] * 1000 + curr_time_arr[2]/1000</span><br><span class="line"><span class="built_in">local</span> curr_timestamp = tonumber(ARGV[2])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 当前方法为初始化</span><br><span class="line"><span class="keyword">if</span> method == <span class="string">&#x27;init&#x27;</span> <span class="keyword">then</span></span><br><span class="line">    --如果app不为null说明已经初始化过，不要重复初始化</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>(app) ~=<span class="string">&#x27;boolean&#x27;</span> and app ~=nil) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> SUCCESS</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    redis.pcall(<span class="string">&quot;HMSET&quot;</span>, KEYS[1],</span><br><span class="line">        <span class="string">&quot;last_mill_second&quot;</span>, curr_timestamp,</span><br><span class="line">        <span class="string">&quot;stored_permits&quot;</span>, ARGV[3],</span><br><span class="line">        <span class="string">&quot;max_permits&quot;</span>, ARGV[4],</span><br><span class="line">        <span class="string">&quot;interval&quot;</span>, ARGV[5],</span><br><span class="line">        <span class="string">&quot;app&quot;</span>, ARGV[6])</span><br><span class="line">    --始终返回成功</span><br><span class="line">    <span class="built_in">return</span> SUCCESS</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 当前方法为修改配置</span><br><span class="line"><span class="keyword">if</span> method == <span class="string">&quot;modify&quot;</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>(app) ==<span class="string">&#x27;boolean&#x27;</span> or app ==nil) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> MODIFY_ERROR</span><br><span class="line">    end</span><br><span class="line">    --只能修改max_permits和interval</span><br><span class="line">    redis.pcall(<span class="string">&quot;HMSET&quot;</span>, KEYS[1],</span><br><span class="line">        <span class="string">&quot;max_permits&quot;</span>, ARGV[3],</span><br><span class="line">        <span class="string">&quot;interval&quot;</span>, ARGV[4])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> SUCCESS</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 当前方法为删除</span><br><span class="line"><span class="keyword">if</span> method == <span class="string">&quot;delete&quot;</span> <span class="keyword">then</span></span><br><span class="line">    --已经清除完毕</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>(app) ==<span class="string">&#x27;boolean&#x27;</span> or app ==nil) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> SUCCESS</span><br><span class="line">    end</span><br><span class="line">    redis.pcall(<span class="string">&quot;DEL&quot;</span>, KEYS[1])</span><br><span class="line">    <span class="built_in">return</span> SUCCESS</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 尝试获取permits</span><br><span class="line"><span class="keyword">if</span> method == <span class="string">&quot;acquire&quot;</span> <span class="keyword">then</span></span><br><span class="line">    -- 如果app为null说明没有对这个进行任何配置，返回0代表不限流</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>(app) ==<span class="string">&#x27;boolean&#x27;</span> or app ==nil) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> NO_LIMIT</span><br><span class="line">    end</span><br><span class="line">    --需要获取令牌数量</span><br><span class="line">    <span class="built_in">local</span> acquire_permits = tonumber(ARGV[3])</span><br><span class="line">    --计算上一次放令牌到现在的时间间隔中，一共应该放入多少令牌</span><br><span class="line">    <span class="built_in">local</span> reserve_permits = math.max(0, math.floor((curr_timestamp - last_mill_second) / interval))</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">local</span> new_permits = math.min(max_permits, stored_permits + reserve_permits)</span><br><span class="line">    <span class="built_in">local</span> result = ACQUIRE_FAIL</span><br><span class="line">    --如果桶中令牌数量够则放行</span><br><span class="line">    <span class="keyword">if</span> new_permits &gt;= acquire_permits <span class="keyword">then</span></span><br><span class="line">        result = SUCCESS</span><br><span class="line">        new_permits = new_permits - acquire_permits</span><br><span class="line">    end</span><br><span class="line">    --更新当前桶中的令牌数量 </span><br><span class="line">    redis.pcall(<span class="string">&quot;HSET&quot;</span>, KEYS[1], <span class="string">&quot;stored_permits&quot;</span>, new_permits)</span><br><span class="line">    --如果这次有放入令牌，则更新时间</span><br><span class="line">    <span class="keyword">if</span> reserve_permits &gt; 0 <span class="keyword">then</span></span><br><span class="line">        redis.pcall(<span class="string">&quot;HSET&quot;</span>, KEYS[1], <span class="string">&quot;last_mill_second&quot;</span>, curr_timestamp)</span><br><span class="line">    end</span><br><span class="line">    <span class="built_in">return</span> result</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> UNSUPPORT_METHOD</span><br></pre></td></tr></table></figure>
<h2 id="实现-set"><a href="#实现-set" class="headerlink" title="实现 set"></a>实现 set</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 是一个使用 map 实现的集合</span></span><br><span class="line"><span class="keyword">type</span> Set <span class="keyword">struct</span> &#123;</span><br><span class="line">    m <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSet 创建一个新的空集合</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSet</span><span class="params">()</span></span> *Set &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Set&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 向集合中添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Add(value <span class="type">string</span>) &#123;</span><br><span class="line">    s.m[value] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove 从集合中删除一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Remove(value <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="built_in">delete</span>(s.m, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Contains 检查集合中是否包含某个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Contains(value <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    _, ok := s.m[value]</span><br><span class="line">    <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len 返回集合的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s.m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear 清空集合</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Clear() &#123;</span><br><span class="line">    s.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Values 返回集合中的所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Values() []<span class="type">string</span> &#123;</span><br><span class="line">    values := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(s.m))</span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> s.m &#123;</span><br><span class="line">        values = <span class="built_in">append</span>(values, k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    set := NewSet()</span><br><span class="line">    set.Add(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    set.Add(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    set.Add(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;Set contains &#x27;a&#x27;:&quot;</span>, set.Contains(<span class="string">&quot;a&quot;</span>)) <span class="comment">// true</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Set contains &#x27;d&#x27;:&quot;</span>, set.Contains(<span class="string">&quot;d&quot;</span>)) <span class="comment">// false</span></span><br><span class="line">    </span><br><span class="line">    set.Remove(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Set contains &#x27;a&#x27;:&quot;</span>, set.Contains(<span class="string">&quot;a&quot;</span>)) <span class="comment">// false</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;Set length:&quot;</span>, set.Len()) <span class="comment">// 2</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;Set values:&quot;</span>, set.Values()) <span class="comment">// [b c]</span></span><br><span class="line">    </span><br><span class="line">    set.Clear()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Set length after clear:&quot;</span>, set.Len()) <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现协程交替打印"><a href="#实现协程交替打印" class="headerlink" title="实现协程交替打印"></a>实现协程交替打印</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> countNum = <span class="number">100</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//3个函数分别打印cat、dog、fish，要求每个函数都要起一个goroutine，按照cat、dog、fish顺序打印在屏幕上10次</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"> </span><br><span class="line">    dogCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(dogCh)</span><br><span class="line">    catCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(catCh)</span><br><span class="line">    fishCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(fishCh)</span><br><span class="line"> </span><br><span class="line">    wg.Add(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">go</span> catPrint(&amp;wg, &amp;catCh, &amp;dogCh)</span><br><span class="line">    <span class="keyword">go</span> dogPrint(&amp;wg, &amp;dogCh, &amp;fishCh)</span><br><span class="line">    <span class="keyword">go</span> fishPrint(&amp;wg, &amp;fishCh, &amp;catCh)</span><br><span class="line"> </span><br><span class="line">    catCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">catPrint</span><span class="params">(wg *sync.WaitGroup, catCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, dogCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> count &gt;= countNum &#123;</span><br><span class="line">            wg.Done()</span><br><span class="line">            <span class="comment">//fmt.Println(&quot;cat quit&quot;)</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        &lt;-*catCh</span><br><span class="line">        fmt.Println(<span class="string">&quot;cat&quot;</span>, count+<span class="number">1</span>)</span><br><span class="line">        count++</span><br><span class="line">        *dogCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dogPrint</span><span class="params">(wg *sync.WaitGroup, dogCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, fishCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> count &gt;= countNum &#123;</span><br><span class="line">            wg.Done()</span><br><span class="line">            <span class="comment">//fmt.Println(&quot;dog quit&quot;)</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        &lt;-*dogCh</span><br><span class="line">        fmt.Println(<span class="string">&quot;dog&quot;</span>)</span><br><span class="line">        count++</span><br><span class="line">        *fishCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fishPrint</span><span class="params">(wg *sync.WaitGroup, dogCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, catCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> count &gt;= countNum &#123;</span><br><span class="line">            wg.Done()</span><br><span class="line">            <span class="comment">//fmt.Println(&quot;fish quit&quot;)</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        &lt;-*dogCh</span><br><span class="line">        fmt.Println(<span class="string">&quot;fish&quot;</span>)</span><br><span class="line">        count++</span><br><span class="line">        *catCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    
    
  </div>

  

  

</article>
  
    
  <nav class="pagination">  
      
      
      <a class="next" href="/page/2/">  
        <span class="next-text">Next</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  
</section>
        </div>
          

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2019 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">draco</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    

  







<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>



<script type="text/javascript" src="/lib/slideout/slideout.js"></script>



<script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>