---
title: "[Go] 闭包"
date: 2021-12-04
tags:
  - Golang
categories:
  - Golang
  - 语言基础
published: true
toc: "true"
comments: "true"
description:
---
>闭包是有状态函数

<!--more-->

# 闭包

## 1 function value

Go 语言中的函数是头等公民。可以做为参数传递，可以做函数返回值、也可以绑定到变量。

Go 语言称这样的参数、返回值或变量为**function value**。

function value 不直接指向函数指令入口，而是指向一个 `runtime.funcval`结构体。

```go
// runtime/runtime2.go
type funcval struct {
	fn uintptr
	// variable-size, fn-specific data here
}
```

可以看到 funcval 只有一个字段 fn，存储的就是函数指令入口地址。

## 2 闭包 Closure

**为什么要用 funcval 结构体来包装函数指令入口地址，然后使用二级指针来调用？**

主要是为了处理闭包的情况。

维基百科上的[闭包]([https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)](https://zh.wikipedia.org/wiki/闭包_(计算机科学)))定义如下：

* 1）必须要有在函数外部定义但在函数内部引用的`自由变量`
* 2）脱离了形成闭包的上下文，闭包也能照常使用这些自由变量。

就向下面这个例子

```go
func main() {
	f1 := create()
	f2 := create()
	fmt.Println(f1())
	fmt.Println(f2())
}

func create() func() int {
	i := 2
	return func() int {
		return i
	}
}
```

create() 函数执行结束后，通过 f1()，f2() 依然可以正常调用这个闭包函数，并使用定义在 create() 函数内部的局部变量 i，所以这符合闭包的定义。

通常称这个变量 i 为**捕获变量**。



**闭包函数的指令在编译阶段生成，但是闭包对象要到执行阶段才创建，因为每个闭包对象都要保存自己的捕获变量**。

闭包函数指令存放在栈中的代码段上。

闭包对象则会分配到堆上，闭包对象具体组成如下：

* 1）funcval 结构体
* 2）捕获变量列表

```go
f1 := create()
f2 := create()
```

这里创建了两个闭包对象，其中的 funcval 都指向同一个函数指令入口，但是捕获变量则需要各自维护。

然后把这两个闭包对象的地址赋值给接收者，即这里的 f1,f2。

通过f1、f2调用闭包函数会找到各自对应的 funcval 结构体，拿到同一个函数入口，但是却使用的是各自的捕获变量列表。

**这就是称闭包为有状态函数的原因。**


## 3 获取捕获列表

**闭包函数是如何找到对应的捕获列表呢？**

Go语言中通过一个 function value 调用函数时，会把对应的**funcval 结构体地址**存入特定寄存器。例如 amd64 平台使用的是 DX 寄存器。

这样在闭包函数中就可以通过寄存器取出 funcval 结构体的地址，然后加上相应的**偏移量**来找到每一个被捕获的变量。



所以**Go 语言中闭包就是有捕获列表的 function value**，而没有捕获列表的 function value 直接忽略这个寄存器的值就好了。



## 4 捕获变量

被闭包捕获的变量，要在外层函数闭包函数中表现一致，好像它们在使用同一个变量。为此 Go 语言编译器针对不同情况做了不同的处理。

> 变量逃逸、参数堆分配、返回值



### 4.1 没有修改

被捕获变量 i 除了赋值之外没有被其他地方修改，所以直接拷贝到捕获列表即可。

就像下面这个例子：

```go
func incrementer() func() int {
	i := 2
	return func() int {
		return i
	}
}
```


### 4.2 有修改

除了初始化赋值外还被修改过，则需要进一步细分。

**捕获的是局部变量**

被闭包捕获的局部变量如果除了初始化赋值外还被修改过，就会分配到堆上。

闭包导致的局部变量堆分配，也是变量逃逸的一种。

例子如下：

```go
func main() {
	fs := create()
	for i := 0; i < len(fs); i++ {
		fs[i]()
	}
}

func create() (fs [2]func()) {
	for i := 0; i < 2; i++ {
		fs[i] = func() {
			fmt.Println(i)
		}
	}
	return
}
```

create() 函数中的局部变量 i 除了初始化之外，还被修改过(i++)，同时还被闭包捕获，所以会分配到堆上，然后栈上只存储该变量的地址。

每次 i++ 自增的是堆上的变量 i，而闭包捕获的都是变量 i 的地址，都指向堆上的变量 i。

最后 i 会自增到 2 ，所以最终闭包打印出来的i值都为2。

**捕获的是参数**

由于参数设计到函数原型，就不能像局部变量这样处理了。

参数依然通过调用者栈帧传入，但是编译器会把栈上参数拷贝一份到堆上。然后外层函数和闭包函数都使用堆上分配的这个。


**捕获的是返回值**

如果捕获的是返回值，则处理又不同。

调用者栈帧上依然会分配返回值空间，不过闭包的外层函数会在堆上也分配一个，外层函数和闭包函数都使用堆上分配的这个。

但是在外层函数返回前，需要把堆上的返回值拷贝到栈上的返回值空间。

### 4.3 小结

处理方式虽然多种多样，但是目标只有一个，那就是**保持捕获变量在外层函数和闭包函数中的一致性**。

## 5 小结

* **闭包由 funcval 结构体和捕获变量组成**。
	  * funcval 结构体中的 fn 字段指向闭包函数的函数入口
	  * 捕获变量则是当前闭包对象的参数，每个闭包对象维护各种的参数列表。
* 除初始化外还被修改过的局部变量被闭包捕获后会**分配到堆上，栈上保存的是指向堆上变量的指针**。
	  * 局部变量堆分配，变量逃逸的一种。
	  * 所以这个时候闭包中的局部变量其实就是一个地址，都指向堆上的同一个变量。
	  * 这也是为什么各种 for 循环最后打印出的 i 都是一个值

## 6 参考

`https://zh.wikipedia.org/wiki/闭包_(计算机科学)`