---
title: "[DDIA] 分布式系统中的麻烦事"
date: 2023-07-14
tags:
  - DDIA
categories:
  - 阅读笔记
  - DDIA
published: true
toc: "true"
comments: "true"
description:
---
>是否要在目标场景下解决这些问题、还是为了降低系统复杂度忽略这些问题

<!--more-->


## 1 故障和部分失败
单机系统通常具有一种很好地特性：**要么正常运行、要么出错崩溃，而不会处于一种中间状态**。

**部分失败**（partial failure），即系统的一部分正常工作，另一部分却以某种诡异的方式出错。这些问题，多数都是由于连接不同主机的**异步网络**所引入的。

### 1.1 云计算和超算
- 在线离线， 故障常态化，  容错
- 为了让分布式系统能够工作，就必须假设故障一定会存在，并在设计层面考虑各种出错处理。即，**我们要基于不可靠的组件构建一个可靠系统**。

### 1.2 基于不可靠组件构建可靠系统
1. 纠错码能够容忍信道中偶尔一两个比特的误传。
2. IP 层不可靠，但 TCP 层却基于 IP 层提供了相对可靠的传输保证。

## 2 不可靠的网络
**所有机器不共享资源（如内存、磁盘），通信的唯一途径就是网络**。
互联网和数据中心（多是以太网）的内部网络多是**异步封包网络**（**asynchronous packet networks**）。

1. 请求没有发出去就丢了（比如你的网线可能被拔了）
2. 请求可能先排了会队，稍后才被发出去（比如网络或接收方负载过高）
3. 对端节点挂了（比如遇到异常宕机或者断电了）
4. 对端节点临时无响应（比如正在进行 GC），但稍后又能正常工作
5. 对端节点处理了你的请求，但应答在网络回程中丢了（比如网关配错了）
6. 对端节点处理了你的请求，但应答被推迟了（比如网络或你的机器负载过高）

在异步网络中，当你发送出一个请求，并在一段时间内没有收到应答，任何事情都有可能发生：由于没有收到任何信息，你无从得知具体原因是什么。甚至，你都不知道你的请求是否已被送达处理。

应对这种情况的惯常做法是——**超时**（timeout）。即，设定一个时限，到点后，我们便认为这个请求废了。但在实际上，该请求可能只是还在排队、可能稍后到到达远端节点、甚至可能最终还会收到应答。

### 2.1 故障检测
**自动检测故障节点**，并据此做出一些决策：
- 负载均衡器需要停止对故障节点流量的分发。
- 在单主模型的分布式数据库中，如果主节点故障，需要选出一个从节点顶上。


- **操作系统通知**。如果你能触达**服务**所在**机器**，但发现没有进程在监听预期端口（比如对应服务进程挂了），操作系统会通过发送 RST 或 FIN 包来关闭 TCP 连接。但是如果对端节点在处理你的请求时整个宕机了，就很难得知你请求的具体处理进度。
- **daemon 脚本通知**。可以通过一些 daemon **脚本**，在本机服务进程死掉之后，主动通知其他节点。来避免其他节点通过发送请求超时来判断此节点宕机。当然这前提是，服务进程挂了，但所在节点没挂。
- **数据链路层面**。如果你是管理员，并且能访问到你数据中心的网络交换机，可以在数据链路层判断远端机器是否宕机。当然如果你访问不到交换机，那这种方法就不太行。
- **IP 不可达**。如果路由器发现你要发送请求的 IP 地址不可达，它会直接回你一个 ICMP 不可达包。但路由器也并不能真正判断是否该机器不可用了。

设置一个**合理的超时时限**和重试次数。直到，你确认没有再重试的必要——即不管远端节点是否存活，我在重试几次后，都认为它不可用了（或者暂时不可用）。

### 2.2 超时和无界延迟（unbounded delays）

**超时间隔**要设置多久呢？总的来说：
1. 不能太长：过长会浪费很多时间在等待上。
2. 不能太短：太短会造成误判，误将网络抖动也视为远端节点失败。

设有一个理想的网络系统，能够保证所有的网络**通信延迟不超过 d**：所有的网络包要么在 d 时间内送达对端、要么就会丢失，即不可能在超过 d 的时限后才到。如果网络能提供此种保证，则应用层可大为简化：假设我们预估出单个请求最大处理时间 r，则 2d+r 是一个很好超时间隔。


#### 2.2.1 网络拥塞和数据包排队
**网络流量越满，单个请求延迟抖动越大**。


#### 2.2.2 同步网络和异步网络
固话网会为每一次通话预留**稳定低延迟**和**充足的带宽**链路以传输语音。

## 3 不可靠的时钟
实践中，常通过 **NTP**（网络时间协议）对机器进行自动校准。其大致原理是，首先使用更精确时钟（如 GPS 接收器）构建一组**可信服务器**作为时钟源（比如阿里云的源），

### 3.1 单调时钟
单调时钟主用于取两个时间点的**差值**来测量时间间隔，如服务器的超时间隔和响应时间。

### 3.2 时间戳以定序

1. **写入谜之丢失**。一个具有落后时钟的节点产生的写入数据，无法覆盖一个具有超前时钟节点先前写入的数据，造成后写入的数据反而被没有任何提醒的丢弃。
2. **无法区分先后和并行**。两者主要区别在于，一个是有明显的依赖关系，如上图中自增依赖于之前的初始化；另一个是相关的几个操作互相并不关心。为了解决这个问题，需要引入额外的时间戳机制进行因果关系追踪，如 version vector（一种逻辑时钟）。
3. **两个独立节点可能会产生相同时间戳的事件**。尤其是在时钟精读不太够的情况下（比如最低只能给到毫秒），可以使用额外的随机数来对其进一步区分，但这样也会导致一些时间上的因果问题。


### 3.3 进程停顿

分布式系统中的节点可能在**任意时刻**的**任意代码位置**停顿**任何时长**，而在此间，系统的其他节点仍在正常往前执行，甚至由于该节点不响应而将其标记为死亡。最终，该停顿节点可能会继续执行

有一些手段可以用来减轻进程停顿现象，且不必借助代价高昂的强实时系统。比如**垃圾回收器**（GC 进程）可以实时追踪**对象分配速率**和剩余**可利用内存**，利用这些信息，GC 进程可以给应用程序提供一些信号。然后我们在构造系统时捕获这些信号，然后拒绝服务一段时间，等待 GC 结束。就跟临时故障或者下线的节点一样，别的节点会来接管请求。

