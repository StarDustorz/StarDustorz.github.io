---
title: "[DDIA] 事务"
date: 2023-06-20
tags:
  - DDIA
categories:
  - 阅读笔记
  - DDIA
published: true
toc: "true"
comments: "true"
description:
---
>从**时间**和**空间**两个角度来理解事务，从生命周期（时间）来讲，事务要保证一组操作的整体性；从并发控制（空间），事务要做好多个事务间的并发控制。

<!--more-->

在分布式数据系统中，任何问题都有可能发生：
1. 系统侧：数据库系统和硬件系统任何时间都有可能发生故障
2. 应用侧：使用数据库的应用程序任何时刻都有可能故障。
3. 网络侧：应用程序和数据库间，数据库的多个节点间，随时都有可能断开连接。
4. 多个客户端：并发写入时，可能会有竞态条件和相互覆盖。
5. 半读：一个客户端可能会读到部分更新的数据库。

**事务**，就是数据库为了解决类似的问题，所提供的一种保证，以**简化应用层的编程模型**。

**事务**就是将一组语句（或者说操作）打包成一个逻辑单元进行执行，并提供一种保证，这一组操作要么全部成功（ **commit**，应用到数据库里），要么全部失败（被动 **abort**，或者主动 **rollback**），而不会存在只执行了一半的中间状态。此外，如果多个客户端的事务并发执行，会涉及到隔离性的问题，一般来说，数据库允许用户在隔离级别和性能之间做选择。


用户在发现事务失败后，可以放心的进行重试，直到成功，就可以确定事务中的所有操作都生效了。但任何便利性都是有代价的，事务便是在一定程度上牺牲了性能和可用性。


## 1 概念
### 1.1 ACID
Atomicity、Consistency、Isolation 和 Durability
#### 1.1.1 原子性
原子性所提供的保证是：**在发生错误时，会回滚该事务所有已经写入的变更**。

#### 1.1.2 一致性
一致性是对某些**不变性（invariants）** 的维持，所谓不变性，即某些约束条件。如，在银行账户中，在任何时刻，账户余额须等于收入减去支出。

不同于 ACID 中其他性质，一致性是需要**应用侧**和**数据库侧**共同维护的：

1. 应用侧需要写入满足应用侧视角约束要求的数据。
2. 数据库侧需要保证多次写入前后，尤其是遇到问题时，维持该约束。
#### 1.1.3 隔离性
每个事务的执行是互相隔离的，每个事务都可以认为自己是系统中唯一正在运行的事务，因此传统上，教科书将事务隔离形式称为：**可串行化（Serializability）**。即，如果所有事务都串行执行，则任意时刻必然只有一个事务在执行，从而在根本上消除任何并发问题。
#### 1.1.4 持久性
持久性是一种保证，即事务一旦提交，即使服务器宕机重启、甚至发生硬件故障，已经提交的事务所写入的数据就不会丢失。

**持久性**都只能做到某种程度的保证，而非绝对保证，比如：
1. 对于单机，可以容忍宕机。但磁盘坏了就完犊子。
2. 对于多机，可以容忍少数副本损坏，但是多数副本完后也没辙。

### 1.2 单对象和多对象操作
对象事务中，一个关键点是如何确定多个操作是否属于同一事务：
1. 从**物理上来考虑**。可以通过 TCP 连接来确定，在同一个连接中，`BEGIN TRANSACTION` 和  `COMMIT`语句之间的所有内容，可以认为属于同一个事务。但会有一些 corner case，如在客户端提交请求后，服务器确认提交之前，网络中断，连接断开，此时客户端则无从得知事务是否被成功提交。
2. **从逻辑上来考虑**。使用事务管理器，为每个事务分配一个唯一标识符，从而对操作进行分组。

实际中基本上使用第二种方法。

#### 1.2.1 单对象写入
当只更改单个对象时，仍会面临原子性和隔离性的问题
一般的数据库哪怕不支持完整的事务，也会提供针对单个对象的原子性和隔离性。比如，可以使用写前日志来保证原子性，使用锁来保证隔离性。

其他一些数据库，也会提供更复杂的原子支持，如原子的自增操作，从而避免交错更新。另一种更泛化的原子性保证是提供单个对象上的 CAS 操作，允许用户原子的执行针对单个对象的 read-modify-write 操作。当然，如果咬文嚼字一下，**原子自增**（atomic increment），在 ACID 中应该是属于隔离性（Isolation）的范畴，此处的原子自增其实是多线程的概念。

#### 1.2.2 界定对多对象事务的需求
跨机器的分布式事务很难实现、且非常损失性能（可能在一个数量级），很多分布式数据库选择不支持多对象事务。但有些场景确实需要多对象事务，因此一些数据库多将是否打开事务设为一个开关。

需要协同更新多个对象：
1. 在关系型数据库中，一些表通常会有一些外键。在更新时，需要进行同步更新。
2. 在文档型数据库中，相关的数据通常会放到一个文档中，但由于大部分文档数据库不支持 Join，因此不得不使用前文提到的 denormalization 对信息进行冗余存储，便产生了同步更新需求。
3. 在支持次级索引的数据库中，数据和对应的多个索引需要进行同步更新。

#### 1.2.3 故障和终止
事务的一个重要特点是在执行到一半时，可以安全的终止并重试。事务的设计哲学是：当出现违反原子性、隔离性和持久性的危险时，就**丢弃而非保留**已经发生的修改。

另一些场景，如多副本中的无主模型，就采用了“**尽力而为**”的模型，即尽可能的保证完成任务，如不能完成，也不会回滚已经发生的修改。因此，应用侧需要处理这种半完成的状态。

1. 事务已经被成功提交，但返回给用户时出错。用户如果简单重试，就会使该事务中的操作执行两次，从而造成数据冗余，除非用户在应用代码侧进行去重（如多次执行这些语句，效果一样）。
2. 由于系统负载过高，而造成事务执行失败。如果无脑重试，会进一步加重系统负担。此时可以使用指数后退方式重试，并且限制最大重试次数。
3. 一些临时错误，如死锁、异常、网络抖动和故障切换时，重试才有效；对于一些永久故障，重试是没有意义的。
4. 某事务在数据库之外如有副作用，重试事务时，会造成副作用的多次发生。如果某个事务的副作用是发送邮件，则肯定不希望事务每次重试时都发送一次电子邮件。如果想进行多个系统间的协同，可以考虑两阶段提交。
5. 如果客户端在写入数据时故障，则所有该客户端正在执行的事务所涉及的数据修改都会丢失。


## 2 几种弱隔离级别

数据库试图通过**事务隔离**（transaction isolation）来给用户提供一种隔离保证，从而降低应用侧的编程复杂度。

最强的隔离性——可串行化，可以理解为全局一把大排它锁，每个事务在启动时获取，在提交、回滚或终止时释放，但无疑这种隔离级别性能最差。而其他几种弱隔离级别，可以理解为是为了提高性能，缩小了加锁的粒度、减小了加锁的时间，从而牺牲部分一致性换取性能。从上锁的强弱考虑，我们有**互斥锁**（Mutex Lock，又称写锁）和**共享锁**（Shared Lock，又称读锁）；从上锁的长短来考虑，我们有**长时锁**（Long Period Lock，事务开始获取锁，到事务结束时释放）和**短时锁**（Short Period Lock，访问时获取，用完旋即释放）；从上锁的粗细来考虑，我们有对象锁（Row Lock，锁一行）和谓词锁（Predicate Lock，锁一个范围）。

但这没有覆盖到到另一个常见的隔离级别——**快照隔离**（Snapshot Isolation），因为它引出了另一种实现族——MVCC。由于属于不同的实现，快照隔离和可重复读在隔离级别的光谱上属于一个偏序关系，不能说谁强于谁。

### 2.1 读已提交
性能最好的隔离级别就是不上任何锁，但会存在**脏读**和**脏写**的问题。为了避免脏写，可以给要更改的对象加长时写锁，但读数据时并不加锁，此时的隔离级别称为**读未提交**（RU，Read Uncommitted）。但此时仍然会有脏读，为了避免脏读，可以对要读取的对象加**短时读锁**，此时的隔离级别是**读已提交**（RC，Read Committed），他提供了两个保证：
1. 从数据库读取时，只能读到已经提交的数据（即没有脏读，no dirty reads）
2. 往数据库写入时，只能覆盖已经提交的数据（即没有脏写，no dirty writes）

### 2.2 快照隔离和重复读

Alice 分两个账户，各存了 500 块钱，但如果其两次分别查看两个账户期间，发生了一笔转账交易，则两次查看的余额加起来并不等于 1000。 
**同一个操作期间，两次读取到的数据不一致。** 也就是在事务a执行中，事务b修改了数据并提交了


这种异常被称为**不可重复读**（non-repeatable read）或者**读倾斜**（read skew）。读已提交的隔离级别允许出现不可重复读问题，如上述例子，每次读取到的都是已提交的内容。

在某些情况下，这种暂时的不一致也是不可接受的：
1. **备份**。备份可能需要花费很长时间，而备份过程中可能会有读写存在，从而造成备份时的不一致。如果之后再利用此备份进行恢复，则会造成永久的不一致。
2. **分析型查询和完整性检查**。这个操作和备份一样，耗时都会比较长，如果中间有其他事务并发导致出现不一致的现象，就会导致返回的结果有问题。
3. 
**快照隔离**（snapshot isolation）级别能够解决上述问题，使用此级别，每个事务都可以取得一个某个时间点的**一致性快照**（consistent snapshot），在整个事务期间，读到的状态都是该时间点的快照。其他事务的修改并不会影响到该快照上。

#### 2.2.1 快照隔离的实现
快照隔离也使用加锁的方式来防止脏写，但在进行读取不使用锁。快照隔离的一个关键原则是“读不阻塞写，写不阻塞读”，从而允许用户在进行长时间查询时，不影响新的写入。

为了实现快照隔离，保证读不阻塞写，且避免脏读，数据库需要对同一个对象保留多个已提交的版本，我们称之为**多版本并发控制**（**MVCC，multi-version concurrency control**）。

1. **读已提交**在查询语句粒度使用单独的快照，快照粒度更小，因此性能更好。
2. **快照隔离**在事务粒度使用相同的快照（主要解决**不可重复读**问题）。

**MVCC 的基本要点为：**
1. 每个事务开始时会获取一个自增的、唯一的事务 ID（txid），该 txid = max(existing tx id) + 1。
2. 该事务在修改数据时，不会修改以前版本，而会新增一个具有 txid 版本的数据。
3. 该事务只能访问到所有版本 ≤ txid 的数据。
4. 在写入时，如果发现某个数据存在 > txid 的版本，则存在写写冲突。

#### 2.2.2 可见性规则
在事务中进行读取时，对于每个对象来说，需要**控制**其版本对事务的可见性，以保证该事务能够看到一致性的视图。
1. 事务开始时，所有正在进行（已经开始但未提交或中止）的事务，所做的任何写入都会被忽略。
2. 被中止的事务，所做的任何写入都会被忽略。
3. 具有较晚事务 ID 的事务所做的任何写入都会被忽略。
4. 剩余其他的数据，对此事务都可见。

### 2.3 索引和快照隔离

当数据有多个版本时，如何给数据建立索引？一个简单的方法是将索引指向对象的所有版本，然后在查询时使用再进行版本过滤。当某个对象的所有版本对任何事务都不再可见时，相应的索引条目也可以被同时删除。


### 2.4 防止更新丢失
更新丢失发生的关键在于，两个事务中都有读后写序列（读取 - 修改 - 写入序列，写偏序也是这个序列，但是针对多个对象），即**写依赖于之前的读**。如果读到的内容被其他事务修改，则本事务稍后的依赖于此读的写就会发生问题。如：
1. 并发更新计数器和账户余额。
2. 复合值的并发修改（如 json 文档中的列表字段，需要先读出，加一个字段后写回）。
3. 两个用户同时修改 wiki 页面，并且都是修改后将页面完整覆写回。
#### 2.4.1 原子写
有些数据库提供原子的（**针对单个对象的**）read-modify-write 操作，因此，如果应用层逻辑能用这个原子操作表达，就可以避免更新丢失。
原子操作的通常实现方式为，在读取某对象时，获取其互斥锁，从而阻止其他事务读取该对象。

#### 2.4.2 显式上锁
应用在有针对单个对象的 read-modify-write 序列时，将是否上锁的决策交给应用层

#### 2.4.3 自动检测更新丢失
使用**乐观**方式，允许其并发执行，检测到更新丢失后进行重试。

#### 2.4.4 Compare-and-set
使用 CAS 操作也能避免更新丢失，保证 read-modify-write 的原子性。
仅当发现内容没有被修改时，才写会修改后的内容。

#### 2.4.5 多副本和冲突解决
在多副本数据库中，解决更新丢失问题会更难一些，尤其如果多个副本允许并发写入。
可以允许并发写入和异步更新，如果有冲突就用多版本来解决，最后使用用户代码或者特殊数据结构来合并冲突。

### 2.5 写偏序和幻读
假定数据库运行在快照隔离级别下，Alice 和 Bob 同时查询了今天值班情况，发现有多于一人值班，然后先后提交了休假申请，并且都通过了。这并没有违反快照隔离级别，但确实造成了问题——今天没有人值班了。
#### 2.5.1 写偏序的特点
写偏序可以算作是更新丢失的一种泛化。写偏序本质也是 read-modify-write，虽然是涉及多个对象，但本质仍然是**一个事务的写入会导致另外一个事务读取到的信息失效**。
写偏序是由 MVCC 实现的快照隔离级别的特有的缺陷，它是由于读依赖同一个不变的快照引起的。


如果没有办法使用可串行的化的隔离级别，还可以利用数据库提供的（for update）机制进行显式的加锁。

#### 2.5.2 幻读导致写偏序
都可以归纳为以下模式：
1. 通过 select 语句 + 条件过滤出符合条件的所有行。
2. 依赖上述结果，应用侧代码决定是否继续。
3. 如果应用侧决定继续，就执行更改（插入、更新或者删除），并提交事务。
步骤 3 会导致另一个事务的步骤 1 失效，即如果另一个事务此时重新执行 1 的 select 查询，会得到不同的结果，进而影响步骤 2 是否继续的决策。

#### 2.5.3 物化冲突
将幻读转化为数据库物理中实实在在的表和行。但如何对冲突进行合理的物化，很难且易出错。并且，此方法会将解决冲突的细节暴露给了应用层（因为应用层需要感知物化出来的表）。因此，这是最不得以的一种方法，如果数据库本就支持可串行化，则大多数情况下，可以直接使用可串行隔离级别。

## 3 可串行化
可串行化当前主要实现方法：
1. 物理上真正的对所有事务进行串行的执行。
2. **两阶段锁**（2PL，two-phase locking），曾经几十年中唯一的可用选项。
3. **乐观并发控制**（OCC，Optimistic concurrency control），如可串行化的快照隔离。

### 3.1 物理上串行
将所有事务串行的执行

### 3.2 将事务封装成存储过程
线程串行事务系统不允许交互式的多语句事务。用户需要将多语句封装为存储过程一次性提交给数据库。如果数据都在内存中，则存储过程可以被快速的执行。

#### 3.2.1 存储过程的优缺点
对于内存数据库的单线程事务，使用存储过程可以获得不错的吞吐：
1. 内存数据库和存储过程避免了 IO
2. 单线程避免了锁开销

#### 3.2.2 对数据进行分区


### 3.3 两阶段锁
两阶段锁，其实就是将使用锁的过程分为两个阶段，通常称为**扩张阶段**和**收缩阶段**。在扩张阶段（事务的整个执行过程），只会申请锁，在收缩阶段（事务提交时），只会释放锁。从另一个角度理解，每个事务都是访问数据库的一个数据对象子集，扩张阶段就是逐渐拿到该子集所有相关对象的所有权，收缩阶段就是将持有对象所有权释放。而 **S2PL**（Strict 2PL），是在 2PL 的基础上，将写锁保持到事务结束； **SS2PL**（Strong 2PL 或 Strong Strict 2PL）是将读写锁都保持到事务结束。

1. 如果所有事务都没有写入，允许多事务并发读取一个对象。
2. 只要任何一个事务有写入，就会将其**独占**到事务**结束**，不允许其他任何事务**读或写**。

2PL 不允许读写并发、写写并发，而快照隔离却正好相反，即读写互相不阻塞。另一方面，2PL 通过阻止读写并发，可以避免**更新丢失**和**写偏序**等并发问题。

#### 3.3.1 实现
通过对每个对象进行加锁，可以实现单个对象的读写互斥。锁可以处于**共享模式**（shared mode）或者**互斥模式**（exclusive mode），具体来说：

1. 如果某个事务想**读取**一个对象，需要首先获取该对象的**共享锁**。多个事务可以同时获取同一个对象的共享锁。但若某个事务持有该对象的互斥锁，则所有需要读写该对象的事务都得等待。
2. 如果某个事务想**写入**一个对象，需要首先获取该对象的**互斥锁**。任何其他事务都不能同时持有该对象的任何种类的锁。因此，如果该对象上已经有锁，该事务必须先等待其释放。
3. 如果某个事务要先**读取**，再**写入**某个对象，可以先获取其共享锁，然后将其升级为互斥锁。升级互斥锁和获取互斥锁的条件相同。
4. 当某个事务获取锁之后，必须**持有**到事务结束（中止或者提交）。这也是上面两阶段定义的由来。

由于每个对象都要上锁，而一个事务通常会访问多个对象，因此很可能造成**死锁**：多个事务持有锁，并且互相等待对方的锁。

#### 3.3.2 两阶段锁的性能
两阶段锁的实现下，事务的吞吐要比其他弱隔离级别低的多。维护大量锁的开销是一个原因，更重要的原因是**并发性**的降低。
**死锁更加频繁**。尽管基于锁实现的**读已提交**隔离级别会发生死锁，但其发生频次远不如基于 2PL 实现的**可串行化**隔离级别。这也会造成额外的性能问题：死锁被检测到，会引发重试；如果死锁频繁，则会浪费巨大的性能。

#### 3.3.3 谓词锁
和共享锁类似，只不过粒度更大一些。

1. 当某个事务需要读取匹配条件的所有对象时，需要获得该查询条件的**共享谓词锁**。如果有任何其他事务持有该范围内对象的互斥锁，则该事务需要等待其结束。
2. 当某个事务想要写入（插入、更新或者删除）某个对象时，上互斥锁前，需要检查是否有其他事务持有包含该对象的谓词锁。如果有，则该事务需要等待其结束。

谓词锁的一个关键点是，可以锁住一个对象集合，该对象集中的对象甚至不必已存在，但将来可能会被添加。通过谓词锁，2PL 可以解决幻读问题。


#### 3.3.4 索引范围锁
大多数 2PL 的数据库使用了谓词锁的一个近似——**索引范围锁**（index-range locking，也称为 next-key locking）。
通过适当**放大锁住的对象集**来简化谓词锁。如当有多个条件进行**与**的时候，只锁一个条件。
只锁定单个条件的好处在于，你可能在该条件上有索引。则可以将谓词锁，转化为一个在该索引上的范围锁、甚至单个索引对象锁。相比谓词锁，可以更快的判断冲突
这种方式也可以避免幻读和写偏序。相比谓词锁，索引范围锁虽然锁住的范围大，但实现开销较低。但谓词相关的索引并不总是能找到，此时可以简单的退化成整张表上的共享锁。这样做虽然有损性能，但是实现简单且安全。


### 3.4 可串行的快照隔离

数据库中隔离级别的图景：

1. 在光谱一侧，我们有很好的隔离级别——可串行化，但其实现要么性能差（两阶段锁），要么不可扩展（物理上串行执行）。
2. 在光谱另一个侧，我们有一些相对较弱的隔离级别，它们性能较好，但会有各种竞态条件（更新丢失、写偏序、幻读等等）。

#### 3.4.1 乐悲观并发控制
SSI 是一种**乐观**（_optimistic_）的并发控制机制，类比多线程编程中的乐观锁。其相应哲学是，当存在潜在危险时，仍然不做任何检查去大胆的执行。当事务提交时，再进行冲突检测，如果存在冲突，则回退重试。
#### 3.4.2 基于失效前提的决策
**读取 - 决策 - 写入**。
1. 读取：事务首先从数据库中读取到一些数据。
2. 决策：考察读到的数据，做出某种决策。
3. 写入：将对应决策造成结果写回数据库。

如何检测前提是否失效
1. 在读取时，要检测读到的数据版本是否为最新版本。（读之前，可能有未提交的写入）
2. 在写入时，要检测写入的数据是否覆盖了其他事务的读取。（读之后，可能发生了写入）

#### 3.4.3 MVCC 读取的过时检测
快照隔离通常通过**多版本并发控制**（MVCC）来实现。当事务基于 MVCC 数据库中的某个一致性的快照进行读取时，会忽略其他事务潜在的任何修写入。

**读取时，检测写读冲突，延到提交时，看有冲突的写入是否已提交**。


#### 3.4.4 影响之前读取的写入检测
在一个事务写入某对象时，需要检测是否该数据被另一个事务读取过
**在写入时，利用之前在对应索引范围记下的读取事务编号记录冲突，在提交时，看有冲突的读取是否已经提交**。

#### 3.4.5 可串行快照隔离的性能
和 2PL 相比，SSI 的最大优点是，不会通过锁来阻塞有依赖关系的事务并发执行。SSI 就想运行在快照隔离级别一样，读不阻塞写，写不阻塞读。只是追踪记录，在提交时决定是否提交或重试。这种设计是的查询延迟更可预测。尤其是，只读事务可以工作在一致性快照上，而不受影响，这对读负载很重的场景很有吸引力。