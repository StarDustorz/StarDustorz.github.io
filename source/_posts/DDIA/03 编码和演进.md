---
title: "[DDIA] 编码和演进"
date: 2023-05-28
tags:
  - DDIA
categories:
  - 阅读笔记
  - DDIA
published: true
toc: "true"
comments: "true"
description:
---
>编码主要涉及两方面问题：如何编码能够节省空间、提高性能; 
 如何编码以适应数据的演化和兼容。

<!--more-->


所有涉及跨进程通信的地方，都需要对数据进行**编码**（**Encoding**），或者说**序列化**（**Serialization**）。因为持久化存储和网络传输都是面向字节流的。序列化本质上是一种“**降维**”操作，将内存中高维的数据结构降维成单维的字节流，于是底层硬件和相关协议，只需要处理一维信息即可。
**编码主要涉及两方面问题：**
1. 如何编码能够节省空间、提高性能。
2. 如何编码以适应数据的演化和兼容。

## 1 数据编码的格式
### 1.1 JSON、XML 及其二进制变体
JSON，XML 和 CSV 属于常用的**文本编码**格式，其好处在于肉眼可读，坏处在于不够紧凑，占空间较多。
除了不够紧凑外，**文本编码（text encoding）** 还有以下缺点：
1. 对**数值类型支持不够**。CSV 和 XML 直接不支持，万物皆字符串。JSON 虽区分字符串和数值，但是不进一步区分细分数值类型。可以理解，毕竟文本编码嘛，主要还是面向字符串。
2. **对二进制数据支持不够**。支持 Unicode，但是对二进制串支持不够，可能会显示为乱码。虽然可以通过 Base64 编码来绕过，但有点做无用功的感觉。
3. **XML 和 JSON 支持额外的模式**。模式会描述数据的类型，告诉你如何理解数据。配合这些模式语言，虽然可以让 XML 和 JSON 变得强大，但是大大增加了复杂度。
4. **CSV 没有任何模式**。

#### 1.1.1 二进制编码
JSON 有很多二进制变种：MessagePack、BSON、BJSON、UBJSON、BISON 和 Smile 等。

### 1.2 Thrift 和 Protocol Buffers
在编码前都需要由接口定义语言（IDL）来描述模式：
IDL 是编程语言无关的，可以利用相关代码生成工具，可以将上述 IDL 翻译为指定语言的代码。即，集成这些生成的代码，无论什么样的语言，都可以使用同样的格式编解码。
这也是不同 service 可以使用不同编码语言，且能够互相通信的基础。


#### 1.2.1 字段标号和模式演变
**模式**，即有哪些字段，字段分别为什么类型。
在模式发生改变后，需要：
1. **向后兼容**：新的代码，在处理新的增量数据格式的同时，也得处理旧的存量数据。
2. **向前兼容**：旧的代码，如果遇到新的数据格式，不能 crash。
3. ProtoBuf 和 Thrift 是怎么处理？ 
	1. **字段标号** + **限定符**（optional、required） 
	2. 向后兼容：新加的字段需为 optional。这样在解析旧数据时，才不会出现字段缺失的情况。 
	3. 向前兼容：字段标号不能修改，只能追加。这样旧代码在看到不认识的标号时，省略即可。

#### 1.2.2 数据类型和模式演变
- 修改数据类型比较麻烦：只能够在相容类型中进行修改。
- 如不能将字符串修改为整形，但是可以在整形内修改：32 bit 到 64 bit 整形。
- ProtoBuf 没有列表类型，而有一个 repeated 类型。其好处在于**兼容数组类型**的同时，支持将可选（optional）**单值字段**，修改为**多值字段**。修改后，旧代码在看到新的多值字段时，只会使用最后一个元素。


### 1.3 模式的优点
模式的本质是显式类型约束， 先有模式，再有数据
**基于显式定义二进制编码优点有：**
1. 省去字段名，从而更加紧凑。
2. 模式是数据的注释或者文档，并且总是最新的。
3. 数据模式允许不读取数据，仅比对模式来做低成本的兼容性检查。
4. 对于静态类型来说，可以利用代码生成做编译时的类型检查。
## 2 几种数据流模式
- 数据可以以很多种形式从一个系统流向另一个系统，但不变的是，流动时都需要编码与解码。
- 在数据流动时，会涉及编解码双方模式匹配问题
- 几种进程间典型的数据流方式：
	- 通过数据库
	- 通过服务调用
	- 通过异步消息传递

### 2.1 数据库
1. **只由同一个进程访问**。则数据库可以理解为该进程向将来发送数据的中介。
2. **由多个进程访问**。则多个进程可能有的是旧版本，有的是新版本，此时数据库需要考虑向前和向后兼容的问题。

对于应用程序，可能很短时间就可以由旧版本替换为新版本。但是对于数据，旧版本的代码写入的数据量，经年累月，可能很大。在变更了模式之后，由于这些旧模式的数据量很大，全部更新对齐到新版本的代价很高。
这种情况我们称之为：**数据的生命周期超过了其对应代码的生命周期**。
在读取时，数据库一般会对缺少对应列的旧数据：
1. 填充新版本字段的**默认值**（default value）
2. 如果没有默认值则填充**空值**（nullable）
后返回给用户。一般来说，在更改模式时（比如 alter table），数据库不允许增加既没有默认值、也不允许为空的列。

有时候需要对数据库做备份到外存。在做备份（或者说快照）时，虽然会有不同时间点生成的数据，但通常会将各种版本数据转化、对齐到最新版本。毕竟，总是要全盘拷贝数据，那就顺便做下转换好了。

### 2.2 经由服务的数据流：REST 和 RPC
- 通过网络通信时，通常涉及两种角色：服务器（server）和客户端（client）。
- 通常来说，暴露于公网的多为 HTTP 服务，而 RPC 服务常在内部使用。
- 服务器也可以同时是客户端：
	1. 作为客户端访问数据库。
	2. 作为客户端访问其他服务。
- 对于后者，是因为我们常把一个大的服务拆成一组功能独立、相对解耦的服务，这就是 **面向服务的架构（service-oriented architecture，SOA）**，或者最近比较火的**微服务架构（micro-services architecture）**。
- 服务在某种程度上和数据库类似：允许客户端以某种方式存储和查询数据。但不同的是，数据库通常提供某种灵活的查询语言，而服务只能提供相对死板的 API。

#### 2.2.1 web 服务
两种设计 HTTP API 的方法：REST 和 SOAP。
1. **REST 并不是一种协议，而是一种设计哲学**。它强调简单的 API 格式，使用 URL 来标识资源，使用 HTTP 的动作（GET、POST、PUT、DELETE）来对资源进行增删改查。由于其简洁风格，越来越受欢迎。
2. SOAP 是基于 XML 的协议。虽然使用 HTTP，但目的在于独立于 HTTP。现在提的比较少了。

#### 2.2.2 RPC 面临的问题
1. 本地函数调用要么成功、要么不成功。但是 RPC 由于经过网络，可能会有各种复杂情况，比如请求丢失、响应丢失、hang 住以至于超时等等。因此，可能需要重试。
2. 如果重试，需要考虑**幂等性**问题。因为上一次的请求可能已经到达了服务端，只是请求没有成功返回。那么多次调用远端函数，就要保证不会造成额外副作用。
3. 远端调用延迟不可用，受网络影响较大。
4. 客户端与服务端使用的编程语言可能不同，但如果有些类型不是两种语言都有，就会出一些问题
#### 2.2.3 RPC 当前方向
1. 比如局域网的网络通常比较快速、可控。
2. 多次调用，使用幂等性来解决。
3. 跨语言，可以使用 RPC 框架的 IDL 来解决。

#### 2.2.4 数据编码和 RPC 的演化
通过服务的数据流通常可以假设：所有的服务端先更新，然后客户端再更新。因此，只需要在请求里考虑后向兼容性，在响应中考虑前向兼容性：
1. Thrift、gRPC（Protobuf）和 Avro RPC 可以根据编码格式的兼容性规则进行演变。
2. RESTful API 通常使用 JSON 作为请求响应的格式，JSON 比较容易添加新的字段来进行演进和兼容。
3. SOAP 按下不表。
对于 RPC，服务的兼容性比较困难，因为一旦 RPC 服务的 SDK 提供出去之后，你就无法对其生命周期进行控制：总有用户因为各种原因，不会进行主动升级。因此可能需要长期保持兼容性，或者提前通知和不断预告，或者维护多个版本 SDK 并逐渐对早期版本进行淘汰。
对于 RESTful API，常用的兼容方法是，将版本号做到 URL 或者 HTTP 请求头中。


### 2.3 经由消息传递的数据流
介于数据库和 RPC 间的**异步消息系统**：一个存储（消息 broker、消息队列来临时存储消息）+ 两次 RPC（生产者一次，消费者一次）。
与 RPC 相比，使用消息队列的优点：
1. 如果消费者暂时不可用，可以充当暂存系统。
2. 当消费者宕机重启后，自动地重新发送消息。
3. 生产者不必知道消费者 IP 和端口。
4. 能将一条消息发送给多个消费者。
5. 将生产者和消费者解耦。

#### 2.3.1 消息队列
消息队列的**送达保证**因实现和配置而异，包括：
1. **最少一次（at-least-once）**：同一条数据可能会送达多次给消费者。
2. **最多一次（at-most-once）**：同一条数据最多会送达一次给消费者，有可能丢失。
3. **严格一次（exactly-once）**：同一条数据保证会送达一次，且最多一次给消费者。