---
title: 计算机网络
date: 2021-06-12 19:29:17
tags:
  - 计算机网络
categories:
  - Basic
published: false
toc: "true"
comments: "true"
description: 
---

## 1 网络模型与协议
### 1.1 网络模型分层解析
- `OSI七层模型`：应用（DNS，HTTP，SMTP，FTP）， 表示 ，会话，传输（TCP、UDP），网络（IP ICMP），数据链路，物理
- `TCP/IP`：
	- `应用层`：工作在用户态，往下都在内核态；主要协议有：HTTP、FTP、Telnet、DNS、SMTP等
	- `传输层`：为用层提供网络支持；主要协议有 TCP&UDP，加上 TCP 头部
	- `网络层`：实现实际的传输功能；主要协议有 IP 协议，加上 IP 头部
	- `网络接口层`：链路级别， IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上
### 1.2 常见协议报文格式
- `TCP首部格式`（源/目标端口号; 序列号(随机数,避免乱序); 确认号(避免丢包); 首部长度; 关键字; 窗口; 校验和）
- `UDP`（端口号 长度 校验和） 包 最大为64k
- `IP报文`（版本 首部长度 服务类型 总长度 生存时间 校验和 ip地址
- `TCP`：TCP`最大报文段长度`（MSS，536字节），超过就分块（TCP Segment） IP：加上IP头成为IP报文，如果超过`MTU`（1500字节）就分片

## 2 HTTP & HTTPS
### 2.1 HTTP  
#### 2.1.1 HTTP 基本概念
##### 2.1.1.1 HTTP 是什么？
超文本传输协议
##### 2.1.1.2 HTTP 常见状态码
- 1xx：**指示信息**--表示请求已接收，继续处理；
- 2xx：**成功**--表示请求已被成功接收、理解、接受；200—OK 204--请求收到，但返回信息为空 206--服务器已经完成了部分用户的GET请求
- 3xx：**重定向**--信息不完整需要进一步补充；300 请求资源在多处可得到。301—永久重定向，隐式重定向。302 临时重定向，显示重定向。 304—请求的资源没有改变，可以使用缓存。
- 4xx：**客户端错误**--请求有语法错误或请求无法实现； 401---未授权 403—禁止访问。 404 –找不到。409：对当前资源状态，请求不能完成
- 5xx：**服务器端错误**--服务器未能实现合法的请求；500内部服务器错误，501未实现，502网关错误，503服务不可用，504 网关超时
##### 2.1.1.3 HTTP 常见字段
- _Host_ 字段：指定服务器域名
- _Content-Length 字段_：表明本次回应的数据长度
- _Connection 字段_：要求服务器使用「HTTP 长连接」机制，Keep-Alive
- _Content-Type 字段_：本次数据格式
- _Content-Encoding 字段_：数据的压缩方法
#### 2.1.2 GET 和 POST 有什么区别
- `RFC 规范`：GET 的语义是从服务器 _获取指定的资源_；POST 的语义是根据请求负荷（报文body）对 _指定的资源做出处理_
- GET 方法是安全、幂等、可被缓存的
- POST 不安全，不幂等，（大部分实现）不可缓存
#### 2.1.3 HTTP缓存技术
- `强制缓存`：Cache-Control 和 Expires 控制资源在客户端的缓存有效期
- `协商缓存`：_Last-Modified_ 资源没修改，响应 HTTP 304 走缓存 ; _ETag_,判断资源有没有变化
#### 2.1.4 HTTP特性
- 优点：简单，灵活容易拓展，跨平台
- 缺点：明文传输，无状态，不安全
- 性能：_长连接_；_管道网络传输_：当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「**队头阻塞**」
### 2.2 HTTPS
#### 2.2.1 HTTPS 的区别
- `加密传输`：在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议
	- 混合加密：**对称加密**和**非对称加密**结合，非对称加密交换会话秘钥
	- _摘要算法 + 数字签名_：计算内容的指纹
- `连接建立`：需进行 SSL/TLS 的握手过程
	- 基于 RSA 的 TLS 握手过程
		- _ClientHello_：客户端发起加密通信请求，发送（一个随机数，TLS 版本，加密算法）给服务器
		- _SeverHello_：服务端回应，发送随机数和数字证书
		- _客户端回应_：取出公钥加密报文，再发送随机数过去，握手介绍，生成摘要
		- _服务器的最后回应_： 计算出本次通话的会话秘钥，变更加密通信算法
- `默认端口`：HTTP 默认端口号是 `80`，HTTPS 默认端口号是 `443`
- `可信身份`：向 CA（证书权威机构）申请数字证书
	- 把公钥注册到 CA，客户端拿到`数字证书`（公钥+数字签名）后用 CA 的公钥验证
#### 2.2.2 HTTPS 怎么保证数据完整性
- TLS 在实现上分为**握手协议**和**记录协议**两层：
- TLS 握手协议负责协商加密算法和生成对称密钥
- TLS 记录协议负责保护应用程序数据并验证其完整性和来源
	- 消息被分割成多个较短的片段,然后分别对每个片段进行压缩
	- **加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证**。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。
	- 经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。
	- 经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。

#### 2.2.3 HTTPS 一定安全吗
- 中间人攻击：客户端接受了中间人服务器的证书，然后中间人分别和客户端服务器 TLS 握手并转发。
- HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。
- 抓包：使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。
### 2.3 HTTP 1.1&2.0 & 3.0 演变
#### 2.3.1 HTTP/1.1 相比 HTTP/1.0
- 优点：
	- 使用`长连接`的方式改善了 HTTP/1.0 短连接造成的性能开销。
	- 支持管道（pipeline）网络传输
- 缺点：
	- 请求 / 响应头部（Header）没压缩，造成浪费
	- 队头阻塞
	- 没有请求优先级控制
	- 服务器只能被动响应
#### 2.3.2 HTTP/2 优化
- _头部压缩_：消除重复的部分,HPACK算法维护头信息表和字段的映射
- _二进制格式_：头信息和数据体都是二进制，并且统称为帧（frame）
- _并发传输_：引入了 Stream，针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，可以并行交错地发送请求和响应
- _服务器推送_：**双方都可以建立 Stream**，服务器可以主动向客户端发送消息
- 问题：基于 TCP 传输数据，需要按序到达缓冲区才能从内核取数据，一旦丢包就会阻塞所有请求这就是 HTTP/2 `队头阻塞`问题。
#### 2.3.3 HTTP/3 优化
-  **把 HTTP 下层的 TCP 协议改成了 UDP**
- 基于 UDP 的 **QUIC 协议**实现可靠传输：就是把 TCP 的校验放到应用层实现

### 2.4 HTTP & RPC
- TCP 的特点 **面向连接**、**可靠**、基于**字节流**
	- 没有消息边界，于是会加上信息头，以及包长度
	- 需要协议约定消息体格式
- 服务发现：HTTP 只要知道网址就可以 DNS 解析出 IP 地址和 80 端口；RPC 需要之间服务
- 传输的内容：RPC 定制化程度高，序列化协议多，性能稍好
- `gRPC` 底层都直接用的 `HTTP/2`
- HTTP/2 是 2015 年出来的，有惯性
## 3 TCP & UDP
### 3.1 简介与区别
- TCP 头部
	- ![[Pasted image 20230904012336.png]]
	- _ACK_：该位为 `1` 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 `SYN` 包之外该位必须设置为 `1` 。
	- _RST_：该位为 `1` 时，表示 TCP 连接中出现异常必须强制断开连接。
	- _SYN_：该位为 `1` 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。
	- _FIN_：该位为 `1` 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 `FIN` 位为 1 的 TCP 段。
- `为什么需要 TCP`？ IP 层不可靠，需要传输层确保接收端接收的网络包是**无损坏、无间隔、非冗余和按序的。**
- `什么是 TCP`：**面向连接的、可靠的、基于字节流**的传输层通信协议。
- 什么是 TCP 连接？用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 `Socket、序列号和窗口大小`称为连接。
	- 连接数量限制：文件描述符限制，内存限制，单机最大 TCP 连接数，约为 `2` 的 `48` 次方

- `UDP 和 TCP 有什么区别呢？分别的应用场景是？`
	- *连接*：UDP 不需要连接，即刻传输数据
	- *服务对象*：TCP 是一对一的两点服务；UDP 支持一对一、一对多、多对多的交互通信
	- *可靠性*：UDP 尽最大努力交付，不保证可靠交付数据
	- _拥塞控制、流量控制_：网络拥堵也不影响 UDP 发送速率
	- _传输方式_：TCP 是流式传输，没有边界；UDP 是一个包一个包的发送
	- _分片不同_：TCP 大于 MSS(536字节) 在传输层分片；UDP 大于 MTU(1500字节)在 IP 层分片
	- _使用场景_：TCP 用于文件传输，HTTP 等；UDP 用于视频，广播，`DNS` 等
- `有一方突然断电或者崩溃`
	- 两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。
	- 服务端是**无法感知到的**，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，**服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态**，直到服务端重启进程。
	- 所以，我们可以得知一个点，在没有使用 TCP 保活机制且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED 状态，并不代表另一方的连接还一定正常。
	- **在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手**。所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。
	- 如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 **TCP 保活时间会被重置**，等待下一个 TCP 保活时间的到来。
	- 如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，**TCP 会报告该 TCP 连接已经死亡**。
	- `在客户端主机宕机后`，服务端向客户端发送的报文会得不到任何的响应，在一定时长后，服务端就会触发**超时重传**机制，重传未得到响应的报文。
		- 服务端重传报文的过程中，客户端主机重启完成后，客户端的内核就会接收重传的报文，然后根据报文的信息传递给对应的进程：
		- 如果客户端主机上**没有**进程监听该 TCP 报文的目标端口号，那么客户端内核就会**回复 RST 报文，重置该 TCP 连接*；
		- 如果客户端主机上**有**进程监听该 TCP 报文的目标端口号，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会**回复 RST 报文，重置该 TCP 连接**。
		- 所以，只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接。
### 3.2 TCP
#### 3.2.1 如何保证可靠？
#### 3.2.2 三次握手
- _目的_:
	- `防止旧的重复连接初始化造成混乱`：网络阻塞重发建立连接请求
	- `同步双方的初始序列号`
	- `避免资源浪费`：避免建立冗余链接
- _过程_：控制位: ACK(确认应答); RST(强制断开); SYN(建立连接); FIN(断开连接)
	- 建立连接时，客户端随机初始化序列号（**client-isn**），**SYN 标志为1**，表示 SYN 报文，发送到服务器，并进入**SYN-SENT状态**，等待服务器确认；
	- 服务器收到SYN报文，也随机初始化自己的序列号（server-isn），填入序号，然后在**确认应答号字段**填入 **client-isn+1**，然后将**SYN和ACK置为1**，发送给客户端。此时服务器进入**SYN_RECV状态**；
	- 客户端收到服务器报文后，向服务器回应最后一个应答报文，ACK=1，确认应答号填入server-isn+1，发送给服务端，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。**此次可以携带数据**
	- `netstat -napt` 查看连接状态
- _握手丢失_：
	- 第一次：客户端超时重传
	- 第二次：服务端超时重传
	- 第三次：服务端超时重传
- _SYN 攻击_：
	- Linux 内核会维护两个队列:半连接队列，全连接队列
	- SYN 攻击就是打满半连接队列
	- 解决：
		- 调大 netdev_max_backlog，保存数据包的队列
		- 增大 TCP 半连接队列
		- 开启 tcp_syncookies，绕开 SYN 半连接建立连接
		- 减少 SYN+ACK 重传次数，加快处于 SYN_REVC 状态的 TCP 连接断开
#### 3.2.3 四次挥手
- _目的_：客户端发送了FIN连接释放报文后，服务器加入close-wait状态，是为了`让服务器发送还未传送完毕的数据`，传送完毕之后，服务器会发送FIN连接释放报文;
- _过程_：
	- 客户端发送一个 TCP 首部 `FIN` 标志位被置为 `1` 的报文，也即 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
	- 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSE_WAIT` 状态。
	- 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
	- 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
	- 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态
	- 服务端收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。
	- 客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。
- _TIME_WAIT状态_： 
	- 防止历史连接中的数据，被后面相同四元组的连接错误的接收；
	- 保证「被动关闭连接」的一方，能被正确的关闭；确保最后的 ACK 到达。
	- MSL：**报文最大生存时间**，2MSL是允许报文丢失一次
	- 过多会占用系统资源和端口资源；复用**TIME_WAIT**的 socket；超过 18000 直接重置；让客户端去断开，承受**TIME_WAIT**
	- 出现大量TIME_WAIT状态？ 没有用长连接；长连接超时；
#### 3.2.4 重传机制
- TCP 针对数据包丢失的情况，会用**重传机制**解决
- *超时重传*：
	- 触发场景：数据包丢失，确认应答丢失
	- 超时时间：RTO 略大于 RTT `包往返时间`
	- 每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送
- _快速重传_：`三次重复的 ACK` 触发，但是不知道要重传一个还是所有
- _SACK 方法_：`选择性确认`，将已收到的数据的信息发送给「发送方」
- _D-ACK_：Duplicate 使用了 SACK 来告诉「发送方」有哪些数据被`重复接收`了，可以知道是数据包丢了还是 ACK 包丢了
#### 3.2.5 滑动窗口
- _窗口_：一个缓存空间，是无需等待确认应答，而可以继续发送数据的`最大值`
- TCP 报文中的 Windows 字段控制
- 四部分：发送已确认，发送未确认，未发生但是在处理范围内，未发送范围外
#### 3.2.6 流量控制
- 让「发送方」根据「接收方」的`实际接收能力`控制发送的数据量，让接受方处理的过来
- _窗口关闭_：可能导致死锁。收到零窗口通知，就启动`持续计时器`，如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文。
- _糊涂窗口综合症_：接收方太忙，来不及处理，窗口越来越小
	- 接收方不通告小窗口：小于 MSS 或者 缓存空间/2 ，通告窗口为 0
	-  发送方避免发送小数据：Nagle 算法，除非窗口够大且数据够多并且收到 ack，否则囤积数据
#### 3.2.7 拥塞控制
- 避免「发送方」的数据填满整个网络。发送方维护一个叫`拥塞窗口`（cwnd）的状态变量
- _慢开始与拥塞避免_：发送的最初执行`慢开始`，令cwnd=1，发送方只能发送一个报文段，当收到确认后，将cwnd`加倍`，设置一个`慢开始门限` ssthresh，当cwnd>=ssthresh时进入`拥塞避免`，按照`线性`增长方式增加，线性增长达到`网络拥塞`时，则令ssthresh=cwnd/2，然后重新执行慢开始。
- _快重传与快恢复_：每次接收到报文段都对最后一个已收到的的有序报文段进行`确认`。在发送方，如果收到`三个重复确认`，那么可以知道下一个报文段丢失，此时执行快重传，`立即重传下一个报文段`。在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行`快恢复`，令ssthresh = cwnd/2，cwnd = ssthresh 。直接进入`拥塞避免`。
#### 3.2.8 拾遗
- 查看 TCP 连接信息的命令？ `netstat -napt`

## 4 IP协议
### 4.1 基本认识
- 处于第三层，也就是**网络层**：实现主机与主机之间的通信
- DNS：解析 IP 地址
- ARP：获取下一跳的 MAC 地址，通过广播 ARP 请求与 ARP 响应实现
- ICMP：**互联网控制报文协议**，确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等
### 4.2 Ping
- _工作原理_：基于 ICMP 协议工作
	- **发送ICMP请求**：Ping工具向目标主机发送一个ICMP请求数据包（通常是一个特殊的Echo请求），请求目标主机进行响应。
	- **目标主机响应**：目标主机接收到ICMP请求后，会发送一个ICMP响应数据包（Echo响应）回给Ping工具。
	- **测量延迟**：Ping工具在发送ICMP请求和接收ICMP响应之间测量时间，从而计算出往返时间（Round-Trip Time，RTT）。RTT表示数据从Ping工具发送到目标主机并返回所需的时间，用于衡量网络的延迟。
	- **报告结果**：Ping工具会显示目标主机的IP地址、RTT和其他统计信息，以便用户可以了解网络连接的质量和性能。
- ping 127.0.0.1
	- **127 开头的都属于回环地址**：目标 IP 是回环地址是会选择本地网卡
- ping 0.0.0.0
	- 会失败，因为这是无效的目标地址

## 5 DNS协议
1. DNS 解析过程，端口号？
	1. 客户端发出 DNS 请求到`本地 DNS 服务器`
	2. `本地 DNS 服务器`如果没有对应的缓存，就去访问`根域名服务器`
	3. 根域名返回网址对应的`顶级域名服务器`地址
	4. `本地 DNS 服务器`请求`顶级域名服务器`，获得`权威 DNS 服务器`的地址
	5. `本地 DNS 服务器`请求`权威 DNS 服务器`，获取 IP 地址
	6. 返回给客户端，客户端和目标建立连接
2. DNS 使用什么传输层协议？
	1. 多数情况下使用 UDP
	2. 响应的大小超过UDP数据包的`最大限制`和`进行区域传输`（Zone Transfer）时 使用 TCP

## 6 拾遗
### 6.1 键入网址到网页显示，期间发生了什么？
1. `解析 URL`：确定了 Web 服务器和文件名，生成 HTTP 请求
2.  `查询服务器域名对应的 IP 地址`：按照浏览器缓存，操作系统缓存和 hosts 的顺序查询，如果没有就去请求本地 DNS 服务器，进入 `DNS 解析流程`
3. 应用程序（浏览器）通过调用 Socket 库，来委托`协议栈`工作
	1. TCP 可靠传输   `三次握手`
	2. IP 远程定位，将数据封装成**网络包**发送给通信对象
	3. MAC 两点传输，在 IP 头部的前面加上 **MAC 头部**，包含接收方和发送方的 MAC 地址等信息。
4. 出口`网卡`：在其**开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列**
5. 交换机：**根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口**  `MAC 层`
6. 路由器：根据 MAC 头部后方的 `IP` 头部中的内容进行包的转发操作
7. 拆包，获取数据内容，交给浏览器渲染页面，然后`四次挥手`断开连接



### 6.2 TCP 报文头部
![[Pasted image 20230903203817.png]]

- 首先，**源端口号**和**目标端口**号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。
- 接下来有包的**序**号，这个是为了解决包乱序的问题。
- 还有应该有的是**确认号**，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决丢包的问题。
- 接下来还有一些**状态位**。例如 `SYN` 是发起一个连接，`ACK` 是回复，`RST` 是重新连接，`FIN` 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。
- 还有一个重要的就是**窗口大小**。TCP 要做**流量控制**，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。
- 除了做流量控制以外，TCP还会做**拥塞控制**，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。

### 6.3 网络报文图
![[Pasted image 20230903204154.png]]



### 6.4 网络攻击
#### 6.4.1 CSRF攻击
- CSRF（Cross-Site Request Forgery，跨站请求伪造）攻击，利用了用户已经在某个网站上进行了`身份验证`的情况下，对用户在另一个网站上的操作进行`伪造请求`，以执行未经授权的操作。
- 防范：
	- **使用HTTP-only Cookie**
	- **使用验证码**：敏感操作输入验证码
	- 限制敏感操作
	- **使用CSRF令牌**：为了确保请求是合法的，服务器可以生成一个唯一的CSRF令牌，并将其嵌入到表单或请求中
	- **定期审查和更新安全策略**
	- **同源策略**CORS：浏览器的同源策略要求网页只能从同一来源加载资源。通过使用同源策略，浏览器可以限制对不同网站的跨站请求，从而减少CSRF攻击的可能性。

#### 6.4.2 XSS攻击
- XSS（Cross-Site Scripting，跨站脚本攻击），将恶意脚本注入到网页中，以便在受害者的浏览器上执行恶意代码。XSS攻击可能导致盗取用户的敏感信息、劫持用户会话、操纵网页内容等恶意行为。
- 防范：
	- **输入验证和过滤**：在应用程序接受用户输入时，对输入数据进行验证和过滤。确保只接受预期的输入，并拒绝包含恶意脚本的输入。这可以通过编码规范、白名单过滤和黑名单过滤来实现。
	- **转义输出**：在将用户输入插入到HTML、JavaScript或其他上下文中时，确保对用户输入进行适当的转义。这可以防止浏览器将用户输入解释为可执行的脚本。
	- **CORS策略**：使用CORS（Cross-Origin Resource Sharing，跨源资源共享）策略来限制其他域名的网页访问您的网页，从而减少恶意脚本的机会。
	- **HTTP头设置**：设置HTTP头中的安全标头，如Content Security Policy（CSP）和X-XSS-Protection，以帮助阻止XSS攻击。

