---
title: 操作系统
date: 2021-06-12 19:29:17
tags:
  - 操作系统
categories:
  - Basic
published: false
toc: "true"
comments: "true"
description: 
---

## 1 硬件结构
- 什么是中断？
	- 中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。
- 什么是软中断？
	- 为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」
	- **上半部直接处理硬件请求，也就是硬中断**，主要是负责耗时短的工作，特点是快速执行；
	- **下半部是由内核触发，也就说软中断**，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；

## 2 内存管理
### 2.1 虚拟内存
- _虚拟地址_： 隔离不同进程，给每个进程独立的虚拟地址，并通过内存管理单元 MMU 映射到物理地址。
- _虚拟内存_：让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。  因为申请了不代表会用满，局部性原理
### 2.2 内存分段
- 程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。**不同的段是有不同的属性的，所以就用分段（_Segmentation_）的形式把这些段分离出来。**
- 分段机制下的虚拟地址由两部分组成，**段选择因子**和**段内偏移量**。
	- **段选择子**就保存在段寄存器里面。段选择子里面最重要的是**段号**，用作段表的索引。**段表**里面保存的是这个**段的基地址、段的界限和特权等级**等。
	- 虚拟地址中的**段内偏移量**应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。
- 缺点：**内存碎片**，内存交换效率低
### 2.3 内存分页
- **分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小**。这样一个连续并且尺寸固定的内存空间，我们叫**页**（_Page_）。在 Linux 下，每一页的大小为 `4KB`。
- **内存管理单元** （_MMU_）将虚拟内存地址转换成物理地址
- 分页机制下，虚拟地址分为两部分，**页号**和**页内偏移**。页号作为页表的索引，**页表**包含物理页每页所在**物理内存的基地址**，这个基地址与页内偏移的组合就形成了物理内存地址
- _多级页表_：将页表（一级页表）分为 `1024` 个页表（二级页表），每个表（二级页表）中包含 `1024` 个「页表项」，形成**二级分页**。
- _快表 TLB_： 页表缓存、转址旁路缓存、快表; 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。
### 2.4 段页式
- 先将程序划分为多个有逻辑意义的段，再把每个段划分为多个页
- 地址结构就由**段号、段内页号和页内位移**三部分组成
- 每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号
### 2.5 Linux 内存布局
- **Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理**。于是 Linux 就把所有段的基地址设为 `0`，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。
- Linux 系统中虚拟空间分布可分为**用户态**和**内核态**两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。
## 3 进程管理
### 3.1 进程基础知识
> **进程是若干个活动的执行流以及各类相关资源的总称**，这些资源包括内核结构、地址空间（内存），寄存器等
> 运行可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个**运行中的程序，就被称为「进程」（Process）**
#### 3.1.1 进程的状态
- 运行状态（_Running_）：该时刻进程占用 CPU；
- 就绪状态（_Ready_）：可运行，由于其他进程处于运行状态而暂时停止运行；
- 阻塞状态（_Blocked_）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；
- 创建状态（_new_）：进程正在被创建时的状态；
- 结束状态（_Exit_）：进程正在从系统中消失时的状态；
#### 3.1.2 进程的控制结构
- 用**进程控制块**（_process control block，PCB_）数据结构来描述进程
- _PCB 是进程存在的唯一标识_
	- `进程描述信息`：
		- 进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；
		- 用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；
	- `进程控制和管理信息`：
		- 进程当前状态，如 new、ready、running、waiting 或 blocked 等；
		- 进程优先级：进程抢占 CPU 时的优先级；
	- `资源分配清单`：
		- 有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。
	- `CPU 相关信息`：
		- CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。
#### 3.1.3 进程的上下文切换
- **一个进程切换到另一个进程运行，称为进程的上下文切换**。
- _CPU 上下文切换_：把保存前一个任务的 CPU 上下文（CPU 寄存器和程序计数器），加载新任务的上下文到这些寄存器和程序计数器，再跳转到程序计数器所指的新位置，运行新任务
- _进程的上下文切换_ :不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。

### 3.2 进程通信
- 每个进程的用户地址空间都是独立的，进程之间要通信必须通过内核。
- _管道_：对于匿名管道，它的通信范围是存在父子关系的进程，通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。
- _消息队列_：保存在内核中的消息链表
- _共享内存_：拿出一块虚拟地址空间来，映射到相同的物理内存中
- _信号量_：主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据
- _Socket_：跨网络与不同主机上的进程之间通信，针对 TCP、UDP、本机间的模型
-  _死锁_
	- 条件：互斥，占用和等待，不可抢占，循环等待
	- 忽略；检测和恢复，预防，避免

### 3.3 线程
- _线程是进程当中的一条执行流程。_ 同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套`独立的寄存器和栈`，这样可以确保线程的控制流是相对独立的。
- _线程与进程的比较_
	- 进程是`资源（包括内存、打开的文件等）分配`的单位，线程是` CPU 调度`的单位
	- 进程拥有一个完整的`资源平台`，而线程只独享必不可少的资源，如`寄存器和栈`
	- 线程能减少并发执行的`时间和空间开销`
		- 线程的创建时间比进程快，不涉及资源管理
		- 线程的终止时间比进程快，释放的资源少
		- 同一个进程内的线程切换比进程切换快，不需要切换页表
		- 共享内存和文件资源，数据交互效率更高
- _线程的上下文切换_：两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的`私有数据`、寄存器等不共享的数据
- _线程的实现_：
	- **用户线程（_User Thread_）**：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；
	- **内核线程（_Kernel Thread_）**：在内核中实现的线程，是由内核管理的线程；
	- **轻量级进程（_LightWeight Process_）**：在内核中来支持用户线程；
- _线程控制块TCB_ ：线程状态信息（PC、栈指针、寄存器）
- _线程通信_：共享变量等，主要关注竞争共享资源的问题
### 3.4 协程
- 不是进程也不是线程，而是一个特殊的函数。协程是属于线程的。协程程序是在线程里面跑的，因此协程又称微线程和纤程等
	- 比线程更轻量级，协程完全由程序控制（也就是在用户态执行）
	- 没有线程切换的开销
	- 和多线程比，线程数量越多，协程的性能优势就越明显

## 4 调度算法
### 4.1 进程调度算法
- _先来先服务调度算法_：每次从就绪队列选择最先进入队列的进程
- _最短作业优先调度算法_：优先选择运行时间最短的进程来运行
- _高响应比优先调度算法_：把「响应比优先级」最高的进程投入运行  服务时间+等待时间/服务时间
- _时间片轮转调度算法_：每个进程被分配一个时间段
- _最高优先级调度算法_：从就绪队列中选择最高优先级的进程进行运行
- _多级反馈队列调度算法_：设置多个优先级队列，优先级越高时间片越短，在当前队列没执行完就去下一级队尾
### 4.2 内存页面置换算法
- 当 CPU 访问的页面不在物理内存时，便会产生一个`缺页中断`，请求操作系统将所缺页调入到物理内存
- _最佳页面置换算法_：理想状态
- _先进先出置换算法_：置换掉在内存驻留时间很长的页面
- _时钟页面置换算法_：指到谁就替换
- _最不常用算法_：选择「访问次数」最少的那个页面，并将其淘汰
### 4.3 磁盘调度算法
- _先来先服务算法
- _最短寻道时间优先算法
- _扫描算法
- _循环扫描算法
- _LOOK 与 C-LOOK 算法

## 5 网络系统
### 5.1 零拷贝
- **直接内存访问（_Direct Memory Access_）** 技术
- 由 DMA 控制器负责进行 I/O 设备和内存的数据传输工作，CPU 不参与
- 过程：
	- 操作系统将 I/O 请求发送 DMA
	- DMA 将 I/O 请求发送给磁盘
	- 磁盘把数据读取到缓冲区中，读满后，向 DMA 发起中断信号，告知缓冲区已满
	- DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中
	- 当 DMA 读取了足够多的数据，就会发送中断信号给 CPU
	- CPU 将数据从内核拷贝到用户空间，系统调用返回
- 实现零拷贝？
	- 减少「上下文切换」和「数据拷贝」的次数
	- mmap + write：把内核缓冲区里的数据「**映射**」到用户空间
	- sendfile：替代前面的 `read()` 和 `write()` 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销
### 5.2 I/O 多路复用
- 多个请求复用了一个进程，这就是多路复用，**程可以通过一个系统调用函数从内核中获取多个事件**
#### 5.2.1 Select
- 将已连接的 Socket 都放到一个**文件描述符集合**，然后调用 select 函数**拷贝**到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过**遍历**文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合**拷贝**回用户态里，然后用户态还需要再通过**遍历**的方法找到可读或可写的 Socket，然后再对其处理。
- 需要进行 **2 次「遍历」文件描述符集合**
- 使用固定长度的 BitsMap，表示文件描述符集合，最多监听 1024 个

#### 5.2.2 poll
- poll 用链表形式来组织存储所关注的文件描述符，突破了 select 的文件描述符个数限制
- 和 select 并没有太大的本质区别，都是线性结构，也都需要遍历

#### 5.2.3 epoll
- epoll 在内核里使用**红黑树来跟踪进程所有待检测的文件描述字**，把需要监控的 socket 通过 `epoll_ctl()` 函数加入内核中的红黑树里
- epoll 使用`事件驱动`的机制，内核里维护了一个`链表`来记录就绪事件，当某个 socket 有事件发生时，通过`回调函数`内核会将其加入到这个就绪事件列表中，当用户调用 `epoll_wait()` 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。
- _事件触发模式_
	- **边缘触发**：当被监控的 Socket 描述符上有可读事件发生时，**服务器端只会从 epoll_wait 中苏醒一次**，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；   **一般和非阻塞 I/O 搭配使用**
	- **水平触发**：当被监控的 Socket 上有可读事件发生时，**服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束**，目的是告诉我们有数据需要读取；

### 5.3 高性能网络模式
**I/O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程**
#### 5.3.1 Reactor 模式
- **Reactor（监听和分发事件）、Acceptor（获取连接）、Handler（处理业务）**
- 单 Reactor 单进程 / 线程，不用考虑进程间通信以及数据同步的问题，因此实现起来比较简单，这种方案的缺陷在于无法充分利用多核 CPU，而且处理业务逻辑的时间不能太长，否则会延迟响应，所以不适用于计算机密集型的场景，适用于业务处理快速的场景，比如 Redis（6.0之前 ） 采用的是单 Reactor 单进程的方案。
- 单 Reactor 多线程，通过多线程的方式解决了方案一的缺陷，但它离高并发还差一点距离，差在只有一个 Reactor 对象来承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方。
- Reactor 多进程 / 线程，通过多个 Reactor 来解决了方案二的缺陷，主 Reactor 只负责监听事件，响应事件的工作交给了从 Reactor
#### 5.3.2 Proactor 异步网络模式
- 阻塞 I/O：食堂等  ； 非阻塞 I/O： 过一段时间再去食堂； 异步 I/O： 阿姨送过来
- **Proactor 是异步网络模式， 感知的是已完成的读写事件**。**「来了事件操作系统来处理，处理完再通知应用进程」**。

## 6 Linux命令
### 6.1 查看网络性能指标
 - 网络的配置和状态   使用 `ifconfig` 或者 `ip` 命令来查看
 - socket 信息如何查看   使用 `netstat` 或者 `ss`
 - 网络吞吐率和 PPS 如何查看     使用 `sar` 命令
 - 连通性和延时如何查看  ping
 