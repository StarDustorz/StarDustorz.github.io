---
title: Raft
date: 2021-06-12 19:29:17
tags:
  - System-Design
categories:
  - System-Design
published: false
toc: "true"
comments: "true"
description: 
---

## 1 核心概念
|**中文术语**|**英文术语**|**含义**|
|---|---|---|
|领导者|leader|节点的三种角色之一. 集群的首脑，负责发起”提议“、”提交“被多数派认可的决断.|
|跟随者|follower|节点的三种角色之一. 需要对 leader 的 ”提议“ 、”提交“和 candidate 的 ”竞选“ 进行响应.|
|候选人|candidate|节点的三种角色之一. 是一种处于竞选流程中的临时状态，根据多数派投票的结果会切为 leader 或 follower 的稳定态.|
|最终一致性|finnal consistency|中强一致性. 对于写请求，服务端保证最终一定能提供出正确的结果，但需要同步时间. 同步期间，可能被读到不一致的老数据.|
|即时一次性|immediate consistency|强一致性. 服务端要求做到写入立即可读.|
|预写日志|write ahead log|记录写请求明细的日志.（单指 raft 算法下狭义的预写日志）|
|状态机|state machine|节点内存储数据的介质.|
|提议|proposal|两阶段提交的第一个阶段. 指的是 leader 向所有节点发起日志同步请求的过程.|
|提交|commit|两阶段提交的第二个阶段. 指的是 leader 认可一笔写请求已经被系统采纳的动作.|
|应用|apply|指的是将预写日志记录内记录的写操作应用到状态机的过程.|
|任期|term|任期是用于标识 leader 更迭的概念. 每个任期内至多只允许有一个 leader.|
|日志索引|index|日志在预写日志数组中的位置.|
|脑裂|brain split|同一任期内，集群出现两个 leader，导致秩序崩盘.|

### 1.1 多数派原则
> 系统的决断无需全员参与,多数派达成的共识即可视为整个系统的答复
- 以集群存在 5 个节点为例，多数派则需要集齐 3 个及 3 个以上节点，至多可以允许 2 个节点存在开小差背离主流的情况. 同理，倘若集群 6 个节点，则多数派需要集齐 4 个及 4 个以上节点，因此同样至多允许 2 个节点开小差. 综上，这是奉行多数派原则的集群通常将节点个数设置为奇数的原因之一.
- 多数派原则是提高分布式系统可用性 A 的关键. 对于整个系统而言，执行一项操作要求全员共同响应以实现强 C 的保证是过于苛刻的，因为我们无法保证所有节点都能健康运作，这种底线思维是研发人员所必须具备的素养. 但是倘若退而求其次，只要多数派达成共识即可正常决断和响应，这样下限就提高很多了. 由全员响应进化为多数派共识，这将把一种底线思维下的随机性问题进化为一个数学期望问题.

### 1.2 一主多从、读写分离
- raft 算法下系统中的节点分为领导者 leader 和跟随者 follower 两类角色;leader拥有更广阔的视野，需要总览全局，领导一些日常事务的推进；follower 职责相对简单但同样重要，因为这是一个基于多数派原则运作的民众团体，所有角色只要拧成一股绳，聚成了多数派，就能代表整个系统进行决断，甚至包括推翻 leader.
- 读操作可以由集群的任意节点提供服务；写操作统一需要由 leader 收口处理，并向 follower 同步. 倘若 follower 率先收到了来自客户端的写请求，也需要转发给 leader 进行处理.

### 1.3 状态机与预写日志
- 状态机 （state machine）是节点实际存储数据的容器,写请求的最后一步是将结果写入状态机，而读请求也需要从状态机中获取数据进行响应.
- 预写日志（write ahead log，简称 wal）是通过日志的方式记录下每一笔写请求的明细（例如 set x = 3 这样一笔记录），使得变更历史有迹可循. 在 raft 算法中，写请求会先组织成预写日志的形式添加到日志数组中，当一个日志（写请求）达到集群多数派的认可后，才能够被提交，将变更应用到状态机当中.
### 1.4 两阶段提交
（1）leader 接收到来自客户端的一笔写请求；
（2）leader 将写请求添加到本地的预写日志中，并向集群中其他节点广播同步这笔写请求. 这个过程可以称之为“提议”（proposal）；
（3）集群中各节点接收到同步请求后，会一套检验机制判断是否能执行同步（添加到预写日志），校验机制这里不细述，留待 4.1 小节细说；
（4）倘若集群总计半数以上的节点（包括 leader 自身）都将这笔请求添加预写日志，并给予了 leader 肯定的答复（ack），那么 leader 此时会“提交”这个请求，并给予客户端写请求已成功处理的响应；
（5）其他节点在随后的时段中，会通过与 leader 的交互（心跳或其他同步数据的请求）感知到这个“提交”动作，最终也在预写日志中提交这笔请求；
（6）被提交的预写日志具备了被应用到状态机的资格. 但应用的时机取决于实现方式，倘若只追求最终一致性，可以选择异步应用；倘若追求立即一致性，则会要求 leader 先应用到状态机，才能给予客户端 ack.
### 1.5 Leader选举
- leader 需要定期向 follower 发送心跳，证明自己仍然健在. 与之对应的，follower 会建立一个心跳检测定时器，当超过指定时长未收到 leader 的心跳，则认为 leader 已死，会切换成候选人（candidate）发起竞选，尝试补位成为新的 leader.
- follower 成为 candidate 后,会广播向所有节点拉票，当投赞同票的节点数（包括candidate 本身）达到多数派的时候，该 candidate 会胜任，成为新的 leader.

### 1.6 任期与日志索引
- 每当一个 candidate 发起一轮竞选时，会将当前 term 在旧任期的基础上加1，倘若胜任成为新的 leader，这就将成为自己的“国号”.
- 值得一提的是，不是每个 term 都有 leader，因为可能在 candidate 未胜出的前提下，term 又进一步进行了累加，从而实现朝代的跨越.
- 但能够保证的是，`每个 term 至多只会有一个 leader`
- 节点中的预写日志存放在一个数组中，每则日志在数组中的位置称之为索引 index.
- 于是，每一则预写日志会有两个核心的标识属性：
	- term：标志了这则日志是哪个任期的 leader 在位时同步写入的；
	- index：标志了这则日志在预写日志数组的位置.
- 通过 {term , index} 二元组可以组成一个全局唯一键，定位到一则日志，并且能够保证位于不同节点中日志，只要其 term 和 index 均相同，其内容一定完全一致

## 2 角色流转
### 2.1 角色定义及切换
- `leader -> follower`
	- 倘若 leader 发现当前系统中出现了更大的任期，则会进行“禅让”，主动退位成 follower.
	- 这里 leader 发现更大任期的方式包括：I 向 follower 提交日志同步请求时,从 follower 的响应参数中获得; II 收到了来自新任 leader 的心跳或者同步日志请求；III 收到了任期更大的 candidate 的拉票请求.
- `follower -> candidate`
	- leader 需要定期向 follower 发送心跳，告知自己仍健在的消息.
	- 倘若 follower 超过一定时长没收到 leader 心跳时，会将状态切换为 candidate ，在当前任期的基础上加 1 作为竞选任期，发起竞选尝试补位.
- `candidate -> follower`
	- candidate 参与竞选过程中，出现以下两种情形时会退回 follower：
		- 多数派投了反对票；
		- 竞选期间，收到了任期大于等于自身竞选任期的 leader 传来的请求.
- `candidate -> leader`
	- candidate 竞选时，倘若多数派投了赞同票，则切换为 leader.
- `candidate -> candidate`
	- candidate 的竞选流程有一个时间阈值. 倘若超时仍未形成有效结论（多数派赞同或拒绝），则会维持 candidate 身份，将竞选任期加1，发起新一轮竞选.
### 2.2 领导者
领导者是写请求的统一入口，在接收到来自客户端的写请求时，会开启“两阶段提交”的流程：
- 广播 proposal，向所有节点同步这一请求；
- 当请求得到多数派的赞同后，才会提交这一请求.
- leader 还需要周期性地向集群中所有节点发送自己的心跳，告知自己的健康状况，用途包括：
- 让 follower 重置心跳检测定时器，避免其切换成 candidate 发起竞选；
- 在心跳请求中携带上 leader 最新已提交日志的标识 id（term + index），推动 follower 更新日志提交进度.
### 2.3 跟随者
- 负责同步 leader 传来的写请求，此时也有一个参与民主反馈的过程，倘若同步成功，会给予 leader 正向反馈，当 leader 的同步请求收到半数以上的认可时，会提交日志；
- 通过接收 leader 心跳的方式，获取到携带的 commitIndex 信息，及时完成已被多数派认可的预写日志的提交，以推进其写入状态机的进度. 这一项相当于做到了数据的备份，也被读请求最终一致性提供了保证;
- 负责为参与竞选 candidate 的投票
- 通过心跳检测定时器时时关注 leader 的健康状态，当超时未收到心跳时，会切换为 candidate 发起竞选.
### 2.4 候选人
- 倘若 follower 切为 candidate，会将当前任期加1，作为竞选任期；
- 会将自身的一票投给自己；
- 广播向所有节点拉票；
- 倘若拉票请求超时前，得到多数派认可，则上位为 leader；
- 倘若拉票请求超时前，遭到多数派拒绝，则老实退回 follower；
- 倘若拉票请求超时前，收到了任期大于等于自身竞选任期的 leader 的请求，则老实退回 follower；
- 倘若拉票请求超时，则竞选任期加 1，发起新一轮竞选拉票请求.


## 3 常见问题
### 3.1 为什么能保证一个任期内至多只有一个领导者？
可以，通过选举的机制可以保证.
- 首先，candidate 竞选前会自增 term，因此 term 在总体上为单调递增趋势；
- 其次，在选举机制上，一个 term 内，一个 follower 只有一票，因此只能投票给一个 candidate；
- 最后，基于多数派原则，一个 candidate 只有拿到半数以上的赞同票才能当选 leader.
- 因此，同一个 term 内，不可能出现有两个 candidate 同时获得半数以上的赞同票，因此一个 term 至多只有一个 leader.
### 3.2 为什么能保证通过任期和索引相同的日志内容一定相同？
- 首先，预写日志具有 append-only 的性质，只作追加，不存在更新和删除操作；
- 其次，同一个 term 只有一个 leader；
- 因此，在 term 相同的情况下，所有节点在同一个 index 上的日志都会与 term 内 leader 对应 index 位置的日志保持一致；
- 综上，term 和 index 共同组成了一个全局唯一标识键. 只要term 和 index 均相同，日志内容一定相同
### 3.3 关于选举机制方面，如何解决选票瓜分引发的问题？
- 每个节点在心跳超时阈值和竞选超时阈值上添加一个随机扰动值，通过这一扰动，避免多个节点在进入完全相同的竞选节奏. 于是进入 candidate 状态的节点有了先后之分，胜负自然就可见分晓.
### 3.4 为什么新任 leader 一定拥有旧 leader 已提交的日志？
由两阶段提交和选举流程中的多数派原则保证的：
- 只有被集群多数派完成同步的日志才会被 leader 提交；
- 在选举流程中，节点只会把票投给日志进度不滞后于自身的 candidate；
- 在竞选流程，candidate 需要获取多数派的赞同票才能胜任，成为新任 leader.
- 可知，新任 leader 的日志进度一定能在竞选流程的多数派中出于不滞后的地位.
- 而在集群节点个数固定的情况下，本轮竞选流程的多数派和认可前任 leader 同步日志请求的多数派至少存在一个重复的节点，否则就违背了多数派的语义（集群半数以上），因此可以得知，新任 leader 一定拥有前任 leader 那笔被多数派认可的日志，即旧 leader 提交的日志.

### 3.5 leader 向 follower 同步日志时，如何保证不出现乱序、丢失、重复的问题？
- 不乱序、不重复：follower 同步日志前，会校验上一笔日志是否和 leader 的上一笔完全一致，只有这样才会执行同步动作.
- 不丢失：基于 ack 机制保证. 倘若 leader 超时未收到 follower 同步日志的 ack，会重发同步日志请求.

### 3.6 如何保证各节点已提交的预写日志顺序和内容都完全一致？
- 假设节点 a 最后一笔已提交的预写日志的 term = x、index = y，这说明集群中有多数派认同了 term 为 x 的 leader 同步该笔日志的请求.
- 首先证明：倘若其他节点在 index = y 位置的日志已提交了，则这笔日志的 term 一定也为 x.
- 证明思路：倘若节点 b 在 index = y 处的日志已提交，且任期为 z，那么就说明集群中有多数派认可了任期为 z 的 leader 同步的 term = z、index = y 的日志的请求. 由于集群不可能存在两个对立的多数派，因此唯一的可能性就是 z = x，原题得证.
- 接下来基于 7.2 小节的证明结论，我们可以得知各节点在 term = x、index = y 前面部分的日志也都完全一致，即各节点已提交的预写日志顺序和内容都完全一致.

### 3.7 如何保证状态机数据的最终一致性？
- 被提交的预写日志顺序和内容都必然是完全一致的.
- 又由于只有被提交的预写日志才能被应用到状态机，因此状态机的数据必然会按照正确的顺序和请求内容被依次更新，最终一致性得以保证.

### 3.8 如何解决网络分区引发的无意义选举问题？
- 倘若集群产生网络分区，部分处于小分区的节点由于无法接收到 leader 的心跳，导致进入选举流程. 又因为网络分区问题，导致选举始终无法获得多数派的响应，最终 candidate 会无限自增 term. 直到网络恢复的那一刻，由于 candidate 异常的高 term，导致 leader 退位，集群进入新一轮的选举流程.
- 尽管小分区中的节点由于数据的滞后不可能在选举中胜出，最后必然是大分区中的节点胜任，节点数据的一致性依然可以得到保证. 但是这个无意义的选举过程同样会导致集群陷入暂不可用的阶段. 因此，我们可以通过这样的措施来避免这类无意义的选举：
- 每个 candidate 发起真实选举之前，会有一个提前试探的过程，试探机制是向集群所有节点发送请求，只有得到多数派的响应，证明自己不存在网络环境问题时，才会将竞选任期自增，并且发起真实的选举流程.

### 3.9 如果保证客户端提交写请求不丢失、不重复？
- 不丢失：通过 ack 机制保证. 客户端超时未收到服务端的 ack，则会重发请求.
- 不重复：客户端记录写请求的序列号，与服务端交互时透传这个序列号. 最终由服务端的 leader 实现对相同序列号写请求的幂等去重.