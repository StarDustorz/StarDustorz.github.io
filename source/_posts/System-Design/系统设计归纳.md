---
title: 系统设计归纳
date: 2021-06-12 19:29:17
tags:
  - System-Design
categories:
  - System-Design
published: false
toc: "true"
comments: "true"
description: 
---


## 1 实现令牌桶
"HMSET" 是 Redis 的哈希表命令，用于设置哈希表中的多个字段及其对应的值。
通过将获取锁封装到lua脚本中，提交给redis进行eval和evalsha操作来完成lua脚本的执行，由于lua脚本在redis中天然的原子性，我们的需求能够比较好的满足，问题是将业务逻辑封装在lua中，对于开发人员自身的能力和调试存在一定的问题。
限流器在每次请求令牌和放入令牌操作中，存在一个协同的问题，即获取令牌操作要尽可能保证原子性，否则无法保证限流器是否能正常工作。在RateLimiter的实现中使用了mutex作为互斥锁来保证操作的原子性，那么在redis中就需要一个类似于事务的机制来保证获取令牌中多重操作的原子性。

```bash
-- 返回码 1:操作成功 0:未配置 -1: 获取失败 -2:修改错误，建议重新初始化 -500:不支持的操作
-- redis hashmap 中存放的内容:
-- last_mill_second 上次放入令牌或者初始化的时间
-- stored_permits 目前令牌桶中的令牌数量
-- max_permits 令牌桶容量
-- interval 放令牌间隔
-- app 一个标志位，表示对于当前key有没有限流存在

local SUCCESS = 1
local NO_LIMIT = 0
local ACQUIRE_FAIL = -1
local MODIFY_ERROR = -2
local UNSUPPORT_METHOD = -500

local ratelimit_info = redis.pcall("HMGET",KEYS[1], "last_mill_second", "stored_permits", "max_permits", "interval", "app")
local last_mill_second = ratelimit_info[1]
local stored_permits = tonumber(ratelimit_info[2])
local max_permits = tonumber(ratelimit_info[3])
local interval = tonumber(ratelimit_info[4])
local app = ratelimit_info[5]

local method = ARGV[1]

--获取当前毫秒
--考虑主从策略和脚本回放机制，这个time由客户端获取传入
--local curr_time_arr = redis.call('TIME')
--local curr_timestamp = curr_time_arr[1] * 1000 + curr_time_arr[2]/1000
local curr_timestamp = tonumber(ARGV[2])


-- 当前方法为初始化
if method == 'init' then
    --如果app不为null说明已经初始化过，不要重复初始化
    if(type(app) ~='boolean' and app ~=nil) then
        return SUCCESS
    end

    redis.pcall("HMSET", KEYS[1],
        "last_mill_second", curr_timestamp,
        "stored_permits", ARGV[3],
        "max_permits", ARGV[4],
        "interval", ARGV[5],
        "app", ARGV[6])
    --始终返回成功
    return SUCCESS
end

-- 当前方法为修改配置
if method == "modify" then
    if(type(app) =='boolean' or app ==nil) then
        return MODIFY_ERROR
    end
    --只能修改max_permits和interval
    redis.pcall("HMSET", KEYS[1],
        "max_permits", ARGV[3],
        "interval", ARGV[4])

    return SUCCESS

end

-- 当前方法为删除
if method == "delete" then
    --已经清除完毕
    if(type(app) =='boolean' or app ==nil) then
        return SUCCESS
    end
    redis.pcall("DEL", KEYS[1])
    return SUCCESS
end

-- 尝试获取permits
if method == "acquire" then
    -- 如果app为null说明没有对这个进行任何配置，返回0代表不限流
    if(type(app) =='boolean' or app ==nil) then
        return NO_LIMIT
    end
    --需要获取令牌数量
    local acquire_permits = tonumber(ARGV[3])
    --计算上一次放令牌到现在的时间间隔中，一共应该放入多少令牌
    local reserve_permits = math.max(0, math.floor((curr_timestamp - last_mill_second) / interval))
    
    local new_permits = math.min(max_permits, stored_permits + reserve_permits)
    local result = ACQUIRE_FAIL
    --如果桶中令牌数量够则放行
    if new_permits >= acquire_permits then
        result = SUCCESS
        new_permits = new_permits - acquire_permits
    end
    --更新当前桶中的令牌数量 
    redis.pcall("HSET", KEYS[1], "stored_permits", new_permits)
    --如果这次有放入令牌，则更新时间
    if reserve_permits > 0 then
        redis.pcall("HSET", KEYS[1], "last_mill_second", curr_timestamp)
    end
    return result
end

return UNSUPPORT_METHOD
```


## 2 实现 set
```go
package main

import "fmt"

// Set 是一个使用 map 实现的集合
type Set struct {
    m map[string]struct{}
}

// NewSet 创建一个新的空集合
func NewSet() *Set {
    return &Set{m: make(map[string]struct{})}
}

// Add 向集合中添加一个元素
func (s *Set) Add(value string) {
    s.m[value] = struct{}{}
}

// Remove 从集合中删除一个元素
func (s *Set) Remove(value string) {
    delete(s.m, value)
}

// Contains 检查集合中是否包含某个元素
func (s *Set) Contains(value string) bool {
    _, ok := s.m[value]
    return ok
}

// Len 返回集合的长度
func (s *Set) Len() int {
    return len(s.m)
}

// Clear 清空集合
func (s *Set) Clear() {
    s.m = make(map[string]struct{})
}

// Values 返回集合中的所有元素
func (s *Set) Values() []string {
    values := make([]string, 0, len(s.m))
    for k := range s.m {
        values = append(values, k)
    }
    return values
}

func main() {
    set := NewSet()
    set.Add("a")
    set.Add("b")
    set.Add("c")
    
    fmt.Println("Set contains 'a':", set.Contains("a")) // true
    fmt.Println("Set contains 'd':", set.Contains("d")) // false
    
    set.Remove("a")
    fmt.Println("Set contains 'a':", set.Contains("a")) // false
    
    fmt.Println("Set length:", set.Len()) // 2
    
    fmt.Println("Set values:", set.Values()) // [b c]
    
    set.Clear()
    fmt.Println("Set length after clear:", set.Len()) // 0
}
```

## 3 实现协程交替打印
```go

import (
    "fmt"
    "sync"
)
 
var countNum = 100
 
//3个函数分别打印cat、dog、fish，要求每个函数都要起一个goroutine，按照cat、dog、fish顺序打印在屏幕上10次
func main() {
    var wg sync.WaitGroup
 
    dogCh := make(chan struct{}, 1)
    defer close(dogCh)
    catCh := make(chan struct{}, 1)
    defer close(catCh)
    fishCh := make(chan struct{}, 1)
    defer close(fishCh)
 
    wg.Add(3)
    go catPrint(&wg, &catCh, &dogCh)
    go dogPrint(&wg, &dogCh, &fishCh)
    go fishPrint(&wg, &fishCh, &catCh)
 
    catCh <- struct{}{}
    wg.Wait()
}
func catPrint(wg *sync.WaitGroup, catCh *chan struct{}, dogCh *chan struct{}) {
    count := 0
    for {
        if count >= countNum {
            wg.Done()
            //fmt.Println("cat quit")
            return
        }
        <-*catCh
        fmt.Println("cat", count+1)
        count++
        *dogCh <- struct{}{}
    }
}
 
func dogPrint(wg *sync.WaitGroup, dogCh *chan struct{}, fishCh *chan struct{}) {
    count := 0
    for {
        if count >= countNum {
            wg.Done()
            //fmt.Println("dog quit")
            return
        }
        <-*dogCh
        fmt.Println("dog")
        count++
        *fishCh <- struct{}{}
    }
}
 
func fishPrint(wg *sync.WaitGroup, dogCh *chan struct{}, catCh *chan struct{}) {
    count := 0
    for {
        if count >= countNum {
            wg.Done()
            //fmt.Println("fish quit")
            return
        }
        <-*dogCh
        fmt.Println("fish")
        count++
        *catCh <- struct{}{}
    }
}
```