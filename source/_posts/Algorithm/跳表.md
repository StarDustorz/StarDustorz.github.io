---
title: 跳表
date: 2021-06-12 19:29:17
tags:
  - Algorithm
categories:
  - 跳表
published: false
toc: "true"
comments: "true"
description: 
---

![图片](file:///Users/caotianlong/Documents/%E5%88%B7%E9%A2%98/%E7%83%AD%E9%97%A8%E5%AE%9E%E7%8E%B0/img/640-20230911011754301.png?lastModify=1694370430)

## 1 核心性质

- 跳表由多层索引结构组成
- 每次节点个数接近于相邻下层节点数的一半
- 对于一个 m 层存在的节点，在 1~m-1层中这个节点也一定存在
- 为保证连贯性，跳表额外补充了本身不存储数据的头节点和尾节点，作为起点和终点
- 头节点和尾节点的高度是动态扩缩的，其高度取决于当前跳表内数据节点的最大高度
- 跳表的”跳“字体现在，在高层检索时，每跳过一个节点，实际上都过滤跳过了底层的大量数据，从而实现检索加速
## 2 数据结构定义

```go
 // 跳表的数据结构 Skiplist  
 type Skiplist struct {  
     head *node  
 }  
 // 节点定义  
 type node struct {  
     // 长度为当前节点的高度  
     nexts    []*node  
     key, val int  
 }
```

## 3 读流程
- 以 head 节点作为起点
- 从当前跳表存在的最大高度出发
- 倘若右侧节点 key 值小于 target，则持续向右遍历
- 倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回
- 倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层
- 重复（3）-（5）步
- 倘若已经抵达第1层仍然找到不到 target，则返回 key 不存在的信息
    
```go
 // 根据 key 读取 val，第二个 bool flag 反映 key 在 skiplist 中是否存在  
 func (s *Skiplist) Get(key int) (int, bool) {  
     // 根据 key 尝试检索对应的 node，如果 node 存在，则返回对应的 val  
     if _node := s.search(key); _node != nil {  
         return _node.val, true  
     }  
     return -1, false  
 }  
 ​  
 // 从跳表中检索 key 对应的 node  
 func (s *Skiplist) search(key int) *node {  
     // 每次检索从头部出发  
     move := s.head  
     // 每次检索从最大高度出发，直到来到首层  
     for level := len(s.head.nexts) - 1; level >= 0; level-- {  
         // 在每一层中持续向右遍历，直到下一个节点不存在或者 key 值大于等于 key  
         for move.nexts[level] != nil && move.nexts[level].key < key {  
             move = move.nexts[level]  
         }  
         // 如果 key 值相等，则找到了目标直接返回  
         if move.nexts[level] != nil && move.nexts[level].key == key {  
             return move.nexts[level]  
         }  
         // 当前层没找到目标，则层数减 1，继续向下  
     }  
     // 遍历完所有层数，都没有找到目标，返回 nil  
     return nil  
 }
```

## 4 写流程

- 首先基于读流程检索出 key 对应的节点是否存在，倘若存在，则对值进行更新并直接返回
- 随机出新插入节点的高度；倘若新插入节点的高度大于当前跳表的最大高度，则需要对起点和终点的高度进行扩容
- 以 head 节点作为起点，从当前跳表存在的最大高度出发
- 倘若右侧节点 key 值小于 target，则持续向右遍历
- 倘若右侧节点为终点（nil）或者 key 值大于 target，则在该空隙插入新节点，并降低高度进入下一层
- 重复（4）-（5）步
- 倘若已经进入第 1 层，插入新节点后即可返回
```go
 import ("math/rand")  
 roll 骰子，决定一个待插入的新节点在 skiplist 中最高层对应的 index  
 func (s *Skiplist) roll() int {  
     var level int  
     // 每次投出 1，则层数加 1  
     for rand.Int() > 0 {  
         level++  
     }  
     return level  
 }  
 ​  
 // 将 key-val 对加入 skiplist  
 func (s *Skiplist) Put(key, val int) {  
     // 假如 kv对已存在，则直接对值进行更新并返回  
     if _node := s.search(key); _node != nil {  
         _node.val = val  
         return  
     }  
 ​  
     // roll 出新节点的高度  
     level := s.roll()  
     
     // 新节点高度超出跳表最大高度，则需要对高度进行补齐  
     for len(s.head.nexts)-1 < level {  
         s.head.nexts = append(s.head.nexts, nil)  
     }  
 ​  
     // 创建出新的节点  
     newNode := node{  
         key:   key,  
         val:   val,  
         nexts: make([]*node, level+1),  
     }  
    
     // 从头节点的最高层出发  
     move := s.head  
     for level := level; level >= 0; level-- {  
         // 向右遍历，直到右侧节点不存在或者 key 值大于 key  
         for move.nexts[level] != nil && move.nexts[level].key < key {  
             move = move.nexts[level]  
         }  
         // 调整指针关系，完成新节点的插入  
         newNode.nexts[level] = move.nexts[level]  
         move.nexts[level] = &newNode  
     }  
 }  
 ```


## 删流程
- 以 head 节点作为起点，从当前跳表存在的最大高度出发
- 倘若右侧节点 key 值小于 target，则持续向右遍历
- 倘若右侧节点为终点（nil）或者 key 值大于 target，则在该空隙插入新节点，并降低高度进入下一层
- 倘若右侧节点 key 值等于 target，则代表找到目标
- 找到目标值后，沿当前节点层层向下，依次将每层中的目标节点删除
- 倘若已经进入第 1 层仍然没有找到节点，说明节点不存在，删除失败
- 倘若删除成功，需要尝试对跳表的整体高度进行缩容，即需要对高度递减，直到确定最大高度对应的层数上至少存在一个有效的数据节点为止

 ```go
// 根据 key 从跳表中删除对应的节点  
 func (s *Skiplist) Del(key int) {  
     // 如果 kv 对不存在，则无需删除直接返回  
     if _node := s.search(key); _node == nil {  
         return  
     }  
 ​  
     // 从头节点的最高层出发      
     move := s.head  
     for level := len(s.head.nexts) - 1; level >= 0; level-- {  
         // 向右遍历，直到右侧节点不存在或者 key 值大于等于 key  
         for move.nexts[level] != nil && move.nexts[level].key < key {  
             move = move.nexts[level]  
         }  
           
         // 右侧节点不存在或者 key 值大于 target，则直接跳过  
         if move.nexts[level] == nil || move.nexts[level].key > key{  
            continue  
         }      
         // 走到此处意味着右侧节点的 key 值必然等于 key，则调整指针引用  
         move.nexts[level] = move.nexts[level].nexts[level]  
     }  
 ​  
     // 对跳表的最大高度进行更新  
     var dif int  
     // 倘若某一层已经不存在数据节点，高度需要递减  
     for level := len(s.head.nexts) - 1; level > 0 && s.head.nexts[level] == nil; level-- {  
         dif++  
     }  
     s.head.nexts = s.head.nexts[:len(s.head.nexts)-dif]  
 }
```
## 5 RANGE 流程
- 以 head 节点作为起点
- 从当前跳表存在的最大高度出发
- 倘若右侧节点 key 值小于 target，则持续向右遍历
- 倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层
- 倘若右侧节点 key 值等于 target，则代表找到目标，直接沿该节点向下来到第1层
- 重复（3）-（5）步，直到来到第1层，接下来从首个大于等于 target 的节点出发，向右依次遍历，直到取满 range 区间的数据后返回

 ```go
// 找到 skiplist 当中 ≥ start，且 ≤ end 的 kv 对  
 func (s *Skiplist) Range(start, end int) [][2]int {  
     // 首先通过 ceiling 方法，找到 skiplist 中 key 值大于等于 start 且最接近于 start 的节点 ceilNode  
     ceilNode := s.ceiling(start)  
     // 如果不存在，直接返回  
     if ceilNode == nil {  
         return [][2]int{}  
     }  
 ​  
     // 从 ceilNode 首层出发向右遍历，把所有位于 [start,end] 区间内的节点统统返回  
     var res [][2]int  
     for move := ceilNode; move != nil && move.key <= end; move = move.nexts[0] {  
         res = append(res, [2]int{move.key, move.val})  
     }  
     return res  
 }  
 ​  
 // 找到 key 值大于等于 target 且 key 值最接近于 target 的节点  
 func (s *Skiplist) ceiling(target int) *node {  
     move := s.head  
     // 自上而下，找到 key 值小于 target 且最接近 target 的 kv 对  
     for level := len(s.head.nexts) - 1; level >= 0; level-- {  
         for move.nexts[level] != nil && move.nexts[level].key < target {  
             move = move.nexts[level]  
         }  
         // 如果 key 值等于 targe 的 kv 对存在，则直接返回  
         if move.nexts[level] != nil && move.nexts[level].key == target {  
             return move.nexts[level]  
         }  
     }  
     // 此时 move 已经对应于在首层 key 值小于 key 且最接近于 key 的节点，其右侧第一个节点即为所寻找的目标节点  
     return move.nexts[0]  
 }
```

## CEILING 流程

- 以 head 节点作为起点
- 从当前跳表存在的最大高度出发
- 倘若右侧节点 key 值小于 target，则持续向右遍历
- 倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层
- 倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回
- 重复（3）-（5）步，直到找到 key 值等于 target 的节点或者来到第1层，接下来获取到首个大于等于 target 的节点并返回

```go
 // 找到 skiplist 中，key 值大于等于 target 且最接近于 target 的 key-value 对  
 func (s *Skiplist) Ceiling(target int) ([2]int, bool) {  
     if ceilNode := s.ceiling(target); ceilNode != nil {  
         return [2]int{ceilNode.key, ceilNode.val}, true  
     }  
     return [2]int{}, false  
 }  
```
 ​

## 6 FLOOR 流程

- 以 head 节点作为起点
- 从当前跳表存在的最大高度出发
- 倘若右侧节点 key 值小于 target，则持续向右遍历
- 倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层
- 倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回
- 重复（3）-（5）步，直到找到 key 值等于 target 的节点或者来到第1层，接下来获取到首个小于等于 target 的节点并返回

 ```go
// 找到 skiplist 中，key 值小于等于 target 且最接近于 target 的 key-value 对  
 func (s *Skiplist) Floor(target int) ([2]int, bool) {  
     // 引用 floor 方法，取 floorNode 值进行返回  
     if floorNode := s.floor(target); floorNode != nil {  
         return [2]int{floorNode.key, floorNode.val}, true  
     }  
 ​  
 ​  
     return [2]int{}, false  
 }  
 ​  
 // 找到 key 值小于等于 target 且 key 值最接近于 target 的节点  
 func (s *Skiplist) floor(target int) *node {  
     move := s.head  
     // 自上而下，找到 key 值小于 target 且最接近 target 的 kv 对  
     for level := len(s.head.nexts) - 1; level >= 0; level-- {  
         for move.nexts[level] != nil && move.nexts[level].key < target {  
             move = move.nexts[level]  
         }  
         // 如果 key 值等于 targe 的 kv对存在，则直接返回  
         if move.nexts[level] != nil && move.nexts[level].key == target {  
             return move.nexts[level]  
         }  
     }  
 ​  
     // move 是首层中 key 值小于 target 且最接近 target 的节点，直接返回 move 即可  
     return move  
 }  
```
 ​  
 ​