<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->

<meta name="description" content="[Go] Map" />


<!-- Website keywords -->

<meta name="keywords" content="Golang, Go数据结构, Draco&#39;s Blog" />




<!-- Website rss -->

<link rel="alternate" href="/atom.xml" title="Draco's Blog" type="application/atom+xml">


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://stardustorz.github.io/2025/06/03/Golang/0 基础/数据结构/Map/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":false};
</script>
  
  <title>[Go] Map - Draco&#39;s Blog</title>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Draco&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        Home              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        Archives              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        Tags              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        Categories              </li>
    </a>
    
    <a href="/links/">
      <li class="mobile-menu-item">
        
        
        Links              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        About              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">Draco's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              Home  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              Archives  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              Tags  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              Categories  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/links/">  
              
              
              Links  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              About  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      [Go] Map
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-06-03
      </span>
      
      
      
    </div>
  </header>

  
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">1 基础使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%AF%BB"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%86%99"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-%E5%88%A0%E9%99%A4"><span class="toc-number">1.5.</span> <span class="toc-text">1.5 删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.</span> <span class="toc-text">1.6 遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7-%E5%B9%B6%E5%8F%91%E5%86%B2%E7%AA%81"><span class="toc-number">1.7.</span> <span class="toc-text">1.7 并发冲突</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">2 核心原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-hash"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 hash</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%A1%B6%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 桶数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-hash-%E5%86%B2%E7%AA%81"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 hash 冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%89%A9%E5%AE%B9%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 扩容优化性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">3 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-hmap"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 hmap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-mapextra"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 mapextra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-bmap"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 bmap</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">4 构造方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-makemap"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 makemap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-overLoadFactor"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 overLoadFactor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-makeBucketArray"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 makeBucketArray</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%AF%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">5 读流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E8%AF%BB%E6%B5%81%E7%A8%8B%E6%A6%82%E8%A7%88"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 读流程概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-mapaccess-%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 mapaccess 方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%86%99%E6%B5%81%E7%A8%8B"><span class="toc-number">6.</span> <span class="toc-text">6 写流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E5%86%99%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 写流程梳理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-mapassign"><span class="toc-number">6.2.</span> <span class="toc-text">6.2  mapassign</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%88%A0%E6%B5%81%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">7 删流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%88%A0%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 删流程梳理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E9%81%8D%E5%8E%86%E6%B5%81%E7%A8%8B"><span class="toc-number">8.</span> <span class="toc-text">8 遍历流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 迭代器数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E6%89%A9%E5%AE%B9%E6%B5%81%E7%A8%8B"><span class="toc-number">9.</span> <span class="toc-text">9 扩容流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E6%89%A9%E5%AE%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 扩容类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E6%89%A9%E5%AE%B9%E8%A7%A6%E5%8F%91"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 扩容触发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E6%89%A9%E5%AE%B9%E8%BF%81%E7%A7%BB%E8%A7%84%E5%88%99"><span class="toc-number">9.3.</span> <span class="toc-text">9.3 扩容迁移规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E6%B8%90%E8%BF%9B%E5%BC%8F%E6%89%A9%E5%AE%B9"><span class="toc-number">9.4.</span> <span class="toc-text">9.4 渐进式扩容</span></a></li></ol></li></ol>
    </div>
  </div>
  

  <div class="post-content">
    
    <blockquote>
<p>map 的底层数据结构和实现原理</p>
</blockquote>
<span id="more"></span>
<h2 id="1-基础使用"><a href="#1-基础使用" class="headerlink" title="1 基础使用"></a>1 基础使用</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>核心特征包含下述三点：</p>
<ul>
<li>存储基于 key-value 对映射的模式；</li>
<li>基于 key 维度实现存储数据的去重；</li>
<li>读、写、删操作控制，时间复杂度 O(1).</li>
</ul>
<h3 id="1-2-初始化"><a href="#1-2-初始化" class="headerlink" title="1.2 初始化"></a>1.2 初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myMap1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>,<span class="number">2</span>)</span><br><span class="line">myMap2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">myMap3 :=<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;</span><br><span class="line">  <span class="number">1</span>:<span class="number">2</span>,</span><br><span class="line">  <span class="number">3</span>:<span class="number">4</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>map 中，key 的数据类型必须为可比较的类型，chan、map、func不可比较</li>
</ul>
<h3 id="1-3-读"><a href="#1-3-读" class="headerlink" title="1.3 读"></a>1.3 读</h3><ul>
<li>直接读，倘若 key 存在，则获取到对应的 val，倘若 key 不存在或者 map 未初始化，会返回 val 类型的零值作为兜底.</li>
<li><p>读的同时添加一个 bool 类型的 flag 标识是否读取成功. 倘若 ok == false，说明读取失败， key 不存在，或者 map 未初始化.</p>
<h3 id="1-4-写"><a href="#1-4-写" class="headerlink" title="1.4 写"></a>1.4 写</h3></li>
<li><p>如果 map 未初始化，直接执行写操作会导致 panic</p>
<h3 id="1-5-删除"><a href="#1-5-删除" class="headerlink" title="1.5 删除"></a>1.5 删除</h3></li>
<li><p>执行 delete 方法时，倘若 key 存在，则会从 map 中将对应的 key-value 对删除；倘若 key 不存在或 map 未初始化，则方法直接结束，不会产生显式提示</p>
<h3 id="1-6-遍历"><a href="#1-6-遍历" class="headerlink" title="1.6 遍历"></a>1.6 遍历</h3></li>
</ul>
<ul>
<li>基于 k,v 依次承接 map 中的 key-value 对<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> myMap&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>基于 k 依次承接 map 中的 key，不关注 val 的取值</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> myMap&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在执行 map 遍历操作时，获取的 key-value 对并没有一个固定的顺序，因此前后两次遍历顺序可能存在差异</p>
</li>
</ul>
<h3 id="1-7-并发冲突"><a href="#1-7-并发冲突" class="headerlink" title="1.7 并发冲突"></a>1.7 并发冲突</h3><p>map 不是并发安全的数据结构，倘若存在并发读写行为，会抛出 fatal error.<br>具体规则是：</p>
<ul>
<li>并发读没有问题；</li>
<li>并发读写中的“写”是广义上的，包含写入、更新、删除等操作；</li>
<li>读的时候发现其他 goroutine 在并发写，抛出 fatal error；</li>
<li>写的时候发现其他 goroutine 在并发写，抛出 fatal error.<blockquote>
<p>fatal error，是一种比 panic 更严重的错误，无法使用 recover 操作捕获.</p>
</blockquote>
</li>
</ul>
<h2 id="2-核心原理"><a href="#2-核心原理" class="headerlink" title="2 核心原理"></a>2 核心原理</h2><p>hashmap 就是在算法上基于 hash 实现 key 的映射和寻址；在数据结构上基于桶数组实现 key-value 对的存储.</p>
<ul>
<li>通过哈希方法取得 key 的 hash 值</li>
<li>hash 值对桶数组长度取模，确定其所属的桶；</li>
<li>在桶中插入 key-value 对.</li>
<li>相同的 key 必然产生相同的 hash 值，因此能映射到相同的桶中，通过桶内遍历的方式锁定对应的 key-value 对</li>
</ul>
<h3 id="2-1-hash"><a href="#2-1-hash" class="headerlink" title="2.1 hash"></a>2.1 hash</h3><blockquote>
<p>hash 译作散列，是一种将任意长度的输入压缩到某一固定长度的输出摘要的过程，由于这种转换属于压缩映射，输入空间远大于输出空间，因此不同输入可能会映射成相同的输出结果. 此外，hash在压缩过程中会存在部分信息的遗失，因此这种映射关系具有不可逆的特质.</p>
</blockquote>
<ul>
<li>hash 的可重入性：相同的 key，必然产生相同的 hash 值</li>
<li>hash 的离散性：只要两个 key 不相同，不论其相似度的高低，产生的 hash 值会在整个输出域内均匀地离散化</li>
<li>hash 的离散性：只要两个 key 不相同，不论其相似度的高低，产生的 hash 值会在整个输出域内均匀地离散化</li>
<li>hash 冲突：由于输入域（key）无穷大，输出域（hash 值）有限，因此必然存在不同 key 映射到相同 hash 值的情况，称之为 hash 冲突</li>
</ul>
<h3 id="2-2-桶数组"><a href="#2-2-桶数组" class="headerlink" title="2.2 桶数组"></a>2.2 桶数组</h3><p>map 中，会通过长度为 2 的整数次幂的桶数组进行 key-value 对的存储：</p>
<ul>
<li>每个桶固定可以存放 8 个 key-value 对；</li>
<li><p>倘若超过 8 个 key-value 对打到桶数组的同一个索引当中，此时会通过创建桶链表的方式来化解这一问题.</p>
<h3 id="2-3-hash-冲突"><a href="#2-3-hash-冲突" class="headerlink" title="2.3 hash 冲突"></a>2.3 hash 冲突</h3></li>
<li><p>由于 hash 冲突的存在，不同 key 可能存在相同的 hash 值; hash 值会对桶数组长度取模，因此不同 hash 值可能被打到同一个桶中; 不同的 key-value 可能被映射到 map 的同一个桶当中</p>
</li>
<li>拉链法: 将命中同一个桶的元素通过链表的形式进行链接，因此很便于动态扩展.</li>
<li>开放寻址法: 在插入新条目时，会基于一定的探测策略持续寻找，直到找到一个可用于存放数据的空位为止</li>
<li>map 的插入写流程, 结合了拉链法和开放寻址法两种思路<ul>
<li>桶数组中的每个桶，严格意义上是一个单向桶链表，以桶为节点进行串联</li>
<li>每个桶固定可以存放 8 个 key-value 对</li>
<li>当 key 命中一个桶时，首先根据开放寻址法，在桶的 8 个位置中寻找空位进行插入</li>
<li>倘若桶的 8 个位置都已被占满，则基于桶的溢出桶指针，找到下一个桶，重复第（3）步</li>
<li>倘若遍历到链表尾部，仍未找到空位，则基于拉链法，在桶链表尾部续接新桶，并插入 key-value 对</li>
</ul>
</li>
</ul>
<h3 id="2-4-扩容优化性能"><a href="#2-4-扩容优化性能" class="headerlink" title="2.4 扩容优化性能"></a>2.4 扩容优化性能</h3><blockquote>
<p>map 的桶数组长度固定不变，那么随着 key-value 对数量的增长，当一个桶下挂载的 key-value 达到一定的量级，此时操作的时间复杂度会趋于线性, 导致性能不可接受</p>
</blockquote>
<p>扩容机制:</p>
<ul>
<li>扩容分为增量扩容和等量扩容</li>
<li>当桶内 key-value 总数/桶数组长度 &gt; 6.5 时发生增量扩容，桶数组长度增长为原值的两倍</li>
<li>当桶内溢出桶数量大于等于 2^B 时( B 为桶数组长度的指数，B 最大取 15)，发生等量扩容，桶的长度保持为原值</li>
<li>采用渐进扩容的方式，当桶被实际操作到时，由使用者负责完成数据迁移，避免因为一次性的全量数据迁移引发性能抖动</li>
</ul>
<h2 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3 数据结构"></a>3 数据结构</h2><h3 id="3-1-hmap"><a href="#3-1-hmap" class="headerlink" title="3.1 hmap"></a>3.1 hmap</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="type">int</span> </span><br><span class="line">    flags     <span class="type">uint8</span></span><br><span class="line">    B         <span class="type">uint8</span>  </span><br><span class="line">    noverflow <span class="type">uint16</span> </span><br><span class="line">    hash0     <span class="type">uint32</span> </span><br><span class="line">    buckets    unsafe.Pointer </span><br><span class="line">    oldbuckets unsafe.Pointer </span><br><span class="line">    nevacuate  <span class="type">uintptr</span>       </span><br><span class="line">    extra *mapextra </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>count：map 中的 key-value 总数</li>
<li>flags：map 状态标识，可以标识出 map 是否被 goroutine 并发读写</li>
<li>B：桶数组长度的指数，桶数组长度为 2^B</li>
<li>noverflow：map 中溢出桶的数量</li>
<li>hash0：hash 随机因子，生成 key 的 hash 值时会使用到</li>
<li>buckets：桶数组</li>
<li>oldbuckets：扩容过程中老的桶数组</li>
<li>nevacuate：扩容时的进度标识，index 小于 nevacuate 的桶都已经由老桶转移到新桶中</li>
<li>extra：预申请的溢出桶</li>
</ul>
<h3 id="3-2-mapextra"><a href="#3-2-mapextra" class="headerlink" title="3.2 mapextra"></a>3.2 mapextra</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">    overflow    *[]*bmap</span><br><span class="line">    oldoverflow *[]*bmap</span><br><span class="line">  </span><br><span class="line">    nextOverflow *bmap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 map 初始化时，如果容量过大，会提前申请好一批溢出桶，方便后续使用，这部分溢出桶存放在 hmap.mapextra 当中</p>
<ul>
<li>mapextra.overflow：供桶数组 buckets 使用的溢出桶</li>
<li>mapextra.oldoverFlow: 扩容流程中，供老桶数组 oldBuckets 使用的溢出桶</li>
<li>mapextra.nextOverflow：下一个可用的溢出桶</li>
</ul>
<h3 id="3-3-bmap"><a href="#3-3-bmap" class="headerlink" title="3.3 bmap"></a>3.3 bmap</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bucketCnt = <span class="number">8</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">	tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>bmap 就是 map 中的桶，可以存储 8 组 key-value 对的数据，以及一个指向下一个溢出桶的指针</li>
<li>每组 key-value 对数据包含 key 高 8 位 hash 值 tophash，key 和 val 三部分</li>
<li>tophash、key 和 val 的数据长度固定，因此可以通过内存地址偏移的方式寻找到后续的 key 数组、val 数组以及溢出桶指针</li>
</ul>
<h2 id="4-构造方法"><a href="#4-构造方法" class="headerlink" title="4 构造方法"></a>4 构造方法</h2><blockquote>
<p>创建 map 时，会调用 runtime/map.go 文件中的 makemap 方法</p>
</blockquote>
<h3 id="4-1-makemap"><a href="#4-1-makemap" class="headerlink" title="4.1 makemap"></a>4.1 makemap</h3><ul>
<li>hint 为 map 拟分配的容量；在分配前，会提前对拟分配的内存大小进行判断，倘若超限，会将 hint 置为零</li>
<li>通过 new 方法初始化 hmap</li>
<li>调用 fastrand，构造 hash 因子：hmap.hash0</li>
<li>大致上基于 log2(B) &gt;= hint 的思路,计算桶数组的容量 B</li>
<li>调用 makeBucketArray 方法，初始化桶数组 hmap.buckets</li>
<li>倘若 map 容量较大，会提前申请一批溢出桶 hmap.extra</li>
</ul>
<h3 id="4-2-overLoadFactor"><a href="#4-2-overLoadFactor" class="headerlink" title="4.2 overLoadFactor"></a>4.2 overLoadFactor</h3><p>通过 overLoadFactor 方法，对 map 预分配容量和桶数组长度指数进行判断，决定是否仍需要增长 B 的数值</p>
<ul>
<li>map 预分配容量小于等于 8，B 取 0，桶的个数为 1</li>
<li>保证 map 预分配容量小于等于桶数组长度 * 6.5</li>
</ul>
<h3 id="4-3-makeBucketArray"><a href="#4-3-makeBucketArray" class="headerlink" title="4.3 makeBucketArray"></a>4.3 makeBucketArray</h3><ul>
<li>makeBucketArray 会为 map 的桶数组申请内存，在桶数组的指数 b &gt;= 4时（桶数组的容量 &gt;= 52 ），会需要提前创建溢出桶.</li>
<li>通过 base 记录桶数组的长度，不包含溢出桶；通过 nbuckets 记录累加上溢出桶后，桶数组的总长度.</li>
<li>调用 newarray 方法为桶数组申请内存空间，连带着需要初始化的溢出桶</li>
<li>倘若 base != nbuckets，说明需要创建溢出桶，会基于地址偏移的方式，通过 nextOverflow 指向首个溢出桶的地址</li>
<li>倘若需要创建溢出桶，会在将最后一个溢出桶的 overflow 指针指向 buckets 数组，以此来标识申请的溢出桶已经用完</li>
</ul>
<h2 id="5-读流程"><a href="#5-读流程" class="headerlink" title="5 读流程"></a>5 读流程</h2><blockquote>
<p>map 读操作最终会走进 runtime/map.go 的 mapaccess 方法中</p>
<h3 id="5-1-读流程概览"><a href="#5-1-读流程概览" class="headerlink" title="5.1 读流程概览"></a>5.1 读流程概览</h3></blockquote>
<p>map 读流程主要分为以下几步：</p>
<ul>
<li>根据 key 取 hash 值</li>
<li>根据 hash 值对桶数组取模，确定所在的桶</li>
<li>沿着桶链表依次遍历各个桶内的 key-value 对</li>
<li>命中相同的 key，则返回 value；倘若 key 不存在，则返回零值</li>
</ul>
<h3 id="5-2-mapaccess-方法"><a href="#5-2-mapaccess-方法" class="headerlink" title="5.2 mapaccess 方法"></a>5.2 mapaccess 方法</h3><ul>
<li>倘若 map 未初始化，或此时存在 key-value 对数量为 0，直接返回零值</li>
<li>倘若发现存在其他 goroutine 在写 map，直接抛出并发读写的 fatal error；其中，并发写标记，位于 hmap.flags 的第 3 个 bit 位</li>
<li>通过 maptype.hasher() 方法计算得到 key 的 hash 值，并对桶数组长度取模，取得对应的桶</li>
<li>在取桶时，会关注当前 map 是否处于扩容的流程，倘若是的话，需要在老的桶数组 oldBuckets 中取桶，通过 evacuated 方法判断桶数据是已迁到新桶还是仍存留在老桶，倘若仍在老桶，需要取老桶进行遍历<ul>
<li>在取老桶前，会先判断 map 的扩容流程是否是增量扩容，倘若是的话，说明老桶数组的长度是新桶数组的一半，需要将桶长度值 m 除以 2</li>
<li>取老桶时，会调用 evacuated 方法判断数据是否已经迁移到新桶. 判断的方式是，取桶中首个 tophash 值，倘若该值为 2,3,4 中的一个，都代表数据已经完成迁移</li>
</ul>
</li>
<li>取 key hash 值的高 8 位值 top. 倘若该值 &lt; 5，会累加 5，以避开 0 ~ 4 的取值. 因为这几个值会用于枚举</li>
<li>开启两层 for 循环进行遍历流程，外层基于桶链表，依次遍历首个桶和后续的每个溢出桶，内层依次遍历一个桶内的 key-value 对</li>
</ul>
<h2 id="6-写流程"><a href="#6-写流程" class="headerlink" title="6 写流程"></a>6 写流程</h2><h3 id="6-1-写流程梳理"><a href="#6-1-写流程梳理" class="headerlink" title="6.1 写流程梳理"></a>6.1 写流程梳理</h3><p>map 写流程主要分为以下几步：</p>
<ul>
<li>根据 key 取 hash 值；</li>
<li>根据 hash 值对桶数组取模，确定所在的桶；</li>
<li>倘若 map 处于扩容，则迁移命中的桶，帮助推进渐进式扩容；</li>
<li>沿着桶链表依次遍历各个桶内的 key-value 对；</li>
<li>倘若命中相同的 key，则对 value 中进行更新；</li>
<li>倘若 key 不存在，则插入 key-value 对；</li>
<li>倘若发现 map 达成扩容条件，则会开启扩容模式，并重新返回第（2）步</li>
</ul>
<h3 id="6-2-mapassign"><a href="#6-2-mapassign" class="headerlink" title="6.2  mapassign"></a>6.2  mapassign</h3><ul>
<li>写操作时，倘若 map 未初始化，直接 panic</li>
<li>倘若其他 goroutine 在进行写或删操作，抛出并发写 fatal error</li>
<li>通过 maptype.hasher() 方法求得 key 对应的 hash 值</li>
<li>通过异或位运算，将 map.flags 的第 3 个 bit 位置为 1，添加写标记</li>
<li>倘若 map 的桶数组 buckets 未空，则对其进行初始化</li>
<li>找到当前 key 对应的桶索引 bucket</li>
<li>倘若发现当前 map 正处于扩容过程，则帮助其渐进扩容</li>
<li>从 map 的桶数组 buckets 出发，结合桶索引和桶容量大小，进行地址偏移，获得对应桶 b</li>
<li>取得 key 的高 8 位 tophash</li>
<li>提前声明好的三个指针，用于指向存放 key-value 的空槽</li>
<li>开启两层 for 循环，外层沿着桶链表依次遍历，内层依次遍历桶内的 key-value 对</li>
<li>倘若 key 的 tophash 和当前位置 tophash 不同，则会尝试将 inserti、insertk elem 调整指向首个空位，用于后续的插入操作</li>
<li>倘若找到了相等的 key，则执行更新操作，并且直接跳转到方法的 done 标志位处，进行收尾处理</li>
<li>倘若没找到相等的 key，会在执行插入操作前，判断 map 是否需要开启扩容模式</li>
<li>倘若遍历完桶链表，都没有为当前待插入的 key-value 对找到空位，则会创建一个新的溢出桶，挂载在桶链表的尾部，并将 inserti、insertk、elem 指向溢出桶的首个空位</li>
<li>将 tophash、key、value 插入到取得空位中，并且将 map 的 key-value 对计数器 count 值加 1</li>
<li>收尾环节，再次校验是否有其他协程并发写，倘若有，则抛 fatal error. 将 hmap.flags 中的写标记抹去，然后退出方法</li>
</ul>
<h2 id="7-删流程"><a href="#7-删流程" class="headerlink" title="7 删流程"></a>7 删流程</h2><h3 id="7-1-删流程梳理"><a href="#7-1-删流程梳理" class="headerlink" title="7.1 删流程梳理"></a>7.1 删流程梳理</h3><ul>
<li>根据 key 取 hash 值</li>
<li>根据 hash 值对桶数组取模，确定所在的桶</li>
<li>倘若 map 处于扩容，则迁移命中的桶，帮助推进渐进式扩容</li>
<li>沿着桶链表依次遍历各个桶内的 key-value 对</li>
<li>倘若命中相同的 key，删除对应的 key-value 对；并将当前位置的 tophash 置为 emptyOne，表示为空</li>
<li>倘若当前位置为末位，或者下一个位置的 tophash 为 emptyRest，则沿当前位置向前遍历，将毗邻的 emptyOne 统一更新为 emptyRest</li>
</ul>
<h2 id="8-遍历流程"><a href="#8-遍历流程" class="headerlink" title="8 遍历流程"></a>8 遍历流程</h2><p>map 的遍历流程首先会走进 runtime/map.go 的 mapiterinit() 方法当中，初始化用于遍历的迭代器 hiter；接着会调用 runtime/map.go 的 mapiternext() 方法开启遍历流程</p>
<h3 id="8-1-迭代器数据结构"><a href="#8-1-迭代器数据结构" class="headerlink" title="8.1 迭代器数据结构"></a>8.1 迭代器数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    key         unsafe.Pointer </span><br><span class="line">    elem        unsafe.Pointer </span><br><span class="line">    t           *maptype</span><br><span class="line">    h           *hmap</span><br><span class="line">    buckets     unsafe.Pointer </span><br><span class="line">    bptr        *bmap         </span><br><span class="line">    overflow    *[]*bmap      </span><br><span class="line">    oldoverflow *[]*bmap      </span><br><span class="line">    startBucket <span class="type">uintptr</span>       </span><br><span class="line">    offset      <span class="type">uint8</span>         </span><br><span class="line">    wrapped     <span class="type">bool</span>         </span><br><span class="line">    B           <span class="type">uint8</span></span><br><span class="line">    i           <span class="type">uint8</span></span><br><span class="line">    bucket      <span class="type">uintptr</span></span><br><span class="line">    checkBucket <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>key：指向遍历得到 key 的指针</li>
<li>value：指向遍历得到 value 的指针</li>
<li>t：map 类型，包含了 key、value 类型大小等信息</li>
<li>h：map 的指针</li>
<li>bptr：当前遍历到的桶</li>
<li>startBucket：遍历起始位置的桶索引</li>
<li>offset：遍历起始位置的 key-value 对索引</li>
<li>wrapped：遍历是否穿越桶数组尾端回到头部了</li>
<li>i：当前遍历到的 key-value 对在桶中的索引</li>
<li>checkBucket：因为扩容流程的存在，需要额外检查的桶</li>
</ul>
<h2 id="9-扩容流程"><a href="#9-扩容流程" class="headerlink" title="9 扩容流程"></a>9 扩容流程</h2><h3 id="9-1-扩容类型"><a href="#9-1-扩容类型" class="headerlink" title="9.1 扩容类型"></a>9.1 扩容类型</h3><p>map 的扩容类型分为两类，一类叫做增量扩容，一类叫做等量扩容</p>
<ul>
<li>增量扩容<ul>
<li>扩容后，桶数组的长度增长为原长度的 2 倍</li>
<li>降低每个桶中 key-value 对的数量，优化 map 操作的时间复杂度</li>
</ul>
</li>
<li>等量扩容<ul>
<li>扩容后，桶数组的长度和之前保持一致；但是溢出桶的数量会下降</li>
<li>提高桶主体结构的数据填充率，减少溢出桶数量，避免发生内存泄漏</li>
</ul>
</li>
</ul>
<h3 id="9-2-扩容触发"><a href="#9-2-扩容触发" class="headerlink" title="9.2 扩容触发"></a>9.2 扩容触发</h3><ul>
<li>只有 map 的写流程可能开启扩容模式</li>
<li>写 map 新插入 key-value 对之前，会发起是否需要扩容的逻辑判断</li>
<li>根据 hmap 的 oldbuckets 是否空，可以判断 map 此前是否已开启扩容模式</li>
<li>倘若此前未进入扩容模式，且 map 中 key-value 对的数量超过 8 个，且大于桶数组长度的 6.5 倍，则进入增量扩容</li>
<li>倘若溢出桶的数量大于 2^B 个（即桶数组的长度；B 大于 15 时取15），则进入等量扩容</li>
</ul>
<h3 id="9-3-扩容迁移规则"><a href="#9-3-扩容迁移规则" class="headerlink" title="9.3 扩容迁移规则"></a>9.3 扩容迁移规则</h3><ul>
<li>在等量扩容中，新桶数组长度与原桶数组相同；</li>
<li>key-value 对在新桶数组和老桶数组的中的索引号保持一致；</li>
<li>在增量扩容中，新桶数组长度为原桶数组的两倍；</li>
<li>把新桶数组中桶号对应于老桶数组的区域称为 x 区域，新扩展的区域称为 y 区域.</li>
<li>实际上，一个 key 属于哪个桶，取决于其 hash 值对桶数组长度取模得到的结果，因此依赖于其低位的 hash 值结果.；</li>
<li>在增量扩容流程中，新桶数组的长度会扩展一位，假定 key 原本从属的桶号为 i，则在新桶数组中从属的桶号只可能是 i （x 区域）或者 i + 老桶数组长度（y 区域）；</li>
<li>当 key 低位 hash 值向左扩展一位的 bit 位为 0，则应该迁往 x 区域的 i 位置；倘若该 bit 位为 1，应该迁往 y 区域对应的 i + 老桶数组长度的位置.</li>
</ul>
<h3 id="9-4-渐进式扩容"><a href="#9-4-渐进式扩容" class="headerlink" title="9.4 渐进式扩容"></a>9.4 渐进式扩容</h3><ul>
<li>map 采用的是渐进扩容的方式，避免因为一次性的全量数据迁移引发性能抖动.</li>
<li>当每次触发写、删操作时，会为处于扩容流程中的 map 完成两组桶的数据迁移<ul>
<li>一组桶是当前写、删操作所命中的桶</li>
<li>另一组桶是，当前未迁移的桶中，索引最小的那个桶</li>
</ul>
</li>
</ul>

    
  </div>

  
  <!-- Post Copyright -->

<div class="post-copyright">
  <p class="copyright-item">
    <span>Author: </span>
    <a href="https://stardustorz.github.io">draco</a>
  </p>
  <p class="copyright-item">
    <span>Link: </span>
    <a href="https://stardustorz.github.io/2025/06/03/Golang/0%20%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Map/">https://stardustorz.github.io/2025/06/03/Golang/0%20%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Map/</a>
  </p>
  <p class="copyright-item">
    <span>License: </span>
    
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
  </p>
</div>

    

  

  
  <footer class="post-footer">
    
    <div class="post-tags">
      
      <a href="/tags/Golang/">Golang</a>
      
      <a href="/tags/Go%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">Go数据结构</a>
      
    </div>
    
      
  <nav class="post-nav">  
      
      <a class="prev" href="/2025/06/03/Golang/0%20%E5%9F%BA%E7%A1%80/%E5%85%B3%E9%94%AE%E5%AD%97/for%20%E5%92%8C%20range/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text nav-default">[Go] for 和 range</span>  
        <span class="prev-text nav-mobile">Prev</span>  
      </a>  
      
      
      <a class="next" href="/2025/06/03/Golang/0%20%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/String/">  
        <span class="next-text nav-default">[Go] String</span>  
        <span class="prev-text nav-mobile">Next</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  </footer>
  

</article>
        </div>
      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2019 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">draco</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
  







<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>



<script type="text/javascript" src="/lib/slideout/slideout.js"></script>



<script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>