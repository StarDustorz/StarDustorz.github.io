<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->

<meta name="description" content="[Basic] Computer Network" />


<!-- Website keywords -->

<meta name="keywords" content="Basic, Draco&#39;s Blog" />




<!-- Website rss -->

<link rel="alternate" href="/atom.xml" title="Draco's Blog" type="application/atom+xml">


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://stardustorz.github.io/2025/07/25/Basic/计算机网络/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":false};
</script>
  
  <title>[Basic] Computer Network - Draco&#39;s Blog</title>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Draco&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        Home              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        Archives              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        Tags              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        Categories              </li>
    </a>
    
    <a href="/links/">
      <li class="mobile-menu-item">
        
        
        Links              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        About              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">Draco's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              Home  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              Archives  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              Tags  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              Categories  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/links/">  
              
              
              Links  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              About  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      [Basic] Computer Network
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-07-25
      </span>
      
      
      
    </div>
  </header>

  
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.</span> <span class="toc-text">1 网络模型与协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%88%86%E5%B1%82%E8%A7%A3%E6%9E%90"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 网络模型分层解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 常见协议报文格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-HTTP-amp-HTTPS"><span class="toc-number">2.</span> <span class="toc-text">2 HTTP &amp; HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-HTTP"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-HTTP-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1 HTTP 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-1-HTTP-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">2.1.1.1 HTTP 是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-2-HTTP-%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">2.1.1.2 HTTP 常见状态码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-1-3-HTTP-%E5%B8%B8%E8%A7%81%E5%AD%97%E6%AE%B5"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">2.1.1.3 HTTP 常见字段</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-GET-%E5%92%8C-POST-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2 GET 和 POST 有什么区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-3-HTTP%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="toc-number">2.1.3.</span> <span class="toc-text">2.1.3 HTTP缓存技术</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-4-HTTP%E7%89%B9%E6%80%A7"><span class="toc-number">2.1.4.</span> <span class="toc-text">2.1.4 HTTP特性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-HTTPS"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-HTTPS-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.2.1.</span> <span class="toc-text">2.2.1 HTTPS 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-HTTPS-%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.2.2 HTTPS 怎么保证数据完整性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-HTTPS-%E4%B8%80%E5%AE%9A%E5%AE%89%E5%85%A8%E5%90%97"><span class="toc-number">2.2.3.</span> <span class="toc-text">2.2.3 HTTPS 一定安全吗</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-HTTP-1-1-amp-2-0-amp-3-0-%E6%BC%94%E5%8F%98"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 HTTP 1.1&amp;2.0 &amp; 3.0 演变</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-HTTP-1-1-%E7%9B%B8%E6%AF%94-HTTP-1-0"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 HTTP&#x2F;1.1 相比 HTTP&#x2F;1.0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-HTTP-2-%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 HTTP&#x2F;2 优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-HTTP-3-%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3 HTTP&#x2F;3 优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-HTTP-amp-RPC"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 HTTP &amp; RPC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-TCP-amp-UDP"><span class="toc-number">3.</span> <span class="toc-text">3 TCP &amp; UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 简介与区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-TCP"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 TCP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8F%AF%E9%9D%A0%EF%BC%9F"><span class="toc-number">3.2.1.</span> <span class="toc-text">3.2.1 如何保证可靠？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">3.2.2.</span> <span class="toc-text">3.2.2 三次握手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">3.2.3.</span> <span class="toc-text">3.2.3 四次挥手</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.4.</span> <span class="toc-text">3.2.4 重传机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">3.2.5.</span> <span class="toc-text">3.2.5 滑动窗口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-6-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">3.2.6.</span> <span class="toc-text">3.2.6 流量控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-7-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">3.2.7.</span> <span class="toc-text">3.2.7 拥塞控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-8-%E6%8B%BE%E9%81%97"><span class="toc-number">3.2.8.</span> <span class="toc-text">3.2.8 拾遗</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-IP%E5%8D%8F%E8%AE%AE"><span class="toc-number">4.</span> <span class="toc-text">4 IP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 基本认识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Ping"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 Ping</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-DNS%E5%8D%8F%E8%AE%AE"><span class="toc-number">5.</span> <span class="toc-text">5 DNS协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%8B%BE%E9%81%97"><span class="toc-number">6.</span> <span class="toc-text">6 拾遗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%EF%BC%8C%E6%9C%9F%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 键入网址到网页显示，期间发生了什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-TCP-%E6%8A%A5%E6%96%87%E5%A4%B4%E9%83%A8"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 TCP 报文头部</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E7%BD%91%E7%BB%9C%E6%8A%A5%E6%96%87%E5%9B%BE"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 网络报文图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB"><span class="toc-number">6.4.</span> <span class="toc-text">6.4 网络攻击</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-1-CSRF%E6%94%BB%E5%87%BB"><span class="toc-number">6.4.1.</span> <span class="toc-text">6.4.1 CSRF攻击</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-XSS%E6%94%BB%E5%87%BB"><span class="toc-number">6.4.2.</span> <span class="toc-text">6.4.2 XSS攻击</span></a></li></ol></li></ol></li></ol>
    </div>
  </div>
  

  <div class="post-content">
    
    <span id="more"></span>
<h2 id="1-网络模型与协议"><a href="#1-网络模型与协议" class="headerlink" title="1 网络模型与协议"></a>1 网络模型与协议</h2><h3 id="1-1-网络模型分层解析"><a href="#1-1-网络模型分层解析" class="headerlink" title="1.1 网络模型分层解析"></a>1.1 网络模型分层解析</h3><ul>
<li><code>OSI七层模型</code>：应用（DNS，HTTP，SMTP，FTP）， 表示 ，会话，传输（TCP、UDP），网络（IP ICMP），数据链路，物理</li>
<li><code>TCP/IP</code>：<ul>
<li><code>应用层</code>：工作在用户态，往下都在内核态；主要协议有：HTTP、FTP、Telnet、DNS、SMTP等</li>
<li><code>传输层</code>：为用层提供网络支持；主要协议有 TCP&amp;UDP，加上 TCP 头部</li>
<li><code>网络层</code>：实现实际的传输功能；主要协议有 IP 协议，加上 IP 头部</li>
<li><code>网络接口层</code>：链路级别， IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上<h3 id="1-2-常见协议报文格式"><a href="#1-2-常见协议报文格式" class="headerlink" title="1.2 常见协议报文格式"></a>1.2 常见协议报文格式</h3></li>
</ul>
</li>
<li><code>TCP首部格式</code>（源/目标端口号; 序列号(随机数,避免乱序); 确认号(避免丢包); 首部长度; 关键字; 窗口; 校验和）</li>
<li><code>UDP</code>（端口号 长度 校验和） 包 最大为64k</li>
<li><code>IP报文</code>（版本 首部长度 服务类型 总长度 生存时间 校验和 ip地址</li>
<li><code>TCP</code>：TCP<code>最大报文段长度</code>（MSS，536字节），超过就分块（TCP Segment） IP：加上IP头成为IP报文，如果超过<code>MTU</code>（1500字节）就分片</li>
</ul>
<h2 id="2-HTTP-amp-HTTPS"><a href="#2-HTTP-amp-HTTPS" class="headerlink" title="2 HTTP &amp; HTTPS"></a>2 HTTP &amp; HTTPS</h2><h3 id="2-1-HTTP"><a href="#2-1-HTTP" class="headerlink" title="2.1 HTTP"></a>2.1 HTTP</h3><h4 id="2-1-1-HTTP-基本概念"><a href="#2-1-1-HTTP-基本概念" class="headerlink" title="2.1.1 HTTP 基本概念"></a>2.1.1 HTTP 基本概念</h4><h5 id="2-1-1-1-HTTP-是什么？"><a href="#2-1-1-1-HTTP-是什么？" class="headerlink" title="2.1.1.1 HTTP 是什么？"></a>2.1.1.1 HTTP 是什么？</h5><p>超文本传输协议</p>
<h5 id="2-1-1-2-HTTP-常见状态码"><a href="#2-1-1-2-HTTP-常见状态码" class="headerlink" title="2.1.1.2 HTTP 常见状态码"></a>2.1.1.2 HTTP 常见状态码</h5><ul>
<li>1xx：<strong>指示信息</strong>—表示请求已接收，继续处理；</li>
<li>2xx：<strong>成功</strong>—表示请求已被成功接收、理解、接受；200—OK 204—请求收到，但返回信息为空 206—服务器已经完成了部分用户的GET请求</li>
<li>3xx：<strong>重定向</strong>—信息不完整需要进一步补充；300 请求资源在多处可得到。301—永久重定向，隐式重定向。302 临时重定向，显示重定向。 304—请求的资源没有改变，可以使用缓存。</li>
<li>4xx：<strong>客户端错误</strong>—请求有语法错误或请求无法实现； 401—-未授权 403—禁止访问。 404 –找不到。409：对当前资源状态，请求不能完成</li>
<li>5xx：<strong>服务器端错误</strong>—服务器未能实现合法的请求；500内部服务器错误，501未实现，502网关错误，503服务不可用，504 网关超时<h5 id="2-1-1-3-HTTP-常见字段"><a href="#2-1-1-3-HTTP-常见字段" class="headerlink" title="2.1.1.3 HTTP 常见字段"></a>2.1.1.3 HTTP 常见字段</h5></li>
<li><em>Host</em> 字段：指定服务器域名</li>
<li><em>Content-Length 字段</em>：表明本次回应的数据长度</li>
<li><em>Connection 字段</em>：要求服务器使用「HTTP 长连接」机制，Keep-Alive</li>
<li><em>Content-Type 字段</em>：本次数据格式</li>
<li><em>Content-Encoding 字段</em>：数据的压缩方法<h4 id="2-1-2-GET-和-POST-有什么区别"><a href="#2-1-2-GET-和-POST-有什么区别" class="headerlink" title="2.1.2 GET 和 POST 有什么区别"></a>2.1.2 GET 和 POST 有什么区别</h4></li>
<li><code>RFC 规范</code>：GET 的语义是从服务器 <em>获取指定的资源</em>；POST 的语义是根据请求负荷（报文body）对 <em>指定的资源做出处理</em></li>
<li>GET 方法是安全、幂等、可被缓存的</li>
<li>POST 不安全，不幂等，（大部分实现）不可缓存<h4 id="2-1-3-HTTP缓存技术"><a href="#2-1-3-HTTP缓存技术" class="headerlink" title="2.1.3 HTTP缓存技术"></a>2.1.3 HTTP缓存技术</h4></li>
<li><code>强制缓存</code>：Cache-Control 和 Expires 控制资源在客户端的缓存有效期</li>
<li><code>协商缓存</code>：<em>Last-Modified</em> 资源没修改，响应 HTTP 304 走缓存 ; <em>ETag</em>,判断资源有没有变化<h4 id="2-1-4-HTTP特性"><a href="#2-1-4-HTTP特性" class="headerlink" title="2.1.4 HTTP特性"></a>2.1.4 HTTP特性</h4></li>
<li>优点：简单，灵活容易拓展，跨平台</li>
<li>缺点：明文传输，无状态，不安全</li>
<li>性能：<em>长连接</em>；<em>管道网络传输</em>：当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」<h3 id="2-2-HTTPS"><a href="#2-2-HTTPS" class="headerlink" title="2.2 HTTPS"></a>2.2 HTTPS</h3><h4 id="2-2-1-HTTPS-的区别"><a href="#2-2-1-HTTPS-的区别" class="headerlink" title="2.2.1 HTTPS 的区别"></a>2.2.1 HTTPS 的区别</h4></li>
<li><code>加密传输</code>：在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议<ul>
<li>混合加密：<strong>对称加密</strong>和<strong>非对称加密</strong>结合，非对称加密交换会话秘钥</li>
<li><em>摘要算法 + 数字签名</em>：计算内容的指纹</li>
</ul>
</li>
<li><code>连接建立</code>：需进行 SSL/TLS 的握手过程<ul>
<li>基于 RSA 的 TLS 握手过程<ul>
<li><em>ClientHello</em>：客户端发起加密通信请求，发送（一个随机数，TLS 版本，加密算法）给服务器</li>
<li><em>SeverHello</em>：服务端回应，发送随机数和数字证书</li>
<li><em>客户端回应</em>：取出公钥加密报文，再发送随机数过去，握手介绍，生成摘要</li>
<li><em>服务器的最后回应</em>： 计算出本次通话的会话秘钥，变更加密通信算法</li>
</ul>
</li>
</ul>
</li>
<li><code>默认端口</code>：HTTP 默认端口号是 <code>80</code>，HTTPS 默认端口号是 <code>443</code></li>
<li><code>可信身份</code>：向 CA（证书权威机构）申请数字证书<ul>
<li>把公钥注册到 CA，客户端拿到<code>数字证书</code>（公钥+数字签名）后用 CA 的公钥验证<h4 id="2-2-2-HTTPS-怎么保证数据完整性"><a href="#2-2-2-HTTPS-怎么保证数据完整性" class="headerlink" title="2.2.2 HTTPS 怎么保证数据完整性"></a>2.2.2 HTTPS 怎么保证数据完整性</h4></li>
</ul>
</li>
<li>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</li>
<li>TLS 握手协议负责协商加密算法和生成对称密钥</li>
<li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源<ul>
<li>消息被分割成多个较短的片段,然后分别对每个片段进行压缩</li>
<li><strong>加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证</strong>。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</li>
<li>经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。</li>
<li>经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li>
</ul>
</li>
</ul>
<h4 id="2-2-3-HTTPS-一定安全吗"><a href="#2-2-3-HTTPS-一定安全吗" class="headerlink" title="2.2.3 HTTPS 一定安全吗"></a>2.2.3 HTTPS 一定安全吗</h4><ul>
<li>中间人攻击：客户端接受了中间人服务器的证书，然后中间人分别和客户端服务器 TLS 握手并转发。</li>
<li>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。</li>
<li>抓包：使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。<h3 id="2-3-HTTP-1-1-amp-2-0-amp-3-0-演变"><a href="#2-3-HTTP-1-1-amp-2-0-amp-3-0-演变" class="headerlink" title="2.3 HTTP 1.1&amp;2.0 &amp; 3.0 演变"></a>2.3 HTTP 1.1&amp;2.0 &amp; 3.0 演变</h3><h4 id="2-3-1-HTTP-1-1-相比-HTTP-1-0"><a href="#2-3-1-HTTP-1-1-相比-HTTP-1-0" class="headerlink" title="2.3.1 HTTP/1.1 相比 HTTP/1.0"></a>2.3.1 HTTP/1.1 相比 HTTP/1.0</h4></li>
<li>优点：<ul>
<li>使用<code>长连接</code>的方式改善了 HTTP/1.0 短连接造成的性能开销。</li>
<li>支持管道（pipeline）网络传输</li>
</ul>
</li>
<li>缺点：<ul>
<li>请求 / 响应头部（Header）没压缩，造成浪费</li>
<li>队头阻塞</li>
<li>没有请求优先级控制</li>
<li>服务器只能被动响应<h4 id="2-3-2-HTTP-2-优化"><a href="#2-3-2-HTTP-2-优化" class="headerlink" title="2.3.2 HTTP/2 优化"></a>2.3.2 HTTP/2 优化</h4></li>
</ul>
</li>
<li><em>头部压缩</em>：消除重复的部分,HPACK算法维护头信息表和字段的映射</li>
<li><em>二进制格式</em>：头信息和数据体都是二进制，并且统称为帧（frame）</li>
<li><em>并发传输</em>：引入了 Stream，针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，可以并行交错地发送请求和响应</li>
<li><em>服务器推送</em>：<strong>双方都可以建立 Stream</strong>，服务器可以主动向客户端发送消息</li>
<li>问题：基于 TCP 传输数据，需要按序到达缓冲区才能从内核取数据，一旦丢包就会阻塞所有请求这就是 HTTP/2 <code>队头阻塞</code>问题。<h4 id="2-3-3-HTTP-3-优化"><a href="#2-3-3-HTTP-3-优化" class="headerlink" title="2.3.3 HTTP/3 优化"></a>2.3.3 HTTP/3 优化</h4></li>
<li><strong>把 HTTP 下层的 TCP 协议改成了 UDP</strong></li>
<li>基于 UDP 的 <strong>QUIC 协议</strong>实现可靠传输：就是把 TCP 的校验放到应用层实现</li>
</ul>
<h3 id="2-4-HTTP-amp-RPC"><a href="#2-4-HTTP-amp-RPC" class="headerlink" title="2.4 HTTP &amp; RPC"></a>2.4 HTTP &amp; RPC</h3><ul>
<li>TCP 的特点 <strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong><ul>
<li>没有消息边界，于是会加上信息头，以及包长度</li>
<li>需要协议约定消息体格式</li>
</ul>
</li>
<li>服务发现：HTTP 只要知道网址就可以 DNS 解析出 IP 地址和 80 端口；RPC 需要之间服务</li>
<li>传输的内容：RPC 定制化程度高，序列化协议多，性能稍好</li>
<li><code>gRPC</code> 底层都直接用的 <code>HTTP/2</code></li>
<li>HTTP/2 是 2015 年出来的，有惯性<h2 id="3-TCP-amp-UDP"><a href="#3-TCP-amp-UDP" class="headerlink" title="3 TCP &amp; UDP"></a>3 TCP &amp; UDP</h2><h3 id="3-1-简介与区别"><a href="#3-1-简介与区别" class="headerlink" title="3.1 简介与区别"></a>3.1 简介与区别</h3></li>
<li>TCP 头部<ul>
<li>![[Pasted image 20230904012336.png]]</li>
<li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li>
<li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li>
</ul>
</li>
<li><code>为什么需要 TCP</code>？ IP 层不可靠，需要传输层确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></li>
<li><code>什么是 TCP</code>：<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</li>
<li><p>什么是 TCP 连接？用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 <code>Socket、序列号和窗口大小</code>称为连接。</p>
<ul>
<li>连接数量限制：文件描述符限制，内存限制，单机最大 TCP 连接数，约为 <code>2</code> 的 <code>48</code> 次方</li>
</ul>
</li>
<li><p><code>UDP 和 TCP 有什么区别呢？分别的应用场景是？</code></p>
<ul>
<li><em>连接</em>：UDP 不需要连接，即刻传输数据</li>
<li><em>服务对象</em>：TCP 是一对一的两点服务；UDP 支持一对一、一对多、多对多的交互通信</li>
<li><em>可靠性</em>：UDP 尽最大努力交付，不保证可靠交付数据</li>
<li><em>拥塞控制、流量控制</em>：网络拥堵也不影响 UDP 发送速率</li>
<li><em>传输方式</em>：TCP 是流式传输，没有边界；UDP 是一个包一个包的发送</li>
<li><em>分片不同</em>：TCP 大于 MSS(536字节) 在传输层分片；UDP 大于 MTU(1500字节)在 IP 层分片</li>
<li><em>使用场景</em>：TCP 用于文件传输，HTTP 等；UDP 用于视频，广播，<code>DNS</code> 等</li>
</ul>
</li>
<li><code>有一方突然断电或者崩溃</code><ul>
<li>两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。</li>
<li>服务端是<strong>无法感知到的</strong>，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，<strong>服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态</strong>，直到服务端重启进程。</li>
<li>所以，我们可以得知一个点，在没有使用 TCP 保活机制且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED 状态，并不代表另一方的连接还一定正常。</li>
<li><strong>在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手</strong>。所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</li>
<li>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li>
<li>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li>
<li><code>在客户端主机宕机后</code>，服务端向客户端发送的报文会得不到任何的响应，在一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的报文。<ul>
<li>服务端重传报文的过程中，客户端主机重启完成后，客户端的内核就会接收重传的报文，然后根据报文的信息传递给对应的进程：</li>
<li>如果客户端主机上<strong>没有</strong>进程监听该 TCP 报文的目标端口号，那么客户端内核就会<em>*回复 RST 报文，重置该 TCP 连接</em>；</li>
<li>如果客户端主机上<strong>有</strong>进程监听该 TCP 报文的目标端口号，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会<strong>回复 RST 报文，重置该 TCP 连接</strong>。</li>
<li>所以，只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接。<h3 id="3-2-TCP"><a href="#3-2-TCP" class="headerlink" title="3.2 TCP"></a>3.2 TCP</h3><h4 id="3-2-1-如何保证可靠？"><a href="#3-2-1-如何保证可靠？" class="headerlink" title="3.2.1 如何保证可靠？"></a>3.2.1 如何保证可靠？</h4><h4 id="3-2-2-三次握手"><a href="#3-2-2-三次握手" class="headerlink" title="3.2.2 三次握手"></a>3.2.2 三次握手</h4></li>
</ul>
</li>
</ul>
</li>
<li><em>目的</em>:<ul>
<li><code>防止旧的重复连接初始化造成混乱</code>：网络阻塞重发建立连接请求</li>
<li><code>同步双方的初始序列号</code></li>
<li><code>避免资源浪费</code>：避免建立冗余链接</li>
</ul>
</li>
<li><em>过程</em>：控制位: ACK(确认应答); RST(强制断开); SYN(建立连接); FIN(断开连接)<ul>
<li>建立连接时，客户端随机初始化序列号（<strong>client-isn</strong>），<strong>SYN 标志为1</strong>，表示 SYN 报文，发送到服务器，并进入<strong>SYN-SENT状态</strong>，等待服务器确认；</li>
<li>服务器收到SYN报文，也随机初始化自己的序列号（server-isn），填入序号，然后在<strong>确认应答号字段</strong>填入 <strong>client-isn+1</strong>，然后将<strong>SYN和ACK置为1</strong>，发送给客户端。此时服务器进入<strong>SYN_RECV状态</strong>；</li>
<li>客户端收到服务器报文后，向服务器回应最后一个应答报文，ACK=1，确认应答号填入server-isn+1，发送给服务端，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<strong>此次可以携带数据</strong></li>
<li><code>netstat -napt</code> 查看连接状态</li>
</ul>
</li>
<li><em>握手丢失</em>：<ul>
<li>第一次：客户端超时重传</li>
<li>第二次：服务端超时重传</li>
<li>第三次：服务端超时重传</li>
</ul>
</li>
<li><em>SYN 攻击</em>：<ul>
<li>Linux 内核会维护两个队列:半连接队列，全连接队列</li>
<li>SYN 攻击就是打满半连接队列</li>
<li>解决：<ul>
<li>调大 netdev_max_backlog，保存数据包的队列</li>
<li>增大 TCP 半连接队列</li>
<li>开启 tcp_syncookies，绕开 SYN 半连接建立连接</li>
<li>减少 SYN+ACK 重传次数，加快处于 SYN_REVC 状态的 TCP 连接断开<h4 id="3-2-3-四次挥手"><a href="#3-2-3-四次挥手" class="headerlink" title="3.2.3 四次挥手"></a>3.2.3 四次挥手</h4></li>
</ul>
</li>
</ul>
</li>
<li><em>目的</em>：客户端发送了FIN连接释放报文后，服务器加入close-wait状态，是为了<code>让服务器发送还未传送完毕的数据</code>，传送完毕之后，服务器会发送FIN连接释放报文;</li>
<li><em>过程</em>：<ul>
<li>客户端发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li>
<li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</li>
<li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li>
<li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li>
<li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li>
</ul>
</li>
<li><em>TIME_WAIT状态</em>： <ul>
<li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li>
<li>保证「被动关闭连接」的一方，能被正确的关闭；确保最后的 ACK 到达。</li>
<li>MSL：<strong>报文最大生存时间</strong>，2MSL是允许报文丢失一次</li>
<li>过多会占用系统资源和端口资源；复用<strong>TIME_WAIT</strong>的 socket；超过 18000 直接重置；让客户端去断开，承受<strong>TIME_WAIT</strong></li>
<li>出现大量TIME_WAIT状态？ 没有用长连接；长连接超时；<h4 id="3-2-4-重传机制"><a href="#3-2-4-重传机制" class="headerlink" title="3.2.4 重传机制"></a>3.2.4 重传机制</h4></li>
</ul>
</li>
<li>TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决</li>
<li><em>超时重传</em>：<ul>
<li>触发场景：数据包丢失，确认应答丢失</li>
<li>超时时间：RTO 略大于 RTT <code>包往返时间</code></li>
<li>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送</li>
</ul>
</li>
<li><em>快速重传</em>：<code>三次重复的 ACK</code> 触发，但是不知道要重传一个还是所有</li>
<li><em>SACK 方法</em>：<code>选择性确认</code>，将已收到的数据的信息发送给「发送方」</li>
<li><em>D-ACK</em>：Duplicate 使用了 SACK 来告诉「发送方」有哪些数据被<code>重复接收</code>了，可以知道是数据包丢了还是 ACK 包丢了<h4 id="3-2-5-滑动窗口"><a href="#3-2-5-滑动窗口" class="headerlink" title="3.2.5 滑动窗口"></a>3.2.5 滑动窗口</h4></li>
<li><em>窗口</em>：一个缓存空间，是无需等待确认应答，而可以继续发送数据的<code>最大值</code></li>
<li>TCP 报文中的 Windows 字段控制</li>
<li>四部分：发送已确认，发送未确认，未发生但是在处理范围内，未发送范围外<h4 id="3-2-6-流量控制"><a href="#3-2-6-流量控制" class="headerlink" title="3.2.6 流量控制"></a>3.2.6 流量控制</h4></li>
<li>让「发送方」根据「接收方」的<code>实际接收能力</code>控制发送的数据量，让接受方处理的过来</li>
<li><em>窗口关闭</em>：可能导致死锁。收到零窗口通知，就启动<code>持续计时器</code>，如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文。</li>
<li><em>糊涂窗口综合症</em>：接收方太忙，来不及处理，窗口越来越小<ul>
<li>接收方不通告小窗口：小于 MSS 或者 缓存空间/2 ，通告窗口为 0</li>
<li>发送方避免发送小数据：Nagle 算法，除非窗口够大且数据够多并且收到 ack，否则囤积数据<h4 id="3-2-7-拥塞控制"><a href="#3-2-7-拥塞控制" class="headerlink" title="3.2.7 拥塞控制"></a>3.2.7 拥塞控制</h4></li>
</ul>
</li>
<li>避免「发送方」的数据填满整个网络。发送方维护一个叫<code>拥塞窗口</code>（cwnd）的状态变量</li>
<li><em>慢开始与拥塞避免</em>：发送的最初执行<code>慢开始</code>，令cwnd=1，发送方只能发送一个报文段，当收到确认后，将cwnd<code>加倍</code>，设置一个<code>慢开始门限</code> ssthresh，当cwnd&gt;=ssthresh时进入<code>拥塞避免</code>，按照<code>线性</code>增长方式增加，线性增长达到<code>网络拥塞</code>时，则令ssthresh=cwnd/2，然后重新执行慢开始。</li>
<li><em>快重传与快恢复</em>：每次接收到报文段都对最后一个已收到的的有序报文段进行<code>确认</code>。在发送方，如果收到<code>三个重复确认</code>，那么可以知道下一个报文段丢失，此时执行快重传，<code>立即重传下一个报文段</code>。在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行<code>快恢复</code>，令ssthresh = cwnd/2，cwnd = ssthresh 。直接进入<code>拥塞避免</code>。<h4 id="3-2-8-拾遗"><a href="#3-2-8-拾遗" class="headerlink" title="3.2.8 拾遗"></a>3.2.8 拾遗</h4></li>
<li>查看 TCP 连接信息的命令？ <code>netstat -napt</code></li>
</ul>
<h2 id="4-IP协议"><a href="#4-IP协议" class="headerlink" title="4 IP协议"></a>4 IP协议</h2><h3 id="4-1-基本认识"><a href="#4-1-基本认识" class="headerlink" title="4.1 基本认识"></a>4.1 基本认识</h3><ul>
<li>处于第三层，也就是<strong>网络层</strong>：实现主机与主机之间的通信</li>
<li>DNS：解析 IP 地址</li>
<li>ARP：获取下一跳的 MAC 地址，通过广播 ARP 请求与 ARP 响应实现</li>
<li>ICMP：<strong>互联网控制报文协议</strong>，确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等<h3 id="4-2-Ping"><a href="#4-2-Ping" class="headerlink" title="4.2 Ping"></a>4.2 Ping</h3></li>
<li><em>工作原理</em>：基于 ICMP 协议工作<ul>
<li><strong>发送ICMP请求</strong>：Ping工具向目标主机发送一个ICMP请求数据包（通常是一个特殊的Echo请求），请求目标主机进行响应。</li>
<li><strong>目标主机响应</strong>：目标主机接收到ICMP请求后，会发送一个ICMP响应数据包（Echo响应）回给Ping工具。</li>
<li><strong>测量延迟</strong>：Ping工具在发送ICMP请求和接收ICMP响应之间测量时间，从而计算出往返时间（Round-Trip Time，RTT）。RTT表示数据从Ping工具发送到目标主机并返回所需的时间，用于衡量网络的延迟。</li>
<li><strong>报告结果</strong>：Ping工具会显示目标主机的IP地址、RTT和其他统计信息，以便用户可以了解网络连接的质量和性能。</li>
</ul>
</li>
<li>ping 127.0.0.1<ul>
<li><strong>127 开头的都属于回环地址</strong>：目标 IP 是回环地址是会选择本地网卡</li>
</ul>
</li>
<li>ping 0.0.0.0<ul>
<li>会失败，因为这是无效的目标地址</li>
</ul>
</li>
</ul>
<h2 id="5-DNS协议"><a href="#5-DNS协议" class="headerlink" title="5 DNS协议"></a>5 DNS协议</h2><ol>
<li>DNS 解析过程，端口号？<ol>
<li>客户端发出 DNS 请求到<code>本地 DNS 服务器</code></li>
<li><code>本地 DNS 服务器</code>如果没有对应的缓存，就去访问<code>根域名服务器</code></li>
<li>根域名返回网址对应的<code>顶级域名服务器</code>地址</li>
<li><code>本地 DNS 服务器</code>请求<code>顶级域名服务器</code>，获得<code>权威 DNS 服务器</code>的地址</li>
<li><code>本地 DNS 服务器</code>请求<code>权威 DNS 服务器</code>，获取 IP 地址</li>
<li>返回给客户端，客户端和目标建立连接</li>
</ol>
</li>
<li>DNS 使用什么传输层协议？<ol>
<li>多数情况下使用 UDP</li>
<li>响应的大小超过UDP数据包的<code>最大限制</code>和<code>进行区域传输</code>（Zone Transfer）时 使用 TCP</li>
</ol>
</li>
</ol>
<h2 id="6-拾遗"><a href="#6-拾遗" class="headerlink" title="6 拾遗"></a>6 拾遗</h2><h3 id="6-1-键入网址到网页显示，期间发生了什么？"><a href="#6-1-键入网址到网页显示，期间发生了什么？" class="headerlink" title="6.1 键入网址到网页显示，期间发生了什么？"></a>6.1 键入网址到网页显示，期间发生了什么？</h3><ol>
<li><code>解析 URL</code>：确定了 Web 服务器和文件名，生成 HTTP 请求</li>
<li><code>查询服务器域名对应的 IP 地址</code>：按照浏览器缓存，操作系统缓存和 hosts 的顺序查询，如果没有就去请求本地 DNS 服务器，进入 <code>DNS 解析流程</code></li>
<li>应用程序（浏览器）通过调用 Socket 库，来委托<code>协议栈</code>工作<ol>
<li>TCP 可靠传输   <code>三次握手</code></li>
<li>IP 远程定位，将数据封装成<strong>网络包</strong>发送给通信对象</li>
<li>MAC 两点传输，在 IP 头部的前面加上 <strong>MAC 头部</strong>，包含接收方和发送方的 MAC 地址等信息。</li>
</ol>
</li>
<li>出口<code>网卡</code>：在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong></li>
<li>交换机：<strong>根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>  <code>MAC 层</code></li>
<li>路由器：根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作</li>
<li>拆包，获取数据内容，交给浏览器渲染页面，然后<code>四次挥手</code>断开连接</li>
</ol>
<h3 id="6-2-TCP-报文头部"><a href="#6-2-TCP-报文头部" class="headerlink" title="6.2 TCP 报文头部"></a>6.2 TCP 报文头部</h3><p>![[Pasted image 20230903203817.png]]</p>
<ul>
<li>首先，<strong>源端口号</strong>和<strong>目标端口</strong>号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</li>
<li>接下来有包的<strong>序</strong>号，这个是为了解决包乱序的问题。</li>
<li>还有应该有的是<strong>确认号</strong>，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决丢包的问题。</li>
<li>接下来还有一些<strong>状态位</strong>。例如 <code>SYN</code> 是发起一个连接，<code>ACK</code> 是回复，<code>RST</code> 是重新连接，<code>FIN</code> 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</li>
<li>还有一个重要的就是<strong>窗口大小</strong>。TCP 要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。</li>
<li>除了做流量控制以外，TCP还会做<strong>拥塞控制</strong>，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。</li>
</ul>
<h3 id="6-3-网络报文图"><a href="#6-3-网络报文图" class="headerlink" title="6.3 网络报文图"></a>6.3 网络报文图</h3><p>![[Pasted image 20230903204154.png]]</p>
<h3 id="6-4-网络攻击"><a href="#6-4-网络攻击" class="headerlink" title="6.4 网络攻击"></a>6.4 网络攻击</h3><h4 id="6-4-1-CSRF攻击"><a href="#6-4-1-CSRF攻击" class="headerlink" title="6.4.1 CSRF攻击"></a>6.4.1 CSRF攻击</h4><ul>
<li>CSRF（Cross-Site Request Forgery，跨站请求伪造）攻击，利用了用户已经在某个网站上进行了<code>身份验证</code>的情况下，对用户在另一个网站上的操作进行<code>伪造请求</code>，以执行未经授权的操作。</li>
<li>防范：<ul>
<li><strong>使用HTTP-only Cookie</strong></li>
<li><strong>使用验证码</strong>：敏感操作输入验证码</li>
<li>限制敏感操作</li>
<li><strong>使用CSRF令牌</strong>：为了确保请求是合法的，服务器可以生成一个唯一的CSRF令牌，并将其嵌入到表单或请求中</li>
<li><strong>定期审查和更新安全策略</strong></li>
<li><strong>同源策略</strong>CORS：浏览器的同源策略要求网页只能从同一来源加载资源。通过使用同源策略，浏览器可以限制对不同网站的跨站请求，从而减少CSRF攻击的可能性。</li>
</ul>
</li>
</ul>
<h4 id="6-4-2-XSS攻击"><a href="#6-4-2-XSS攻击" class="headerlink" title="6.4.2 XSS攻击"></a>6.4.2 XSS攻击</h4><ul>
<li>XSS（Cross-Site Scripting，跨站脚本攻击），将恶意脚本注入到网页中，以便在受害者的浏览器上执行恶意代码。XSS攻击可能导致盗取用户的敏感信息、劫持用户会话、操纵网页内容等恶意行为。</li>
<li>防范：<ul>
<li><strong>输入验证和过滤</strong>：在应用程序接受用户输入时，对输入数据进行验证和过滤。确保只接受预期的输入，并拒绝包含恶意脚本的输入。这可以通过编码规范、白名单过滤和黑名单过滤来实现。</li>
<li><strong>转义输出</strong>：在将用户输入插入到HTML、JavaScript或其他上下文中时，确保对用户输入进行适当的转义。这可以防止浏览器将用户输入解释为可执行的脚本。</li>
<li><strong>CORS策略</strong>：使用CORS（Cross-Origin Resource Sharing，跨源资源共享）策略来限制其他域名的网页访问您的网页，从而减少恶意脚本的机会。</li>
<li><strong>HTTP头设置</strong>：设置HTTP头中的安全标头，如Content Security Policy（CSP）和X-XSS-Protection，以帮助阻止XSS攻击。</li>
</ul>
</li>
</ul>

    
  </div>

  
  <!-- Post Copyright -->

<div class="post-copyright">
  <p class="copyright-item">
    <span>Author: </span>
    <a href="https://stardustorz.github.io">draco</a>
  </p>
  <p class="copyright-item">
    <span>Link: </span>
    <a href="https://stardustorz.github.io/2025/07/25/Basic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">https://stardustorz.github.io/2025/07/25/Basic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</a>
  </p>
  <p class="copyright-item">
    <span>License: </span>
    
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
  </p>
</div>

    

  

  
  <footer class="post-footer">
    
    <div class="post-tags">
      
      <a href="/tags/Basic/">Basic</a>
      
    </div>
    
      
  <nav class="post-nav">  
      
      <a class="prev" href="/2025/07/25/Basic/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text nav-default">[Basic] Operating System</span>  
        <span class="prev-text nav-mobile">Prev</span>  
      </a>  
      
      
      <a class="next" href="/2025/07/25/Algorithm/Array/">  
        <span class="next-text nav-default">[Algorithm] Array</span>  
        <span class="prev-text nav-mobile">Next</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  </footer>
  

</article>
        </div>
      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2019 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">draco</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
  







<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>



<script type="text/javascript" src="/lib/slideout/slideout.js"></script>



<script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>