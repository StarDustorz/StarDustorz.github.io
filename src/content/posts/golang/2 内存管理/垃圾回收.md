---
abbrlink: article-243ec30f
published: 2022-09-12
tags:
- Golang
- 内存管理
title: 垃圾回收
---

> 垃圾回收（Garbage Collection，简称 GC）是一种内存管理策略，由垃圾收集器以类似守护协程的方式在后台运作，按照既定的策略为用户回收那些不再被使用的对象，释放对应的内存空间.

<!--more-->

## 1 垃圾回收算法

### 1.1 概述

**GC 带来的优势**
- 屏蔽内存回收的细节, 使用户更好地聚焦于核心的业务逻辑
- 以全局视野执行任务

**GC 带来的劣势**
- 提高了下限但降低了上限
- 增加了额外的成本

### 1.2 标记清扫

标记清扫（Mark-Sweep）算法, 分为两步实现:
- 标记：标记出当前还存活的对象
- 清扫：清扫掉未被标记到的垃圾对象

标记清扫通过标记存活对象，从而取补集推断出垃圾对象, 它的缺点在于会产生内存碎片, 这些碎片分散分布的话, 会影响大对象的内存分配.

### 1.3 标记压缩

标记压缩（Mark-Compact）算法，是在标记清扫算法的基础上做了升级，在第二步”清扫“的同时还会对存活对象进行压缩整合，使得整体空间更为紧凑，从而解决内存碎片问题
缺陷在于实现时会有很高的复杂度.

### 1.4 半空间复制

**半空间复制（Semispace Copy）算法主要实现如下:**
- 分配两片相等大小的空间，称为 fromspace 和 tospace
- 每轮只使用 fromspace 空间，以GC作为分水岭划分轮次
- GC时，将fromspace存活对象转移到tospace中，并以此为契机对空间进行压缩整合
- GC后，交换fromspace和tospace，开启新的轮次

半空间复制算法应用了以空间换取时间的优化策略，解决了内存碎片的问题，也在一定程度上降低了压缩空间的复杂度. 但其缺点也同样很明显——比较浪费空间
Java 所采用的就是半空间复制的升级版

### 1.5 引用计数

**引用计数（Reference Counting）主要实现如下:**
- 对象每被引用一次，计数器加1
- 对象每被删除引用一次，计数器减1
- GC时，把计数器等于 0 的对象删除

缺陷在于无法解决循环引用和自引用的问题

## 2 Golang 中的垃圾回收

> 在 1.8版本之后，Golang 的 GC 策略主要为并发三色标记法+混合写屏障机制

### 2.1 三色标记法

Golang GC 中用到的三色标记法属于标记清扫-算法下的一种实现, 主要思路如下:
- 对象分为三种颜色标记：黑、灰、白
- 黑对象代表，对象自身存活，且其指向对象都已标记完成
- 灰对象代表，对象自身存活，但其指向对象还未标记完成
- 白对象代表，对象尙未被标记到，可能是垃圾对象
- 标记开始前，将根对象（全局对象、栈上局部变量等）置黑，将其所指向的对象置灰
- 标记规则是: 从灰对象出发，将其所指向的对象都置灰. 所有指向对象都置灰后，当前灰对象置黑
- 标记结束后，白色对象就是不可达的垃圾对象，需要进行清扫

### 2.2 并发垃圾回收

- Golang 1.5 版本是个分水岭，在此之前，GC时需要停止全局的用户协程，专注完成GC工作后，再恢复用户协程，这样做在实现上简单直观，但是会对用户造成不好的体验
- 自1.5版本以来，Golang引入了并发垃圾回收机制，允许用户协程和后台的GC协程并发运行，大大地提高了用户体验. 但用户协程并发运行时可能对对象间的引用关系进行调整，这会严重打乱GC三色标记时的标记秩序

### 2.3 可能的问题

- **漏标问题**
	- 假设只有对象 B 持有对象 C 的引用,如果 GC 协程在 B 删除 C 的引用后才开始扫描 B，就会无法到达 C.  此时从扫描结果上看，C 是不可达的
	- 针对漏标问题，Golang 给出的解决方案是屏障机制
- **多标问题**
	- 假设对象 A 持有对象 B 的引用
	- GC协程下，对象 A 被扫描完成，置黑；对象 B 被对象 A 引用，因此被置灰
	- 用户协程下，对象 A 删除指向对象 B 的引用
	- B 在被 A 删除引用后，已成为垃圾对象，但由于其事先已被置灰，因此最终会更新为黑色，不会被 GC 删除
	- 错标问题对比于漏标问题而言，是相对可以接受的, 至多到下一轮 GC，这部分对象就会被 GC 回收
- **内存碎片问题**
	- Golang采用 TCMalloc 机制，依据对象的大小将其归属为到事先划分好的spanClass当中，这样能够消解外部碎片的问题，将问题限制在相对可控的内部碎片当中
- **为什么不学 Java 用分代?**
	- 分代算法指的是，将对象分为年轻代和老年代两部分（或者更多），采用不同的GC策略进行分类管理. 分代GC算法有效的前提是，绝大多数年轻代对象都是朝生夕死，拥有更高的GC回收率，因此适合采用特别的策略进行处理.
	- Golang中存在内存逃逸机制，会在编译过程中将生命周期更长的对象转移到堆中，将生命周期短的对象分配在栈上，并以栈为单位对这部分对象进行回收
	- 综上，内存逃逸机制减弱了分代算法对Golang GC所带来的优势，考虑分代算法需要产生额外的成本（如不同年代的规则映射、状态管理以及额外的写屏障），Golang 选择不采用分代GC算法

## 3 屏障机制

> 主要是为了解决2.3小节中提及的并发GC下的漏标问题

### 3.1 强弱三色不变式

漏标问题的本质就是，一个已经扫描完成的黑对象指向了一个被灰\白对象删除引用的白色对象. 构成这一场景的要素拆分如下：
1. 黑色对象指向了白色对象
2. 灰、白对象删除了白色对象
3. （1）、（2）步中谈及的白色对象是同一个对象
4. （1）发生在（2）之前

通过破坏这些要素,可以解决漏标问题, 称为强弱三色不变式:
- 强三色不变式：白色对象不能被黑色对象直接引用（直接破坏（1））
- 弱三色不变式：白色对象可以被黑色对象引用，但要从某个灰对象出发仍然可达该白对象（间接破坏了（1）、（2）的联动）

### 3.2 插入写屏障

- 屏障机制类似于一个回调保护机制，指的是在完成某个特定动作前，会先完成屏障成设置的内容
- 插入写屏障（Dijkstra）的目标是实现**强三色不变式**，保证当一个黑色对象指向一个白色对象前，会先触发屏障将白色对象置为灰色，再建立引用


### 3.3 删除写屏障

- 删除写屏障（Yuasa barrier）的目标是实现**弱三色不变式**，保证当一个白色对象即将被上游删除引用前，会触发屏障将其置灰，之后再删除上游指向其的引用
- 也就是保证在删除到这个对象 A 的引用后,  对象 A对于 GC 来说依旧是可见的

### 3.4 混合写屏障

- 插入写屏障、删除写屏障二者择其一，即可解决并发GC的漏标问题，至于错标问题，则采用容忍态度，放到下一轮GC中进行延后处理即可
- 但是, 屏障机制无法作用于栈对象, 因为栈对象可能涉及频繁的轻量操作，高频率的触发屏障机制，带来的成本将是无法接受的.
- 在 Go1.8 前, 栈上的垃圾对象通过引入额外的Stop the world（STW）阶段解决, 1.18 后,  引入了混合写屏障机制来消除 STW 成本, 主要思路如下:
	- GC 开始前，以栈为单位分批扫描，将栈中所有对象置黑
	- GC 期间，栈上新创建对象直接置黑
	- 堆对象正常启用插入写屏障
	- 堆对象正常启用删除写屏障