---
title: "[Go] 面试题总结"
published: 2021-12-04
tags:
  - Golang
  - Go其他
lang: zh
toc: true
abbrlink: golang-interview
draft: true
---

<!--more-->

## 1 常见问题总结

- `map`
  - map 的底层数据结构和实现？是否并发安全？扩容过程？`2
  - Map的并发检测是怎么做的
  - map如何顺序读取?按key从小到大的顺序打印出来?
  - 实现set
  - map 和 slice 在类型上的区别?  值类型还是引用类型
  - map，如果不初始化就赋值，会有什么问题？
  - 如果我去map中删除了某个key，它的内存会释放吗？
  - 多线程同时读写map中不同的key，一个线程只会读写一个key，会发生什么
- `slice`
  - slice 的底层数据结构和实现？slice 和数组的区别？slice 的扩容规则？`2`
  - Golang的值传递，slice作为函数参数（值传递）在函数内append是否会影响到外面，如果是对slice的值修改呢？ `2`
  - 并发读写安全吗? 会 panic 吗
  - 初始化和不初始化使用 slice 的区别，哪种情况可以不初始化直接用？
- `channel`
  - 如何判断一个 channel 是否已关闭？
  - channel 的类型？之间区别？应用场景？底层数据结构与实现？ `2`
  - 关闭一个已经关闭的 channel 会发生什么？对一个已经关闭的 channel 进行读写会发生什么？
  - 如果通道里头没数据了，那些go 协程会怎样？
  - channel 优雅关闭方面，有什么好的实践？
  - Channel 什么情况下会出现死锁，有遇到过吗？
  - 容量为1的 channel 在什么情况下会堵塞（除了常见的）
- `GMP`
  - 像协程，线程，进程随着计算机发展的演变，从你个人的视角和理解，讲讲这个改变的历程，触发这种演变的原因是什么?
  - GMP模型中有几种调度类型？Go的调度机制发生了怎么样的演变历程?
  - GPM 调度模型，如果一个 P 的本地 G 队列执行完了，会发生什么  1
  - GMP中协程的调度，是抢占式还是时间片？会饥饿吗？怎么处理？  1
  - 如何初始化
  - 假如有一个M挂掉了，或者发生io 阻塞，这时候会发生什么？
  - 发生网络io,会怎么调度？发生阻塞的IO会怎么调度？epoll详解？
- `struct`
  - go struct能不能比较
  - go结构体和结构体指针的区别
- `select`
  - select可以用于什么?
  - 说一下select的底层实现
- `context`
  - context 协程安全吗？   `2
  - 项目中 context 如何使用的？有使用过 context 哪些方法？`2
  - 一个异常程序，一直往这个valueContext中添加不同的数据，会有什么问题吗？
  - 如果现在设置了很多value，我现在通过Context去取这些值的时候，效率上会有什么问题吗？
  - context包内部如何实现的？
- `goroutine`
  - goroutine 数据结构、创建过程及生命周期？`2`
  - goroutine 创建过程？`2
  - 父goroutine退出，如何使得子goroutine也退出？ `2`
  - 子goroutine的panic会导致主goroutine的panic吗，为什么 `2`
  - 多个协程等待一个协程执行完，除了WaitGroup 还有什么方式？
  - 如果收到一个请求，里头有100个子任务，用 go 编码时直接创建100个协程并发处理，是否合适呢，会导致什么问题？
    - 不合适  资源消耗 调度开销 阻塞 控制困难  用协程池 限制并发数量
- `并发控制`
  - RW 锁的底层实现？ 1
  - go 中sync.Mutex 的底层如何实现的？抢占算法是怎样的？如何避免饥饿现象？1
  - waitgroup 实现 ? errGroup 是用来干什么的
- `内存分配机制`
  - 有mcentral为啥要mcache?
  - Go语言内存分配，什么分配在堆上，什么分配在栈上
- `垃圾回收`
  - go的内存泄漏遇到过吗，大概会有哪些场景容易发生，怎么去避免？go的GC会自动关闭channel吗？
  - Go 的垃圾回收机制，和 Java 比有什么区别
- `defer`
  - 多个defer的执行顺序是怎么样的？有什么注意事项？
  - defer可以捕获到子Goroutine的panic吗？  `2`
  - defer在什么情况下会修改函数返回值
- `interface` 
  - 底层数据结构和实现？如何判断一个接口变量是否为空（Type 和 Value？）`2`
  - go什么场景使用接口
- `其他go 相关`
  - Go 的反射机制
  - go怎么实现封装继承多态
  - golang 其他语言比较的特点?
  - 有哪些你熟悉的golang中的第三方包？
  - golang开发中遇到过什么内存占用比较高的问题吗，一般是用什么工具排查，是如何优化的？
  - go这门语言在你看来有没有什么设计上的缺陷？
  - 工作中有没有遇到过一些go性能方面的问题？
  - For range的使用中，地址会发生变化吗
  - make和new有什么区别
  - golang 的赋值和传参是值传递还是引用传递？
  - go的变量申请类型
  - go深拷贝，什么时候需要深拷贝
  - go如何避免panic





## 2 数据结构

### 2.1 channel

1. 不要通过共享内存来通信，而要通过通信来实现内存共享 [[go-Channel]]
2. `数据结构`
   1. hchan 是 channel 的数据结构,其中 buf 指向存放数据的环形缓冲区
   2. waitq 是阻塞的协程队列
   3. sudog 是用于包装协程的节点
3. 构造:根据有无缓冲进行申请和初始化,本质是值的拷贝
4. `写流程`: 不能写入未初始和已经关闭的 chan
   1. **存在阻塞读的协程**: 加锁后从阻塞读队列中取出 goroutine 的封装对象 sudog,send 直接把元素拷贝给对应的 goroutine
   2. **无阻塞读协程但环形缓冲区仍有空间**:添加到环形缓冲区 sendx 位置
   3. **写时无阻塞读协程且环形缓冲区无空间**: 构造当前 goroutine 的 sudog 对象,并添加到阻塞写队列中
5. `读流程`
   1. 读空 chan , park 挂起,死锁
   2. 读已经关闭且无元素的,直接解锁返回
   3. 读时有阻塞的写,直接读缓冲区同步,然后唤醒写协程
   4. 读时无阻塞写,缓冲区无元素,构造 sudog 加入阻塞读队列
6. `关闭`:
   1. 关闭未初始化的会 panic
   2. 重复关闭会 panic
   3. 优雅关闭: 向一个 closed channel 发送数据会导致 panic。因此原则是 发送端进行关闭,可以增加一个用于通知的中间信号 chan
7. `应用场景`
   1. 停止信号
   2. 任务定时
   3. 控制并发

### 2.2 map 

**用于 kv 储存的字典**

1. `注意点`
   1. 初始化  `myMap1 := make(map[int]int,2)`,不初始化就赋值会导致 panic
   2. key必须可比较，不能是`chan、map、func`,也就是要求 hash 后的值和字面值都相等,float 会有精度转换,最好别作为 key
   3. 遍历是`无序`的，可以借助 slice 先排序；并发写**不安全**
   4. 时间复杂度： O(1) 常数；大量的键值冲突，扩容会影响
   5. map 的比较必须,非空, 长度相等 每个元素都相等
2. `底层数据结构与实现`
   1. map 是一个指针,指向  [[go-hmap]] 结构体, hmap 中有 buckets 桶数组,bucket 指向 [[go-bmap]] 结构体 , 每个桶可存放八个 k-v 对,如果超过则会创建桶链表,通过溢出桶指针连接,结合了拉链法和开放地址法
   2. 写入流程
      1. 获取 key 的 hash 值,共 64 个 bit 位
      2. 用最后的 B 个 bit 位,hash 值对桶数组长度取模,确定所属的桶 (`B` 是 buckets 数组的长度的对数)
      3. 再用哈希值的高8位,找到 key 在 bucket 中的位置
      4. 在桶中插入 kv 对 , key 和 value 是分别存放的
3. `扩容流程`
   1. **触发条件**
      1. 通过 overLoadFactor 方法分辨
      2. map 预分配容量小于等于 8，B 取 0，桶的个数为 1；
      3. 保证 map 预分配容量小于等于`桶数组长度 * 6.5`.
   2. **扩容方式**
      1. **增量扩容**：当桶内 元素总数/桶数组长度 > 6.5 时发生增量扩容，桶数组长度增长为原值的两倍
         1. 举例：B = 5，根据它 hash 的后五位决定位置，扩容后 B=6，其低六位决定位置；这就是 rehash
      2. **等量扩容**：当桶内溢出桶数量大于等于 2^B 时( B 为桶数组长度的指数，B 最大取 15)，发生等量扩容，桶的长度保持为原值； ` 可以解决剧烈的 hash 冲突,不是因为元素太多,而是溢出桶太多`
      3. 采用渐进扩容的方式，每次最多搬两个,当桶被实际操作到时，由使用者负责完成数据迁移，避免因为一次性的全量数据迁移引发性能抖动.
4. `读写过程`
   1. **读流程**  [[mapacess]]
      1. 根据 key 取 hash 值；
      2. 根据 hash 值对桶数组取模，确定所在的桶；
      3. 沿着桶链表依次遍历各个桶内的 key-value 对；
      4. 命中相同的 key，则返回 value；倘若 key 不存在，则返回零值.
   2. **写流程** [[mapassgin]]
      1. 确定所在的桶；
      2. 如果 map 处于扩容，则迁移命中的桶，帮助推进渐进式扩容；
      3. 沿着桶链表依次遍历各个桶内的 key-value 对；
      4. 如果命中相同的 key，则对 value 中进行更新；否则插入
      5. 如果发现 map 达成扩容条件，则会开启扩容模式，并重新返回第（2）步.
5. `并发安全？`
   1. map不能同时读写或写写，会引起`fatal` 错误
   2. map.flags 的第 3 个 bit 位是`写标记`
   3. `sync.Mutex` 降低性能来保证并发安全，读写都加
   4. `sync.RWMutex` 读写锁，运行并发读，提高性能
   5. `sync.Map`  [[00-Inbox/A-Golang/代码引用/sync.Map]]
      1. 适用于读多、更新多、删多、写少的场景
      2. 读写 read，全程无锁，dirty 需要加锁，多用 read
      3. CAS 当前值A、内存值V、要修改的新值B
6. `注意问题？`
   1. 记得初始化，否则会 panic，这个 panic 可以 recover吗？
      1. **不能**，调用的是 `runtime.fatalthrow()`，然后调用 `exit(2)`结束进程
      2. [[panic 机制]]
   2. 遍历是无序的
   3. key 是否存在，校验一下 ok
   4. map 是引用类型的，用 make 来构造
   5. 可以通过定义 value 为 struct 来节约内存；[[go-struct]]
   6. map 中删除一个 key，它的内存会释放么？
   7. map 取一个 key，然后修改这个值，原 map 数据的值会不会变化

### 2.3 slice

1. `底层数据`：[[go-slice]]
   1. slice 是对数组的封装,描述一个数组的片段;
   2. 结构体中有三个字段：长度、容量、**底层数组**
   3. 底层数组可以被多个 slice 持有,因此会互相影响
2. `扩容`:
   1. append 向 slice 添加元素达到底层数组最大值后就要扩容
   2. 当原 slice 容量小于 `1024` 的时候，新 slice 容量变成原来的 `2` 倍；原 slice 容量超过 `1024`，新 slice 容量变成原来的`1.25`倍。  
   3. 1.18 版本更新: 当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap = oldcap+(oldcap+3✖️256)/4
   4. 还有一个内存对齐的操作,可能会偏大
3. `作为函数参数`
   1. 在该函数中修改切片中变量值，会影响到外部，而向这个切片添加元素则不影响；？why
   2. 因为传递过去的是 array，len，cap 的拷贝，指针指向 array 因此修改可以感知到，而添加修改的只是函数内的 len，外部的 len 没变。
   3. Go 语言的函数参数传递，只有值传递，没有引用传递。

### 2.4 interface

1. 底层实现[[go-interface]]
   1. iface：非空接口，包括指向具体值的 `data` 数据指针，和指向 itab 实体的`tab`指针,中有 `fun` 方法集合和` interfacetype` 描述类型信息
   2. eface：空接口，只有类型信息和数据指针
2. 比较
   1. 先将 nil 转换成 interface`(type=nil, data=nil)` ，然后分别比较 type 和 data

### 2.5 defer

1. [[go-defer]] 
2. 实现: 底层是使用链表实现,每次新注册的都是头插法注册到链表头部
3. 原理：deferproc()注册到`_defer` 链表头，并在 return前插入了函数deferreturn()
4. 执行顺序：`延迟函数参数`在defer语句`出现时`就已经确定下来,后进先出的
5. **参数求值**：defer 语句中的参数在声明时就会被计算
6. defer只能捕获`本层的panic`
7. 作用: 资源,连接的关闭和清除缓存

### 2.6 select

- select 是 Go 中的一个控制结构，类似于 switch 语句。
- select 语句只能用于通道操作，每个 case 必须是一个通道操作，要么是发送要么是接收。
- select 语句会监听所有指定的通道上的操作，一旦其中一个通道准备好就会执行相应的代码块。
- 如果多个通道都准备好，那么 select 语句会随机选择一个通道执行。如果所有通道都没有准备好，那么执行 default 块中的代码。

## 3 GMP原理

### 3.1 协程

1. `进程`、`线程`、`协程`的概念与区别
   1. **进程**：
      	1. 进程是程序的一次执行过程；由程序，数据和进程控制块组成
      	2. 进程是系统进行资源分配和调度的一个独立单位。
      	3. 每个进程都有自己的独立内存空间，不同进程通过`进程间通信`来通信
   2. **线程**：
      	1. 线程是进程的一个实体,是CPU调度和分派的基本单位,是比进程更小的能独立运行的基本单位.
      	2. 线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。
      	3. 线程间通信主要通过`共享内存`，上下文切换很快。
   3. **协程**：
      	1. 协程是一种`用户态`的轻量级线程，协程的调度完全由用户控制，类似于函数调用。
      	2. 协程拥有自己的寄存器上下文和栈。直接操作栈则基本没有**内核切换**的开销，可以不加锁的访问全局变量，所以切换非常快。
      	3. 实现：协程是基于线程的，就是 GMP
      	4. `Goroutine`
      		1. 创建、销毁、调度在用户态完成，对内核透明，足够轻便；
      		2. 可利用多个线程，实现`并行`；
      		3. 通过调度器的斡旋，实现和线程间的`动态绑定`和`灵活调度`；
      		4. 栈空间大小可动态扩缩，因地制宜.
   4. **区别：**
      	1. `内存消耗`：goroutine 2kb    线程 MB
      	2. `创建和销毁`:线程的创建销毁是内核级的,小号较大,goroutine 是用户级的
      	3. `切换`: 线程切换要保存各种寄存器,goroutine 只要三个 Program Counter, Stack Pointer and BP,  只要 200ns 大概五分之一
2. `Goroutine` 详解  [[go-Goroutine]]
   1. 数据结构:
      1. m：在 p 的代理，负责执行当前 g 的 m
      2. 保存各种寄存器和系统调用返回值的 sched
   2. 生命周期
      1. 未初始化  待执行 执行中 系统调用 挂起 已销毁 栈扩容中  被抢占
   3. 创建过程:  newproc函数创建一个新的 goroutine
   4. 子goroutine的panic会导致主goroutine的panic吗，为什么
      1. 不会，panic 只会导致程序退出
   5. 父goroutine退出，如何使得子goroutine也退出？  
      1. 可以通过channel 或者 Context 实现
   6. 控制：协程池，Semaphore，waitgroup
      1. 多个协程同步等待,除了 waitgroup 还可以用通道

### 3.2 GMP 调度

1. [[go-GMP]]
2. GMP 调度模型
   1. G(goroutine协程)  :有自己的运行栈、状态、以及执行的任务函数
   2. P(Processor调度器)：承上启下，调度 g 并代理 m，决定了 g 最大并行数量，最多有`GOMAXPROCS`(可配置)个，超过 cpu 核数的无效
   3. M( machine,thread线程) ：不直接执行 g，而是先和 p 绑定，由其实现代理
   4. 数量关系
      1. P的数量问题：由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定。 最多只有这么多个。一般建议是**逻辑 CPU 数量的 2 倍**
      2. M的数量：默认是 1000；SetMaxThreads函数设置；M 阻塞会创建新的
3. 调度策略：
   1. G的存放队列有三类：P的本地队列；全局队列；和wait队列
   2. M调度G时，优先取P本地队列，其次取全局队列，最后取wait队列；这样的好处是，取本地队列时，可以接近于`无锁化`，减少全局锁竞争；
   3. 为防止不同P的闲忙差异过大，设立 `work-stealing` 机制，本地队列为空的P可以尝试从其他P本地队列偷取一半的G补充到自身队列.

## 4 内存模型

### 4.1 go-内存模型与分配机制

1.  [[go-内存模型与分配机制]]
2.  内存模型
    1. 从大到小：mheap，mcentral，mcache，mspan
3.  分配流程
    1. 从 P 专属 mcache 的 tiny 分配器取内存（无锁）
    2. 根据所属的 spanClass，从 P 专属 mcache 缓存的 mspan 中取内存（无锁）
    3. 根据所属的 spanClass 从对应的 mcentral 中取 mspan 填充到 mcache，然后从 mspan 中取内存（spanClass 粒度锁）
    4. 根据所属的 spanClass，从 mheap 的页分配器 pageAlloc 取得足够数量空闲页组装成 mspan 填充到 mcache，然后从 mspan 中取内存（全局锁）
    5. mheap 向操作系统申请内存，更新页分配器的索引信息，然后重复（4）.

### 4.2 内存泄露

1. 谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？
2. 分配的内存资源没有被正确释放或回收，导致程序占用的内存不断增加，最终可能导致程序性能下降或崩溃。
3. 原因：未关闭文件或网络连接；不释放资源；协程泄漏；通道阻塞；保持对对象的引用；循环引用
4. 怎么排查：`go vet`、`go tool pprof`和`go tool trace`等

### 4.3 内存逃逸

1. 谈谈内存逃逸？什么情况下会发生内存逃逸？
2. 在函数或方法中分配的内存在函数的生命周期结束后仍然被引用或访问，使得该内存块无法在函数的栈上分配并在函数退出时自动回收，而`必须分配在堆上`，并由垃圾回收器负责回收。
3. `原因`：
   	1. **返回指针到局部变量**:如果一个函数返回了一个指向局部变量的指针，并且这个指针在函数外部被引用，那么该局部变量就会逃逸到堆上。
   	2. **闭包引用**：如果一个闭包（函数值）引用了函数内部的变量，并且该闭包在函数外部被执行，那么这些变量就会逃逸到堆上。
   	3. **使用`go`关键字启动协程**：使用`go`关键字启动协程时，被协程引用的变量可能会逃逸到堆上，因为协程的生命周期不受限制，可能会在函数退出后继续执行。
   	4. 栈空间不足逃逸：比如切片过大
   	5. **向函数传递指针或切片**：如果将指针或切片传递给函数，并且在函数内部对它们进行修改后，它们可能会逃逸到堆上。
4. `闭包`：
   	1. 是一种函数值（Function Value），它包含了一个函数体和一个引用了外部变量的词法环境。
   	2. **函数体**：闭包包含了一个函数体，这个函数体可以有参数和返回值，就像普通函数一样。
   	3. **词法环境**：闭包引用了一个或多个外部变量，这些外部变量存在于闭包创建时的作用域中，而不是在闭包被调用时的作用域中。这些外部变量可以在闭包内部被访问和修改。
   	4. **独立性**：每个闭包都有自己的词法环境，因此闭包之间的外部变量不会相互影响。

### 4.4 内存分配

Go 是如何分配内存的？  Channel 分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？
	1. 通道（Channel）本身是一个`引用类型`，它在栈上分配的是通道的`描述符`，而实际的通道数据结构（包括通道的缓冲区和其他管理信息）是在堆上分配的。这是因为通道的大小是动态的，无法在编译时确定，因此通道的数据结构需要在运行时进行`动态分配`。
	2. **栈上分配**：
		1. 局部变量：函数内部定义的局部变量通常分配在栈上，它们在函数执行结束时自动释放。
		2. 函数参数：函数参数也分配在栈上，它们的生命周期与函数调用关联。
	3. **堆上分配**：
		1. 动态分配：使用`new()`、`make()`、`append()`等内建函数动态分配的对象通常分配在堆上，因为它们的生命周期不受限制，需要在程序的其他部分继续访问。
		2. 逃逸对象：如果编译器无法确定对象的生命周期，或者对象被引用超出了其定义的作用域，那么这些对象可能会逃逸到堆上分配。

## 5 GC 原理

1. [[go-GC 原理]]
2. 垃圾回收算法：三色标记法
3. 屏障机制
4. GC 中 stw 时机，各个阶段是如何解决的？
   1. 通过屏障技术解决
5. GC 的触发时机？
   1. 手动触发，调用 `runtime.GC`
   2. 系统触发：
      1. gcTriggerHeap：当所分配的堆大小达到阈值时，将会触发。
      2. gcTriggerTime：当距离上一个 GC 周期的时间超过一定时间时，将会触发。默认 2 分钟。
      3. gcTriggerCycle：如果没有开启 GC，则启动 GC。
6. 介绍一下大对象小对象，为什么小对象多了会造成 gc 压力
   1. Go 的内存分配用的是 tcmalloc 算法，传统的 tcmalloc，会为每个分配请求执行一个比较完整的 malloc GC 方法
   2. 通常小对象过多会导致GC三色法消耗过多的CPU。优化思路是，减少对象分配。

## 6 并发编程

### 6.1 内存模型

### 6.2 context

1. [[go-context]]
2. 用途：超时控制和传递 traceid
   1. WithCancel：可以手动调用 cancel() 方法以取消
   2. WithDeadline & WithTimeout：可以自定义超时时间
   3. WithValue：可以携带信息，比如 traceid 等,父节点不能获取子节点存储的值
3. context 并发安全

### 6.3 sync.Map

1. 使用场景: 读多、更新多、删多、写少
2. 底层实现: 
   - read 和 dirty 两个字段将读写分离
   - 最新写入的数据则存在 dirty 字段上
   - 读取时会先查询 read，不存在再查询 dirty，写入时则只写入 dirty
   - 读取 read 并不需要加锁，而读或写 dirty 都需要加锁
   - 另外有 misses 字段来统计 read 被穿透的次数（被穿透指需要读 dirty 的情况），超过一定次数则将 dirty 数据同步到 read 上,因为读是在 read 上的,所以 read 是最新的,然后 dirty 为 nil
   - 对于删除数据则直接通过标记来延迟删除
3. 和直接加锁的区别?  读写分离 提高并发
4. 删: 先读 read,有的话标记删除,没有就去 dirty 中直接删除,标记删除可以缓存
5. 读: Load() ,先去 read 查,没有就去 dirty加锁查,miss 加一
6. 写: Store() 
   1. 倘若 read map 存在拟写入的 key，且 entry 不为 expunged 状态，说明这次操作属于更新而非插入，直接基于 CAS 操作进行 entry 值的更新，并直接返回（存活态或者软删除，直接覆盖更新）；
   2. 倘若未命中（1）的分支，则需要加锁 double check；
   3. 倘若第二轮检查中发现 read map 或者 dirty map 中存在 key-entry 对，则直接将 entry 更新为新值即可（存活态或者软删除，直接覆盖更新）；
   4. 在第（3）步中，如果发现 read map 中该 key-entry 为 expunged 态，需要在 dirty map 先补齐 key-entry 对，再更新 entry 值（从硬删除中恢复，然后覆盖更新）；
   5. 倘若 read map 和 dirty map 均不存在，则在 dirty map 中插入新 key-entry 对，并且保证 read map 的 amended flag 为 true.（插入）
   6. 第（5）步的分支中，倘若发现 dirty map 未初始化，需要前置执行 dirtyLocked 流程；
7. value 状态
   1. 存活态很好理解，即 key-entry 对仍未删除；
   2. nil 态表示软删除，read map 和 dirty map 底层的 map 结构仍存在 key-entry 对，但在逻辑上该 key-entry 对已经被删除，因此无法被用户查询到；
   3. expunged 态表示硬删除，dirty map 中已不存在该 key-entry 对.
8. 总结
   1. 为什么需要使用 expunged 态来区分软硬删除呢？软删除可以 CAS,硬删除态要加锁
   2. 总体思想，希望能多用 read map，少用 dirty map，因为操作前者无锁，后者需要加锁；
   3. 除了 expunged 态的 entry 之外，read map 的内容为 dirty map 的子集；
   4. dirtyLocked: dirty 为空,访问 readmiss,遍历 read,拷贝到 dirty 去
   5. sync.Map 适用于读多、更新多、删多、写少的场景；
   6. 倘若写操作过多，sync.Map 基本等价于互斥锁 + map；
   7. sync.Map 可能存在性能抖动问题，主要发生于在读/删流程 miss 只读 map 次数过多时（触发 missLocked 流程），下一次插入操作的过程当中（dirtyLocked 流程）.

### 6.4 sync.WaitGroup

1. [[00-Inbox/A-Golang/代码引用/go-sync.WaitGroup]]
2. 主要方法：add done wait
3. 其他实现方法？   channel 信号量这些并发安全的进行计数，然后主协程进行汇总

### 6.5 sync.mutex

1. [[00-Inbox/A-Golang/代码引用/go-sync.Mutex]]
2. 底层实现
   1. state 字段标识当前互斥锁的状态
   2. sema 信号量 控制锁状态的信号量
3. 抢占算法
   - 如果互斥锁处于初始化状态，会通过 `CAS` 置位 `mutexLocked` 加锁；
   - 如果互斥锁处于 `mutexLocked` 状态并且在普通模式下工作，会进入自旋，执行 30 次 `PAUSE` 指令消耗 CPU 时间等待锁的释放；
   - 如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；
   - 互斥锁在正常情况下会通过`sync_runtime_SemacquireMutex`将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；
   - 如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式；
4. 如何避免饥饿： 一旦 Goroutine `超过 1ms` 没有获取到锁，它就会将当前互斥锁切换`饥饿模式`，防止部分 Goroutine 被**饿死**。

### 6.6 sync.RWMutex

### 6.7 sync.Cond

### 6.8 sync.Once

### 6.9 sync.Pool

### 6.10 拾遗

1. `Go 如何实现原子操作` ：Go语言的标准库代码包sync/atomic提供了原子的读取（Load为前缀的函数）或写入（Store为前缀的函数）某个值

## 7 拾遗

### 7.1 反射

- `reflect` 包提供了反射机制，可以在运行时获取变量的类型信息、值信息、方法信息等等。
- go 中的 `interface{}` 实际上包含了两个指针，一个指向类型信息，一个指向值信息。正因如此，我们可以在运行时通过 `interface{}` 来获取变量的类型信息、值信息。
- `reflect.Type` 代表一个类型，`reflect.Value` 代表一个值。通过 `reflect.Type` 可以获取类型信息，通过 `reflect.Value` 可以获取值信息。
- 反射三定律：
  - 反射可以将 `interface` 类型变量转换成反射对象。
  - 反射可以将反射对象还原成 `interface` 对象。
  - 如果要修改反射对象，那么反射对象必须是可设置的（`CanSet`）。
- `reflect.Value` 和 `reflect.Type` 里面都有 `Elem` 方法，但是它们的作用不一样：
  - `reflect.Type` 的 `Elem` 方法返回的是元素类型，只适用于 array、chan、map、pointer 和 slice 类型的 `reflect.Type`。
  - `reflect.Value` 的 `Elem` 方法返回的是值，只适用于接口或指针类型的 `reflect.Value`。
- 通过 `reflect.Value` 的 `Interface` 方法可以获取到反射对象的原始变量，但是是 `interface{}` 类型的。
- `Type` 和 `Kind` 都表示类型，但是 `Type` 是类型的反射对象，`Kind` 是 go 类型系统中最基本的一些类型，比如 `int`、`string`、`struct` 等等。
- 如果我们想通过 `reflect.Value` 来修改变量的值，那么 `reflect.Value` 必须是可设置的（`CanSet`）。同时如果想要 `CanSet` 为 true，那么我们的变量必须是可寻址的。
- 我们有很多方法可以创建 `reflect.Type` 和 `reflect.Value`，我们需要根据具体的场景来选择合适的方法。
- `reflect.Type` 和 `reflect.Value` 里面，都有一部分方法是通用的，也有一部分只适用于特定的类型。如果我们想要调用那些适用于特定类型的方法，那么我们必须先判断 `reflect.Type` 或 `reflect.Value` 的类型（这里说的是 `Kind`），然后再调用。

### 7.2 select 通道选择器

随机选择可读取或者写入的通道执行

1. 多个case分支的通道可以执行，随机选择一个case分支执行
2. 如果存在default，执行；否则阻塞到有分支可以执行

### 7.3 make 和 new 的区别？

1. **make** ：用于创建内置数据结构的实例，返回一个已初始化的实例(因为他们本来就是引用类型)。；**只用于slice，map，channel的创建**
2. **new**：根据传入的类型分配一片内存空间并返回指向零值的**指针**;  它不会对这些数据结构进行初始化。
3. make只用于创建map，slice和channel等内置的数据结构，并且不返回指针。要获得一个显式的指针，使用new进行分配，或者显式地使用一个变量的地址。
4. make和new都是golang用来分配内存的內建函数，且在堆上分配内存，make 即分配内存，也初始化内存。new只是将内存清零，并没有初始化内存。
5. make返回的还是引用类型本身；而new返回的是指向类型的指针。
6. make只能用来分配及初始化类型为slice，map，channel的数据；new可以分配任意类型的数据。

### 7.4 协程泄露

>创建的协程（Goroutine）没有被正确地释放或终止，导致这些协程一直存在于程序中，却无法被垃圾回收，从而占用了系统资源。

`产生原因`

- 协程没有正常退出
- 协程被阻塞而无法退出
- 协程泄露的循环引用
  `解决方法`
- 使用`defer`确保资源释放
- 使用通道来通知协程退出
- 使用`context`包 ^890b65
- 避免循环引用
- 使用工具进行检查：可以使用一些工具和分析器，如`go vet`、`go race`和`go tool trace`来检测协程泄露和并发问题

### 7.5 struct

[[go-struct]]
`go struct 能不能比较？`

- 可以比较的结构体
  - 前提：结构体内的字段都是可以比较的
  - 如果两个结构体的字段相同并且相等，那么它们被认为是相等的。
- 不可比较的结构体
  - 结构体中包含不可比较的字段，例如切片（slice）、映射（map）或函数类型
  - 结构体中包含指针字段，比较的是指针的值而不是指针指向的内容

### 7.6 泛型

1. 在函数和方法中使用类型参数：你可以编写可以接受不同类型参数的函数和方法，这样可以大大提高代码的复用性。
2. 创建泛型数据结构：你可以创建可以处理多种数据类型的数据结构，例如通用的切片、映射或链表等。
3. 提供类型安全性：泛型在编译时进行类型检查，确保类型参数的一致性，避免了运行时的类型错误。

### 7.7 for range 原理与要点

1. for range 是 Go 语言用来遍历的一种方式，它可以操作数组、切片、map、channel 等
2. 遍历 map 为随机序输出，slice 为索引序输出；
3. range v 是值拷贝，且只会声明初始化一次；
4. 在`for-range`循环过程中，`v`的地址保持不变，而`v`地址对应的值是`最后一次循环`对应的`v`的值。
5. 对`map`遍历时删除元素能遍历到吗？——不会
6. 对`map`遍历时新增元素会被遍历到吗——可能会
7. `range`操作的对象都是在复制的对象中操作，而不是原对象上
   1. 由于数组是值拷贝，中间过程中对原对象做任何改变，都不会改变拷贝对象的值。
   2. 由于切片是地址拷贝，即`range`拷贝出来的值和原来变量的值都是指向了同一个对象，当一个地方改变了对象的值，另外一个地方来访问对象的值时也会随之发生变化。

### 7.8 数据类型 rune uint

 - rune：是一种整数类型，用于表示Unicode字符。具体来说，`rune`是一个32位的整数类型，可以存储任何有效的Unicode代码点（Unicode code point）。因此，`rune`类型通常用于处理和操作Unicode字符，例如在字符串中遍历和索引字符。

 - `uint32`是一个32位无符号整数类型，表示的范围是从0到2^32-1，即0到4294967295。当一个`uint32`类型的变量的值超过了这个范围时，就会发生溢出（Overflow）。溢出是指一个数值超过了其数据类型所能表示的最大值，或者低于其数据类型所能表示的最小值。在`uint32`的情况下，当一个变量的值超过了4294967295，即2^32-1时，它会从0开始重新计数，继续增加。