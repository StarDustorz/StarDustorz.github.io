<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2025/05/22/Golang/Go%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <url>/2025/05/22/Golang/Go%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="1-常见问题总结"><a href="#1-常见问题总结" class="headerlink" title="1 常见问题总结"></a>1 常见问题总结</h2><ul><li><code>map</code><ul><li>map 的底层数据结构和实现？是否并发安全？扩容过程？`2</li><li>Map的并发检测是怎么做的</li><li>map如何顺序读取?按key从小到大的顺序打印出来?</li><li>实现set</li><li>map 和 slice 在类型上的区别?  值类型还是引用类型</li><li>map，如果不初始化就赋值，会有什么问题？</li><li>如果我去map中删除了某个key，它的内存会释放吗？</li><li>多线程同时读写map中不同的key，一个线程只会读写一个key，会发生什么</li></ul></li><li><code>slice</code><ul><li>slice 的底层数据结构和实现？slice 和数组的区别？slice 的扩容规则？<code>2</code></li><li>Golang的值传递，slice作为函数参数（值传递）在函数内append是否会影响到外面，如果是对slice的值修改呢？ <code>2</code></li><li>并发读写安全吗? 会 panic 吗</li><li>初始化和不初始化使用 slice 的区别，哪种情况可以不初始化直接用？</li></ul></li><li><code>channel</code><ul><li>如何判断一个 channel 是否已关闭？</li><li>channel 的类型？之间区别？应用场景？底层数据结构与实现？ <code>2</code></li><li>关闭一个已经关闭的 channel 会发生什么？对一个已经关闭的 channel 进行读写会发生什么？</li><li>如果通道里头没数据了，那些go 协程会怎样？</li><li>channel 优雅关闭方面，有什么好的实践？</li><li>Channel 什么情况下会出现死锁，有遇到过吗？</li><li>容量为1的 channel 在什么情况下会堵塞（除了常见的）</li></ul></li><li><code>GMP</code><ul><li>像协程，线程，进程随着计算机发展的演变，从你个人的视角和理解，讲讲这个改变的历程，触发这种演变的原因是什么?</li><li>GMP模型中有几种调度类型？Go的调度机制发生了怎么样的演变历程?</li><li>GPM 调度模型，如果一个 P 的本地 G 队列执行完了，会发生什么  1</li><li>GMP中协程的调度，是抢占式还是时间片？会饥饿吗？怎么处理？  1</li><li>如何初始化</li><li>假如有一个M挂掉了，或者发生io 阻塞，这时候会发生什么？</li><li>发生网络io,会怎么调度？发生阻塞的IO会怎么调度？epoll详解？</li></ul></li><li><code>struct</code><ul><li>go struct能不能比较</li><li>go结构体和结构体指针的区别</li></ul></li><li><code>select</code><ul><li>select可以用于什么?</li><li>说一下select的底层实现</li></ul></li><li><code>context</code><ul><li>context 协程安全吗？   `2</li><li>项目中 context 如何使用的？有使用过 context 哪些方法？`2</li><li>一个异常程序，一直往这个valueContext中添加不同的数据，会有什么问题吗？</li><li>如果现在设置了很多value，我现在通过Context去取这些值的时候，效率上会有什么问题吗？</li><li>context包内部如何实现的？</li></ul></li><li><code>goroutine</code><ul><li>goroutine 数据结构、创建过程及生命周期？<code>2</code></li><li>goroutine 创建过程？`2</li><li>父goroutine退出，如何使得子goroutine也退出？ <code>2</code></li><li>子goroutine的panic会导致主goroutine的panic吗，为什么 <code>2</code></li><li>多个协程等待一个协程执行完，除了WaitGroup 还有什么方式？</li><li>如果收到一个请求，里头有100个子任务，用 go 编码时直接创建100个协程并发处理，是否合适呢，会导致什么问题？<ul><li>不合适  资源消耗 调度开销 阻塞 控制困难  用协程池 限制并发数量</li></ul></li></ul></li><li><code>并发控制</code><ul><li>RW 锁的底层实现？ 1</li><li>go 中sync.Mutex 的底层如何实现的？抢占算法是怎样的？如何避免饥饿现象？1</li><li>waitgroup 实现 ? errGroup 是用来干什么的</li></ul></li><li><code>内存分配机制</code><ul><li>有mcentral为啥要mcache?</li><li>Go语言内存分配，什么分配在堆上，什么分配在栈上</li></ul></li><li><code>垃圾回收</code><ul><li>go的内存泄漏遇到过吗，大概会有哪些场景容易发生，怎么去避免？go的GC会自动关闭channel吗？</li><li>Go 的垃圾回收机制，和 Java 比有什么区别</li></ul></li><li><code>defer</code><ul><li>多个defer的执行顺序是怎么样的？有什么注意事项？</li><li>defer可以捕获到子Goroutine的panic吗？  <code>2</code></li><li>defer在什么情况下会修改函数返回值</li></ul></li><li><code>interface</code> <ul><li>底层数据结构和实现？如何判断一个接口变量是否为空（Type 和 Value？）<code>2</code></li><li>go什么场景使用接口</li></ul></li><li><code>其他go 相关</code><ul><li>Go 的反射机制</li><li>go怎么实现封装继承多态</li><li>golang 其他语言比较的特点?</li><li>有哪些你熟悉的golang中的第三方包包？</li><li>golang开发中遇到过什么内存占用比较高的问题吗，一般是用什么工具排查，是如何优化的？</li><li>go这门语言在你看来有没有什么设计上的缺陷？</li><li>工作中有没有遇到过一些go性能方面的问题？</li><li>For range的使用中，地址会发生变化吗</li><li>make和new有什么区别</li><li>golang 的赋值和传参是值传递还是引用传递？</li><li>go的变量申请类型</li><li>go深拷贝，什么时候需要深拷贝</li><li>go如何避免panic</li></ul></li></ul><h2 id="2-数据结构"><a href="#2-数据结构" class="headerlink" title="2 数据结构"></a>2 数据结构</h2><h3 id="2-1-channel"><a href="#2-1-channel" class="headerlink" title="2.1 channel"></a>2.1 channel</h3><ol><li>不要通过共享内存来通信，而要通过通信来实现内存共享 [[go-Channel]]</li><li><code>数据结构</code><ol><li>hchan 是 channel 的数据结构,其中 buf 指向存放数据的环形缓冲区</li><li>waitq 是阻塞的协程队列</li><li>sudog 是用于包装协程的节点</li></ol></li><li>构造:根据有无缓冲进行申请和初始化,本质是值的拷贝</li><li><code>写流程</code>: 不能写入未初始和已经关闭的 chan<ol><li><strong>存在阻塞读的协程</strong>: 加锁后从阻塞读队列中取出 goroutine 的封装对象 sudog,send 直接把元素拷贝给对应的 goroutine</li><li><strong>无阻塞读协程但环形缓冲区仍有空间</strong>:添加到环形缓冲区 sendx 位置</li><li><strong>写时无阻塞读协程且环形缓冲区无空间</strong>: 构造当前 goroutine 的 sudog 对象,并添加到阻塞写队列中</li></ol></li><li><code>读流程</code><ol><li>读空 chan , park 挂起,死锁</li><li>读已经关闭且无元素的,直接解锁返回</li><li>读时有阻塞的写,直接读缓冲区同步,然后唤醒写协程</li><li>读时无阻塞写,缓冲区无元素,构造 sudog 加入阻塞读队列</li></ol></li><li><code>关闭</code>:<ol><li>关闭未初始化的会 panic</li><li>重复关闭会 panic</li><li>优雅关闭: 向一个 closed channel 发送数据会导致 panic。因此原则是 发送端进行关闭,可以增加一个用于通知的中间信号 chan</li></ol></li><li><code>应用场景</code><ol><li>停止信号</li><li>任务定时</li><li>控制并发</li></ol></li></ol><h3 id="2-2-map"><a href="#2-2-map" class="headerlink" title="2.2 map"></a>2.2 map</h3><p><strong>用于 kv 储存的字典</strong></p><ol><li><code>注意点</code><ol><li>初始化  <code>myMap1 := make(map[int]int,2)</code>,不初始化就赋值会导致 panic</li><li>key必须可比较，不能是<code>chan、map、func</code>,也就是要求 hash 后的值和字面值都相等,float 会有精度转换,最好别作为 key</li><li>遍历是<code>无序</code>的，可以借助 slice 先排序；并发写<strong>不安全</strong></li><li>时间复杂度： O(1) 常数；大量的键值冲突，扩容会影响</li><li>map 的比较必须,非空, 长度相等 每个元素都相等</li></ol></li><li><code>底层数据结构与实现</code><ol><li>map 是一个指针,指向  [[go-hmap]] 结构体, hmap 中有 buckets 桶数组,bucket 指向 [[go-bmap]] 结构体 , 每个桶可存放八个 k-v 对,如果超过则会创建桶链表,通过溢出桶指针连接,结合了拉链法和开放地址法</li><li>写入流程<ol><li>获取 key 的 hash 值,共 64 个 bit 位</li><li>用最后的 B 个 bit 位,hash 值对桶数组长度取模,确定所属的桶 (<code>B</code> 是 buckets 数组的长度的对数)</li><li>再用哈希值的高8位,找到 key 在 bucket 中的位置</li><li>在桶中插入 kv 对 , key 和 value 是分别存放的</li></ol></li></ol></li><li><code>扩容流程</code><ol><li><strong>触发条件</strong><ol><li>通过 overLoadFactor 方法分辨</li><li>map 预分配容量小于等于 8，B 取 0，桶的个数为 1；</li><li>保证 map 预分配容量小于等于<code>桶数组长度 * 6.5</code>.</li></ol></li><li><strong>扩容方式</strong><ol><li><strong>增量扩容</strong>：当桶内 元素总数/桶数组长度 &gt; 6.5 时发生增量扩容，桶数组长度增长为原值的两倍<ol><li>举例：B = 5，根据它 hash 的后五位决定位置，扩容后 B=6，其低六位决定位置；这就是 rehash</li></ol></li><li><strong>等量扩容</strong>：当桶内溢出桶数量大于等于 2^B 时( B 为桶数组长度的指数，B 最大取 15)，发生等量扩容，桶的长度保持为原值； <code>可以解决剧烈的 hash 冲突,不是因为元素太多,而是溢出桶太多</code></li><li>采用渐进扩容的方式，每次最多搬两个,当桶被实际操作到时，由使用者负责完成数据迁移，避免因为一次性的全量数据迁移引发性能抖动.</li></ol></li></ol></li><li><code>读写过程</code><ol><li><strong>读流程</strong>  [[mapacess]]<ol><li>根据 key 取 hash 值；</li><li>根据 hash 值对桶数组取模，确定所在的桶；</li><li>沿着桶链表依次遍历各个桶内的 key-value 对；</li><li>命中相同的 key，则返回 value；倘若 key 不存在，则返回零值.</li></ol></li><li><strong>写流程</strong> [[mapassgin]]<ol><li>确定所在的桶；</li><li>如果 map 处于扩容，则迁移命中的桶，帮助推进渐进式扩容；</li><li>沿着桶链表依次遍历各个桶内的 key-value 对；</li><li>如果命中相同的 key，则对 value 中进行更新；否则插入</li><li>如果发现 map 达成扩容条件，则会开启扩容模式，并重新返回第（2）步.</li></ol></li></ol></li><li><code>并发安全？</code><ol><li>map不能同时读写或写写，会引起<code>fatal</code> 错误</li><li>map.flags 的第 3 个 bit 位是<code>写标记</code></li><li><code>sync.Mutex</code> 降低性能来保证并发安全，读写都加</li><li><code>sync.RWMutex</code> 读写锁，运行并发读，提高性能</li><li><code>sync.Map</code>  [[00-Inbox/A-Golang/代码引用/sync.Map]]<ol><li>适用于读多、更新多、删多、写少的场景</li><li>读写 read，全程无锁，dirty 需要加锁，多用 read</li><li>CAS 当前值A、内存值V、要修改的新值B</li></ol></li></ol></li><li><code>注意问题？</code><ol><li>记得初始化，否则会 panic，这个 panic 可以 recover吗？<ol><li><strong>不能</strong>，调用的是 <code>runtime.fatalthrow()</code>，然后调用 <code>exit(2)</code>结束进程</li><li>[[panic 机制]]</li></ol></li><li>遍历是无序的</li><li>key 是否存在，校验一下 ok</li><li>map 是引用类型的，用 make 来构造</li><li>可以通过定义 value 为 struct 来节约内存；[[go-struct]]</li><li>map 中删除一个 key，它的内存会释放么？</li><li>map 取一个 key，然后修改这个值，原 map 数据的值会不会变化</li></ol></li></ol><h3 id="2-3-slice"><a href="#2-3-slice" class="headerlink" title="2.3 slice"></a>2.3 slice</h3><ol><li><code>底层数据</code>：[[go-slice]]<ol><li>slice 是对数组的封装,描述一个数组的片段;</li><li>结构体中有三个字段：长度、容量、<strong>底层数组</strong></li><li>底层数组可以被多个 slice 持有,因此会互相影响</li></ol></li><li><code>扩容</code>:<ol><li>append 向 slice 添加元素达到底层数组最大值后就要扩容</li><li>当原 slice 容量小于 <code>1024</code> 的时候，新 slice 容量变成原来的 <code>2</code> 倍；原 slice 容量超过 <code>1024</code>，新 slice 容量变成原来的<code>1.25</code>倍。  </li><li>1.18 版本更新: 当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap = oldcap+(oldcap+3✖️256)/4</li><li>还有一个内存对齐的操作,可能会偏大</li></ol></li><li><code>作为函数参数</code><ol><li>在该函数中修改切片中变量值，会影响到外部，而向这个切片添加元素则不影响；？why</li><li>因为传递过去的是 array，len，cap 的拷贝，指针指向 array 因此修改可以感知到，而添加修改的只是函数内的 len，外部的 len 没变。</li><li>Go 语言的函数参数传递，只有值传递，没有引用传递。</li></ol></li></ol><h3 id="2-4-interface"><a href="#2-4-interface" class="headerlink" title="2.4 interface"></a>2.4 interface</h3><ol><li>底层实现[[go-interface]]<ol><li>iface：非空接口，包括指向具体值的 <code>data</code> 数据指针，和指向 itab 实体的<code>tab</code>指针,中有 <code>fun</code> 方法集合和<code>interfacetype</code> 描述类型信息</li><li>eface：空接口，只有类型信息和数据指针</li></ol></li><li>比较<ol><li>先将 nil 转换成 interface<code>(type=nil, data=nil)</code> ，然后分别比较 type 和 data</li></ol></li></ol><h3 id="2-5-defer"><a href="#2-5-defer" class="headerlink" title="2.5 defer"></a>2.5 defer</h3><ol><li>[[go-defer]] </li><li>实现: 底层是使用链表实现,每次新注册的都是头插法注册到链表头部</li><li>原理：deferproc()注册到<code>_defer</code> 链表头，并在 return前插入了函数deferreturn()</li><li>执行顺序：<code>延迟函数参数</code>在defer语句<code>出现时</code>就已经确定下来,后进先出的</li><li><strong>参数求值</strong>：defer 语句中的参数在声明时就会被计算</li><li>defer只能捕获<code>本层的panic</code></li><li>作用: 资源,连接的关闭和清除缓存</li></ol><h3 id="2-6-select"><a href="#2-6-select" class="headerlink" title="2.6 select"></a>2.6 select</h3><ul><li>select 是 Go 中的一个控制结构，类似于 switch 语句。</li><li>select 语句只能用于通道操作，每个 case 必须是一个通道操作，要么是发送要么是接收。</li><li>select 语句会监听所有指定的通道上的操作，一旦其中一个通道准备好就会执行相应的代码块。</li><li>如果多个通道都准备好，那么 select 语句会随机选择一个通道执行。如果所有通道都没有准备好，那么执行 default 块中的代码。</li></ul><h2 id="3-GMP原理"><a href="#3-GMP原理" class="headerlink" title="3 GMP原理"></a>3 GMP原理</h2><h3 id="3-1-协程"><a href="#3-1-协程" class="headerlink" title="3.1 协程"></a>3.1 协程</h3><ol><li><code>进程</code>、<code>线程</code>、<code>协程</code>的概念与区别<ol><li><strong>进程</strong>：<pre><code>1. 进程是程序的一次执行过程；由程序，数据和进程控制块组成2. 进程是系统进行资源分配和调度的一个独立单位。3. 每个进程都有自己的独立内存空间，不同进程通过`进程间通信`来通信</code></pre></li><li><strong>线程</strong>：<pre><code>1. 线程是进程的一个实体,是CPU调度和分派的基本单位,是比进程更小的能独立运行的基本单位.2. 线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。3. 线程间通信主要通过`共享内存`，上下文切换很快。</code></pre></li><li><strong>协程</strong>：<pre><code>1. 协程是一种`用户态`的轻量级线程，协程的调度完全由用户控制，类似于函数调用。2. 协程拥有自己的寄存器上下文和栈。直接操作栈则基本没有**内核切换**的开销，可以不加锁的访问全局变量，所以切换非常快。3. 实现：协程是基于线程的，就是 GMP4. `Goroutine`    1. 创建、销毁、调度在用户态完成，对内核透明，足够轻便；    2. 可利用多个线程，实现`并行`；    3. 通过调度器的斡旋，实现和线程间的`动态绑定`和`灵活调度`；    4. 栈空间大小可动态扩缩，因地制宜.</code></pre></li><li><strong>区别：</strong><pre><code>1. `内存消耗`：goroutine 2kb    线程 MB2. `创建和销毁`:线程的创建销毁是内核级的,小号较大,goroutine 是用户级的3. `切换`: 线程切换要保存各种寄存器,goroutine 只要三个 Program Counter, Stack Pointer and BP,  只要 200ns 大概五分之一</code></pre></li></ol></li><li><code>Goroutine</code> 详解  [[go-Goroutine]]<ol><li>数据结构:<ol><li>m：在 p 的代理，负责执行当前 g 的 m</li><li>保存各种寄存器和系统调用返回值的 sched</li></ol></li><li>生命周期<ol><li>未初始化  待执行 执行中 系统调用 挂起 已销毁 栈扩容中  被抢占</li></ol></li><li>创建过程:  newproc函数创建一个新的 goroutine</li><li>子goroutine的panic会导致主goroutine的panic吗，为什么<ol><li>不会，panic 只会导致程序退出</li></ol></li><li>父goroutine退出，如何使得子goroutine也退出？  <ol><li>可以通过channel 或者 Context 实现</li></ol></li><li>控制：协程池，Semaphore，waitgroup<ol><li>多个协程同步等待,除了 waitgroup 还可以用通道</li></ol></li></ol></li></ol><h3 id="3-2-GMP-调度"><a href="#3-2-GMP-调度" class="headerlink" title="3.2 GMP 调度"></a>3.2 GMP 调度</h3><ol><li>[[go-GMP]]</li><li>GMP 调度模型<ol><li>G(goroutine协程)  :有自己的运行栈、状态、以及执行的任务函数</li><li>P(Processor调度器)：承上启下，调度 g 并代理 m，决定了 g 最大并行数量，最多有<code>GOMAXPROCS</code>(可配置)个，超过 cpu 核数的无效</li><li>M( machine,thread线程) ：不直接执行 g，而是先和 p 绑定，由其实现代理</li><li>数量关系<ol><li>P的数量问题：由启动时环境变量$GOMAXPROCS或者是由runtime的方法GOMAXPROCS()决定。 最多只有这么多个。一般建议是<strong>逻辑 CPU 数量的 2 倍</strong></li><li>M的数量：默认是 1000；SetMaxThreads函数设置；M 阻塞会创建新的</li></ol></li></ol></li><li>调度策略：<ol><li>G的存放队列有三类：P的本地队列；全局队列；和wait队列</li><li>M调度G时，优先取P本地队列，其次取全局队列，最后取wait队列；这样的好处是，取本地队列时，可以接近于<code>无锁化</code>，减少全局锁竞争；</li><li>为防止不同P的闲忙差异过大，设立 <code>work-stealing</code> 机制，本地队列为空的P可以尝试从其他P本地队列偷取一半的G补充到自身队列.</li></ol></li></ol><h2 id="4-内存模型"><a href="#4-内存模型" class="headerlink" title="4 内存模型"></a>4 内存模型</h2><h3 id="4-1-go-内存模型与分配机制"><a href="#4-1-go-内存模型与分配机制" class="headerlink" title="4.1 go-内存模型与分配机制"></a>4.1 go-内存模型与分配机制</h3><ol><li>[[go-内存模型与分配机制]]</li><li>内存模型<ol><li>从大到小：mheap，mcentral，mcache，mspan</li></ol></li><li>分配流程<ol><li>从 P 专属 mcache 的 tiny 分配器取内存（无锁）</li><li>根据所属的 spanClass，从 P 专属 mcache 缓存的 mspan 中取内存（无锁）</li><li>根据所属的 spanClass 从对应的 mcentral 中取 mspan 填充到 mcache，然后从 mspan 中取内存（spanClass 粒度锁）</li><li>根据所属的 spanClass，从 mheap 的页分配器 pageAlloc 取得足够数量空闲页组装成 mspan 填充到 mcache，然后从 mspan 中取内存（全局锁）</li><li>mheap 向操作系统申请内存，更新页分配器的索引信息，然后重复（4）.</li></ol></li></ol><h3 id="4-2-内存泄露"><a href="#4-2-内存泄露" class="headerlink" title="4.2 内存泄露"></a>4.2 内存泄露</h3><ol><li>谈谈内存泄露，什么情况下内存会泄露？怎么定位排查内存泄漏问题？</li><li>分配的内存资源没有被正确释放或回收，导致程序占用的内存不断增加，最终可能导致程序性能下降或崩溃。</li><li>原因：未关闭文件或网络连接；不释放资源；协程泄漏；通道阻塞；保持对对象的引用；循环引用</li><li>怎么排查：<code>go vet</code>、<code>go tool pprof</code>和<code>go tool trace</code>等</li></ol><h3 id="4-3-内存逃逸"><a href="#4-3-内存逃逸" class="headerlink" title="4.3 内存逃逸"></a>4.3 内存逃逸</h3><ol><li>谈谈内存逃逸？什么情况下会发生内存逃逸？</li><li>在函数或方法中分配的内存在函数的生命周期结束后仍然被引用或访问，使得该内存块无法在函数的栈上分配并在函数退出时自动回收，而<code>必须分配在堆上</code>，并由垃圾回收器负责回收。</li><li><code>原因</code>：<pre><code>1. **返回指针到局部变量**:如果一个函数返回了一个指向局部变量的指针，并且这个指针在函数外部被引用，那么该局部变量就会逃逸到堆上。2. **闭包引用**：如果一个闭包（函数值）引用了函数内部的变量，并且该闭包在函数外部被执行，那么这些变量就会逃逸到堆上。3. **使用`go`关键字启动协程**：使用`go`关键字启动协程时，被协程引用的变量可能会逃逸到堆上，因为协程的生命周期不受限制，可能会在函数退出后继续执行。4. 栈空间不足逃逸：比如切片过大5. **向函数传递指针或切片**：如果将指针或切片传递给函数，并且在函数内部对它们进行修改后，它们可能会逃逸到堆上。</code></pre></li><li><code>闭包</code>：<pre><code>1. 是一种函数值（Function Value），它包含了一个函数体和一个引用了外部变量的词法环境。2. **函数体**：闭包包含了一个函数体，这个函数体可以有参数和返回值，就像普通函数一样。3. **词法环境**：闭包引用了一个或多个外部变量，这些外部变量存在于闭包创建时的作用域中，而不是在闭包被调用时的作用域中。这些外部变量可以在闭包内部被访问和修改。4. **独立性**：每个闭包都有自己的词法环境，因此闭包之间的外部变量不会相互影响。</code></pre></li></ol><h3 id="4-4-内存分配"><a href="#4-4-内存分配" class="headerlink" title="4.4 内存分配"></a>4.4 内存分配</h3><p>Go 是如何分配内存的？  Channel 分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？</p><pre><code>1. 通道（Channel）本身是一个`引用类型`，它在栈上分配的是通道的`描述符`，而实际的通道数据结构（包括通道的缓冲区和其他管理信息）是在堆上分配的。这是因为通道的大小是动态的，无法在编译时确定，因此通道的数据结构需要在运行时进行`动态分配`。2. **栈上分配**：    1. 局部变量：函数内部定义的局部变量通常分配在栈上，它们在函数执行结束时自动释放。    2. 函数参数：函数参数也分配在栈上，它们的生命周期与函数调用关联。3. **堆上分配**：    1. 动态分配：使用`new()`、`make()`、`append()`等内建函数动态分配的对象通常分配在堆上，因为它们的生命周期不受限制，需要在程序的其他部分继续访问。    2. 逃逸对象：如果编译器无法确定对象的生命周期，或者对象被引用超出了其定义的作用域，那么这些对象可能会逃逸到堆上分配。</code></pre><h2 id="5-GC-原理"><a href="#5-GC-原理" class="headerlink" title="5 GC 原理"></a>5 GC 原理</h2><ol><li>[[go-GC 原理]]</li><li>垃圾回收算法：三色标记法</li><li>屏障机制</li><li>GC 中 stw 时机，各个阶段是如何解决的？<ol><li>通过屏障技术解决</li></ol></li><li>GC 的触发时机？<ol><li>手动触发，调用 <code>runtime.GC</code></li><li>系统触发：<ol><li>gcTriggerHeap：当所分配的堆大小达到阈值时，将会触发。</li><li>gcTriggerTime：当距离上一个 GC 周期的时间超过一定时间时，将会触发。默认 2 分钟。</li><li>gcTriggerCycle：如果没有开启 GC，则启动 GC。</li></ol></li></ol></li><li>介绍一下大对象小对象，为什么小对象多了会造成 gc 压力<ol><li>Go 的内存分配用的是 tcmalloc 算法，传统的 tcmalloc，会为每个分配请求执行一个比较完整的 malloc GC 方法</li><li>通常小对象过多会导致GC三色法消耗过多的CPU。优化思路是，减少对象分配。</li></ol></li></ol><h2 id="6-并发编程"><a href="#6-并发编程" class="headerlink" title="6 并发编程"></a>6 并发编程</h2><h3 id="6-1-内存模型"><a href="#6-1-内存模型" class="headerlink" title="6.1 内存模型"></a>6.1 内存模型</h3><h3 id="6-2-context"><a href="#6-2-context" class="headerlink" title="6.2 context"></a>6.2 context</h3><ol><li>[[go-context]]</li><li>用途：超时控制和传递 traceid<ol><li>WithCancel：可以手动调用 cancel() 方法以取消</li><li>WithDeadline &amp; WithTimeout：可以自定义超时时间</li><li>WithValue：可以携带信息，比如 traceid 等,父节点不能获取子节点存储的值</li></ol></li><li>context 并发安全</li></ol><h3 id="6-3-sync-Map"><a href="#6-3-sync-Map" class="headerlink" title="6.3 sync.Map"></a>6.3 sync.Map</h3><ol><li>使用场景: 读多、更新多、删多、写少</li><li>底层实现: <ul><li>read 和 dirty 两个字段将读写分离</li><li>最新写入的数据则存在 dirty 字段上</li><li>读取时会先查询 read，不存在再查询 dirty，写入时则只写入 dirty</li><li>读取 read 并不需要加锁，而读或写 dirty 都需要加锁</li><li>另外有 misses 字段来统计 read 被穿透的次数（被穿透指需要读 dirty 的情况），超过一定次数则将 dirty 数据同步到 read 上,因为读是在 read 上的,所以 read 是最新的,然后 dirty 为 nil</li><li>对于删除数据则直接通过标记来延迟删除</li></ul></li><li>和直接加锁的区别?  读写分离 提高并发</li><li>删: 先读 read,有的话标记删除,没有就去 dirty 中直接删除,标记删除可以缓存</li><li>读: Load() ,先去 read 查,没有就去 dirty加锁查,miss 加一</li><li>写: Store() <ol><li>倘若 read map 存在拟写入的 key，且 entry 不为 expunged 状态，说明这次操作属于更新而非插入，直接基于 CAS 操作进行 entry 值的更新，并直接返回（存活态或者软删除，直接覆盖更新）；</li><li>倘若未命中（1）的分支，则需要加锁 double check；</li><li>倘若第二轮检查中发现 read map 或者 dirty map 中存在 key-entry 对，则直接将 entry 更新为新值即可（存活态或者软删除，直接覆盖更新）；</li><li>在第（3）步中，如果发现 read map 中该 key-entry 为 expunged 态，需要在 dirty map 先补齐 key-entry 对，再更新 entry 值（从硬删除中恢复，然后覆盖更新）；</li><li>倘若 read map 和 dirty map 均不存在，则在 dirty map 中插入新 key-entry 对，并且保证 read map 的 amended flag 为 true.（插入）</li><li>第（5）步的分支中，倘若发现 dirty map 未初始化，需要前置执行 dirtyLocked 流程；</li></ol></li><li>value 状态<ol><li>存活态很好理解，即 key-entry 对仍未删除；</li><li>nil 态表示软删除，read map 和 dirty map 底层的 map 结构仍存在 key-entry 对，但在逻辑上该 key-entry 对已经被删除，因此无法被用户查询到；</li><li>expunged 态表示硬删除，dirty map 中已不存在该 key-entry 对.</li></ol></li><li>总结<ol><li>为什么需要使用 expunged 态来区分软硬删除呢？软删除可以 CAS,硬删除态要加锁</li><li>总体思想，希望能多用 read map，少用 dirty map，因为操作前者无锁，后者需要加锁；</li><li>除了 expunged 态的 entry 之外，read map 的内容为 dirty map 的子集；</li><li>dirtyLocked: dirty 为空,访问 readmiss,遍历 read,拷贝到 dirty 去</li><li>sync.Map 适用于读多、更新多、删多、写少的场景；</li><li>倘若写操作过多，sync.Map 基本等价于互斥锁 + map；</li><li>sync.Map 可能存在性能抖动问题，主要发生于在读/删流程 miss 只读 map 次数过多时（触发 missLocked 流程），下一次插入操作的过程当中（dirtyLocked 流程）.</li></ol></li></ol><h3 id="6-4-sync-WaitGroup"><a href="#6-4-sync-WaitGroup" class="headerlink" title="6.4 sync.WaitGroup"></a>6.4 sync.WaitGroup</h3><ol><li>[[00-Inbox/A-Golang/代码引用/go-sync.WaitGroup]]</li><li>主要方法：add done wait</li><li>其他实现方法？   channel 信号量这些并发安全的进行计数，然后主协程进行汇总</li></ol><h3 id="6-5-sync-mutex"><a href="#6-5-sync-mutex" class="headerlink" title="6.5 sync.mutex"></a>6.5 sync.mutex</h3><ol><li>[[00-Inbox/A-Golang/代码引用/go-sync.Mutex]]</li><li>底层实现<ol><li>state 字段标识当前互斥锁的状态</li><li>sema 信号量 控制锁状态的信号量</li></ol></li><li>抢占算法<ul><li>如果互斥锁处于初始化状态，会通过 <code>CAS</code> 置位 <code>mutexLocked</code> 加锁；</li><li>如果互斥锁处于 <code>mutexLocked</code> 状态并且在普通模式下工作，会进入自旋，执行 30 次 <code>PAUSE</code> 指令消耗 CPU 时间等待锁的释放；</li><li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li><li>互斥锁在正常情况下会通过<code>sync_runtime_SemacquireMutex</code>将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；</li><li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式；</li></ul></li><li>如何避免饥饿： 一旦 Goroutine <code>超过 1ms</code> 没有获取到锁，它就会将当前互斥锁切换<code>饥饿模式</code>，防止部分 Goroutine 被<strong>饿死</strong>。</li></ol><h3 id="6-6-sync-RWMutex"><a href="#6-6-sync-RWMutex" class="headerlink" title="6.6 sync.RWMutex"></a>6.6 sync.RWMutex</h3><h3 id="6-7-sync-Cond"><a href="#6-7-sync-Cond" class="headerlink" title="6.7 sync.Cond"></a>6.7 sync.Cond</h3><h3 id="6-8-sync-Once"><a href="#6-8-sync-Once" class="headerlink" title="6.8 sync.Once"></a>6.8 sync.Once</h3><h3 id="6-9-sync-Pool"><a href="#6-9-sync-Pool" class="headerlink" title="6.9 sync.Pool"></a>6.9 sync.Pool</h3><h3 id="6-10-拾遗"><a href="#6-10-拾遗" class="headerlink" title="6.10 拾遗"></a>6.10 拾遗</h3><ol><li><code>Go 如何实现原子操作</code> ：Go语言的标准库代码包sync/atomic提供了原子的读取（Load为前缀的函数）或写入（Store为前缀的函数）某个值</li></ol><h2 id="7-拾遗"><a href="#7-拾遗" class="headerlink" title="7 拾遗"></a>7 拾遗</h2><h3 id="7-1-反射"><a href="#7-1-反射" class="headerlink" title="7.1 反射"></a>7.1 反射</h3><ul><li><code>reflect</code> 包提供了反射机制，可以在运行时获取变量的类型信息、值信息、方法信息等等。</li><li>go 中的 <code>interface&#123;&#125;</code> 实际上包含了两个指针，一个指向类型信息，一个指向值信息。正因如此，我们可以在运行时通过 <code>interface&#123;&#125;</code> 来获取变量的类型信息、值信息。</li><li><code>reflect.Type</code> 代表一个类型，<code>reflect.Value</code> 代表一个值。通过 <code>reflect.Type</code> 可以获取类型信息，通过 <code>reflect.Value</code> 可以获取值信息。</li><li>反射三定律：<ul><li>反射可以将 <code>interface</code> 类型变量转换成反射对象。</li><li>反射可以将反射对象还原成 <code>interface</code> 对象。</li><li>如果要修改反射对象，那么反射对象必须是可设置的（<code>CanSet</code>）。</li></ul></li><li><code>reflect.Value</code> 和 <code>reflect.Type</code> 里面都有 <code>Elem</code> 方法，但是它们的作用不一样：<ul><li><code>reflect.Type</code> 的 <code>Elem</code> 方法返回的是元素类型，只适用于 array、chan、map、pointer 和 slice 类型的 <code>reflect.Type</code>。</li><li><code>reflect.Value</code> 的 <code>Elem</code> 方法返回的是值，只适用于接口或指针类型的 <code>reflect.Value</code>。</li></ul></li><li>通过 <code>reflect.Value</code> 的 <code>Interface</code> 方法可以获取到反射对象的原始变量，但是是 <code>interface&#123;&#125;</code> 类型的。</li><li><code>Type</code> 和 <code>Kind</code> 都表示类型，但是 <code>Type</code> 是类型的反射对象，<code>Kind</code> 是 go 类型系统中最基本的一些类型，比如 <code>int</code>、<code>string</code>、<code>struct</code> 等等。</li><li>如果我们想通过 <code>reflect.Value</code> 来修改变量的值，那么 <code>reflect.Value</code> 必须是可设置的（<code>CanSet</code>）。同时如果想要 <code>CanSet</code> 为 true，那么我们的变量必须是可寻址的。</li><li>我们有很多方法可以创建 <code>reflect.Type</code> 和 <code>reflect.Value</code>，我们需要根据具体的场景来选择合适的方法。</li><li><code>reflect.Type</code> 和 <code>reflect.Value</code> 里面，都有一部分方法是通用的，也有一部分只适用于特定的类型。如果我们想要调用那些适用于特定类型的方法，那么我们必须先判断 <code>reflect.Type</code> 或 <code>reflect.Value</code> 的类型（这里说的是 <code>Kind</code>），然后再调用。</li></ul><h3 id="7-2-select-通道选择器"><a href="#7-2-select-通道选择器" class="headerlink" title="7.2 select 通道选择器"></a>7.2 select 通道选择器</h3><p>随机选择可读取或者写入的通道执行</p><ol><li>多个case分支的通道可以执行，随机选择一个case分支执行</li><li>如果存在default，执行；否则阻塞到有分支可以执行</li></ol><h3 id="7-3-make-和-new-的区别？"><a href="#7-3-make-和-new-的区别？" class="headerlink" title="7.3 make 和 new 的区别？"></a>7.3 make 和 new 的区别？</h3><ol><li><strong>make</strong> ：用于创建内置数据结构的实例，返回一个已初始化的实例(因为他们本来就是引用类型)。；<strong>只用于slice，map，channel的创建</strong></li><li><strong>new</strong>：根据传入的类型分配一片内存空间并返回指向零值的<strong>指针</strong>;  它不会对这些数据结构进行初始化。</li><li>make只用于创建map，slice和channel等内置的数据结构，并且不返回指针。要获得一个显式的指针，使用new进行分配，或者显式地使用一个变量的地址。</li><li>make和new都是golang用来分配内存的內建函数，且在堆上分配内存，make 即分配内存，也初始化内存。new只是将内存清零，并没有初始化内存。</li><li>make返回的还是引用类型本身；而new返回的是指向类型的指针。</li><li>make只能用来分配及初始化类型为slice，map，channel的数据；new可以分配任意类型的数据。</li></ol><h3 id="7-4-协程泄露"><a href="#7-4-协程泄露" class="headerlink" title="7.4 协程泄露"></a>7.4 协程泄露</h3><blockquote><p>创建的协程（Goroutine）没有被正确地释放或终止，导致这些协程一直存在于程序中，却无法被垃圾回收，从而占用了系统资源。</p></blockquote><p><code>产生原因</code></p><ul><li>协程没有正常退出</li><li>协程被阻塞而无法退出</li><li>协程泄露的循环引用<br><code>解决方法</code></li><li>使用<code>defer</code>确保资源释放</li><li>使用通道来通知协程退出</li><li>使用<code>context</code>包 ^890b65</li><li>避免循环引用</li><li>使用工具进行检查：可以使用一些工具和分析器，如<code>go vet</code>、<code>go race</code>和<code>go tool trace</code>来检测协程泄露和并发问题</li></ul><h3 id="7-5-struct"><a href="#7-5-struct" class="headerlink" title="7.5 struct"></a>7.5 struct</h3><p>[[go-struct]]<br><code>go struct 能不能比较？</code></p><ul><li>可以比较的结构体<ul><li>前提：结构体内的字段都是可以比较的</li><li>如果两个结构体的字段相同并且相等，那么它们被认为是相等的。</li></ul></li><li>不可比较的结构体<ul><li>结构体中包含不可比较的字段，例如切片（slice）、映射（map）或函数类型</li><li>结构体中包含指针字段，比较的是指针的值而不是指针指向的内容</li></ul></li></ul><h3 id="7-6-泛型"><a href="#7-6-泛型" class="headerlink" title="7.6 泛型"></a>7.6 泛型</h3><ol><li>在函数和方法中使用类型参数：你可以编写可以接受不同类型参数的函数和方法，这样可以大大提高代码的复用性。</li><li>创建泛型数据结构：你可以创建可以处理多种数据类型的数据结构，例如通用的切片、映射或链表等。</li><li>提供类型安全性：泛型在编译时进行类型检查，确保类型参数的一致性，避免了运行时的类型错误。</li></ol><h3 id="7-7-for-range-原理与要点"><a href="#7-7-for-range-原理与要点" class="headerlink" title="7.7 for range 原理与要点"></a>7.7 for range 原理与要点</h3><ol><li>for range 是 Go 语言用来遍历的一种方式，它可以操作数组、切片、map、channel 等</li><li>遍历 map 为随机序输出，slice 为索引序输出；</li><li>range v 是值拷贝，且只会声明初始化一次；</li><li>在<code>for-range</code>循环过程中，<code>v</code>的地址保持不变，而<code>v</code>地址对应的值是<code>最后一次循环</code>对应的<code>v</code>的值。</li><li>对<code>map</code>遍历时删除元素能遍历到吗？——不会</li><li>对<code>map</code>遍历时新增元素会被遍历到吗——可能会</li><li><code>range</code>操作的对象都是在复制的对象中操作，而不是原对象上<ol><li>由于数组是值拷贝，中间过程中对原对象做任何改变，都不会改变拷贝对象的值。</li><li>由于切片是地址拷贝，即<code>range</code>拷贝出来的值和原来变量的值都是指向了同一个对象，当一个地方改变了对象的值，另外一个地方来访问对象的值时也会随之发生变化。</li></ol></li></ol><h3 id="7-8-数据类型-rune-uint"><a href="#7-8-数据类型-rune-uint" class="headerlink" title="7.8 数据类型 rune uint"></a>7.8 数据类型 rune uint</h3><ul><li><p>rune：是一种整数类型，用于表示Unicode字符。具体来说，<code>rune</code>是一个32位的整数类型，可以存储任何有效的Unicode代码点（Unicode code point）。因此，<code>rune</code>类型通常用于处理和操作Unicode字符，例如在字符串中遍历和索引字符。</p></li><li><p><code>uint32</code>是一个32位无符号整数类型，表示的范围是从0到2^32-1，即0到4294967295。当一个<code>uint32</code>类型的变量的值超过了这个范围时，就会发生溢出（Overflow）。溢出是指一个数值超过了其数据类型所能表示的最大值，或者低于其数据类型所能表示的最小值。在<code>uint32</code>的情况下，当一个变量的值超过了4294967295，即2^32-1时，它会从0开始重新计数，继续增加。</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/07/Basic/Linux/"/>
      <url>/2025/05/07/Basic/Linux/</url>
      
        <content type="html"><![CDATA[<h2 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1 常用命令"></a>1 常用命令</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">查看进程  ps -ef| grep A</span><br><span class="line">复制文件  scp -r /home/a.txt root@B_ip:/home  <span class="comment">//将A服务器中/home/a.txt 复制到B服务器的/home中</span></span><br><span class="line">动态查看命令执行结果  watch</span><br><span class="line">网络相关  tcpdump</span><br><span class="line">列出当前系统打开的文件描述符  lsof</span><br><span class="line">网络信息统计    netstat</span><br><span class="line">系统的进程信息，内存使用等资源使用情况   vmstat</span><br><span class="line">cpu的使用情况   mpstat</span><br><span class="line"> </span><br><span class="line"><span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 2 升级 openssh</span></span><br><span class="line"><span class="string">一、升级背景：</span></span><br><span class="line"><span class="string">漏洞扫描显示linux服务器openssh有高危漏洞，需要进行修复。openssh是远程登录到linux服务器</span></span><br><span class="line"><span class="string">的重要工具，要修复此漏洞需升级到最高版本（2021年5月中旬最新版本为8.6p1）。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">二、升级说明：</span></span><br><span class="line"><span class="string">1、所有升级文件均从官网下载。</span></span><br><span class="line"><span class="string">2、linux服务器系统为Centos7可适用此方案。</span></span><br><span class="line"><span class="string">3、Centos7系统需要有yum源，方便解决依赖关系问题。如无法实现，则需上传同系统版本安装映</span></span><br><span class="line"><span class="string">像文件，作为本地yum源。</span></span><br><span class="line"><span class="string">4、安装过程受网络影响极大，一旦出现不可抗因素致网络断开，可能会导致升级中断，无法远程</span></span><br><span class="line"><span class="string">连接，出现此情况需现场人员配合解决。</span></span><br><span class="line"><span class="string">5、升级过程出现问题需现场人员根据回退方案进行恢复操作。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">三、升级过程：</span></span><br><span class="line"><span class="string">（0）安装并启用telnet</span></span><br><span class="line"><span class="string">1、安装telnet</span></span><br><span class="line"><span class="string">`</span>yum install telnet-server telnet xinet</span><br><span class="line"><span class="number">2</span>、修改配置文件</span><br><span class="line"><span class="string">`vi /etc/xinetd.d/telnet</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span>disable= no       <span class="comment">//将yes改为no</span></span><br><span class="line"><span class="string">``</span>#让root可以登录</span><br><span class="line"><span class="string">``</span>#mv /etc/securetty /etc/securetty.bak</span><br><span class="line">重启服务</span><br><span class="line"><span class="string">`service xinetd restart</span></span><br><span class="line"><span class="string">3、启动相应服务，然后使用telnet登录到服务器</span></span><br><span class="line"><span class="string">`</span>systemctl start telnet.socket</span><br><span class="line"><span class="string">`systemctl start xinetd</span></span><br><span class="line"><span class="string">`</span>chkconfig --list</span><br><span class="line">（一）配置yum源</span><br><span class="line"><span class="number">1</span>、上传与生产环境相同的centos7版本的iso和openssh8<span class="number">.6</span>p1的安装包到服务器。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、挂载iso</span><br><span class="line">创建iso存放目录和挂载目录，并上传iso镜像文件到iso存放目录/mnt/iso下</span><br><span class="line"><span class="string">`mkdir /mnt/iso </span></span><br><span class="line"><span class="string">`</span>mkdir /mnt/cdrom</span><br><span class="line"><span class="string">`mv CentOS-7.6-x86_64-DVD-1810.iso /mnt/iso/</span></span><br><span class="line"><span class="string">挂载iso镜像到挂载目录/mnt/cdrom下</span></span><br><span class="line"><span class="string">`</span>mount -o loop /mnt/iso/CentOS<span class="number">-7.6</span>-x86_64-DVD<span class="number">-1810.i</span>so /mnt/cdrom</span><br><span class="line">使用df -h命令查询挂载是否成功</span><br><span class="line"><span class="string">`df -h</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">3、备份原本地源</span></span><br><span class="line"><span class="string">进入repos配置目录</span></span><br><span class="line"><span class="string">`</span>cd /etc/yum.repos.d/</span><br><span class="line">创建备份文件夹</span><br><span class="line"><span class="string">`mkdir repobak</span></span><br><span class="line"><span class="string">移动配置文件到repobak文件夹中</span></span><br><span class="line"><span class="string">`</span>mv *.repo repobak/</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>、新建光盘源配置文件</span><br><span class="line"><span class="string">`vi CentOS-Media.repo</span></span><br><span class="line"><span class="string">输入下列内容</span></span><br></pre></td></tr></table></figure><p>[c7-media]<br>name=CentOS-$releasever - Media<br>baseurl=file:///mnt/cdrom/</p><p>gpgcheck=0<br>enabled=1<br><code>``5、测试安装源</code>yum clean all<br><code>yum makecache（二）升级openssh版本到8.6p11、下载或上传安装包openssh-8.6p1.tar.gz到/root目录下进入安装包所在文件夹</code>cd /root/linshi</p><p>2、关闭Selinux<br><code>setenforce 0</code>sed -i “s/SELINUX=enforcing/SELINUX=disabled/g” /etc/selinux/config</p><p>3、安装依赖关系<br><code>yum install -y gcc pam-devel rpm-build wget zlib-devel openssl-devel net-tools</code>tar -xvf openssh-8.6p1.tar.gz<br>`cd openssh-8.6p1</p><p>4、卸载旧版openssh<br><code>rpm -qa |grep opensshps:下一步骤为删除原有ssh，但不会影响现在进行的ssh会话，所以整个操作过程不要断开ssh会话，否则无法再次连接，只能由现场人员进行回退后重新操作（推荐使用telnet进行升级）。</code>for i in $(rpm -qa |grep openssh);do rpm -e $i —nodeps;done</p><p>5、设置、编译、安装<br><code>`./configure --prefix=/usr --sysconfdir=/etc/ssh --with-md5-passwords --with-pam --with-tcp-wrappers  --with-ssl-dir=/usr/local/ssl/lib --without-hardening</code>mv /etc/ssh /etc/ssh.old<br>`cp contrib/redhat/sshd.pam /etc/pam.d/sshd</p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>`make</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>`make install</p><p>6、设置自启动<br><code>复制启动脚本到/etc/init.d</code>cp contrib/redhat/sshd.init /etc/init.d/sshd<br><code>chkconfig --add sshd</code>chkconfig sshd on<br><code>chkconfig --list|grep sshd</code>sed -i “32a PermitRootLogin yes” /etc/ssh/sshd_config<br><code>`重启ssh服务</code>service sshd restart</p><p>7、检查升级情况<br>`ssh -V<br>输出版本号为“OpenSSH_8.6p1”，说明更新成功</p><p>(三)关闭telnet<br>关闭服务<br><code>systemctl stop telnet.socket</code>systemctl stop xinetd<br><code>#root可以登录</code>#mv /etc/securetty.bak /etc/securetty</p><p>卸载telnet<br>`yum remove telnet-server  xinetd</p><p>ps：此时ssh是可以连接状态，不要断开连接防止修改出错无法连接服务器。测试新端口是否打开<br>`telnet 127.0.0.1 22</p><h1 id="出现如下显示表示端口正常打开"><a href="#出现如下显示表示端口正常打开" class="headerlink" title="出现如下显示表示端口正常打开"></a>出现如下显示表示端口正常打开</h1><p><code>Trying 127.0.0.1...</code>Connected to 127.0.0.1.<br><code>Escape character is &#39;^]&#39;.</code>SSH-2.0-OpenSSH_8.6<br>使用远程工具新开窗口，连接新端口测试修改是否成功，如有问题马上使用之前的连接进行检查修改。</p><p>（四）回退方案<br>1、挂载iso文件作为yum源<br><code>mount -o loop /mnt/iso/CentOS-7.6-x86_64-DVD-1810.iso /mnt/cdrom2、安装openssh</code>yum install openssh*<br>3、启动ssh<br>`service sshd start<br>4、重新连接ssh，然后从（二）4开始做。</p><h2 id="3-查看CPU信息："><a href="#3-查看CPU信息：" class="headerlink" title="3 查看CPU信息："></a>3 查看CPU信息：</h2><p>内存文件：</p><p>/proc/meminfo</p><p>/proc/cpuinfo</p><p>命令：</p><p>lscpu lsmem</p><p>查看CPU使用最高的进程：</p><p>ps -aux | sort -k3nr | head -n</p><h2 id="4-查看端口："><a href="#4-查看端口：" class="headerlink" title="4 查看端口："></a>4 查看端口：</h2><p>netstat -anp | grep port_number</p><h2 id="5-查看硬盘空间："><a href="#5-查看硬盘空间：" class="headerlink" title="5 查看硬盘空间："></a>5 查看硬盘空间：</h2><p>df -aTh</p><p>du -h -d 1</p><p>作者：赵先生<br>链接：<a href="https://www.zhihu.com/question/483668258/answer/3048322619">https://www.zhihu.com/question/483668258/answer/3048322619</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/07/Basic/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2025/05/07/Basic/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="1-一、文件和目录"><a href="#1-一、文件和目录" class="headerlink" title="1 一、文件和目录"></a>1 一、文件和目录</h2><blockquote><p>查看路径</p></blockquote><h3 id="1-1-pwd"><a href="#1-1-pwd" class="headerlink" title="1.1 pwd"></a>1.1 <strong>pwd</strong></h3><p><strong>显示当前目录的路径</strong></p><h3 id="1-2-which"><a href="#1-2-which" class="headerlink" title="1.2 which"></a>1.2 <strong>which</strong></h3><p>查看命令的可执行文件所在路径， Linux 下，每一条命令其实都对应一个可执行程序，在终端中输入命令，按回车的时候，就是执行了对应的那个程序， which 命令本身对应的程序也存在于 Linux 中。</p><p>总的来说一个命令就是一个可执行程序。</p><blockquote><p><em>浏览和切换目录</em></p></blockquote><h3 id="1-3-ls"><a href="#1-3-ls" class="headerlink" title="1.3 ls"></a>1.3 <strong>ls</strong></h3><p><strong>列出文件和目录，它是 Linux 最常用的命令之一。</strong></p><p>【常用参数】</p><ul><li>-a 显示所有文件和目录包括隐藏的</li><li>-l 显示详细列表</li><li>-h 适合人类阅读的</li><li>-t 按文件最近一次修改时间排序</li><li>-i 显示文件的 inode （ inode 是文件内容的标识）</li></ul><h3 id="1-4-cd"><a href="#1-4-cd" class="headerlink" title="1.4 cd"></a>1.4 <strong>cd</strong></h3><p><strong>cd 是英语 change directory 的缩写，表示切换目录。</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd / --&gt; 跳转到根目录</span><br><span class="line">cd ~ --&gt; 跳转到家目录</span><br><span class="line">cd .. --&gt; 跳转到上级目录</span><br><span class="line">cd ./home --&gt; 跳转到当前目录的home目录下</span><br><span class="line">cd /home/lion --&gt; 跳转到根目录下的home目录下的lion目录</span><br><span class="line">cd --&gt; 不添加任何参数，也是回到家目录</span><br></pre></td></tr></table></figure><p>[注意] 输入cd /ho + 单次 tab 键会自动补全路径 + 两次 tab 键会列出所有可能的目录列表。</p><h3 id="1-5-du"><a href="#1-5-du" class="headerlink" title="1.5 du"></a>1.5 <strong>du</strong></h3><p><strong>列举目录大小信息。</strong></p><p>【常用参数】</p><ul><li>-h 适合人类阅读的；</li><li>-a 同时列举出目录下文件的大小信息；</li><li>-s 只显示总计大小，不显示具体信息。</li></ul><h3 id="1-6-浏览和创建文件"><a href="#1-6-浏览和创建文件" class="headerlink" title="1.6 浏览和创建文件"></a>1.6 浏览和创建文件</h3><h3 id="1-7-cat"><a href="#1-7-cat" class="headerlink" title="1.7 cat"></a>1.7 <strong>cat</strong></h3><p><strong>一次性显示文件所有内容，更适合查看小的文件。</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat cloud-init.log</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>【常用参数】</p><ul><li>-n 显示行号。  </li></ul><h3 id="1-8-less"><a href="#1-8-less" class="headerlink" title="1.8 less"></a>1.8 <strong>less</strong></h3><p><strong>分页显示文件内容，更适合查看大的文件。</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">less cloud-init.log</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>【快捷操作】</p><ul><li>空格键：前进一页（一个屏幕）；</li><li>b 键：后退一页；</li><li>回车键：前进一行；</li><li>y 键：后退一行；</li><li>上下键：回退或前进一行；</li><li>d 键：前进半页；</li><li>u 键：后退半页；</li><li>q 键：停止读取文件，中止 less 命令；</li><li>= 键：显示当前页面的内容是文件中的第几行到第几行以及一些其它关于本页内容的详细信息；</li><li>h 键：显示帮助文档；</li><li>/ 键：进入搜索模式后，按 n 键跳到一个符合项目，按 N 键跳到上一个符合项目，同时也可以输入<a href="https://www.zhihu.com/search?q=%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">正则表达式</a>匹配。</li></ul><h3 id="1-9-head"><a href="#1-9-head" class="headerlink" title="1.9 head"></a>1.9 <strong>head</strong></h3><p><strong>显示文件的开头几行（默认是10行）</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head cloud-init.log</span><br></pre></td></tr></table></figure><p>【参数】</p><ul><li>-n 指定行数 head cloud-init.log -n 2  </li></ul><h3 id="1-10-tail"><a href="#1-10-tail" class="headerlink" title="1.10 tail"></a>1.10 <strong>tail</strong></h3><p><strong>显示文件的结尾几行（默认是10行）</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail cloud-init.log复制代码</span><br></pre></td></tr></table></figure><p>【参数】</p><ul><li>-n 指定行数 tail cloud-init.log -n 2</li><li>-f 会每过1秒检查下文件是否有更新内容，也可以用 -s 参数指定间隔时间 tail -f -s 4 xxx.log</li></ul><h3 id="1-11-touch"><a href="#1-11-touch" class="headerlink" title="1.11 touch"></a>1.11 <strong>touch</strong></h3><p><strong>创建一个文件</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch new_file复制代码</span><br></pre></td></tr></table></figure><h3 id="1-12-mkdir"><a href="#1-12-mkdir" class="headerlink" title="1.12 mkdir"></a>1.12 <strong>mkdir</strong></h3><p><strong>创建一个目录</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir new_folder复制代码</span><br></pre></td></tr></table></figure><p>【常用参数】</p><ul><li>-p 递归的创建目录结构 mkdir -p one/two/three  </li></ul><blockquote><p>文件的复制和移动</p></blockquote><h3 id="1-13-cp"><a href="#1-13-cp" class="headerlink" title="1.13 cp"></a>1.13 <strong>cp</strong></h3><p><strong>拷贝文件和目录</strong></p><p>cp file file_copy —&gt; file 是目标文件，file_copy 是拷贝出来的文件cp file one —&gt; 把 file 文件拷贝到 one 目录下，并且文件名依然为 file</p><p>cp file one/file_copy —&gt; 把 file 文件拷贝到 one 目录下，文件名为file_copy</p><p>cp *.txt folder —&gt; 把当前目录下所有 txt 文件拷贝到 folder 目录下</p><p>【常用参数】</p><ul><li>-r 递归的拷贝，常用来拷贝一整个目录  </li></ul><h3 id="1-14-mv"><a href="#1-14-mv" class="headerlink" title="1.14 mv"></a>1.14 <strong>mv</strong></h3><p><strong>移动（重命名）文件或目录，与cp命令用法相似。</strong></p><p>mv file one —&gt; 将 file 文件移动到 one 目录下</p><p>mv new_folder one —&gt; 将 new_folder 文件夹移动到one目录下mv *.txt folder —&gt; 把当前目录下所有 txt 文件移动到 folder 目录下mv file new_file —&gt; file 文件重命名为 new_file</p><blockquote><p>文件的删除和链接</p></blockquote><h3 id="1-15-rm"><a href="#1-15-rm" class="headerlink" title="1.15 rm"></a>1.15 <strong>rm</strong></h3><p><strong>删除文件和目录，由于 Linux 下没有回收站，一旦删除非常难恢复，因此需要谨慎操作</strong></p><p>rm new_file —&gt; 删除 new_file 文件</p><p>rm f1 f2 f3 —&gt; 同时删除 f1 f2 f3 3个文件</p><p>【常用参数】</p><ul><li>-i 向用户确认是否删除；</li><li>-f 文件强制删除；</li><li>-r 递归删除文件夹，著名的删除操作 rm -rf 。  </li></ul><h3 id="1-16-ln"><a href="#1-16-ln" class="headerlink" title="1.16 ln"></a>1.16 <strong>ln</strong></h3><p><strong>英文 Link 的缩写，表示创建链接。</strong></p><p>学习创建链接之前，首先要理解链接是什么，我们先来看看 Linux 的文件是如何存储的：</p><p>Linux 文件的存储方式分为3个部分，文件名、文件内容以及权限，其中文件名的列表是存储在硬盘的其它地方和文件内容是分开存放的，每个文件名通过 inode 标识绑定到文件内容。</p><p>Linux 下有两种链接类型：硬链接和软链接。</p><h3 id="1-17-硬链接"><a href="#1-17-硬链接" class="headerlink" title="1.17 硬链接"></a>1.17 硬链接</h3><p>使链接的两个文件共享同样文件内容，就是同样的 inode ，一旦文件1和文件2之间有了硬链接，那么修改任何一个文件，修改的都是同一块内容，它的缺点是，只能创建指向文件的硬链接，不能创建指向目录的（其实也可以，但比较复杂）而软链接都可以，<strong>因此软链接使用更加广泛</strong>。</p><p>这个部分暂时不展开。  </p><h2 id="2-二、用户与权限"><a href="#2-二、用户与权限" class="headerlink" title="2 二、用户与权限"></a>2 二、用户与权限</h2><blockquote><p>用户</p></blockquote><p>Linux 是一个多用户的操作系统。在 Linux 中，理论上来说，我们可以创建无数个用户，但是这些用户是被划分到不同的群组里面的，有一个用户，名叫 root ，是一个很特殊的用户，它是超级用户，拥有最高权限。</p><h3 id="2-1-sudo"><a href="#2-1-sudo" class="headerlink" title="2.1 sudo"></a>2.1 <strong>sudo</strong></h3><p><strong>以 root 身份运行命令</strong></p><h3 id="2-2-useradd-passwd"><a href="#2-2-useradd-passwd" class="headerlink" title="2.2 useradd + passwd"></a>2.2 <strong>useradd + passwd</strong></h3><ul><li>useradd 添加新用户</li><li>passwd 修改用户密码</li></ul><p>这两个命令需要 root 用户权限</p><h3 id="2-3-userdel"><a href="#2-3-userdel" class="headerlink" title="2.3 userdel"></a>2.3 <strong>userdel</strong></h3><p><strong>删除用户，需要 root 用户权限</strong></p><h3 id="2-4-su"><a href="#2-4-su" class="headerlink" title="2.4 su"></a>2.4 <strong>su</strong></h3><p><strong>切换用户</strong>，需要 root 用户权限</p><blockquote><p>群组的管理</p></blockquote><p>Linux 中每个用户都属于一个特定的群组，如果你不设置用户的群组，默认会创建一个和它的用户名一样的群组，并且把用户划归到这个群组。</p><h3 id="2-5-groupadd"><a href="#2-5-groupadd" class="headerlink" title="2.5 groupadd"></a>2.5 <strong>groupadd</strong></h3><p><strong>创建群组，</strong>用法和 useradd 类似</p><h3 id="2-6-groupdel"><a href="#2-6-groupdel" class="headerlink" title="2.6 groupdel"></a>2.6 <strong>groupdel</strong></h3><p><strong>删除一个已存在的群组</strong></p><h3 id="2-7-groups"><a href="#2-7-groups" class="headerlink" title="2.7 groups"></a>2.7 <strong>groups</strong></h3><p><strong>查看用户所在群组</strong></p><h3 id="2-8-usermod"><a href="#2-8-usermod" class="headerlink" title="2.8 usermod"></a>2.8 <strong>usermod</strong></h3><p><strong>用于修改用户的账户。</strong></p><p>【常用参数】</p><ul><li>-l 对用户重命名。需要注意的是 /home 中的用户家目录的名字不会改变，需要手动修改。</li><li>-g 修改用户所在的群组，例如 usermod -g friends lion修改 lion 用户的群组为 friends 。</li><li>-G 一次性让用户添加多个群组，例如 usermod -G friends,foo,bar lion 。</li><li>-a -G 会让你离开原先的群组，如果你不想这样做的话，就得再添加 -a 参数，意味着append 追加的意思。  </li></ul><h3 id="2-9-chgrp"><a href="#2-9-chgrp" class="headerlink" title="2.9 chgrp"></a>2.9 <strong>chgrp</strong></h3><p><strong>用于修改文件的群组。</strong></p><h3 id="2-10-chown"><a href="#2-10-chown" class="headerlink" title="2.10 chown"></a>2.10 <strong>chown</strong></h3><p><strong>改变文件的所有者</strong>，需要 root 身份才能运行。</p><p>【常用参数】</p><ul><li>-R 递归设置子目录和子文件， chown -R lion:lion /home/frank 把 frank 文件夹的用户和群组都改为 lion 。</li></ul><blockquote><p>文件权限管理</p></blockquote><h3 id="2-11-chmod"><a href="#2-11-chmod" class="headerlink" title="2.11 chmod"></a>2.11 <strong>chmod</strong></h3><p><strong>修改访问权限。</strong></p><p>【常用参数】</p><ul><li>-R 可以递归地修改文件访问权限，例如 chmod -R 777 /home/lion</li></ul><p>其中 drwxr-xr-x 表示文件或目录的权限。让我们一起来解读它具体代表什么？</p><ul><li>d ：表示目录，就是说这是一个目录，普通文件是 - ，链接是 l 。</li><li>r ：read 表示文件可读。</li><li>w ：write 表示文件可写，一般有写的权限，就有删除的权限。</li><li>x ：execute 表示文件可执行。</li><li><ul><li>：表示没有相应权限。</li></ul></li></ul><p>现在再来理解这句权限 drwxr-xr-x 的意思：</p><ul><li>它是一个文件夹；</li><li>它的所有者具有：读、写、执行权限；</li><li>它的群组用户具有：读、执行的权限，没有写的权限；</li><li>它的其它用户具有：读、执行的权限，没有写的权限。  </li></ul><p>现在理解了权限，我们使用 chmod 来尝试修改权限。chmod 它不需要是 root 用户才能运行的，只要你是此文件所有者，就可以用 chmod 来修改文件的访问权限。</p><p><img src="https://pic1.zhimg.com/80/v2-419fd37f2018837b1ffd75925e24901e_1440w.webp?source=1940ef5c" alt=""></p><p>chmod 640 hello.c</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>6 = 4 + 2 + 0 表示所有者具有 rw 权限</p><p>4 = 4 + 0 + 0 表示群组用户具有 r 权限</p><p>0 = 0 + 0 + 0 表示其它用户没有权限</p><p>对应文字权限为：-rw-r——-</p><h3 id="0-1-用字母来分配权限"><a href="#0-1-用字母来分配权限" class="headerlink" title="0.1 用字母来分配权限"></a>0.1 用字母来分配权限</h3><ul><li>u ：user 的缩写，用户的意思，表示所有者。</li><li>g ：group 的缩写，群组的意思，表示群组用户。</li><li>o ：other 的缩写，其它的意思，表示其它用户。</li><li>a ：all 的缩写，所有的意思，表示所有用户。</li><li><ul><li>：加号，表示添加权限。</li></ul></li><li><ul><li>：减号，表示去除权限。</li></ul></li><li>= ：等于号，表示分配权限。</li></ul><p>chmod u+rx file —&gt; 文件file的所有者增加读和运行的权限</p><p>chmod g+r file —&gt; 文件file的群组用户增加读的权限</p><p>chmod o-r file—&gt; 文件file的其它用户移除读的权限</p><p>chmod g+r file —&gt; 文件file的群组用户增加读的权限，其它用户移除读的权限</p><p>chmod go-r file —&gt; 文件file的群组和其他用户移除读的权限</p><p>chmod +x file —&gt; 文件file的所有用户增加运行的权限</p><p>chmod u=rwx,g=r,o=- file —&gt; 文件file的所有者分配读写和执行的权限，群组其它用户分配读的权限，其他用户没有任何权限</p><h2 id="1-三、查找文件"><a href="#1-三、查找文件" class="headerlink" title="1 三、查找文件"></a>1 三、查找文件</h2><h3 id="1-1-locate"><a href="#1-1-locate" class="headerlink" title="1.1 locate"></a>1.1 <strong>locate</strong></h3><p><strong>搜索包含关键字的所有文件和目录。后接需要查找的文件名，也可以用正则表达式。</strong></p><h3 id="1-2-安装-locate"><a href="#1-2-安装-locate" class="headerlink" title="1.2 安装 locate"></a>1.2 安装 locate</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mlocate --&gt; 安装包updatedb --&gt; 更新数据库复制代码locate file.txtlocate fil*.txt</span><br></pre></td></tr></table></figure><p>[注意] locate 命令会去<a href="https://www.zhihu.com/search?q=%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%BA%93&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">文件数据库</a>中查找命令，而不是全磁盘查找，因此刚创建的文件并不会更新到数据库中，所以无法被查找到，可以执行 updatedb 命令去更新数据库。</p><blockquote><p>find</p></blockquote><p>用于查找文件，它会去遍历你的实际硬盘进行查找，而且它允许我们对每个找到的文件进行后续操作，功能非常强大。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &lt;何处&gt; &lt;何物&gt; &lt;做什么&gt;</span><br></pre></td></tr></table></figure><ul><li>何处：指定在哪个目录查找，此目录的所有子目录也会被查找。</li><li>何物：查找什么，可以根据文件的名字来查找，也可以根据其大小来查找，还可以根据其最近访问时间来查找。</li><li>做什么：找到文件后，可以进行后续处理，如果不指定这个参数， find 命令只会显示找到的文件。  </li></ul><h3 id="1-3-根据文件名查找"><a href="#1-3-根据文件名查找" class="headerlink" title="1.3 根据文件名查找"></a>1.3 <strong>根据文件名查找</strong></h3><p>find -name “file.txt” —&gt; 当前目录以及子目录下通过名称查找文件</p><p>find . -name “syslog” —&gt; 当前目录以及子目录下通过名称查找文件</p><p>find / -name “syslog” —&gt; 整个硬盘下查找syslog</p><p>find /var/log -name “syslog” —&gt; 在指定的目录/var/log下查找syslog文件find /var/log -name “syslog*” —&gt; 查找syslog1、syslog2 … 等文件，通配符表示所有</p><p>find /var/log -name “<em>syslog</em>“ —&gt; 查找包含syslog的文件</p><p>[注意] find 命令只会查找完全符合 “何物” 字符串的文件，而 locate 会查找所有包含关键字的文件。</p><h3 id="1-4-根据文件大小查找"><a href="#1-4-根据文件大小查找" class="headerlink" title="1.4 根据文件大小查找"></a>1.4 <strong>根据文件大小查找</strong></h3><p>find /var -size +10M —&gt; /var 目录下查找文件大小超过 10M 的文件</p><p>find /var -size -50k —&gt; /var 目录下查找文件大小小于 50k 的文件</p><p>find /var -size +1G —&gt; /var 目录下查找文件大小查过 1G 的文件</p><p>find /var -size 1M —&gt; /var 目录下查找文件大小等于 1M 的文件</p><h3 id="1-5-根据文件最近访问时间查找"><a href="#1-5-根据文件最近访问时间查找" class="headerlink" title="1.5 根据文件最近访问时间查找"></a>1.5 <strong>根据文件最近访问时间查找</strong></h3><p>find -name “*.txt” -atime -7</p><p>—&gt; 近 7天内访问过的.txt结尾的文件</p><h3 id="1-6-仅查找目录或文件-根据类型查找"><a href="#1-6-仅查找目录或文件-根据类型查找" class="headerlink" title="1.6 仅查找目录或文件,根据类型查找"></a>1.6 <strong>仅查找目录或文件,根据类型查找</strong></h3><p>find . -name “file” -type f</p><p>—&gt; 只查找当前目录下的file文件</p><p>find . -name “file” -type d</p><p>—&gt; 只查找当前目录下的file目录</p><blockquote><p>软件仓库</p></blockquote><p>Linux 下软件是以包的形式存在，一个软件包其实就是软件的所有文件的压缩包，是二进制的形式，包含了安装软件的所有指令。Red Hat 家族的软件包后缀名一般为 .rpm ，Debian 家族的软件包后缀是 .deb 。</p><p>Linux 的包都存在一个仓库，叫做软件仓库，它可以使用 yum 来管理软件包， yum 是 CentOS 中默认的包管理工具，适用于 Red Hat 一族。可以理解成 Node.js 的 npm 。</p><blockquote><p>yum 常用命令</p></blockquote><ul><li>yum update | yum upgrade 更新软件包</li><li>yum search xxx 搜索相应的软件包</li><li>yum install xxx 安装软件包</li><li>yum remove xxx 删除软件包</li></ul><h2 id="2-四、文本操作"><a href="#2-四、文本操作" class="headerlink" title="2 四、文本操作"></a>2 四、文本操作</h2><blockquote><p>grep</p></blockquote><p><strong>全局搜索一个正则表达式，并且打印到屏幕。简单来说就是，在文件中查找关键字，并显示关键字所在行。</strong></p><h3 id="2-1-基础语法"><a href="#2-1-基础语法" class="headerlink" title="2.1 基础语法"></a>2.1 基础语法</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep text file # text代表要搜索的文本，file代表供搜索的文件</span><br></pre></td></tr></table></figure><h3 id="2-2-常用参数"><a href="#2-2-常用参数" class="headerlink" title="2.2 常用参数"></a>2.2 常用参数</h3><ul><li>-i 忽略大小写， grep -i path /etc/profile</li><li>-n 显示行号，grep -n path /etc/profile</li><li>-v 只显示搜索文本不在的那些行，grep -v path /etc/profile</li><li>-r 递归查找， grep -r hello /etc ，Linux 中还有一个 rgrep 命令，作用相当于 grep -r</li></ul><h3 id="2-3-sort"><a href="#2-3-sort" class="headerlink" title="2.3 sort"></a>2.3 sort</h3><p><strong>对文件的行进行排序。</strong></p><h3 id="2-4-基础语法"><a href="#2-4-基础语法" class="headerlink" title="2.4 基础语法"></a>2.4 基础语法</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort name.txt # 对name.txt文件进行排序</span><br></pre></td></tr></table></figure><h3 id="2-5-实例用法"><a href="#2-5-实例用法" class="headerlink" title="2.5 实例用法"></a>2.5 实例用法</h3><p>为了演示方便，我们首先创建一个文件 name.txt ，放入以下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChristopherShawnTedRockNoahZacharyBella</span><br></pre></td></tr></table></figure><p>执行 sort name.txt 命令，会对文本内容进行排序。</p><h3 id="2-6-常用参数"><a href="#2-6-常用参数" class="headerlink" title="2.6 常用参数"></a>2.6 常用参数</h3><ul><li>-o 将排序后的文件写入新文件， sort -o name_sorted.txt name.txt ；</li><li>-r 倒序排序， sort -r name.txt ；</li><li>-R 随机排序， sort -R name.txt ；</li><li>-n 对数字进行排序，默认是把数字识别成字符串的，因此 138 会排在 25 前面，如果添加了 -n 数字排序的话，则 25 会在 138 前面。</li></ul><h3 id="2-7-wc"><a href="#2-7-wc" class="headerlink" title="2.7 wc"></a>2.7 wc</h3><p><strong>word count 的缩写，用于文件的统计。它可以统计单词数目、行数、字符数，字节数等。</strong></p><h3 id="2-8-基础语法"><a href="#2-8-基础语法" class="headerlink" title="2.8 基础语法"></a>2.8 基础语法</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc name.txt # 统计name.txt</span><br></pre></td></tr></table></figure><h3 id="2-9-实例用法"><a href="#2-9-实例用法" class="headerlink" title="2.9 实例用法"></a>2.9 实例用法</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lion ~]# wc name.txt 13 13 91 name.txt</span><br></pre></td></tr></table></figure><ul><li>第一个13，表示行数；</li><li>第二个13，表示单词数；</li><li>第三个91，表示字节数。</li></ul><h3 id="2-10-常用参数"><a href="#2-10-常用参数" class="headerlink" title="2.10 常用参数"></a>2.10 常用参数</h3><ul><li>-l 只统计行数， wc -l name.txt ；</li><li>-w 只统计单词数， wc -w name.txt ；</li><li>-c 只统计字节数， wc -c name.txt ；</li><li>-m 只统计字符数， wc -m name.txt 。  </li></ul><h3 id="2-11-uniq"><a href="#2-11-uniq" class="headerlink" title="2.11 uniq"></a>2.11 uniq</h3><p><strong>删除文件中的重复内容。</strong></p><h3 id="2-12-基础语法"><a href="#2-12-基础语法" class="headerlink" title="2.12 基础语法"></a>2.12 基础语法</h3><p>uniq name.txt # 去除name.txt重复的行数，并打印到屏幕上</p><p>【注意】它只能去除连续重复的行数。</p><h3 id="2-13-常用参数"><a href="#2-13-常用参数" class="headerlink" title="2.13 常用参数"></a>2.13 常用参数</h3><ul><li>-c 统计重复行数， uniq -c name.txt ；</li><li>-d 只显示重复的行数， uniq -d name.txt 。  </li></ul><h3 id="2-14-cut"><a href="#2-14-cut" class="headerlink" title="2.14 cut"></a>2.14 <strong>cut</strong></h3><p><strong>剪切文件的一部分内容。</strong></p><h3 id="2-15-基础语法"><a href="#2-15-基础语法" class="headerlink" title="2.15 基础语法"></a>2.15 基础语法</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -c 2-4 name.txt # 剪切每一行第二到第四个字符</span><br></pre></td></tr></table></figure><h3 id="2-16-常用参数"><a href="#2-16-常用参数" class="headerlink" title="2.16 常用参数"></a>2.16 常用参数</h3><ul><li>-d 用于指定用什么分隔符（比如逗号、分号、双引号等等） cut -d , name.txt ；</li><li>-f 表示剪切下用分隔符分割的哪一块或哪几块区域， cut -d , -f 1 name.txt 。  </li></ul><h2 id="3-五、重定向-管道-流"><a href="#3-五、重定向-管道-流" class="headerlink" title="3 五、重定向 管道 流"></a>3 五、重定向 管道 流</h2><p>在 Linux 中一个命令的去向可以有3个地方：终端、文件、作为另外一个命令的入参。</p><p>命令一般都是通过键盘输入，然后输出到终端、文件等地方，它的标准用语是 stdin 、 stdout 以及 stderr 。</p><ul><li>标准输入 stdin ，终端接收键盘输入的命令，会产生两种输出；</li><li>标准输出 stdout ，终端输出的信息（不包含错误信息）；</li><li>标准错误输出 stderr ，终端输出的错误信息。</li></ul><h3 id="3-1-重定向"><a href="#3-1-重定向" class="headerlink" title="3.1 重定向"></a>3.1 重定向</h3><p>把本来要显示在终端的命令结果，输送到别的地方（到文件中或者作为其他命令的输入）。</p><h3 id="3-2-输出重定向-gt"><a href="#3-2-输出重定向-gt" class="headerlink" title="3.2 输出重定向 &gt;"></a>3.2 <strong>输出重定向 &gt;</strong></h3><blockquote><p>表示重定向到新的文件， cut -d , -f 1 notes.csv &gt; name.csv ，它表示通过逗号剪切notes.csv 文件（剪切完有3个部分）获取第一个部分，重定向到 name.csv 文件。</p></blockquote><p>我们来看一个具体示例，学习它的使用，假设我们有一个文件 notes.csv ，文件内容如下：</p><p>Mark1,951/100,很不错1Mark2,952/100,很不错2Mark3,</p><p>953/100,很不错3Mark4,954/100,很不错4Mark5,955/100,很不错5Mark6,956/100,很不错6</p><p>执行命令：cut -d , -f 1 notes.csv &gt; name.csv 最后输出如下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mark1Mark2Mark3Mark4Mark5Mark6</span><br></pre></td></tr></table></figure><p>【注意】使用 &gt; 要注意，如果输出的文件不存在它会新建一个，如果输出的文件已经存在，则会覆盖。因此执行这个操作要非常小心，以免覆盖其它重要文件。</p><h3 id="3-3-输出重定向-gt-gt"><a href="#3-3-输出重定向-gt-gt" class="headerlink" title="3.3 输出重定向 &gt;&gt;"></a>3.3 <strong>输出重定向 &gt;&gt;</strong></h3><p>表示重定向到文件末尾，因此它不会像 &gt; 命令这么危险，它是追加到文件的末尾（当然如果文件不存在，也会被创建）。</p><p>再次执行 cut -d , -f 1 notes.csv &gt;&gt; name.csv ，则会把名字追加到 name.csv 里面。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mark1Mark2Mark3Mark4Mark5Mark6Mark1Mark2Mark3Mark4Mark5Mark6</span><br></pre></td></tr></table></figure><p>我们平时读的 log 日志文件其实都是用这个命令输出的。</p><h3 id="3-4-输出重定向-2-gt"><a href="#3-4-输出重定向-2-gt" class="headerlink" title="3.4 输出重定向 2&gt;"></a>3.4 <strong>输出重定向 2&gt;</strong></h3><p>标准错误输出</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat not_exist_file.csv &gt; res.txt 2&gt; errors.log</span><br></pre></td></tr></table></figure><ul><li>当我们 cat 一个文件时，会把文件内容打印到屏幕上，这个是标准输出；</li><li>当使用了 &gt; res.txt 时，则不会打印到屏幕，会把标准输出写入文件 res.txt 文件中；</li><li>2&gt; errors.log 当发生错误时会写入 errors.log 文件中。  </li></ul><h3 id="3-5-输出重定向-2-gt-gt"><a href="#3-5-输出重定向-2-gt-gt" class="headerlink" title="3.5 输出重定向 2&gt;&gt;"></a>3.5 <strong>输出重定向 2&gt;&gt;</strong></h3><p>标准错误输出（追加到文件末尾）同 &gt;&gt; 相似。</p><h3 id="3-6-输入重定向-lt"><a href="#3-6-输入重定向-lt" class="headerlink" title="3.6 输入重定向 &lt;"></a>3.6 <strong>输入重定向 &lt;</strong></h3><p>&lt; 符号用于指定命令的输入。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &lt; name.csv # 指定命令的输入为 name.csv</span><br></pre></td></tr></table></figure><p>虽然它的运行结果与 cat name.csv 一样，但是它们的原理却完全不同。</p><ul><li>cat name.csv 表示 cat 命令接收的输入是 notes.csv 文件名，那么要先打开这个文件，然后打印出文件内容。</li><li>cat &lt; name.csv 表示 cat 命令接收的输入直接是 notes.csv 这个文件的内容， cat命令只负责将其内容打印，打开文件并将文件内容传递给 cat 命令的工作则交给终端完成。  </li></ul><h3 id="3-7-输入重定向-lt-lt"><a href="#3-7-输入重定向-lt-lt" class="headerlink" title="3.7 输入重定向 &lt;&lt;"></a>3.7 <strong>输入重定向 &lt;&lt;</strong></h3><p>将键盘的输入重定向为某个命令的输入。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort -n &lt;&lt; END # 输入这个命令之后，按下回车，终端就进入键盘输入模式，其中END为结束命令（这个可以自定义）wc -m &lt;&lt; END # 统计输入的单词复</span><br></pre></td></tr></table></figure><h3 id="3-8-管道"><a href="#3-8-管道" class="headerlink" title="3.8 管道 |"></a>3.8 管道 |</h3><p>把两个命令连起来使用，一个命令的输出作为另外一个命令的输入，英文是 pipeline ，可以想象一个个水管连接起来，管道算是重定向流的一种。</p><p>举几个实际用法案例：</p><p>cut -d , -f 1 name.csv | sort &gt; sorted_name.txt</p><h1 id="第一步获取到的-name-列表，通过管道符再进行排序，最后输出到sorted-name-txt"><a href="#第一步获取到的-name-列表，通过管道符再进行排序，最后输出到sorted-name-txt" class="headerlink" title="第一步获取到的 name 列表，通过管道符再进行排序，最后输出到sorted_name.txt"></a>第一步获取到的 name 列表，通过管道符再进行排序，最后输出到sorted_name.txt</h1><p>du | sort -nr | head</p><h1 id="du-表示列举目录大小信息-sort-进行排序-n-表示按数字排序，-r-表示倒序-head-前10行文件"><a href="#du-表示列举目录大小信息-sort-进行排序-n-表示按数字排序，-r-表示倒序-head-前10行文件" class="headerlink" title="du 表示列举目录大小信息# sort 进行排序,-n 表示按数字排序，-r 表示倒序# head 前10行文件"></a>du 表示列举目录大小信息# sort 进行排序,-n 表示按数字排序，-r 表示倒序# head 前10行文件</h1><p>grep log -Ir /var/log | cut -d : -f 1 | sort | uniq</p><h1 id="grep-log-Ir-var-log-表示在log文件夹下搜索-var-log-文本，-r-表示递归，-I-用于排除二进制文件-cut-d-f-1-表示通过冒号进行剪切，获取剪切的第一部分-sort-进行排序-uniq-进行去重复制代码"><a href="#grep-log-Ir-var-log-表示在log文件夹下搜索-var-log-文本，-r-表示递归，-I-用于排除二进制文件-cut-d-f-1-表示通过冒号进行剪切，获取剪切的第一部分-sort-进行排序-uniq-进行去重复制代码" class="headerlink" title="grep log -Ir /var/log 表示在log文件夹下搜索 /var/log 文本，-r 表示递归，-I 用于排除二进制文件# cut -d : -f 1 表示通过冒号进行剪切，获取剪切的第一部分# sort 进行排序# uniq 进行去重复制代码"></a>grep log -Ir /var/log 表示在log文件夹下搜索 /var/log 文本，-r 表示递归，-I 用于排除二进制文件# cut -d : -f 1 表示通过冒号进行剪切，获取剪切的第一部分# sort 进行排序# uniq 进行去重复制代码</h1><h2 id="1-六、查看进程"><a href="#1-六、查看进程" class="headerlink" title="1 六、查看进程"></a>1 六、查看进程</h2><p>在 Windows 中通过 Ctrl + Alt + Delete 快捷键查看软件进程。</p><h3 id="1-1-w"><a href="#1-1-w" class="headerlink" title="1.1 w"></a>1.1 <strong>w</strong></h3><p><strong>帮助我们快速了解系统中目前有哪些用户登录着，以及他们在干什么。</strong></p><h3 id="1-2-ps"><a href="#1-2-ps" class="headerlink" title="1.2 ps"></a>1.2 <strong>ps</strong></h3><p><strong>用于显示当前系统中的进程， ps 命令显示的进程列表不会随时间而更新，是静态的，是运行 ps 命令那个时刻的状态或者说是一个进程快照。</strong></p><h3 id="1-3-常用参数"><a href="#1-3-常用参数" class="headerlink" title="1.3 常用参数"></a>1.3 常用参数</h3><ul><li>-ef 列出所有进程;</li><li>-efH 以乔木状列举出所有进程;</li><li>-u 列出此用户运行的进程;</li><li>-aux 通过 CPU 和内存使用来过滤进程 ps -aux | less ;</li><li>-aux —sort -pcpu 按 CPU 使用降序排列， -aux —sort -pmem 表示按内存使用降序排列;</li><li>-axjf 以树形结构显示进程， ps -axjf 它和 pstree 效果类似。  </li></ul><h3 id="1-4-top"><a href="#1-4-top" class="headerlink" title="1.4 top"></a>1.4 top</h3><p><strong>获取进程的动态列表。</strong></p><h3 id="1-5-kill"><a href="#1-5-kill" class="headerlink" title="1.5 kill"></a>1.5 <strong>kill</strong></h3><p><strong>结束一个进程， kill + PID 。</strong></p><h2 id="2-七、管理进程"><a href="#2-七、管理进程" class="headerlink" title="2 七、管理进程"></a>2 七、管理进程</h2><h3 id="2-1-进程状态"><a href="#2-1-进程状态" class="headerlink" title="2.1 进程状态"></a>2.1 进程状态</h3><p>主要是切换进程的状态。我们先了解下 Linux 下进程的五种状态：</p><ol><li>状态码 R ：表示正在运行的状态；</li><li>状态码 S ：表示中断（休眠中，受阻，当某个条件形成后或接受到信号时，则脱离该状态）；</li><li>状态码 D ：表示不可中断（进程不响应系统异步信号，即使用kill命令也不能使其中断）；</li><li>状态码 Z ：表示僵死（进程已终止，但进程描述符依然存在，直到父进程调用 wait4()<a href="https://www.zhihu.com/search?q=%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">系统函数</a>后将进程释放）；</li><li>状态码 T ：表示停止（进程收到 SIGSTOP 、 SIGSTP 、 SIGTIN 、 SIGTOU 等停止信号后停止运行）。  </li></ol><h3 id="2-2-前台进程-amp-后台进程"><a href="#2-2-前台进程-amp-后台进程" class="headerlink" title="2.2 前台进程 &amp; 后台进程"></a>2.2 前台进程 &amp; 后台进程</h3><p>默认情况下，用户创建的进程都是前台进程，前台进程从键盘读取数据，并把处理结果输出到显示器。例如运行 top 命令，这就是一个一直运行的前台进程。</p><p>后台进程的优点是不必等待程序运行结束，就可以输入其它命令。在需要执行的命令后面添加&amp; 符号，就表示启动一个后台进程。</p><h3 id="2-3-amp"><a href="#2-3-amp" class="headerlink" title="2.3 &amp;"></a>2.3 &amp;</h3><p>启动后台进程，它的缺点是后台进程与终端相关联，一旦关闭终端，进程就自动结束了。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp name.csv name-copy.csv &amp;</span><br></pre></td></tr></table></figure><h3 id="2-4-nohup"><a href="#2-4-nohup" class="headerlink" title="2.4 nohup"></a>2.4 nohup</h3><p>使进程不受挂断（关闭终端等动作）的影响。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup cp name.csv name-copy.csv</span><br></pre></td></tr></table></figure><p>nohup 命令也可以和 &amp; 结合使用。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup cp name.csv name-copy.csv &amp;</span><br></pre></td></tr></table></figure><h3 id="2-5-bg"><a href="#2-5-bg" class="headerlink" title="2.5 bg"></a>2.5 bg</h3><p>使一个”后台暂停运行”的进程，状态改为”后台运行”。</p><h3 id="2-6-jobs"><a href="#2-6-jobs" class="headerlink" title="2.6 jobs"></a>2.6 jobs</h3><p>显示当前终端后台进程状态。</p><h3 id="2-7-fg"><a href="#2-7-fg" class="headerlink" title="2.7 fg"></a>2.7 fg</h3><p>fg 使进程转为前台运行，用法和 bg 命令类似。</p><p>我们用一张图来表示前后台进程切换：</p><p><img src="https://pic1.zhimg.com/80/v2-fda7a2872cecb93215a9b88f9ae71a29_1440w.webp?source=1940ef5c" alt=""></p><p>我们可以使程序在后台运行，成为后台进程，这样在当前终端中我们就可以做其他事情了，而不必等待此进程运行结束。</p><h2 id="3-八、文件压缩解压"><a href="#3-八、文件压缩解压" class="headerlink" title="3 八、文件压缩解压"></a>3 八、文件压缩解压</h2><ul><li>打包：是将多个文件变成一个总的文件，它的学名叫存档、归档。</li><li>压缩：是将一个大文件（通常指归档）压缩变成一个小文件。  </li></ul><p>我们常常使用 tar 将多个文件归档为一个总的文件，称为 archive 。然后用 gzip 或 bzip2 命令将 archive 压缩为更小的文件。</p><h3 id="3-1-tar"><a href="#3-1-tar" class="headerlink" title="3.1 tar"></a>3.1 <strong>tar</strong></h3><p><strong>创建一个 tar 归档。</strong></p><h3 id="3-2-基础用法"><a href="#3-2-基础用法" class="headerlink" title="3.2 基础用法"></a>3.2 基础用法</h3><p>tar -cvf sort.tar sort/</p><h1 id="将sort文件夹归档为sort-tar"><a href="#将sort文件夹归档为sort-tar" class="headerlink" title="将sort文件夹归档为sort.tar"></a>将sort文件夹归档为sort.tar</h1><p>tar -cvf archive.tar file1 file2 file3</p><h1 id="将-file1-file2-file3-归档为archive-tar复制代码"><a href="#将-file1-file2-file3-归档为archive-tar复制代码" class="headerlink" title="将 file1 file2 file3 归档为archive.tar复制代码"></a>将 file1 file2 file3 归档为archive.tar复制代码</h1><h3 id="0-1-常用参数"><a href="#0-1-常用参数" class="headerlink" title="0.1 常用参数"></a>0.1 常用参数</h3><ul><li>-cvf 表示 create（创建）+ verbose（细节）+ file（文件），创建归档文件并显示操作细节；</li><li>-tf 显示归档里的内容，并不解开归档；</li><li>-rvf 追加文件到归档， tar -rvf archive.tar file.txt ；</li><li>-xvf 解开归档， tar -xvf archive.tar 。</li></ul><h3 id="0-2-gzip-gunzip"><a href="#0-2-gzip-gunzip" class="headerlink" title="0.2 gzip / gunzip"></a>0.2 gzip / gunzip</h3><p>“压缩/解压”归档，默认用 gzip 命令，压缩后的<a href="https://www.zhihu.com/search?q=%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">文件后缀名</a>为 .tar.gz 。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip archive.tar # 压缩gunzip archive.tar.gz # 解压</span><br></pre></td></tr></table></figure><h3 id="0-3-tar-归档-压缩"><a href="#0-3-tar-归档-压缩" class="headerlink" title="0.3 tar 归档+压缩"></a>0.3 tar 归档+压缩</h3><p>可以用 tar 命令同时完成归档和压缩的操作，就是给 tar 命令多加一个选项参数，使之完成归档操作后，还是调用 gzip 或 bzip2 命令来完成压缩操作。</p><p>tar -zcvf archive.tar.gz archive/ # 将archive文件夹归档并压缩</p><p>tar -zxvf archive.tar.gz # 将archive.tar.gz归档压缩文件解压</p><h3 id="0-4-zcat、zless、zmore"><a href="#0-4-zcat、zless、zmore" class="headerlink" title="0.4 zcat、zless、zmore"></a>0.4 zcat、zless、zmore</h3><p>之前讲过使用 cat less more 可以查看文件内容，但是压缩文件的内容是不能使用这些命令进行查看的，而要使用 zcat、zless、zmore 进行查看。</p><p>zcat archive.tar.gz</p><h3 id="0-5-zip-unzip"><a href="#0-5-zip-unzip" class="headerlink" title="0.5 zip/unzip"></a>0.5 zip/unzip</h3><p>“压缩/解压” zip 文件（ zip 压缩文件一般来自 windows 操作系统）。</p><h3 id="0-6-命令安装"><a href="#0-6-命令安装" class="headerlink" title="0.6 命令安装"></a>0.6 命令安装</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Red Hat 一族中的安装方式yum install zip yum install unzip 复制代码</span><br></pre></td></tr></table></figure><h3 id="0-7-基础用法"><a href="#0-7-基础用法" class="headerlink" title="0.7 基础用法"></a>0.7 基础用法</h3><p>unzip archive.zip</p><h1 id="解压-zip-文件"><a href="#解压-zip-文件" class="headerlink" title="解压 .zip 文件"></a>解压 .zip 文件</h1><p>unzip -l archive.zip</p><h1 id="不解开-zip-文件，只看其中内容"><a href="#不解开-zip-文件，只看其中内容" class="headerlink" title="不解开 .zip 文件，只看其中内容"></a>不解开 .zip 文件，只看其中内容</h1><p>zip -r sort.zip sort/</p><h1 id="将sort文件夹压缩为-sort-zip，其中-r表示递归"><a href="#将sort文件夹压缩为-sort-zip，其中-r表示递归" class="headerlink" title="将sort文件夹压缩为 sort.zip，其中-r表示递归"></a>将sort文件夹压缩为 sort.zip，其中-r表示递归</h1><h3 id="0-1-编译安装"><a href="#0-1-编译安装" class="headerlink" title="0.1 编译安装"></a>0.1 编译安装</h3><p>简单来说，编译就是将程序的源代码转换成可执行文件的过程。大多数 Linux 的程序都是开放源码的，可以编译成适合我们的电脑和操纵系统属性的可执行文件。</p><p>基本步骤如下：</p><ol><li>下载源代码</li><li>解压压缩包</li><li>配置</li><li>编译</li><li>安装  </li></ol><h3 id="0-2-实际案例"><a href="#0-2-实际案例" class="headerlink" title="0.2 实际案例"></a>0.2 实际案例</h3><h3 id="0-3-1、下载"><a href="#0-3-1、下载" class="headerlink" title="0.3 1、下载"></a>0.3 1、下载</h3><p>我们来编译安装 htop 软件，首先在它的官网下载源码：<strong><a href="https://link.zhihu.com/?target=http%3A//bintray.com/htop/source">http://bintray.com/htop/source</a>…</strong>[1]</p><p>下载好的源码在本机电脑上使用如下命令同步到服务器上：</p><p>scp 文件名 用户名@服务器ip:目标路径</p><p>scp ~/Desktop/htop-3.0.0.tar.gz root@121.42.11.34:.</p><p>也可以使用 wegt 进行下载：</p><p>wegt+下载地址</p><p>wegt <a href="https://link.zhihu.com/?target=https%3A//bintray.com/htop/source/download_file%3Ffile_path%3Dhtop-3.0.0.tar.gz">https://bintray.com/htop/source/download_file?file_path=htop-3.0.0.tar.gz</a></p><h3 id="0-4-2、解压文件"><a href="#0-4-2、解压文件" class="headerlink" title="0.4 2、解压文件"></a>0.4 2、解压文件</h3><p>tar -zxvf htop-3.0.0.tar.gz</p><h1 id="解压cd-htop-3-0-0-进入目录"><a href="#解压cd-htop-3-0-0-进入目录" class="headerlink" title="解压cd htop-3.0.0 # 进入目录"></a>解压cd htop-3.0.0 # 进入目录</h1><h3 id="0-1-3、配置"><a href="#0-1-3、配置" class="headerlink" title="0.1 3、配置"></a>0.1 3、配置</h3><p>执行 ./configure ，它会分析你的电脑去确认编译所需的工具是否都已经安装了。</p><h3 id="0-2-4、编译"><a href="#0-2-4、编译" class="headerlink" title="0.2 4、编译"></a>0.2 4、编译</h3><p>执行 make 命令</p><h3 id="0-3-5、安装"><a href="#0-3-5、安装" class="headerlink" title="0.3 5、安装"></a>0.3 5、安装</h3><p>执行 make install 命令，安装完成后执行 ls /usr/local/bin/ 查看是否有 htop 命令。如果有就可以执行 htop 命令查看系统进程了。</p><h2 id="1-九、网络"><a href="#1-九、网络" class="headerlink" title="1 九、网络"></a>1 九、网络</h2><h3 id="1-1-ifconfig"><a href="#1-1-ifconfig" class="headerlink" title="1.1 ifconfig"></a>1.1 <strong>ifconfig</strong></h3><p><strong>查看 ip 网络相关信息，如果命令不存在的话， 执行命令 yum install net-tools 安装。</strong></p><p>参数解析：</p><ul><li><p>eth0 对应有线连接（对应你的有线网卡），就是用网线来连接的上网。eth 是 Ethernet 的缩写，表示”<a href="https://www.zhihu.com/search?q=%E4%BB%A5%E5%A4%AA%E7%BD%91&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">以太网</a>“。有些电脑可能同时有好几条网线连着，例如服务器，那么除了eht0 ，你还会看到 eth1 、 eth2 等。  </p></li><li><p>lo 表示本地回环（ Local Loopback 的缩写，对应一个<a href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">虚拟网卡</a>）可以看到它的 ip 地址是 127.0.0.1 。每台电脑都应该有这个接口，因为它对应着”连向自己的链接”。这也是被称之为”本地回环”的原因。所有经由这个接口发送的东西都会回到你自己的电脑。看起来好像并没有什么用，但有时为了某些缘故，我们需要连接自己。例如用来测试一个网络程序，但又不想让局域网或外网的用户查看，只能在此台主机上运行和查看所有的网络接口。例如在我们启动一个前端工程时，在浏览器输入 127.0.0.1:3000 启动项目就能查看到自己的 web 网站，并且它只有你能看到。  </p></li><li><p>wlan0 表示无线局域网</p></li></ul><h3 id="1-2-host"><a href="#1-2-host" class="headerlink" title="1.2 host"></a>1.2 <strong>host</strong></h3><p><strong>ip 地址和主机名的互相转换。</strong></p><h3 id="1-3-ssh-连接远程服务器"><a href="#1-3-ssh-连接远程服务器" class="headerlink" title="1.3 ssh 连接远程服务器"></a>1.3 <strong>ssh 连接远程服务器</strong></h3><p><strong>通过<a href="https://www.zhihu.com/search?q=%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">非对称加密</a>以及对称加密的方式（同 HTTPS 安全连接原理相似）连接到远端服务器。</strong></p><h3 id="1-4-h"><a href="#1-4-h" class="headerlink" title="1.4 *h"></a>1.4 <em>*</em>h</h3><p>config 文件可以<em>*</em>h ，方便批量管理多个 ssh 连接。</p><p>配置文件分为以下几种：</p><ul><li>全局 ssh 服务端的配置：/etc/ssh/sshd_config ；</li><li>全局 ssh 客户端的配置：/etc/ssh/ssh_config（很少修改）；</li><li>当前用户 ssh 客户端的<em>*</em>h/config 。</li></ul><p><img src="https://pica.zhimg.com/80/v2-6822a5b5868d9e08fb6d9fbae94b6661_1440w.webp?source=1940ef5c" alt=""></p><p>配置当前用户的 config ：</p><h1 id="创建config"><a href="#创建config" class="headerlink" title="创建config"></a>创建config</h1><p>vim ~/.ssh/config</p><h1 id="填写一下内容"><a href="#填写一下内容" class="headerlink" title="填写一下内容"></a>填写一下内容</h1><p>Host lion # 别名 HostName 172.x.x.x # ip 地址 Port 22 # 端口 User root # 用户</p><p>这样配置完成后，下次登录时，可以这样登录 ssh lion 会自动识别为 root 用户。</p><p>[注意] 这段配置不是在服务器上，而是你自己的机器上，它仅仅是设置了一个别名。</p><h3 id="0-1-wget"><a href="#0-1-wget" class="headerlink" title="0.1 wget"></a>0.1 wget</h3><p>可以使我们直接从终端控制台下载文件，只需要给出文件的HTTP或FTP地址。</p><h2 id="1-十-备份"><a href="#1-十-备份" class="headerlink" title="1 十 备份"></a>1 十 备份</h2><h3 id="1-1-scp"><a href="#1-1-scp" class="headerlink" title="1.1 scp"></a>1.1 scp</h3><p><strong>它是 Secure Copy 的缩写，表示安全拷贝。scp 可以使我们通过网络，把文件从一台电脑拷贝到另一台电脑。</strong></p><p>scp 是基于 ssh 的原理来运作的， ssh 会在两台通过网络连接的电脑之间创建一条安全通信的管道， scp 就利用这条管道安全地拷贝文件。</p><p>scp source_file destination_file</p><h1 id="source-file-表示源文件，destination-file-表示目标文件"><a href="#source-file-表示源文件，destination-file-表示目标文件" class="headerlink" title="source_file 表示源文件，destination_file 表示目标文件"></a>source_file 表示源文件，destination_file 表示目标文件</h1><p>其中 source_file 和 destination_file 都可以这样表示：user@ip:file_name ， user 是登录名， ip 是域名或 ip 地址。file_name 是文件路径。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp root@192.168.1.5:/root/file.txt file.txt # 表示把远程电脑上的 file.txt 文件拷贝到本机</span><br><span class="line">scp file.txt root@192.168.1.5:/root # 表示把我的电脑中当前文件夹下的 file.txt 文件拷贝到远程电脑</span><br></pre></td></tr></table></figure><h3 id="0-1-rsync"><a href="#0-1-rsync" class="headerlink" title="0.1 rsync"></a>0.1 rsync</h3><p>rsync 命令主要用于远程同步文件。它可以同步两个目录，不管它们是否处于同一台电脑。它应该是最常用于”<a href="https://www.zhihu.com/search?q=%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">增量备份</a>“的命令了。它就是智能版的 scp 命令。</p><h3 id="0-2-软件安装"><a href="#0-2-软件安装" class="headerlink" title="0.2 软件安装"></a>0.2 软件安装</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install rsync复制代码</span><br></pre></td></tr></table></figure><h3 id="0-3-基础用法"><a href="#0-3-基础用法" class="headerlink" title="0.3 基础用法"></a>0.3 基础用法</h3><p>rsync -arv Images/ backups/</p><h1 id="将Images-目录下的所有文件备份到-backups-目录下"><a href="#将Images-目录下的所有文件备份到-backups-目录下" class="headerlink" title="将Images 目录下的所有文件备份到 backups 目录下"></a>将Images 目录下的所有文件备份到 backups 目录下</h1><p>rsync -arv Images/ root@192.x.x.x:backups/</p><h1 id="同步到服务器的backups目录下"><a href="#同步到服务器的backups目录下" class="headerlink" title="同步到服务器的backups目录下"></a>同步到服务器的backups目录下</h1><h3 id="0-1-常用参数-1"><a href="#0-1-常用参数-1" class="headerlink" title="0.1 常用参数"></a>0.1 常用参数</h3><ul><li>-a 保留文件的所有信息，包括权限，修改日期等；</li><li>-r 递归调用，表示子目录的所有文件也都包括；</li><li>-v 冗余模式，输出详细操作信息。</li></ul><p>默认地， rsync 在同步时并不会删除目标目录的文件，例如你在源目录中删除一个文件，但是用 rsync 同步时，它并不会删除同步目录中的相同文件。如果向删除也可以这么做：rsync -arv —delete Images/ backups/ 。</p><h2 id="1-十一-系统"><a href="#1-十一-系统" class="headerlink" title="1 十一 系统"></a>1 十一 系统</h2><h3 id="1-1-halt"><a href="#1-1-halt" class="headerlink" title="1.1 halt"></a>1.1 halt</h3><p>关闭系统，需要 root 身份。</p><h3 id="1-2-reboot"><a href="#1-2-reboot" class="headerlink" title="1.2 reboot"></a>1.2 reboot</h3><p>重启系统，需要 root 身份。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure><h3 id="1-3-poweroff"><a href="#1-3-poweroff" class="headerlink" title="1.3 poweroff"></a>1.3 poweroff</h3><p>直接运行即可关机，不需要 root 身份。</p><h2 id="2-十二-Vim-编辑器"><a href="#2-十二-Vim-编辑器" class="headerlink" title="2 十二 Vim 编辑器"></a>2 十二 Vim 编辑器</h2><h2 id="3-Vim-是什么？"><a href="#3-Vim-是什么？" class="headerlink" title="3 Vim 是什么？"></a>3 Vim 是什么？</h2><p>Vim 是从 vi 发展出来的一个<a href="https://www.zhihu.com/search?q=%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">文本编辑器</a>。其代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和 Emacs 并列成为类 Unix 系统用户最喜欢的编辑器。</p><h2 id="4-Vim-常用模式"><a href="#4-Vim-常用模式" class="headerlink" title="4 Vim 常用模式"></a>4 Vim 常用模式</h2><ul><li>交互模式</li><li>插入模式</li><li>命令模式</li><li>可视模式  </li></ul><h3 id="4-1-交互模式"><a href="#4-1-交互模式" class="headerlink" title="4.1 交互模式"></a>4.1 交互模式</h3><p>也成为正常模式，这是 Vim 的默认模式，每次运行 Vim 程序的时候，就会进入这个模式。</p><p>例如执行 vim name.txt 则会进入交互模式。</p><p>交互模式特征：</p><ul><li>在这个模式下，你不能输入文本；</li><li>它可以让我们在文本间移动，删除一行文本，复制黏贴文本，跳转到指定行，撤销操作，等等  </li></ul><h3 id="4-2-插入模式"><a href="#4-2-插入模式" class="headerlink" title="4.2 插入模式"></a>4.2 插入模式</h3><p>这个模式是我们熟悉的文本编辑器的模式，就是可以输入任何你想输入的内容。进入这个模式有几种方法，最常用的方法是按字母键 i （ i、I、a、A、o、O 都可以进入插入模式，只是所处的位置不同），退出这种模式，只需要按下 Esc 键。</p><ul><li>i, I 进入输入模式 Insert mode ：i 为”从目前光标所在处输入”， I 为”在目前所在行的第一个非空格符处开始输入”；</li><li>a, A 进入输入模式 Insert mode ：a 为”从目前光标所在的下一个字符处开始输入”，A 为”从光标所在行的最后一个字符处开始输入”；</li><li>o, O 进入输入模式 Insert mode ：o 为”在目前光标所在的下一行处输入新的一行”；O 为在目前光标所在处的上一行输入新的一行。</li></ul><h3 id="4-3"><a href="#4-3" class="headerlink" title="4.3"></a>4.3</h3><h3 id="4-4-命令模式"><a href="#4-4-命令模式" class="headerlink" title="4.4 命令模式"></a>4.4 命令模式</h3><p>命令模式也称为底线命令模式，这个模式下可以运行一些命令例如”退出”，”保存”，等动作。</p><p>也可以用这个模式来激活一些 Vim 配置，例如语法高亮，显示行号，等。甚至还可以发送一些命令给终端命令行，例如 ls、cp 。</p><p>为了进入命令模式，首先要进入交互模式，再按下冒号键。</p><p>用一张图表示三种模式如何切换：</p><p><img src="https://picx.zhimg.com/80/v2-ba2da86f7f9e710f75d2b52449458f07_1440w.webp?source=1940ef5c" alt=""></p><p>基本操作</p><h3 id="4-5-打开-Vim"><a href="#4-5-打开-Vim" class="headerlink" title="4.5 打开 Vim"></a>4.5 打开 Vim</h3><p>在终端命令行中输入 vim 回车后 Vim 就会被运行起来，也可以用 Vim 来打开一个文件，只需要在 vim 后面再加文件名。如 vim file.name ，如果文件不存在，那么会被创建。  </p><h3 id="4-6-插入"><a href="#4-6-插入" class="headerlink" title="4.6 插入"></a>4.6 插入</h3><p>进入文件之后，此时处于交互模式，可以通过输入 i 进入插入模式  </p><h3 id="4-7-移动"><a href="#4-7-移动" class="headerlink" title="4.7 移动"></a>4.7 移动</h3><p>在 Vim 的交互模式下，我们可以在文本中移动光标。</p><ul><li>h 向左移动一个字符</li><li>j 向下移动一个字符</li><li>k 向上移动一个字符</li><li>i 向右移动一个字符</li></ul><p>当然也可以使用四个方向键进行移动，效果是一样的。  </p><h3 id="4-8-跳至行首和行末"><a href="#4-8-跳至行首和行末" class="headerlink" title="4.8 跳至行首和行末"></a>4.8 跳至行首和行末</h3><ul><li>行首：在交互模式下，为了将光标定位到一行的开始位置，只需要按下数字键 0 即可，键盘上的 Home 键也有相同效果。</li><li>行末：在交互模式下，为了将光标定位到一行的末尾，只需要按下美元符号键 $ 即可，键盘上的 End 键也有相同效果。</li></ul><h3 id="4-9-按单词移动"><a href="#4-9-按单词移动" class="headerlink" title="4.9 按单词移动"></a>4.9 按单词移动</h3><p>在交互模式下，按字母键 w 可以一个单词一个单词的移动。</p><h3 id="4-10-退出文件"><a href="#4-10-退出文件" class="headerlink" title="4.10 退出文件"></a>4.10 退出文件</h3><p>在交互模式下，按下冒号键 : 进入命令模式，再按下 q 键，就可以退出了。</p><p>如果在退出之前又修改了文件，就直接想用 :q 退出 Vim ，那么 Vim 会显示一个红字标明错误信息。此时我们有两个选择：</p><ol><li>保存并退出 :wq 或 :x ；</li><li>不保存且退出 :q! 。</li></ol><h2 id="5-标准操作"><a href="#5-标准操作" class="headerlink" title="5 标准操作"></a>5 标准操作</h2><h3 id="5-1-删除字符"><a href="#5-1-删除字符" class="headerlink" title="5.1 删除字符"></a>5.1 删除字符</h3><p>在交互模式下，将光标定位到一个你想要删除的字符上，按下字母键 x 你会发现这个字符被删除了。</p><p>也可以一次性删除多个字符，只需要在按 x 键之前输入数字即可。  </p><h3 id="5-2-删除（剪切）单词，行"><a href="#5-2-删除（剪切）单词，行" class="headerlink" title="5.2 删除（剪切）单词，行"></a>5.2 删除（剪切）单词，行</h3><ul><li>删除一行：连按两次 d 来删除光标所在的那一行。</li><li>删除多行：例如先输入数字 2 ，再按下 dd ，就会删除从光标所在行开始的两行。</li><li>删除一个单词：将光标置于一个单词的首字母处，然后按下 dw 。</li><li>删除多个单词：例如先按数字键 2 再按 dw 就可以删除两个单词了。</li><li>从光标所在位置删除至行首：d0 。</li><li>从光标所在位置删除至行末：d$ 。</li></ul><h3 id="5-3-复制单词，行"><a href="#5-3-复制单词，行" class="headerlink" title="5.3 复制单词，行"></a>5.3 复制单词，行</h3><ul><li>复制行：按两次 y 会把光标所在行复制到内存中，和 dd 类似， dd 用于”剪切”光标所在行。</li><li>复制单词：yw 会复制一个单词。</li><li>复制到行末：y$ 是复制从光标所在处到行末的所有字符。</li><li>复制到行首：y0 是复制光标所在处到行首的所有字符。  </li></ul><h3 id="5-4-粘贴"><a href="#5-4-粘贴" class="headerlink" title="5.4 粘贴"></a>5.4 粘贴</h3><p>如果之前用 dd 或者 yy 剪切复制过来的，可以使用 p 来粘贴。同样也可以使用 数字+p来表示复制多次。  </p><h3 id="5-5-替换一个字符"><a href="#5-5-替换一个字符" class="headerlink" title="5.5 替换一个字符"></a>5.5 替换一个字符</h3><p>在交互模式下，将光标置于想要替换的字符上。按下 r 键，接着输入你要替换的字符即可。  </p><h3 id="5-6-撤销操作"><a href="#5-6-撤销操作" class="headerlink" title="5.6 撤销操作"></a>5.6 撤销操作</h3><p>如果要撤销最近的修改，只需要按下 u 键，如果想要撤销最近四次修改，可以按下4，再按下 u 。  </p><h3 id="5-7-重做"><a href="#5-7-重做" class="headerlink" title="5.7 重做"></a>5.7 重做</h3><p>取消撤销，也就是重做之前的修改使用 ctrl + r 。  </p><h3 id="5-8-跳转到指定行"><a href="#5-8-跳转到指定行" class="headerlink" title="5.8 跳转到指定行"></a>5.8 跳转到指定行</h3><p>Vim 编辑的文件中，每一行都有一个行号，行号从1开始，逐一递增。</p><p>行号默认是不显示，如果需要它显示的话，可以进入命令模式，然后输入 set nu ，如果要隐藏行号的话，使用 set nonu 。</p><ul><li>跳转到指定行：数字+gg ，例如 7gg ，表示跳转到第7行。</li><li>要跳转到最后一行，按下 G 。</li><li>要跳转到第一行，按下 gg 。</li></ul><h2 id="6-高级操作"><a href="#6-高级操作" class="headerlink" title="6 高级操作"></a>6 高级操作</h2><h3 id="6-1-查找"><a href="#6-1-查找" class="headerlink" title="6.1 查找"></a>6.1 查找</h3><p>处于交互模式下，按下 / 键，那么就进入查找模式，输入你要查找的字符串，然后按下回车。光标就会跳转到文件中下一个查找到的匹配处。如果字符串不存在，那么会显示 “pattern not found” 。</p><ul><li>n 跳转到下一个匹配项；</li><li>N 跳转到上一个匹配项。</li></ul><p>[注意] 用斜杠来进行的查找是从当前光标处开始向文件尾搜索，如果你要从当前光标处开始，向文件头搜索则使用 ? ，当然也可以先按下 gg 跳转到第一行在进行全文搜索。  </p><h3 id="6-2-查找并替换"><a href="#6-2-查找并替换" class="headerlink" title="6.2 查找并替换"></a>6.2 查找并替换</h3><p>替换光标所在行第一个匹配的字符串：</p><h1 id="语法-s-旧字符串-新字符串-实例-s-one-two"><a href="#语法-s-旧字符串-新字符串-实例-s-one-two" class="headerlink" title="语法:s/旧字符串/新字符串# 实例:s/one/two"></a>语法:s/旧字符串/新字符串# 实例:s/one/two</h1><p>替换光标所在行所有旧字符串为新字符串：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 语法:s/旧字符串/新字符串/g</span><br></pre></td></tr></table></figure><p>替换第几行到第几行中所有字符串：</p><h1 id="语法-n-m-s-旧字符串-新字符串-g"><a href="#语法-n-m-s-旧字符串-新字符串-g" class="headerlink" title="语法:n,m s/旧字符串/新字符串/g"></a>语法:n,m s/旧字符串/新字符串/g</h1><h1 id="实例-2-4-s-one-two-g"><a href="#实例-2-4-s-one-two-g" class="headerlink" title="实例:2,4 s/one/two/g"></a>实例:2,4 s/one/two/g</h1><p>最常用的就是全文替换了：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 语法:%s/旧字符串/新字符串/g</span><br></pre></td></tr></table></figure><h3 id="0-1-合并文件"><a href="#0-1-合并文件" class="headerlink" title="0.1 合并文件"></a>0.1 合并文件</h3><p>可以用冒号 +r ( :r ) 实现在光标处插入一个文件的内容。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r filename # 可以用Tab键来自动补全另外一个文件的路径</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/07/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-cond/"/>
      <url>/2025/05/07/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/02-cond/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>Golang 的 sync 包中的 Cond 实现了一种条件变量，可以使用在<strong>多个Reader</strong>等待共享资源 ready 的场景（如果只有一读一写，一个锁或者channel就搞定了）。<br>Cond的汇合点：多个goroutines等待、1个goroutine通知事件发生。<br>比较适合任务调用场景，一个 Master goroutine 通知事件发生，多个 Worker goroutine 在资源没准备好的时候就挂起，等待通知。<br><strong>使用方法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Cond</span></span><br><span class="line">cond := sync.NewCond(<span class="built_in">new</span>(sync.Mutex))</span><br><span class="line"><span class="comment">// 挂起goroutine</span></span><br><span class="line">cond.L.Lock()</span><br><span class="line">cond.Wait()</span><br><span class="line"><span class="comment">// 唤醒一个</span></span><br><span class="line">cond.Signal()</span><br><span class="line"><span class="comment">// 唤醒所有</span></span><br><span class="line">cond.Broadcast()</span><br></pre></td></tr></table></figure><blockquote><p>基本使用大概是需要等待的时候通过 Wait() 将 Goroutine 挂起，资源准备好的时候再通过 Signal() 或者 Broadcast() 将挂起中的 Goroutine 唤醒。</p></blockquote><p>一个简单的 Demo<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">locker sync.Mutex</span><br><span class="line">cond   = sync.NewCond(&amp;locker)</span><br><span class="line">wg     sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(number <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// wait()方法内部是先释放锁 然后在加锁 所以这里需要先 Lock()</span></span><br><span class="line">cond.L.Lock()</span><br><span class="line"><span class="keyword">defer</span> cond.L.Unlock()</span><br><span class="line">cond.Wait() <span class="comment">// 等待通知,阻塞当前 goroutine</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;g %v ok~ \n&quot;</span>, number)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 每过 50毫秒 唤醒一个 goroutine</span></span><br><span class="line">cond.Signal()</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line"><span class="comment">// 剩下5个 goroutine 一起唤醒</span></span><br><span class="line">cond.Broadcast()</span><br><span class="line">fmt.Println(<span class="string">&quot;Broadcast...&quot;</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><blockquote><p>go version 1.14.7</p></blockquote><h3 id="2-1-Cond"><a href="#2-1-Cond" class="headerlink" title="2.1 Cond"></a>2.1 Cond</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 21</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line">    L Locker</span><br><span class="line">    notify  notifyList</span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCond() 返回指针，保证多 goroutine 获取到的是同一个实例。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span></span> *Cond &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Cond&#123;L: l&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>noCopy</strong>：noCopy对象，实现了<code>sync.Locker</code>接口，使得内嵌 noCopy 的对象在进行 go vet 静态检查的时候，可以检查出是否被复制。</p><blockquote><p>noCopy 具体见 <a href="https://github.com/golang/go/issues/8005">Go issues 8005</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 94</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> noCopy <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*noCopy)</span></span> Lock()   &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*noCopy)</span></span> Unlock() &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>L</strong>：实现了 <code>sync.Locker</code> 接口的锁对象，通常使用 Mutex 或 RWMutex 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： mutex.go</span></span><br><span class="line"><span class="comment">line: 31</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">     Lock()</span><br><span class="line">     Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>notify</strong>：notifyList 对象，维护等待唤醒的 goroutine 队列,使用链表实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： runtime.go</span></span><br><span class="line"><span class="comment">line: 33    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">wait   <span class="type">uint32</span></span><br><span class="line">notify <span class="type">uint32</span></span><br><span class="line">lock   <span class="type">uintptr</span></span><br><span class="line">head   unsafe.Pointer</span><br><span class="line">tail   unsafe.Pointer</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>checker</strong>：copyChecker 对象，实际上是 uintptr 对象，保存自身对象地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 79    </span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="keyword">type</span> copyChecker <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *copyChecker)</span></span> check() &#123;</span><br><span class="line">     <span class="keyword">if</span> <span class="type">uintptr</span>(*c) != <span class="type">uintptr</span>(unsafe.Pointer(c)) &amp;&amp;</span><br><span class="line">            !atomic.CompareAndSwapUintptr((*<span class="type">uintptr</span>)(c), <span class="number">0</span>, <span class="type">uintptr</span>(unsafe.Pointer(c))) &amp;&amp;</span><br><span class="line">            <span class="type">uintptr</span>(*c) != <span class="type">uintptr</span>(unsafe.Pointer(c)) &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;sync.Cond is copied&quot;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>1）检查当前 checker 对象的地址是否等于保存在 checker 中的地址</p><ul><li>由于第一次比较的时候 checker 中没有存地址所以第一次比较肯定是不相等的，于是有了后续 2 3步。</li></ul></li><li><p>2）对 checker 进行 CAS 操作，如果 checker 中存储的地址值为空（就是0）就把当前 checker 对象的地址值存进去</p></li><li>3）第三步和第一步一样，再比较一下。<ul><li>主要是防止在第一步比较发现不相等之后，第二步 CAS 之前，其他 goroutine 也在执行这个方法，并发的将 checker 赋值了，导致这里判定的时候第二步 CAS 失败，返回 false，然后错误的抛出一个 panic，所以执行第三步在比较一下是否相等。如果其他 goroutine 抢先执行 CAS 修改了 checker 中的值导致这里第二步也返回 false 的话，第三步的判定也会是相等的，不会抛出 panic</li></ul></li><li>4）如果 3 个条件都成立，那 checker 肯定是被复制了，就是由于 cond 被复制引起的。</li></ul><blockquote><p>check 方法在第一次调用的时候，会将 checker 对象地址赋值给 checker，也就是将自身内存地址赋值给自身。<br>再次调用 checker 方法的时候，会将当前 checker 对象地址值与 checker 中保存的地址值（原始地址）进行比较，若不相同则表示当前 checker 的地址不是第一次调用 check 方法时候的地址，即 cond 对象被复制了，导致checker 被重新分配了内存地址。</p></blockquote><h3 id="2-2-Wait"><a href="#2-2-Wait" class="headerlink" title="2.2 Wait"></a>2.2 Wait</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 52    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait() &#123;</span><br><span class="line">    <span class="comment">// 1.每次操作之前都要检测一下 cond 是否被复制了。</span></span><br><span class="line">    c.checker.check() </span><br><span class="line">    <span class="comment">// 2.将 notifyList 中的 wait 值加1并返回之前的值</span></span><br><span class="line">    t := runtime_notifyListAdd(&amp;c.notify) </span><br><span class="line">    <span class="comment">// 3.释放锁，因此在调用Wait方法前，必须保证获取到了cond的锁，否则会报错</span></span><br><span class="line">    c.L.Unlock()</span><br><span class="line">    <span class="comment">// 4.将当前goroutine挂起，等待唤醒信号</span></span><br><span class="line">    runtime_notifyListWait(&amp;c.notify, t) </span><br><span class="line">    <span class="comment">// 5.gorountine被唤醒，重新获取锁</span></span><br><span class="line">    c.L.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> package: runtime</span></span><br><span class="line"><span class="comment"> file： sema.go</span></span><br><span class="line"><span class="comment"> line: 479  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListAdd</span><span class="params">(l *notifyList)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> atomic.Xadd(&amp;l.wait, <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: runtime</span></span><br><span class="line"><span class="comment">file： sema.go</span></span><br><span class="line"><span class="comment">line: 488  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 获取当前 goroutine 添加到链表末端，然后 goparkunlock 函数休眠阻塞当前 goroutine</span></span><br><span class="line"><span class="comment">// goparkunlock 函数会让出当前处理器的使用权并等待调度器的唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListWait</span><span class="params">(l *notifyList, t <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.锁住 notify 队列</span></span><br><span class="line">    lock(&amp;l.lock)</span><br><span class="line">    <span class="comment">// 2.判断传入的等待序号t是否小于当前已经唤醒的序号notify</span></span><br><span class="line">    <span class="comment">// 如果是则说明当前 goroutine 不需要阻塞了 直接解锁并返回</span></span><br><span class="line">    <span class="comment">// 有可能执行这步之前 goroutine 就已经被唤醒了</span></span><br><span class="line">    <span class="keyword">if</span> less(t, l.notify) &#123;</span><br><span class="line">        unlock(&amp;l.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.获取当前 goroutine，设置相关参数，将当前等待数赋值给 ticket</span></span><br><span class="line">    s := acquireSudog()</span><br><span class="line">    s.g = getg()</span><br><span class="line">    s.ticket = t</span><br><span class="line">    s.releasetime = <span class="number">0</span></span><br><span class="line">    t0 := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">        s.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.将当前 goroutine 写入到链表尾部</span></span><br><span class="line">    <span class="keyword">if</span> l.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">        l.head = s</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l.tail.next = s</span><br><span class="line">    &#125;</span><br><span class="line">    l.tail = s</span><br><span class="line">    <span class="comment">// 5. 调用 goparkunlock 函数将当前 goroutine 挂起，等待唤醒信号</span></span><br><span class="line">    goparkunlock(&amp;l.lock, <span class="string">&quot;semacquire&quot;</span>, traceEvGoBlockCond, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(s.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-Signal"><a href="#2-3-Signal" class="headerlink" title="2.3 Signal"></a>2.3 Signal</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 64  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal() &#123;</span><br><span class="line">    <span class="comment">// 1.复制检查</span></span><br><span class="line">    c.checker.check() </span><br><span class="line">    <span class="comment">// 2.顺序唤醒一个等待的gorountine</span></span><br><span class="line">    runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: runtime</span></span><br><span class="line"><span class="comment">file： sema.go</span></span><br><span class="line"><span class="comment">line: 554  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyOne</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 1.等待序号和唤醒序号相同则说明没有需要唤醒的 goroutine 直接返回</span></span><br><span class="line">   <span class="keyword">if</span> atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 2.锁住队列后再检查一遍等待序号和唤醒序号是否相同即判断有没有需要唤醒的 goroutine，没有则解锁后直接返回</span></span><br><span class="line">   lock(&amp;l.lock) </span><br><span class="line">   t := l.notify</span><br><span class="line">   <span class="keyword">if</span> t == atomic.Load(&amp;l.wait) &#123;</span><br><span class="line">        unlock(&amp;l.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 3.到这里就说明有需要唤醒的 goroutine，于是先将 notify序号+1</span></span><br><span class="line">   atomic.Store(&amp;l.notify, t+<span class="number">1</span>)  </span><br><span class="line">   <span class="comment">// 4.然后就开始唤醒 goroutine 了</span></span><br><span class="line">   <span class="keyword">for</span> p, s := (*sudog)(<span class="literal">nil</span>), l.head; s != <span class="literal">nil</span>; p, s = s, s.next &#123;</span><br><span class="line">        <span class="comment">// 4.1 找到 ticket等于当前唤醒序号的 goroutine</span></span><br><span class="line">        <span class="keyword">if</span> s.ticket == t &#123;</span><br><span class="line">           <span class="comment">// 4.2 然后将其从等待唤醒链表中移除（因为这个 goroutine 马上就要被唤醒了）</span></span><br><span class="line">           n := s.next</span><br><span class="line">           <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">               p.next = n</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               l.head = n</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">               l.tail = p</span><br><span class="line">           &#125;</span><br><span class="line">           unlock(&amp;l.lock)</span><br><span class="line">           s.next = <span class="literal">nil</span></span><br><span class="line">           <span class="comment">// 4.3 然后唤醒这个 goroutine </span></span><br><span class="line">           readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">           <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 4.4 最后解锁队列 </span></span><br><span class="line">   unlock(&amp;l.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-Broadcast"><a href="#2-4-Broadcast" class="headerlink" title="2.4 Broadcast"></a>2.4 Broadcast</h3><p>唤醒链表中所有的阻塞中的goroutine，还是使用readyWithTime来实现这个功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 73  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast() &#123;</span><br><span class="line">    <span class="comment">// 1.复制检查</span></span><br><span class="line">    c.checker.check()</span><br><span class="line">    <span class="comment">// 2.唤醒所有在等待的 goroutine</span></span><br><span class="line">    runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里和 <code>notifyListNotifyOne()</code>差不多，只是一次性唤醒所有 goroutine。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: runtime</span></span><br><span class="line"><span class="comment">file： sema.go</span></span><br><span class="line"><span class="comment">line: 522 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyAll</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.等待序号和唤醒序号相同则说明没有需要唤醒的 goroutine 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将链表头尾指针置为空（可以看做是清空整个等待队列）</span></span><br><span class="line">    <span class="comment">// 但是需要将当前的链表头保存下来，不然等会找不到链表中的数据了</span></span><br><span class="line">    lock(&amp;l.lock)</span><br><span class="line">    s := l.head</span><br><span class="line">    l.head = <span class="literal">nil</span></span><br><span class="line">    l.tail = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.直接将notify需要赋值成等待序号（这样表示当前没有需要唤醒的 goroutine 了）</span></span><br><span class="line">    <span class="comment">// 前面唤醒一个的时候这里是+1</span></span><br><span class="line">    atomic.Store(&amp;l.notify, atomic.Load(&amp;l.wait))</span><br><span class="line">    unlock(&amp;l.lock)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4.最后 for 循环唤醒链表中所有等待状态的 goroutine</span></span><br><span class="line">    <span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">        next := s.next</span><br><span class="line">        s.next = <span class="literal">nil</span></span><br><span class="line">        readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">        s = next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p><strong>基本使用</strong></p><ul><li>1）资源未准备好时，使用 Wait() 方法将 goroutine 挂起，由底层实现，会让出 CPU 时间片，从而避免使用无意义的循环浪费系统资源。</li><li>2）资源准备好时通过 Signal() 或者 Broadcast() 方法唤醒一个或多个被挂起的 goroutine。</li></ul><p><strong>等待唤醒流程</strong></p><ul><li>1）所有相关数据都是存在 notifyList 中的，包括 goroutine 和一些计数信息。</li><li>2）其中的 wait 和 notify 可以理解为等待序号和唤醒序号，都是自增值，wait 在有新 goroutine 等待时+1，notify 则在唤醒一个 goroutine 时+1。</li><li>3）等待状态的 goroutine 信息则存放在链表中，等待时加入链表尾部，唤醒时移除。</li><li>4）每个等待链表的 goroutine  都会将当前的 wait（等待序号）赋值给 ticket 字段，唤醒的时候会将 ticket=唤醒序号的 goroutine 唤醒。</li><li>5）当 wait==notify 时表示没有 goroutine 需要被唤醒，wait&gt;notify 时表示有 goroutine 需要被唤醒，wait 恒大于等于 notify。</li></ul><p><strong>noCopy</strong><br>Cond在内部持有一个等待队列 notifyList ，这个队列维护所有等待在这个 Cond 的 goroutine。如果 Cond 被复制则会导致其中的等待队列也被复制，最终可能会导致在唤醒 goroutine 的时候出现错误。<br>Kubernetes 的调度中也用到了 sync.Cond 有兴趣的可以研究一下。</p><blockquote><p><a href="https://mp.weixin.qq.com/s/rKLiazgWzneJfpfgHay8cA">https://mp.weixin.qq.com/s/rKLiazgWzneJfpfgHay8cA</a><br><a href="https://github.com/kubernetes/kubernetes/blob/0599ca2bcfcae7d702f95284f3c2e2c2978c7772/pkg/scheduler/internal/queue/scheduling_queue.go">https://github.com/kubernetes/kubernetes/blob/0599ca2bcfcae7d702f95284f3c2e2c2978c7772/pkg/scheduler/internal/queue/scheduling_queue.go</a></p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><code>https://ieevee.com/tech/2019/06/15/cond.html</code></p></blockquote><p><code>https://segmentfault.com/a/1190000019957459</code></p><p><code>https://www.jianshu.com/p/7b59d1d92a95</code></p><p><code>http://www.pydevops.com/2016/12/04/go-cond源码剖析-3/</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/07/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.Mutex/"/>
      <url>/2025/05/07/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.Mutex/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">## 1 基本结构</span><br><span class="line">```go</span><br><span class="line">// sync/mutex.go 25行</span><br><span class="line">type Mutex struct &#123;</span><br><span class="line">state int32      // 当前互斥锁的状态</span><br><span class="line">sema  uint32     // 控制锁状态的信号量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-state字段"><a href="#1-1-state字段" class="headerlink" title="1.1 state字段"></a>1.1 state字段</h3><p>![[Pasted image 20230901043018.png]]<br>低三位分别标识</p><ul><li>mutexLocked（是否上锁）</li><li>mutexWoken（是否有协程在抢锁）</li><li>mutexStarving（是否处于饥饿模式）</li><li>高 29 位的值聚合为一个范围为 0~2^29-1 的整数，表示在阻塞队列中等待的协程个数.</li></ul><h3 id="1-2-正常模式和饥饿模式"><a href="#1-2-正常模式和饥饿模式" class="headerlink" title="1.2 正常模式和饥饿模式"></a>1.2 正常模式和饥饿模式</h3><blockquote><p>mutex 是公平锁</p></blockquote><p><code>正常模式</code>：锁的等待者会按照<code>先进先出</code>的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine <code>超过 1ms</code> 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被<strong>饿死</strong>。<br><code>饥饿模式</code>：互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间<code>少于 1ms</code>，那么当前的互斥锁就会切换回正常模式。</p><h2 id="2-加解锁过程"><a href="#2-加解锁过程" class="headerlink" title="2 加解锁过程"></a>2 加解锁过程</h2><h3 id="2-1-加锁"><a href="#2-1-加锁" class="headerlink" title="2.1 加锁"></a>2.1 加锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/mutex.go 72 行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line"><span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Slow path (outlined so that the fast path can be inlined)</span></span><br><span class="line">m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-1-Fast-path"><a href="#2-1-1-Fast-path" class="headerlink" title="2.1.1 Fast path"></a>2.1.1 Fast path</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先进行 <code>CAS</code> 操作，假如当前未上锁且锁内不存在阻塞协程，则直接 CAS 抢锁成功返回</p></blockquote><h4 id="2-1-2-Slow-Path"><a href="#2-1-2-Slow-Path" class="headerlink" title="2.1.2 Slow Path"></a>2.1.2 Slow Path</h4><p>如果互斥锁的状态不是 0 时就会进入 Slow Path。尝试通过自旋（Spinnig）等方式等待锁的释放，该方法的主体是一个非常大 for 循环，这里将它分成几个部分介绍获取锁的过程：</p><h5 id="2-1-2-1-判断当前-Goroutine-能否进入自旋"><a href="#2-1-2-1-判断当前-Goroutine-能否进入自旋" class="headerlink" title="2.1.2.1 判断当前 Goroutine 能否进入自旋"></a>2.1.2.1 判断当前 Goroutine 能否进入自旋</h5><p><strong>自旋是一种多线程同步机制</strong>，当前的进程在进入自旋的过程中会一直保持 CPU 的占用，持续检查某个条件是否为真。<strong>在多核的 CPU 上，自旋可以避免 Goroutine 的切换</strong>，使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 Goroutine 进入自旋的条件非常苛刻：</p><ul><li>互斥锁只有在普通模式才能进入自旋；</li><li><code>runtime.sync_runtime_canSpin</code>需要返回 true<ul><li>运行在多 CPU 的机器上；</li></ul><ul><li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li><li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li></ul></li></ul><h5 id="2-1-2-2-通过自旋等待互斥锁的释放"><a href="#2-1-2-2-通过自旋等待互斥锁的释放" class="headerlink" title="2.1.2.2 通过自旋等待互斥锁的释放"></a>2.1.2.2 通过自旋等待互斥锁的释放</h5><p>一旦当前 Goroutine 能够进入自旋就会调用<code>runtime.sync_runtime_doSpin</code>和<code>runtime.procyield</code>执行 30 次的 <code>PAUSE</code> 指令，该指令只会占用 CPU 并消耗 CPU 时间：</p><h5 id="2-1-2-3-计算互斥锁的最新状态"><a href="#2-1-2-3-计算互斥锁的最新状态" class="headerlink" title="2.1.2.3 计算互斥锁的最新状态"></a>2.1.2.3 计算互斥锁的最新状态</h5><p>处理了自旋相关的特殊逻辑之后，互斥锁会根据上下文计算当前互斥锁最新的状态。几个不同的条件分别会更新 <code>state</code> 字段中存储的不同信息 — <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 和 <code>mutexWaiterShift</code>：</p><h5 id="2-1-2-4-更新互斥锁的状态并获取锁"><a href="#2-1-2-4-更新互斥锁的状态并获取锁" class="headerlink" title="2.1.2.4 更新互斥锁的状态并获取锁"></a>2.1.2.4 更新互斥锁的状态并获取锁</h5><p>计算了新的互斥锁状态之后，会使用 CAS 函数更新状态<br>如果没有通过 CAS 获得锁，会调用 <code>runtime.sync_runtime_SemacquireMutex</code> 通过信号量保证资源不会被两个 Goroutine 获取。<br><code>runtime.sync_runtime_SemacquireMutex</code> 会在方法中不断尝试获取锁并陷入休眠等待信号量的释放，一旦当前 Goroutine 可以获取信号量，它就会立刻返回，<code>sync.Mutex.Lock</code>的剩余代码也会继续执行。</p><ul><li>在正常模式下，这段代码会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环；</li><li>在饥饿模式下，当前 Goroutine 会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出；</li></ul><h3 id="2-2-解锁"><a href="#2-2-解锁" class="headerlink" title="2.2 解锁"></a>2.2 解锁</h3><h4 id="2-2-1-Fast-path"><a href="#2-2-1-Fast-path" class="headerlink" title="2.2.1 Fast path"></a>2.2.1 Fast path</h4><p>该过程会先使用<code>atomic.AddInt32函数快速解锁，这时会发生下面的两种情况：</code></p><ul><li>如果该函数返回的新状态等于 0，当前 Goroutine 就成功解锁了互斥锁；</li><li>如果该函数返回的新状态不等于 0，则进入 Slow path。<h4 id="2-2-2-Slow-path"><a href="#2-2-2-Slow-path" class="headerlink" title="2.2.2 Slow path"></a>2.2.2 Slow path</h4>先校验锁状态的<code>合法性</code> — 如果当前互斥锁已经被解锁过了会直接抛出异常 “sync: unlock of unlocked mutex” 中止当前程序。<br>在正常模式下，上述代码会使用如下所示的处理过程：</li><li>如果互斥锁不存在等待者或者互斥锁的 <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 状态不都为 0，那么当前方法可以直接返回，不需要唤醒其他等待者；</li><li>如果互斥锁存在等待者，会通过<code>runtime_Semrelease</code>唤醒等待者并移交锁的所有权；<br>在饥饿模式下，上述代码会直接调用<code>runtime_Semrelease</code>将当前锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁，在这时互斥锁还不会退出饥饿状态；</li></ul><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p>互斥锁的<strong>加锁过程</strong>比较复杂，它涉及自旋、信号量以及调度等概念：</p><ul><li>如果互斥锁处于初始化状态，会通过置位 <code>mutexLocked</code> 加锁；</li><li>如果互斥锁处于 <code>mutexLocked</code> 状态并且在普通模式下工作，会进入自旋，执行 30 次 <code>PAUSE</code> 指令消耗 CPU 时间等待锁的释放；</li><li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li><li>互斥锁在正常情况下会通过<code>sync_runtime_SemacquireMutex</code>将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；</li><li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式；</li></ul><p>互斥锁的<strong>解锁过程</strong>与之相比就比较简单：</p><ul><li>当互斥锁已经被解锁时，调用 Mutex.Lock 会直接抛出异常；</li><li>当互斥锁处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 <code>mutexLocked</code> 标志位；</li><li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，会直接返回；在其他情况下会通过<code>sync.runtime_Semrelease</code> 唤醒对应的 Goroutine；</li></ul><h2 id="4-Sync-RWMutex"><a href="#4-Sync-RWMutex" class="headerlink" title="4 Sync.RWMutex"></a>4 Sync.RWMutex</h2><blockquote><p>从逻辑上，可以把 RWMutex 理解为一把读锁加一把写锁；<br>写锁具有<code>严格的排他性</code>，当其被占用，其他试图取写锁或者读锁的 goroutine 均阻塞；<br>读锁具有<code>有限的共享性</code>，当其被占用，试图取写锁的 goroutine 会阻塞，试图取读锁的 goroutine 可与当前 goroutine 共享读锁；<br>RWMutex 适用于<code>读多写少</code>的场景，最理想化的情况，当所有操作均使用读锁，则可实现无锁化；最悲观的情况，倘若所有操作均使用写锁，则 RWMutex 退化为普通的 Mutex.</p></blockquote><h3 id="4-1-数据结构"><a href="#4-1-数据结构" class="headerlink" title="4.1 数据结构"></a>4.1 数据结构</h3><p>![[Pasted image 20230901163649.png]]<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span>   <span class="comment">// 共享读锁的 goroutine 数量上限，值为 2^29；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w           Mutex  <span class="comment">// 内置的一把普通互斥锁 sync.Mutex；</span></span><br><span class="line">    writerSem   <span class="type">uint32</span> <span class="comment">// 关联写锁阻塞队列的信号量；</span></span><br><span class="line">    readerSem   <span class="type">uint32</span> <span class="comment">// 关联读锁阻塞队列的信号量；</span></span><br><span class="line">    readerCount <span class="type">int32</span>  <span class="comment">// 正常情况下等于介入读锁流程的 goroutine 数量；当 goroutine 接入写锁流程时，该值为实际介入读锁流程的 goroutine 数量减 rwmutexMaxReaders.</span></span><br><span class="line">    readerWait  <span class="type">int32</span>  <span class="comment">// 记录在当前 goroutine 获取写锁前，还需要等待多少个 goroutine 释放读锁.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-2-读锁流程"><a href="#4-2-读锁流程" class="headerlink" title="4.2 读锁流程"></a>4.2 读锁流程</h3><h4 id="4-2-1-RLock"><a href="#4-2-1-RLock" class="headerlink" title="4.2.1 RLock"></a>4.2.1 RLock</h4><p>• 基于原子操作，将 RWMutex 的 readCount 变量加一，表示占用或等待读锁的 goroutine 数加一；<br>• 倘若 RWMutex.readCount 的新值仍小于 0，说明有 goroutine 未释放写锁，因此将当前 goroutine 添加到读锁的阻塞队列中并阻塞挂起.</p><h4 id="4-2-2-RUnlock"><a href="#4-2-2-RUnlock" class="headerlink" title="4.2.2 RUnlock"></a>4.2.2 RUnlock</h4><p>• 基于原子操作，将 RWMutex 的 readCount 变量加一，表示占用或等待读锁的 goroutine 数减一；<br>• 倘若 RWMutex.readCount 的新值小于 0，说明有 goroutine 在等待获取写锁，则走入 RWMutex.rUnlockSlow 的流程中.</p><h4 id="4-2-3-rUnlockSlow"><a href="#4-2-3-rUnlockSlow" class="headerlink" title="4.2.3 rUnlockSlow"></a>4.2.3 rUnlockSlow</h4><p>• 对 RWMutex.readerCount 进行校验，倘若发现当前协程此前未抢占过读锁，或者介入读锁流程的 goroutine 数量达到上限，则抛出 fatal；<br>(倘若 r+1 == -rwmutexMaxReaders，说明此时有 goroutine 介入写锁流程，但当前此前未加过读锁，具体原因见 2.3 小节；倘若 r+1=0，则要么此前未加过读锁，要么介入读锁流程的 goroutine 数量达到上限</p><p>• 基于原子操作，对 RWMutex.readerWait 进行减一操作，倘若其新值为 0，说明当前 goroutine 是最后一个介入读锁流程的协程，因此需要唤醒一个等待写锁的阻塞队列的 goroutine.（综合 RWMutex.readerCount 为负值，可以确定存在等待写锁的 goroutine，具体原因见 2.3 小节.）</p><h3 id="4-3-写锁流程"><a href="#4-3-写锁流程" class="headerlink" title="4.3 写锁流程"></a>4.3 写锁流程</h3><h4 id="4-3-1-Lock"><a href="#4-3-1-Lock" class="headerlink" title="4.3.1 Lock"></a>4.3.1 Lock</h4><p>• 对 RWMutex 内置的互斥锁进行加锁操作；<br>• 基于原子操作，对 RWMutex.readerCount 进行减少 -rwmutexMaxReaders 的操作；<br>• 倘若此时存在未释放读锁的 gouroutine，则基于原子操作在 RWMutex.readerWait 的基础上加上介入读锁流程的 goroutine 数量，并将当前 goroutine 添加到写锁的阻塞队列中挂起.</p><h4 id="4-3-2-Unlock"><a href="#4-3-2-Unlock" class="headerlink" title="4.3.2 Unlock"></a>4.3.2 Unlock</h4><p>• 基于原子操作，将 RWMutex.readerCount 的值加上 rwmutexMaxReaders；<br>• 倘若发现 RWMutex.readerCount 的新值大于 rwmutexMaxReaders，则说明要么当前 RWMutex 未上过写锁，要么介入读锁流程的 goroutine 数量已经超限，因此直接抛出 fatal；<br>• 因此唤醒读锁阻塞队列中的所有 goroutine；(可见，竞争读锁的 goroutine 更具备优势)<br>• 解开 RWMutex 内置的互斥锁.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/07/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.WaitGroup/"/>
      <url>/2025/05/07/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.WaitGroup/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">&gt;Golang 调度方式：`主动让渡`和`被动调度`</span><br><span class="line">&gt;被动调度: `通道 channel` 、`单机锁 sync.Mutex`、`并发等待组 sync.WaitGroup`</span><br><span class="line">&gt;当 goroutine 之间需要建立明确的`层级关系`. 倘若父 goroutine 希望持有子 goroutine 的生杀大权，并且保证父 goroutine 消亡时能连带回收其创建的所有子 goroutine ，此时可以使用到 Golang 上下文工具 context，完成父 goroutine 对 子 goroutine 的`生命周期控制`</span><br><span class="line"></span><br><span class="line">&gt; 多个协程等待一个协程执行完，除了WaitGroup 还有什么方式？  写入channel，for循环读</span><br><span class="line">## 1 How to use？</span><br><span class="line">### 1.1 核心方法</span><br><span class="line">• `WaitGroup.Add(n)`：完成一次登记操作，使得 WaitGroup 中并发计数器的数值加上 n. 在使用场景中，WaitGroup.Add(n) 背后的含义是，注册并启动了 n 个子 goroutine</span><br><span class="line">• `WaitGroup.Done()`：完成一次上报操作，使得 WaitGroup 中并发计数器的数值减 1. 在使用场景中，通常会在一个子 goroutine 退出前，会执行一次 WaitGroup.Done 方法</span><br><span class="line">• `WaitGroup.Wait()`：完成聚合操作. 通常由主 goroutine 调用该方法，主 goroutine 会因此陷入阻塞，直到所有子 goroutine 都已经执行完成，使得 WaitGroup 并发计数器数值清零时，主 goroutine 才得以继续往下执行</span><br><span class="line"></span><br><span class="line">### 1.2 案例</span><br><span class="line">```go</span><br><span class="line">func Test_waitGroup(t *testing.T) &#123;</span><br><span class="line">    var wg sync.WaitGroup   // 声明等待组 wg</span><br><span class="line">    for i := 0; i &lt; 10; i++ &#123;   // 循环开启十个子 Goroutine</span><br><span class="line">        wg.Add(1)               // 登记子 Goroutine</span><br><span class="line">        go func() &#123;</span><br><span class="line">            defer wg.Done()     // 保证退出前会调用一次，完成上报</span><br><span class="line">            &lt;-time.After(time.Second)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()                   // 阻塞等待，直到等待组全部完成后才往下走</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：子 goroutine 是异步启动的，所以有可能出现 Wait 方法先于 Add 方法执行，此时由于计数器值为 0，Wait 方法会被直接放行，导致产生预期之外的执行流程；因此要保证 add 在 done 之前。</p></blockquote><h3 id="1-3-WaitGroup-channel-完成数据聚合"><a href="#1-3-WaitGroup-channel-完成数据聚合" class="headerlink" title="1.3 WaitGroup + channel 完成数据聚合"></a>1.3 WaitGroup + channel 完成数据聚合</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_waitGroup</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tasksNum := <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据缓存 channel</span></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    <span class="comment">// 数据结果 slice</span></span><br><span class="line">    resp := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, tasksNum)</span><br><span class="line">    <span class="comment">// 控制管道</span></span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 启动读 goroutine</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> data := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">            resp = <span class="built_in">append</span>(resp, data)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标识数据读取完成</span></span><br><span class="line">        stopCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证获取到所有数据后，通过 channel 传递到读协程手中</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; tasksNum; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            ch &lt;- time.Now().UnixNano()</span><br><span class="line">        &#125;(dataCh)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确保所有取数据的协程都完成了工作，才关闭 ch</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(dataCh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保读协程处理完成</span></span><br><span class="line">    &lt;-stopCh</span><br><span class="line"></span><br><span class="line">    t.Logf(<span class="string">&quot;resp: %+v&quot;</span>, resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-源码走读"><a href="#2-源码走读" class="headerlink" title="2 源码走读"></a>2 源码走读</h2><h3 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h3><p>WaitGroup 位于 golang sync 包下，对应的类声明中包含了几个核心字段：</p><ul><li><code>noCopy</code>：这是防拷贝标识，标记了 WaitGroup 不应该用于值传递</li><li><code>state1</code>：这是 WaitGroup 的核心字段，是一个无符号的64位整数，高32位是 WaitGroup 中并发计数器的数值，即当前 WaitGroup.Add 与 WaitGroup.Done 之间的差值；低 32 位标识了，当前有多少 goroutine 因 WaitGroup.Wait 操作而处于阻塞态，陷入阻塞态的原因是因为计数器的值没有清零，即 state1 字段高 32 位是一个正值</li><li><code>state2</code>：用于阻塞和唤醒 goroutine 的信号量</li></ul><p><code>WaitGroup.Add</code> 方法会给 WaitGroup 的计数器累加上一定的值，背后的含义是标识出当前有多少 goroutine 正在运行，需要由 WaitGroup.Done 操作完成数值的抵扣：</p><ul><li>首先通过 WaitGroup.state 方法，获取到 WaitGroup 的 state1 和 state2 字段，分别将字段对应的地址赋给临时变量 statep 和 semap</li><li>调用 atomic.AddUint64，直接通过指针的方式直接在 WaitGroup.state1 的高 32 位基础上累加上 delta 的值</li><li>获取到 state1 高 32 位的值，赋值给局部变量 v，其含义是并发计数器的数值，即 WaitGroup.Add 和 WaitGroup.Done 之间的差值</li><li>获取到 state1 低 32 位的值，赋值给局部变量 w. 其含义是因执行 WaitGroup.Wait 操作而陷入阻塞态的 goroutine 数量</li><li>倘若 WaitGroup 计数器出现负值，直接 panic（ Done 不应该多于 Add ）</li><li>倘若首次 Add 操作是在有 goroutine 因 Wait 操作而陷入阻塞时才执行，抛出 panic（if w != 0 &amp;&amp; delta &gt; 0 &amp;&amp; v == int32(delta) ）</li><li>倘若执行完 Add 操作后，WaitGroup 的计数器还是正值，则直接返回</li><li>倘若发现本次 Add 操作后， WaitGroup 计数器被清零了，则接下来需要依次把因 Wait 操作而陷入阻塞的 goroutine 唤醒. 在这期间，不允许再并发执行 Add 操作，否则会 panic</li><li>唤醒 goroutine 使用的方法是 runtime_Semrelease 方法，底层会执行 goready 操作，属于 goroutine 的被动调度模式</li></ul><p>执行 WaitGroup.Wait 方法，会判断 WaitGroup 中的并发计数器数值是否为 0，如果不等于0，则当前 goroutine 会陷入阻塞态，直到计数器数值清零之后，才会被唤醒. 具体的执行流程如下：</p><ul><li>执行 WaitGroup.state 方法，获取到 state1 和 state2 字段</li><li>走进 for 循环开启自旋流程</li><li>将 state1 高 32 位所存储的计数器数值赋给局部变量 v</li><li>将 state1 低 32 位所存储的阻塞 goroutine 数量赋给局部变量 w</li><li>倘若计数器数值 v 已经是 0 了，则无需阻塞 goroutine，直接返回即可</li><li>倘若计数器数值 v 大于 0，代表当前 goroutine 需要被阻塞挂起.</li><li>基于 cas，将 state1 低 32 位的数值加 1，标识有一个额外的 goroutine 需要阻塞挂起了</li><li>调用 runtime_Semacquire 方法，内部会通过 go park 操作，将当前 goroutine 阻塞挂起，属于被动调度模式</li><li>当 goroutine 从 runtime_Semacquire 方法走出来时，说明 WaitGroup 计数器已经被清零了.</li><li>在被唤醒的 goroutine 返回前，WaitGroup 不能被并发执行 Add 操作，否则会陷入 panic</li><li>被唤醒的 goroutine 正常返回，Wait 流程结束</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/05/07/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/04-sync.Mutex/"/>
      <url>/2025/05/07/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/04-sync.Mutex/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">Go 语言在 `sync` 包中提供了用于同步的一些基本原语,`sync.Mutex` 就是其中最常用的一个。</span><br><span class="line"></span><br><span class="line">&gt; 本文基于 Go 1.17.1</span><br><span class="line">## 1 基本结构</span><br><span class="line">Go 语言的 `sync.Mutex`由两个字段 `state` 和 `sema` 组成。其中 `state` 表示当前互斥锁的状态，而 `sema` 是用于控制锁状态的信号量。</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">// sync/mutex.go 25行</span><br><span class="line">type Mutex struct &#123;</span><br><span class="line">state int32</span><br><span class="line">sema  uint32</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两个字段加起来只占 8 字节空间的结构体表示了 Go 语言中的互斥锁。</p><h3 id="1-1-状态"><a href="#1-1-状态" class="headerlink" title="1.1 状态"></a>1.1 状态</h3><p>互斥锁的状态比较复杂，如下图所示，最低三位分别表示 <code>mutexLocked</code>、<code>mutexWoken</code> 和 <code>mutexStarving</code>，剩下的位置用来表示当前有多少个 Goroutine 在等待互斥锁的释放：<br>![[mutex-state.png]]<br><code>int32</code> 中的不同位分别表示了不同的状态：</p><ul><li><code>mutexLocked</code> — 表示互斥锁的锁定状态；</li><li><code>mutexWoken</code> — 表示从正常模式被从唤醒；</li><li><code>mutexStarving</code> — 当前的互斥锁进入饥饿状态；</li><li><code>waitersCount</code> — 当前互斥锁上等待的 Goroutine 个数</li></ul><p>在默认情况下，互斥锁的所有状态位都是 0，即默认为未锁定状态。</p><blockquote><p>同时也表明 Mutex 是不需要初始化的</p></blockquote><p>源码中也提供了相关常量</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/mutex.go 36</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line"></span><br><span class="line">    mutexLocked = <span class="number">1</span> &lt;&lt; <span class="literal">iota</span> <span class="comment">// 1 0001 含义：用最后一位表示当前对象锁的状态，0-未锁住 1-已锁住</span></span><br><span class="line"></span><br><span class="line">    mutexWoken <span class="comment">// 2 0010 含义：用倒数第二位表示当前对象是否被唤醒 0-唤醒 1-未唤醒</span></span><br><span class="line"></span><br><span class="line">    mutexStarving <span class="comment">// 4 0100 含义：用倒数第三位表示当前对象是否为饥饿模式，0为正常模式，1为饥饿模式。</span></span><br><span class="line"></span><br><span class="line">    mutexWaiterShift = <span class="literal">iota</span> <span class="comment">// 3，从倒数第四位往前的bit位表示在排队等待的goroutine数</span></span><br><span class="line"></span><br><span class="line">    starvationThresholdNs = <span class="number">1e6</span> <span class="comment">// 1ms 切换到饥饿模式的阈值</span></span><br><span class="line"></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="1-2-正常模式和饥饿模式"><a href="#1-2-正常模式和饥饿模式" class="headerlink" title="1.2 正常模式和饥饿模式"></a>1.2 正常模式和饥饿模式</h3><p>Mutex 有两种模式：</p><ul><li>正常模式；</li><li>饥饿模式。</li></ul><p><strong>在正常模式下</strong>，锁的等待者会按照先进先出的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine 超过 1ms 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被<strong>饿死</strong>。</p><blockquote><p><strong>引入饥饿模式的目的是保证互斥锁的公平性。</strong></p><p>说明 Mutex 是公平锁。</p></blockquote><p><strong>在饥饿模式中</strong>，互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间少于 1ms，那么当前的互斥锁就会切换回正常模式。</p><blockquote><p>与饥饿模式相比，正常模式下的互斥锁能够提供更好地性能，饥饿模式的能避免 Goroutine 由于陷入等待无法获取锁而造成的高尾延时。</p></blockquote><p>这里贴一下源码中的注释</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Mutex fairness.</span><br><span class="line"></span><br><span class="line">Mutex can be in 2 modes of operations: normal and starvation.</span><br><span class="line">In normal mode waiters are queued in FIFO order, but a woken up waiter</span><br><span class="line">does not own the mutex and competes with new arriving goroutines over</span><br><span class="line">the ownership. New arriving goroutines have an advantage -- they are</span><br><span class="line">already running on CPU and there can be lots of them, so a woken up</span><br><span class="line">waiter has good chances of losing. In such case it is queued at front</span><br><span class="line">of the wait queue. If a waiter fails to acquire the mutex for more than 1ms,</span><br><span class="line">it switches mutex to the starvation mode.</span><br><span class="line"></span><br><span class="line">In starvation mode ownership of the mutex is directly handed off from</span><br><span class="line">the unlocking goroutine to the waiter at the front of the queue.</span><br><span class="line">New arriving goroutines don&#x27;t try to acquire the mutex even if it appears</span><br><span class="line">to be unlocked, and don&#x27;t try to spin. Instead they queue themselves at</span><br><span class="line">the tail of the wait queue.</span><br><span class="line"></span><br><span class="line">If a waiter receives ownership of the mutex and sees that either</span><br><span class="line">(1) it is the last waiter in the queue, or (2) it waited for less than 1 ms,</span><br><span class="line">it switches mutex back to normal operation mode.</span><br><span class="line"></span><br><span class="line">Normal mode has considerably better performance as a goroutine can acquire</span><br><span class="line">a mutex several times in a row even if there are blocked waiters.</span><br><span class="line">Starvation mode is important to prevent pathological cases of tail latency.</span><br></pre></td></tr></table></figure><h2 id="2-加解锁过程"><a href="#2-加解锁过程" class="headerlink" title="2 加解锁过程"></a>2 加解锁过程</h2><p>在<code>sync</code>包中 中定义了 Locker 接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/mutex.go 31 行</span></span><br><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">        Lock()</span><br><span class="line">        Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Mutex 实现了 Locker 接口。除了互斥锁 Mutex 之外读写锁 RWMutex，也实现了 Locker 接口。</p><h3 id="2-1-Lock"><a href="#2-1-Lock" class="headerlink" title="2.1 Lock"></a>2.1 Lock</h3><p>互斥锁的加锁是靠 Mutex.Lock 方法完成的，以下代码进行了简化，省略了 race 相关代码，只保留主干部分：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/mutex.go 72 行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line"><span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Slow path (outlined so that the fast path can be inlined)</span></span><br><span class="line">m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，整个加锁过程分为 Fast path 和 Slow Path。</p><h4 id="2-1-1-Fast-path"><a href="#2-1-1-Fast-path" class="headerlink" title="2.1.1 Fast path"></a>2.1.1 Fast path</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 m.state 为 0,说明当前锁为未锁定状态，将其设置为 1。</p><p>这也是最简单的部分，直接通过一个 CAS 操作，尝试获取锁。</p><h4 id="2-1-2-Slow-Path"><a href="#2-1-2-Slow-Path" class="headerlink" title="2.1.2 Slow Path"></a>2.1.2 Slow Path</h4><p>如果互斥锁的状态不是 0 时就会进入 Slow Path。尝试通过自旋（Spinnig）等方式等待锁的释放，该方法的主体是一个非常大 for 循环，这里将它分成几个部分介绍获取锁的过程：</p><ul><li>1）判断当前 Goroutine 能否进入自旋；</li><li>2）通过自旋等待互斥锁的释放；</li><li>3）计算互斥锁的最新状态；</li><li>4）更新互斥锁的状态并获取锁；</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> lockSlow() &#123;</span><br><span class="line">   <span class="keyword">var</span> waitStartTime <span class="type">int64</span></span><br><span class="line">   starving := <span class="literal">false</span></span><br><span class="line">   awoke := <span class="literal">false</span></span><br><span class="line">   iter := <span class="number">0</span></span><br><span class="line">   old := m.state</span><br><span class="line">   <span class="keyword">for</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) &#123;</span><br><span class="line">         <span class="keyword">if</span> !awoke &amp;&amp; old&amp;mutexWoken == <span class="number">0</span> &amp;&amp; old&gt;&gt;mutexWaiterShift != <span class="number">0</span> &amp;&amp;</span><br><span class="line">            atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) &#123;</span><br><span class="line">            awoke = <span class="literal">true</span></span><br><span class="line">         &#125;</span><br><span class="line">         runtime_doSpin()</span><br><span class="line">         iter++</span><br><span class="line">         old = m.state</span><br><span class="line">         <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">new</span> := old</span><br><span class="line">   </span><br><span class="line">      <span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">         <span class="built_in">new</span> |= mutexLocked</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">         <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">         <span class="built_in">new</span> |= mutexStarving</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> awoke &#123;</span><br><span class="line">         <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">         &#125;</span><br><span class="line">         queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">         <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">            waitStartTime = runtime_nanotime()</span><br><span class="line">         &#125;</span><br><span class="line">         runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">         starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">         old = m.state</span><br><span class="line">         <span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">               throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">            <span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">               delta -= mutexStarving</span><br><span class="line">            &#125;</span><br><span class="line">            atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">         &#125;</span><br><span class="line">         awoke = <span class="literal">true</span></span><br><span class="line">         iter = <span class="number">0</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         old = m.state</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1）判断当前 Goroutine 能否进入自旋；</strong></p><p><strong>自旋是一种多线程同步机制</strong>，当前的进程在进入自旋的过程中会一直保持 CPU 的占用，持续检查某个条件是否为真。<strong>在多核的 CPU 上，自旋可以避免 Goroutine 的切换</strong>，使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 Goroutine 进入自旋的条件非常苛刻：</p><ul><li>1）互斥锁只有在普通模式才能进入自旋；</li><li>2）<code>runtime.sync_runtime_canSpin</code>需要返回 true<ul><li>运行在多 CPU 的机器上；</li><li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li><li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/proc.go 6364 行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_canSpin</span><span class="params">(i <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> i &gt;= active_spin || ncpu &lt;= <span class="number">1</span> || gomaxprocs &lt;= <span class="type">int32</span>(sched.npidle+sched.nmspinning)+<span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> p := getg().m.p.ptr(); !runqempty(p) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）通过自旋等待互斥锁的释放；</strong></p><p>一旦当前 Goroutine 能够进入自旋就会调用<code>runtime.sync_runtime_doSpin</code>和<code>runtime.procyield</code>执行 30 次的 <code>PAUSE</code> 指令，该指令只会占用 CPU 并消耗 CPU 时间：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/proc.go 6381 行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_doSpin</span><span class="params">()</span></span> &#123;</span><br><span class="line">procyield(active_spin_cnt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// runtime/asm_386.s 574 行</span><br><span class="line">TEXT runtime·procyield(SB),NOSPLIT,$0-0</span><br><span class="line">MOVLcycles+0(FP), AX</span><br><span class="line">again:</span><br><span class="line">PAUSE</span><br><span class="line">SUBL$1, AX</span><br><span class="line">JNZagain</span><br><span class="line">RET</span><br></pre></td></tr></table></figure><p><strong>3）计算互斥锁的最新状态；</strong></p><p> 处理了自旋相关的特殊逻辑之后，互斥锁会根据上下文计算当前互斥锁最新的状态。几个不同的条件分别会更新 <code>state</code> 字段中存储的不同信息 — <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 和 <code>mutexWaiterShift</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">new</span> := old</span><br><span class="line"><span class="keyword">if</span> old&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">new</span> |= mutexLocked</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">new</span> += <span class="number">1</span> &lt;&lt; mutexWaiterShift</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> starving &amp;&amp; old&amp;mutexLocked != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">new</span> |= mutexStarving</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> awoke &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexWoken == <span class="number">0</span> &#123;</span><br><span class="line">        throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">new</span> &amp;^= mutexWoken</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4）更新互斥锁的状态并获取锁；</strong></p><p>计算了新的互斥锁状态之后，会使用 CAS 函数更新状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> old&amp;(mutexLocked|mutexStarving) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// locked the mutex with CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">    queueLifo := waitStartTime != <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123;</span><br><span class="line">        waitStartTime = runtime_nanotime()</span><br><span class="line">    &#125;</span><br><span class="line">    runtime_SemacquireMutex(&amp;m.sema, queueLifo, <span class="number">1</span>)</span><br><span class="line">    starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">    old = m.state</span><br><span class="line">    <span class="keyword">if</span> old&amp;mutexStarving != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> old&amp;(mutexLocked|mutexWoken) != <span class="number">0</span> || old&gt;&gt;mutexWaiterShift == <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">&quot;sync: inconsistent mutex state&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        delta := <span class="type">int32</span>(mutexLocked - <span class="number">1</span>&lt;&lt;mutexWaiterShift)</span><br><span class="line">        <span class="keyword">if</span> !starving || old&gt;&gt;mutexWaiterShift == <span class="number">1</span> &#123;</span><br><span class="line">            delta -= mutexStarving</span><br><span class="line">        &#125;</span><br><span class="line">        atomic.AddInt32(&amp;m.state, delta)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    awoke = <span class="literal">true</span></span><br><span class="line">    iter = <span class="number">0</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    old = m.state</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有通过 CAS 获得锁，会调用 <code>runtime.sync_runtime_SemacquireMutex</code> 通过信号量保证资源不会被两个 Goroutine 获取。</p><p><code>runtime.sync_runtime_SemacquireMutex</code> 会在方法中不断尝试获取锁并陷入休眠等待信号量的释放，一旦当前 Goroutine 可以获取信号量，它就会立刻返回，<code>sync.Mutex.Lock</code>的剩余代码也会继续执行。</p><ul><li>在正常模式下，这段代码会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环；</li><li>在饥饿模式下，当前 Goroutine 会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出；</li></ul><p>其中还包含了状态切换的部分逻辑:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> waitStartTime <span class="type">int64</span></span><br><span class="line"><span class="keyword">for</span>&#123; <span class="comment">// for 循环里尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> waitStartTime == <span class="number">0</span> &#123; <span class="comment">// waitStartTime 只有第一次执行时才会赋值</span></span><br><span class="line">        waitStartTime = runtime_nanotime()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果等待时间超过 1ms 则切换到饥饿模式</span></span><br><span class="line">    starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-Unlock"><a href="#2-2-Unlock" class="headerlink" title="2.2 Unlock"></a>2.2 Unlock</h3><p>相比之下互斥锁的解锁过程就比较简单,同样分为 Fast path 和 Slow path。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Unlock() &#123;</span><br><span class="line"><span class="comment">// Fast path: drop lock bit.</span></span><br><span class="line"><span class="built_in">new</span> := atomic.AddInt32(&amp;m.state, -mutexLocked)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">new</span> != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// Outlined slow path to allow inlining the fast path.</span></span><br><span class="line"><span class="comment">// To hide unlockSlow during tracing we skip one extra frame when tracing GoUnblock.</span></span><br><span class="line">m.unlockSlow(<span class="built_in">new</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-1-Fast-path"><a href="#2-2-1-Fast-path" class="headerlink" title="2.2.1 Fast path"></a>2.2.1 Fast path</h4><p>该过程会先使用<code>atomic.AddInt32函数快速解锁，这时会发生下面的两种情况：</code></p><ul><li>如果该函数返回的新状态等于 0，当前 Goroutine 就成功解锁了互斥锁；</li><li>如果该函数返回的新状态不等于 0，则进入 Slow path。</li></ul><h4 id="2-2-2-Slow-path"><a href="#2-2-2-Slow-path" class="headerlink" title="2.2.2 Slow path"></a>2.2.2 Slow path</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> unlockSlow(<span class="built_in">new</span> <span class="type">int32</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">      throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123;</span><br><span class="line">      old := <span class="built_in">new</span></span><br><span class="line">      <span class="keyword">for</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> old&gt;&gt;mutexWaiterShift == <span class="number">0</span> || old&amp;(mutexLocked|mutexWoken|mutexStarving) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">new</span> = (old - <span class="number">1</span>&lt;&lt;mutexWaiterShift) | mutexWoken</span><br><span class="line">         <span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, old, <span class="built_in">new</span>) &#123;</span><br><span class="line">            runtime_Semrelease(&amp;m.sema, <span class="literal">false</span>, <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">         &#125;</span><br><span class="line">         old = m.state</span><br><span class="line">      &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      runtime_Semrelease(&amp;m.sema, <span class="literal">true</span>, <span class="number">1</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先校验锁状态的合法性 — 如果当前互斥锁已经被解锁过了会直接抛出异常 “sync: unlock of unlocked mutex” 中止当前程序。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">new</span>+mutexLocked)&amp;mutexLocked == <span class="number">0</span> &#123;</span><br><span class="line">    throw(<span class="string">&quot;sync: unlock of unlocked mutex&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后根据当前锁模式分别处理</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="built_in">new</span>&amp;mutexStarving == <span class="number">0</span> &#123; <span class="comment">// 正常模式</span></span><br><span class="line">    </span><br><span class="line">&#125;<span class="keyword">else</span>&#123; <span class="comment">// 饥饿模式</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在正常模式下，上述代码会使用如下所示的处理过程：</p><ul><li>如果互斥锁不存在等待者或者互斥锁的 <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 状态不都为 0，那么当前方法可以直接返回，不需要唤醒其他等待者；</li><li>如果互斥锁存在等待者，会通过<code>runtime_Semrelease</code>唤醒等待者并移交锁的所有权；</li></ul><p>在饥饿模式下，上述代码会直接调用<code>runtime_Semrelease</code>将当前锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁，在这时互斥锁还不会退出饥饿状态；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/sema.go 65行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_Semrelease</span><span class="params">(addr *<span class="type">uint32</span>, handoff <span class="type">bool</span>, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">semrelease1(addr, handoff, skipframes)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">semrelease1</span><span class="params">(addr *<span class="type">uint32</span>, handoff <span class="type">bool</span>, skipframes <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">root := semroot(addr)</span><br><span class="line">atomic.Xadd(addr, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;root.nwait) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Harder case: search for a waiter and wake it.</span></span><br><span class="line">lockWithRank(&amp;root.lock, lockRankRoot)</span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;root.nwait) == <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;root.lock)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">s, t0 := root.dequeue(addr)</span><br><span class="line"><span class="keyword">if</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">atomic.Xadd(&amp;root.nwait, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;root.lock)</span><br><span class="line"><span class="keyword">if</span> s != <span class="literal">nil</span> &#123; <span class="comment">// May be slow or even yield, so unlock first</span></span><br><span class="line">acquiretime := s.acquiretime</span><br><span class="line"><span class="keyword">if</span> acquiretime != <span class="number">0</span> &#123;</span><br><span class="line">mutexevent(t0-acquiretime, <span class="number">3</span>+skipframes)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> s.ticket != <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;corrupted semaphore ticket&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> handoff &amp;&amp; cansemacquire(addr) &#123;</span><br><span class="line">s.ticket = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">readyWithTime(s, <span class="number">5</span>+skipframes)</span><br><span class="line"><span class="keyword">if</span> s.ticket == <span class="number">1</span> &amp;&amp; getg().m.locks == <span class="number">0</span> &#123;</span><br><span class="line">goyield()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p>互斥锁的<strong>加锁过程</strong>比较复杂，它涉及自旋、信号量以及调度等概念：</p><ul><li>如果互斥锁处于初始化状态，会通过置位 <code>mutexLocked</code> 加锁；</li><li>如果互斥锁处于 <code>mutexLocked</code> 状态并且在普通模式下工作，会进入自旋，执行 30 次 <code>PAUSE</code> 指令消耗 CPU 时间等待锁的释放；</li><li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li><li>互斥锁在正常情况下会通过<code>sync_runtime_SemacquireMutex</code>将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；</li><li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式；</li></ul><p>互斥锁的<strong>解锁过程</strong>与之相比就比较简单：</p><ul><li>当互斥锁已经被解锁时，调用 Mutex.Lock 会直接抛出异常；</li><li>当互斥锁处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 <code>mutexLocked</code> 标志位；</li><li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，会直接返回；在其他情况下会通过<code>sync.runtime_Semrelease</code> 唤醒对应的 Goroutine；</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/04/16/LLM/Agent/"/>
      <url>/2025/04/16/LLM/Agent/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/04/16/LLM/RAG/"/>
      <url>/2025/04/16/LLM/RAG/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2025/04/16/LLM/Prompt%20Engineering/"/>
      <url>/2025/04/16/LLM/Prompt%20Engineering/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/18/DevOps/Docker/"/>
      <url>/2024/07/18/DevOps/Docker/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2024/07/01/DevOps/K8S/"/>
      <url>/2024/07/01/DevOps/K8S/</url>
      
        <content type="html"><![CDATA[<ul><li>k8s<ul><li>docker<ul><li>实现原理<ul><li>namespace</li><li>cgroup</li><li>chroot</li></ul></li><li>镜像<ul><li>分层结构<ul><li>rootfs</li></ul></li><li>Dockerfile<ul><li>FROM</li><li>COPY</li><li>RUN</li><li>CMD</li></ul></li><li>镜像仓库</li></ul></li><li>命令<ul><li>ps</li><li>images</li><li>build</li><li>run</li><li>pull/push</li><li>save/load</li></ul></li></ul></li><li>架构<ul><li>master<ul><li>apiserver</li><li>etcd</li><li>scheduler</li><li>controller-manager</li></ul></li><li>node<ul><li>kubelet</li><li>kube-proxy</li><li>container-runtime</li></ul></li></ul></li><li>kubelet<ul><li>get</li><li>run</li><li>exec</li><li>apply</li><li>describe</li><li>explain</li></ul></li><li>api对象<ul><li>yaml语言</li><li>Pod</li><li>Job/CronJob</li><li>ConfigMap/Secret</li><li>Deployment<ul><li>kubectl scale</li><li>replicas</li><li>selector</li></ul></li><li>DaemonSet<ul><li>守护进程</li></ul></li><li>StatefulSet<ul><li>有状态应用</li></ul></li><li>Service<ul><li>负载均衡</li><li>iptables</li><li>kubectl expose</li></ul></li><li>Ingress<ul><li>Ingress-Controller</li></ul></li></ul></li><li>持久化存储<ul><li>PVC</li><li>NFS</li></ul></li><li>网络插件<ul><li>flannel</li><li>calico</li></ul></li></ul></li></ul><p>构建镜像</p><ul><li>docker build -f article-api.dockerfile -t article-api:v1.0.0 .<br>查看镜像</li><li>docker images | grep ‘article-api’<br>生成Deployment</li><li>goctl kube deploy -name article-api -namespace beyond -image article-api:v1.0.0 -port 80 -o article-api.yaml<br>打包、拷贝、解压镜像</li><li>docker save -o article-api.tar article-api:v1.0.0</li><li>scp ./article-api.tar zsg@192.168.56.3:/home/zsg/images</li><li>docker load —input article-api.tar</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/11/02/DevOps/%E7%9F%A5%E5%B7%B1%E4%B8%8A%E4%BA%91/"/>
      <url>/2023/11/02/DevOps/%E7%9F%A5%E5%B7%B1%E4%B8%8A%E4%BA%91/</url>
      
        <content type="html"><![CDATA[<p>STKE 提供的 HPA 能力能够很好的满足知几对扩缩容的需求，知几同时使用了定时 HPA 和动态 HAP 满足不同的场景：</p><ul><li>针对突发流量， 知几采用 CPU request 和内存 request 作为触发扩容的条件。</li><li>节假日和周五、六晚未成年人游戏上线，知几采用周定时 HPA 提前扩容。</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/gBXSicjuwMvE0DQ8sSf45n8FicIXxprYlNGMicaf7MMKK4leVEHNQxhsJ6OxWLdWxZKauYkGfq5icgnPjwibQGqehrQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><p>这样很大程度上减少了开发、运维同学面对运营活动和突发流量时的心智负担，提高了服务稳定性。特别是定时 HPA，可以很方便的满足知几在未成年人保护方面对扩缩容的要求，系统可以在特定时间段完成系统容量的扩容和缩容，在保证系统平稳应对流量的同时也不会造成对资源的浪费。迁移上云后，知几通过这种方式保证了周末时段和线上多场运营活动的平稳进行。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/gBXSicjuwMvE0DQ8sSf45n8FicIXxprYlNIMxLkne6debgic5fyjau3WsZibMU3kSvEibLa6VpCib2sez4bUCicP37XVw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h3 id="1-可观测性"><a href="#1-可观测性" class="headerlink" title="1 可观测性"></a>1 可观测性</h3><p>系统的可观测性能够让开发同学根据系统输出快速监控、定位问题。可观测性可以从 Metrics、Log、Trace 三个方面来看。</p><ul><li><strong>Metrics</strong>，知几服务大部分对接的是 Monitor 系统，通过自定义 metircs 上报实现模调信息、服务状态、业务等指标的监控，知几封装了 Monitor 的标准库实现指标模板的标准化和上报。Monitor 上报需要通过 http 请求获取上报的 ip 再将数据通过 tcp 形式发送到 Monitor 侧，这种形式的上报对业务并不友好，Monitor 当前也已不再接入新的业务，目前知几正逐步将 Metrics 迁移到智研监控系统，trpc 提供插件接入智研监控能力。</li><li><strong>Log</strong>，早期知几上云时采用的 filebeat 采集日志，现在 stke 提供了统一的日志数据解决方案 CLS，可以方便的进行日志采集、存储、检索，运维成本较低，体验较好。</li><li><strong>Trace</strong>，知几接入天机阁来对请求做 traceing，记录系统的请求链路等上下文信息。通过 traceId 对请求进行标记染色很大程度上提升了问题定位的效率。在此基础上，知几同时也在尝试 dapr[2] 这类新的分布式应用开发组件，dapr 提供的可观测性的无感知接入，相比天机阁等侵入式的接入方式，成本更低。</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/gBXSicjuwMvE0DQ8sSf45n8FicIXxprYlNpjxQQNVZy5e36lgIIU4qCsfOkmV6U3wFJ7vB5iaciaHEZUhSU4IibVraA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p><h3 id="2-业务稳定是第一位"><a href="#2-业务稳定是第一位" class="headerlink" title="2 业务稳定是第一位"></a>2 业务稳定是第一位</h3><p>在云原生提分实践过程中，发现很多模块的瓶颈并不是 CPU，而是流量或者内存，但是目前云原生的计算方式只计算 CPU，所以制定 HPA 扩缩容策略时需要综合各维度去考虑。</p><h3 id="3-降低-request-值"><a href="#3-降低-request-值" class="headerlink" title="3 降低 request 值"></a>3 降低 request 值</h3><p>对于某些流量型的模块如 http、preupload和 prxoy，可以把 workoad 的 request 的值适当降低，这样可以让 CPU 利用率的提升有立竿见影的效果，需要结合压力测试来确认 request 降低后 CPU 不会成为瓶颈。</p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5NjA1MjkxNw==&amp;mid=2247521650&amp;idx=1&amp;sn=6a13f20045cb4aae49ae7ad82256c25c&amp;chksm=c0042ea8f773a7beaa3daeff95afc8eecd03187d650d70c483e96fa1ee03c03e002c5f10d97e&amp;scene=178&amp;cur_album_id=1487567830194667526#rd">https://mp.weixin.qq.com/s?__biz=Mzg5NjA1MjkxNw==&amp;mid=2247521650&amp;idx=1&amp;sn=6a13f20045cb4aae49ae7ad82256c25c&amp;chksm=c0042ea8f773a7beaa3daeff95afc8eecd03187d650d70c483e96fa1ee03c03e002c5f10d97e&amp;scene=178&amp;cur_album_id=1487567830194667526#rd</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/31/DevOps/%E4%BA%91%E8%AE%A1%E7%AE%97%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/10/31/DevOps/%E4%BA%91%E8%AE%A1%E7%AE%97%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="云原生概论"><a href="#云原生概论" class="headerlink" title="云原生概论"></a>云原生概论</h2><h3 id="1-云原生的定义"><a href="#1-云原生的定义" class="headerlink" title="1. 云原生的定义"></a>1. 云原生的定义</h3><ul><li>模块化</li><li>可观测性</li><li>可测试性</li><li>可处理性</li><li>可替换性<blockquote><p>云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。</p></blockquote></li></ul><h3 id="2-云原生的目标"><a href="#2-云原生的目标" class="headerlink" title="2. 云原生的目标"></a>2. 云原生的目标</h3><ul><li>可用（Available）：通过各种机制来实现应用的高可用，以保证服务提供的连续性。</li><li>规模（Scale）：要求云原生服务能够适应不同的规模（包括但不限于用户规模/部署规模/请求量），并能够在部署时动态分配资源，以便在不同的规模之间快速和平滑的伸缩。典型场景如：<ul><li>初创公司或新产品线快速成长，用户规模和应用部署规模在短时间内十倍百倍增长。</li><li>促销、季节性、节假日带来的访问量波动。</li><li>高峰时间段的突发流量等。</li></ul></li><li>敏捷（Agility）：快速响应市场需求。</li><li>成本（Cost）：充分有效的利用资源。<h3 id="3-云原生代表技术"><a href="#3-云原生代表技术" class="headerlink" title="3. 云原生代表技术"></a>3. 云原生代表技术</h3><h4 id="3-1-容器技术"><a href="#3-1-容器技术" class="headerlink" title="3.1. 容器技术"></a>3.1. 容器技术</h4><h4 id="3-2-微服务"><a href="#3-2-微服务" class="headerlink" title="3.2. 微服务"></a>3.2. 微服务</h4><h4 id="3-3-服务网格"><a href="#3-3-服务网格" class="headerlink" title="3.3. 服务网格"></a>3.3. 服务网格</h4><h4 id="3-4-不可变基础设施"><a href="#3-4-不可变基础设施" class="headerlink" title="3.4. 不可变基础设施"></a>3.4. 不可变基础设施</h4><h4 id="3-5-声明式设计"><a href="#3-5-声明式设计" class="headerlink" title="3.5. 声明式设计"></a>3.5. 声明式设计</h4><h4 id="3-6-DevOps"><a href="#3-6-DevOps" class="headerlink" title="3.6. DevOps"></a>3.6. DevOps</h4></li></ul><h2 id="容器技术概论和实践"><a href="#容器技术概论和实践" class="headerlink" title="容器技术概论和实践"></a>容器技术概论和实践</h2><h3 id="1-容器技术的优点"><a href="#1-容器技术的优点" class="headerlink" title="1. 容器技术的优点"></a>1. 容器技术的优点</h3><p>容器本质上是受到资源限制，彼此间相互隔离的若干个 Linux 进程集合。容器技术借助 cgroups、namespace，以及 Linux 内核等技术从而应用可以在沙箱环境中独立运行，从而避免之间的冲突和影响</p><ul><li><strong>轻量</strong>： 容器共享计算机操作系统内核，无需为每个应用程序提供完整的操作系统实例，容器体积更小，依赖更少。与虚拟机相比，这意味着可以快速运行，更好地支持横向扩展的云原生应用程序。</li><li><strong>可移植且平台独立</strong>： 容器包含所有的依赖关系，这意味着软件一次编写即可运行，交付时无需再配置各类环境。由于跨平台部署的可移植性/一致性以及体积优势，容器非常适用于如 DevOps、Serverless 以及微服务这类的现代开发和应用模式。</li><li><strong>利用率高</strong>：容器结合容器编排系统如 Kubernetes 可以更精细地部署和扩展应用组件，实现资源利用以及业务稳定、可靠运行之间的平衡。<h3 id="2-容器技术的核心原理"><a href="#2-容器技术的核心原理" class="headerlink" title="2. 容器技术的核心原理"></a>2. 容器技术的核心原理</h3><h4 id="2-1-Namespace-资源隔离"><a href="#2-1-Namespace-资源隔离" class="headerlink" title="2.1. Namespace 资源隔离"></a>2.1. Namespace 资源隔离</h4>Linux Namespace 提供了一种内核级别隔离系统资源的方法，通过将系统的全局资源放在不同的 Namespace 中来实现资源隔离的目的。<h4 id="2-2-Cgroups-资源限制"><a href="#2-2-Cgroups-资源限制" class="headerlink" title="2.2. Cgroups 资源限制"></a>2.2. Cgroups 资源限制</h4>Cgroups 全称是 Control Groups，是 Linux 内核提供的一种可以限制单个或者多个进程多所使用物理资源的机制，可以对 CPU、内存、I/O、网络等资源实现精准的控制。</li><li>资源限制：对进程组使用的资源总额进行限制。</li><li>优先级分配：通过分配 CPU 时间片与硬盘 I/O，控制进程运行优先级。</li><li>资源统计： 统计进程、系统实际资源使用量。</li><li>进程控制：对进程组执行挂起、恢复等操作。<h4 id="2-3-UnionFs-联合文件系统"><a href="#2-3-UnionFs-联合文件系统" class="headerlink" title="2.3. UnionFs 联合文件系统"></a>2.3. UnionFs 联合文件系统</h4>联合文件系统（Union File System， UnionFs）它可以不同物理位置的目录合并、挂载到同一个目录中，而实际上目录的物理位置是分开的。UnionFs 把文件系统的每一次修改作为一个个层进行叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/09/Algorithm/%E8%B7%B3%E8%A1%A8/"/>
      <url>/2023/10/09/Algorithm/%E8%B7%B3%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">![图片](file:///Users/caotianlong/Documents/%E5%88%B7%E9%A2%98/%E7%83%AD%E9%97%A8%E5%AE%9E%E7%8E%B0/img/640-20230911011754301.png?lastModify=1694370430)</span><br><span class="line"></span><br><span class="line">## 1 核心性质</span><br><span class="line"></span><br><span class="line">- 跳表由多层索引结构组成</span><br><span class="line">- 每次节点个数接近于相邻下层节点数的一半</span><br><span class="line">- 对于一个 m 层存在的节点，在 1~m-1层中这个节点也一定存在</span><br><span class="line">- 为保证连贯性，跳表额外补充了本身不存储数据的头节点和尾节点，作为起点和终点</span><br><span class="line">- 头节点和尾节点的高度是动态扩缩的，其高度取决于当前跳表内数据节点的最大高度</span><br><span class="line">- 跳表的”跳“字体现在，在高层检索时，每跳过一个节点，实际上都过滤跳过了底层的大量数据，从而实现检索加速</span><br><span class="line">## 2 数据结构定义</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line"> // 跳表的数据结构 Skiplist  </span><br><span class="line"> type Skiplist struct &#123;  </span><br><span class="line">     head *node  </span><br><span class="line"> &#125;  </span><br><span class="line"> // 节点定义  </span><br><span class="line"> type node struct &#123;  </span><br><span class="line">     // 长度为当前节点的高度  </span><br><span class="line">     nexts    []*node  </span><br><span class="line">     key, val int  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="3-读流程"><a href="#3-读流程" class="headerlink" title="3 读流程"></a>3 读流程</h2><ul><li>以 head 节点作为起点</li><li>从当前跳表存在的最大高度出发</li><li>倘若右侧节点 key 值小于 target，则持续向右遍历</li><li>倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回</li><li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li><li>重复（3）-（5）步</li><li>倘若已经抵达第1层仍然找到不到 target，则返回 key 不存在的信息</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 根据 key 读取 val，第二个 bool flag 反映 key 在 skiplist 中是否存在  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Get(key <span class="type">int</span>) (<span class="type">int</span>, <span class="type">bool</span>) &#123;  </span><br><span class="line">     <span class="comment">// 根据 key 尝试检索对应的 node，如果 node 存在，则返回对应的 val  </span></span><br><span class="line">     <span class="keyword">if</span> _node := s.search(key); _node != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> _node.val, <span class="literal">true</span>  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">false</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 从跳表中检索 key 对应的 node  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> search(key <span class="type">int</span>) *node &#123;  </span><br><span class="line">     <span class="comment">// 每次检索从头部出发  </span></span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="comment">// 每次检索从最大高度出发，直到来到首层  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="comment">// 在每一层中持续向右遍历，直到下一个节点不存在或者 key 值大于等于 key  </span></span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; key &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 如果 key 值相等，则找到了目标直接返回  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key == key &#123;  </span><br><span class="line">             <span class="keyword">return</span> move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 当前层没找到目标，则层数减 1，继续向下  </span></span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">// 遍历完所有层数，都没有找到目标，返回 nil  </span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="4-写流程"><a href="#4-写流程" class="headerlink" title="4 写流程"></a>4 写流程</h2><ul><li>首先基于读流程检索出 key 对应的节点是否存在，倘若存在，则对值进行更新并直接返回</li><li>随机出新插入节点的高度；倘若新插入节点的高度大于当前跳表的最大高度，则需要对起点和终点的高度进行扩容</li><li>以 head 节点作为起点，从当前跳表存在的最大高度出发</li><li>倘若右侧节点 key 值小于 target，则持续向右遍历</li><li>倘若右侧节点为终点（nil）或者 key 值大于 target，则在该空隙插入新节点，并降低高度进入下一层</li><li>重复（4）-（5）步</li><li>倘若已经进入第 1 层，插入新节点后即可返回<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> (<span class="string">&quot;math/rand&quot;</span>)  </span><br><span class="line"> roll 骰子，决定一个待插入的新节点在 skiplist 中最高层对应的 index  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> roll() <span class="type">int</span> &#123;  </span><br><span class="line">     <span class="keyword">var</span> level <span class="type">int</span>  </span><br><span class="line">     <span class="comment">// 每次投出 1，则层数加 1  </span></span><br><span class="line">     <span class="keyword">for</span> rand.Int() &gt; <span class="number">0</span> &#123;  </span><br><span class="line">         level++  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> level  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 将 key-val 对加入 skiplist  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Put(key, val <span class="type">int</span>) &#123;  </span><br><span class="line">     <span class="comment">// 假如 kv对已存在，则直接对值进行更新并返回  </span></span><br><span class="line">     <span class="keyword">if</span> _node := s.search(key); _node != <span class="literal">nil</span> &#123;  </span><br><span class="line">         _node.val = val  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// roll 出新节点的高度  </span></span><br><span class="line">     level := s.roll()  </span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 新节点高度超出跳表最大高度，则需要对高度进行补齐  </span></span><br><span class="line">     <span class="keyword">for</span> <span class="built_in">len</span>(s.head.nexts)<span class="number">-1</span> &lt; level &#123;  </span><br><span class="line">         s.head.nexts = <span class="built_in">append</span>(s.head.nexts, <span class="literal">nil</span>)  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 创建出新的节点  </span></span><br><span class="line">     newNode := node&#123;  </span><br><span class="line">         key:   key,  </span><br><span class="line">         val:   val,  </span><br><span class="line">         nexts: <span class="built_in">make</span>([]*node, level+<span class="number">1</span>),  </span><br><span class="line">     &#125;  </span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 从头节点的最高层出发  </span></span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="keyword">for</span> level := level; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="comment">// 向右遍历，直到右侧节点不存在或者 key 值大于 key  </span></span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; key &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 调整指针关系，完成新节点的插入  </span></span><br><span class="line">         newNode.nexts[level] = move.nexts[level]  </span><br><span class="line">         move.nexts[level] = &amp;newNode  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure></li></ul><h2 id="删流程"><a href="#删流程" class="headerlink" title="删流程"></a>删流程</h2><ul><li>以 head 节点作为起点，从当前跳表存在的最大高度出发</li><li>倘若右侧节点 key 值小于 target，则持续向右遍历</li><li>倘若右侧节点为终点（nil）或者 key 值大于 target，则在该空隙插入新节点，并降低高度进入下一层</li><li>倘若右侧节点 key 值等于 target，则代表找到目标</li><li>找到目标值后，沿当前节点层层向下，依次将每层中的目标节点删除</li><li>倘若已经进入第 1 层仍然没有找到节点，说明节点不存在，删除失败</li><li><p>倘若删除成功，需要尝试对跳表的整体高度进行缩容，即需要对高度递减，直到确定最大高度对应的层数上至少存在一个有效的数据节点为止</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 key 从跳表中删除对应的节点  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Del(key <span class="type">int</span>) &#123;  </span><br><span class="line">     <span class="comment">// 如果 kv 对不存在，则无需删除直接返回  </span></span><br><span class="line">     <span class="keyword">if</span> _node := s.search(key); _node == <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 从头节点的最高层出发      </span></span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="comment">// 向右遍历，直到右侧节点不存在或者 key 值大于等于 key  </span></span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; key &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">           </span><br><span class="line">         <span class="comment">// 右侧节点不存在或者 key 值大于 target，则直接跳过  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] == <span class="literal">nil</span> || move.nexts[level].key &gt; key&#123;  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">         &#125;      </span><br><span class="line">         <span class="comment">// 走到此处意味着右侧节点的 key 值必然等于 key，则调整指针引用  </span></span><br><span class="line">         move.nexts[level] = move.nexts[level].nexts[level]  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 对跳表的最大高度进行更新  </span></span><br><span class="line">     <span class="keyword">var</span> dif <span class="type">int</span>  </span><br><span class="line">     <span class="comment">// 倘若某一层已经不存在数据节点，高度需要递减  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt; <span class="number">0</span> &amp;&amp; s.head.nexts[level] == <span class="literal">nil</span>; level-- &#123;  </span><br><span class="line">         dif++  </span><br><span class="line">     &#125;  </span><br><span class="line">     s.head.nexts = s.head.nexts[:<span class="built_in">len</span>(s.head.nexts)-dif]  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="5-RANGE-流程"><a href="#5-RANGE-流程" class="headerlink" title="5 RANGE 流程"></a>5 RANGE 流程</h2></li><li>以 head 节点作为起点</li><li>从当前跳表存在的最大高度出发</li><li>倘若右侧节点 key 值小于 target，则持续向右遍历</li><li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li><li>倘若右侧节点 key 值等于 target，则代表找到目标，直接沿该节点向下来到第1层</li><li><p>重复（3）-（5）步，直到来到第1层，接下来从首个大于等于 target 的节点出发，向右依次遍历，直到取满 range 区间的数据后返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到 skiplist 当中 ≥ start，且 ≤ end 的 kv 对  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Range(start, end <span class="type">int</span>) [][<span class="number">2</span>]<span class="type">int</span> &#123;  </span><br><span class="line">     <span class="comment">// 首先通过 ceiling 方法，找到 skiplist 中 key 值大于等于 start 且最接近于 start 的节点 ceilNode  </span></span><br><span class="line">     ceilNode := s.ceiling(start)  </span><br><span class="line">     <span class="comment">// 如果不存在，直接返回  </span></span><br><span class="line">     <span class="keyword">if</span> ceilNode == <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> [][<span class="number">2</span>]<span class="type">int</span>&#123;&#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 从 ceilNode 首层出发向右遍历，把所有位于 [start,end] 区间内的节点统统返回  </span></span><br><span class="line">     <span class="keyword">var</span> res [][<span class="number">2</span>]<span class="type">int</span>  </span><br><span class="line">     <span class="keyword">for</span> move := ceilNode; move != <span class="literal">nil</span> &amp;&amp; move.key &lt;= end; move = move.nexts[<span class="number">0</span>] &#123;  </span><br><span class="line">         res = <span class="built_in">append</span>(res, [<span class="number">2</span>]<span class="type">int</span>&#123;move.key, move.val&#125;)  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> res  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 找到 key 值大于等于 target 且 key 值最接近于 target 的节点  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> ceiling(target <span class="type">int</span>) *node &#123;  </span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="comment">// 自上而下，找到 key 值小于 target 且最接近 target 的 kv 对  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; target &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 如果 key 值等于 targe 的 kv 对存在，则直接返回  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key == target &#123;  </span><br><span class="line">             <span class="keyword">return</span> move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">// 此时 move 已经对应于在首层 key 值小于 key 且最接近于 key 的节点，其右侧第一个节点即为所寻找的目标节点  </span></span><br><span class="line">     <span class="keyword">return</span> move.nexts[<span class="number">0</span>]  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="CEILING-流程"><a href="#CEILING-流程" class="headerlink" title="CEILING 流程"></a>CEILING 流程</h2><ul><li>以 head 节点作为起点</li><li>从当前跳表存在的最大高度出发</li><li>倘若右侧节点 key 值小于 target，则持续向右遍历</li><li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li><li>倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回</li><li>重复（3）-（5）步，直到找到 key 值等于 target 的节点或者来到第1层，接下来获取到首个大于等于 target 的节点并返回</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 找到 skiplist 中，key 值大于等于 target 且最接近于 target 的 key-value 对  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Ceiling(target <span class="type">int</span>) ([<span class="number">2</span>]<span class="type">int</span>, <span class="type">bool</span>) &#123;  </span><br><span class="line">     <span class="keyword">if</span> ceilNode := s.ceiling(target); ceilNode != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;ceilNode.key, ceilNode.val&#125;, <span class="literal">true</span>  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;&#125;, <span class="literal">false</span>  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure><p> ​</p><h2 id="6-FLOOR-流程"><a href="#6-FLOOR-流程" class="headerlink" title="6 FLOOR 流程"></a>6 FLOOR 流程</h2><ul><li>以 head 节点作为起点</li><li>从当前跳表存在的最大高度出发</li><li>倘若右侧节点 key 值小于 target，则持续向右遍历</li><li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li><li>倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回</li><li><p>重复（3）-（5）步，直到找到 key 值等于 target 的节点或者来到第1层，接下来获取到首个小于等于 target 的节点并返回</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到 skiplist 中，key 值小于等于 target 且最接近于 target 的 key-value 对  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Floor(target <span class="type">int</span>) ([<span class="number">2</span>]<span class="type">int</span>, <span class="type">bool</span>) &#123;  </span><br><span class="line">     <span class="comment">// 引用 floor 方法，取 floorNode 值进行返回  </span></span><br><span class="line">     <span class="keyword">if</span> floorNode := s.floor(target); floorNode != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;floorNode.key, floorNode.val&#125;, <span class="literal">true</span>  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;&#125;, <span class="literal">false</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 找到 key 值小于等于 target 且 key 值最接近于 target 的节点  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> floor(target <span class="type">int</span>) *node &#123;  </span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="comment">// 自上而下，找到 key 值小于 target 且最接近 target 的 kv 对  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; target &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 如果 key 值等于 targe 的 kv对存在，则直接返回  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key == target &#123;  </span><br><span class="line">             <span class="keyword">return</span> move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// move 是首层中 key 值小于 target 且最接近 target 的节点，直接返回 move 即可  </span></span><br><span class="line">     <span class="keyword">return</span> move  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure><p>​<br>​</p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/09/Basic/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2023/10/09/Basic/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-硬件结构"><a href="#1-硬件结构" class="headerlink" title="1 硬件结构"></a>1 硬件结构</h2><ul><li>什么是中断？<ul><li>中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。</li></ul></li><li>什么是软中断？<ul><li>为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」</li><li><strong>上半部直接处理硬件请求，也就是硬中断</strong>，主要是负责耗时短的工作，特点是快速执行；</li><li><strong>下半部是由内核触发，也就说软中断</strong>，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；</li></ul></li></ul><h2 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2 内存管理"></a>2 内存管理</h2><h3 id="2-1-虚拟内存"><a href="#2-1-虚拟内存" class="headerlink" title="2.1 虚拟内存"></a>2.1 虚拟内存</h3><ul><li><em>虚拟地址</em>： 隔离不同进程，给每个进程独立的虚拟地址，并通过内存管理单元 MMU 映射到物理地址。</li><li><em>虚拟内存</em>：让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。  因为申请了不代表会用满，局部性原理<h3 id="2-2-内存分段"><a href="#2-2-内存分段" class="headerlink" title="2.2 内存分段"></a>2.2 内存分段</h3></li><li>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。<strong>不同的段是有不同的属性的，所以就用分段（<em>Segmentation</em>）的形式把这些段分离出来。</strong></li><li>分段机制下的虚拟地址由两部分组成，<strong>段选择因子</strong>和<strong>段内偏移量</strong>。<ul><li><strong>段选择子</strong>就保存在段寄存器里面。段选择子里面最重要的是<strong>段号</strong>，用作段表的索引。<strong>段表</strong>里面保存的是这个<strong>段的基地址、段的界限和特权等级</strong>等。</li><li>虚拟地址中的<strong>段内偏移量</strong>应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</li></ul></li><li>缺点：<strong>内存碎片</strong>，内存交换效率低<h3 id="2-3-内存分页"><a href="#2-3-内存分页" class="headerlink" title="2.3 内存分页"></a>2.3 内存分页</h3></li><li><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）。在 Linux 下，每一页的大小为 <code>4KB</code>。</li><li><strong>内存管理单元</strong> （<em>MMU</em>）将虚拟内存地址转换成物理地址</li><li>分页机制下，虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，<strong>页表</strong>包含物理页每页所在<strong>物理内存的基地址</strong>，这个基地址与页内偏移的组合就形成了物理内存地址</li><li><em>多级页表</em>：将页表（一级页表）分为 <code>1024</code> 个页表（二级页表），每个表（二级页表）中包含 <code>1024</code> 个「页表项」，形成<strong>二级分页</strong>。</li><li><em>快表 TLB</em>： 页表缓存、转址旁路缓存、快表; 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。<h3 id="2-4-段页式"><a href="#2-4-段页式" class="headerlink" title="2.4 段页式"></a>2.4 段页式</h3></li><li>先将程序划分为多个有逻辑意义的段，再把每个段划分为多个页</li><li>地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成</li><li>每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号<h3 id="2-5-Linux-内存布局"><a href="#2-5-Linux-内存布局" class="headerlink" title="2.5 Linux 内存布局"></a>2.5 Linux 内存布局</h3></li><li><strong>Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理</strong>。于是 Linux 就把所有段的基地址设为 <code>0</code>，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。</li><li>Linux 系统中虚拟空间分布可分为<strong>用户态</strong>和<strong>内核态</strong>两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。<h2 id="3-进程管理"><a href="#3-进程管理" class="headerlink" title="3 进程管理"></a>3 进程管理</h2><h3 id="3-1-进程基础知识"><a href="#3-1-进程基础知识" class="headerlink" title="3.1 进程基础知识"></a>3.1 进程基础知识</h3><blockquote><p><strong>进程是若干个活动的执行流以及各类相关资源的总称</strong>，这些资源包括内核结构、地址空间（内存），寄存器等<br>运行可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个<strong>运行中的程序，就被称为「进程」（Process）</strong></p><h4 id="3-1-1-进程的状态"><a href="#3-1-1-进程的状态" class="headerlink" title="3.1.1 进程的状态"></a>3.1.1 进程的状态</h4></blockquote></li><li>运行状态（<em>Running</em>）：该时刻进程占用 CPU；</li><li>就绪状态（<em>Ready</em>）：可运行，由于其他进程处于运行状态而暂时停止运行；</li><li>阻塞状态（<em>Blocked</em>）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；</li><li>创建状态（<em>new</em>）：进程正在被创建时的状态；</li><li>结束状态（<em>Exit</em>）：进程正在从系统中消失时的状态；<h4 id="3-1-2-进程的控制结构"><a href="#3-1-2-进程的控制结构" class="headerlink" title="3.1.2 进程的控制结构"></a>3.1.2 进程的控制结构</h4></li><li>用<strong>进程控制块</strong>（<em>process control block，PCB</em>）数据结构来描述进程</li><li><em>PCB 是进程存在的唯一标识</em><ul><li><code>进程描述信息</code>：<ul><li>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；</li><li>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；</li></ul></li><li><code>进程控制和管理信息</code>：<ul><li>进程当前状态，如 new、ready、running、waiting 或 blocked 等；</li><li>进程优先级：进程抢占 CPU 时的优先级；</li></ul></li><li><code>资源分配清单</code>：<ul><li>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。</li></ul></li><li><code>CPU 相关信息</code>：<ul><li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。<h4 id="3-1-3-进程的上下文切换"><a href="#3-1-3-进程的上下文切换" class="headerlink" title="3.1.3 进程的上下文切换"></a>3.1.3 进程的上下文切换</h4></li></ul></li></ul></li><li><strong>一个进程切换到另一个进程运行，称为进程的上下文切换</strong>。</li><li><em>CPU 上下文切换</em>：把保存前一个任务的 CPU 上下文（CPU 寄存器和程序计数器），加载新任务的上下文到这些寄存器和程序计数器，再跳转到程序计数器所指的新位置，运行新任务</li><li><em>进程的上下文切换</em> :不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</li></ul><h3 id="3-2-进程通信"><a href="#3-2-进程通信" class="headerlink" title="3.2 进程通信"></a>3.2 进程通信</h3><ul><li>每个进程的用户地址空间都是独立的，进程之间要通信必须通过内核。</li><li><em>管道</em>：对于匿名管道，它的通信范围是存在父子关系的进程，通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</li><li><em>消息队列</em>：保存在内核中的消息链表</li><li><em>共享内存</em>：拿出一块虚拟地址空间来，映射到相同的物理内存中</li><li><em>信号量</em>：主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</li><li><em>Socket</em>：跨网络与不同主机上的进程之间通信，针对 TCP、UDP、本机间的模型</li><li><em>死锁</em><ul><li>条件：互斥，占用和等待，不可抢占，循环等待</li><li>忽略；检测和恢复，预防，避免</li></ul></li></ul><h3 id="3-3-线程"><a href="#3-3-线程" class="headerlink" title="3.3 线程"></a>3.3 线程</h3><ul><li><em>线程是进程当中的一条执行流程。</em> 同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套<code>独立的寄存器和栈</code>，这样可以确保线程的控制流是相对独立的。</li><li><em>线程与进程的比较</em><ul><li>进程是<code>资源（包括内存、打开的文件等）分配</code>的单位，线程是<code>CPU 调度</code>的单位</li><li>进程拥有一个完整的<code>资源平台</code>，而线程只独享必不可少的资源，如<code>寄存器和栈</code></li><li>线程能减少并发执行的<code>时间和空间开销</code><ul><li>线程的创建时间比进程快，不涉及资源管理</li><li>线程的终止时间比进程快，释放的资源少</li><li>同一个进程内的线程切换比进程切换快，不需要切换页表</li><li>共享内存和文件资源，数据交互效率更高</li></ul></li></ul></li><li><em>线程的上下文切换</em>：两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的<code>私有数据</code>、寄存器等不共享的数据</li><li><em>线程的实现</em>：<ul><li><strong>用户线程（<em>User Thread</em>）</strong>：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；</li><li><strong>内核线程（<em>Kernel Thread</em>）</strong>：在内核中实现的线程，是由内核管理的线程；</li><li><strong>轻量级进程（<em>LightWeight Process</em>）</strong>：在内核中来支持用户线程；</li></ul></li><li><em>线程控制块TCB</em> ：线程状态信息（PC、栈指针、寄存器）</li><li><em>线程通信</em>：共享变量等，主要关注竞争共享资源的问题<h3 id="3-4-协程"><a href="#3-4-协程" class="headerlink" title="3.4 协程"></a>3.4 协程</h3></li><li>不是进程也不是线程，而是一个特殊的函数。协程是属于线程的。协程程序是在线程里面跑的，因此协程又称微线程和纤程等<ul><li>比线程更轻量级，协程完全由程序控制（也就是在用户态执行）</li><li>没有线程切换的开销</li><li>和多线程比，线程数量越多，协程的性能优势就越明显</li></ul></li></ul><h2 id="4-调度算法"><a href="#4-调度算法" class="headerlink" title="4 调度算法"></a>4 调度算法</h2><h3 id="4-1-进程调度算法"><a href="#4-1-进程调度算法" class="headerlink" title="4.1 进程调度算法"></a>4.1 进程调度算法</h3><ul><li><em>先来先服务调度算法</em>：每次从就绪队列选择最先进入队列的进程</li><li><em>最短作业优先调度算法</em>：优先选择运行时间最短的进程来运行</li><li><em>高响应比优先调度算法</em>：把「响应比优先级」最高的进程投入运行  服务时间+等待时间/服务时间</li><li><em>时间片轮转调度算法</em>：每个进程被分配一个时间段</li><li><em>最高优先级调度算法</em>：从就绪队列中选择最高优先级的进程进行运行</li><li><em>多级反馈队列调度算法</em>：设置多个优先级队列，优先级越高时间片越短，在当前队列没执行完就去下一级队尾<h3 id="4-2-内存页面置换算法"><a href="#4-2-内存页面置换算法" class="headerlink" title="4.2 内存页面置换算法"></a>4.2 内存页面置换算法</h3></li><li>当 CPU 访问的页面不在物理内存时，便会产生一个<code>缺页中断</code>，请求操作系统将所缺页调入到物理内存</li><li><em>最佳页面置换算法</em>：理想状态</li><li><em>先进先出置换算法</em>：置换掉在内存驻留时间很长的页面</li><li><em>时钟页面置换算法</em>：指到谁就替换</li><li><em>最不常用算法</em>：选择「访问次数」最少的那个页面，并将其淘汰<h3 id="4-3-磁盘调度算法"><a href="#4-3-磁盘调度算法" class="headerlink" title="4.3 磁盘调度算法"></a>4.3 磁盘调度算法</h3></li><li>_先来先服务算法</li><li>_最短寻道时间优先算法</li><li>_扫描算法</li><li>_循环扫描算法</li><li>_LOOK 与 C-LOOK 算法</li></ul><h2 id="5-网络系统"><a href="#5-网络系统" class="headerlink" title="5 网络系统"></a>5 网络系统</h2><h3 id="5-1-零拷贝"><a href="#5-1-零拷贝" class="headerlink" title="5.1 零拷贝"></a>5.1 零拷贝</h3><ul><li><strong>直接内存访问（<em>Direct Memory Access</em>）</strong> 技术</li><li>由 DMA 控制器负责进行 I/O 设备和内存的数据传输工作，CPU 不参与</li><li>过程：<ul><li>操作系统将 I/O 请求发送 DMA</li><li>DMA 将 I/O 请求发送给磁盘</li><li>磁盘把数据读取到缓冲区中，读满后，向 DMA 发起中断信号，告知缓冲区已满</li><li>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中</li><li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU</li><li>CPU 将数据从内核拷贝到用户空间，系统调用返回</li></ul></li><li>实现零拷贝？<ul><li>减少「上下文切换」和「数据拷贝」的次数</li><li>mmap + write：把内核缓冲区里的数据「<strong>映射</strong>」到用户空间</li><li>sendfile：替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销<h3 id="5-2-I-O-多路复用"><a href="#5-2-I-O-多路复用" class="headerlink" title="5.2 I/O 多路复用"></a>5.2 I/O 多路复用</h3></li></ul></li><li>多个请求复用了一个进程，这就是多路复用，<strong>程可以通过一个系统调用函数从内核中获取多个事件</strong><h4 id="5-2-1-Select"><a href="#5-2-1-Select" class="headerlink" title="5.2.1 Select"></a>5.2.1 Select</h4></li><li>将已连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后调用 select 函数<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合<strong>拷贝</strong>回用户态里，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket，然后再对其处理。</li><li>需要进行 <strong>2 次「遍历」文件描述符集合</strong></li><li>使用固定长度的 BitsMap，表示文件描述符集合，最多监听 1024 个</li></ul><h4 id="5-2-2-poll"><a href="#5-2-2-poll" class="headerlink" title="5.2.2 poll"></a>5.2.2 poll</h4><ul><li>poll 用链表形式来组织存储所关注的文件描述符，突破了 select 的文件描述符个数限制</li><li>和 select 并没有太大的本质区别，都是线性结构，也都需要遍历</li></ul><h4 id="5-2-3-epoll"><a href="#5-2-3-epoll" class="headerlink" title="5.2.3 epoll"></a>5.2.3 epoll</h4><ul><li>epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里</li><li>epoll 使用<code>事件驱动</code>的机制，内核里维护了一个<code>链表</code>来记录就绪事件，当某个 socket 有事件发生时，通过<code>回调函数</code>内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</li><li><em>事件触发模式</em><ul><li><strong>边缘触发</strong>：当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；   <strong>一般和非阻塞 I/O 搭配使用</strong></li><li><strong>水平触发</strong>：当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong>，目的是告诉我们有数据需要读取；</li></ul></li></ul><h3 id="5-3-高性能网络模式"><a href="#5-3-高性能网络模式" class="headerlink" title="5.3 高性能网络模式"></a>5.3 高性能网络模式</h3><p><strong>I/O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程</strong></p><h4 id="5-3-1-Reactor-模式"><a href="#5-3-1-Reactor-模式" class="headerlink" title="5.3.1 Reactor 模式"></a>5.3.1 Reactor 模式</h4><ul><li><strong>Reactor（监听和分发事件）、Acceptor（获取连接）、Handler（处理业务）</strong></li><li>单 Reactor 单进程 / 线程，不用考虑进程间通信以及数据同步的问题，因此实现起来比较简单，这种方案的缺陷在于无法充分利用多核 CPU，而且处理业务逻辑的时间不能太长，否则会延迟响应，所以不适用于计算机密集型的场景，适用于业务处理快速的场景，比如 Redis（6.0之前 ） 采用的是单 Reactor 单进程的方案。</li><li>单 Reactor 多线程，通过多线程的方式解决了方案一的缺陷，但它离高并发还差一点距离，差在只有一个 Reactor 对象来承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方。</li><li>Reactor 多进程 / 线程，通过多个 Reactor 来解决了方案二的缺陷，主 Reactor 只负责监听事件，响应事件的工作交给了从 Reactor<h4 id="5-3-2-Proactor-异步网络模式"><a href="#5-3-2-Proactor-异步网络模式" class="headerlink" title="5.3.2 Proactor 异步网络模式"></a>5.3.2 Proactor 异步网络模式</h4></li><li>阻塞 I/O：食堂等  ； 非阻塞 I/O： 过一段时间再去食堂； 异步 I/O： 阿姨送过来</li><li><strong>Proactor 是异步网络模式， 感知的是已完成的读写事件</strong>。<strong>「来了事件操作系统来处理，处理完再通知应用进程」</strong>。</li></ul><h2 id="6-Linux命令"><a href="#6-Linux命令" class="headerlink" title="6 Linux命令"></a>6 Linux命令</h2><h3 id="6-1-查看网络性能指标"><a href="#6-1-查看网络性能指标" class="headerlink" title="6.1 查看网络性能指标"></a>6.1 查看网络性能指标</h3><ul><li>网络的配置和状态   使用 <code>ifconfig</code> 或者 <code>ip</code> 命令来查看</li><li>socket 信息如何查看   使用 <code>netstat</code> 或者 <code>ss</code></li><li>网络吞吐率和 PPS 如何查看     使用 <code>sar</code> 命令</li><li>连通性和延时如何查看  ping</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/09/Basic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2023/10/09/Basic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="1-网络模型与协议"><a href="#1-网络模型与协议" class="headerlink" title="1 网络模型与协议"></a>1 网络模型与协议</h2><h3 id="1-1-网络模型分层解析"><a href="#1-1-网络模型分层解析" class="headerlink" title="1.1 网络模型分层解析"></a>1.1 网络模型分层解析</h3><ul><li><code>OSI七层模型</code>：应用（DNS，HTTP，SMTP，FTP）， 表示 ，会话，传输（TCP、UDP），网络（IP ICMP），数据链路，物理</li><li><code>TCP/IP</code>：<ul><li><code>应用层</code>：工作在用户态，往下都在内核态；主要协议有：HTTP、FTP、Telnet、DNS、SMTP等</li><li><code>传输层</code>：为用层提供网络支持；主要协议有 TCP&amp;UDP，加上 TCP 头部</li><li><code>网络层</code>：实现实际的传输功能；主要协议有 IP 协议，加上 IP 头部</li><li><code>网络接口层</code>：链路级别， IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上<h3 id="1-2-常见协议报文格式"><a href="#1-2-常见协议报文格式" class="headerlink" title="1.2 常见协议报文格式"></a>1.2 常见协议报文格式</h3></li></ul></li><li><code>TCP首部格式</code>（源/目标端口号; 序列号(随机数,避免乱序); 确认号(避免丢包); 首部长度; 关键字; 窗口; 校验和）</li><li><code>UDP</code>（端口号 长度 校验和） 包 最大为64k</li><li><code>IP报文</code>（版本 首部长度 服务类型 总长度 生存时间 校验和 ip地址</li><li><code>TCP</code>：TCP<code>最大报文段长度</code>（MSS，536字节），超过就分块（TCP Segment） IP：加上IP头成为IP报文，如果超过<code>MTU</code>（1500字节）就分片</li></ul><h2 id="2-HTTP-amp-HTTPS"><a href="#2-HTTP-amp-HTTPS" class="headerlink" title="2 HTTP &amp; HTTPS"></a>2 HTTP &amp; HTTPS</h2><h3 id="2-1-HTTP"><a href="#2-1-HTTP" class="headerlink" title="2.1 HTTP"></a>2.1 HTTP</h3><h4 id="2-1-1-HTTP-基本概念"><a href="#2-1-1-HTTP-基本概念" class="headerlink" title="2.1.1 HTTP 基本概念"></a>2.1.1 HTTP 基本概念</h4><h5 id="2-1-1-1-HTTP-是什么？"><a href="#2-1-1-1-HTTP-是什么？" class="headerlink" title="2.1.1.1 HTTP 是什么？"></a>2.1.1.1 HTTP 是什么？</h5><p>超文本传输协议</p><h5 id="2-1-1-2-HTTP-常见状态码"><a href="#2-1-1-2-HTTP-常见状态码" class="headerlink" title="2.1.1.2 HTTP 常见状态码"></a>2.1.1.2 HTTP 常见状态码</h5><ul><li>1xx：<strong>指示信息</strong>—表示请求已接收，继续处理；</li><li>2xx：<strong>成功</strong>—表示请求已被成功接收、理解、接受；200—OK 204—请求收到，但返回信息为空 206—服务器已经完成了部分用户的GET请求</li><li>3xx：<strong>重定向</strong>—信息不完整需要进一步补充；300 请求资源在多处可得到。301—永久重定向，隐式重定向。302 临时重定向，显示重定向。 304—请求的资源没有改变，可以使用缓存。</li><li>4xx：<strong>客户端错误</strong>—请求有语法错误或请求无法实现； 401—-未授权 403—禁止访问。 404 –找不到。409：对当前资源状态，请求不能完成</li><li>5xx：<strong>服务器端错误</strong>—服务器未能实现合法的请求；500内部服务器错误，501未实现，502网关错误，503服务不可用，504 网关超时<h5 id="2-1-1-3-HTTP-常见字段"><a href="#2-1-1-3-HTTP-常见字段" class="headerlink" title="2.1.1.3 HTTP 常见字段"></a>2.1.1.3 HTTP 常见字段</h5></li><li><em>Host</em> 字段：指定服务器域名</li><li><em>Content-Length 字段</em>：表明本次回应的数据长度</li><li><em>Connection 字段</em>：要求服务器使用「HTTP 长连接」机制，Keep-Alive</li><li><em>Content-Type 字段</em>：本次数据格式</li><li><em>Content-Encoding 字段</em>：数据的压缩方法<h4 id="2-1-2-GET-和-POST-有什么区别"><a href="#2-1-2-GET-和-POST-有什么区别" class="headerlink" title="2.1.2 GET 和 POST 有什么区别"></a>2.1.2 GET 和 POST 有什么区别</h4></li><li><code>RFC 规范</code>：GET 的语义是从服务器 <em>获取指定的资源</em>；POST 的语义是根据请求负荷（报文body）对 <em>指定的资源做出处理</em></li><li>GET 方法是安全、幂等、可被缓存的</li><li>POST 不安全，不幂等，（大部分实现）不可缓存<h4 id="2-1-3-HTTP缓存技术"><a href="#2-1-3-HTTP缓存技术" class="headerlink" title="2.1.3 HTTP缓存技术"></a>2.1.3 HTTP缓存技术</h4></li><li><code>强制缓存</code>：Cache-Control 和 Expires 控制资源在客户端的缓存有效期</li><li><code>协商缓存</code>：<em>Last-Modified</em> 资源没修改，响应 HTTP 304 走缓存 ; <em>ETag</em>,判断资源有没有变化<h4 id="2-1-4-HTTP特性"><a href="#2-1-4-HTTP特性" class="headerlink" title="2.1.4 HTTP特性"></a>2.1.4 HTTP特性</h4></li><li>优点：简单，灵活容易拓展，跨平台</li><li>缺点：明文传输，无状态，不安全</li><li>性能：<em>长连接</em>；<em>管道网络传输</em>：当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」<h3 id="2-2-HTTPS"><a href="#2-2-HTTPS" class="headerlink" title="2.2 HTTPS"></a>2.2 HTTPS</h3><h4 id="2-2-1-HTTPS-的区别"><a href="#2-2-1-HTTPS-的区别" class="headerlink" title="2.2.1 HTTPS 的区别"></a>2.2.1 HTTPS 的区别</h4></li><li><code>加密传输</code>：在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议<ul><li>混合加密：<strong>对称加密</strong>和<strong>非对称加密</strong>结合，非对称加密交换会话秘钥</li><li><em>摘要算法 + 数字签名</em>：计算内容的指纹</li></ul></li><li><code>连接建立</code>：需进行 SSL/TLS 的握手过程<ul><li>基于 RSA 的 TLS 握手过程<ul><li><em>ClientHello</em>：客户端发起加密通信请求，发送（一个随机数，TLS 版本，加密算法）给服务器</li><li><em>SeverHello</em>：服务端回应，发送随机数和数字证书</li><li><em>客户端回应</em>：取出公钥加密报文，再发送随机数过去，握手介绍，生成摘要</li><li><em>服务器的最后回应</em>： 计算出本次通话的会话秘钥，变更加密通信算法</li></ul></li></ul></li><li><code>默认端口</code>：HTTP 默认端口号是 <code>80</code>，HTTPS 默认端口号是 <code>443</code></li><li><code>可信身份</code>：向 CA（证书权威机构）申请数字证书<ul><li>把公钥注册到 CA，客户端拿到<code>数字证书</code>（公钥+数字签名）后用 CA 的公钥验证<h4 id="2-2-2-HTTPS-怎么保证数据完整性"><a href="#2-2-2-HTTPS-怎么保证数据完整性" class="headerlink" title="2.2.2 HTTPS 怎么保证数据完整性"></a>2.2.2 HTTPS 怎么保证数据完整性</h4></li></ul></li><li>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</li><li>TLS 握手协议负责协商加密算法和生成对称密钥</li><li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源<ul><li>消息被分割成多个较短的片段,然后分别对每个片段进行压缩</li><li><strong>加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证</strong>。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</li><li>经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。</li><li>经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li></ul></li></ul><h4 id="2-2-3-HTTPS-一定安全吗"><a href="#2-2-3-HTTPS-一定安全吗" class="headerlink" title="2.2.3 HTTPS 一定安全吗"></a>2.2.3 HTTPS 一定安全吗</h4><ul><li>中间人攻击：客户端接受了中间人服务器的证书，然后中间人分别和客户端服务器 TLS 握手并转发。</li><li>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。</li><li>抓包：使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。<h3 id="2-3-HTTP-1-1-amp-2-0-amp-3-0-演变"><a href="#2-3-HTTP-1-1-amp-2-0-amp-3-0-演变" class="headerlink" title="2.3 HTTP 1.1&amp;2.0 &amp; 3.0 演变"></a>2.3 HTTP 1.1&amp;2.0 &amp; 3.0 演变</h3><h4 id="2-3-1-HTTP-1-1-相比-HTTP-1-0"><a href="#2-3-1-HTTP-1-1-相比-HTTP-1-0" class="headerlink" title="2.3.1 HTTP/1.1 相比 HTTP/1.0"></a>2.3.1 HTTP/1.1 相比 HTTP/1.0</h4></li><li>优点：<ul><li>使用<code>长连接</code>的方式改善了 HTTP/1.0 短连接造成的性能开销。</li><li>支持管道（pipeline）网络传输</li></ul></li><li>缺点：<ul><li>请求 / 响应头部（Header）没压缩，造成浪费</li><li>队头阻塞</li><li>没有请求优先级控制</li><li>服务器只能被动响应<h4 id="2-3-2-HTTP-2-优化"><a href="#2-3-2-HTTP-2-优化" class="headerlink" title="2.3.2 HTTP/2 优化"></a>2.3.2 HTTP/2 优化</h4></li></ul></li><li><em>头部压缩</em>：消除重复的部分,HPACK算法维护头信息表和字段的映射</li><li><em>二进制格式</em>：头信息和数据体都是二进制，并且统称为帧（frame）</li><li><em>并发传输</em>：引入了 Stream，针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，可以并行交错地发送请求和响应</li><li><em>服务器推送</em>：<strong>双方都可以建立 Stream</strong>，服务器可以主动向客户端发送消息</li><li>问题：基于 TCP 传输数据，需要按序到达缓冲区才能从内核取数据，一旦丢包就会阻塞所有请求这就是 HTTP/2 <code>队头阻塞</code>问题。<h4 id="2-3-3-HTTP-3-优化"><a href="#2-3-3-HTTP-3-优化" class="headerlink" title="2.3.3 HTTP/3 优化"></a>2.3.3 HTTP/3 优化</h4></li><li><strong>把 HTTP 下层的 TCP 协议改成了 UDP</strong></li><li>基于 UDP 的 <strong>QUIC 协议</strong>实现可靠传输：就是把 TCP 的校验放到应用层实现</li></ul><h3 id="2-4-HTTP-amp-RPC"><a href="#2-4-HTTP-amp-RPC" class="headerlink" title="2.4 HTTP &amp; RPC"></a>2.4 HTTP &amp; RPC</h3><ul><li>TCP 的特点 <strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong><ul><li>没有消息边界，于是会加上信息头，以及包长度</li><li>需要协议约定消息体格式</li></ul></li><li>服务发现：HTTP 只要知道网址就可以 DNS 解析出 IP 地址和 80 端口；RPC 需要之间服务</li><li>传输的内容：RPC 定制化程度高，序列化协议多，性能稍好</li><li><code>gRPC</code> 底层都直接用的 <code>HTTP/2</code></li><li>HTTP/2 是 2015 年出来的，有惯性<h2 id="3-TCP-amp-UDP"><a href="#3-TCP-amp-UDP" class="headerlink" title="3 TCP &amp; UDP"></a>3 TCP &amp; UDP</h2><h3 id="3-1-简介与区别"><a href="#3-1-简介与区别" class="headerlink" title="3.1 简介与区别"></a>3.1 简介与区别</h3></li><li>TCP 头部<ul><li>![[Pasted image 20230904012336.png]]</li><li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li><li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li><li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li><li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li></ul></li><li><code>为什么需要 TCP</code>？ IP 层不可靠，需要传输层确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></li><li><code>什么是 TCP</code>：<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</li><li><p>什么是 TCP 连接？用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 <code>Socket、序列号和窗口大小</code>称为连接。</p><ul><li>连接数量限制：文件描述符限制，内存限制，单机最大 TCP 连接数，约为 <code>2</code> 的 <code>48</code> 次方</li></ul></li><li><p><code>UDP 和 TCP 有什么区别呢？分别的应用场景是？</code></p><ul><li><em>连接</em>：UDP 不需要连接，即刻传输数据</li><li><em>服务对象</em>：TCP 是一对一的两点服务；UDP 支持一对一、一对多、多对多的交互通信</li><li><em>可靠性</em>：UDP 尽最大努力交付，不保证可靠交付数据</li><li><em>拥塞控制、流量控制</em>：网络拥堵也不影响 UDP 发送速率</li><li><em>传输方式</em>：TCP 是流式传输，没有边界；UDP 是一个包一个包的发送</li><li><em>分片不同</em>：TCP 大于 MSS(536字节) 在传输层分片；UDP 大于 MTU(1500字节)在 IP 层分片</li><li><em>使用场景</em>：TCP 用于文件传输，HTTP 等；UDP 用于视频，广播，<code>DNS</code> 等</li></ul></li><li><code>有一方突然断电或者崩溃</code><ul><li>两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。</li><li>服务端是<strong>无法感知到的</strong>，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，<strong>服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态</strong>，直到服务端重启进程。</li><li>所以，我们可以得知一个点，在没有使用 TCP 保活机制且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED 状态，并不代表另一方的连接还一定正常。</li><li><strong>在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手</strong>。所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</li><li>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li><li>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li><li><code>在客户端主机宕机后</code>，服务端向客户端发送的报文会得不到任何的响应，在一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的报文。<ul><li>服务端重传报文的过程中，客户端主机重启完成后，客户端的内核就会接收重传的报文，然后根据报文的信息传递给对应的进程：</li><li>如果客户端主机上<strong>没有</strong>进程监听该 TCP 报文的目标端口号，那么客户端内核就会<em>*回复 RST 报文，重置该 TCP 连接</em>；</li><li>如果客户端主机上<strong>有</strong>进程监听该 TCP 报文的目标端口号，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会<strong>回复 RST 报文，重置该 TCP 连接</strong>。</li><li>所以，只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接。<h3 id="3-2-TCP"><a href="#3-2-TCP" class="headerlink" title="3.2 TCP"></a>3.2 TCP</h3><h4 id="3-2-1-如何保证可靠？"><a href="#3-2-1-如何保证可靠？" class="headerlink" title="3.2.1 如何保证可靠？"></a>3.2.1 如何保证可靠？</h4><h4 id="3-2-2-三次握手"><a href="#3-2-2-三次握手" class="headerlink" title="3.2.2 三次握手"></a>3.2.2 三次握手</h4></li></ul></li></ul></li><li><em>目的</em>:<ul><li><code>防止旧的重复连接初始化造成混乱</code>：网络阻塞重发建立连接请求</li><li><code>同步双方的初始序列号</code></li><li><code>避免资源浪费</code>：避免建立冗余链接</li></ul></li><li><em>过程</em>：控制位: ACK(确认应答); RST(强制断开); SYN(建立连接); FIN(断开连接)<ul><li>建立连接时，客户端随机初始化序列号（<strong>client-isn</strong>），<strong>SYN 标志为1</strong>，表示 SYN 报文，发送到服务器，并进入<strong>SYN-SENT状态</strong>，等待服务器确认；</li><li>服务器收到SYN报文，也随机初始化自己的序列号（server-isn），填入序号，然后在<strong>确认应答号字段</strong>填入 <strong>client-isn+1</strong>，然后将<strong>SYN和ACK置为1</strong>，发送给客户端。此时服务器进入<strong>SYN_RECV状态</strong>；</li><li>客户端收到服务器报文后，向服务器回应最后一个应答报文，ACK=1，确认应答号填入server-isn+1，发送给服务端，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<strong>此次可以携带数据</strong></li><li><code>netstat -napt</code> 查看连接状态</li></ul></li><li><em>握手丢失</em>：<ul><li>第一次：客户端超时重传</li><li>第二次：服务端超时重传</li><li>第三次：服务端超时重传</li></ul></li><li><em>SYN 攻击</em>：<ul><li>Linux 内核会维护两个队列:半连接队列，全连接队列</li><li>SYN 攻击就是打满半连接队列</li><li>解决：<ul><li>调大 netdev_max_backlog，保存数据包的队列</li><li>增大 TCP 半连接队列</li><li>开启 tcp_syncookies，绕开 SYN 半连接建立连接</li><li>减少 SYN+ACK 重传次数，加快处于 SYN_REVC 状态的 TCP 连接断开<h4 id="3-2-3-四次挥手"><a href="#3-2-3-四次挥手" class="headerlink" title="3.2.3 四次挥手"></a>3.2.3 四次挥手</h4></li></ul></li></ul></li><li><em>目的</em>：客户端发送了FIN连接释放报文后，服务器加入close-wait状态，是为了<code>让服务器发送还未传送完毕的数据</code>，传送完毕之后，服务器会发送FIN连接释放报文;</li><li><em>过程</em>：<ul><li>客户端发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li><li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</li><li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li><li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li><li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li><li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li><li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li></ul></li><li><em>TIME_WAIT状态</em>： <ul><li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li><li>保证「被动关闭连接」的一方，能被正确的关闭；确保最后的 ACK 到达。</li><li>MSL：<strong>报文最大生存时间</strong>，2MSL是允许报文丢失一次</li><li>过多会占用系统资源和端口资源；复用<strong>TIME_WAIT</strong>的 socket；超过 18000 直接重置；让客户端去断开，承受<strong>TIME_WAIT</strong></li><li>出现大量TIME_WAIT状态？ 没有用长连接；长连接超时；<h4 id="3-2-4-重传机制"><a href="#3-2-4-重传机制" class="headerlink" title="3.2.4 重传机制"></a>3.2.4 重传机制</h4></li></ul></li><li>TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决</li><li><em>超时重传</em>：<ul><li>触发场景：数据包丢失，确认应答丢失</li><li>超时时间：RTO 略大于 RTT <code>包往返时间</code></li><li>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送</li></ul></li><li><em>快速重传</em>：<code>三次重复的 ACK</code> 触发，但是不知道要重传一个还是所有</li><li><em>SACK 方法</em>：<code>选择性确认</code>，将已收到的数据的信息发送给「发送方」</li><li><em>D-ACK</em>：Duplicate 使用了 SACK 来告诉「发送方」有哪些数据被<code>重复接收</code>了，可以知道是数据包丢了还是 ACK 包丢了<h4 id="3-2-5-滑动窗口"><a href="#3-2-5-滑动窗口" class="headerlink" title="3.2.5 滑动窗口"></a>3.2.5 滑动窗口</h4></li><li><em>窗口</em>：一个缓存空间，是无需等待确认应答，而可以继续发送数据的<code>最大值</code></li><li>TCP 报文中的 Windows 字段控制</li><li>四部分：发送已确认，发送未确认，未发生但是在处理范围内，未发送范围外<h4 id="3-2-6-流量控制"><a href="#3-2-6-流量控制" class="headerlink" title="3.2.6 流量控制"></a>3.2.6 流量控制</h4></li><li>让「发送方」根据「接收方」的<code>实际接收能力</code>控制发送的数据量，让接受方处理的过来</li><li><em>窗口关闭</em>：可能导致死锁。收到零窗口通知，就启动<code>持续计时器</code>，如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文。</li><li><em>糊涂窗口综合症</em>：接收方太忙，来不及处理，窗口越来越小<ul><li>接收方不通告小窗口：小于 MSS 或者 缓存空间/2 ，通告窗口为 0</li><li>发送方避免发送小数据：Nagle 算法，除非窗口够大且数据够多并且收到 ack，否则囤积数据<h4 id="3-2-7-拥塞控制"><a href="#3-2-7-拥塞控制" class="headerlink" title="3.2.7 拥塞控制"></a>3.2.7 拥塞控制</h4></li></ul></li><li>避免「发送方」的数据填满整个网络。发送方维护一个叫<code>拥塞窗口</code>（cwnd）的状态变量</li><li><em>慢开始与拥塞避免</em>：发送的最初执行<code>慢开始</code>，令cwnd=1，发送方只能发送一个报文段，当收到确认后，将cwnd<code>加倍</code>，设置一个<code>慢开始门限</code> ssthresh，当cwnd&gt;=ssthresh时进入<code>拥塞避免</code>，按照<code>线性</code>增长方式增加，线性增长达到<code>网络拥塞</code>时，则令ssthresh=cwnd/2，然后重新执行慢开始。</li><li><em>快重传与快恢复</em>：每次接收到报文段都对最后一个已收到的的有序报文段进行<code>确认</code>。在发送方，如果收到<code>三个重复确认</code>，那么可以知道下一个报文段丢失，此时执行快重传，<code>立即重传下一个报文段</code>。在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行<code>快恢复</code>，令ssthresh = cwnd/2，cwnd = ssthresh 。直接进入<code>拥塞避免</code>。<h4 id="3-2-8-拾遗"><a href="#3-2-8-拾遗" class="headerlink" title="3.2.8 拾遗"></a>3.2.8 拾遗</h4></li><li>查看 TCP 连接信息的命令？ <code>netstat -napt</code></li></ul><h2 id="4-IP协议"><a href="#4-IP协议" class="headerlink" title="4 IP协议"></a>4 IP协议</h2><h3 id="4-1-基本认识"><a href="#4-1-基本认识" class="headerlink" title="4.1 基本认识"></a>4.1 基本认识</h3><ul><li>处于第三层，也就是<strong>网络层</strong>：实现主机与主机之间的通信</li><li>DNS：解析 IP 地址</li><li>ARP：获取下一跳的 MAC 地址，通过广播 ARP 请求与 ARP 响应实现</li><li>ICMP：<strong>互联网控制报文协议</strong>，确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等<h3 id="4-2-Ping"><a href="#4-2-Ping" class="headerlink" title="4.2 Ping"></a>4.2 Ping</h3></li><li><em>工作原理</em>：基于 ICMP 协议工作<ul><li><strong>发送ICMP请求</strong>：Ping工具向目标主机发送一个ICMP请求数据包（通常是一个特殊的Echo请求），请求目标主机进行响应。</li><li><strong>目标主机响应</strong>：目标主机接收到ICMP请求后，会发送一个ICMP响应数据包（Echo响应）回给Ping工具。</li><li><strong>测量延迟</strong>：Ping工具在发送ICMP请求和接收ICMP响应之间测量时间，从而计算出往返时间（Round-Trip Time，RTT）。RTT表示数据从Ping工具发送到目标主机并返回所需的时间，用于衡量网络的延迟。</li><li><strong>报告结果</strong>：Ping工具会显示目标主机的IP地址、RTT和其他统计信息，以便用户可以了解网络连接的质量和性能。</li></ul></li><li>ping 127.0.0.1<ul><li><strong>127 开头的都属于回环地址</strong>：目标 IP 是回环地址是会选择本地网卡</li></ul></li><li>ping 0.0.0.0<ul><li>会失败，因为这是无效的目标地址</li></ul></li></ul><h2 id="5-DNS协议"><a href="#5-DNS协议" class="headerlink" title="5 DNS协议"></a>5 DNS协议</h2><ol><li>DNS 解析过程，端口号？<ol><li>客户端发出 DNS 请求到<code>本地 DNS 服务器</code></li><li><code>本地 DNS 服务器</code>如果没有对应的缓存，就去访问<code>根域名服务器</code></li><li>根域名返回网址对应的<code>顶级域名服务器</code>地址</li><li><code>本地 DNS 服务器</code>请求<code>顶级域名服务器</code>，获得<code>权威 DNS 服务器</code>的地址</li><li><code>本地 DNS 服务器</code>请求<code>权威 DNS 服务器</code>，获取 IP 地址</li><li>返回给客户端，客户端和目标建立连接</li></ol></li><li>DNS 使用什么传输层协议？<ol><li>多数情况下使用 UDP</li><li>响应的大小超过UDP数据包的<code>最大限制</code>和<code>进行区域传输</code>（Zone Transfer）时 使用 TCP</li></ol></li></ol><h2 id="6-拾遗"><a href="#6-拾遗" class="headerlink" title="6 拾遗"></a>6 拾遗</h2><h3 id="6-1-键入网址到网页显示，期间发生了什么？"><a href="#6-1-键入网址到网页显示，期间发生了什么？" class="headerlink" title="6.1 键入网址到网页显示，期间发生了什么？"></a>6.1 键入网址到网页显示，期间发生了什么？</h3><ol><li><code>解析 URL</code>：确定了 Web 服务器和文件名，生成 HTTP 请求</li><li><code>查询服务器域名对应的 IP 地址</code>：按照浏览器缓存，操作系统缓存和 hosts 的顺序查询，如果没有就去请求本地 DNS 服务器，进入 <code>DNS 解析流程</code></li><li>应用程序（浏览器）通过调用 Socket 库，来委托<code>协议栈</code>工作<ol><li>TCP 可靠传输   <code>三次握手</code></li><li>IP 远程定位，将数据封装成<strong>网络包</strong>发送给通信对象</li><li>MAC 两点传输，在 IP 头部的前面加上 <strong>MAC 头部</strong>，包含接收方和发送方的 MAC 地址等信息。</li></ol></li><li>出口<code>网卡</code>：在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong></li><li>交换机：<strong>根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>  <code>MAC 层</code></li><li>路由器：根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作</li><li>拆包，获取数据内容，交给浏览器渲染页面，然后<code>四次挥手</code>断开连接</li></ol><h3 id="6-2-TCP-报文头部"><a href="#6-2-TCP-报文头部" class="headerlink" title="6.2 TCP 报文头部"></a>6.2 TCP 报文头部</h3><p>![[Pasted image 20230903203817.png]]</p><ul><li>首先，<strong>源端口号</strong>和<strong>目标端口</strong>号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</li><li>接下来有包的<strong>序</strong>号，这个是为了解决包乱序的问题。</li><li>还有应该有的是<strong>确认号</strong>，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决丢包的问题。</li><li>接下来还有一些<strong>状态位</strong>。例如 <code>SYN</code> 是发起一个连接，<code>ACK</code> 是回复，<code>RST</code> 是重新连接，<code>FIN</code> 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</li><li>还有一个重要的就是<strong>窗口大小</strong>。TCP 要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。</li><li>除了做流量控制以外，TCP还会做<strong>拥塞控制</strong>，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。</li></ul><h3 id="6-3-网络报文图"><a href="#6-3-网络报文图" class="headerlink" title="6.3 网络报文图"></a>6.3 网络报文图</h3><p>![[Pasted image 20230903204154.png]]</p><h3 id="6-4-网络攻击"><a href="#6-4-网络攻击" class="headerlink" title="6.4 网络攻击"></a>6.4 网络攻击</h3><h4 id="6-4-1-CSRF攻击"><a href="#6-4-1-CSRF攻击" class="headerlink" title="6.4.1 CSRF攻击"></a>6.4.1 CSRF攻击</h4><ul><li>CSRF（Cross-Site Request Forgery，跨站请求伪造）攻击，利用了用户已经在某个网站上进行了<code>身份验证</code>的情况下，对用户在另一个网站上的操作进行<code>伪造请求</code>，以执行未经授权的操作。</li><li>防范：<ul><li><strong>使用HTTP-only Cookie</strong></li><li><strong>使用验证码</strong>：敏感操作输入验证码</li><li>限制敏感操作</li><li><strong>使用CSRF令牌</strong>：为了确保请求是合法的，服务器可以生成一个唯一的CSRF令牌，并将其嵌入到表单或请求中</li><li><strong>定期审查和更新安全策略</strong></li><li><strong>同源策略</strong>CORS：浏览器的同源策略要求网页只能从同一来源加载资源。通过使用同源策略，浏览器可以限制对不同网站的跨站请求，从而减少CSRF攻击的可能性。</li></ul></li></ul><h4 id="6-4-2-XSS攻击"><a href="#6-4-2-XSS攻击" class="headerlink" title="6.4.2 XSS攻击"></a>6.4.2 XSS攻击</h4><ul><li>XSS（Cross-Site Scripting，跨站脚本攻击），将恶意脚本注入到网页中，以便在受害者的浏览器上执行恶意代码。XSS攻击可能导致盗取用户的敏感信息、劫持用户会话、操纵网页内容等恶意行为。</li><li>防范：<ul><li><strong>输入验证和过滤</strong>：在应用程序接受用户输入时，对输入数据进行验证和过滤。确保只接受预期的输入，并拒绝包含恶意脚本的输入。这可以通过编码规范、白名单过滤和黑名单过滤来实现。</li><li><strong>转义输出</strong>：在将用户输入插入到HTML、JavaScript或其他上下文中时，确保对用户输入进行适当的转义。这可以防止浏览器将用户输入解释为可执行的脚本。</li><li><strong>CORS策略</strong>：使用CORS（Cross-Origin Resource Sharing，跨源资源共享）策略来限制其他域名的网页访问您的网页，从而减少恶意脚本的机会。</li><li><strong>HTTP头设置</strong>：设置HTTP头中的安全标头，如Content Security Policy（CSP）和X-XSS-Protection，以帮助阻止XSS攻击。</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/09/System-Design/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%BD%92%E7%BA%B3/"/>
      <url>/2023/10/09/System-Design/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%BD%92%E7%BA%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="实现令牌桶"><a href="#实现令牌桶" class="headerlink" title="实现令牌桶"></a>实现令牌桶</h2><p>“HMSET” 是 Redis 的哈希表命令，用于设置哈希表中的多个字段及其对应的值。<br>通过将获取锁封装到lua脚本中，提交给redis进行eval和evalsha操作来完成lua脚本的执行，由于lua脚本在redis中天然的原子性，我们的需求能够比较好的满足，问题是将业务逻辑封装在lua中，对于开发人员自身的能力和调试存在一定的问题。<br>限流器在每次请求令牌和放入令牌操作中，存在一个协同的问题，即获取令牌操作要尽可能保证原子性，否则无法保证限流器是否能正常工作。在RateLimiter的实现中使用了mutex作为互斥锁来保证操作的原子性，那么在redis中就需要一个类似于事务的机制来保证获取令牌中多重操作的原子性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">-- 返回码 1:操作成功 0:未配置 -1: 获取失败 -2:修改错误，建议重新初始化 -500:不支持的操作</span><br><span class="line">-- redis hashmap 中存放的内容:</span><br><span class="line">-- last_mill_second 上次放入令牌或者初始化的时间</span><br><span class="line">-- stored_permits 目前令牌桶中的令牌数量</span><br><span class="line">-- max_permits 令牌桶容量</span><br><span class="line">-- interval 放令牌间隔</span><br><span class="line">-- app 一个标志位，表示对于当前key有没有限流存在</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> SUCCESS = 1</span><br><span class="line"><span class="built_in">local</span> NO_LIMIT = 0</span><br><span class="line"><span class="built_in">local</span> ACQUIRE_FAIL = -1</span><br><span class="line"><span class="built_in">local</span> MODIFY_ERROR = -2</span><br><span class="line"><span class="built_in">local</span> UNSUPPORT_METHOD = -500</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> ratelimit_info = redis.pcall(<span class="string">&quot;HMGET&quot;</span>,KEYS[1], <span class="string">&quot;last_mill_second&quot;</span>, <span class="string">&quot;stored_permits&quot;</span>, <span class="string">&quot;max_permits&quot;</span>, <span class="string">&quot;interval&quot;</span>, <span class="string">&quot;app&quot;</span>)</span><br><span class="line"><span class="built_in">local</span> last_mill_second = ratelimit_info[1]</span><br><span class="line"><span class="built_in">local</span> stored_permits = tonumber(ratelimit_info[2])</span><br><span class="line"><span class="built_in">local</span> max_permits = tonumber(ratelimit_info[3])</span><br><span class="line"><span class="built_in">local</span> interval = tonumber(ratelimit_info[4])</span><br><span class="line"><span class="built_in">local</span> app = ratelimit_info[5]</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> method = ARGV[1]</span><br><span class="line"></span><br><span class="line">--获取当前毫秒</span><br><span class="line">--考虑主从策略和脚本回放机制，这个time由客户端获取传入</span><br><span class="line">--<span class="built_in">local</span> curr_time_arr = redis.call(<span class="string">&#x27;TIME&#x27;</span>)</span><br><span class="line">--<span class="built_in">local</span> curr_timestamp = curr_time_arr[1] * 1000 + curr_time_arr[2]/1000</span><br><span class="line"><span class="built_in">local</span> curr_timestamp = tonumber(ARGV[2])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 当前方法为初始化</span><br><span class="line"><span class="keyword">if</span> method == <span class="string">&#x27;init&#x27;</span> <span class="keyword">then</span></span><br><span class="line">    --如果app不为null说明已经初始化过，不要重复初始化</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>(app) ~=<span class="string">&#x27;boolean&#x27;</span> and app ~=nil) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> SUCCESS</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    redis.pcall(<span class="string">&quot;HMSET&quot;</span>, KEYS[1],</span><br><span class="line">        <span class="string">&quot;last_mill_second&quot;</span>, curr_timestamp,</span><br><span class="line">        <span class="string">&quot;stored_permits&quot;</span>, ARGV[3],</span><br><span class="line">        <span class="string">&quot;max_permits&quot;</span>, ARGV[4],</span><br><span class="line">        <span class="string">&quot;interval&quot;</span>, ARGV[5],</span><br><span class="line">        <span class="string">&quot;app&quot;</span>, ARGV[6])</span><br><span class="line">    --始终返回成功</span><br><span class="line">    <span class="built_in">return</span> SUCCESS</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 当前方法为修改配置</span><br><span class="line"><span class="keyword">if</span> method == <span class="string">&quot;modify&quot;</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>(app) ==<span class="string">&#x27;boolean&#x27;</span> or app ==nil) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> MODIFY_ERROR</span><br><span class="line">    end</span><br><span class="line">    --只能修改max_permits和interval</span><br><span class="line">    redis.pcall(<span class="string">&quot;HMSET&quot;</span>, KEYS[1],</span><br><span class="line">        <span class="string">&quot;max_permits&quot;</span>, ARGV[3],</span><br><span class="line">        <span class="string">&quot;interval&quot;</span>, ARGV[4])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> SUCCESS</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 当前方法为删除</span><br><span class="line"><span class="keyword">if</span> method == <span class="string">&quot;delete&quot;</span> <span class="keyword">then</span></span><br><span class="line">    --已经清除完毕</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>(app) ==<span class="string">&#x27;boolean&#x27;</span> or app ==nil) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> SUCCESS</span><br><span class="line">    end</span><br><span class="line">    redis.pcall(<span class="string">&quot;DEL&quot;</span>, KEYS[1])</span><br><span class="line">    <span class="built_in">return</span> SUCCESS</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 尝试获取permits</span><br><span class="line"><span class="keyword">if</span> method == <span class="string">&quot;acquire&quot;</span> <span class="keyword">then</span></span><br><span class="line">    -- 如果app为null说明没有对这个进行任何配置，返回0代表不限流</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>(app) ==<span class="string">&#x27;boolean&#x27;</span> or app ==nil) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> NO_LIMIT</span><br><span class="line">    end</span><br><span class="line">    --需要获取令牌数量</span><br><span class="line">    <span class="built_in">local</span> acquire_permits = tonumber(ARGV[3])</span><br><span class="line">    --计算上一次放令牌到现在的时间间隔中，一共应该放入多少令牌</span><br><span class="line">    <span class="built_in">local</span> reserve_permits = math.max(0, math.floor((curr_timestamp - last_mill_second) / interval))</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">local</span> new_permits = math.min(max_permits, stored_permits + reserve_permits)</span><br><span class="line">    <span class="built_in">local</span> result = ACQUIRE_FAIL</span><br><span class="line">    --如果桶中令牌数量够则放行</span><br><span class="line">    <span class="keyword">if</span> new_permits &gt;= acquire_permits <span class="keyword">then</span></span><br><span class="line">        result = SUCCESS</span><br><span class="line">        new_permits = new_permits - acquire_permits</span><br><span class="line">    end</span><br><span class="line">    --更新当前桶中的令牌数量 </span><br><span class="line">    redis.pcall(<span class="string">&quot;HSET&quot;</span>, KEYS[1], <span class="string">&quot;stored_permits&quot;</span>, new_permits)</span><br><span class="line">    --如果这次有放入令牌，则更新时间</span><br><span class="line">    <span class="keyword">if</span> reserve_permits &gt; 0 <span class="keyword">then</span></span><br><span class="line">        redis.pcall(<span class="string">&quot;HSET&quot;</span>, KEYS[1], <span class="string">&quot;last_mill_second&quot;</span>, curr_timestamp)</span><br><span class="line">    end</span><br><span class="line">    <span class="built_in">return</span> result</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> UNSUPPORT_METHOD</span><br></pre></td></tr></table></figure><h2 id="实现-set"><a href="#实现-set" class="headerlink" title="实现 set"></a>实现 set</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 是一个使用 map 实现的集合</span></span><br><span class="line"><span class="keyword">type</span> Set <span class="keyword">struct</span> &#123;</span><br><span class="line">    m <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSet 创建一个新的空集合</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSet</span><span class="params">()</span></span> *Set &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Set&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 向集合中添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Add(value <span class="type">string</span>) &#123;</span><br><span class="line">    s.m[value] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove 从集合中删除一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Remove(value <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="built_in">delete</span>(s.m, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Contains 检查集合中是否包含某个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Contains(value <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    _, ok := s.m[value]</span><br><span class="line">    <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len 返回集合的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s.m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear 清空集合</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Clear() &#123;</span><br><span class="line">    s.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Values 返回集合中的所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Values() []<span class="type">string</span> &#123;</span><br><span class="line">    values := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(s.m))</span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> s.m &#123;</span><br><span class="line">        values = <span class="built_in">append</span>(values, k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    set := NewSet()</span><br><span class="line">    set.Add(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    set.Add(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    set.Add(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;Set contains &#x27;a&#x27;:&quot;</span>, set.Contains(<span class="string">&quot;a&quot;</span>)) <span class="comment">// true</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Set contains &#x27;d&#x27;:&quot;</span>, set.Contains(<span class="string">&quot;d&quot;</span>)) <span class="comment">// false</span></span><br><span class="line">    </span><br><span class="line">    set.Remove(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Set contains &#x27;a&#x27;:&quot;</span>, set.Contains(<span class="string">&quot;a&quot;</span>)) <span class="comment">// false</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;Set length:&quot;</span>, set.Len()) <span class="comment">// 2</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;Set values:&quot;</span>, set.Values()) <span class="comment">// [b c]</span></span><br><span class="line">    </span><br><span class="line">    set.Clear()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Set length after clear:&quot;</span>, set.Len()) <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现协程交替打印"><a href="#实现协程交替打印" class="headerlink" title="实现协程交替打印"></a>实现协程交替打印</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> countNum = <span class="number">100</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//3个函数分别打印cat、dog、fish，要求每个函数都要起一个goroutine，按照cat、dog、fish顺序打印在屏幕上10次</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"> </span><br><span class="line">    dogCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(dogCh)</span><br><span class="line">    catCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(catCh)</span><br><span class="line">    fishCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(fishCh)</span><br><span class="line"> </span><br><span class="line">    wg.Add(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">go</span> catPrint(&amp;wg, &amp;catCh, &amp;dogCh)</span><br><span class="line">    <span class="keyword">go</span> dogPrint(&amp;wg, &amp;dogCh, &amp;fishCh)</span><br><span class="line">    <span class="keyword">go</span> fishPrint(&amp;wg, &amp;fishCh, &amp;catCh)</span><br><span class="line"> </span><br><span class="line">    catCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">catPrint</span><span class="params">(wg *sync.WaitGroup, catCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, dogCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> count &gt;= countNum &#123;</span><br><span class="line">            wg.Done()</span><br><span class="line">            <span class="comment">//fmt.Println(&quot;cat quit&quot;)</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        &lt;-*catCh</span><br><span class="line">        fmt.Println(<span class="string">&quot;cat&quot;</span>, count+<span class="number">1</span>)</span><br><span class="line">        count++</span><br><span class="line">        *dogCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dogPrint</span><span class="params">(wg *sync.WaitGroup, dogCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, fishCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> count &gt;= countNum &#123;</span><br><span class="line">            wg.Done()</span><br><span class="line">            <span class="comment">//fmt.Println(&quot;dog quit&quot;)</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        &lt;-*dogCh</span><br><span class="line">        fmt.Println(<span class="string">&quot;dog&quot;</span>)</span><br><span class="line">        count++</span><br><span class="line">        *fishCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fishPrint</span><span class="params">(wg *sync.WaitGroup, dogCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, catCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> count &gt;= countNum &#123;</span><br><span class="line">            wg.Done()</span><br><span class="line">            <span class="comment">//fmt.Println(&quot;fish quit&quot;)</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        &lt;-*dogCh</span><br><span class="line">        fmt.Println(<span class="string">&quot;fish&quot;</span>)</span><br><span class="line">        count++</span><br><span class="line">        *catCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/09/DevOps/HPA/"/>
      <url>/2023/10/09/DevOps/HPA/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="0-1-扩容场景"><a href="#0-1-扩容场景" class="headerlink" title="0.1 扩容场景"></a>0.1 扩容场景</h3><ol><li>对于有流量突发的关键业务，在需要的时候应该快速扩容 (即便可能不需要，以防万一)，但缩容要慢 (防止另一个流量高峰)。</li><li>处理关键数据的应用，数据量飙升时它们应该尽快扩容以减少数据处理时间，数据量降低时应尽快缩小规模以降低成本，数据量的短暂抖动导致不必要的频繁扩缩是可以接受的。</li><li>处理常规数据/网络流量的业务，不是很重要，它们可能会以一般的方式扩大和缩小规模，以减少抖动。<h3 id="0-2-扩缩容策略"><a href="#0-2-扩缩容策略" class="headerlink" title="0.2 扩缩容策略"></a>0.2 扩缩容策略</h3></li></ol><ul><li>HPA Spec 下新增了一个 <code>behavior</code> 字段，下面有 <code>scaleUp</code> 和 <code>scaleDown</code> 两个字段分别控制扩容和缩容的行为</li><li><code>scaleUp</code> 和 <code>scaleDown</code> 都可以配置1个或多个策略，最终扩缩时用哪个策略，取决于 <code>selectPolicy</code>。</li><li><code>selectPolicy</code> 默认是 <code>Max</code>，即扩缩时，评估多个策略算出来的结果，最终选取扩缩 Pod 数量最多的那个策略的结果。</li><li><code>stabilizationWindowSeconds</code> 是稳定窗口时长，即需要指标高于或低于阈值，并持续这个窗口的时长才会真正执行扩缩，以防止抖动导致频繁扩缩容。扩容时，稳定窗口默认为0，即立即扩容；缩容时，稳定窗口默认为5分钟。</li><li><p><code>policies</code> 中定义扩容或缩容策略，<code>type</code> 的值可以是 <code>Pods</code> 或 <code>Percent</code>，表示每 <code>periodSeconds</code> 时间范围内，允许扩缩容的最大副本数或比例。</p></li><li><p>快速扩容，缓慢缩容，避免下一个流量高峰</p></li><li>缓慢扩容</li><li>禁止自动缩容</li><li>延长缩容时间窗口</li><li>延长扩容时间窗口<h3 id="0-3-指标值的计算方式"><a href="#0-3-指标值的计算方式" class="headerlink" title="0.3 指标值的计算方式"></a>0.3 指标值的计算方式</h3>每个 <strong>Pod 的指标是其中所有容器指标之和</strong>，如果计算百分比，就再除以 Pod 的 requests.<br>HPA 默认使用 Pod 的当前指标进行计算，以 CPU 使用率为例，其计算公式为：<br>`「Pod 的 CPU 使用率」= 100% * 「所有 Container 的 CPU 用量之和」/「所有 Container 的 CPU requests 之和」<h3 id="0-4-HPA-的扩缩容算法"><a href="#0-4-HPA-的扩缩容算法" class="headerlink" title="0.4 HPA 的扩缩容算法"></a>0.4 HPA 的扩缩容算法</h3></li></ul><ol><li>HPA 的「目标指标」可以使用两种形式：绝对度量指标和资源利用率。<ul><li>绝对度量指标：比如 CPU，就是指 CPU 的使用量</li><li>资源利用率（资源使用量/资源请求 * 100%）：在 Pod 设置了资源请求时，可以使用资源利用率进行 Pod 伸缩</li></ul></li><li>HPA 的「当前指标」是一段时间内所有 Pods 的平均值，不是峰值</li><li>只要「当前指标」超过了目标指标，就一定会发生扩容。</li><li><code>当前指标 / 目标指标</code>要小到一定的程度，才会触发缩容。<ol><li>比如双副本的情况下，上述比值要小于等于 1/2，才会缩容到单副本。</li><li>三副本的情况下，上述比值的临界点是 2/3。</li><li>五副本时临界值是 4/5，100副本时临界值是 99/100，依此类推。</li><li>如果 <code>当前指标 / 目标指标</code> 从 1 降到 0.5，副本的数量将会减半。（虽然说副本数越多，发生这么大变化的可能性就越小。）</li></ol></li><li><code>当前副本数 / 目标指标</code>的值越大，「当前指标」的波动对「期望副本数」的影响就越大。<br><strong>为了防止扩缩容过于敏感，HPA 有几个相关参数：</strong></li><li>Hardcoded 参数<ol><li>HPA Loop 延时：默认 15 秒，每 15 秒钟进行一次 HPA 扫描。</li><li>缩容冷却时间：默认 5 分钟。</li></ol></li><li>对于 K8s 1.18+，HPA 通过 <code>spec.behavior</code> 提供了多种控制扩缩容行为的参数<h3 id="0-5-HPA-的期望值设成多少合适？如何兼顾资源利用率与服务稳定性？"><a href="#0-5-HPA-的期望值设成多少合适？如何兼顾资源利用率与服务稳定性？" class="headerlink" title="0.5 HPA 的期望值设成多少合适？如何兼顾资源利用率与服务稳定性？"></a>0.5 HPA 的期望值设成多少合适？如何兼顾资源利用率与服务稳定性？</h3></li></ol><ul><li>核心服务<ul><li>requests/limits 值: 建议设成相等的，保证<a href="https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/">服务质量等级</a>为 Guaranteed<ul><li>需要注意 CPU 跟 Memory 的 limits 限制策略是不同的，CPU 是真正地限制了上限，而 Memory 是用超了就干掉容器（OOMKilled）</li><li>k8s 一直使用 cgroups v1 (<code>cpu_shares</code>/<code>memory.limit_in_bytes</code>)来限制 cpu/memory，但是对于 <code>Guaranteed</code> 的 Pods 而言，内存并不能完全预留，资源竞争总是有可能发生的。1.22 有 alpha 特性改用 cgroups v2，可以关注下。</li></ul></li><li>HPA: 一般来说，期望值设为 60% 到 70% 可能是比较合适的，最小副本数建议设为 2 - 5. （仅供参考）</li><li>PodDisruptionBudget: 建议按服务的健壮性与 HPA 期望值，来设置 PDB，后面会详细介绍，这里就先略过了</li></ul></li><li>非核心服务<ul><li>requests/limits 值: 建议 requests 设为 limits 的 0.6 - 0.9 倍（仅供参考），对应的服务质量等级为 Burstable<ul><li>也就是超卖了资源，这样做主要的考量点是，很多非核心服务负载都很低，根本跑不到 limits 这么高，降低 requests 可以提高集群资源利用率，也不会损害服务稳定性。</li></ul></li><li>HPA: 因为 requests 降低了，而 HPA 是以 requests 为 100% 计算使用率的，我们可以提高 HPA 的期望值（如果使用百分比为期望值的话），比如 80% ~ 90%，最小副本数建议设为 1 - 3. （仅供参考）</li><li>PodDisruptionBudget: 非核心服务嘛，保证最少副本数为 1 就行了。</li></ul></li></ul><h3 id="0-6-HPA-扩缩容过于敏感，导致-Pod-数量震荡"><a href="#0-6-HPA-扩缩容过于敏感，导致-Pod-数量震荡" class="headerlink" title="0.6 HPA 扩缩容过于敏感，导致 Pod 数量震荡"></a>0.6 HPA 扩缩容过于敏感，导致 Pod 数量震荡</h3><p>通常来讲，K8s 上绝大部分负载都应该选择使用 CPU 进行扩缩容。因为 CPU 通常能很好的反映服务的负载情况<br>但是有些服务会存在其他影响 CPU 使用率的因素，导致使用 CPU 扩缩容变得不那么可靠，比如：</p><ul><li>有些 Java 服务堆内存设得很大，GC pause 也设得比较长，因此内存 GC 会造成 CPU 间歇性飙升，CPU 监控会有大量的尖峰。</li><li>有些服务有定时任务，定时任务一运行 CPU 就涨，但是这跟服务的 QPS 是无关的</li><li>有些服务可能一运行 CPU 就会立即处于一个高位状态，它可能希望使用别的业务侧指标来进行扩容，而不是 CPU.<br>因为上述问题存在，使用 CPU 扩缩容，就可能会造成服务频繁的扩容然后缩容，或者无限扩容。 而有些服务（如我们的「推荐服务」），对「扩容」和「缩容」都是比较敏感的，每次扩缩都会造成服务可用率抖动。<br>对这类服务而言，HPA 有这几种调整策略：</li><li>选择使用 <strong>QPS</strong> 等相对比较平滑，没有 GC 这类干扰的指标来进行扩缩容，这需要借助 KEDA 等社区组件。</li><li>对 kubernetes 1.18+，可以直接使用 HPA 的 <code>behavior.scaleDown</code> 和 <code>behavior.scaleUp</code> 两个参数，控制每次扩缩容的最多 pod 数量或者比例。</li></ul><h3 id="0-7-配置实例"><a href="#0-7-配置实例" class="headerlink" title="0.7 配置实例"></a>0.7 配置实例</h3><p>![[Pasted image 20230918234033.png]]</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/09/System-Design/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2023/10/09/System-Design/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/10/09/DevOps/Docker%E4%B8%8E%20K8S/"/>
      <url>/2023/10/09/DevOps/Docker%E4%B8%8E%20K8S/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>基础<br>●Docker主要用于开发和运维的协作，可将整个项目的环境，依赖全部打包成镜像<br>●在集群中，使用一个镜像就可以很方便的进行部署<br>●Docker和虚拟机类似，但不需要去模拟硬件，启动会更快<br>○可以理解为一个浓缩版的Linux系统<br>○摒弃了Linux中不需要的很多东西<br>●概念<br>○镜像：镜像就相当于 Java类<br>○容器：容器就相当于Java对象，是一个个小型独立的Linux环境<br>○仓库：仓库是集中存放镜像的地方<br>●镜像可以生成容器实例，同一个镜像可以生成多个同时运行的容器<br>●容器可以启动，关闭，重启等等操作，就相当于一个虚拟机<br>●文档：<a href="https://yeasy.gitbook.io/docker_practice/">文档-Gitbook</a>  </p><p>操作  </p><p>安装<br>●Docker有企业版和社区版，使用社区版(DockerCE)即可<br>●具体方法看开头Gitbook文档  </p><p>镜像加速<br>●阿里云推出的的Docker Hub镜像站，方便国内用户加速下载<br>●地址：<a href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/</a><br>●获取镜像加速器地址(唯一的)<br>●配置方法在上面的地址<br>○配置文件没有的话就自己创建  </p><p>运行hello-world<br>●与编程语言的学习一样，都会有helloworld<br>●使用以下命令运行，如果没有就会去镜像仓库去拉取最新版到本地<br>○docker run hello-world  </p><p>底层原理<br>●Docker是一个Client-Server结构的系统<br>○Docker守护进程运行在主机上<br>○通过Socket连接从客户端访问<br>○守护进程从客户端接受命令并管理运行在主机上的容器<br>●Docker比虚拟机更快的原因是它有更少的抽象层，不需要去模拟硬件虚拟化。<br>●Docker直接使用宿主机的引擎和内核，多个容器也是，而虚拟机需要去重新加载多个内核<br>●</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2145785/1672129612884-e7ec2dc4-181f-408d-8970-89f1d839da94.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_36%2Ctext_QW9tc2ly%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp" alt="image.png"></p><p>常用命令  </p><p>帮助命令<br>●docker version—版本信息<br>●docker info —全面的信息描述<br>●docker —help —帮助命令  </p><p>镜像命令<br>●docker images —-列出本地的镜像<br>○列出本地所有镜像 - docker images -a<br>■所有镜像(含中间镜像层)<br>○列出本地镜像的ID —docker images -qa<br>○镜像详细信息— docker images —digests<br>●docker search [option] 镜像名 —hub上搜索镜像<br>○罗列出点赞数为30以上的镜像—docker search -s 30 tomcat<br>●docker pull 镜像名[:tag]—丛hub拉取镜像到本地<br>○不写tag就是最新版<br>○arm架构的机器就需要加特定标签  </p><ul><li>docker rmi 镜像名[:tag]  <ul><li>删除单个—-docker rmi -f 镜像<br>○ 删除多个—-docker rmi -f 镜像1 镜像2<br>○ 删除全部—-docker rmi -f$(docker images -qa )<br>●docker system df<br>○查看镜像文件等占用的空间  </li></ul></li></ul><p>容器命令<br>●启动<br>○docker run -it 镜像ID<br>○docker run -it —name=”别名” 镜像ID<br>○ -it 代表启动交互式<br>○-d代表守护式交互，不会进入容器内去操作，会在后台挂着<br>○docker run -it ubuntu /bin/bash<br>●列出正在运行的全部容器<br>○docker ps<br>○正在运行/历史运行过的 docker ps -a<br>○上5次运行过的容器 docker ps -n 5<br>○列出刚刚运行过的容器 docker ps -l<br>○列出刚刚运行过的容器ID： docker ps -ql<br>●退出容器<br>○ctrl+p+q 容器不停止退出<br>○exit命令 容器停止并退出<br>●启动容器<br>○docker start 容器ID —用ps命令获取ID<br>●重启容器<br>○docker restart 容器ID<br>●停止容器<br>○docker stop 容器ID —温柔停止<br>○docker kill 容器ID —粗暴停止<br>●删除已停止的容器<br>○docker rm 容器ID<br>●查看容器内部细节<br>○docker inspect 容器ID<br>●进入正在运行的容器<br>○docker attach 容器ID<br>○docker exec 容器ID<br>■会有新的进程、用的多<br>■退出不会导致容器的停止<br>●拷贝docker内的文件到宿主机<br>○docker cp 容器ID:容器内路径以及文件名 宿主机路径<br>●导出所有<br>○docker export 容器ID&gt;xxx.tar<br>○cat xxx.tar|docker import - xxx:3.7将打的包换成镜像<br>●查看容器日志<br>○docker logs 容器ID  </p><p>镜像发布  </p><p>镜像原理<br>●Docker的镜像是一个分层的结构<br>●从底层一层层的向上，像一个画卷<br>●Docker使用的UnionFS 联合文件系统<br>●比如我拉一个Tomcat镜像，里面就有Linux内核，JDK运行环境，Tomcat等等<br>○我就可以使用Linux内核和JDK制作一个镜像<br>○然后使用这个基础镜像+不同版本的Tomcat进行操作  </p><p>创建<br>●Docker拉取的是精简的镜像，没有用的东西都会丢掉，比如vim<br>●制作一个带有vim的centos镜像<br>○运行一个centos容器，使用yum安装vim<br>○使用下述命令进行创建<br>○docker commit -m=”add vim” -a=”aomsir” 容器ID 新镜像名字  </p><p>发布  </p><p>阿里云<br>●这里使用的Hub是使用的阿里云的Hub<br>○<a href="https://cr.console.aliyun.com/cn-hangzhou/instances">阿里云容器镜像服务</a><br>●docker tag 8ecc2667bae7 registry.cn-hangzhou.aliyuncs.com/aomsir/ubuntu_vim:1.0-镜像ID<br>●docker push registry.cn-hangzhou.aliyuncs.com/aomsir/ubuntu_vim:1.0 - 推送<br>●docker pull registry.cn-hangzhou.aliyuncs.com/aomsir/ubuntu_vim:1.0  </p><p>本地私有库<br>●拉取库：docker pull registry<br>●运行：docker run -d -p 5000:5000 -v /aomsir/myregistry/:/tmp/registry —privileged=true registry<br>●打包镜像：docker tag redis:latest 192.168.1.113:5000/redis:latest<br>●修改权限-vim /etc/docker/daemon.json，将其支持http<br>●push推送到私有库：docker push 192.168.1.113:5000/redis:1.0<br>●查看库中的镜像：curl -XGET <a href="http://192.168.1.113:5000/v2/_catalog">http://192.168.1.113:5000/v2/_catalog</a>  </p><p>容器数据卷<br>●容器数据卷的作用是用于将容器内的数据进行映射，进行持久化到本地主机目录<br>●命令docker run -it —privileged=true -v /宿主机绝对路径:/容器内目录 镜像名<br>○-v 代表 volumes<br>●宿主机目录和容器目录会双向同步<br>●容器可实现可读可写，可写等操作，一般都是可读可写<br>●卷的继承和共享<br>○容器1完成和宿主机的映射<br>○容器2继承容器1的卷规则<br>●应用场景<br>○MySQL容器重启以后数据都丢失，有了容器卷就不会<br>○当我新运行一个容器，就可以使用原来的数据直接跑  </p><p>常用应用<br>●拉取镜像的时候一定要去Docker Hub看看有没对应自己芯片架构的镜像<br>●启动服务的时候去看一下宿主机有没有安装对应的服务<br>●对应服务在宿主机有安装的话就给Docke的r容器换个端口  </p><p>Tomcat<br>●最新版Tomcat安装启动后没有首页<br>○进tomcat将webapps删除<br>○将webapps.dist改名为webapps<br>●docker run -d -p 8080:8080 -name tomcat1 /bin/bash  </p><p>MySQL<br>●使用oracle是因为有arm架构<br>●操作<br>○创建容器<br>○/root/aomsir/mysql/conf目录下新建my.cnf文件<br>○添加下面的内容,因为容器里的mysql没有utf8编码<br>●数据备份<br>○可以使用容器卷直接转移<br>○也可以使用dump命令将SQL文件导出  </p><p>Redis<br>●要去官网下载对应版本的Redis配置文件<br>●创建容器<br>○将redis.conf文件放一个在宿主机的数据卷目录  </p><p>Nginx<br>●如下  </p><p>Docker网络<br>●Docker网络可以 和 主机和虚拟机的网络相结合理解<br>●可用于容器间的通信<br>○用于编排，比如a容器的接口服务，访问b容器的redis<br>●</p><p>简介</p><p>网络模式</p><p>为每个容器分配,设置IP等,并将容器连接到一个DOCKERO</p><p>BRIDGE</p><p>虚拟网桥,默认为该模式</p><p>容器将不会虚拟出自己的网卡,配置自己的IP等,而是使用</p><p>HOST</p><p>宿主机的IP和端口</p><p>容器有独立的NETWORK NAMESPACE,但:</p><p>.但并没有对其进行任</p><p>NONE</p><p>何网络设置,如分配VETHPAIR和网桥连接,IP等</p><p>新创建的容器不会创建自己的网桥和配置自己的IP,而是和</p><p>CONTAINER</p><p>一个指定的容器共享IP和端口范围</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/2145785/1672131504934-9089d9fe-9263-44b6-a069-e6278cdfe2dd.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_34%2Ctext_QW9tc2ly%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_1198%2Climit_0" alt="image.png"></p><p>基础<br>●Docker启动以后在宿主机上会有一个docker0的虚拟网桥<br>●docker会有3大网络模式  </p><p>网络模式<br>●bridge<br>○Docker服务启动以后，会在宿主机上创建一块虚拟网卡，名为docker0(桥接模式)<br>■创建容器不指定网卡就默认使用docker0这块虚拟网卡<br>■启动一个默认服务时，容器内会生成一个eth0接口，docker0网卡会虚拟出一个vethxxx接口进行连接<br>○</p><p>DOCKER CONTAINER</p><p>DOCKER CONTAINER</p><p>DOCKER CONTAINER</p><p>ETHO</p><p>ETHO</p><p>ETHO</p><p>VETH1</p><p>VETH3</p><p>VETH2</p><p>DOCKERO</p><p>ETHO(ENS33)</p><p><img src="https://cdn.nlark.com/yuque/0/2023/png/2145785/1677821386653-4fe071e0-655d-4265-816e-354aba01a4a4.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_62%2Ctext_QW9tc2ly%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp" alt="image.png"></p><p>●host<br>○这个是主机模式，共用宿主机的IP和端口，不需要端口映射<br>○假如说宿主机啥服务都没有，使用host服务开一个tomcat，直接用宿主机ip➕端口即可访问<br>○不推荐这么使用<br>●none<br>○就是没有网络设置，不推荐这么使用<br>●container<br>○容器模式，a容器去公用b容器的网络设置  </p><p>自定义网桥<br>●docker0网卡很方便，但也有很多的弊端<br>○使用其的每个容器的IP都是动态的，每次重启都会变化<br>○容器间的通信只可以通过IP，而不可以通过hostname<br>○容器多了会降低网络传递的效率<br>●因为有弊端，所以可以自定义网桥<br>●自定义网桥操作<br>○docker nerwork create -d bridge(默认有的,可不写) 网络名称 - 创建网络<br>○自定义网段<br>■docker network create —subnet=172.18.0.0/18 my_net<br>■创建容器的时候指定容器的IP —net my_net —ip 172.18.0.2 \<br>○docker nwtwork ls - 查看现有网络<br>○docker network inspect 网络名称 - 查看某个网络的详细信息<br>○docker network rm 网络名称 - 删除某个网络<br>○使用自定义网络<br>■docker run -d —network 网络名称 - 创建容器的时候指定<br>■docker network connect 网络名称 容器名称 - 已创建的容器加入指定网络<br>●将容器加入到新建网桥中(未创建/创建容器)<br>○把启动容器的命令重新跑一遍，把network加上<br>●注意：任何模式都不可跨桥通信  </p><p>Dockerfile  </p><p>理论学习<br>●重点中的重点，学好以后可以把所有的项目使用Dockerfile进行构建<br>●Dockerfile可以认为是Docker镜像的描述文件，是由一系列命令和参数构成的脚本。主要作用是用来构建Docker镜像的构建文件<br>●官方的一个个镜像无法满足我们实际的业务需求<br>●作用：可以通过Dockerfile构建自己的镜像文件<br>●步骤<br>○<a href="https://docs.docker.com/engine/reference/builder/">官方文档</a><br>○编写dockerfile文件，如下demo<br>■注意每一行是一条完整指令<br>■第一行必须是FROM命令<br>■RUN命令后面写法很多，参照官网<br>■ADD命令与COPY命令用法一致<br>■COPY只能复制，ADD后面还可以写url，会自动去这个url下载<br>■ENTRYPOINT&amp;CMD<br>●都是用于指定容器启动时默认的执行命令(思考为啥run redis，Redis就会启动)<br>●使用语法一致，CMD如果有多条，只有最后一个有效<br>●CMD命令可以使用JSON数组的格式<br>●两者区别在于运行容器时覆盖操作 - [参考redis容器的创建]<br>○docker run 镜像:版本号 覆盖的命令 ls /<br>○docker run —entrypoint=”要覆盖的指令” 镜像:版本号 传递的参数<br>●通常EHTRYPOINT与CMD搭配进行使用<br>○使用 docker build -t xx:1.0 .(指定的dockerfile所在的位置)进行构建<br>■.代表当前目录，保证Dockerfile文件所在目录下没有无关文件，因为会一起打进去<br>○注意<br>■RUN命令是构建镜像的时候使用的，CMD是启动容器时默认执行的  </p><p>实战操作<br>●发布一个SpringBoot项目<br>●操作<br>○打jar包，同目录下写Dockerfile文件<br>○然后进行构建启动[需要的中间件等提前准备好]  </p><p>Docker-Compose  </p><p>理论学习<br>●现有Docker在进行项目部署的时候还是有很多的问题<br>●完成一个项目肯定会用到N个容器去进行业务的开发，用到后就一定会产生一些依赖(比如容器的启动时间)<br>●新需求：把服务器A的容器迁移至服务器B，很麻烦。因为部署的时候没有站在项目的角度<br>●容器的编排就显得至关重要，所以就需要使用Docker-Compose<br>●DockerCompose是Docker官方的项目<br>○Compose负责实现对Docker实现快速编排的工具<br>○一个项目一个compose文件 - docker-compose.yml<br>○project与service<br>●Compose<br>○只有Linux上面安装Docker后没有默认安装DockerCompose的<br>○Linux平台将docker-compose文件下载放到/usr/local/bin下面，赋予权限即可  </p><p>操作<br>●步骤<br>○编写docker-compose.yml配置文件<br>○在配置文件所在目录下执行 docker-compose up -d<br>○使用depends_on解决容器的编排<br>●注意<br>○docker-compose up用一次就会对配置有所缓存，可以使用对应的down进行操作<br>○docker-compose的命令有很多的操作，比如只启动一个服务，停一个服务等等<br>■用到的时候去看文档  </p><p>YAML</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>27</p><p>28</p><p>29</p><p>30</p><p>31</p><p>32</p><p>version: ‘3.8’ # docker-compose的版本号,要看具体的docker引擎</p><p>services:</p><p>tomcat:</p><p>image: tomcat:8.0 # 代表使用的是什么镜像</p><p>ports: # 代表容器与宿主机之间的映射</p><ul><li>‘8080:8080’</li></ul><p>redis:</p><p>image: redis:6.5.0</p><p>container_name: redis # 给容器起别名,推荐使用默认的</p><p>ports:</p><ul><li>‘6379:6379’</li></ul><p>networks:</p><ul><li>ems</li></ul><p>volumes:</p><ul><li>/root/redis/data/:/data</li></ul><p>command: redis-server</p><p>mysql:</p><p>image: mysql:8.0</p><p>ports:</p><ul><li>‘3306:3306’</li></ul><p>environment: # 代表给当前容器启动制定环境</p><ul><li>‘MYSQL_ROOT_PASSWORD=root’</li></ul><p>volumes:</p><ul><li>/root/mysqldata1:/var/lib/mysql</li></ul><p>depends_on:</p><p>tomcat # 依赖于tomcat,需要让其先启动</p><p>networks:</p><p>ems:</p><p>实战操作<br>●Docker-Compose基于Dockerfile去构建镜像<br>●需要使用Compose就去看人家使用镜像是怎么操作的<br>●操作<br>○使用build命令  </p><p>YAML</p><p>1</p><p>2</p><p>3</p><p>4</p><p>5</p><p>6</p><p>7</p><p>8</p><p>9</p><p>10</p><p>11</p><p>12</p><p>13</p><p>14</p><p>15</p><p>16</p><p>17</p><p>18</p><p>19</p><p>20</p><p>21</p><p>22</p><p>23</p><p>24</p><p>25</p><p>26</p><p>version: ‘3.8’</p><p>services:</p><p>tomcat:</p><p>image: tomcat:8.0</p><p>ports:</p><ul><li>‘8080:8080’</li></ul><p>networks:</p><ul><li>dangdang</li></ul><p>apps:</p><p>build:</p><p>context: ./ # dockerfile的上下文目录</p><p>dockerfile: Dockerfile # 文件名</p><p>ports:</p><ul><li>‘80:7891’</li></ul><p>command: [“test.jar”]</p><p>env_file:</p><p>./.env # 将环境文件写到.env中</p><p>networks:</p><ul><li>dangdang</li></ul><p>restart: always</p><p>networks:</p><p>dangdang: # 声明网桥</p><p>经验之谈<br>●DockerDesktop<br>○macOS上的Docker Desktop很重，占用大打开慢，可以考虑使用OrbStack进行替代<br>○注意：Docker Desktop和Orbstack同时安装的情况下，会有两套Docker Engine、Server、CLI等。容器是隔离的，注意切换上下文<br>○docker context use orbstack/docker context use desktop-linux<br>●避免镜像推不上DockerHub ，使用docker login</p><h3 id="1-docker的工作原理是什么，讲一下"><a href="#1-docker的工作原理是什么，讲一下" class="headerlink" title="1 docker的工作原理是什么，讲一下"></a>1 docker的工作原理是什么，讲一下</h3><p>docker是一个Client-Server结构的系统，docker<a href="https://www.zhihu.com/search?q=%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">守护进程</a>运行在宿主机上，守护进程从<a href="https://www.zhihu.com/search?q=%E5%AE%A2%E6%88%B7%E7%AB%AF&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">客户端</a>接受命令并管理运行在主机上的容器，容器是一个运行时环境，这就是我们说的集装箱。</p><h3 id="2-docker的组成包含哪几大部分"><a href="#2-docker的组成包含哪几大部分" class="headerlink" title="2 docker的组成包含哪几大部分"></a>2 docker的组成包含哪几大部分</h3><p>一个完整的docker有以下几个部分组成： 1、docker client，客户端，为用户提供一系列可执行命令，用户用这些命令实现跟 docker daemon 交互；</p><p>2、docker daemon，守护进程，一般在宿主主机后台运行，等待接收来自客户端的请求消息；</p><p>3、docker image，镜像，镜像run之后就生成为docker容器；</p><p>4、docker container，容器，一个系统级别的服务，拥有自己的ip和系统目录结构；运行容器前需要本地存在对应的镜像，如果本地不存在该镜像则就去镜像仓库下载。</p><p>docker 使用客户端-服务器 (C/S) 架构模式，使用远程api来管理和创建docker容器。docker 容器通过 docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。</p><h3 id="3-docker与传统虚拟机的区别什么？"><a href="#3-docker与传统虚拟机的区别什么？" class="headerlink" title="3 docker与传统虚拟机的区别什么？"></a>3 docker与传统<a href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">虚拟机</a>的区别什么？</h3><p>1、传统虚拟机是需要安装整个<a href="https://www.zhihu.com/search?q=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">操作系统</a>的，然后再在上面安装业务应用，启动应用，通常需要几分钟去启动应用，而docker是直接使用镜像来运行业务容器的，其容器启动属于秒级别；</p><p>2、Docker需要的资源更少，Docker在操作系统级别进行虚拟化，Docker容器和内核交互，几乎没有性能损耗，而虚拟机运行着整个操作系统，占用物理机的资源就比较多;</p><p>3、Docker更轻量，Docker的架构可以共用一个内核与共享应用程序库，所占内存极小;同样的硬件环境，Docker运行的镜像数远多于虚拟机数量，对系统的利用率非常高;</p><p>4、与虚拟机相比，Docker隔离性更弱，Docker属于进程之间的隔离，虚拟机可实现系统级别隔离;</p><p>5、Docker的安全性也更弱，Docker的租户root和宿主机root相同，一旦容器内的用户从普通用户权限提升为<a href="https://www.zhihu.com/search?q=root%E6%9D%83%E9%99%90&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">root权限</a>，它就直接具备了宿主机的root权限，进而可进行无限制的操作。虚拟机租户root权限和宿主机的root虚拟机权限是分离的，并且虚拟机利用如Intel的VT-d和VT-x的ring-1硬件隔离技术，这种技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离;</p><p>6、Docker的集中化管理工具还不算成熟，各种<a href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">虚拟化技术</a>都有成熟的管理工具，比如：VMware vCenter提供完备的虚拟机管理能力;</p><p>7、Docker对业务的高可用支持是通过快速重新部署实现的，虚拟化具备负载均衡，高可用、容错、迁移和数据保护等经过生产实践检验的成熟保障机制，Vmware可承诺虚拟机99.999%高可用，保证业务连续性;</p><p>8、虚拟化创建是分钟级别的，Docker容器创建是秒级别的，Docker的快速迭代性，决定了无论是开发、测试、部署都可以节省大量时间;</p><p>9、虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化，Docker在Dockerfile中记录了容器构建过程，可在集群中实现快速分发和快速部署。</p><h3 id="4-docker技术的三大核心概念是什么？"><a href="#4-docker技术的三大核心概念是什么？" class="headerlink" title="4 docker技术的三大核心概念是什么？"></a>4 docker技术的三大核心概念是什么？</h3><p>镜像：镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。</p><p>容器：容器是基于镜像创建的，是镜像运行起来之后的一个实例，容器才是真正运行业务程序的地方。如果把镜像比作程序里面的类，那么容器就是对象。</p><p>镜像仓库：存放镜像的地方，研发工程师打包好镜像之后需要把镜像上传到镜像仓库中去，然后就可以运行有仓库权限的人拉取镜像来运行容器了。</p><h3 id="5-centos镜像几个G，但是docker-centos镜像才几百兆，这是为什么？"><a href="#5-centos镜像几个G，但是docker-centos镜像才几百兆，这是为什么？" class="headerlink" title="5 centos镜像几个G，但是docker centos镜像才几百兆，这是为什么？"></a>5 centos镜像几个G，但是docker centos镜像才几百兆，这是为什么？</h3><p>一个完整的Linux操作系统包含Linux内核和rootfs根文件系统，即我们熟悉的<code>/dev</code>、<code>/proc/</code>、<code>/bin</code>等目录。我们平时看到的CentOS除了rootfs，还会选装很多软件，服务，图形桌面等，所以CentOS镜像有好几个G也不足为奇。</p><p>而对于容器镜像而言，所有容器都是共享宿主机的Linux 内核的，而对于docker镜像而言，docker镜像只需要提供一个很小的rootfs即可，只需要包含最基本的命令，工具，程序库即可，所有docker镜像才会这么小。</p><h3 id="6-讲一下镜像的分层结构以及为什么要使用镜像的分层结构？"><a href="#6-讲一下镜像的分层结构以及为什么要使用镜像的分层结构？" class="headerlink" title="6 讲一下镜像的分层结构以及为什么要使用镜像的分层结构？"></a>6 讲一下镜像的分层结构以及为什么要使用镜像的分层结构？</h3><p>一个新的镜像其实是从 base 镜像一层一层叠加生成的。每安装一个软件，dockerfile中使用<code>RUN</code>指令，就会在现有镜像的基础上增加一层，这样一层一层的叠加最后构成整个镜像。所以我们<code>docker pull</code>拉取一个镜像的时候会看到docker是一层层拉去的。</p><p>分层机构最大的一个好处就是 ： 共享资源。比如：有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p><h3 id="7-讲一下容器的copy-on-write特性，修改容器里面的内容会修改镜像吗？"><a href="#7-讲一下容器的copy-on-write特性，修改容器里面的内容会修改镜像吗？" class="headerlink" title="7 讲一下容器的copy-on-write特性，修改容器里面的内容会修改镜像吗？"></a>7 讲一下容器的copy-on-write特性，修改容器里面的内容会修改镜像吗？</h3><p>我们知道，镜像是分层的，镜像的每一层都可以被共享，同时，镜像是只读的。当一个容器启动时，一个新的可写层被加载到镜像的顶部，这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><p>所有对容器的改动 - 无论添加、删除、还是修改文件，都只会发生在容器层中，因为只有容器层是可写的，容器层下面的所有镜像层都是只读的。镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。如果不同层中有一个相同路径的文件，比如<code>/a</code>，上层的 <code>/a</code> 会覆盖下层的<code>/a</code>，也就是说用户只能访问到上层中的文件 <code>/a</code>。在容器层中，用户看到的是一个叠加之后的文件系统。</p><p>添加文件时：在容器中创建文件时，新文件被添加到容器层中。</p><p>读取文件：在容器中读取某个文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后打开并读入内存。</p><p>修改文件：在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。</p><p>删除文件：在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。</p><p>只有当需要修改时才复制一份数据，这种特性被称作 Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。</p><h3 id="8-简单描述一下Dockerfile的整个构建镜像过程"><a href="#8-简单描述一下Dockerfile的整个构建镜像过程" class="headerlink" title="8 简单描述一下Dockerfile的整个构建镜像过程"></a>8 简单描述一下Dockerfile的整个构建镜像过程</h3><p>1、首先，创建一个目录用于存放应用程序以及构建过程中使用到的各个文件等；</p><p>2、然后，在这个目录下创建一个Dockerfile文件，一般建议Dockerfile的<a href="https://www.zhihu.com/search?q=%E6%96%87%E4%BB%B6%E5%90%8D&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">文件名</a>就是Dockerfile；</p><p>3、编写Dockerfile文件，编写指令，如，使用<code>FORM指</code>令指定基础镜像，<code>COPY</code>指令复制文件，<code>RUN</code>指令指定要运行的命令，<code>ENV</code>设置环境变量，<code>EXPOSE</code>指定容器要暴露的端口，<code>WORKDIR</code>设置当前工作目录，<code>CMD</code>容器启动时运行命令，等等指令构建镜像；</p><p>4、Dockerfile编写完成就可以构建镜像了，使用<code>docker build -t 镜像名:tag .</code>命令来构建镜像，最后一个点是表示当前目录，docker会默认寻找当前目录下的Dockerfile文件来构建镜像，如果不使用默认，可以使用<code>-f</code>参数来指定dockerfile文件，如：<code>docker build -t 镜像名:tag -f /xx/xxx/Dockerfile</code>；</p><p>5、使用<code>docker build</code>命令构建之后，docker就会将当前目录下所有的文件发送给docker daemon，顺序执行Dockerfile文件里的指令，在这过程中会生成临时容器，在临时容器里面安装RUN指定的命令，安装成功后，docker底层会使用类似于<code>docker commit</code>命令来将容器保存为镜像，然后删除临时容器，以此类推，一层层的构建镜像，运行临时容器安装软件，直到最后的镜像构建成功。</p><h3 id="9-Dockerfile构建镜像出现异常，如何排查？"><a href="#9-Dockerfile构建镜像出现异常，如何排查？" class="headerlink" title="9 Dockerfile构建镜像出现异常，如何排查？"></a>9 Dockerfile构建镜像出现异常，如何排查？</h3><p>首先，Dockerfile是一层一层的构建镜像，期间会产生一个或多个临时容器，构建过程中其实就是在临时容器里面安装应用，如果因为临时容器安装应用出现异常导致镜像构建失败，这时容器虽然被清理掉了，但是期间构建的中间镜像还在，那么我们可以根据异常时上一层已经构建好的临时镜像，将临时镜像运行为容器，然后在容器里面运行安装命令来定位具体的异常。</p><h3 id="10-Dockerfile的基本指令有哪些？"><a href="#10-Dockerfile的基本指令有哪些？" class="headerlink" title="10 Dockerfile的基本指令有哪些？"></a>10 Dockerfile的基本指令有哪些？</h3><p><code>FROM</code> 指定基础镜像（必须为第一个指令，因为需要指定使用哪个基础镜像来构建镜像）；</p><p><code>MAINTAINER</code> 设置镜像作者相关信息，如作者名字，日期，邮件，联系方式等；</p><p><code>COPY</code> 复制文件到镜像；</p><p><code>ADD</code> 复制文件到镜像（<code>ADD</code>与<code>COPY</code>的区别在于，<code>ADD</code>会自动解压tar、zip、tgz、xz等归档文件，而<code>COPY</code>不会，同时<code>ADD</code>指令还可以接一个url下载文件地址，一般建议使用COPY复制文件即可，文件在宿主机上是什么样子复制到镜像里面就是什么样子这样比较好）；</p><p><code>ENV</code> 设置环境变量；</p><p><code>EXPOSE</code> 暴露容器进程的端口，仅仅是提示别人容器使用的哪个端口，没有过多作用；</p><p><code>VOLUME</code> 数据卷持久化，挂载一个目录；</p><p><code>WORKDIR</code> 设置工作目录，如果目录不在，则会自动创建目录；</p><p><code>RUN</code>在容器中运行命令，<code>RUN</code>指令会创建新的镜像层，<code>RUN</code>指令经常被用于安装软件包；</p><p><code>CMD</code> 指定容器启动时默认运行哪些命令，如果有多个<code>CMD</code>，则只有最后一个生效，另外，<code>CMD</code>指令可以被<code>docker run</code>之后的参数替换；</p><p><code>ENTRYOINT</code> 指定容器启动时运行哪些命令，如果有多个<code>ENTRYOINT</code>，则只有最后一个生效，另外，如果Dockerfile中同时存在<code>CMD</code>和<code>ENTRYOINT</code>，那么<code>CMD</code>或<code>docker run</code>之后的参数将被当做参数传递给<code>ENTRYOINT</code>；</p><h3 id="11-如何进入容器？使用哪个命令"><a href="#11-如何进入容器？使用哪个命令" class="headerlink" title="11 如何进入容器？使用哪个命令"></a>11 如何进入容器？使用哪个命令</h3><p>进入容器有两种方法：<code>docker attach</code>、<code>docker exec</code>；</p><p><code>docker attach</code>命令是attach到容器启动命令的终端，<code>docker exec</code>是另外在容器里面启动一个TTY终端。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker run -d centos /bin/bash -c <span class="string">&quot;while true;do sleep 2;echo I_am_a_container;done&quot;</span></span><br><span class="line">3274412d88ca4f1d1292f6d28d46f39c14c733da5a4085c11c6a854d30d1cde0</span><br><span class="line">docker attach 3274412d88ca4f                        <span class="comment">#attach进入容器</span></span><br><span class="line">Ctrl + c  退出，Ctrl + c会直接关闭容器终端，这样容器没有进程一直在前台运行就会死掉了</span><br><span class="line">Ctrl + pq 退出（不会关闭容器终端停止容器，仅退出）</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it 3274412d88ca /bin/bash              <span class="comment">#exec进入容器   </span></span><br><span class="line">[root@3274412d88ca /]<span class="comment"># ps -ef                       #进入到容器了开启了一个bash进程</span></span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 05:31 ?        00:00:01 /bin/bash -c <span class="keyword">while</span> <span class="literal">true</span>;<span class="keyword">do</span> <span class="built_in">sleep</span> 2;<span class="built_in">echo</span> I_am_a_container;<span class="keyword">done</span></span><br><span class="line">root        306      0  1 05:41 pts/0    00:00:00 /bin/bash</span><br><span class="line">root        322      1  0 05:41 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=<span class="built_in">sleep</span> /usr/bin/sleep 2</span><br><span class="line">root        323    306  0 05:41 pts/0    00:00:00 ps -ef</span><br><span class="line">[root@3274412d88ca /]<span class="comment">#exit                          #退出容器，仅退出我们自己的bash窗口</span></span><br></pre></td></tr></table></figure><p>小结：attach是直接进入容器启动命令的终端，不会启动新的进程；exec则是在容器里面打开新的终端，会启动新的进程；一般建议已经exec进入容器。</p><h3 id="12-什么是k8s？说出你的理解"><a href="#12-什么是k8s？说出你的理解" class="headerlink" title="12 什么是k8s？说出你的理解"></a>12 什么是k8s？说出你的理解</h3><p>K8s是kubernetes的简称，其本质是一个开源的容器编排系统，主要用于管理容器化的应用，其目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。</p><p>说简单点：k8s就是一个编排容器的系统，一个可以管理容器应用全生命周期的工具，从创建应用，应用的部署，应用提供服务，扩容缩容应用，应用更新，都非常的方便，而且还可以做到故障自愈，所以，k8s是一个非常强大的容器编排系统。</p><h3 id="13-k8s的组件有哪些，作用分别是什么？"><a href="#13-k8s的组件有哪些，作用分别是什么？" class="headerlink" title="13 k8s的组件有哪些，作用分别是什么？"></a>13 k8s的组件有哪些，作用分别是什么？</h3><p>k8s主要由master节点和node节点构成。master节点负责管理集群，node节点是容器应用真正运行的地方。 master节点包含的组件有：kube-api-server、kube-controller-manager、kube-scheduler、etcd。 node节点包含的组件有：kubelet、kube-proxy、container-runtime。</p><p>kube-api-server：以下简称api-server，api-server是k8s最重要的核心组件之一，它是k8s集群管理的统一访问入口，提供了RESTful API接口, 实现了认证、授权和准入控制等安全功能；api-server还是其他组件之间的数据交互和通信的枢纽，其他组件彼此之间并不会直接通信，其他组件对资源对象的增、删、改、查和监听操作都是交由api-server处理后，api-server再提交给etcd<a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">数据库</a>做持久化存储，只有api-server才能直接操作etcd数据库，其他组件都不能直接操作etcd数据库，其他组件都是通过api-server间接的读取，写入数据到etcd。</p><p>kube-controller-manager：以下简称controller-manager，controller-manager是k8s中各种控制器的的管理者，是k8s集群内部的管理控制中心，也是k8s<a href="https://www.zhihu.com/search?q=%E8%87%AA%E5%8A%A8%E5%8C%96&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">自动化</a>功能的核心；controller-manager内部包含replication controller、node controller、deployment controller、endpoint controller等各种资源对象的控制器，每种控制器都负责一种特定资源的控制流程，而controller-manager正是这些controller的核心管理者。</p><p>kube-scheduler：以下简称scheduler，scheduler负责集群资源调度，其作用是将待调度的pod通过一系列复杂的调度算法计算出最合适的node节点，然后将pod绑定到目标节点上。shceduler会根据pod的信息，全部节点信息列表，过滤掉不符合要求的节点，过滤出一批候选节点，然后给候选节点打分，选分最高的就是最佳节点，scheduler就会把目标pod安置到该节点。</p><p>Etcd：etcd是一个分布式的键值对存储数据库，主要是用于保存k8s集群状态数据，比如，pod，service等资源对象的信息；etcd可以是单个也可以有多个，多个就是etcd数据库集群，etcd通常部署奇数个实例，在大规模集群中，etcd有5个或7个节点就足够了；另外说明一点，etcd本质上可以不与master节点部署在一起，只要master节点能通过<a href="https://www.zhihu.com/search?q=%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">网络连接</a>etcd数据库即可。</p><p>kubelet：每个node节点上都有一个kubelet服务进程，kubelet作为连接master和各node之间的桥梁，负责维护pod和容器的生命周期，当监听到master下发到本节点的任务时，比如创建、更新、终止pod等任务，kubelet 即通过控制docker来创建、更新、销毁容器； 每个kubelet进程都会在api-server上注册本节点自身的信息，用于定期向master汇报本节点资源的使用情况。</p><p>kube-proxy：kube-proxy运行在node节点上，在Node节点上实现Pod网络代理，维护网络规则和四层负载均衡工作，kube-proxy会监听api-server中从而获取service和endpoint的变化情况，创建并维护路由规则以提供服务IP和负载均衡功能。简单理解此进程是Service的透明代理兼负载均衡器，其核心功能是将到某个Service的访问请求转发到后端的多个Pod实例上。</p><p>container-runtime：容器运行时环境，即运行容器所需要的一系列程序，目前k8s支持的容器运行时有很多，如docker、rkt或其他，比较受欢迎的是docker，但是新版的k8s已经宣布弃用docker。</p><h3 id="14-kube-api-server的端口是多少？各个pod是如何访问kube-api-server的？"><a href="#14-kube-api-server的端口是多少？各个pod是如何访问kube-api-server的？" class="headerlink" title="14 kube-api-server的端口是多少？各个pod是如何访问kube-api-server的？"></a>14 kube-api-server的端口是多少？各个pod是如何访问kube-api-server的？</h3><p>kube-api-server的端口是8080和6443，前者是http的端口，后者是https的端口，以我本机使用kubeadm安装的k8s为例：</p><p>在命名空间的kube-system命名空间里，有一个名称为kube-api-master的pod，这个pod就是运行着kube-api-server进程，它绑定了master主机的ip地址和6443端口，但是在default命名空间下，存在一个叫kubernetes的服务，该服务对外暴露端口为443，目标端口6443，这个服务的ip地址是clusterip地址池里面的第一个地址，同时这个服务的yaml定义里面并没有指定标签选择器，也就是说这个kubernetes服务所对应的endpoint是手动创建的，该endpoint也是名称叫做kubernetes，该endpoint的yaml定义里面代理到master节点的6443端口，也就是kube-api-server的IP和端口。这样一来，其他pod访问kube-api-server的整个流程就是：pod创建后嵌入了环境变量，pod获取到了kubernetes这个服务的ip和443端口，请求到kubernetes这个服务其实就是转发到了master节点上的6443端口的kube-api-server这个pod里面。</p><h3 id="15-k8s中命名空间的作用是什么？"><a href="#15-k8s中命名空间的作用是什么？" class="headerlink" title="15 k8s中命名空间的作用是什么？"></a>15 k8s中命名空间的作用是什么？</h3><p>amespace是kubernetes系统中的一种非常重要的资源，namespace的主要作用是用来实现多套环境的资源隔离，或者说是多租户的资源隔离。</p><p>k8s通过将集群内部的资源分配到不同的namespace中，可以形成逻辑上的隔离，以方便不同的资源进行隔离使用和管理。不同的命名空间可以存在同名的资源，命名空间为资源提供了一个作用域。</p><p>可以通过k8s的授权机制，将不同的namespace交给不同的租户进行管理，这样就实现了多租户的资源隔离，还可以结合k8s的资源配额机制，限定不同的租户能占用的资源，例如CPU使用量、内存使用量等等来实现租户可用资源的管理。</p><h3 id="16-k8s提供了大量的REST接口，其中有一个是Kubernetes-Proxy-API接口，简述一下这个Proxy接口的作用，已经怎么使用。"><a href="#16-k8s提供了大量的REST接口，其中有一个是Kubernetes-Proxy-API接口，简述一下这个Proxy接口的作用，已经怎么使用。" class="headerlink" title="16 k8s提供了大量的REST接口，其中有一个是Kubernetes Proxy API接口，简述一下这个Proxy接口的作用，已经怎么使用。"></a>16 k8s提供了大量的REST接口，其中有一个是Kubernetes Proxy API接口，简述一下这个Proxy接口的作用，已经怎么使用。</h3><p>好的。kubernetes proxy <a href="https://www.zhihu.com/search?q=api%E6%8E%A5%E5%8F%A3&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">api接口</a>，从名称中可以得知，proxy是代理的意思，其作用就是代理rest请求；</p><p>Kubernets API server 将接收到的rest请求转发到某个node上的kubelet守护进程的rest接口，由该kubelet进程负责响应。我们可以使用这种Proxy接口来<a href="https://www.zhihu.com/search?q=%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">直接访问</a>某个pod，这对于逐一排查pod异常问题很有帮助。 下面是一些简单的例子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://&lt;kube-api-server&gt;:&lt;api-sever-port&gt;/api/v1/nodes/node名称/proxy/pods    <span class="comment">#查看指定node的所有pod信息</span></span><br><span class="line">http://&lt;kube-api-server&gt;:&lt;api-sever-port&gt;/api/v1/nodes/node名称/proxy/stats   <span class="comment">#查看指定node的物理资源统计信息</span></span><br><span class="line">http://&lt;kube-api-server&gt;:&lt;api-sever-port&gt;/api/v1/nodes/node名称/proxy/spec    <span class="comment">#查看指定node的概要信息</span></span><br><span class="line"></span><br><span class="line">http://&lt;kube-api-server&gt;:&lt;api-sever-port&gt;/api/v1/namespace/命名名称/pods/pod名称/pod服务的url/   <span class="comment">#访问指定pod的程序页面</span></span><br><span class="line">http://&lt;kube-api-server&gt;:&lt;api-sever-port&gt;/api/v1/namespace/命名名称/servers/svc名称/url/      <span class="comment">#访问指定server的url程序页面</span></span><br></pre></td></tr></table></figure><h3 id="17-pod是什么？"><a href="#17-pod是什么？" class="headerlink" title="17 pod是什么？"></a>17 pod是什么？</h3><p>在kubernetes的世界中，k8s并不直接处理容器，而是使用多个容器共存的理念，这组容器就叫做pod。pod是k8s中可以创建和管理的最小单元，是资源对象模型中由用户创建或部署的最小资源对象模型，其他的资源对象都是用来支撑pod对象功能的，比如，pod控制器就是用来管理pod对象的，service或者ingress资源对象是用来暴露pod引用对象的，persistentvolume资源是用来为pod提供存储等等，简而言之，k8s不会直接处理容器，而是pod，pod才是k8s中可以创建和管理的最小单元，也是基本单元。</p><h3 id="18-pod的原理是什么？"><a href="#18-pod的原理是什么？" class="headerlink" title="18 pod的原理是什么？"></a>18 pod的原理是什么？</h3><p>在<a href="https://www.zhihu.com/search?q=%E5%BE%AE%E6%9C%8D%E5%8A%A1&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">微服务</a>的概念里，一般的，一个容器会被设计为运行一个进程，除非进程本身产生子进程，这样，由于不能将多个进程聚集在同一个单独的容器中，所以需要一种更高级的结构将容器绑定在一起，并将它们作为一个单元进行管理，这就是k8s中pod的背后原理。</p><h3 id="19-pod有什么特点？"><a href="#19-pod有什么特点？" class="headerlink" title="19 pod有什么特点？"></a>19 pod有什么特点？</h3><p>1、每个pod就像一个独立的逻辑机器，k8s会为每个pod分配一个集群内部唯一的IP地址，所以每个pod都拥有自己的IP地址、主机名、进程等；</p><p>2、一个pod可以包含1个或多个容器，1个容器一般被设计成只运行1个进程，1个pod只可能运行在单个节点上，即不可能1个pod跨节点运行，pod的生命周期是短暂，也就是说pod可能随时被消亡（如节点异常，pod异常等情况）；</p><p>3、每一个pod都有一个特殊的被称为”根容器”的pause容器，也称info容器，pause容器对应的镜像属于k8s平台的一部分，除了pause容器，每个pod还包含一个或多个跑业务相关组件的应用容器；</p><p>4、一个pod中的容器共享network命名空间；</p><p>5、一个pod里的多个容器共享pod IP，这就意味着1个pod里面的多个容器的进程所占用的端口不能相同，否则在这个pod里面就会产生端口冲突；既然每个pod都有自己的IP和端口空间，那么对不同的两个pod来说就不可能存在端口冲突；</p><p>6、应该将应用程序组织到多个pod中，而每个pod只包含紧密相关的组件或进程；</p><p>7、pod是k8s中扩容、缩容的基本单位，也就是说k8s中扩容缩容是针对pod而言而非容器。</p><h3 id="20-pause容器作用是什么？"><a href="#20-pause容器作用是什么？" class="headerlink" title="20 pause容器作用是什么？"></a>20 pause容器作用是什么？</h3><p>每个pod里运行着一个特殊的被称之为pause的容器，也称根容器，而其他容器则称为业务容器；创建pause容器主要是为了为业务容器提供 Linux命名空间，共享基础：包括 pid、icp、net 等，以及启动 init 进程，并收割僵尸进程；这些业务容器共享pause容器的网络命名空间和volume挂载卷，当pod被创建时，pod首先会创建pause容器，从而把其他业务容器加入pause容器，从而让所有业务容器都在同一个命名空间中，这样可以就可以实现网络共享。pod还可以共享存储，在pod级别引入数据卷volume，业务容器都可以挂载这个数据卷从而实现持久化存储。</p><h3 id="21-pod的重启策略有哪些？"><a href="#21-pod的重启策略有哪些？" class="headerlink" title="21 pod的重启策略有哪些？"></a>21 pod的重启策略有哪些？</h3><p>pod重启容器策略是指针对pod内所有容器的重启策略，不是重启pod，其可以通过<code>restartPolicy</code>字段配置pod重启容器的策略，如下：</p><ul><li><code>Always</code>: 当容器终止退出后，总是重启容器，默认策略就是<code>Always</code>。</li><li><code>OnFailure</code>: 当容器异常退出，退出状态码非0时，才重启容器。</li><li><code>Never</code>: 当容器终止退出，不管退出状态码是什么，从不重启容器。</li></ul><h3 id="22-pod的镜像拉取策略有哪几种？"><a href="#22-pod的镜像拉取策略有哪几种？" class="headerlink" title="22 pod的镜像拉取策略有哪几种？"></a>22 pod的镜像拉取策略有哪几种？</h3><p>pod镜像拉取策略可以通过<code>imagePullPolicy</code>字段配置镜像拉取策略，主要有3中镜像拉取策略，如下：</p><ul><li><code>IfNotPresent</code>: 默认值，镜像在node节点宿主机上不存在时才拉取。</li><li><code>Always</code>: 总是重新拉取，即每次创建pod都会重新从镜像仓库拉取一次镜像。</li><li><code>Never</code>: 永远不会主动拉取镜像，仅使用本地镜像，需要你手动拉取镜像到node节点，如果node节点不存在镜像则pod启动失败。</li></ul><h3 id="23-pod的存活探针有哪几种？"><a href="#23-pod的存活探针有哪几种？" class="headerlink" title="23 pod的存活探针有哪几种？"></a>23 pod的存活探针有哪几种？</h3><p>kubernetes可以通过存活探针检查容器是否还在运行，可以为pod中的每个容器单独定义存活探针，kubernetes将定期执行探针，如果探测失败，将杀死容器，并根据<code>restartPolicy</code>策略来决定是否重启容器，kubernetes提供了3种探测容器的存活探针，如下：</p><ul><li><code>httpGet</code>：通过容器的IP、端口、路径发送http 请求，返回200-400范围内的状态码表示成功。</li><li><code>exec</code>：在容器内执行shell命令，根据命令退出状态码是否为0进行判断，0表示健康，非0表示不健康。</li><li><code>TCPSocket</code>：与容器的端口建立TCP Socket链接。</li></ul><h3 id="24-存活探针的属性参数有哪几个？"><a href="#24-存活探针的属性参数有哪几个？" class="headerlink" title="24 存活探针的属性参数有哪几个？"></a>24 存活探针的属性参数有哪几个？</h3><p>存活探针的附加属性参数有以下几个：</p><ul><li><code>initialDelaySeconds</code>：表示在容器启动后延时多久秒才开始探测；</li><li><code>periodSeconds</code>：表示执行探测的频率，即间隔多少秒探测一次，默认间隔周期是10秒，最小1秒；</li><li><code>timeoutSeconds</code>：表示探测超时时间，默认1秒，最小1秒，表示容器必须在超时时间范围内做出响应，否则视为本次探测失败；</li><li><code>successThreshold</code>：表示最少连续探测成功多少次才被认定为成功，默认是1，对于liveness必须是1，最小值是1；</li><li><code>failureThreshold</code>：表示连续探测失败多少次才被认定为失败，默认是3，连续3次失败，k8s 将根据pod重启策略对容器做出决定；</li></ul><p>注意：定义存活探针时，一定要设置<code>initialDelaySeconds</code>属性，该属性为初始延时，如果不设置，默认容器启动时探针就开始探测了，这样可能会存在应用程序还未启动就绪，就会导致探针检测失败，k8s就会根据pod重启策略杀掉容器然后再重新创建容器的莫名其妙的问题。</p><p>在生产环境中，一定要定义一个存活探针。</p><h3 id="25-pod的就绪探针有哪几种？"><a href="#25-pod的就绪探针有哪几种？" class="headerlink" title="25 pod的就绪探针有哪几种？"></a>25 pod的就绪探针有哪几种？</h3><p>我们知道，当一个pod启动后，就会立即加入service的endpoint ip列表中，并开始接收到客户端的链接请求，假若此时pod中的容器的业务进程还没有初始化完毕，那么这些客户端链接请求就会失败，为了解决这个问题，kubernetes提供了就绪探针来解决这个问题的。</p><p>在pod中的容器定义一个就绪探针，就绪探针周期性检查容器，如果就绪探针检查失败了，说明该pod还未准备就绪，不能接受客户端链接，则该pod将从endpoint列表中移除，被剔除了service就不会把请求分发给该pod，然后就绪探针继续检查，如果随后容器就绪，则再重新把pod加回endpoint列表。k8s提供了3种就绪探针，如下：</p><ul><li><code>exec</code>：在容器中执行命令并检查命令退出的状态码，如果状态码为0，则说明容器已经准备就绪；</li><li><code>httpGet</code>：向容器发送http get请求，通过响应的http状态码判断容器是否准备就绪；</li><li><code>tcpSocket</code>：打开一个tcp连接到容器的指定端口，如果连接已建立，则认为容器已经准备就绪。</li></ul><h3 id="26-就绪探针的属性参数有哪些"><a href="#26-就绪探针的属性参数有哪些" class="headerlink" title="26 就绪探针的属性参数有哪些"></a>26 就绪探针的属性参数有哪些</h3><p>就绪探针的附加属性参数有以下几个：</p><ul><li><code>initialDelaySeconds</code>：延时秒数，即容器启动多少秒后才开始探测，不写默认容器启动就探测；</li><li><code>periodSeconds</code> ：执行探测的频率（秒），默认为10秒，最低值为1；</li><li><code>timeoutSeconds</code> ：超时时间，表示探测时在超时时间内必须得到响应，负责视为本次探测失败，默认为1秒，最小值为1；</li><li><code>failureThreshold</code> ：连续探测失败的次数，视为本次探测失败，默认为3次，最小值为1次；</li><li><code>successThreshold</code> ：连续探测成功的次数，视为本次探测成功，默认为1次，最小值为1次；</li></ul><h3 id="27-就绪探针与存活探针区别是什么？"><a href="#27-就绪探针与存活探针区别是什么？" class="headerlink" title="27 就绪探针与存活探针区别是什么？"></a>27 就绪探针与存活探针区别是什么？</h3><p>两者作用不一样，存活探针是将检查失败的容器杀死，创建新的启动容器来保持pod正常工作；</p><p>就绪探针是，当就绪探针检查失败，并不重启容器，而是将pod移出endpoint，就绪探针确保了service中的pod都是可用的，确保客户端只与正常的pod交互并且客户端永远不会知道系统存在问题。</p><h3 id="28-简单讲一下-pod创建过程"><a href="#28-简单讲一下-pod创建过程" class="headerlink" title="28 简单讲一下 pod创建过程"></a>28 简单讲一下 pod创建过程</h3><p>1、用户通过kubectl或其他api客户端工具提交需要创建的pod信息给apiserver；</p><p>2、apiserver验证客户端的用户权限信息，验证通过开始处理创建请求生成pod对象信息，并将信息存入etcd，然后返回确认信息给客户端；</p><p>3、apiserver开始反馈etcd中pod对象的变化，其他组件使用watch机制跟踪apiserver上的变动；</p><p>4、scheduler发现有新的pod对象要创建，开始调用内部算法机制为pod分配最佳的主机，并将结果信息更新至apiserver；</p><p>5、node节点上的kubelet通过watch机制跟踪apiserver发现有pod调度到本节点，尝试调用docker启动容器，并将结果反馈apiserver；</p><p>6、apiserver将收到的pod状态信息存入etcd中。</p><p>至此，整个pod调度完成，创建完毕。</p><h3 id="29-简单描述一下pod的终止过程"><a href="#29-简单描述一下pod的终止过程" class="headerlink" title="29 简单描述一下pod的终止过程"></a>29 简单描述一下pod的终止过程</h3><p>1、用户向apiserver发送删除pod对象的命令；</p><p>2、apiserver中的pod对象信息会随着时间的推移而更新，在宽限期内（默认30s），pod被视为dead；</p><p>3、将pod标记为terminating状态；</p><p>4、kubectl在监控到pod对象为terminating状态了就会启动pod关闭过程；</p><p>5、endpoint控制器监控到pod对象的关闭行为时将其从所有匹配到此endpoint的server资源endpoint列表中删除；</p><p>6、如果当前pod对象定义了preStop钩子处理器，则在其被标记为terminating后会意同步的方式启动执行；</p><p>7、pod对象中的容器进程收到停止信息；</p><p>8、宽限期结束后，若pod中还存在运行的进程，那么pod对象会收到立即终止的信息；</p><p>9、kubelet请求apiserver将此pod资源的宽限期设置为0从而完成删除操作，此时pod对用户已不可见。</p><h3 id="30-pod的生命周期有哪几种？"><a href="#30-pod的生命周期有哪几种？" class="headerlink" title="30 pod的生命周期有哪几种？"></a>30 pod的生命周期有哪几种？</h3><p>pod生命周期有的5种状态（也称5种相位），如下：</p><ul><li><strong>Pending</strong>（挂起）：API server已经创建pod，但是该pod还有一个或多个容器的镜像没有创建，包括正在下载镜像的过程；</li><li><strong>Running</strong>（运行中）：Pod内所有的容器已经创建，且至少有一个容器处于运行状态、正在启动括正在重启状态；</li><li><strong>Succeed</strong>（成功）：Pod内所有容器均已退出，且不会再重启；</li><li><strong>Failed</strong>（失败）：Pod内所有容器均已退出，且至少有一个容器为退出失败状态</li><li><strong>Unknown</strong>（未知）：某于某种原因apiserver无法获取该pod的状态，可能由于网络通行问题导致；</li></ul><h3 id="31-pod的初始化容器是干什么的？"><a href="#31-pod的初始化容器是干什么的？" class="headerlink" title="31 pod的初始化容器是干什么的？"></a>31 pod的初始化容器是干什么的？</h3><p>init container，初始化容器用于在启动应用容器之前完成应用容器所需要的前置条件，初始化容器本质上和应用容器是一样的，但是初始化容器是仅允许一次就结束的任务，初始化容器具有两大特征：</p><p>1、初始化容器必须运行完成直至结束，若某初始化容器运行失败，那么kubernetes需要重启它直到成功完成；</p><p>2、初始化容器必须按照定义的顺序执行，当且仅当前一个初始化容器成功之后，后面的一个初始化容器才能运行；</p><h3 id="32-pod的资源请求、限制如何定义？"><a href="#32-pod的资源请求、限制如何定义？" class="headerlink" title="32 pod的资源请求、限制如何定义？"></a>32 pod的资源请求、限制如何定义？</h3><p>pod的资源请求、资源限制可以直接在pod中定义，主要包括两块内容，limits，限制pod能使用的最大cpu和内存，requests，pod启动时申请的cpu和内存。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resources:</span>                  <span class="comment">#资源配额</span></span><br><span class="line">  <span class="attr">limits:</span>                   <span class="comment">#限制最大资源，上限</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="number">2</span>                  <span class="comment">#CPU限制，单位是code数</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">2G</span>              <span class="comment">#内存最大限制</span></span><br><span class="line">  <span class="attr">requests:</span>                 <span class="comment">#请求资源（最小，下限）</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="number">1</span>                  <span class="comment">#CPU请求，单位是code数</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">500G</span>            <span class="comment">#内存最小请求</span></span><br></pre></td></tr></table></figure><h3 id="33-标签及标签选择器是什么，如何使用？"><a href="#33-标签及标签选择器是什么，如何使用？" class="headerlink" title="33 标签及标签选择器是什么，如何使用？"></a>33 标签及标签选择器是什么，如何使用？</h3><p>标签是键值对类型，标签可以附加到任何资源对象上，主要用于管理对象，查询和筛选。标签常被用于标签选择器的匹配度检查，从而完成资源筛选；一个资源可以定义一个或多个标签在其上面。</p><p>标签选择器，标签要与标签选择器结合在一起，标签选择器允许我们选择标记有特定标签的资源对象子集，如pod，并对这些特定标签的pod进行查询，删除等操作。</p><p>标签和标签选择器最重要的使用之一在于，在deployment中，在pod模板中定义pod的标签，然后在deployment定义标签选择器，这样就通过标签选择器来选择哪些pod是受其控制的，service也是通过标签选择器来关联哪些pod最后其服务后端pod。</p><h3 id="34-service是如何与pod关联的？"><a href="#34-service是如何与pod关联的？" class="headerlink" title="34 service是如何与pod关联的？"></a>34 service是如何与pod关联的？</h3><p>答案是通过标签选择器，每一个由deployment创建的pod都带有标签，这样，service就可以定义标签选择器来关联哪些pod是作为其后端了，就是这样，service就与pod管联在一起了。</p><h3 id="35-service的域名解析格式、pod的域名解析格式"><a href="#35-service的域名解析格式、pod的域名解析格式" class="headerlink" title="35 service的域名解析格式、pod的域名解析格式"></a>35 service的<a href="https://www.zhihu.com/search?q=%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">域名解析</a>格式、pod的域名解析格式</h3><p>service的DNS域名表示格式为<code>&lt;servicename&gt;.&lt;namespace&gt;.svc.&lt;clusterdomain&gt;</code>，servicename是service的名称，namespace是service所处的命名空间，clusterdomain是k8s集群设置的域名后缀，一般默认为 <code>cluster.local</code></p><p>pod的DNS域名格式为：<code>&lt;pod-ip&gt;.&lt;namespace&gt;.pod.&lt;clusterdomain&gt;</code>，其中，<code>pod-ip</code>需要使用<code>-</code>将<code>ip</code>直接的点替换掉，namespace为pod所在的命名空间，clusterdomain是k8s集群设置的域名后缀，一般默认为<code>cluster.local</code> .</p><h3 id="36-一个应用pod是如何发现service的，或者说，pod里面的容器用于是如何连接service的？"><a href="#36-一个应用pod是如何发现service的，或者说，pod里面的容器用于是如何连接service的？" class="headerlink" title="36 一个应用pod是如何发现service的，或者说，pod里面的容器用于是如何连接service的？"></a>36 一个应用pod是如何发现service的，或者说，pod里面的容器用于是如何连接service的？</h3><p>答：有两种方式，一种是通过环境变量，另一种是通过service的dns域名方式。</p><p>1、环境变量：当pod被创建之后，k8s系统会自动为容器注入集群内有效的service名称和端口号等信息为环境变量的形式，这样容器应用直接通过取环境变量值就能访问service了，如<code>curl http://$&#123;WEBAPP_SERVICE_HOST&#125;:&#123;WEBAPP_SERVICE_PORT&#125;</code></p><p>2、DNS方式：使用dns域名解析的前提是k8s集群内有DNS域名解析服务器，默认k8s中会有一个CoreDNS作为k8s集群的默认DNS服务器提供域名解析服务器；service的DNS域名表示格式为<code>&lt;servicename&gt;.&lt;namespace&gt;.svc.&lt;clusterdomain&gt;</code>，servicename是service的名称，namespace是service所处的命名空间，clusterdomain是k8s集群设置的域名后缀，一般默认为 cluster.local ，这样容器应用直接通过service域名就能访问service了，如<code>wget http://svc-deployment-nginx.default.svc.cluster.local:80</code>，另外，service的port端口如果定义了名称，那么port也可以通过DNS进行解析，格式为：<code>_&lt;portname&gt;._&lt;protocol&gt;.&lt;servicename&gt;.&lt;namespace&gt;.svc.&lt;clusterdomain&gt;</code></p><h3 id="37-如何创建一个service代理外部的服务，或者换句话来说，在k8s集群内的应用如何访问外部的服务，如数据库服务，缓存服务等"><a href="#37-如何创建一个service代理外部的服务，或者换句话来说，在k8s集群内的应用如何访问外部的服务，如数据库服务，缓存服务等" class="headerlink" title="37 如何创建一个service代理外部的服务，或者换句话来说，在k8s集群内的应用如何访问外部的服务，如数据库服务，缓存服务等?"></a>37 如何创建一个service代理外部的服务，或者换句话来说，在k8s集群内的应用如何访问外部的服务，如数据库服务，缓存服务等?</h3><p>答：可以通过创建一个没有标签选择器的service来代理集群外部的服务。</p><p>1、创建service时不指定selector标签选择器，但需要指定service的port、targetPort、协议等，这样创建出来的service因为没有指定标签选择器就不会自动创建endpoint；</p><p>2、手动创建一个与service同名的endpoint，endpoint中定义外部服务的IP和端口，endpoint的名称一定要与service的名称一样，协议也要一样，不然endpoint不能与service进行关联。 完成以上两步，k8s会自动将service和同名的endpoint进行关联，这样，k8s集群内的应用服务直接访问这个service就可以相当于访问外部的服务了。</p><h3 id="38-service、endpoint、kube-proxys三种的关系是什么？"><a href="#38-service、endpoint、kube-proxys三种的关系是什么？" class="headerlink" title="38 service、endpoint、kube-proxys三种的关系是什么？"></a>38 service、endpoint、kube-proxys三种的关系是什么？</h3><p>service：在kubernetes中，service是一种为一组功能相同的pod提供单一不变的接入点的资源。当service被建立时，service的IP和端口不会改变，这样外部的客户端（也可以是集群内部的客户端）通过service的IP和端口来建立链接，这些链接会被路由到提供该服务的任意一个pod上。通过这样的方式，客户端不需要知道每个单独提供服务的pod地址，这样pod就可以在集群中随时被创建或销毁。</p><p>endpoint：service维护一个叫endpoint的资源列表，endpoint资源对象保存着service关联的pod的ip和端口。从表面上看，当pod消失，service会在endpoint列表中剔除pod，当有新的pod加入，service就会将pod ip加入endpoint列表；但是正在底层的逻辑是，endpoint的这种自动剔除、添加、更新pod的地址其实底层是由endpoint controller控制的，endpoint controller负责监听service和对应的pod副本的变化，如果监听到service被删除，则删除和该service同名的endpoint对象，如果监听到新的service被创建或者修改，则根据该service<a href="https://www.zhihu.com/search?q=%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">信息获取</a>得相关pod列表，然后创建或更新service对应的endpoint对象，如果监听到pod事件，则更新它所对应的service的endpoint对象。</p><p>kube-proxy：kube-proxy运行在node节点上，在Node节点上实现Pod网络代理，维护网络规则和四层负载均衡工作，kube-proxy会监听api-server中从而获取service和endpoint的变化情况，创建并维护路由规则以提供服务IP和负载均衡功能。简单理解此进程是Service的透明代理兼负载均衡器，其核心功能是将到某个Service的访问请求转发到后端的多个Pod实例上。</p><h3 id="39-deployment怎么扩容或缩容？"><a href="#39-deployment怎么扩容或缩容？" class="headerlink" title="39 deployment怎么扩容或缩容？"></a>39 deployment怎么扩容或缩容？</h3><p>答：直接修改pod副本数即可，可以通过下面的方式来修改pod副本数：</p><p>1、直接修改yaml文件的replicas字段数值，然后<code>kubectl apply -f xxx.yaml</code>来实现更新；</p><p>2、使用<code>kubectl edit deployment xxx</code>修改replicas来实现在线更新；</p><p>3、使用<code>kubectl scale --replicas=5 deployment/deployment-nginx</code>命令来扩容缩容。</p><h3 id="40-deployment的更新升级策略有哪些？"><a href="#40-deployment的更新升级策略有哪些？" class="headerlink" title="40 deployment的更新升级策略有哪些？"></a>40 deployment的更新升级策略有哪些？</h3><p>答：deployment的升级策略主要有两种。</p><p>1、<code>Recreate</code> 重建更新：这种更新策略会杀掉所有正在运行的pod，然后再重新创建的pod；</p><p>2、<code>rollingUpdate</code> 滚动更新：这种更新策略，deployment会以滚动更新的方式来逐个更新pod，同时通过设置滚动更新的两个参数<code>maxUnavailable、maxSurge</code>来控制更新的过程。</p><h3 id="41-deployment的滚动更新策略有两个特别主要的参数，解释一下它们是什么意思？"><a href="#41-deployment的滚动更新策略有两个特别主要的参数，解释一下它们是什么意思？" class="headerlink" title="41 deployment的滚动更新策略有两个特别主要的参数，解释一下它们是什么意思？"></a>41 deployment的滚动更新策略有两个特别主要的参数，解释一下它们是什么意思？</h3><p>答：deployment的滚动更新策略，<code>rollingUpdate</code> 策略，主要有两个参数，<code>maxUnavailable</code>、<code>maxSurge</code>。</p><ul><li><code>maxUnavailable</code>：最大不可用数，<code>maxUnavailable</code>用于指定deployment在更新的过程中不可用状态的pod的最大数量，<code>maxUnavailable</code>的值可以是一个整数值，也可以是pod期望副本的百分比，如25%，计算时向下取整。</li><li><code>maxSurge</code>：最大激增数，<code>maxSurge</code>指定deployment在更新的过程中pod的总数量最大能超过pod副本数多少个，<code>maxUnavailable</code>的值可以是一个整数值，也可以是pod期望副本的百分比，如25%，计算时向上取整。</li></ul><h3 id="42-deployment更新的命令有哪些？"><a href="#42-deployment更新的命令有哪些？" class="headerlink" title="42 deployment更新的命令有哪些？"></a>42 deployment更新的命令有哪些？</h3><p>答：可以通过三种方式来实现更新deployment。</p><p>1、直接修改yaml文件的镜像版本，然后<code>kubectl apply -f xxx.yaml</code>来实现更新；</p><p>2、使用<code>kubectl edit deployment xxx</code>实现在线更新；</p><p>3、使用<code>kubectl set image deployment/nginx busybox=busybox nginx=nginx:1.9.1</code>命令来更新。</p><h3 id="43-简述一下deployment的更新过程"><a href="#43-简述一下deployment的更新过程" class="headerlink" title="43 简述一下deployment的更新过程?"></a>43 简述一下deployment的更新过程?</h3><p>deployment是通过控制replicaset来实现，由replicaset真正创建pod副本，每更新一次deployment，都会创建新的replicaset，下面来举例deployment的更新过程： 假设要升级一个nginx-deployment的版本镜像为<code>nginx:1.9</code>，deployment的定义滚动更新参数如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">replicas: 3</span><br><span class="line">deployment.spec.strategy.type: RollingUpdate</span><br><span class="line">maxUnavailable：25%</span><br><span class="line">maxSurge：25%</span><br></pre></td></tr></table></figure><p>通过计算我们得出，3*25%=0.75，<code>maxUnavailable</code>是向下取整，则<code>maxUnavailable=0</code>，<code>maxSurge</code>是向上取整，则<code>maxSurge=1</code>，所以我们得出在整个deployment升级镜像过程中，不管旧的pod和新的pod是如何创建消亡的，pod总数最大不能超过<code>3+maxSurge=4</code>个，最大pod不可用数<code>3-maxUnavailable=3</code>个。</p><p>现在具体讲一下deployment的更新升级过程： 使用<code>kubectl set image deployment/nginx nginx=nginx:1.9 --record</code>命令来更新；</p><p>1、deployment创建一个新的replaceset，先新增1个新版本pod，此时pod总数为4个，不能再新增了，再新增就超过pod总数4个了；旧=3，新=1，总=4；</p><p>2、减少一个旧版本的pod，此时pod总数为3个，这时不能再减少了，再减少就不满足最大pod不可用数3个了；旧=2，新=1，总=3；</p><p>3、再新增一个新版本的pod，此时pod总数为4个，不能再新增了；旧=2，新=2，总=4；</p><p>4、减少一个旧版本的pod，此时pod总数为3个，这时不能再减少了；旧=1，新=2，总=3；</p><p>5、再新增一个新版本的pod，此时pod总数为4个，不能再新增了；旧=1，新=3，总=4；</p><p>6、减少一个旧版本的pod，此时pod总数为3个，更新完成，pod都是新版本了；旧=0，新=3，总=3；</p><h3 id="44-deployment的回滚使用什么命令"><a href="#44-deployment的回滚使用什么命令" class="headerlink" title="44 deployment的回滚使用什么命令"></a>44 deployment的回滚使用什么命令</h3><p>在升级deployment时kubectl set image 命令加上 —record 参数可以记录具体的升级历史信息，使用<code>kubectl rollout history deployment/deployment-nginx</code>命令来查看指定的deployment升级历史记录，如果需要回滚到某个指定的版本，可以使用<code>kubectl rollout undo deployment/deployment-nginx --to-revision=2</code>命令来实现。</p><h3 id="45-讲一下都有哪些存储卷，作用分别是什么"><a href="#45-讲一下都有哪些存储卷，作用分别是什么" class="headerlink" title="45 讲一下都有哪些存储卷，作用分别是什么?"></a>45 讲一下都有哪些存储卷，作用分别是什么?</h3><div class="table-container"><table><thead><tr><th>卷</th><th>作用</th><th>常用场景</th></tr></thead><tbody><tr><td>emptyDir</td><td>用于存储临时数据的简单空目录</td><td>一个pod中的多个容器需要共享彼此的数据 ，emptyDir的数据随着容器的消亡也会销毁</td></tr><tr><td>hostPath</td><td>用于将目录从工作节点的文件系统挂载到pod中</td><td>不常用，缺点是，pod的调度不是固定的，也就是当pod消失后deployment重新创建一个pod，而这pod如果不是被调度到之前pod的节点，那么该pod就不能访问之前的数据</td></tr><tr><td>configMap</td><td>用于将非敏感的数据保存到键值对中，使用时可以使用作为环境变量、命令行参数arg，存储卷被pods挂载使用</td><td>将应用程序的不敏感配置文件创建为configmap卷，在pod中挂载configmap卷，可是实现热更新</td></tr><tr><td>secret</td><td>主要用于存储和管理一些敏感数据，然后通过在 Pod 的容器里挂载 Volume 的方式或者环境变量的方式访问到这些 Secret 里保存的信息了，pod会自动解密Secret 的信息</td><td>将应用程序的账号密码等敏感信息通过secret卷的形式挂载到pod中使用</td></tr><tr><td>downwardApi</td><td>主要用于暴露pod元数据，如pod的名字</td><td>pod中的应用程序需要指定pod的name等元数据，就可以通过downwardApi 卷的形式挂载给pod使用</td></tr><tr><td>projected</td><td>这是一种特殊的卷，用于将上面这些卷一次性的挂载给pod使用</td><td>将上面这些卷一次性的挂载给pod使用</td></tr><tr><td>pvc</td><td>pvc是存储卷声明</td><td>通常会创建pvc表示对存储的申请，然后在pod中使用pvc</td></tr><tr><td>网络存储卷</td><td>pod挂载网络存储卷，这样就能将数据持久化到后端的存储里</td><td>常见的网络存储卷有nfs存储、glusterfs 卷、ceph rbd存储卷</td></tr></tbody></table></div><p><strong>pv的访问模式有哪几种</strong></p><ul><li><code>ReadWriteOnce</code>，简写：RWO 表示，只仅允许单个节点以读写方式挂载；</li><li><code>ReadOnlyMany</code>，简写：ROX 表示，可以被许多节点以只读方式挂载；</li><li><code>ReadWriteMany</code>，简写：RWX 表示，可以被多个节点以读写方式挂载；</li></ul><h3 id="46-pv的回收策略有哪几种"><a href="#46-pv的回收策略有哪几种" class="headerlink" title="46 pv的回收策略有哪几种"></a>46 pv的回收策略有哪几种</h3><p>主要有3中回收策略：Retain 、Delete、Recycle。</p><ul><li>Retain：保留，该策略允许手动回收资源，当删除PVC时，PV仍然存在，PV被视为已释放，管理员可以手动回收卷。</li><li>Delete：删除，如果Volume插件支持，删除PVC时会同时删除PV，动态卷默认为Delete，目前支持Delete的存储后端包括AWS EBS，GCE PD，Azure Disk，OpenStack Cinder等。</li><li>Recycle：回收，如果Volume插件支持，Recycle策略会对卷执行<code>rm -rf</code>清理该PV，并使其可用于下一个新的PVC，但是本策略将来会被弃用，目前只有NFS和HostPath支持该策略。（这种策略已经被废弃，不用记）</li></ul><h3 id="47-在pv的生命周期中，一般有几种状态"><a href="#47-在pv的生命周期中，一般有几种状态" class="headerlink" title="47 在pv的生命周期中，一般有几种状态"></a>47 在pv的生命周期中，一般有几种状态</h3><p>创建pv后，pv的的状态有以下4种：</p><ul><li><code>Available</code>，表示pv已经创建正常，处于可用状态；</li><li><code>Bound</code>，表示pv已经被某个pvc绑定，注意，一个pv一旦被某个pvc绑定，那么该pvc就独占该pv，其他pvc不能再与该pv绑定；</li><li><code>Released</code>，表示pvc被删除了，pv状态就会变成已释放；</li><li><code>Failed</code>，表示pv的自动回收失败；</li></ul><h3 id="48-存储类的资源回收策略"><a href="#48-存储类的资源回收策略" class="headerlink" title="48 存储类的资源回收策略:"></a>48 存储类的资源回收策略:</h3><p>主要有2中回收策略，Delete 、Retain。默认就是Delete策略</p><ul><li>Retain：保留，该策略允许手动回收资源，当删除PVC时，PV仍然存在，PV被视为已释放，管理员可以手动回收卷。</li><li>Delete：删除，如果Volume插件支持，删除PVC时会同时删除PV，动态卷默认为Delete，目前支持Delete的存储后端包括AWS EBS，GCE PD，Azure Disk，OpenStack Cinder等。</li></ul><p>注意：使用存储类动态创建的pv默认继承存储类的回收策略，当然当pv创建后你也可以手动修改pv的回收策略。</p><h3 id="49-pv存储空间不足怎么扩容"><a href="#49-pv存储空间不足怎么扩容" class="headerlink" title="49 pv存储空间不足怎么扩容?"></a>49 pv存储空间不足怎么扩容?</h3><p>一般的，我们会使用动态分配存储资源，在创建<code>storageclass</code>时指定参数 <code>allowVolumeExpansion：true</code>，表示允许用户通过修改pvc申请的存储空间自动完成pv的扩容，当增大pvc的存储空间时，不会重新创建一个pv，而是扩容其绑定的后端pv。这样就能完成扩容了。但是<code>allowVolumeExpansion</code>这个特性只支持扩容空间不支持减少空间。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/09/11/System-Design/Raft/"/>
      <url>/2023/09/11/System-Design/Raft/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h2><div class="table-container"><table><thead><tr><th><strong>中文术语</strong></th><th><strong>英文术语</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>领导者</td><td>leader</td><td>节点的三种角色之一. 集群的首脑，负责发起”提议“、”提交“被多数派认可的决断.</td></tr><tr><td>跟随者</td><td>follower</td><td>节点的三种角色之一. 需要对 leader 的 ”提议“ 、”提交“和 candidate 的 ”竞选“ 进行响应.</td></tr><tr><td>候选人</td><td>candidate</td><td>节点的三种角色之一. 是一种处于竞选流程中的临时状态，根据多数派投票的结果会切为 leader 或 follower 的稳定态.</td></tr><tr><td>最终一致性</td><td>finnal consistency</td><td>中强一致性. 对于写请求，服务端保证最终一定能提供出正确的结果，但需要同步时间. 同步期间，可能被读到不一致的老数据.</td></tr><tr><td>即时一次性</td><td>immediate consistency</td><td>强一致性. 服务端要求做到写入立即可读.</td></tr><tr><td>预写日志</td><td>write ahead log</td><td>记录写请求明细的日志.（单指 raft 算法下狭义的预写日志）</td></tr><tr><td>状态机</td><td>state machine</td><td>节点内存储数据的介质.</td></tr><tr><td>提议</td><td>proposal</td><td>两阶段提交的第一个阶段. 指的是 leader 向所有节点发起日志同步请求的过程.</td></tr><tr><td>提交</td><td>commit</td><td>两阶段提交的第二个阶段. 指的是 leader 认可一笔写请求已经被系统采纳的动作.</td></tr><tr><td>应用</td><td>apply</td><td>指的是将预写日志记录内记录的写操作应用到状态机的过程.</td></tr><tr><td>任期</td><td>term</td><td>任期是用于标识 leader 更迭的概念. 每个任期内至多只允许有一个 leader.</td></tr><tr><td>日志索引</td><td>index</td><td>日志在预写日志数组中的位置.</td></tr><tr><td>脑裂</td><td>brain split</td><td>同一任期内，集群出现两个 leader，导致秩序崩盘.</td></tr></tbody></table></div><h3 id="1-1-多数派原则"><a href="#1-1-多数派原则" class="headerlink" title="1.1 多数派原则"></a>1.1 多数派原则</h3><blockquote><p>系统的决断无需全员参与,多数派达成的共识即可视为整个系统的答复</p><ul><li>以集群存在 5 个节点为例，多数派则需要集齐 3 个及 3 个以上节点，至多可以允许 2 个节点存在开小差背离主流的情况. 同理，倘若集群 6 个节点，则多数派需要集齐 4 个及 4 个以上节点，因此同样至多允许 2 个节点开小差. 综上，这是奉行多数派原则的集群通常将节点个数设置为奇数的原因之一.</li><li>多数派原则是提高分布式系统可用性 A 的关键. 对于整个系统而言，执行一项操作要求全员共同响应以实现强 C 的保证是过于苛刻的，因为我们无法保证所有节点都能健康运作，这种底线思维是研发人员所必须具备的素养. 但是倘若退而求其次，只要多数派达成共识即可正常决断和响应，这样下限就提高很多了. 由全员响应进化为多数派共识，这将把一种底线思维下的随机性问题进化为一个数学期望问题.</li></ul></blockquote><h3 id="1-2-一主多从、读写分离"><a href="#1-2-一主多从、读写分离" class="headerlink" title="1.2 一主多从、读写分离"></a>1.2 一主多从、读写分离</h3><ul><li>raft 算法下系统中的节点分为领导者 leader 和跟随者 follower 两类角色;leader拥有更广阔的视野，需要总览全局，领导一些日常事务的推进；follower 职责相对简单但同样重要，因为这是一个基于多数派原则运作的民众团体，所有角色只要拧成一股绳，聚成了多数派，就能代表整个系统进行决断，甚至包括推翻 leader.</li><li>读操作可以由集群的任意节点提供服务；写操作统一需要由 leader 收口处理，并向 follower 同步. 倘若 follower 率先收到了来自客户端的写请求，也需要转发给 leader 进行处理.</li></ul><h3 id="1-3-状态机与预写日志"><a href="#1-3-状态机与预写日志" class="headerlink" title="1.3  状态机与预写日志"></a>1.3  状态机与预写日志</h3><ul><li>状态机 （state machine）是节点实际存储数据的容器,写请求的最后一步是将结果写入状态机，而读请求也需要从状态机中获取数据进行响应.</li><li>预写日志（write ahead log，简称 wal）是通过日志的方式记录下每一笔写请求的明细（例如 set x = 3 这样一笔记录），使得变更历史有迹可循. 在 raft 算法中，写请求会先组织成预写日志的形式添加到日志数组中，当一个日志（写请求）达到集群多数派的认可后，才能够被提交，将变更应用到状态机当中.<h3 id="1-4-两阶段提交"><a href="#1-4-两阶段提交" class="headerlink" title="1.4  两阶段提交"></a>1.4  两阶段提交</h3>（1）leader 接收到来自客户端的一笔写请求；<br>（2）leader 将写请求添加到本地的预写日志中，并向集群中其他节点广播同步这笔写请求. 这个过程可以称之为“提议”（proposal）；<br>（3）集群中各节点接收到同步请求后，会一套检验机制判断是否能执行同步（添加到预写日志），校验机制这里不细述，留待 4.1 小节细说；<br>（4）倘若集群总计半数以上的节点（包括 leader 自身）都将这笔请求添加预写日志，并给予了 leader 肯定的答复（ack），那么 leader 此时会“提交”这个请求，并给予客户端写请求已成功处理的响应；<br>（5）其他节点在随后的时段中，会通过与 leader 的交互（心跳或其他同步数据的请求）感知到这个“提交”动作，最终也在预写日志中提交这笔请求；<br>（6）被提交的预写日志具备了被应用到状态机的资格. 但应用的时机取决于实现方式，倘若只追求最终一致性，可以选择异步应用；倘若追求立即一致性，则会要求 leader 先应用到状态机，才能给予客户端 ack.<h3 id="1-5-Leader选举"><a href="#1-5-Leader选举" class="headerlink" title="1.5  Leader选举"></a>1.5  Leader选举</h3></li><li>leader 需要定期向 follower 发送心跳，证明自己仍然健在. 与之对应的，follower 会建立一个心跳检测定时器，当超过指定时长未收到 leader 的心跳，则认为 leader 已死，会切换成候选人（candidate）发起竞选，尝试补位成为新的 leader.</li><li>follower 成为 candidate 后,会广播向所有节点拉票，当投赞同票的节点数（包括candidate 本身）达到多数派的时候，该 candidate 会胜任，成为新的 leader.</li></ul><h3 id="1-6-任期与日志索引"><a href="#1-6-任期与日志索引" class="headerlink" title="1.6  任期与日志索引"></a>1.6  任期与日志索引</h3><ul><li>每当一个 candidate 发起一轮竞选时，会将当前 term 在旧任期的基础上加1，倘若胜任成为新的 leader，这就将成为自己的“国号”.</li><li>值得一提的是，不是每个 term 都有 leader，因为可能在 candidate 未胜出的前提下，term 又进一步进行了累加，从而实现朝代的跨越.</li><li>但能够保证的是，<code>每个 term 至多只会有一个 leader</code></li><li>节点中的预写日志存放在一个数组中，每则日志在数组中的位置称之为索引 index.</li><li>于是，每一则预写日志会有两个核心的标识属性：<ul><li>term：标志了这则日志是哪个任期的 leader 在位时同步写入的；</li><li>index：标志了这则日志在预写日志数组的位置.</li></ul></li><li>通过 {term , index} 二元组可以组成一个全局唯一键，定位到一则日志，并且能够保证位于不同节点中日志，只要其 term 和 index 均相同，其内容一定完全一致</li></ul><h2 id="2-角色流转"><a href="#2-角色流转" class="headerlink" title="2. 角色流转"></a>2. 角色流转</h2><h3 id="2-1-角色定义及切换"><a href="#2-1-角色定义及切换" class="headerlink" title="2.1 角色定义及切换"></a>2.1 角色定义及切换</h3><ul><li><code>leader -&gt; follower</code><ul><li>倘若 leader 发现当前系统中出现了更大的任期，则会进行“禅让”，主动退位成 follower.</li><li>这里 leader 发现更大任期的方式包括：I 向 follower 提交日志同步请求时,从 follower 的响应参数中获得; II 收到了来自新任 leader 的心跳或者同步日志请求；III 收到了任期更大的 candidate 的拉票请求.</li></ul></li><li><code>follower -&gt; candidate</code><ul><li>leader 需要定期向 follower 发送心跳，告知自己仍健在的消息.</li><li>倘若 follower 超过一定时长没收到 leader 心跳时，会将状态切换为 candidate ，在当前任期的基础上加 1 作为竞选任期，发起竞选尝试补位.</li></ul></li><li><code>candidate -&gt; follower</code><ul><li>candidate 参与竞选过程中，出现以下两种情形时会退回 follower：<ul><li>多数派投了反对票；</li><li>竞选期间，收到了任期大于等于自身竞选任期的 leader 传来的请求.</li></ul></li></ul></li><li><code>candidate -&gt; leader</code><ul><li>candidate 竞选时，倘若多数派投了赞同票，则切换为 leader.</li></ul></li><li><code>candidate -&gt; candidate</code><ul><li>candidate 的竞选流程有一个时间阈值. 倘若超时仍未形成有效结论（多数派赞同或拒绝），则会维持 candidate 身份，将竞选任期加1，发起新一轮竞选.<h3 id="2-2-领导者"><a href="#2-2-领导者" class="headerlink" title="2.2 领导者"></a>2.2 领导者</h3>领导者是写请求的统一入口，在接收到来自客户端的写请求时，会开启“两阶段提交”的流程：</li></ul></li><li>广播 proposal，向所有节点同步这一请求；</li><li>当请求得到多数派的赞同后，才会提交这一请求.</li><li>leader 还需要周期性地向集群中所有节点发送自己的心跳，告知自己的健康状况，用途包括：</li><li>让 follower 重置心跳检测定时器，避免其切换成 candidate 发起竞选；</li><li>在心跳请求中携带上 leader 最新已提交日志的标识 id（term + index），推动 follower 更新日志提交进度.<h3 id="2-3-跟随者"><a href="#2-3-跟随者" class="headerlink" title="2.3 跟随者"></a>2.3 跟随者</h3></li><li>负责同步 leader 传来的写请求，此时也有一个参与民主反馈的过程，倘若同步成功，会给予 leader 正向反馈，当 leader 的同步请求收到半数以上的认可时，会提交日志；</li><li>通过接收 leader 心跳的方式，获取到携带的 commitIndex 信息，及时完成已被多数派认可的预写日志的提交，以推进其写入状态机的进度. 这一项相当于做到了数据的备份，也被读请求最终一致性提供了保证;</li><li>负责为参与竞选 candidate 的投票</li><li>通过心跳检测定时器时时关注 leader 的健康状态，当超时未收到心跳时，会切换为 candidate 发起竞选.<h3 id="2-4-候选人"><a href="#2-4-候选人" class="headerlink" title="2.4 候选人"></a>2.4 候选人</h3></li><li>倘若 follower 切为 candidate，会将当前任期加1，作为竞选任期；</li><li>会将自身的一票投给自己；</li><li>广播向所有节点拉票；</li><li>倘若拉票请求超时前，得到多数派认可，则上位为 leader；</li><li>倘若拉票请求超时前，遭到多数派拒绝，则老实退回 follower；</li><li>倘若拉票请求超时前，收到了任期大于等于自身竞选任期的 leader 的请求，则老实退回 follower；</li><li>倘若拉票请求超时，则竞选任期加 1，发起新一轮竞选拉票请求.</li></ul><h2 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3. 常见问题"></a>3. 常见问题</h2><h3 id="3-1-为什么能保证一个任期内至多只有一个领导者？"><a href="#3-1-为什么能保证一个任期内至多只有一个领导者？" class="headerlink" title="3.1 为什么能保证一个任期内至多只有一个领导者？"></a>3.1 为什么能保证一个任期内至多只有一个领导者？</h3><p>可以，通过选举的机制可以保证.</p><ul><li>首先，candidate 竞选前会自增 term，因此 term 在总体上为单调递增趋势；</li><li>其次，在选举机制上，一个 term 内，一个 follower 只有一票，因此只能投票给一个 candidate；</li><li>最后，基于多数派原则，一个 candidate 只有拿到半数以上的赞同票才能当选 leader.</li><li>因此，同一个 term 内，不可能出现有两个 candidate 同时获得半数以上的赞同票，因此一个 term 至多只有一个 leader.<h3 id="3-2-为什么能保证通过任期和索引相同的日志内容一定相同？"><a href="#3-2-为什么能保证通过任期和索引相同的日志内容一定相同？" class="headerlink" title="3.2 为什么能保证通过任期和索引相同的日志内容一定相同？"></a>3.2 为什么能保证通过任期和索引相同的日志内容一定相同？</h3></li><li>首先，预写日志具有 append-only 的性质，只作追加，不存在更新和删除操作；</li><li>其次，同一个 term 只有一个 leader；</li><li>因此，在 term 相同的情况下，所有节点在同一个 index 上的日志都会与 term 内 leader 对应 index 位置的日志保持一致；</li><li>综上，term 和 index 共同组成了一个全局唯一标识键. 只要term 和 index 均相同，日志内容一定相同<h3 id="3-3-关于选举机制方面，如何解决选票瓜分引发的问题？"><a href="#3-3-关于选举机制方面，如何解决选票瓜分引发的问题？" class="headerlink" title="3.3 关于选举机制方面，如何解决选票瓜分引发的问题？"></a>3.3 关于选举机制方面，如何解决选票瓜分引发的问题？</h3></li><li>每个节点在心跳超时阈值和竞选超时阈值上添加一个随机扰动值，通过这一扰动，避免多个节点在进入完全相同的竞选节奏. 于是进入 candidate 状态的节点有了先后之分，胜负自然就可见分晓.<h3 id="3-4-为什么新任-leader-一定拥有旧-leader-已提交的日志？"><a href="#3-4-为什么新任-leader-一定拥有旧-leader-已提交的日志？" class="headerlink" title="3.4 为什么新任 leader 一定拥有旧 leader 已提交的日志？"></a>3.4 为什么新任 leader 一定拥有旧 leader 已提交的日志？</h3>由两阶段提交和选举流程中的多数派原则保证的：</li><li>只有被集群多数派完成同步的日志才会被 leader 提交；</li><li>在选举流程中，节点只会把票投给日志进度不滞后于自身的 candidate；</li><li>在竞选流程，candidate 需要获取多数派的赞同票才能胜任，成为新任 leader.</li><li>可知，新任 leader 的日志进度一定能在竞选流程的多数派中出于不滞后的地位.</li><li>而在集群节点个数固定的情况下，本轮竞选流程的多数派和认可前任 leader 同步日志请求的多数派至少存在一个重复的节点，否则就违背了多数派的语义（集群半数以上），因此可以得知，新任 leader 一定拥有前任 leader 那笔被多数派认可的日志，即旧 leader 提交的日志.</li></ul><h3 id="3-5-leader-向-follower-同步日志时，如何保证不出现乱序、丢失、重复的问题？"><a href="#3-5-leader-向-follower-同步日志时，如何保证不出现乱序、丢失、重复的问题？" class="headerlink" title="3.5 leader 向 follower 同步日志时，如何保证不出现乱序、丢失、重复的问题？"></a>3.5 leader 向 follower 同步日志时，如何保证不出现乱序、丢失、重复的问题？</h3><ul><li>不乱序、不重复：follower 同步日志前，会校验上一笔日志是否和 leader 的上一笔完全一致，只有这样才会执行同步动作.</li><li>不丢失：基于 ack 机制保证. 倘若 leader 超时未收到 follower 同步日志的 ack，会重发同步日志请求.</li></ul><h3 id="3-6-如何保证各节点已提交的预写日志顺序和内容都完全一致？"><a href="#3-6-如何保证各节点已提交的预写日志顺序和内容都完全一致？" class="headerlink" title="3.6 如何保证各节点已提交的预写日志顺序和内容都完全一致？"></a>3.6 如何保证各节点已提交的预写日志顺序和内容都完全一致？</h3><ul><li>假设节点 a 最后一笔已提交的预写日志的 term = x、index = y，这说明集群中有多数派认同了 term 为 x 的 leader 同步该笔日志的请求.</li><li>首先证明：倘若其他节点在 index = y 位置的日志已提交了，则这笔日志的 term 一定也为 x.</li><li>证明思路：倘若节点 b 在 index = y 处的日志已提交，且任期为 z，那么就说明集群中有多数派认可了任期为 z 的 leader 同步的 term = z、index = y 的日志的请求. 由于集群不可能存在两个对立的多数派，因此唯一的可能性就是 z = x，原题得证.</li><li>接下来基于 7.2 小节的证明结论，我们可以得知各节点在 term = x、index = y 前面部分的日志也都完全一致，即各节点已提交的预写日志顺序和内容都完全一致.</li></ul><h3 id="3-7-如何保证状态机数据的最终一致性？"><a href="#3-7-如何保证状态机数据的最终一致性？" class="headerlink" title="3.7 如何保证状态机数据的最终一致性？"></a>3.7 如何保证状态机数据的最终一致性？</h3><ul><li>被提交的预写日志顺序和内容都必然是完全一致的.</li><li>又由于只有被提交的预写日志才能被应用到状态机，因此状态机的数据必然会按照正确的顺序和请求内容被依次更新，最终一致性得以保证.</li></ul><h3 id="3-8-如何解决网络分区引发的无意义选举问题？"><a href="#3-8-如何解决网络分区引发的无意义选举问题？" class="headerlink" title="3.8 如何解决网络分区引发的无意义选举问题？"></a>3.8 如何解决网络分区引发的无意义选举问题？</h3><ul><li>倘若集群产生网络分区，部分处于小分区的节点由于无法接收到 leader 的心跳，导致进入选举流程. 又因为网络分区问题，导致选举始终无法获得多数派的响应，最终 candidate 会无限自增 term. 直到网络恢复的那一刻，由于 candidate 异常的高 term，导致 leader 退位，集群进入新一轮的选举流程.</li><li>尽管小分区中的节点由于数据的滞后不可能在选举中胜出，最后必然是大分区中的节点胜任，节点数据的一致性依然可以得到保证. 但是这个无意义的选举过程同样会导致集群陷入暂不可用的阶段. 因此，我们可以通过这样的措施来避免这类无意义的选举：</li><li>每个 candidate 发起真实选举之前，会有一个提前试探的过程，试探机制是向集群所有节点发送请求，只有得到多数派的响应，证明自己不存在网络环境问题时，才会将竞选任期自增，并且发起真实的选举流程.</li></ul><h3 id="3-9-如果保证客户端提交写请求不丢失、不重复？"><a href="#3-9-如果保证客户端提交写请求不丢失、不重复？" class="headerlink" title="3.9 如果保证客户端提交写请求不丢失、不重复？"></a>3.9 如果保证客户端提交写请求不丢失、不重复？</h3><ul><li>不丢失：通过 ack 机制保证. 客户端超时未收到服务端的 ack，则会重发请求.</li><li>不重复：客户端记录写请求的序列号，与服务端交互时透传这个序列号. 最终由服务端的 leader 实现对相同序列号写请求的幂等去重.</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/09/10/System-Design/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/"/>
      <url>/2023/09/10/System-Design/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>分布式实际上就是单一的本地一体解决方案，在硬件或者资源上不够业务需求，而采取的一种分散式多节点，可以扩容资源的一种解决思路。</p><h2 id="1-一、从本地事务到分布式理论"><a href="#1-一、从本地事务到分布式理论" class="headerlink" title="1 一、从本地事务到分布式理论"></a>1 一、从本地事务到分布式理论</h2><p>事务提供一种机制将一个活动涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作只有在所有操作均能正常执行的情况下方能提交，只要其中任一操作执行失败，都将导致整个事务的回滚。</p><h3 id="1-1-1、ACID理论"><a href="#1-1-1、ACID理论" class="headerlink" title="1.1 1、ACID理论"></a>1.1 1、ACID理论</h3><ul><li><strong>原子性（Atomicity）</strong> 所有操作，要么全部完成，要么全部不完成</li><li><strong>一致性（Consistency）</strong> 在事务开始之前和事务结束以后，数据库数据的一致性约束没有被破坏。 不能说凭空多了 100 块钱</li><li><strong>隔离性（Isolation）</strong> 不受未提交事务的影响。隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</li><li><strong>持久性（Durability</strong>   事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。<h3 id="1-2-2、CAP-理论"><a href="#1-2-2、CAP-理论" class="headerlink" title="1.2 2、CAP 理论"></a>1.2 2、CAP 理论</h3>一个分布式系统最多只能同时满足<code>一致性（Consistency）</code>、<code>可用性（Availability）</code>和<code>分区容忍性（Partition Tolerance）</code>这三项中的两项。</li><li><strong><em>一致性</em></strong>   指“所有节点同时看到相同的数据”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致，等同于所有节点拥有数据的最新版本。</li><li><strong><em>可用性</em></strong>   指“任何时候，读写都是成功的”，即服务一直可用，而且是正常响应时间。</li><li><strong><em>分区容忍性</em></strong> 指“当部分节点出现消息丢失或者分区故障的时候，分布式系统仍然能够继续运行”，即系统容忍网络出现分区，并且在遇到某节点或网络分区之间网络不可达的情况下，仍然能够对外提供满足一致性和可用性的服务。</li><li>其中，<code>P 是确定的</code>，因为网络断开是客观存在的，因此就是选择 <strong>AP 架构</strong>还是 <strong>CP 架构</strong>的问题，实现更好的<strong>一致性和可用性</strong>。</li></ul></blockquote><pre><code>CP、AP 架构的取舍案例。Zookeeper用来解决分布式集群中应用系统的协调和一致性问题，因此是 CP。 Eureka等服务发现组件是为了保证可用性，因此是 AP。</code></pre><h3 id="1-3-3、Base-理论"><a href="#1-3-3、Base-理论" class="headerlink" title="1.3 3、Base 理论"></a>1.3 3、Base 理论</h3><blockquote><p>BASE是 <code>Basically Available(基本可用）</code>、<code>Soft state(软状态）</code>和 <code>Eventually consistent(最终一致性）</code>三个短语的简写。核心思想是<code>最终一致性</code>。</p><ul><li><em>基本可用</em>： 允许损失部分可用性，延长响应时间，降级服务，限流等时段。</li><li><em>软状态</em>： 允许系统在多个不同节点的数据副本存在数据延时。</li><li><em>最终一致性</em>： 数据不能一直处于软状态，在一个时间期限后保证所有副本的数据一致性。</li><li>Base 是对 CAP 的实际应用，放弃强一致性，实现基本可用。</li></ul></blockquote><h2 id="2-二、分布式事务解决方案"><a href="#2-二、分布式事务解决方案" class="headerlink" title="2 二、分布式事务解决方案"></a>2 二、分布式事务解决方案</h2><blockquote><p>两阶段和三阶段提交协议、 TCC 分段提交，和基于消息队列的最终一致性设计。</p><h3 id="2-1-1、2PC-两阶段提交"><a href="#2-1-1、2PC-两阶段提交" class="headerlink" title="2.1 1、2PC 两阶段提交"></a>2.1 1、2PC 两阶段提交</h3><p>Two-phase Commit Protocol  一致性、中心化的原子提交协议</p><ul><li><strong>提交请求阶段</strong>：协调者将通知事务参与者准备提交事务，然后进入表决过程。在表决过程中，参与者将告知协调者自己的决策。</li><li><strong>提交阶段</strong>：协调者基于投票结果进行决策，所有参与者同意则提交事务。</li><li><strong>问题</strong>：资源阻塞，协调者单点故障，通知丢失造成数据不一致。<h3 id="2-2-2、3PC-三阶段提交"><a href="#2-2-2、3PC-三阶段提交" class="headerlink" title="2.2 2、3PC 三阶段提交"></a>2.2 2、3PC 三阶段提交</h3>在 2PC 之上扩展的提交协议，主要是为了解决两阶段提交协议的阻塞问题，从原来的两个阶段扩展为三个阶段，增加了超时机制。</li><li>CanCommit 阶段：协调者向参与者发送 Can-Commit 请求</li><li>PreCommit 阶段：协调者发送预提交请求，全部通过则进入 Prepared 阶段。</li><li>DoCommit 阶段：进行事务提交和没收到通知后进行超时提交。</li><li>优点和问题：引入超时机制和预提交阶段，保证在最后提交前各节点状态一致<h3 id="2-3-3、TCC-分段提交"><a href="#2-3-3、TCC-分段提交" class="headerlink" title="2.3 3、TCC 分段提交"></a>2.3 3、TCC 分段提交</h3>分布式事务的处理模型，将事务过程拆分为 Try、Confirm、Cancel 三个步骤，在保证强一致性的同时，最大限度提高系统的可伸缩性与可用性。</li><li><strong><em>Try 阶段</em></strong>：先对资源进行锁定，资源处于中间态但不处于最终态</li><li><strong><em>Confirm 或 Cancel 阶段</em></strong>：在 Try 操作的基础上，真正提交这次修改操作还是回滚这次变更操作</li><li><code>事务协调器 TX Manager</code>：负责统筹分布式事务的执行，串联 Try -&gt; Confirm/Cancel 的两阶段流程. 在第一阶段中批量调用 TCC Component 的 Try 接口，根据其结果，决定第二阶段是批量调用 TCC Component 的 Confirm 接口还是 Cancel 接口<h3 id="2-4-4、基于消息补偿的最终一致性"><a href="#2-4-4、基于消息补偿的最终一致性" class="headerlink" title="2.4 4、基于消息补偿的最终一致性"></a>2.4 4、基于消息补偿的最终一致性</h3>具体实现上，基于消息补偿的一致性主要有本地消息表和第三方可靠消息队列等。<h4 id="2-4-1-基于-MQ-实现分布式事务"><a href="#2-4-1-基于-MQ-实现分布式事务" class="headerlink" title="2.4.1 基于 MQ 实现分布式事务"></a>2.4.1 基于 MQ 实现分布式事务</h4></li><li>MQ可以保证至少被消费一次，但是不能解决消息的重复性问题</li><li>消费者需要基于消息的唯一键执行幂等去重操作<h2 id="3-三、Paxos-算法"><a href="#3-三、Paxos-算法" class="headerlink" title="3 三、Paxos 算法"></a>3 三、Paxos 算法</h2><h3 id="3-1-1、Quorum-机制"><a href="#3-1-1、Quorum-机制" class="headerlink" title="3.1 1、Quorum 机制"></a>3.1 1、Quorum 机制</h3>在 N 个副本中，一次更新成功的如果有 W 个，那么我在读取数据时是要从大于 N－W 个副本中读取，这样就能至少读到一个更新的数据了。<br>  WARO：全部更新完成才能写，保证所有副本一致</li><li>定义： 限定一次最少要读的副本数，如共 N 个副本，更新了 W 个，则要读取 N-W+1 个，保证读的数据是最新的。</li><li>需要配合版本号机制来确认。<h3 id="3-2-2、Paxos-节点构成"><a href="#3-2-2、Paxos-节点构成" class="headerlink" title="3.2 2、Paxos 节点构成"></a>3.2 2、Paxos 节点构成</h3>  角色有三种，一个节点可以同时成为这三者</li><li>提案者（Proposer）：提出议案value，比如修改某个变量，一轮只批准一个 value。</li><li>批准者 （Acceptor）：value 超过半数（N/2+1）的 Acceptor 批准后才能通过</li><li>学习者（Learner）： 学习被批准的 value，参考 Quorum机制，至少读 N/2+1 个 Accpetor来学习到通过的 value。</li><li>Client 产生议题者<h3 id="3-3-3、选举过程"><a href="#3-3-3、选举过程" class="headerlink" title="3.3 3、选举过程"></a>3.3 3、选举过程</h3></li><li>准备阶段：Proposer生成唯一的 ProposalID，发送 Prepare 请求。Acceptor 收到后，本地持久化并返回已经接收的提案。</li><li>选举阶段：<ul><li>Proposer 发送 Accept，回复大于一半，发出accept 请求，并带上自己指定的 value。</li><li>Acceptor 应答 Accept，回复提交结果。</li><li>Proposer 统计投票，过半数回复成功，广播结果。失败则回到准备阶段。<h2 id="4-四、Raft-算法"><a href="#4-四、Raft-算法" class="headerlink" title="4 四、Raft 算法"></a>4 四、Raft 算法</h2><h3 id="4-1-1、-概念介绍"><a href="#4-1-1、-概念介绍" class="headerlink" title="4.1 1、 概念介绍"></a>4.1 1、 概念介绍</h3>使用了分治思想把算法流程分为三个子问题：选举（Leader election）、日志复制（Log replication）、安全性（Safety）三个子问题</li></ul></li><li>节点被分为 Leader Follower Cabdidate 三种角色：<ul><li><strong>Leader</strong>：处理与客户端的交互和与 follower 的日志复制等，一般只有一个 Leader；</li><li><strong>Follower</strong>：被动学习 Leader 的日志同步，同时也会在 leader 超时后转变为 Candidate 参与竞选；</li><li><strong>Candidate</strong>：在竞选期间参与竞选；</li></ul></li><li><strong><em>Term</em></strong>：<strong>Raft 算法将时间划分成为任意不同长度的任期（term）</strong>。任期用连续的数字进行表示。<strong>每一个任期的开始都是一次选举（election），一个或多个候选人会试图成为领导人</strong>。如果一个候选人赢得了选举，它就会在该任期的剩余时间担任领导人。在某些情况下，选票会被瓜分，有可能没有选出领导人，那么，将会开始另一个任期，并且立刻开始下一次选举。<strong>Raft 算法保证在给定的一个任期最多只有一个领导人</strong>。</li><li><strong><em>随机超时时间</em></strong>：Follower 节点每次收到 Leader 的心跳请求后，会设置一个随机的，区间位于（150ms, 300ms)的超时时间。如果超过超时时间，还没有收到 Leader 的下一条请求，则认为 Leader 过期/故障了。</li><li><strong>心跳续命</strong>：Leader 在当选期间，会以一定时间间隔向其他节点发送心跳请求，以维护自己的 Leader 地位。</li><li>Raft 算法中服务器节点之间通信使用远程过程调用（RPC）<ul><li>RequestVote RPC：候选人在选举期间发起。</li><li>AppendEntries RPC：领导人发起的一种心跳机制，复制日志也在该命令中完成。</li><li>installSnapshot RPC: 领导者使用该RPC来发送快照给太落后的追随者。<h3 id="4-2-2、协议流程"><a href="#4-2-2、协议流程" class="headerlink" title="4.2 2、协议流程"></a>4.2 2、协议流程</h3></li></ul></li><li><em>选举流程</em><ul><li>当某个 follower 节点在超时时间内未收到 Leader 的请求，将发起选举， 从一个 Follower 变成 Candidate</li><li>如果一个 Candidate 收到了超过半数的投票，则该节点晋升为 Leader，会广播给所有节点；开始进行日志同步、处理客户端请求等</li><li>term用来保证请求的合法性</li></ul></li><li><em>日志复制</em><ul><li><code>复制状态机</code>：不同节点从相同的初始状态出发，执行相同顺序的输入指令集后，会得到相同的结束状态。</li><li>节点初始化后具有相同初始状态，将一个客户端请求（command）封装到一个<code>log entry</code> 中。Leader 负责将这些 log entries 复制到所有的 Follower 节点，然后节点按照相同的顺序应用 commands，达到<code>最终的一致状态</code></li><li>Leader执行请求过程：<ul><li>本地追加日志信息；</li><li>并行发出 AppendEntries RPC 请求；</li><li>等待大多数 Follower 的回应。收到查过半数节点的成功提交回应，代表该日志被复制到了大多数节点中(committed)；</li><li>在状态机上执行 entry command。既将该日志应用到状态机，真正影响到节点状态(applied)；</li><li>回应 Client 执行结果；</li><li>确认 Follower 也执行了这条 command；如果 Follower 崩溃、运行缓慢或者网络丢包，Leader 将无限期地重试 AppendEntries RPC，直到所有 Followers 应用了所有日志条目。<h3 id="4-3-3、安全性及约束"><a href="#4-3-3、安全性及约束" class="headerlink" title="4.3 3、安全性及约束"></a>4.3 3、安全性及约束</h3><h4 id="4-3-1-选举安全性"><a href="#4-3-1-选举安全性" class="headerlink" title="4.3.1 选举安全性"></a>4.3.1 选举安全性</h4></li></ul></li></ul></li><li>任一任期内最多一个 leader 被选出，有多余的 Leader就是脑裂了<ul><li>一个节点某一任期内最多只能投一票；而节点 B 的 term 必须比 A 的新，A 才能给 B 投票</li><li>只有获得多数投票的节点才会成为 leader<h4 id="4-3-2-日志-append-only"><a href="#4-3-2-日志-append-only" class="headerlink" title="4.3.2 日志 append only"></a>4.3.2 日志 append only</h4></li></ul></li><li>leader 在某一 term 的任一位置只会创建一个 log entry，且 log entry 是 append-only</li><li>一致性检查，请求中会包含最新 log entry 的前一个 log 的 term 和 index，如果 follower 在对应的 term index 找不到日志就会重新进行同步<h4 id="4-3-3-日志匹配特性"><a href="#4-3-3-日志匹配特性" class="headerlink" title="4.3.3 日志匹配特性"></a>4.3.3 日志匹配特性</h4></li><li>如果两个节点上的某个 log entry 的 log index 相同且 term 相同，那么在该 index 之前的所有 log entry 应该都是相同的。<h4 id="4-3-4-Leader-完备性"><a href="#4-3-4-Leader-完备性" class="headerlink" title="4.3.4 Leader 完备性"></a>4.3.4 Leader 完备性</h4></li><li>被选举人必须比自己知道的更多（比较 term 、log index）<h4 id="4-3-5-状态机安全性"><a href="#4-3-5-状态机安全性" class="headerlink" title="4.3.5 状态机安全性"></a>4.3.5 状态机安全性</h4></li><li>状态机安全性由日志的一致来保证。在算法中，一个日志被复制到多数节点才算 committed， 如果一个 log entry 在某个任期被提交（committed），那么这条日志一定会出现在所有更高 term 的 leader 的日志里面</li></ul></blockquote><h2 id="5-五、ZooKeeper"><a href="#5-五、ZooKeeper" class="headerlink" title="5 五、ZooKeeper"></a>5 五、ZooKeeper</h2><pre><code>ZooKeeper 提供了一个类似于 Linux 文件系统的数据模型，和基于 Watcher 机制的分布式事件通知。</code></pre><h3 id="5-1-1、Zab-一致性协议"><a href="#5-1-1、Zab-一致性协议" class="headerlink" title="5.1 1、Zab 一致性协议"></a>5.1 1、Zab 一致性协议</h3><pre><code>ZooKeeper Atomic Broadcast，ZooKeeper 原子广播协议，保证分布式事务的最终一致性。具体实现</code></pre><ul><li>消息广播阶段，Leader 节点接受事务提交并将请求广播给 Follower 节点，根据反馈决定是否 Commit。</li><li>崩溃恢复阶段，Leader 宕机，重新进行 Leader 选举并进行数据同步。</li><li>Zxid: 事务编号，有一个新的 Leader 选举出现时，就会从这个 Leader 服务器上取出其本地日志中最大事务的 Zxid，并从中读取 epoch 值，然后加 1，以此作为新的周期 ID。高 32 位代表了每代 Leader 的唯一性，低 32 位则代表了每代 Leader 中事务的唯一性。</li></ul><h2 id="6-六、分布式锁"><a href="#6-六、分布式锁" class="headerlink" title="6 六、分布式锁"></a>6 六、分布式锁</h2><pre><code>分布式锁的目的是保证在分布式部署的应用集群中，多个服务在请求同一个方法或者同一个业务操作的情况下，对应业务逻辑只能被一台机器上的一个线程执行，避免出现并发问题。</code></pre><ul><li><strong>互斥性</strong>: 任意时刻，只有一个客户端能持有锁。</li><li><strong>锁超时释放</strong>：持有锁超时，可以释放，防止不必要的资源浪费，也可以防止死锁。</li><li><strong>可重入性</strong>:一个线程如果获取了锁之后,可以再次对其请求加锁。</li><li><strong>高性能和高可用</strong>：加锁和解锁需要开销尽可能低，同时也要保证高可用，避免分布式锁失效。</li><li><strong>安全性</strong>：锁只能被持有的客户端删除，不能被其他客户端删除<h3 id="6-1-1、基于数据库"><a href="#6-1-1、基于数据库" class="headerlink" title="6.1 1、基于数据库"></a>6.1 1、基于数据库</h3>  基于关系型数据库实现分布式锁，是依赖数据库的唯一性来实现资源锁定，比如主键和唯一索引等。<br>  问题：单点故障，超时无法失效，不可重入，不能阻塞。<h3 id="6-2-2、基于缓存-Redis"><a href="#6-2-2、基于缓存-Redis" class="headerlink" title="6.2 2、基于缓存 Redis"></a>6.2 2、基于缓存 Redis</h3></li><li>SETNX + EXPIRE：不是原子操作</li><li>SETNX + value值是(系统时间+过期时间)：要求时间同步，没有持有者的标识</li><li>使用Lua脚本(包含SETNX + EXPIRE两条指令)：原子性</li><li>SET的扩展命令（SET EX PX NX）：误删，过期还没执行完</li><li>SET EX PX NX + 校验唯一随机值,再删除：设置 value 标记线程</li><li>Redisson框架：开启一个定时守护线程，延长过期时间</li><li>setnx 是「set if not exists」</li></ul><blockquote><p>高可用，Redlock算法，基于 N 个完全独立的 Redis 节点，一般是大于 3 的奇数个</p><ul><li>客户端记录当前系统时间，以毫秒为单位；</li><li>依次尝试从 5 个 Redis 实例中，使用相同的 key 获取锁，当向 Redis 请求获取锁时，客户端应该设置一个网络连接和响应超时时间，超时时间应该小于锁的失效时间，避免因为网络故障出现的问题；</li><li>客户端使用当前时间减去开始获取锁时间就得到了获取锁使用的时间，当且仅当从半数以上的 Redis 节点获取到锁，并且当使用的时间小于锁失效时间时，锁才算获取成功；</li><li>如果获取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间，减少超时的几率；</li><li>如果获取锁失败，客户端应该在所有的 Redis 实例上进行解锁，即使是上一步操作请求失败的节点，防止因为服务端响应消息丢失，但是实际数据添加成功导致的不一致。</li></ul></blockquote><h3 id="6-3-3、基于Zookeeper"><a href="#6-3-3、基于Zookeeper" class="headerlink" title="6.3 3、基于Zookeeper"></a>6.3 3、基于Zookeeper</h3><ul><li>利用 ZooKeeper 支持临时顺序节点的特性，实现分布式锁。</li><li>当客户端对某个方法加锁时，在 ZooKeeper 中该方法对应的指定节点目录下，生成一个唯一的临时有序节点。</li><li>判断是否获取锁，只需要判断持有的节点是否是有序节点中序号最小的一个，当释放锁的时候，将这个临时节点删除即可，这种方式可以避免服务宕机导致的锁无法释放而产生的死锁问题。<ul><li>客户端连接 ZooKeeper，并在 /lock 下创建临时有序子节点，第一个客户端对应的子节点为 /lock/lock01/00000001，第二个为 /lock/lock01/00000002；</li><li>其他客户端获取 /lock01 下的子节点列表，判断自己创建的子节点是否为当前列表中序号最小的子节点；</li><li>如果是则认为获得锁，执行业务代码，否则通过 watch 事件监听 /lock01 的子节点变更消息，获得变更通知后重复此步骤直至获得锁；</li><li>完成业务流程后，删除对应的子节点，释放分布式锁。</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/09/10/Framework/MySQL/"/>
      <url>/2023/09/10/Framework/MySQL/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-架构与简介"><a href="#1-架构与简介" class="headerlink" title="1. 架构与简介"></a>1. 架构与简介</h2><h3 id="1-MySQL-架构"><a href="#1-MySQL-架构" class="headerlink" title="1 MySQL 架构"></a>1 MySQL 架构</h3><ul><li><em>Server 层</em>：建立连接、分析和执行 SQL；主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</li><li><em>存储引擎层</em>：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></li></ul><h3 id="2-SQL-语句执行过程"><a href="#2-SQL-语句执行过程" class="headerlink" title="2 SQL 语句执行过程"></a>2 SQL 语句执行过程</h3><blockquote><p>MySQL 执行一条 select 查询语句，在 MySQL 中期间发生了什么？</p><ul><li><em>连接器</em>：TCP 三次握手连接</li><li><em>查询缓存</em>：先去查询缓存（ Query Cache ）里查找缓存数据</li><li><em>解析 SQL</em>：解析器进行词法分析和语法分析</li><li><em>执行 SQL</em>：<ul><li><code>预处理器</code>：查询表和字段是否存在</li><li><code>优化器</code>：确定 SQL 语句执行方案，选择最高效的索引<ul><li>explain：select_type 查询类型； type 连接方式；key 用到的索引；rows 扫描出的行数</li></ul></li><li><code>执行器</code>：<ul><li>主键索引查询：选择符合的记录</li><li>全表扫描</li><li><strong><em>索引下推</em></strong>：<code>减少二级索引在查询时的回表操作</code>，将查询条件下推到存储引擎层面进行判断，而不是将数据加载到内存中由应用层进行过滤</li><li>exp： <code>where age &gt; 20 and reward = 100000</code>, 其中 age 可以用到联合索引，通过下推后，直接在存储引擎中过滤出<code>reward = 100000</code>的记录再去回表；<h3 id="3-记录存储"><a href="#3-记录存储" class="headerlink" title="3 记录存储"></a>3 记录存储</h3></li></ul></li></ul></li><li>数据存放：表结构（t_order.frm），表数据（t_order.ibd）</li><li>表空间文件结构：段（segment）、区（extent）、页（page，16KB）、行（row）</li><li><code>null 存储</code>：Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分</li><li>页的大小和结构： 16KB 文件头 页头 最小和最大记录 用户记录 空闲空间 页目录 文件尾</li><li>innodb的行格式：<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png" alt=""><pre><code>  1. 变长字段的真实数据占用的字节数会按照列的顺序**逆序存放**    **使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率**。  2. trx_id   事务id；roll_pointer  记录上一个版本的指针</code></pre></li></ul></blockquote><h2 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h2><h3 id="1-索引简介与-B-树"><a href="#1-索引简介与-B-树" class="headerlink" title="1 索引简介与 B+树"></a>1 索引简介与 B+树</h3><h4 id="1-1-什么是索引？"><a href="#1-1-什么是索引？" class="headerlink" title="1.1 什么是索引？"></a>1.1 什么是索引？</h4><ul><li>帮助存储引擎快速获取数据的一种数据结构</li><li>缺点：本身会占据物理空间；创建索引和维护索引要耗费时间；降低表的增删改的效率</li><li>使用场合：字段有唯一性限制，表数据多，更新不频繁<h4 id="1-2-B-树"><a href="#1-2-B-树" class="headerlink" title="1.2 B+树"></a>1.2 B+树</h4><blockquote><p>主键索引和二级索引默认使用的是 B+Tree 索引</p></blockquote></li><li><em>什么是 B+树？</em><ul><li>B 树：多叉树，左小右大，每个节点都包含索引和数据</li><li><em>B+树</em>:就是 B 树的升级<ul><li>叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引</li><li>所有索引都会在叶子节点出现，叶子节点之间构成一个<code>有序链表</code></li><li>非叶子节点中有多少个子节点，就有多少个索引</li><li>B+ 树点节点内容是数据页，数据页里存放了用户的记录以及各种信息，每个数据页默认大小是 16 KB</li></ul></li></ul></li><li><em>B+树优点</em>：<ul><li>B+树的非叶子节点可以存放更多的索引，出度更大</li><li>范围查询效率更高</li></ul></li><li>单表最大值：一般三层就可以存放两千万行数据，超过可能增加层级；内存放不下索引<h3 id="2-索引分类"><a href="#2-索引分类" class="headerlink" title="2 索引分类"></a>2 索引分类</h3></li><li>按数据结构： B+Tree 索引、HASH 索引、Full-Text 索引</li><li>按物理存储： <strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong> 叶子节点存放的是主键值，还要回表</li><li>按字段特性： <strong>主键索引、唯一索引、普通索引、前缀索引</strong></li><li>按字段个数： <strong>单列索引、联合索引</strong>   <ul><li>最左匹配原则：按照最左优先的方式进行索引的匹配</li><li>exp：（a，b，c）的索引会先按 a 排序，在 a 相同的情况下按 b 排序，再按 c 排序，因此<code>b 和 c 是全局无序，局部相对有序的</code>，所以 <code>where b=2 and c=3；</code> 无法利用索引</li><li>where a &gt; 1 and b = 2  只有 a 能利用联合索引<h3 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3 索引优化"></a>3 索引优化</h3></li></ul></li></ul><ol><li><code>前缀索引</code>优化： 可以减小索引项的大小，但是不能成为覆盖索引</li><li><code>覆盖索引</code>优化： 直接从二级索引获取数据，避免回表</li><li>主键索引<code>自增</code>：插入效率高；避免造成页分裂；主键字段的长度不要太大，减小二级索引规模</li><li>索引设置 NOT NULL：方便优化器选择<h3 id="4-索引失效"><a href="#4-索引失效" class="headerlink" title="4 索引失效"></a>4 索引失效</h3></li></ol><ul><li>使用左或者左右模糊匹配，like %xx</li><li>在查询条件中对索引列做了计算、函数、类型转换操作</li><li>联合索引未遵循最左匹配原则</li><li>WHERE 子句中， OR 前的条件列是索引列， OR 后不是，那么索引会失效<h2 id="3-事务"><a href="#3-事务" class="headerlink" title="3 事务"></a>3 事务</h2><h3 id="1-事务的特性-ACID"><a href="#1-事务的特性-ACID" class="headerlink" title="1 事务的特性 ACID"></a>1 事务的特性 ACID</h3></li><li><em><strong>原子性（Atomicity）</strong></em>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态； <code>由 undo log（回滚日志保证）</code></li><li><em><strong>一致性（Consistency）</strong></em>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态  <code>由持久性+原子性+隔离性 共同保证</code></li><li><em><strong>隔离性（Isolation）</strong></em>：防止多个事务并发执行时由于交叉执行而导致数据的不一致   <code>MVCC（多版本并发控制） 或锁机制</code></li><li><em><strong>持久性（Durability）</strong></em>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。     <code>redo log （重做日志）</code><h3 id="2-并行事务的问题"><a href="#2-并行事务的问题" class="headerlink" title="2 并行事务的问题"></a>2 并行事务的问题</h3></li><li><strong>脏读</strong>： 一个事务「读到」了另一个「<strong>未提交事务修改过的数据</strong>」</li><li><strong>不可重复读</strong>：在一个事务内多次读取同一个数据，前后两次读到的<strong>数据</strong>不一样</li><li><strong>幻读</strong>：在一个事务内多次查询某个符合查询条件的「记录数量」，前后两次查询到的<strong>记录数量</strong>不一样<h3 id="3-事务的隔离级别"><a href="#3-事务的隔离级别" class="headerlink" title="3 事务的隔离级别"></a>3 事务的隔离级别</h3></li><li><strong>读未提交（<em>read uncommitted</em>）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到； <strong>会脏读</strong></li><li><strong>读提交（<em>read committed</em>）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到； <strong>会不可重复读</strong></li><li><strong>可重复读（<em>repeatable read</em>）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>； <strong>会幻读</strong></li><li><strong>串行化（<em>serializable</em> ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；  都不会，但是影响性能</li><li><em>默认的隔离级别</em>：可重复读，用以下方法解决幻读<ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong></li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong></li></ul></li><li>幻读完全解决了吗？ 没有<ol><li>对于快照读，当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，就会产生幻读</li><li>对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。</li><li>在开启事务之后，马上执行 select … for update 这类当前读的语句</li></ol></li></ul><h3 id="4-MVCC-与-ReadView"><a href="#4-MVCC-与-ReadView" class="headerlink" title="4 MVCC 与 ReadView"></a>4 MVCC 与 ReadView</h3><ul><li><em>MVCC 原理</em>？<ul><li>Multi-Version Concurrency Control 多版本并发控制</li><li>核心思想是为每个事务创建一个独立的数据库快照，每个事务在操作时都会基于事务 ID 来访问数据库的对应版本</li></ul></li><li><em>ReadView 的数据结构</em>？  四个字段和聚簇索引记录中的两个隐藏列<ul><li><code>m_ids</code> ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li><li><code>min_trx_id</code> ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</li><li><code>max_trx_id</code> ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</li><li><code>creator_trx_id</code> ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</li><li><code>trx_id</code>，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li><li><code>roll_pointer</code>，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li></ul></li><li><em>可重复读实现</em>？<ul><li>启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</li></ul></li><li><em>读提交实现</em>？<ul><li>在每次读取数据时，都会生成一个新的 Read View</li></ul></li></ul><h2 id="4-锁"><a href="#4-锁" class="headerlink" title="4. 锁"></a>4. 锁</h2><h3 id="1-MySQL-有哪些锁？"><a href="#1-MySQL-有哪些锁？" class="headerlink" title="1 MySQL 有哪些锁？"></a>1 MySQL 有哪些锁？</h3><h4 id="1-1-全局锁"><a href="#1-1-全局锁" class="headerlink" title="1.1 全局锁"></a>1.1 全局锁</h4><ul><li><em>启用</em>：flush tables with read lock    数据库处于只读状态</li><li><em>使用场景</em>：全库备份</li><li>如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作<h4 id="1-2-表级锁"><a href="#1-2-表级锁" class="headerlink" title="1.2 表级锁"></a>1.2 表级锁</h4></li><li><em>表锁</em>：颗粒度太大，性能较差</li><li><em>元数据锁</em>：防止其他线程变更表结构</li><li><em>意向锁</em>：<strong>快速判断表里是否有记录被加锁</strong><ul><li>当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁</li></ul></li><li><em>AUTO-INC 锁</em>：实现主键自增<ul><li>在插入数据时，会加一个表级别的 AUTO-INC 锁，插入语句完成后就释放<h4 id="1-3-行级锁"><a href="#1-3-行级锁" class="headerlink" title="1.3 行级锁"></a>1.3 行级锁</h4></li></ul></li><li><em>Record Lock</em>：记录锁，锁住一条记录；只有 S 型记录锁兼容</li><li><em>Gap Lock</em>：间隙锁，解决可重复读隔离级别下的幻读现象； 如（3，5）会锁住 4</li><li><em>Next-Key Lock</em>：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身；（3，5] 锁住 4，5</li><li><em>插入意向锁</em>：插入有间隙锁位置会发生<strong>阻塞</strong>，生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态</li><li>Innodb 在扫描记录的时，都是针对索引项这个单位去加锁的， update 不带索引就是全表扫描，也就是表里的索引项都加锁，相当于锁了整张表<h4 id="1-4-死锁"><a href="#1-4-死锁" class="headerlink" title="1.4 死锁"></a>1.4 死锁</h4></li><li>两个事务即使生成的间隙锁的范围是一样的，也不会发生冲突，因为间隙锁目的是为了防止其他事务插入数据，因此间隙锁与间隙锁之间是相互兼容的。</li><li>在执行插入语句时，如果插入的记录在其他事务持有间隙锁范围内，插入语句就会被阻塞，因为插入语句在碰到间隙锁时，会生成一个插入意向锁，然后插入意向锁和间隙锁之间是互斥的关系。</li><li>如果两个事务分别向对方持有的间隙锁范围内插入一条记录，而插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，满足了死锁的四个条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>，因此发生了死锁</li><li>事务 A 和事务 B 在执行完后 update 语句后都持有范围为<code>(20, 30）</code>的间隙锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待</li></ul><h2 id="5-日志"><a href="#5-日志" class="headerlink" title="5. 日志"></a>5. 日志</h2><h3 id="1-undo-log（回滚日志）"><a href="#1-undo-log（回滚日志）" class="headerlink" title="1 undo log（回滚日志）"></a>1 undo log（回滚日志）</h3><ul><li>innodb 存储引擎层生成的日志，实现了事务中的 <em><strong>原子性</strong></em> ，主要用于事务回滚和 MVCC</li><li>当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里</li><li>在<code>事务没提交之前</code>，MySQL 会先记录更新前的数据到 undo log 日志文件里面</li><li><em>ReadView + undo log 实现 MVCC</em>：undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的<code>版本链</code>找到满足其<code>可见性</code>的记录</li><li>持久化：buffer pool 中有 undo 页，对 undo 页的修改也都会记录到<code>redo log</code>，redo log 会每秒刷盘，提交事务时也会刷盘<h3 id="2-Buffer-Pool-缓冲池"><a href="#2-Buffer-Pool-缓冲池" class="headerlink" title="2 Buffer Pool  缓冲池"></a>2 Buffer Pool  缓冲池</h3></li><li><em>基于内存，提高数据库的读写性能</em></li><li><em>Buffer Pool 缓存什么</em>：「索引页」和「数据页」，还包括了 Undo 页，插入缓存、自适应哈希索引、锁信息等</li><li>修改记录先缓存 到 change buffer，找机会去写入磁盘<pre><code>  1. 唯一索引不会用 change buffer，因为对应数据页已经加载到内存了--判断唯一性  2. 优点：减少磁盘访问次数；提高内存利用率</code></pre></li><li><strong>缓页管理方式</strong><pre><code>  1. Free List （空闲页链表），管理空闲页；  2. Flush List （脏页链表），管理脏页；  3. LRU List，管理脏页+干净页，将最近且经常查询的数据缓存在其中，而不常查询的数据就淘汰出去；分为 young 和 old 两个区域，先插入 old，被访问进入 young，解决数据批量访问，和大量热数据淘汰的问题；</code></pre><h3 id="3-redo-log（物理日志）"><a href="#3-redo-log（物理日志）" class="headerlink" title="3 redo log（物理日志）"></a>3 redo log（物理日志）</h3></li><li>作用：记录了某个数据页做了什么修改，在事务提交时，只要先将 redo log 持久化到磁盘即可；记录了事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值</li><li><strong><em>预写日志WAL</em></strong>：写操作并不是立刻写到磁盘上，而是先写日志，后面再等待时机写入磁盘</li><li><strong><em>crash-safe</em></strong>（崩溃恢复）：即使数据库发生异常重启，之前已提交的记录都不会丢失，保证了持久性</li><li><strong>优点</strong>：redo log 是追加操作，所以是顺序写，开销更小</li><li><strong>刷盘时机</strong>： 事务提交；每秒；关闭数据库； redo log buffer占用过半</li><li>redo log满了？阻塞，刷新脏页到磁盘，擦除 对应的 redo log 记录腾出空间</li></ul><h3 id="4-bin-log"><a href="#4-bin-log" class="headerlink" title="4 bin log"></a>4 bin log</h3><ul><li>undo 和 redo 都是Innodb 存储引擎生成的，binlog 是 Server 层生成的</li><li>使用对象：Server 层实现的日志，所有存储引擎都可以使用</li><li>文件格式： STATEMENT（默认格式，记录 SQL）、ROW（记录行数据）、 MIXED</li><li>写入方式：追加写，会覆盖以前的日志，保存的是全量的日志。</li><li>作用：用于<strong>主从复制，备份恢复</strong></li><li>binlog cache刷盘：事务提交，内存超了</li><li><strong><em>主从复制实现</em></strong><ol><li><em>主从复制流程</em><ol><li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</li><li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</li><li><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。</li></ol></li><li><em>复制步骤</em><ol><li>主节点log dump线程：当从节点连接主节点时，主节点会创建一个log dump 线程，用于发送bin-log的内容。在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成，甚至在发动给从节点之前，锁会被释放。</li><li>从节点I/O线程：当从节点上执行<code>start slave</code>命令之后，从节点会创建一个I/O线程用来连接主节点，请求主库中更新的bin-log。I/O线程接收到主节点bin log dump 进程发来的更新之后，保存在本地relay-log中。</li><li>从节点SQL线程：SQL线程负责读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。</li></ol></li><li><em>复制模型</em><ol><li>同步复制：性能差</li><li>异步复制：主库宕机数据会丢失</li><li>半同步复制：从库成功一个就行</li></ol></li><li><em>主从同步延迟</em><ol><li>从库只有一个sql Thread，主库写压力大，复制很可能延时；或者从库有大型 query 产生锁等待</li><li>解决：要求高就走主库；sleep 一下；判断一下主备延迟</li></ol></li></ol></li><li><strong><em>两阶段提交</em></strong>    防止<strong>redo log</strong>和<strong>binlog</strong>不一致，导致主从数据不一致；内部 XA 事务<ol><li><strong><em>prepare</em> 阶段</strong>：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li><li><strong><em>commit 阶段</em></strong>：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li><li><strong>是否能在 binlog 中查找到与 redo log 相同的 XID</strong>，如果有就提交事务，如果没有就回滚事务。</li><li>组提交：<strong>有多个事务提交的时候，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I/O 的次数</strong></li><li>问题：磁盘 IO 次数高，锁竞争激烈</li></ol></li></ul><h2 id="6-架构与-SQL-基础"><a href="#6-架构与-SQL-基础" class="headerlink" title="6. 架构与 SQL 基础"></a>6. 架构与 SQL 基础</h2><h3 id="1-SQL-基础"><a href="#1-SQL-基础" class="headerlink" title="1 SQL 基础"></a>1 SQL 基础</h3><ol><li><em>数据库四大范式</em><ol><li>第一范式（1NF）：属性不可拆分 或 无重复的列</li><li>第二范式（2NF）：非主属性对多属性候选键完全函数依赖</li><li>第三范式（3NF）：消除传递依赖  表中不包含已在其它表中已包含的非主属性信息。</li><li>BC范式（BCNF）：候选键存在多个属性时，多个主属性直接要消除传递依赖关系     主属性之间不应该有互相依赖。工号和身份证号是相互依赖。</li><li>第四范式（4NF）：对于候选键只能存在不超过1个多值属性。要求把同一表内的多对多关系删除。</li></ol></li><li><em>分页查询后期性能变慢的原因</em>    深分页问题<ol><li><strong>limit m n</strong>：查询从 m 开始的 n 条数据；扫 m+n 行 丢弃前 m 行</li><li><strong>limit n offset m</strong>：从 m 开始的 n 条</li><li><code>为什么慢</code>？ <ol><li>分页偏移量的增加，需要扫描和跳过的前面的行来到达指定的偏移量，造成浪费，也就是说<code>limit 100000,10</code>，就会扫描100010行</li><li><code>limit 100000,10</code> 扫描更多的行数，也意味着回表判断的次数更多</li></ol></li><li>优化：<ol><li>子查询优化：把条件转移到主键索引树，然后减少回表，比如先查到第 10000 个</li><li>INNER JOIN 延迟关联：先通过二级索引树查询到满足条件的主键ID，再与原表通过主键ID内连接</li><li>基于游标的分页：使用游标或主键来定位结果集中的特定行，而不是使用偏移量。这种方法通常比OFFSET更高效</li><li>使用between…and…：转换成已知位置的查询</li><li>使用合适的索引：确保查询中使用了适当的索引，以减少排序和过滤操作的成本</li></ol></li></ol></li><li>SQL(聚集函数，group by， having 子句， order by, 连接(内连接、外连接(左右)))<ol><li><strong>group by</strong>： 根据一个或多个列对结果集进行分组</li><li><strong>having</strong>：筛选分组后的各组数据    where在group by前， having在group by 之后</li><li><strong>order by</strong>：排序  desc 降序； asc 升序</li><li>连接：<ol><li>inner join：  只取交集</li><li>left join：左表所有行和右表匹配的，不匹配的行返回 null</li><li>right join：和上面类似</li><li>full join：全连接，取并集</li></ol></li></ol></li><li>慢查询日志<ol><li>set global slow_query_log = on;  long_query_time</li><li>mysqldumpslow进行分析<h3 id="2-架构"><a href="#2-架构" class="headerlink" title="2 架构"></a>2 架构</h3></li></ol></li><li>MySQL集群的结构有哪些？各自优缺点？<ol><li>主从架构  读写分离，数据备份</li><li>主主互备  </li></ol></li><li>分库分表的场景？   数据库性能瓶颈  <strong>IO瓶颈</strong>   <strong>CPU瓶颈</strong><ol><li>水平分库： 按 hash 或者 range 策略分到多个库里； 应对高并发</li><li>水平分表：将一个表中的数据拆分到多个表中；单表数据太多，影响 SQL 效率；</li><li>垂直分库：按业务归属不同分库；可以抽象出单独的业务模块</li><li>垂直分表：按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。  字段多，热点数据分离出来；不可用 join</li><li>分配策略： hash 取模；范围分片；地理位置；时间</li></ol></li><li>如何不停服迁移库表？<ol><li><strong>不停服，增加缓冲层（MQ），数据迁移过程中增量数据写入缓存，在数据迁移完成、缓冲层数据消费完成后，打开开关开始双写数据库</strong></li></ol></li><li>怎么分库分表才能均匀？分库分表后某些分片热点写入怎么解决？<ol><li>使用哈希算法：对于分片键（通常是某个列或多个列的组合），使用哈希算法来决定数据应该存储在哪个分片上。这样可以确保数据在分片之间均匀分布，减少热点问题。</li><li>增加分片数量：**如果你发现某些分片写入热点问题，可以考虑增加分片的数量。这会增加分片的数量，减少每个分片的负载，提高了吞吐量。</li><li>负载均衡：使用负载均衡策略来确保访问请求均匀地分布到不同的分片上。负载均衡可以在应用层或数据库代理层实现。</li><li>随机数分片：使用随机数来分配数据到分片，这可以减少数据的热点写入问题，但可能增加查询的复杂性。</li><li>分片键设计：精心设计分片键是解决热点写入问题的关键。尽量避免选择容易导致热点的分片键，例如自增主键。</li><li>数据迁移：定期监测数据分布，如果发现某个分片过于热点，可以考虑进行数据迁移，将一些数据从热点分片移到其他分片上，以实现负载均衡。</li><li>垂直分片：考虑将表按照功能或业务需求进行垂直分片，将不同类型的数据存储在不同的分片上。这可以减少写入热点问题。</li><li>缓存：使用缓存来缓解数据库写入压力。将热点数据缓存到内存中，减少对数据库的频繁写入请求。</li><li>异步写入：如果一些写入操作不需要立即生效，可以考虑将它们异步化，以减轻数据库的写入负载。例如，使用消息队列将写入操作异步处理。</li></ol></li><li>数据库主库挂了，在存在主从延时的情况下，切从的过程中，查询的数据不一致怎么处理<ol><li><strong>等待同步完成</strong>：在进行主从切换前，可以等待从库追赶主库的进度，确保从库的数据已经和主库同步完全。这可以通过监测主从延时来确定。一旦主从延时减少到可以接受的水平，再进行切换。</li><li><strong>切换到可用从库</strong>：如果主从切换后发现某个从库数据不一致，可以尝试切换到另一个可用的从库。这需要确保备用从库与主库的数据同步是正常的。</li><li><strong>手动同步数据</strong>：在切换完成后，可以考虑手动同步数据以修复不一致。这可能涉及将缺失的数据从主库手动导入到从库，以确保一致性。</li><li><strong>数据一致性检查</strong>：在切换后，可以运行一些数据一致性检查工具或脚本来检查数据是否一致。如果发现不一致的数据，可以进行修复。</li><li><strong>定期备份</strong>：在数据库正常运行期间，定期进行数据库备份，包括主库和从库。在切换后，如果出现数据不一致问题，可以使用备份进行恢复。</li><li><strong>容错和监控</strong>：实现主从切换时，确保有足够的监控和容错机制。这样，如果出现问题，可以迅速发现并采取措施来减小数据不一致的风险。</li><li><strong>故障回滚</strong>：如果切换后发现数据不一致问题无法解决，可以考虑回滚到原来的主库，然后采取更谨慎的方式来进行切换，例如逐渐减小主从延时。</li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/09/09/Framework/Kafka/"/>
      <url>/2023/09/09/Framework/Kafka/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Kafka-基础"><a href="#Kafka-基础" class="headerlink" title="Kafka 基础"></a>Kafka 基础</h2><h3 id="1-架构"><a href="#1-架构" class="headerlink" title="1 架构"></a>1 架构</h3><blockquote><p>分布式的、分区化、可复制提交的日志服务<br><img src="https://pic1.zhimg.com/80/v2-672b6f858c187b5c8182c553cd597f14_1440w.webp" alt=""></p><ul><li><em>Producer</em>：消息生产者，就是向 kafka broker 发消息的客户端。</li><li><em>Consumer</em> ：消息消费者，向 kafka broker 取消息的客户端。</li><li><em>Topic</em> ：可以理解为一个队列，一个 Topic 又分为一个或多个分区。</li><li><em>Consumer Group</em>：这是 kafka 用来实现一个 topic 消息的广播（发给所有的 consumer）和单播（发给任意一个 consumer）的手段。一个 topic 可以有多个 Consumer Group。</li><li><em>Broker</em> ：一台 kafka 服务器就是一个 broker。一个集群由多个 broker 组成。一个 broker 可以容纳多个 topic。</li><li><em>Partition</em>：为了实现扩展性，一个非常大的 topic 可以分布到多个 broker上，每个 partition 是一个有序的队列。partition 中的每条消息都会被分配一个有序的id（offset）。将消息发给 consumer，kafka 只保证按一个 partition 中的消息的顺序，不保证一个 topic 的整体（多个 partition 间）的顺序。</li><li><em>Offset</em>：kafka 的存储文件都是按照 offset.kafka 来命名，用 offset 做名字的好处是方便查找。例如你想找位于 2049 的位置，只要找到 2048.kafka 的文件即可。当然 the first offset 就是00000000000.kafka。<h3 id="2-特点"><a href="#2-特点" class="headerlink" title="2 特点"></a>2 特点</h3></li><li><em>高吞吐量、低延迟</em>：每秒可以处理几十万条消息，它的延迟最低只有几毫秒，每个topic可以分多个partition, consumer group 对partition进行consume操作。</li><li><em>可扩展性</em>：kafka集群支持热扩展</li><li><em>持久性、可靠性</em>：消息被持久化到本地磁盘，并且支持数据备份防止数据丢失</li><li><em>容错性</em>：允许集群中节点失败（若副本数量为n,则允许n-1个节点失败）</li><li><em>高并发</em>：支持数千个客户端同时读写<h3 id="3-怎么实现高吞吐量的？"><a href="#3-怎么实现高吞吐量的？" class="headerlink" title="3 怎么实现高吞吐量的？"></a>3 怎么实现高吞吐量的？</h3></li><li><em>分区</em>：多分区通过负载均衡提高了消息并发写入和消费的能力</li><li><em>批量发送和压缩消息</em>：<ul><li><code>批量发送</code>：将消息缓存在内存中的双端队列中，然后Sender线程将从各分区对应的队列中获取已准备好的消息批次，将消息进行批量发送，减少网络传输频次，提高传输效率。</li><li><code>端到端压缩消息</code>：将一批消息打包后进行压缩，在 Consumer 端进行解压</li></ul></li><li><em>顺序读写</em>：将消息messaga追加到本地磁盘文件的末尾</li><li><em>零拷贝ZeroCopy</em>：将数据直接从磁盘文件复制到网卡设备中，避免重新复制数据<ul><li>操作系统从磁盘读取数据到内核空间的 pagecache</li><li>应用程序读取内核空间的数据到用户空间的缓冲区</li><li>应用程序将数据(用户空间的缓冲区)写回内核空间到套接字缓冲区(内核空间)</li><li>操作系统将数据从套接字缓冲区(内核空间)复制到通过网络发送的 NIC 缓冲区</li></ul></li><li><em>PageCache</em>：利用了现代操作系统分页存储 Page Cache 来利用内存提高 I/O 效率<h3 id="4-高可靠性实现"><a href="#4-高可靠性实现" class="headerlink" title="4 高可靠性实现"></a>4 高可靠性实现</h3></li><li>副本机制</li><li><h3 id="5-使用场景"><a href="#5-使用场景" class="headerlink" title="5 使用场景"></a>5 使用场景</h3></li><li>日志收集</li><li>消息系统</li><li>用户活动跟踪<h2 id="主题与日志"><a href="#主题与日志" class="headerlink" title="主题与日志"></a>主题与日志</h2><h3 id="1-Kafka创建Topic时如何将分区放置到不同的Broker中"><a href="#1-Kafka创建Topic时如何将分区放置到不同的Broker中" class="headerlink" title="1 Kafka创建Topic时如何将分区放置到不同的Broker中"></a>1 Kafka创建Topic时如何将分区放置到不同的Broker中</h3></li><li>副本因子不能大于 Broker 的个数；</li><li>第一个分区（编号为0）的第一个副本放置位置是随机从 brokerList 选择的；</li><li>其他分区的第一个副本放置位置相对于第0个分区依次往后移。也就是如果我们有5个 Broker，5个分区，假设第一个分区放在第四个 Broker 上，那么第二个分区将会放在第五个 Broker 上；第三个分区将会放在第一个 Broker 上；第四个分区将会放在第二个 Broker 上，依次类推；</li><li>剩余的副本相对于第一个副本放置位置其实是由 nextReplicaShift 决定的，而这个数也是随机产生的<h3 id="2-Kafka-分区数可以增加或减少吗？为什么？"><a href="#2-Kafka-分区数可以增加或减少吗？为什么？" class="headerlink" title="2 Kafka 分区数可以增加或减少吗？为什么？"></a>2 Kafka 分区数可以增加或减少吗？为什么？</h3></li><li>可以使用 bin/kafka-topics.sh命令对 Kafka 增加 Kafka 的分区数据，但是 Kafka 不支持减少分区数。</li><li>Kafka 分区数据不支持减少是由很多原因的，比如减少的分区其数据放到哪里去？是删除，还是保留？删除的话，那么这些没消费的消息不就丢了。如果保留这些消息如何放到其他分区里面？追加到其他分区后面的话那么就破坏了 Kafka 单个分区的有序性。如果要保证删除分区数据插入到其他分区保证有序性，那么实现起来逻辑就会非常复杂</li><li>会在含有分区目录最少的文件夹中创建新的分区目录<h3 id="3-kafka分区是不是越多越好"><a href="#3-kafka分区是不是越多越好" class="headerlink" title="3 kafka分区是不是越多越好"></a>3 kafka分区是不是越多越好</h3></li><li>句柄开销过大：每增加一个分区，对应的也会增加一个文件描述符，而一个进程所能支配的文件描述符是有限的，这也就是通常说的文件句柄开销。当分区数量超过进程能支配的文件描述符数量时，将出现 <code>Too many open files</code>错误.</li><li>生产端占用内存过大：kafka 发送消息时不是立刻发送的，而是会先将每个分区的消息先进行缓存（缓存区大小由<code>batch.size</code>设置，默认16KB），缓存满了后才会发送消息。分区越多的情况下，分区占用的缓存区也将更大。</li><li>影响系统可用性：broker数量一定的情况下，分区数量越大则每个broker 中所拥有的分区leader副本数量也将更多。broker出现故障后需要进行leader角色切换的分区数量会很大，导致故障恢复时间较长。<h2 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h2><h3 id="1-消息分区选择"><a href="#1-消息分区选择" class="headerlink" title="1 消息分区选择"></a>1 消息分区选择</h3><h3 id="2-Kafka-分区的目的？"><a href="#2-Kafka-分区的目的？" class="headerlink" title="2 Kafka 分区的目的？"></a>2 Kafka 分区的目的？</h3>分区对于 Kafka 集群的好处是：实现负载均衡。分区对于消费者来说，可以提高并发度，提高效率。<h3 id="3-ack参数设置及意义"><a href="#3-ack参数设置及意义" class="headerlink" title="3 ack参数设置及意义"></a>3 ack参数设置及意义</h3>参数设置： 设置 <code>request.required.acks=-1</code> ，只有 ISR 中所有副本都成功写入消息后才认为 kafka 消息成功写入。acks 参数其他配置项意义如下：</li><li><code>acks = 1</code>(默认)：分区leader 副本写入成功即认为消息成功写入，只确保leader发送成功</li><li><code>acks = 0</code> ：不需要等待任何服务端的响应都可认为消息成功写入，安全性最低但是效率最高。</li><li><code>acks = -1/ all</code> ：代表producer往集群发送数据需要所有的follower都完成从leader的同步才会发送下一条，确保 leader发送成功和所有的副本都完成备份。<h3 id="4-幂等特性"><a href="#4-幂等特性" class="headerlink" title="4 幂等特性"></a>4 幂等特性</h3></li><li>一次或者多次请求某一个资源对于资源本身应该具有同样的结果</li><li><strong>唯一标识</strong>：判断某个请求是否重复，需要有一个唯一性标识，然后服务端就能根据这个唯一标识来判断是否为重复请求。</li><li><strong>记录已经处理过的请求</strong>：服务端需要记录已经处理过的请求，然后根据唯一标识来判断是否是重复请求，如果已经处理过，则直接拒绝或者不做任何操作返回成功。</li><li>只能保证生产端在单个会话内的幂等，如果生产端因为某些原因意外挂掉然后重启，此时是没办法保证幂等的，因为这时没办法获取到之前的状态信息，即无法做到跨会话级别的幂等。</li><li>幂等性不能跨多个主题分区，只能保证单个分区内的幂等，涉及到多个消息分区时，中间的状态并没有同步<h3 id="5-Kafka-是如何做到消息的有序性？"><a href="#5-Kafka-是如何做到消息的有序性？" class="headerlink" title="5 Kafka 是如何做到消息的有序性？"></a>5 Kafka 是如何做到消息的有序性？</h3></li><li>kafka 中的每个 partition 中的消息在写入时都是有序的，而且单独一个 partition 只能由一个消费者去消费，可以在里面保证消息的顺序性。但是分区之间的消息是不保证有序的。</li><li>设置一个topic一个partition，消费者单线程消费</li><li>消息发送指定key，确保相同key的消息发送到同一个partition<h3 id="6-Kafka如何保证消息不丢失"><a href="#6-Kafka如何保证消息不丢失" class="headerlink" title="6 Kafka如何保证消息不丢失"></a>6 Kafka如何保证消息不丢失</h3></li><li><em>生产者</em>：ACK 机制</li><li><em>broker</em>：多副本和副本同步机制；保证ISR副本数量大于等于二</li><li><em>消费者</em>：<ul><li>消息消费关闭自动提交，改为手动提交offset，确保消息可再次消费</li><li>在第一点的前提下，涉及到消息的重复消费，所以消费端应做好消息的幂等处理<h3 id="7-Kafka-Producer-的执行过程？"><a href="#7-Kafka-Producer-的执行过程？" class="headerlink" title="7 Kafka Producer 的执行过程？"></a>7 Kafka Producer 的执行过程？</h3></li></ul></li><li>Producer生产消息</li><li>从Zookeeper找到Partition的Leader</li><li>推送消息</li><li>通过ISR列表通知给Follower</li><li>Follower从Leader拉取消息，并发送ack</li><li>Leader收到所有副本的ack，更新Offset，并向Producer发送ack，表示消息写入成功。<h3 id="8-Kafka消息是采用Pull模式，还是Push模式？"><a href="#8-Kafka消息是采用Pull模式，还是Push模式？" class="headerlink" title="8 Kafka消息是采用Pull模式，还是Push模式？"></a>8 Kafka消息是采用Pull模式，还是Push模式？</h3></li><li>producer将消息推送到broker，consumer从broker拉取消息</li><li>consumer可以自主的根据消费能力和策略决定是否批量的从broker拉取数据<h3 id="9-如何保证消息不被重复消费？"><a href="#9-如何保证消息不被重复消费？" class="headerlink" title="9 如何保证消息不被重复消费？"></a>9 如何保证消息不被重复消费？</h3></li><li>生产者在向Kafka写数据时，每条消息会有一个offset，表示消息写入顺序的序号。当消费者消费后，<strong>每隔一段时间会把自己已消费消息的offset通过Zookeeper提交给Kafka</strong>，告知Kafka自己offset的位置。这样一来，如果消费者重启，则会从Kafka记录的offset之后的数据开始消费，从而避免重复消费。</li><li>在发生重复消费后，如何<strong>保证消息消费时的幂等性</strong>。如果消费者可以在消费消息时先判断一下，自己是否已经消费了该消息，如果是就不消费，那么就可以保证系统的幂等性。<ul><li>数据库查询</li><li>redis 用 set 去重</li><li>全局 id</li></ul></li></ul></blockquote><h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><h3 id="1-消费组"><a href="#1-消费组" class="headerlink" title="1 消费组"></a>1 消费组</h3><ul><li>多个消费者可以组成一个消费组，每个消费者只属于一个消费组。</li><li>消费组订阅主题的每个分区只会分配给该消费组中的某个消费者处理，不同的消费组之间彼此隔离无依赖。</li><li>同一个消息只会被消费组中的一个消费者消费，如果想要让同一个消息被多个消费者消费，那么每个消费者需要属于不同的消费组，且对应消费组中只有该一个消费者，消费组的引入可以实现消费的“独占”或“广播”效果。<h3 id="2-重平衡机制"><a href="#2-重平衡机制" class="headerlink" title="2 重平衡机制"></a>2 重平衡机制</h3></li><li><em>触发条件</em>：<ul><li>消费者数量变化： 新消费者加入、消费者下线、消费者主动退出消费组</li><li>消费组内订阅的主题或者主题的分区数量发生变化</li><li>消费组对应的 GroupCoorinator 节点发生变化</li></ul></li><li><em>rebalance过程</em>：<ul><li>寻找到消费组的 协调者(GroupCoordination)，消费者组提交组位移的 partiotion 所在的 broker</li><li>所有消费者向协调者发送 JoinGroup 请求</li><li>协调者为消费组选择新的leader</li><li>协调者发送 <code>JoinGroupResponse</code> 给各个消费组，其中leader消费者的 <code>JoinGroupResponse</code> 包含了消费组成员信息</li><li>leader消费者指定新的消费方案</li><li>各消费者向 协调者 发送 <code>SyncGroupRequest</code> 请求，其中 leader消费者的<code>SyncGroupRequest</code> 携带有相关的分配方案</li><li>协调者向各消费者下发分区分配方案</li></ul></li><li><em>避免非必要rebalance</em> ：设置合理的心跳发送时间；设置Consumer 消费时间最大间隔<h3 id="3-Kafka-消费者是否可以消费指定分区消息？"><a href="#3-Kafka-消费者是否可以消费指定分区消息？" class="headerlink" title="3 Kafka 消费者是否可以消费指定分区消息？"></a>3 Kafka 消费者是否可以消费指定分区消息？</h3>Kafa consumer消费消息时，向broker发出fetch请求去消费特定分区的消息，consumer指定消息在日志中的偏移量（offset），就可以消费从这个位置开始的消息，customer拥有了offset的控制权，可以向后回滚去重新消费之前的消息，这是很有意义的。<h3 id="4-讲一下-Kafka-Consumer-消费消息时的线程模型，为何如此设计？"><a href="#4-讲一下-Kafka-Consumer-消费消息时的线程模型，为何如此设计？" class="headerlink" title="4 讲一下 Kafka Consumer 消费消息时的线程模型，为何如此设计？"></a>4 讲一下 Kafka Consumer 消费消息时的线程模型，为何如此设计？</h3>Thread-Per-Consumer Model，这种多线程模型是利用Kafka的topic分多个partition的机制来实现并行：每个线程都有自己的consumer实例，负责消费若干个partition。各个线程之间是完全独立的，不涉及任何线程同步和同学通信，所以实现起来非常简单。<h2 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h2><h3 id="1-ISR集合-AR-OSR"><a href="#1-ISR集合-AR-OSR" class="headerlink" title="1 ISR集合,AR,OSR"></a>1 ISR集合,AR,OSR</h3></li><li><em>In-Sync Replicas 副本同步队列</em>，表示可用的副本集合，也就是和主副本差距不大</li><li>ISR 是由 leader 维护，follower从leader 同步数据有一些延迟（包括延迟时间和延迟条数）, 任意一个超过阈值都会把follower剔除出ISR, 存入OSR（Outof-Sync Replicas）列表，新加入的follower也会先存放在OSR中。AR=ISR+OSR</li><li>主要是解决<code>同步副本</code>与<code>异步复制</code>两种方案各自的缺陷<h3 id="2-HW-amp-LEO"><a href="#2-HW-amp-LEO" class="headerlink" title="2 HW&amp;LEO"></a>2 HW&amp;LEO</h3></li><li>HW（High Watermark）：消费端消费时只能拉取到小于HW的消息而HW及之后的消息对于消费者来说是不可见的，保证HW之前消息的可靠性</li><li>LEO（Log End Offset）：表示当前副本最新消息的下一个offset<h3 id="3-leader-epoch机制"><a href="#3-leader-epoch机制" class="headerlink" title="3 leader epoch机制"></a>3 leader epoch机制</h3>leader epoch表示一个键值对<epoch, offset>，其中epoch表示leader主副本的版本号，从0开始编码，当leader每变更一次就会+1，offset表示该epoch版本的主副本写入第一条消息的位置，比如<0,0>表示第一个主副本从位移0开始写入消息，<1,100>表示第二个主副本版本号为1并从位移100开始写入消息，主副本会将该信息保存在缓存中并定期写入到checkpoint文件中，每次发生主副本切换都会去从缓存中查询该信息<h2 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h2></li></ul><h3 id="1-除了kafka-还用过哪些消息队列-他和kafka-有哪些区别，优劣"><a href="#1-除了kafka-还用过哪些消息队列-他和kafka-有哪些区别，优劣" class="headerlink" title="1 除了kafka 还用过哪些消息队列 他和kafka 有哪些区别，优劣"></a>1 除了kafka 还用过哪些消息队列 他和kafka 有哪些区别，优劣</h3><h3 id="2-Kafka-高效文件存储设计特点"><a href="#2-Kafka-高效文件存储设计特点" class="headerlink" title="2 Kafka 高效文件存储设计特点"></a>2 Kafka 高效文件存储设计特点</h3><ul><li>Kafka把topic中一个parition大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。</li><li>通过索引信息可以快速定位message和确定 response的最大大小。</li><li>通过index元数据全部映射到memory，可以避免segment file的IO磁盘操作。</li><li>通过索引文件稀疏存储，可以大幅降低 index 文件元数据占用空间大小</li></ul><h3 id="3-Kafka-数据一致性原理"><a href="#3-Kafka-数据一致性原理" class="headerlink" title="3 Kafka 数据一致性原理"></a>3 Kafka 数据一致性原理</h3><ul><li>一致性就是说不论是老的 Leader 还是新选举的 Leader，Consumer 都能读到一样的数据。</li><li>假设分区的副本为3，其中副本0是 Leader，副本1和副本2是 follower，并且在 ISR 列表里面。虽然副本0已经写入了 Message4，但是 Consumer 只能读取到 Message2。因为所有的 ISR 都同步了 Message2，只有 High Water Mark 以上的消息才支持 Consumer 读取，而 High Water Mark 取决于 ISR 列表里面偏移量最小的分区，类似于<strong>木桶原理</strong>。</li><li>还没有被足够多副本复制的消息被认为是“不安全”的，如果 Leader 发生崩溃，另一个副本成为新 Leader，那么这些消息很可能丢失了。如果我们允许消费者读取这些消息，可能就会破坏一致性。试想，一个消费者从当前 Leader（副本0） 读取并处理了 Message4，这个时候 Leader 挂掉了，选举了副本1为新的 Leader，这时候另一个消费者再去从新的 Leader 读取消息，发现这个消息其实并不存在，这就导致了数据不一致性问题。</li></ul><h3 id="4-数据传输的事务有几种？"><a href="#4-数据传输的事务有几种？" class="headerlink" title="4 数据传输的事务有几种？"></a>4 数据传输的事务有几种？</h3><ul><li>数据传输的事务定义通常有以下三种级别：</li><li>最多一次: 消息不会被重复发送，最多被传输一次，但也有可能一次不传输 </li><li>最少一次: 消息不会被漏发送，最少被传输一次，但也有可能被重复传输.</li><li>精确的一次（Exactly once）: 不会漏传输也不会重复传输,每个消息都传输被</li></ul><h3 id="5-kafka为什么不需要支持读写分离"><a href="#5-kafka为什么不需要支持读写分离" class="headerlink" title="5 kafka为什么不需要支持读写分离"></a>5 kafka为什么不需要支持读写分离</h3><ul><li>读写均衡</li><li>分区，压力都不大</li></ul><h3 id="6-Kafka-中-zookeeper-的作用？它是如何保证-kafka-高可用的？主节点选举机制？"><a href="#6-Kafka-中-zookeeper-的作用？它是如何保证-kafka-高可用的？主节点选举机制？" class="headerlink" title="6 Kafka 中 zookeeper 的作用？它是如何保证 kafka 高可用的？主节点选举机制？"></a>6 Kafka 中 zookeeper 的作用？它是如何保证 kafka 高可用的？主节点选举机制？</h3><ol><li>用于在集群中不同节点之间进行通信</li><li>提交偏移量</li><li>leader 检测、分布式同步、配置管理、识别新节点何时离开或连接、集群、节点实时状态<h3 id="7-使用-kafka-的时候，如何确定一个-topic-的-partition-数量？"><a href="#7-使用-kafka-的时候，如何确定一个-topic-的-partition-数量？" class="headerlink" title="7 使用 kafka 的时候，如何确定一个 topic 的 partition 数量？"></a>7 使用 kafka 的时候，如何确定一个 topic 的 partition 数量？</h3></li><li>单台broker上partition数量不超过4000, 整个集群partition数量不超过2000,000</li><li>更多的Partition可能导致不可用时间增长；增加端到端的延迟；使用过多的内存<h3 id="8-kafka消息积压如何处理"><a href="#8-kafka消息积压如何处理" class="headerlink" title="8 kafka消息积压如何处理"></a>8 kafka消息积压如何处理</h3></li></ol><ul><li>问题定位：<ul><li>消息生产端数据量是否存在陡升的情况</li><li>消息消费端消费能力是否有下降</li><li>消息积压是发生在所有的partition还是所有的partition都有积压情况</li></ul></li><li>解决：<ul><li>前两个可以多线程，批量消费等提高消费速度</li><li>后者<ul><li>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量</li><li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，<strong>消费之后不做耗时的处理</strong>，直接均匀轮询写入临时建立好的 10 倍数量的 queue</li><li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据</li><li>等快速消费完积压数据之后，<strong>得恢复原先部署的架构</strong>，<strong>重新</strong>用原先的 consumer 机器来消费消息</li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/09/05/Framework/Redis/"/>
      <url>/2023/09/05/Framework/Redis/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1 基础知识"></a>1 基础知识</h2><h3 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h3><ul><li>Redis 为什么快：基于<code>内存</code>的数据库，单线程执行命令，没有并发问题，QPS 能轻松破 10w； I/O 多路复用机制；还有就是实现的数据结构能高效的处理数据操作；</li><li>使用场景：<strong>缓存，消息队列、分布式锁等场景</strong>。<h3 id="1-2-线程模型"><a href="#1-2-线程模型" class="headerlink" title="1.2 线程模型"></a>1.2 线程模型</h3><h4 id="1-2-1-Redis-是单线程吗？"><a href="#1-2-1-Redis-是单线程吗？" class="headerlink" title="1.2.1 Redis 是单线程吗？"></a>1.2.1 Redis 是单线程吗？</h4></li><li>接收客户端请求-&gt;解析请求 -&gt;进行数据读写等操作-&gt;发送数据给客户端 是单线程完成的</li><li>会启动后台线程（BIO）：<ul><li>2.6 版本：两个线程分别处理<code>关闭文件</code>、<code>AOF 刷盘</code></li><li>4.0 版本：新增lazyfree 线程，异步释放内存，避免 del 大 key 卡顿主线程,应该用 <code>unlink</code> 命令<code>异步删除</code>大 key<h4 id="1-2-2-单线程模式是怎样的？"><a href="#1-2-2-单线程模式是怎样的？" class="headerlink" title="1.2.2 单线程模式是怎样的？"></a>1.2.2 单线程模式是怎样的？</h4></li></ul></li><li>调用 epoll_create() 创建一个 epoll 对象和调用 socket() 创建一个服务端 socket</li><li>调用 bind() 绑定端口和调用 listen() 监听该 socket</li><li>将调用 epoll_ctl() 将 listen socket 加入到 epoll，同时注册「连接事件」处理函数</li><li>先调用<strong>处理发送队列函数</strong>，看是发送队列里是否有任务，如果有发送任务，则通过 write 函数将客户端发送缓存区里的数据发送出去，如果这一轮数据没有发送完，就会注册写事件处理函数，等待 epoll_wait 发现可写后再处理</li><li>调用 epoll_wait 函数等待事件的到来：<strong>连接事件</strong>，<strong>读事件</strong>，<strong>写事件</strong><h4 id="1-2-3-单线程模式为什么快？"><a href="#1-2-3-单线程模式为什么快？" class="headerlink" title="1.2.3 单线程模式为什么快？"></a>1.2.3 单线程模式为什么快？</h4></li><li>大部分操作都在<code>内存</code>中完成，并且采用了<code>高效的数据结构</code>，因此 Redis <code>瓶颈</code>可能是机器的内存或者网络带宽，而并非 CPU</li><li>采用单线程模型可以避免了多线程之间的竞争和切换带来的开销</li><li>采用了<code>I/O 多路复用机制</code>处理大量的客户端 Socket 请求，IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听 Socket 和已连接 Socket。内核会一直监听这些 Socket 上的<code>连接请求或数据请求</code>。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果<h4 id="1-2-4-为什么引入多线程？"><a href="#1-2-4-为什么引入多线程？" class="headerlink" title="1.2.4 为什么引入多线程？"></a>1.2.4 为什么引入多线程？</h4></li><li>采用了多个 I/O 线程来处理网络请求，这是因为随着网络硬件的性能提升，Redis 的性能瓶颈有时会出现在<code>网络 I/O</code> 的处理上。 ^6bcb8c</li><li><strong>命令的执行，Redis 仍然使用单线程来处理</strong><h2 id="2-2-数据类型和结构"><a href="#2-2-数据类型和结构" class="headerlink" title="2 2.数据类型和结构"></a>2 2.数据类型和结构</h2><h3 id="2-1-数据类型和使用场景"><a href="#2-1-数据类型和使用场景" class="headerlink" title="2.1 数据类型和使用场景"></a>2.1 数据类型和使用场景</h3><h4 id="2-1-1-String-字符串"><a href="#2-1-1-String-字符串" class="headerlink" title="2.1.1 String 字符串"></a>2.1.1 String 字符串</h4></li><li><em>介绍</em>：key-value 结构,最大 512M</li><li><em>内部实现</em>：int 和 <code>SDS 简单动态字符串</code> </li><li><em>使用场景</em>：缓存对象、常规计数、分布式锁、共享 session 信息等</li><li><em>分布式锁</em>：SETNX  「key不存在才插入」<h4 id="2-1-2-List-列表"><a href="#2-1-2-List-列表" class="headerlink" title="2.1.2 List 列表"></a>2.1.2 List 列表</h4></li><li><em>介绍</em>：简单的字符串列表,最大长度为 <code>2^32 - 1</code>   40亿</li><li><em>内部实现</em>：<ul><li><code>压缩列表</code>：列表元素小于 512 个，且都小于 64 字节</li><li><code>双向链表</code>：不满足以上</li><li><code>quicklist</code>：Redis3.2 版本后</li></ul></li><li><em>使用场景</em>：消息队列<h4 id="2-1-3-Hash"><a href="#2-1-3-Hash" class="headerlink" title="2.1.3 Hash"></a>2.1.3 Hash</h4></li><li><em>介绍</em>：键值对集合</li><li><em>内部实现</em>：<ul><li><code>压缩列表</code>：列表元素小于 512 个，且都小于 64 字节</li><li><code>哈希表</code>：不满足以上</li><li><code>listpack</code>：Redis7.0 版本后</li></ul></li><li><em>使用场景</em>：缓存对象，比如实现购物车<h4 id="2-1-4-Set"><a href="#2-1-4-Set" class="headerlink" title="2.1.4 Set"></a>2.1.4 Set</h4></li><li><em>介绍</em>：无序并唯一的键值集合  2^32-1</li><li><em>内部实现</em>：<ul><li><code>整数集合</code>：列表元素小于 512 个，且都是整数</li><li><code>哈希表</code>：不满足以上</li></ul></li><li><em>使用场景</em>：点赞，共同关注（交集），抽奖<h4 id="2-1-5-ZSet"><a href="#2-1-5-ZSet" class="headerlink" title="2.1.5 ZSet"></a>2.1.5 ZSet</h4></li><li><em>介绍</em>：有序并唯一的键值集合，多了排序属性 Score</li><li><em>内部实现</em>：<ul><li><code>压缩列表</code>：元素小于 128 个，且都小于 64 字节</li><li><code>跳表</code>：不满足以上</li><li><code>listpack</code>：Redis7.0 版本后，压缩列表废弃了</li></ul></li><li><em>使用场景</em>：排行榜,电话排序</li><li><em>复杂度</em>： zrange：O [ (LogN)+M]； ZSCORE：O(1) ；zrank：O(logn)<h4 id="2-1-6-BitMap"><a href="#2-1-6-BitMap" class="headerlink" title="2.1.6 BitMap"></a>2.1.6 BitMap</h4></li><li><em>介绍</em>：位图，连续的二进制数组</li><li><em>内部实现</em>：<ul><li><code>String 类型</code>：String 会保存为二进制的字节数组</li></ul></li><li><em>使用场景</em>：二值统计，签到打卡，用户登录<h3 id="2-2-数据结构"><a href="#2-2-数据结构" class="headerlink" title="2.2 数据结构"></a>2.2 数据结构</h3><h4 id="2-2-1-SDS-简单动态字符串"><a href="#2-2-1-SDS-简单动态字符串" class="headerlink" title="2.2.1 SDS 简单动态字符串"></a>2.2.1 SDS 简单动态字符串</h4></li><li><em>C 语言字符串的问题</em>：<ul><li>获取字符串长度的时间复杂度为 O（N）</li><li>字符串的结尾是以 “\0” 字符标识，字符串里面不能包含有 “\0” 字符，因此不能保存二进制数据；</li><li>字符串操作函数不高效且不安全，比如有缓冲区溢出的风险，有可能会造成程序运行终止；</li></ul></li><li><em>SDS 结构设计</em><ul><li><code>len</code>，记录了字符串长度；<code>alloc</code>，分配给字符数组的空间长度；<code>flags</code>，用来表示不同类型的 SDS; <code>buf[]</code>，字符数组，用来保存实际数据</li></ul></li><li><em>特点</em>：添加了三个元数据解决 C 语言字符串的缺陷，二进制安全，节约内存空间<h4 id="2-2-2-链表"><a href="#2-2-2-链表" class="headerlink" title="2.2.2 链表"></a>2.2.2 链表</h4></li><li><em>链表结构设计</em>：添加了前驱指针</li><li>3.0 版本前，数据量少的情况下会用压缩列表作为底层结构实现<h4 id="2-2-3-压缩列表"><a href="#2-2-3-压缩列表" class="headerlink" title="2.2.3 压缩列表"></a>2.2.3 压缩列表</h4></li><li><em>目的</em>：为了节约内存，由连续内存块组成的顺序型数据结构</li><li><em>节点结构设计</em>：<ul><li>prevlen，记录了「前一个节点」的长度</li><li>encoding，记录了当前节点实际数据的「类型和长度」</li><li>data，记录了当前节点的实际数据</li></ul></li><li><em>连锁更新</em>：有多个连续的、长度在 250～253 之间的节点，prelen 会用一个字节保存长度，如果有大于 254 字节的新节点加入，prelen 要扩展到 5 字节，引起连锁更新</li><li>quicklist（Redis 3.2 引入） 和 listpack（Redis 5.0 引入）解决连锁更新<h4 id="2-2-4-哈希表"><a href="#2-2-4-哈希表" class="headerlink" title="2.2.4 哈希表"></a>2.2.4 哈希表</h4></li><li><em>特点</em>：通过 hash 计算，以 O(1) 的复杂度快速查询数据，通过<code>「链式哈希」</code>来解决哈希冲突</li><li><em>结构设计</em>：哈希表是一个<code>数组</code>（dictEntry table），数组的每个元素是一个指向「哈希表节点（dictEntry）」的指针</li><li><em>rehash</em>： 渐进式 rehash   <code>触发条件</code>：负载因子大于 1（没有 bgsve） 和 5（强制）<ul><li>给「哈希表 2」 分配空间，一般会比「哈希表 1」 大 2 倍</li><li>在 rehash 进行期间，每次哈希表元素进行新增、删除、查找或者更新操作时，Redis 除了会执行对应的操作之外，还会顺序将「哈希表 1 」中索引位置上的所有 key-value <code>迁移</code>到「哈希表 2」 上</li><li>迁移完成后，「哈希表 1 」的空间会被释放，并把「哈希表 2」 设置为「哈希表 1」，然后在「哈希表 2」 新创建一个空白的哈希表，为下次 rehash 做准备<h4 id="2-2-5-整数集合"><a href="#2-2-5-整数集合" class="headerlink" title="2.2.5 整数集合"></a>2.2.5 整数集合</h4></li></ul></li><li><em>特点</em>：当 Set 对象只包含整数值元素，并且元素数量不大时，就会使用整数集这个数据结构作为底层实现</li><li><em>升级</em>：将一个新元素加入到整数集合里面，如果新元素的类型（int32_t）比整数集合现有所有元素的类型（int16_t）都要长时，整数集合需要先进行升级，也就是按<code>新元素的类型</code>（int32_t）扩展 contents 数组的空间大小，然后才能将新元素加入到整数集合里   <code>节省内存资源</code><h4 id="2-2-6-跳表"><a href="#2-2-6-跳表" class="headerlink" title="2.2.6 跳表"></a>2.2.6 跳表</h4><blockquote><p>Zset底层包括 跳表和哈希表 实现高效的范围查询和单点查询</p></blockquote></li><li><em>结构设计</em>：在链表基础上实现了一种多层有序链表<ul><li>多层级实现：zskiplistLevel 结构体类型的 level 数组</li><li>跨度：将沿途所有层的跨度累加就是节点在跳表中的排位</li></ul></li><li><em>节点查询过程</em><ul><li>当前节点的权重「小于」要查找的权重时，访问该层的下一个节点</li><li>当前节点的权重「等于」要查找的权重时，当前节点的 SDS 类型数据「小于」要查找的数据时，跳表就会访问该层上的下一个节点</li><li>都不满足，去下一层继续查找</li></ul></li><li><em>节点层数设置</em>：相邻两层理想比例为 2：1，复杂度为 O(logN)<ul><li>在创建节点时候，会生成范围为[0-1]的一个随机数，如果这个随机数小于 0.25（相当于概率 25%），那么层数就增加 1 层，然后继续生成下一个随机数，直到随机数的结果大于 0.25 结束，最终确定该节点的层数</li></ul></li><li><em>为什么不用平衡树</em><ul><li><code>内存占用</code>：平衡树每个节点两个指针，跳表只有 1.33</li><li><code>范围查询</code>：平衡树需要中序遍历，跳表直接遍历就行</li><li><code>实现难度</code>：平衡树插入删除要调整子树，跳表只要调整相邻节点</li></ul></li></ul><h4 id="2-2-7-quicklist"><a href="#2-2-7-quicklist" class="headerlink" title="2.2.7 quicklist"></a>2.2.7 quicklist</h4><ul><li><em>介绍</em>：3.2后 <code>List</code>对象的底层改由 quicklist 数据结构</li><li><em>结构设计</em>：<code>双向链表</code>，链表的元素是<code>压缩列表</code></li><li><em>优点</em>：控制每个链表节点中的<code>压缩列表的大小</code>或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少，连锁更新带来的影响就越小，从而提供了更好的访问性能<h4 id="2-2-8-listpack"><a href="#2-2-8-listpack" class="headerlink" title="2.2.8 listpack"></a>2.2.8 listpack</h4></li><li><em>介绍</em>：目的是替换压缩列表，每个节点不再包含前一个节点的长度</li><li><em>结构设计</em>：借鉴<code>压缩列表</code>设计</li><li><em>优点</em>：listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题</li></ul><h2 id="3-3-持久化"><a href="#3-3-持久化" class="headerlink" title="3 3.持久化"></a>3 3.持久化</h2><h3 id="3-1-AOF-日志"><a href="#3-1-AOF-日志" class="headerlink" title="3.1 AOF 日志 :"></a>3.1 AOF 日志 :</h3><ol><li>实现：先执行写操作命令，然后将命令追加到日志文件</li><li>优缺点：不会阻塞当前命令的执行；可能丢失数据</li><li>写回策略：<strong>Always</strong> 总是；<strong>Everysec</strong> 每秒；No 操作系统决定</li><li><strong>AOF 重写</strong>： <strong>后台子进程 <em>bgrewriteaof</em></strong>； 扫描数据库中所有数据，逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志； 状态一样,<code>文件体积更小</code><ol><li>重写过程中，主进程依然可以正常处理命令</li><li>在重写 AOF 期间,将这个写命令写入到 「AOF 缓冲区」和 「AOF 重写缓冲区」</li><li>将 AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致<h3 id="3-2-RDB-快照"><a href="#3-2-RDB-快照" class="headerlink" title="3.2 RDB 快照"></a>3.2 RDB 快照</h3>将某一时刻的内存数据，以二进制的方式写入磁盘; </li></ol></li><li>save ：主线程实现，可能阻塞</li><li>bgsave： 子进程</li><li>写时复制：如果主线程执行写操作，则被修改的数据会复制一份副本，然后 bgsave 子进程会把该副本数据写入 RDB 文件<h3 id="3-3-混合持久化"><a href="#3-3-混合持久化" class="headerlink" title="3.3 混合持久化"></a>3.3 混合持久化</h3>AOF重写时以 RDB 为开头;<strong>前半部分是 RDB 格式的全量数据，后半部分是 AOF 格式的增量数据</strong>。保证了 Redis 重启速度，又降低数据丢失风险。  <h3 id="3-4-大-key-对持久化的影响"><a href="#3-4-大-key-对持久化的影响" class="headerlink" title="3.4 大 key 对持久化的影响"></a>3.4 大 key 对持久化的影响</h3></li></ol><ul><li><em>大 Key 对 AOF 日志的影响</em>：使用 Always 策略的时候，如果写入是一个大 Key，主线程在执行 fsync() 函数的时候，阻塞的时间会比较久，因为当写入的数据量很大的时候，数据同步到硬盘这个过程是很耗时的</li><li><em>大 Key 对 AOF 重写和 RDB 的影响</em>：<ul><li>创建子进程的途中，由于要复制父进程的页表等数据结构，阻塞的时间跟页表的大小有关，页表越大，阻塞的时间也越长；</li><li>创建完子进程后，如果子进程或者父进程修改了共享数据，就会发生写时复制，这期间会拷贝物理内存，如果内存越大，自然阻塞的时间也越长；</li></ul></li><li><em>其他影响</em>：<ul><li><code>客户端超时阻塞</code>。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li><li><code>引发网络阻塞</code>。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li><li><code>阻塞工作线程</code>。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li><li><code>内存分布不均</code>。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。</li></ul></li><li>删除用 unlink 进行异步删除<h2 id="4-4-集群"><a href="#4-4-集群" class="headerlink" title="4 4.集群"></a>4 4.集群</h2><h3 id="4-1-主从复制"><a href="#4-1-主从复制" class="headerlink" title="4.1 主从复制"></a>4.1 主从复制</h3><blockquote><p>主从之间采用<code>读写分离</code></p></blockquote></li></ul><ol><li><strong>第一次同步数据</strong>： 使用 <code>replicaof</code> 命令<pre><code> 1. _建立链接、协商同步_：从服务器发送 `psync `要求同步，主服务器回应 `FULLRESYNC`，同步复制的`进度` 2. _主同步数据给从_：主服务器生成 RBD 文件发送给从服务器，期间执行的命令会写入` replication buffer` 缓冲区 3. _发送新写操作命令给从_：将缓冲区中的命令发送给从服务器</code></pre></li><li><strong>命令传播</strong>：维护 TCP 长连接</li><li>分摊主服务器的压力：从服务器同步给其他</li><li><em>增量复制</em>：同步<strong>网络断开</strong>期间的写操作; 环形缓冲区(<strong>repl_backlog_buffer</strong>) 和 <strong>replication offset</strong>标记同步进度<h3 id="4-2-哨兵机制"><a href="#4-2-哨兵机制" class="headerlink" title="4.2 哨兵机制"></a>4.2 哨兵机制</h3></li></ol><ul><li><em>作用</em>：主从节点故障转移；主要负责<code>监控,选主,通知</code></li><li><em>判断故障</em>：每隔 1 秒给所有主从节点发送 PING 命令，没有响应就主观下线；　因为可能网络延迟，不一定真的就挂了</li><li><em>客观下线</em>：判断主观下线后，哨兵集群进行投票，超过半数同意就判定客观下线；</li><li><em>主从故障转移</em>：<pre><code>  1. `Leader选举`：到半数以上的赞成票，作为 leader 实现主从切换  2. `选出新主节点`：**优先级、复制进度、ID 号**  3. `将从节点指向新主节点`；通知客户的主节点已更换；将旧主节点变为从节  4. `通知客户的主节点已更换`</code></pre></li><li>哨兵集群组成：通过 Redis 的发布者/订阅者机制来相互发现；10 秒一次的频率向主节点发送 INFO 命令来获取所有「从节点」的信息<h3 id="4-3-脑裂"><a href="#4-3-脑裂" class="headerlink" title="4.3 脑裂"></a>4.3 脑裂</h3></li><li>由于网络问题，集群节点之间失去联系。主从数据不同步；重新平衡选举，产生两个主服务。等网络恢复，旧主节点会降级为从节点，再与新主节点进行同步复制的时候，由于会从节点会清空自己的缓冲区，所以导致之前客户端写入的数据丢失了。</li><li><strong>主节点连接的从节点中至少有 N 个从节点，「并且」主节点进行数据复制时的 ACK 消息延迟不能超过 T 秒</strong>，否则，主节点就不会再接收客户端的写请求了。</li><li>等到新主节点上线时，就只有新主节点能接收和处理客户端请求，此时，新写的数据会被直接写到新主节点中。而原主节点会被哨兵降为从节点，即使它的数据被清空了，也不会有新数据丢失。<h2 id="5-过期删除和内存淘汰"><a href="#5-过期删除和内存淘汰" class="headerlink" title="5 过期删除和内存淘汰"></a>5 过期删除和内存淘汰</h2><blockquote><p>过期删除策略是删除已经过期的 key，当 Redis 的运行内存超过最大内存后，会用内存淘汰策略删除符合条件的 key</p><h3 id="5-1-过期删除策略"><a href="#5-1-过期删除策略" class="headerlink" title="5.1 过期删除策略"></a>5.1 过期删除策略</h3></blockquote></li><li>可以给 key 设置过期时间，会有个过期字典保存所有 key 的过期时间</li><li><em>定时删除</em>：在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作；<code>内存友好但是 CPU 不友好</code></li><li><em>惰性删除</em>：不主动删除过期键，每次从数据库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。<code>CPU友好但是内存不友好</code></li><li><em>定期删除</em>：每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key</li><li><em>Redis 的策略</em>：「惰性删除+定期删除」配和使用<h3 id="5-2-内存淘汰策略"><a href="#5-2-内存淘汰策略" class="headerlink" title="5.2 内存淘汰策略"></a>5.2 内存淘汰策略</h3></li><li>不进行数据淘汰的策略：直接返回错误</li><li>进行数据淘汰的策略<ul><li>在设置了过期时间的数据中进行淘汰<ul><li>随机； 最久未使用； 最少使用；更早过期</li></ul></li><li>在所有数据范围内进行淘汰<ul><li>随机； 最久未使用； 最少使用<h2 id="6-缓存设计"><a href="#6-缓存设计" class="headerlink" title="6 缓存设计"></a>6 缓存设计</h2><h3 id="6-1-缓存雪崩"><a href="#6-1-缓存雪崩" class="headerlink" title="6.1 缓存雪崩"></a>6.1 缓存雪崩</h3></li></ul></li></ul></li><li><em>现象</em>：大量缓存数据在同一时间过期（失效）或者 Redis 故障宕机，请求全部直接访问数据库，导致系统崩溃</li><li><em>解决过期</em>：<ul><li><code>均匀设置过期时间</code>：过期时间加上一个随机数    </li><li><code>互斥锁</code>：如果发现访问的数据不在 Redis 里，就加个互斥锁，保证同一时间内只有一个请求来构建缓存</li><li><code>双 key 策略</code>：</li><li><code>后台更新缓存</code>：让缓存“永久有效”，并将更新缓存的工作交由后台线程定时更新</li></ul></li><li><em>解决宕机</em>：服务熔断或请求限流机制；Redis 缓存高可靠集群<h3 id="6-2-缓存击穿"><a href="#6-2-缓存击穿" class="headerlink" title="6.2 缓存击穿"></a>6.2 缓存击穿</h3></li><li><em>现象</em>：某个热点数据过期，大量请求访问该数据，直接打到了数据库中</li><li><em>解决</em><ul><li><code>互斥锁</code>：同一时间只有一个业务线程更新缓存，未能获取互斥锁的请求，要么等待锁释放后重新读取缓存，要么就返回空值或者默认值</li><li>不给热点数据设置过期时间，由后台异步更新缓存，或者在热点数据准备要过期前，提前通知后台线程更新缓存以及重新设置过期时间<h3 id="6-3-缓存穿透"><a href="#6-3-缓存穿透" class="headerlink" title="6.3 缓存穿透"></a>6.3 缓存穿透</h3></li></ul></li><li><em>现象</em>： 请求的数据<strong>既不在缓存中，也不在数据库中</strong>请求全到数据库</li><li><em>解决</em>：<ul><li>限制<code>非法请求</code></li><li>出现缓存穿透，可以<code>缓存空值或者默认值</code></li><li>使用<code>布隆过滤器</code>快速判断数据是否存在</li></ul></li><li><em>布隆过滤器</em>  [[布隆过滤器]]<h3 id="6-4-数据库和缓存一致性"><a href="#6-4-数据库和缓存一致性" class="headerlink" title="6.4 数据库和缓存一致性"></a>6.4 数据库和缓存一致性</h3></li><li>先更新数据库还是缓存？<ul><li>先更新数据库，再更新缓存：在并发情况下同时更新一个数据可能导致数据不一致</li><li>先更新缓存，再更新数据库：也可能因为并发导致不一致</li></ul></li><li>先更新数据库还是先删除缓存？  <code>旁路缓存策略（Cache Aside）</code><ul><li><em>先删除缓存，再更新数据库</em>：可能会在缓存删除且数据库没更新时出现问题</li><li><strong><em>先更新数据库，再删除缓存</em></strong>：理论上会出现不一致（请求 B 在请求 A 没写入缓存前更新了数据并删除了缓存），但是因为缓存的写入快于数据库的写入，出现概率不高；为了确保，还可以加上<code>过期时间</code>或者选择延迟双删</li><li><code>延迟双删</code>：先删缓存，然后更新数据库，等一会再删除缓存</li></ul></li><li>怎么保证更新数据库和删除缓存成功？<ul><li><code>重试机制</code>：用<code>消息队列</code>进行重试</li><li><code>订阅 binlog</code>：Canal，订阅日志拿到要操作的数据再执行缓存删除</li><li>都是<code>异步</code>操作缓存<h2 id="7-其他"><a href="#7-其他" class="headerlink" title="7 其他"></a>7 其他</h2><h3 id="7-1-redis分布式锁"><a href="#7-1-redis分布式锁" class="headerlink" title="7.1 redis分布式锁"></a>7.1 redis分布式锁</h3></li></ul></li></ul><ol><li>SET 命令有个 NX 参数可以实现「key不存在才插入」</li><li>缺点：主从复制模式中的数据是异步复制的，这样导致分布式锁的不可靠性</li><li>分布式锁算法 Redlock（红锁）：客户端和多个独立的 Redis 节点依次请求申请加锁，在加锁超时时间内获得半数以上的节点的锁，就获得分布式锁，否则加锁失败。  </li><li>使用 redis 做分布式锁怎么做？如何保证set key 和设置过期时间的原子性？除了 lua 脚本有没有其他方法？</li><li>Redis 分布式锁 如果watch dog续期线程阻塞了 导致锁释放，锁不安全了怎么办，或者续期次数到达限制 任务还没执行完怎么办（数据库乐观锁保证只有一条数据成功）<h3 id="7-2-实现一个延迟队列"><a href="#7-2-实现一个延迟队列" class="headerlink" title="7.2 实现一个延迟队列"></a>7.2 实现一个延迟队列</h3></li><li>使用有序集合（ZSet）的方式来实现 score 记录延迟的时间</li><li>如果想重复消费？</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/08/27/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/05-sync.pool/"/>
      <url>/2023/08/27/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/05-sync.pool/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍了Go语言(golang)中的<code>sync.pool</code>包。给出了 sync.pool 的基本用法，以及各大框架中的使用案例。并从源码层面对其底层结构和具体实现原理进行分析。</p><blockquote><p>以下分析基于 Go 1.17.1</p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><h3 id="1-1-大致理念"><a href="#1-1-大致理念" class="headerlink" title="1.1 大致理念"></a>1.1 大致理念</h3><p><code>sync.Pool</code> 是 sync 包下的一个组件，可以作为保存临时取还对象的一个“池子”，可以缓存暂时不用的对象，下次需要时直接使用（无需重新分配）。</p><blockquote><p>因为频繁的内存分配和回收会对性能产生影响，通过复用临时对象就可以避免改问题。</p></blockquote><p>下面是 2018 年的时候，《Go 夜读》上关于 <code>sync.Pool</code> 的分享，关于适用场景：</p><blockquote><p>当多个 goroutine 都需要创建同⼀个对象的时候，如果 goroutine 数过多，导致对象的创建数⽬剧增，进⽽导致 GC 压⼒增大。形成 “并发⼤－占⽤内存⼤－GC 缓慢－处理并发能⼒降低－并发更⼤”这样的恶性循环。 在这个时候，需要有⼀个对象池，每个 goroutine 不再⾃⼰单独创建对象，⽽是从对象池中获取出⼀个对象（如果池中已经有的话）。</p></blockquote><p>因此关键思想就是对象的复用，避免重复创建、销毁，下面我们来看看如何使用。</p><p>所以，sync.pool 的作用一句话描述就是，<strong>复用临时对象，以避免频繁的内存分配和回收，从而减少 GC 压力</strong>。</p><h3 id="1-2-基本使用"><a href="#1-2-基本使用" class="headerlink" title="1.2 基本使用"></a>1.2 基本使用</h3><p>首先，<code>sync.Pool</code> 是协程安全的，这对于使用者来说是极其方便的。使用前，设置好对象的 <code>New</code> 函数，用于在 <code>Pool</code> 里没有缓存的对象时，创建一个。之后，在程序的任何地方、任何时候仅通过 <code>Get()</code>、<code>Put()</code> 方法就可以取、还对象了。</p><p>以下为基本使用 demo：</p><blockquote><p>完整代码见 <a href="#">Github</a><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> main  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">   <span class="string">&quot;sync&quot;</span>  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;  </span><br><span class="line">   Name   <span class="type">string</span>  </span><br><span class="line">   Remark [<span class="number">1024</span>]<span class="type">byte</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Gopher)</span></span> Reset() &#123;  </span><br><span class="line">   s.Name = <span class="string">&quot;&quot;</span>  </span><br><span class="line">   s.Remark = [<span class="number">1024</span>]<span class="type">byte</span>&#123;&#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">var</span> gopherPool = sync.Pool&#123;  </span><br><span class="line">   New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">new</span>(Gopher)  </span><br><span class="line">   &#125;,  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   g := gopherPool.Get().(*Gopher)  </span><br><span class="line">   fmt.Println(<span class="string">&quot;首次从 pool 里获取：&quot;</span>, g.Name)  </span><br><span class="line"> ​  </span><br><span class="line">   g.Name = <span class="string">&quot;first&quot;</span>  </span><br><span class="line">   fmt.Printf(<span class="string">&quot;设置 p.Name = %s\n&quot;</span>, g.Name)  </span><br><span class="line">   gopherPool.Put(g)  </span><br><span class="line"> ​  </span><br><span class="line">   fmt.Println(<span class="string">&quot;Pool 里已有一个对象：&amp;&#123;first&#125;，调用 Get: &quot;</span>, gopherPool.Get().(*Gopher).Name)  </span><br><span class="line">   fmt.Println(<span class="string">&quot;Pool 没有对象了，调用 Get: &quot;</span>, gopherPool.Get().(*Gopher).Name)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>运行结果：<br> 首次从 pool 里获取：<br> 设置 p.Name = first<br> Pool 里已有一个对象：&amp;{first}，调用 Get:  first<br> Pool 没有对象了，调用 Get:<br>首先，需要初始化 <code>Pool</code>，唯一需要的就是设置好 <code>New</code> 函数。当调用 Get 方法时，如果池子里缓存了对象，就直接返回缓存的对象。如果没有存货，则调用 New 函数创建一个新的对象。</p></blockquote><p>另外，我们发现 Get 方法取出来的对象和上次 Put 进去的对象实际上是同一个，Pool 没有做任何“清空”的处理。但我们不应当对此有任何假设，因为在实际的并发使用场景中，无法保证这种顺序，<strong>最好的做法是在 Put 前，将对象清空</strong>。</p><p><strong>Benchmark</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> defaultGopher, _ = json.Marshal(Gopher&#123;Name: <span class="string">&quot;17x&quot;</span>&#125;)  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">BenchmarkUnmarshal</span><span class="params">(b *testing.B)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">var</span> g *Gopher  </span><br><span class="line">   <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;  </span><br><span class="line">     g = <span class="built_in">new</span>(Gopher)  </span><br><span class="line">     json.Unmarshal(defaultGopher, g)  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">BenchmarkUnmarshalWithPool</span><span class="params">(b *testing.B)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">var</span> g *Gopher  </span><br><span class="line">   <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;  </span><br><span class="line">     g = gopherPool.Get().(*Gopher)  </span><br><span class="line">     json.Unmarshal(defaultGopher, g)  </span><br><span class="line">     g.Reset() <span class="comment">// 重置后在放进去  </span></span><br><span class="line">     gopherPool.Put(g)  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure><br> ​<br>运行结果：</p><p> BenchmarkUnmarshal-6                9518            124806 ns/op            1280 B/op          6 allocs/op<br> BenchmarkUnmarshalWithPool-6       10000            124350 ns/op             128 B/op          5 allocs/op<br> <code>3287449 357 ns/op</code> 表示单位时间内（默认是1s）被测函数运行了 3287449 次，每次运行耗时 357ns，<br> <code>B/op</code> 是每个操作分配的字节数<br> <code>allocs/op</code> 表示每个操作(单次迭代)发生了多少不同的内存分配。</p><p>功能比较简单，其中 json 反序列化占用了大量时间，因此两种方式最终的执行时间几乎没什么变化。但是内存占用差了一个数量级，使用了 <code>sync.Pool</code> 后，内存占用仅为未使用的 128/1280=1/10，对 GC 的影响就很大了。</p><h3 id="1-3-使用案例"><a href="#1-3-使用案例" class="headerlink" title="1.3 使用案例"></a>1.3 使用案例</h3><h4 id="1-3-1-fmt-包"><a href="#1-3-1-fmt-包" class="headerlink" title="1.3.1 fmt 包"></a>1.3.1 fmt 包</h4><p>这部分主要看 <code>fmt.Printf</code> 如何使用：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;  </span><br><span class="line">   <span class="keyword">return</span> Fprintf(os.Stdout, format, a...)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>继续看 <code>Fprintf</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;  </span><br><span class="line">   p := newPrinter()  </span><br><span class="line">   p.doPrintf(format, a)  </span><br><span class="line">   n, err = w.Write(p.buf)  </span><br><span class="line">   p.free()  </span><br><span class="line">   <span class="keyword">return</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br><code>Fprintf</code> 函数的参数是一个 <code>io.Writer</code>，<code>Printf</code> 传的是 <code>os.Stdout</code>，相当于直接输出到标准输出。这里的 <code>newPrinter</code> 用的就是 Pool：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> ppFree = sync.Pool&#123;  </span><br><span class="line">   New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123; <span class="keyword">return</span> <span class="built_in">new</span>(pp) &#125;,  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">newPrinter</span><span class="params">()</span></span> *pp &#123;  </span><br><span class="line">   p := ppFree.Get().(*pp)  </span><br><span class="line">   p.panicking = <span class="literal">false</span>  </span><br><span class="line">   p.erroring = <span class="literal">false</span>  </span><br><span class="line">   p.wrapErrs = <span class="literal">false</span>  </span><br><span class="line">   p.fmt.init(&amp;p.buf)  </span><br><span class="line">   <span class="keyword">return</span> p  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>回到 <code>Fprintf</code> 函数，拿到 pp 指针后，会做一些 format 的操作，并且将 p.buf 里面的内容写入 w。最后，调用 free 函数，将 pp 指针归还到 Pool 中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(p *pp)</span></span> free() &#123;  </span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">cap</span>(p.buf) &gt; <span class="number">64</span>&lt;&lt;<span class="number">10</span> &#123;  </span><br><span class="line">     <span class="keyword">return</span>  </span><br><span class="line">   &#125;  </span><br><span class="line"> ​  </span><br><span class="line">   p.buf = p.buf[:<span class="number">0</span>]  </span><br><span class="line">   p.arg = <span class="literal">nil</span>  </span><br><span class="line">   p.value = reflect.Value&#123;&#125;  </span><br><span class="line">   p.wrappedErr = <span class="literal">nil</span>  </span><br><span class="line">   ppFree.Put(p)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>归还到 Pool 前还进行了<strong>字段清零</strong>，这样，通过 Get 拿到缓存的对象时，就可以安全地使用了。</p><h4 id="1-3-2-gin-框架"><a href="#1-3-2-gin-框架" class="headerlink" title="1.3.2 gin 框架"></a>1.3.2 gin 框架</h4><p>gin 框架会给每个请求分配一个 Context 用以进行追踪，这就是典型的 sync.pool 使用场景：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Engine &#123;  </span><br><span class="line">engine := &amp;Engine&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">engine.pool.New = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line"><span class="keyword">return</span> engine.allocateContext()  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> engine  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> allocateContext() *Context &#123;  </span><br><span class="line"><span class="keyword">return</span> &amp;Context&#123;engine: engine&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;  </span><br><span class="line">c := engine.pool.Get().(*Context)  </span><br><span class="line">c.writermem.reset(w)  </span><br><span class="line">c.Request = req  </span><br><span class="line">c.reset()  </span><br><span class="line">  </span><br><span class="line">engine.handleHTTPRequest(c)  </span><br><span class="line">  </span><br><span class="line">engine.pool.Put(c)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从 pool 中获取 Context 对象，用完后又还回去，注意 还回去之前这里也调用了 reset() 方法进行<strong>字段清空</strong>。</p><h3 id="1-4-正确姿势"><a href="#1-4-正确姿势" class="headerlink" title="1.4 正确姿势"></a>1.4 正确姿势</h3><p>根据以上几个案例，可以看出正确使用姿势就是：</p><ul><li><p>1）设置 New 方法</p></li><li><p>2）使用时直接 Get</p></li><li><p>3）使用完成后先进行<strong>字段清空</strong>,然后在 Put 回去。</p></li></ul><blockquote><p>一定要进行 Reset，不然会出现意想不到的问题。分享一个<a href="https://github.com/lixd/daily-notes/blob/master/Golang/FAQ/mongodb%E9%87%87%E5%9D%91.md">类似的坑</a></p></blockquote><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><blockquote><p>一下分析基于 Go 1.17.1</p></blockquote><h3 id="2-1-Pool-结构体"><a href="#2-1-Pool-结构体" class="headerlink" title="2.1 Pool 结构体"></a>2.1 Pool 结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;  </span><br><span class="line">noCopy noCopy  </span><br><span class="line">local     unsafe.Pointer <span class="comment">// local fixed-size per-P pool, actual type is [P]poolLocal  </span></span><br><span class="line">localSize <span class="type">uintptr</span>        <span class="comment">// size of the local array  </span></span><br><span class="line">victim     unsafe.Pointer <span class="comment">// local from previous cycle  </span></span><br><span class="line">victimSize <span class="type">uintptr</span>        <span class="comment">// size of victims array  </span></span><br><span class="line">New <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段详解：</p><ul><li><code>noCopy</code>对象，实现了<code>sync.Locker</code>接口，使得内嵌了 noCopy 的对象在进行 go vet 静态检查的时候，可以检查出是否被复制。<ul><li>具体见 <a href="https://github.com/golang/go/issues/8005">Go issues 8005</a></li><li>说明 Pool 对象也是不允许复制的。</li></ul></li><li><code>local</code> 字段存储指向 <code>[P]poolLocal</code> 数组（严格来说，它是一个切片）的指针。<code>localSize</code> 则表示 local 数组的大小。<ul><li>访问时，根据 P 的 id 去访问对应下标的 <code>local[pid]</code></li><li>通过这样的设计，多个 goroutine 使用同一个 Pool 时，减少了竞争，提升了性能。</li><li>有点类似于降低锁粒度，分段锁的思想。</li></ul></li><li><code>victim</code> 和 <code>victimSize</code> 则会在在一轮 GC 到来时，分别“接管” local 和 localSize。<ul><li>victim cache 是一种提高缓存性能的硬件技术;</li><li><code>victim</code> 的机制用于减少 GC 后冷启动导致的性能抖动，让分配对象更平滑;</li></ul></li><li><code>New</code>就是我们指定的新建对象的方法。</li></ul><blockquote><p><a href="https://en.wikipedia.org/wiki/Victim_cache">Victim Cache</a> 是一种提高缓存性能的硬件技术，主要用于提升缓存命令率。<br>所谓受害者缓存（Victim Cache），是一个与直接匹配或低相联缓存并用的、容量很小的全相联缓存。当一个数据块被逐出缓存时，并不直接丢弃，而是暂先进入受害者缓存。如果受害者缓存已满，就替换掉其中一项。当进行缓存标签匹配时，在与索引指向标签匹配的同时，并行查看受害者缓存，如果在受害者缓存发现匹配，就将其此数据块与缓存中的不匹配数据块做交换，同时返回给处理器。</p></blockquote><h4 id="2-1-1-local"><a href="#2-1-1-local" class="headerlink" title="2.1.1 local"></a>2.1.1 local</h4><p>local 具体结构如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> &#123;  </span><br><span class="line">poolLocalInternal  </span><br><span class="line">    <span class="comment">// 将 poolLocal 补齐至128字节(即两个cache line)的倍数，防止 false sharing,  </span></span><br><span class="line">    <span class="comment">// 伪共享，仅占位用，防止在 cache line 上分配多个 poolLocalInternal  </span></span><br><span class="line">pad [<span class="number">128</span> - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%<span class="number">128</span>]<span class="type">byte</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">type</span> poolLocalInternal <span class="keyword">struct</span> &#123;  </span><br><span class="line">private <span class="keyword">interface</span>&#123;&#125; <span class="comment">// Can be used only by the respective P.  </span></span><br><span class="line">shared  poolChain   <span class="comment">// Local P can pushHead/popHead; any P can popTail.  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>poolLocalInternal</code>对象 中包含一个 <code>private</code> 和 <code>shared</code>。其中 private 只有当前 p 能用，shared 则是其他 p 都可以用。</p><h4 id="2-1-2-cpu-cache-amp-false-sharing"><a href="#2-1-2-cpu-cache-amp-false-sharing" class="headerlink" title="2.1.2 cpu cache &amp; false sharing"></a>2.1.2 cpu cache &amp; false sharing</h4><p><strong>cpu cache</strong><br>现代 cpu 中，cache 都划分成以 cache line (cache block) 为单位，在 x86_64 体系下一般都是 64 字节，cache line 是操作的最小单元。 程序即使只想读内存中的 1 个字节数据，也要同时把附近 63 节字加载到 cache 中，如果读取超个 64 字节，那么就要加载到多个 cache line 中。<br>这样，访问后续 63 字节数据时就可以直接从 cache line 中读取，性能有很大提升。</p><p><strong><a href="https://en.wikipedia.org/wiki/False_sharing">false sharing</a></strong></p><blockquote><p>伪共享的非标准定义为：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会令整个 cache line 失效，无意中影响彼此的性能，这就是伪共享。</p></blockquote><p>简单来说，如果没有 pad 字段，那么当需要访问 0 号索引的 poolLocal 时，CPU 同时会把 0 号和 1 号索引同时加载到 cpu cache。在只修改 0 号索引的情况下，会让 1 号索引的 poolLocal 失效。这样，当其他线程想要读取 1 号索引时，发生 cache miss，还得重新再加载，对性能有损。增加一个 <code>pad</code>，补齐缓存行，让相关的字段能独立地加载到缓存行就不会出现 <code>false sharding</code> 了。</p><h4 id="2-1-3-poolChain"><a href="#2-1-3-poolChain" class="headerlink" title="2.1.3 poolChain"></a>2.1.3 poolChain</h4><p><code>poolChain</code> 是一个双端队列的实现<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolChain <span class="keyword">struct</span> &#123;  </span><br><span class="line">  </span><br><span class="line">   head *poolChainElt  </span><br><span class="line">  </span><br><span class="line">   tail *poolChainElt  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> poolChainElt <span class="keyword">struct</span> &#123;  </span><br><span class="line">poolDequeue  </span><br><span class="line">  </span><br><span class="line">next, prev *poolChainElt  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> poolDequeue <span class="keyword">struct</span> &#123;  </span><br><span class="line">  </span><br><span class="line">headTail <span class="type">uint64</span>  </span><br><span class="line">  </span><br><span class="line">vals []eface  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>poolDequeue</code> 被实现为单生产者、多消费者的固定大小的无锁（atomic 实现） Ring 式队列（底层存储使用数组，使用两个指针标记 head、tail）。生产者可以从 head 插入、head 删除，而消费者仅可从 tail 删除。 <code>headTail</code> 指向队列的头和尾，通过位运算将 head 和 tail 存入 headTail 变量中。</p><p>我们用一幅图来完整地描述 Pool 结构体：</p><p>![[pool-structure.png]]</p><blockquote><p>图源：<a href="https://zhuanlan.zhihu.com/p/133638023">码农桃花源</a></p><h3 id="2-2-大致流程"><a href="#2-2-大致流程" class="headerlink" title="2.2 大致流程"></a>2.2 大致流程</h3></blockquote><p>分析完 Pool 结构体之后，先提前说明一下大致的流程，后续分析时便于理解。</p><p><strong>存储</strong></p><p>为每个 P 开辟了一个 Local 用于数据，降低竞争。</p><p>Local 中包含 private 和 shared。</p><ul><li><p>private ：只有当前 P 能使用</p></li><li><p>shared：所有 P 共享，当 private 没有时优先去当前 P 的 local.shared 中取，如果还没有就去其他 P 中 local.shared 中窃取一个来用。</p></li></ul><p><strong>Get</strong></p><p>优先从当前P 的 local.private 中取，没有则从当前 P 的 local.shared 中取，还没有则去其他 P 中 local.shared 中窃取一个。</p><p><strong>Put</strong></p><p>优先存放到当前 P 的 local.private，local.private 已经有值了就往 shared 中放。</p><h3 id="2-3-Get"><a href="#2-3-Get" class="headerlink" title="2.3 Get"></a>2.3 Get</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Get() <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">l, pid := p.pin()  </span><br><span class="line">x := l.private  </span><br><span class="line">l.private = <span class="literal">nil</span>  </span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;  </span><br><span class="line">x, _ = l.shared.popHead()  </span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;  </span><br><span class="line">x = p.getSlow(pid)  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">runtime_procUnpin()  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;  </span><br><span class="line">x = p.New()  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> x  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程如下：</p><ol><li><p>首先，调用 <code>p.pin()</code> 函数将当前的 goroutine 和 P 绑定，禁止被抢占，返回当前 P 对应的 poolLocal，以及 pid。</p></li><li><p>然后直接取 l.private，赋值给 x，并置 l.private 为 nil。</p></li><li><p>判断 x 是否为空，若为空，则尝试从 l.shared 的头部 pop 一个对象出来，同时赋值给 x。</p></li><li><p>如果 x 仍然为空，则调用 getSlow 尝试从其他 P 的 shared 双端队列尾部“偷”一个对象出来。</p></li><li><p>Pool 的相关操作做完了，调用 <code>runtime_procUnpin()</code> 解除禁止抢占。</p></li><li><p>最后如果还是没有取到缓存的对象，那就直接调用预先设置好的 New 函数，创建一个出来。</p></li></ol><h4 id="2-3-1-pin"><a href="#2-3-1-pin" class="headerlink" title="2.3.1 pin"></a>2.3.1 pin</h4><p>首先，调用 <code>p.pin()</code> 函数将当前的 goroutine 和 P 绑定，禁止被抢占，返回当前 P 对应的 poolLocal，以及 pid。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pin() (*poolLocal, <span class="type">int</span>) &#123;  </span><br><span class="line">   <span class="comment">// pin 具体逻辑由 runtime_procPin 实现  </span></span><br><span class="line">   pid :=  runtime_procPin()  </span><br><span class="line">   <span class="comment">// 原子操作取出 p.localSize 和 p.local  </span></span><br><span class="line">   s := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire  </span></span><br><span class="line">   l := p.local                              <span class="comment">// load-consume  </span></span><br><span class="line">   <span class="comment">// 因为是把 pid 做下标从 pool.local 中取得 p 对应的 local 的，  </span></span><br><span class="line">   <span class="comment">// 所以如果 pid 小于 pool.local size 的时候才有可能取到对应的 local  </span></span><br><span class="line">   <span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;  </span><br><span class="line">      <span class="keyword">return</span> indexLocal(l, pid), pid  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// 正常情况下会一直满足该条件，  </span></span><br><span class="line">   <span class="comment">// 只有刚开始  pool.local 还没创建或者动态调整了 P 的数量这两种情况  </span></span><br><span class="line">   <span class="comment">// 会进入到下面的逻辑 去创建 pool.local  </span></span><br><span class="line">   <span class="keyword">return</span> p.pinSlow()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-3-2-pinSlow"><a href="#2-3-2-pinSlow" class="headerlink" title="2.3.2 pinSlow"></a>2.3.2 pinSlow</h4><p>pinSlow 主要是完成 pool.local 的创建。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pinSlow() (*poolLocal, <span class="type">int</span>) &#123;  </span><br><span class="line">    <span class="comment">// 这里先取消绑定，然后加锁，最后有绑定上  </span></span><br><span class="line">runtime_procUnpin()  </span><br><span class="line">allPoolsMu.Lock()  </span><br><span class="line"><span class="keyword">defer</span> allPoolsMu.Unlock()  </span><br><span class="line">pid := runtime_procPin()  </span><br><span class="line"><span class="comment">// doubleCheck 因为在执行上述命令过程中 pinSlow 可能已经被其他的线程调用，因此这时候需要再次对 pid 进行检查  </span></span><br><span class="line">s := p.localSize  </span><br><span class="line">l := p.local  </span><br><span class="line"><span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;  </span><br><span class="line"><span class="keyword">return</span> indexLocal(l, pid), pid  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> p.local == <span class="literal">nil</span> &#123;  </span><br><span class="line">allPools = <span class="built_in">append</span>(allPools, p)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 根据当前 P 的数量创建 pool.local并更新pool.localSize  </span></span><br><span class="line">size := runtime.GOMAXPROCS(<span class="number">0</span>)  </span><br><span class="line">local := <span class="built_in">make</span>([]poolLocal, size)  </span><br><span class="line">atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="number">0</span>])) <span class="comment">// store-release  </span></span><br><span class="line">runtime_StoreReluintptr(&amp;p.localSize, <span class="type">uintptr</span>(size))     <span class="comment">// store-release  </span></span><br><span class="line">    <span class="comment">// 最后根据 pid 返回当前 P 对应的 local  </span></span><br><span class="line"><span class="keyword">return</span> &amp;local[pid], pid  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### popHead</span><br><span class="line"></span><br><span class="line">然后回到 Get 方法</span><br><span class="line">```go</span><br><span class="line">x := l.private  </span><br><span class="line">l.private = nil  </span><br><span class="line">if x == nil &#123;  </span><br><span class="line">x, _ = l.shared.popHead()  </span><br><span class="line">if x == nil &#123;  </span><br><span class="line">x = p.getSlow(pid)  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">优先从 local.private 中取，如果没有就调用`poolChain.popHead()`去 local.shared 中取一个。</span><br><span class="line">```go</span><br><span class="line">func (c *poolChain) popHead() (interface&#123;&#125;, bool) &#123;  </span><br><span class="line">d := c.head  </span><br><span class="line">for d != nil &#123;  </span><br><span class="line">if val, ok := d.popHead(); ok &#123;  </span><br><span class="line">return val, ok  </span><br><span class="line">&#125;  </span><br><span class="line">d = loadPoolChainElt(&amp;d.prev)  </span><br><span class="line">&#125;  </span><br><span class="line">return nil, false  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`popHead` 函数只会被 producer 调用。首先拿到头节点：c.head，如果头节点不为空的话，尝试调用头节点的 `poolDequeue.popHead` 方法。</span><br><span class="line">```go</span><br><span class="line">func (d *poolDequeue) popHead() (interface&#123;&#125;, bool) &#123;  </span><br><span class="line">var slot *eface  </span><br><span class="line">for &#123;  </span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">head, tail := d.unpack(ptrs)  </span><br><span class="line">        // 收尾相连则说明队列是空的  </span><br><span class="line">if tail == head &#123;  </span><br><span class="line">return nil, false  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// head 位置是队头的前一个位置，所以此处要先退一位。  </span><br><span class="line">        // 在读出 slot 的 value 之前就把 head 值减 1，取消对这个 slot 的控制  </span><br><span class="line">head--  </span><br><span class="line">ptrs2 := d.pack(head, tail)  </span><br><span class="line">        // 通过 CAS 操作更新头部的位置 这样当前头部第一个元素就算是被移除了  </span><br><span class="line">if atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;  </span><br><span class="line">slot = &amp;d.vals[head&amp;uint32(len(d.vals)-1)]  </span><br><span class="line">break  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">    // 类型转换与 nil 判断  </span><br><span class="line">val := *(*interface&#123;&#125;)(unsafe.Pointer(slot))  </span><br><span class="line">if val == dequeueNil(nil) &#123;  </span><br><span class="line">val = nil  </span><br><span class="line">&#125;  </span><br><span class="line">    // 然后把这个 slot 置空，因为现在这个 slot 已经是队列的 head 了，置空便于前一个 head 被回收。  </span><br><span class="line">*slot = eface&#123;&#125;  </span><br><span class="line">return val, true  </span><br><span class="line">&#125;```</span><br></pre></td></tr></table></figure><p>此函数会删掉并且返回 <code>queue</code> 的头节点。但如果 <code>queue</code> 为空的话，返回 false。这里的 <code>queue</code> 存储的实际上就是 Pool 里缓存的对象。</p><p>整个函数的核心是一个无限循环，这是 Go 中常用的无锁化编程形式。</p><p>首先调用 unpack 函数分离出 head 和 tail 指针，如果 head 和 tail 相等，即首尾相等，那么这个队列就是空的，直接就返回 nil，false。</p><p>否则，将 head 指针后移一位，即 head 值减 1，然后调用 pack 打包 head 和 tail 指针。使用 CAS 更新 headTail 的值，并且把 vals 相应索引处的元素赋值给 slot。</p><blockquote><p>因为 <code>vals</code> 长度实际是只能是 2 的 n 次幂，因此 <code>len(d.vals)-1</code> 实际上得到的值的低 n 位是全 1，它再与 head 进行与运算，实际就是取 head 低 n 位的值作为下标。</p></blockquote><p>得到相应 slot 的元素后，经过类型转换并判断是否是 <code>dequeueNil</code>，如果是，说明没取到缓存的对象，返回 nil。</p><p>type dequeueNil *struct{}</p><p>最后，返回 val 之前，将 slot “归零”，移除和上一个 head 的关联，便于回收上一个 Head。</p><p>*slot = eface{}</p><p>结束后回到 <code>poolChain.popHead()</code>，如果调用 <code>poolDequeue.popHead()</code> 拿到了缓存的对象，就直接返回。否则，将 <code>d</code> 重新指向 <code>d.prev</code>，继续尝试获取缓存的对象。</p><h4 id="2-3-3-getSlow"><a href="#2-3-3-getSlow" class="headerlink" title="2.3.3 getSlow"></a>2.3.3 getSlow</h4><p>如果在 shared 里没有获取到缓存对象，则继续调用 <code>Pool.getSlow()</code>，尝试从其他 P 的 poolLocal 偷取：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> getSlow(pid <span class="type">int</span>) <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line">size := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire  </span></span><br><span class="line">locals := p.local                            <span class="comment">// load-consume  </span></span><br><span class="line">    <span class="comment">// 尝试从其他 p 中窃取一个对象  </span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;  </span><br><span class="line">        <span class="comment">// (pid+i+1)%int(size) 保证每次都可以从 当前pid+1 这个位置开始尝试窃取。  </span></span><br><span class="line">l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="type">int</span>(size))  </span><br><span class="line">        <span class="comment">// 如果能取到就直接返回  </span></span><br><span class="line"><span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> x  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 尝试从其他 P 的 poolLocal 窃取失败后，再尝试从victim cache中取对象  </span></span><br><span class="line">    <span class="comment">// 这样可以使 victim 中的对象更容易被回收。  </span></span><br><span class="line">size = atomic.LoadUintptr(&amp;p.victimSize)  </span><br><span class="line"><span class="keyword">if</span> <span class="type">uintptr</span>(pid) &gt;= size &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">locals = p.victim  </span><br><span class="line">l := indexLocal(locals, pid)  </span><br><span class="line"><span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123;  </span><br><span class="line">l.private = <span class="literal">nil</span>  </span><br><span class="line"><span class="keyword">return</span> x  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;  </span><br><span class="line">l := indexLocal(locals, (pid+i)%<span class="type">int</span>(size))  </span><br><span class="line"><span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> x  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 清空 victim cache。下次就不用再从这里找了  </span></span><br><span class="line">atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;<span class="string">``</span><span class="string">`</span></span><br></pre></td></tr></table></figure></p><p>从索引为 pid+1 的 poolLocal 处开始，尝试调用 <code>shared.popTail()</code> 获取缓存对象。如果没有拿到，则从 victim 里找，和 poolLocal 的逻辑类似。</p><p>最后，实在没找到，就把 victimSize 置 0，防止后来的“人”再到 victim 里找。</p><p>在 Get 函数的最后，经过这一番操作还是没找到缓存的对象，就调用 New 函数创建一个新的对象。</p><h4 id="2-3-4-popTail"><a href="#2-3-4-popTail" class="headerlink" title="2.3.4 popTail"></a>2.3.4 popTail</h4><p>最后，还剩一个 popTail 函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> popTail() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;  </span><br><span class="line">    <span class="comment">// tail 指针为空直接返回 这里的 tail 是一个双端队列  </span></span><br><span class="line">d := loadPoolChainElt(&amp;c.tail)  </span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> &#123;  </span><br><span class="line"><span class="comment">// It&#x27;s important that we load the next pointer  </span></span><br><span class="line"><span class="comment">// *before* popping the tail. In general, d may be  </span></span><br><span class="line"><span class="comment">// transiently empty, but if next is non-nil before  </span></span><br><span class="line"><span class="comment">// the pop and the pop fails, then d is permanently  </span></span><br><span class="line"><span class="comment">// empty, which is the only condition under which it&#x27;s  </span></span><br><span class="line"><span class="comment">// safe to drop d from the chain.  </span></span><br><span class="line">        <span class="comment">// 在 for 循环的一开始，就把 d.next 加载到了 d2。因为 d 可能会短暂为空，但如果 d2 在 pop 或者 pop fails 之前就不为空的话，说明 d 就会永久为空了。在这种情况下，可以安全地将 d 这个结点“甩掉”。  </span></span><br><span class="line">d2 := loadPoolChainElt(&amp;d.next)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> val, ok := d.popTail(); ok &#123;  </span><br><span class="line"><span class="keyword">return</span> val, ok  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> d2 == <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="comment">// This is the only dequeue. It&#x27;s empty right  </span></span><br><span class="line"><span class="comment">// now, but could be pushed to in the future.  </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 同样的通过 CAS 来更新 tail 的值为 d2  </span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) &#123;  </span><br><span class="line">storePoolChainElt(&amp;d2.prev, <span class="literal">nil</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">        <span class="comment">// 最后将d2赋值给d便于进行下一轮循环。  </span></span><br><span class="line">d = d2  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p><p>在 for 循环的一开始，就把 d.next 加载到了 d2。因为 d 可能会短暂为空，但如果 d2 在 pop 或者 pop fails 之前就不为空的话，说明 d 就会永久为空了。在这种情况下，可以安全地将 d 这个结点“甩掉”。</p><p>最后，将 c.tail 更新为 d2，可以防止下次 popTail 的时候查看一个空的 dequeue；而将 d2.prev 设置为 nil，可以防止下次 popHead 时查看一个空的 dequeue。</p><p>我们再看一下核心的 <code>poolDequeue.popTail</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popTail() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;  </span><br><span class="line"><span class="keyword">var</span> slot *eface  </span><br><span class="line"><span class="keyword">for</span> &#123;  </span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">head, tail := d.unpack(ptrs)  </span><br><span class="line">        <span class="comment">// 同样的 head=tail 说明队列为空  </span></span><br><span class="line"><span class="keyword">if</span> tail == head &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 同样是 CAS 更新 headTail 以移除 tail 元素  </span></span><br><span class="line">ptrs2 := d.pack(head, tail+<span class="number">1</span>)  </span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;  </span><br><span class="line"><span class="comment">// Success.  </span></span><br><span class="line">slot = &amp;d.vals[tail&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]  </span><br><span class="line"><span class="keyword">break</span>  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 类型转换和 nil 判断  </span></span><br><span class="line">val := *(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot))  </span><br><span class="line"><span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;  </span><br><span class="line">val = <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 最后也是将这个 slot 置空  </span></span><br><span class="line">    <span class="comment">// 先清空 val 再清空 typ 操作顺序和 pushHead 正好相反  </span></span><br><span class="line">slot.val = <span class="literal">nil</span>  </span><br><span class="line">atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">true</span>  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popTail() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;  </span><br><span class="line"><span class="keyword">var</span> slot *eface  </span><br><span class="line"><span class="keyword">for</span> &#123;  </span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">head, tail := d.unpack(ptrs)  </span><br><span class="line">        <span class="comment">// 同样的 head=tail 说明队列为空  </span></span><br><span class="line"><span class="keyword">if</span> tail == head &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 同样是 CAS 更新 headTail 以移除 tail 元素  </span></span><br><span class="line">ptrs2 := d.pack(head, tail+<span class="number">1</span>)  </span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;  </span><br><span class="line"><span class="comment">// Success.  </span></span><br><span class="line">slot = &amp;d.vals[tail&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]  </span><br><span class="line"><span class="keyword">break</span>  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 类型转换和 nil 判断  </span></span><br><span class="line">val := *(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot))  </span><br><span class="line"><span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;  </span><br><span class="line">val = <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 最后也是将这个 slot 置空  </span></span><br><span class="line">    <span class="comment">// 先清空 val 再清空 typ 操作顺序和 pushHead 正好相反  </span></span><br><span class="line">slot.val = <span class="literal">nil</span>  </span><br><span class="line">atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>)  </span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整体逻辑和 popHead 差不多。</p><h4 id="2-3-5-小结"><a href="#2-3-5-小结" class="headerlink" title="2.3.5 小结"></a>2.3.5 小结</h4><p>首先从 当前 p 对应的 local.private 上取，没有就从 local.shared 里取，还没有就去其他 p 的 local.shared 里取，都没有就 new 一个返回。</p><h3 id="2-4-Put"><a href="#2-4-Put" class="headerlink" title="2.4 Put"></a>2.4 Put</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Put(x <span class="keyword">interface</span>&#123;&#125;) &#123;  </span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">return</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">l, _ := p.pin()  </span><br><span class="line"><span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123;  </span><br><span class="line">l.private = x  </span><br><span class="line">x = <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> x != <span class="literal">nil</span> &#123;  </span><br><span class="line">l.shared.pushHead(x)  </span><br><span class="line">&#125;  </span><br><span class="line">runtime_procUnpin()  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程也比较简单：</p><ol><li>先绑定 g 和 P，然后尝试将 x 赋值给 private 字段。</li><li>如果失败，就调用 <code>pushHead</code> 方法尝试将其放入 shared 字段所维护的双端队列中。<h4 id="2-4-1-pushHead"><a href="#2-4-1-pushHead" class="headerlink" title="2.4.1 pushHead"></a>2.4.1 pushHead</h4></li></ol><p>p.pin() 和之前是一样的，就不分析了，主要看一下 pushHead()<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> pushHead(val <span class="keyword">interface</span>&#123;&#125;) &#123;  </span><br><span class="line">d := c.head  </span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="comment">// 第一次写入，队列为空则进行初始化 默认长度为8  </span></span><br><span class="line"><span class="keyword">const</span> initSize = <span class="number">8</span> <span class="comment">// Must be a power of 2  </span></span><br><span class="line">d = <span class="built_in">new</span>(poolChainElt)  </span><br><span class="line">d.vals = <span class="built_in">make</span>([]eface, initSize)  </span><br><span class="line">c.head = d  </span><br><span class="line">storePoolChainElt(&amp;c.tail, d)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 存储元素 存储成功直接返回  </span></span><br><span class="line"><span class="keyword">if</span> d.pushHead(val) &#123;  </span><br><span class="line"><span class="keyword">return</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// The current dequeue is full. Allocate a new one of twice  </span></span><br><span class="line"><span class="comment">// the size.  </span></span><br><span class="line">    <span class="comment">// 存储失败说明队列满了 进行扩容  </span></span><br><span class="line">newSize := <span class="built_in">len</span>(d.vals) * <span class="number">2</span>  </span><br><span class="line"><span class="keyword">if</span> newSize &gt;= dequeueLimit &#123; <span class="comment">// 限制一下，不能无限扩容  </span></span><br><span class="line">newSize = dequeueLimit  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 扩容逻辑也比较简单，就是首尾相连，构成链表  </span></span><br><span class="line">d2 := &amp;poolChainElt&#123;prev: d&#125;  </span><br><span class="line">d2.vals = <span class="built_in">make</span>([]eface, newSize)  </span><br><span class="line">c.head = d2  </span><br><span class="line">storePoolChainElt(&amp;d.next, d2)  </span><br><span class="line">d2.pushHead(val)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果 <code>c.head</code> 为空，就要创建一个 poolChainElt，作为首结点，当然也是尾节点。它管理的双端队列的长度，初始为 8，放满之后，再创建一个 poolChainElt 节点时，双端队列的长度就要翻倍。当然，有一个最大长度限制（2^30）：</p><p>const dequeueBits = 32  </p><p>const dequeueLimit = (1 &lt;&lt; dequeueBits) / 4</p><p>调用 <code>poolDequeue.pushHead</code> 尝试将对象放到 poolDeque 里去：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> pushHead(val <span class="keyword">interface</span>&#123;&#125;) <span class="type">bool</span> &#123;  </span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">head, tail := d.unpack(ptrs)  </span><br><span class="line">    <span class="comment">// 首先判断队列是否已满： 也就是将尾部指针加上 d.vals 的长度，再取低 31 位，看它是否和 head 相等  </span></span><br><span class="line"><span class="keyword">if</span> (tail+<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)))&amp;(<span class="number">1</span>&lt;&lt;dequeueBits<span class="number">-1</span>) == head &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">slot := &amp;d.vals[head&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Check if the head slot has been released by popTail.  </span></span><br><span class="line">typ := atomic.LoadPointer(&amp;slot.typ)  </span><br><span class="line"><span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="comment">// Another goroutine is still cleaning up the tail, so  </span></span><br><span class="line"><span class="comment">// the queue is actually still full.  </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// slot占位，将val存入vals中  </span></span><br><span class="line"><span class="keyword">if</span> val == <span class="literal">nil</span> &#123;  </span><br><span class="line">val = dequeueNil(<span class="literal">nil</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">*(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot)) = val  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// head 增加 1  </span></span><br><span class="line">atomic.AddUint64(&amp;d.headTail, <span class="number">1</span>&lt;&lt;dequeueBits)  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先判断队列是否已满：</p><pre><code>if (tail+uint32(len(d.vals)))&amp;(1&lt;&lt;dequeueBits-1) == head &#123;      return false  &#125;</code></pre><p>队列没满，通过 head 指针找到即将填充的 slot 位置：取 head 指针的低 31 位。</p><pre><code>slot := &amp;d.vals[head&amp;uint32(len(d.vals)-1)]  // Check if the head slot has been released by popTail.  typ := atomic.LoadPointer(&amp;slot.typ)  if typ != nil &#123;      // Another goroutine is still cleaning up the tail, so      // the queue is actually still full.      return false  &#125;</code></pre><p>这里还判断了当前 slot 是否正在被 popTail 释放，popTail 相关语句如下：</p><pre><code>// 最后也是将这个 slot 置空  // 先清空 val 再清空 typ 操作顺序和 pushHead 正好相反  slot.val = nil  atomic.StorePointer(&amp;slot.typ, nil)</code></pre><p>所以如果 slot.typ==nil 就说明这个 slot 正在被 popTail 释放，说明队列其实还是满的，直接返回 false，走后续的扩容逻辑。</p><p>最后，将 val 赋值到 slot，并将 head 指针值加 1。</p><p>// slot占位，将val存入vals中<br><em>(</em>interface{})(unsafe.Pointer(slot)) = val</p><blockquote><p>这里的实现比较巧妙，slot 是 eface 类型，即空接口，将 slot 转为 interface{} 类型，这样 val 能以 interface{} 赋值给 slot 让 slot.typ 和 slot.val 指向其内存块，于是 slot.typ 和 slot.val 均不为空。</p></blockquote><h4 id="2-4-2-pack-unpack"><a href="#2-4-2-pack-unpack" class="headerlink" title="2.4.2 pack/unpack"></a>2.4.2 pack/unpack</h4><p>最后我们再来看一下 pack 和 unpack 函数，它们实际上是一组绑定、解绑 head 和 tail 指针的两个函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> pack(head, tail <span class="type">uint32</span>) <span class="type">uint64</span> &#123;  </span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span>  </span><br><span class="line"><span class="keyword">return</span> (<span class="type">uint64</span>(head) &lt;&lt; dequeueBits) |  </span><br><span class="line"><span class="type">uint64</span>(tail&amp;mask)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`mask`</span> 的低 <span class="number">31</span> 位为全 <span class="number">1</span>，其他位为 <span class="number">0</span>，它和 tail 相与，就是只看 tail 的低 <span class="number">31</span> 位。而 head 向左移 <span class="number">32</span> 位之后，低 <span class="number">32</span> 位为全 <span class="number">0</span>。最后把两部分“或”起来，head 和 tail 就“绑定”在一起了。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> unpack(ptrs <span class="type">uint64</span>) (head, tail <span class="type">uint32</span>) &#123;  </span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span>  </span><br><span class="line">head = <span class="type">uint32</span>((ptrs &gt;&gt; dequeueBits) &amp; mask)  </span><br><span class="line">tail = <span class="type">uint32</span>(ptrs &amp; mask)  </span><br><span class="line"><span class="keyword">return</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>unpack 则是相反的逻辑，取出 head 指针的方法就是将 ptrs 右移 32 位，再与 mask 相与，同样只看 head 的低 31 位。而 tail 实际上更简单，直接将 ptrs 与 mask 相与就可以了。</p><h4 id="2-4-3-小结"><a href="#2-4-3-小结" class="headerlink" title="2.4.3 小结"></a>2.4.3 小结</h4><p>Put 和 Get 类似，首先尝试将放到当前 p 的 local.private 上，已经有了就放到 local.shared。</p><h3 id="2-5-GC"><a href="#2-5-GC" class="headerlink" title="2.5 GC"></a>2.5 GC</h3><p>对于 Pool 而言，并不能无限扩展，否则对象占用内存太多了，会引起内存溢出。<br>sync.pool 选择了在 GC 时进行清理。<br>在 pool.go 文件的 init 函数里，注册了 GC 发生时，如何清理 Pool 的函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/pool.go  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;  </span><br><span class="line">runtime_registerPoolCleanup(poolCleanup)  </span><br><span class="line">&#125;</span><br><span class="line">编译器在编译时将其注册到运行时：</span><br><span class="line"><span class="comment">// src/runtime/mgc.go  </span></span><br><span class="line"><span class="comment">// Hooks for other packages  </span></span><br><span class="line"><span class="keyword">var</span> poolcleanup <span class="function"><span class="keyword">func</span><span class="params">()</span></span>  </span><br><span class="line"><span class="comment">// 利用编译器标志将 sync 包中的清理注册到运行时  </span></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_registerPoolCleanup sync.runtime_registerPoolCleanup  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_registerPoolCleanup</span><span class="params">(f <span class="keyword">func</span>()</span></span>) &#123;  </span><br><span class="line">  poolcleanup = f  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">具体的 poolCleanup() 函数如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolCleanup</span><span class="params">()</span></span> &#123;  </span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> oldPools &#123;  </span><br><span class="line">p.victim = <span class="literal">nil</span>  </span><br><span class="line">p.victimSize = <span class="number">0</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> allPools &#123;  </span><br><span class="line">p.victim = p.local  </span><br><span class="line">p.victimSize = p.localSize  </span><br><span class="line">p.local = <span class="literal">nil</span>  </span><br><span class="line">p.localSize = <span class="number">0</span>  </span><br><span class="line">&#125;  </span><br><span class="line">oldPools, allPools = allPools, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整体看起来，比较简洁。主要是将 local 和 victim 作交换，这样也就不致于让 GC 把所有的 Pool 都清空了，有 victim 在“兜底”。</p><ol><li>初始状态下，oldPools 和 allPools 均为 nil。</li><li>第 1 次调用 Get，由于 p.local 为 nil，将会在 pinSlow 中创建 p.local，然后将 p 放入 allPools，此时 allPools 长度为 1，oldPools 为 nil。</li><li>对象使用完毕，第 1 次调用 Put 放回对象。</li><li>第 1 次GC STW 阶段，allPools 中所有 p.local 将值赋值给 victim 并置为 nil。allPools 赋值给 oldPools，最后 allPools 为 nil，oldPools 长度为 1。</li><li>第 2 次调用 Get，由于 p.local 为 nil，此时会从 p.victim 里面尝试取对象。</li><li>对象使用完毕，第 2 次调用 Put 放回对象，但由于 p.local 为 nil，重新创建 p.local，并将对象放回，此时 allPools 长度为 1，oldPools 长度为 1。</li><li>第 2 次 GC STW 阶段，oldPools 中所有 p.victim 置 nil，前一次的 cache 在本次 GC 时被回收，allPools 所有 p.local 将值赋值给 victim 并置为nil，最后 allPools 为 nil，oldPools 长度为 1。<br>简单来说就是清理时，先清理 oldPools 的 local.victim,然后把 allPools 中的 local 赋值给 victim，最后再把 allPools 赋值给 oldPools，把 allPools 置空。<blockquote><p>GC 时只会清理 oldPools，allPools 只会先把数据转移到 victim，然后把 allPools 变成 oldPools，如果从 oldPools 中读取出来的数据进行 Put 也会直接放到 allPools 中，相当于要两次 GC 都没有被访问到并且Put回来才会被移除。</p></blockquote></li></ol><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><ul><li><p>1）关键思想是对象的复用，避免重复创建、销毁。将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力。</p></li><li><p>2）<code>sync.Pool</code> 是协程安全的，使用起来非常方便。设置好 New 函数后，调用 Get 获取，调用 Put 归还对象。</p></li><li><p>3）不要对 Get 得到的对象有任何假设，更好的做法是归还对象时，将对象“清空”。</p></li><li><p>4）Pool 里对象的生命周期受 GC 影响，不适合于做连接池，因为连接池需要自己管理对象的生命周期。</p></li></ul><p>一些设计思想或者相关知识点：</p><ul><li><p>lock free：无锁编程是很多编程语言里逃离不了的话题。<code>sync.Pool</code>的无锁是在<code>poolDequeue</code>和<code>poolChain</code>层面实现的。</p></li><li><p>原子操作代替锁：<code>poolDequeue</code>对一些关键变量采用了CAS操作，比如<code>poolDequeue.headTail</code>，既可完整保证并发又能降低相比锁而言的开销。</p></li><li><p>cacheline false sharing 问题</p></li><li><p>noCopy 禁止复制</p></li><li><p>分段锁，降低锁粒度</p></li><li><p>victim cache</p></li><li><p>常见优化手段：复用</p></li></ul><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><code>https://golang.org/src/sync/pool.go</code></p><p><code>https://en.wikipedia.org/wiki/False_sharing</code></p><p><code>https://en.wikipedia.org/wiki/Victim_cache</code></p><p><code>https://zhuanlan.zhihu.com/p/110140126</code></p><p><code>https://medium.com/swlh/go-the-idea-behind-sync-pool-32da5089df72</code></p><p><code>https://zhuanlan.zhihu.com/p/133638023</code></p><p><code>https://www.jianshu.com/p/dc4b5562aad2</code></p><p><code>https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/</code></p><p>[Github]  <a href="https://github.com/lixd/i-go/blob/master/a-tutorials/lib/sync_pool/main.go">https://github.com/lixd/i-go/blob/master/a-tutorials/lib/sync_pool/main.go</a> </p><p>[pool-structure]  <a href="https://github.com/lixd/blog/raw/master/images/golang/lib/sync-pool/pool-structure.png">https://github.com/lixd/blog/raw/master/images/golang/lib/sync-pool/pool-structure.png</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/08/22/Basic/RPC/"/>
      <url>/2023/08/22/Basic/RPC/</url>
      
        <content type="html"><![CDATA[<pre><code>RPC（Remote Procedure Call）远程过程调用，是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议</code></pre><h2 id="RPC机制和实现过程"><a href="#RPC机制和实现过程" class="headerlink" title="RPC机制和实现过程"></a>RPC机制和实现过程</h2><ul><li>RPC 是远程过程调用的方式之一，涉及调用方和被调用方两个进程的交互。因为 RPC 提供类似于本地方法调用的形式，所以对于调用方来说，调用 RPC 方法和调用本地方法并没有明显区别。<br>　　1. 定义 IDL 文件，生成 stub 桩文件，实现函数映射<br>　　2. 调用者（客户端Client）以本地调用的方式发起调用；<br>　　3. 序列化：Client stub（客户端存根）收到调用后，负责将被调用的方法名、参数等打包编码成特定格式的能进行网络传输的消息体；<br>　　4. Client stub将消息体通过网络发送给服务端；<br>　　5. Server stub（服务端存根）收到通过网络接收到消息后按照相应格式进行拆包解码，获取方法名和参数；<br>　　6. Server stub根据方法名和参数进行本地调用；<br>　　7. 被调用者（Server）本地调用执行后将结果返回给server stub；<br>　　8. Server stub将返回值打包编码成消息，并通过网络发送给客户端；<br>　　9. Client stub收到消息后，进行拆包解码，返回给Client；<br>　　10. Client得到本次RPC调用的最终结果。</li><li><strong>消息协议</strong>：以何种方式打包编码和拆包解码，有基于纯文本的 XML 和 JSON、二进制编码的Protobuf和Hessian等，或者自定义私有协议</li><li><strong>传输控制</strong>：主要有HTTP传输和TCP传输，鉴于TCP传输的可靠性，RPC的传输一般使用TCP作为传输协议</li><li><strong>RPC和HTTP区别</strong>  <ul><li>RPC 和 HTTP都是微服务间通信较为常用的方案之一，其实RPC 和 HTTP 并不完全是同一个层次的概念，它们之间还是有所区别的。  <ul><li>RPC 是远程过程调用，其调用协议通常包括序列化协议和传输协议。序列化协议有基于纯文本的 XML 和 JSON、二进制编码的Protobuf和Hessian。传输协议是指其底层网络传输所使用的协议，比如 TCP、HTTP。  </li><li>可以看出HTTP是RPC的传输协议的一个可选方案，比如说 gRPC 的网络传输协议就是 HTTP。HTTP 既可以和 RPC 一样作为服务间通信的解决方案，也可以作为 RPC 中通信层的传输协议（此时与之对比的是 TCP 协议）。</li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>[Go] 垃圾回收</title>
      <link href="/2022/09/12/Golang/2%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2022/09/12/Golang/2%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>垃圾回收（Garbage Collection，简称 GC）是一种内存管理策略，由垃圾收集器以类似守护协程的方式在后台运作，按照既定的策略为用户回收那些不再被使用的对象，释放对应的内存空间.</p></blockquote><span id="more"></span><h2 id="1-垃圾回收算法"><a href="#1-垃圾回收算法" class="headerlink" title="1 垃圾回收算法"></a>1 垃圾回收算法</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p><strong>GC 带来的优势</strong></p><ul><li>屏蔽内存回收的细节, 使用户更好地聚焦于核心的业务逻辑</li><li>以全局视野执行任务</li></ul><p><strong>GC 带来的劣势</strong></p><ul><li>提高了下限但降低了上限</li><li>增加了额外的成本</li></ul><h3 id="1-2-标记清扫"><a href="#1-2-标记清扫" class="headerlink" title="1.2 标记清扫"></a>1.2 标记清扫</h3><p>标记清扫（Mark-Sweep）算法, 分为两步实现:</p><ul><li>标记：标记出当前还存活的对象</li><li>清扫：清扫掉未被标记到的垃圾对象</li></ul><p>标记清扫通过标记存活对象，从而取补集推断出垃圾对象, 它的缺点在于会产生内存碎片, 这些碎片分散分布的话, 会影响大对象的内存分配.</p><h3 id="1-3-标记压缩"><a href="#1-3-标记压缩" class="headerlink" title="1.3 标记压缩"></a>1.3 标记压缩</h3><p>标记压缩（Mark-Compact）算法，是在标记清扫算法的基础上做了升级，在第二步”清扫“的同时还会对存活对象进行压缩整合，使得整体空间更为紧凑，从而解决内存碎片问题<br>缺陷在于实现时会有很高的复杂度.</p><h3 id="1-4-半空间复制"><a href="#1-4-半空间复制" class="headerlink" title="1.4 半空间复制"></a>1.4 半空间复制</h3><p><strong>半空间复制（Semispace Copy）算法主要实现如下:</strong></p><ul><li>分配两片相等大小的空间，称为 fromspace 和 tospace</li><li>每轮只使用 fromspace 空间，以GC作为分水岭划分轮次</li><li>GC时，将fromspace存活对象转移到tospace中，并以此为契机对空间进行压缩整合</li><li>GC后，交换fromspace和tospace，开启新的轮次</li></ul><p>半空间复制算法应用了以空间换取时间的优化策略，解决了内存碎片的问题，也在一定程度上降低了压缩空间的复杂度. 但其缺点也同样很明显——比较浪费空间<br>Java 所采用的就是半空间复制的升级版</p><h3 id="1-5-引用计数"><a href="#1-5-引用计数" class="headerlink" title="1.5 引用计数"></a>1.5 引用计数</h3><p><strong>引用计数（Reference Counting）主要实现如下:</strong></p><ul><li>对象每被引用一次，计数器加1</li><li>对象每被删除引用一次，计数器减1</li><li>GC时，把计数器等于 0 的对象删除</li></ul><p>缺陷在于无法解决循环引用和自引用的问题</p><h2 id="2-Golang-中的垃圾回收"><a href="#2-Golang-中的垃圾回收" class="headerlink" title="2 Golang 中的垃圾回收"></a>2 Golang 中的垃圾回收</h2><blockquote><p>在 1.8版本之后，Golang 的 GC 策略主要为并发三色标记法+混合写屏障机制</p></blockquote><h3 id="2-1-三色标记法"><a href="#2-1-三色标记法" class="headerlink" title="2.1 三色标记法"></a>2.1 三色标记法</h3><p>Golang GC 中用到的三色标记法属于标记清扫-算法下的一种实现, 主要思路如下:</p><ul><li>对象分为三种颜色标记：黑、灰、白</li><li>黑对象代表，对象自身存活，且其指向对象都已标记完成</li><li>灰对象代表，对象自身存活，但其指向对象还未标记完成</li><li>白对象代表，对象尙未被标记到，可能是垃圾对象</li><li>标记开始前，将根对象（全局对象、栈上局部变量等）置黑，将其所指向的对象置灰</li><li>标记规则是: 从灰对象出发，将其所指向的对象都置灰. 所有指向对象都置灰后，当前灰对象置黑</li><li>标记结束后，白色对象就是不可达的垃圾对象，需要进行清扫</li></ul><h3 id="2-2-并发垃圾回收"><a href="#2-2-并发垃圾回收" class="headerlink" title="2.2 并发垃圾回收"></a>2.2 并发垃圾回收</h3><ul><li>Golang 1.5 版本是个分水岭，在此之前，GC时需要停止全局的用户协程，专注完成GC工作后，再恢复用户协程，这样做在实现上简单直观，但是会对用户造成不好的体验</li><li>自1.5版本以来，Golang引入了并发垃圾回收机制，允许用户协程和后台的GC协程并发运行，大大地提高了用户体验. 但用户协程并发运行时可能对对象间的引用关系进行调整，这会严重打乱GC三色标记时的标记秩序</li></ul><h3 id="2-3-可能的问题"><a href="#2-3-可能的问题" class="headerlink" title="2.3 可能的问题"></a>2.3 可能的问题</h3><ul><li><strong>漏标问题</strong><ul><li>假设只有对象 B 持有对象 C 的引用,如果 GC 协程在 B 删除 C 的引用后才开始扫描 B，就会无法到达 C.  此时从扫描结果上看，C 是不可达的</li><li>针对漏标问题，Golang 给出的解决方案是屏障机制</li></ul></li><li><strong>多标问题</strong><ul><li>假设对象 A 持有对象 B 的引用</li><li>GC协程下，对象 A 被扫描完成，置黑；对象 B 被对象 A 引用，因此被置灰</li><li>用户协程下，对象 A 删除指向对象 B 的引用</li><li>B 在被 A 删除引用后，已成为垃圾对象，但由于其事先已被置灰，因此最终会更新为黑色，不会被 GC 删除</li><li>错标问题对比于漏标问题而言，是相对可以接受的, 至多到下一轮 GC，这部分对象就会被 GC 回收</li></ul></li><li><strong>内存碎片问题</strong><ul><li>Golang采用 TCMalloc 机制，依据对象的大小将其归属为到事先划分好的spanClass当中，这样能够消解外部碎片的问题，将问题限制在相对可控的内部碎片当中</li></ul></li><li><strong>为什么不学 Java 用分代?</strong><ul><li>分代算法指的是，将对象分为年轻代和老年代两部分（或者更多），采用不同的GC策略进行分类管理. 分代GC算法有效的前提是，绝大多数年轻代对象都是朝生夕死，拥有更高的GC回收率，因此适合采用特别的策略进行处理.</li><li>Golang中存在内存逃逸机制，会在编译过程中将生命周期更长的对象转移到堆中，将生命周期短的对象分配在栈上，并以栈为单位对这部分对象进行回收</li><li>综上，内存逃逸机制减弱了分代算法对Golang GC所带来的优势，考虑分代算法需要产生额外的成本（如不同年代的规则映射、状态管理以及额外的写屏障），Golang 选择不采用分代GC算法</li></ul></li></ul><h2 id="3-屏障机制"><a href="#3-屏障机制" class="headerlink" title="3 屏障机制"></a>3 屏障机制</h2><blockquote><p>主要是为了解决2.3小节中提及的并发GC下的漏标问题</p></blockquote><h3 id="3-1-强弱三色不变式"><a href="#3-1-强弱三色不变式" class="headerlink" title="3.1 强弱三色不变式"></a>3.1 强弱三色不变式</h3><p>漏标问题的本质就是，一个已经扫描完成的黑对象指向了一个被灰\白对象删除引用的白色对象. 构成这一场景的要素拆分如下：</p><ol><li>黑色对象指向了白色对象</li><li>灰、白对象删除了白色对象</li><li>（1）、（2）步中谈及的白色对象是同一个对象</li><li>（1）发生在（2）之前</li></ol><p>通过破坏这些要素,可以解决漏标问题, 称为强弱三色不变式:</p><ul><li>强三色不变式：白色对象不能被黑色对象直接引用（直接破坏（1））</li><li>弱三色不变式：白色对象可以被黑色对象引用，但要从某个灰对象出发仍然可达该白对象（间接破坏了（1）、（2）的联动）</li></ul><h3 id="3-2-插入写屏障"><a href="#3-2-插入写屏障" class="headerlink" title="3.2 插入写屏障"></a>3.2 插入写屏障</h3><ul><li>屏障机制类似于一个回调保护机制，指的是在完成某个特定动作前，会先完成屏障成设置的内容</li><li>插入写屏障（Dijkstra）的目标是实现<strong>强三色不变式</strong>，保证当一个黑色对象指向一个白色对象前，会先触发屏障将白色对象置为灰色，再建立引用</li></ul><h3 id="3-3-删除写屏障"><a href="#3-3-删除写屏障" class="headerlink" title="3.3 删除写屏障"></a>3.3 删除写屏障</h3><ul><li>删除写屏障（Yuasa barrier）的目标是实现<strong>弱三色不变式</strong>，保证当一个白色对象即将被上游删除引用前，会触发屏障将其置灰，之后再删除上游指向其的引用</li><li>也就是保证在删除到这个对象 A 的引用后,  对象 A对于 GC 来说依旧是可见的</li></ul><h3 id="3-4-混合写屏障"><a href="#3-4-混合写屏障" class="headerlink" title="3.4 混合写屏障"></a>3.4 混合写屏障</h3><ul><li>插入写屏障、删除写屏障二者择其一，即可解决并发GC的漏标问题，至于错标问题，则采用容忍态度，放到下一轮GC中进行延后处理即可</li><li>但是, 屏障机制无法作用于栈对象, 因为栈对象可能涉及频繁的轻量操作，高频率的触发屏障机制，带来的成本将是无法接受的.</li><li>在 Go1.8 前, 栈上的垃圾对象通过引入额外的Stop the world（STW）阶段解决, 1.18 后,  引入了混合写屏障机制来消除 STW 成本, 主要思路如下:<ul><li>GC 开始前，以栈为单位分批扫描，将栈中所有对象置黑</li><li>GC 期间，栈上新创建对象直接置黑</li><li>堆对象正常启用插入写屏障</li><li>堆对象正常启用删除写屏障</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] 内存分配</title>
      <link href="/2022/09/08/Golang/2%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>/2022/09/08/Golang/2%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Golang的内存管理是基于TCMalloc的核心思想来构建的，内存管理本质上是一个<strong>内存池和多级对象管理</strong></p></blockquote><span id="more"></span><h2 id="1-内存模型"><a href="#1-内存模型" class="headerlink" title="1 内存模型"></a>1 内存模型</h2><h3 id="1-1-操作系统存储模型"><a href="#1-1-操作系统存储模型" class="headerlink" title="1.1 操作系统存储模型"></a>1.1 操作系统存储模型</h3><p><strong>多级存储模型</strong></p><ul><li>寄存器      1ns</li><li>高速缓存   2ns</li><li>内存           10ns</li><li>磁盘            10ms</li></ul><p>速度越快, 空间越小, 价格越贵</p><h3 id="1-2-虚拟内存与物理内存"><a href="#1-2-虚拟内存与物理内存" class="headerlink" title="1.2 虚拟内存与物理内存"></a>1.2 虚拟内存与物理内存</h3><p>虚拟内存作用如下：</p><ul><li>在用户与硬件间添加中间代理层</li><li>优化用户体验（进程感知到获得的内存空间是“连续”的）</li><li>“放大”可用内存（虚拟内存可以由物理内存+磁盘补足，并根据冷热动态置换，用户无感知）</li></ul><h3 id="1-3-分页管理"><a href="#1-3-分页管理" class="headerlink" title="1.3 分页管理"></a>1.3 分页管理</h3><p>操作系统中通常会将虚拟内存和物理内存切割成固定的尺寸，于虚拟内存而言叫作“页”，于物理内存而言叫作“帧”，原因如下：</p><ul><li>提高内存空间利用（以页为粒度后，消灭了不稳定的外部碎片，取而代之的是相对可控的内部碎片）</li><li>提高内外存交换效率（更细的粒度带来了更高的灵活度）</li><li>与虚拟内存机制呼应，便于建立虚拟地址-&gt;物理地址的映射关系（聚合映射关系的数据结构，称为页表）</li><li>linux 页/帧的大小固定，为 4KB（这实际是由实践推动的经验值，太粗会增加碎片率，太细会增加分配频率影响效率）</li></ul><h3 id="1-4-Golang-内存模型"><a href="#1-4-Golang-内存模型" class="headerlink" title="1.4 Golang 内存模型"></a>1.4 Golang 内存模型</h3><p><strong>Golang 的内存模型设计的思路：</strong></p><ul><li>以空间换时间，一次缓存，多次复用<ul><li>由于每次向操作系统申请内存的操作很重，那么不妨一次多申请一些，以备后用, 因此产生了堆 mheap<ul><li>对操作系统而言，这是用户进程中缓存的内存</li><li>对于 Go 进程内部，堆是所有对象的内存起源</li></ul></li></ul></li><li><strong>多级缓存，实现无/细锁化</strong><ul><li>堆是 Go 运行时中最大的临界共享资源，这意味着每次存取都要加锁，在性能层面是一件很可怕的事情.</li><li>因此 Golang 在堆 mheap 之上，依次细化粒度，建立了 mcentral、mcache 的模型:<ul><li>mheap：全局的内存起源，访问要加全局锁</li><li>mcentral：每种对象大小规格（全局共划分为 68 种）对应的缓存，锁的粒度也仅限于同一种规格以内</li><li>mcache：每个 P（正是 GMP 中的 P）持有一份的内存缓存，访问时无锁</li></ul></li></ul></li><li>多级规格，提高利用率<ul><li>page：最小的存储单元, Golang 借鉴操作系统分页管理的思想，每个最小的存储单元也称之为页 page，但大小为 8 KB</li><li>mspan：最小的管理单元. mspan 大小为 page 的整数倍，且从 8B 到 80 KB 被划分为 67 种不同的规格，分配对象时，会根据大小映射到不同规格的 mspan，从中获取空间, 多规格 mspan 特点如下:<ul><li>根据规格大小，产生了等级的制度</li><li>消除了外部碎片，但不可避免会有内部碎片</li><li>宏观上能提高整体空间利用率</li><li>正是因为有了规格等级的概念，才支持 mcentral 实现细锁化</li></ul></li></ul></li></ul><h2 id="2-核心概念"><a href="#2-核心概念" class="headerlink" title="2 核心概念"></a>2 核心概念</h2><h3 id="2-1-内存单元-mspan"><a href="#2-1-内存单元-mspan" class="headerlink" title="2.1 内存单元 mspan"></a>2.1 内存单元 mspan</h3><p><strong>mspan 的特质</strong>:</p><ul><li>mspan 是 Golang 内存管理的最小单元</li><li>mspan 大小是 page 的整数倍（Go 中的 page 大小为 8KB），且内部的页是连续的（至少在虚拟内存的视角中是这样）</li><li>每个 mspan 根据空间大小以及面向分配对象的大小，会被划分为不同的等级</li><li>同等级的 mspan 会从属同一个 mcentral，最终会被组织成链表，因此带有前后指针（prev、next）</li><li>同等级的 mspan 内聚于同一个 mcentral，所以会基于同一把互斥锁管理</li><li>mspan 会基于 bitMap 辅助快速找到空闲内存块（块大小为对应等级下的 object 大小），此时需要使用到 Ctz64 算法</li></ul><h3 id="2-2-内存单元等级-spanClass"><a href="#2-2-内存单元等级-spanClass" class="headerlink" title="2.2 内存单元等级 spanClass"></a>2.2 内存单元等级 spanClass</h3><p>mspan 根据空间大小和面向分配对象的大小，被划分为 67 种等级（1-67，实际上还有一种隐藏的 0 级，用于处理更大的对象，上不封顶）</p><div class="table-container"><table><thead><tr><th><strong>class</strong></th><th><strong>bytes/obj</strong></th><th><strong>bytes/span</strong></th><th><strong>objects</strong></th><th><strong>tail waste</strong></th><th><strong>max waste</strong></th></tr></thead><tbody><tr><td>1</td><td>8</td><td>8192</td><td>1024</td><td>0</td><td>87.50%</td></tr><tr><td>2</td><td>16</td><td>8192</td><td>512</td><td>0</td><td>43.75%</td></tr><tr><td>3</td><td>24</td><td>8192</td><td>341</td><td>8</td><td>29.24%</td></tr><tr><td>4</td><td>32</td><td>8192</td><td>256</td><td>0</td><td>21.88%</td></tr><tr><td>…</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>66</td><td>28672</td><td>57344</td><td>2</td><td>0</td><td>4.91%</td></tr><tr><td>67</td><td>32768</td><td>32768</td><td>1</td><td>0</td><td>12.50%</td></tr></tbody></table></div><ul><li>class：mspan 等级标识，1-67</li><li>bytes/obj：该大小规格的对象会从这一 mspan 中获取空间. 创建对象过程中，大小会向上取整为 8B 的整数倍，因此该表可以直接实现 object 到 mspan 等级 的映射</li><li>bytes/span：该等级的 mspan 的总空间大小</li><li>object：该等级的 mspan 最多可以 new 多少个对象，结果等于 （3）/（2）</li><li>tail waste：（3）/（2）可能除不尽，于是该项值为（3）%（2）</li><li>max waste：最不利的情况下浪费的空间比例</li></ul><h3 id="2-3-线程缓存-mcache"><a href="#2-3-线程缓存-mcache" class="headerlink" title="2.3 线程缓存 mcache"></a>2.3 线程缓存 mcache</h3><p><strong>特点</strong></p><ul><li>mcache 是每个 P 独有的缓存，因此交互无锁</li><li>mcache 将每种 spanClass 等级的 mspan 各缓存了一个，总数为 2（nocan 维度） * 68（大小维度）= 136</li><li>mcache 中还有一个为对象分配器 tiny allocator，用于处理小于 16B 对象的内存分配</li></ul><h3 id="2-4-中心缓存-mcentral"><a href="#2-4-中心缓存-mcentral" class="headerlink" title="2.4 中心缓存 mcentral"></a>2.4 中心缓存 mcentral</h3><p><strong>特点:</strong></p><ul><li>每个 mcentral 对应一种 spanClass</li><li>每个 mcentral 下聚合了该 spanClass 下的 mspan</li><li>mcentral 下的 mspan 分为两个链表，分别为有空间 mspan 链表 partial 和满空间 mspan 链表 full</li><li>每个 mcentral 一把锁</li></ul><h3 id="2-5-全局堆缓存-mheap"><a href="#2-5-全局堆缓存-mheap" class="headerlink" title="2.5 全局堆缓存 mheap"></a>2.5 全局堆缓存 mheap</h3><p><strong>特点:</strong></p><ul><li>对于 Golang 上层应用而言，堆是操作系统虚拟内存的抽象</li><li>以页（8KB）为单位，作为最小内存存储单元</li><li>负责将连续页组装成 mspan</li><li>全局内存基于 bitMap 标识其使用情况，每个 bit 对应一页，为 0 则自由，为 1 则已被 mspan 组装</li><li>通过 heapArena 聚合页，记录了页到 mspan 的映射信息</li><li>建立空闲页基数树索引 radix tree index，辅助快速寻找空闲页</li><li>是 mcentral 的持有者，持有所有 spanClass 下的 mcentral，作为自身的缓存</li><li>内存不够时，向操作系统申请，申请单位为 heapArena（64M）</li></ul><h3 id="2-6-空闲页索引-pageAlloc"><a href="#2-6-空闲页索引-pageAlloc" class="headerlink" title="2.6 空闲页索引 pageAlloc"></a>2.6 空闲页索引 pageAlloc</h3><ul><li>mheap 会基于 bitMap 标识内存中各页的使用情况，bit 位为 0 代表该页是空闲的，为 1 代表该页已被 mspan 占用</li><li>每棵基数树聚合了 16 GB 内存空间中各页使用情况的索引信息，用于帮助 mheap 快速找到指定长度的连续空闲页的所在位置</li><li>mheap 持有 2^14 棵基数树，因此索引全面覆盖到 2^14 * 16 GB = 256 T 的内存空间</li><li>基数树中，每个节点称之为 PallocSum，是一个 uint64 类型，体现了索引的聚合信息，包含以下四部分：<ul><li>start：最右侧 21 个 bit，标识了当前节点映射的 bitMap 范围中首端有多少个连续的 0 bit（空闲页），称之为 start；</li><li>max：中间 21 个 bit，标识了当前节点映射的 bitMap 范围中最多有多少个连续的 0 bit（空闲页），称之为 max；</li><li>end：左侧 21 个 bit，标识了当前节点映射的 bitMap 范围中最末端有多少个连续的 0 bit（空闲页），称之为 end.</li><li>最左侧一个 bit，弃置不用</li></ul></li><li>基数树父子关系<ul><li>每个父 pallocSum 有 8 个子 pallocSum</li><li>根 pallocSum 总览全局，映射的 bitMap 范围为全局的 16 GB 空间（其 max 最大值为 2^21，因此总空间大小为 2^21*8KB=16GB）</li><li>从首层向下是一个依次八等分的过程，每一个 pallocSum 映射其父节点 bitMap 范围的八分之一，因此第二层 pallocSum 的 bitMap 范围为 16GB/8 = 2GB，以此类推，第五层节点的范围为 16GB / (8^4) = 4 MB，已经很小</li><li>聚合信息时，自底向上. 每个父 pallocSum 聚合 8 个子 pallocSum 的 start、max、end 信息，形成自己的信息，直到根 pallocSum，坐拥全局 16 GB 的 start、max、end 信息</li><li>mheap 寻页时，自顶向下. 对于遍历到的每个 pallocSum，先看起 start 是否符合，是则寻页成功；再看 max 是否符合，是则进入其下层孩子 pallocSum 中进一步寻访；最后看 end 和下一个同辈 pallocSum 的 start 聚合后是否满足，是则寻页成功</li></ul></li></ul><h3 id="2-7-heapArena"><a href="#2-7-heapArena" class="headerlink" title="2.7 heapArena"></a>2.7 heapArena</h3><ul><li>每个 heapArena 包含 8192 个页，大小为 8192 * 8KB = 64 MB</li><li>heapArena 记录了页到 mspan 的映射. 因为 GC 时，通过地址偏移找到页很方便，但找到其所属的 mspan 不容易. 因此需要通过这个映射信息进行辅助.</li><li>heapArena 是 mheap 向操作系统申请内存的单位（64MB）</li></ul><h2 id="3-对象分配流程"><a href="#3-对象分配流程" class="headerlink" title="3 对象分配流程"></a>3 对象分配流程</h2><p>串联 Golang 中分配对象的流程，不论是以下哪种方式，最终都会殊途同归步入 mallocgc 方法中，并且根据 3.1 小节中的策略执行分配流程:</p><ul><li>new(T)</li><li>&amp;T{}</li><li>make(xxxx)</li></ul><h3 id="3-1-分配流程总览"><a href="#3-1-分配流程总览" class="headerlink" title="3.1 分配流程总览"></a>3.1 分配流程总览</h3><p>Golang 中，依据 object 的大小，会将其分为下述三类:</p><ul><li>tiny 微对象 0-16B</li><li>small 小对象 16B-32KB</li><li>large 大对象 32KB+</li></ul><p>不同类型的对象，会有着不同的分配策略, 核心流程类似于读多级缓存的过程，由上而下，每一步只要成功则直接返回. 若失败，则由下层方法兜底.</p><p><strong>微对象的分配流程：</strong></p><ol><li>从 P 专属 mcache 的 tiny 分配器取内存（无锁）</li><li>根据所属的 spanClass，从 P 专属 mcache 缓存的 mspan 中取内存（无锁）</li><li>根据所属的 spanClass 从对应的 mcentral 中取 mspan 填充到 mcache，然后从 mspan 中取内存（spanClass 粒度锁）</li><li>根据所属的 spanClass，从 mheap 的页分配器 pageAlloc 取得足够数量空闲页组装成 mspan 填充到 mcache，然后从 mspan 中取内存（全局锁）</li><li>mheap 向操作系统申请内存，更新页分配器的索引信息，然后重复 4</li></ol><p>对于小对象的分配流程是跳过（1）步，执行上述流程的（2）-（5）步<br>对于大对象的分配流程是跳过（1）-（3）步，执行上述流程的（4）-（5）步</p><h3 id="3-2-主干方法-mallocgc"><a href="#3-2-主干方法-mallocgc" class="headerlink" title="3.2 主干方法 mallocgc"></a>3.2 主干方法 mallocgc</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">    <span class="comment">// 获取 m</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// 获取当前 p 对应的 mcache</span></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line">    <span class="keyword">var</span> span *mspan</span><br><span class="line">    <span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">    <span class="comment">// 根据当前对象是否包含指针，标识 gc 时是否需要展开扫描</span></span><br><span class="line">    noscan := typ == <span class="literal">nil</span> || typ.ptrdata == <span class="number">0</span></span><br><span class="line">    <span class="comment">// 是否是小于 32KB 的微、小对象</span></span><br><span class="line">    <span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line">    <span class="comment">// 小于 16 B 且无指针，则视为微对象</span></span><br><span class="line">        <span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">        <span class="comment">// tiny 内存块中，从 offset 往后有空闲位置</span></span><br><span class="line">          off := c.tinyoffset</span><br><span class="line">          <span class="comment">// 如果大小为 5 ~ 8 B，size 会被调整为 8 B，此时 8 &amp; 7 == 0，会走进此分支</span></span><br><span class="line">          <span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 将 offset 补齐到 8 B 倍数的位置</span></span><br><span class="line">                off = alignUp(off, <span class="number">8</span>)</span><br><span class="line">                <span class="comment">// 如果大小为 3 ~ 4 B，size 会被调整为 4 B，此时 4 &amp; 3 == 0，会走进此分支  </span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">           <span class="comment">// 将 offset 补齐到 4 B 倍数的位置</span></span><br><span class="line">                off = alignUp(off, <span class="number">4</span>)</span><br><span class="line">                <span class="comment">// 如果大小为 1 ~ 2 B，size 会被调整为 2 B，此时 2 &amp; 1 == 0，会走进此分支  </span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 将 offset 补齐到 2 B 倍数的位置</span></span><br><span class="line">                off = alignUp(off, <span class="number">2</span>)</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">// 如果当前 tiny 内存块空间还够用，则直接分配并返回</span></span><br><span class="line">            <span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 分配空间</span></span><br><span class="line">                x = unsafe.Pointer(c.tiny + off)</span><br><span class="line">                c.tinyoffset = off + size</span><br><span class="line">                c.tinyAllocs++</span><br><span class="line">                mp.mallocing = <span class="number">0</span></span><br><span class="line">                releasem(mp)  </span><br><span class="line">                <span class="keyword">return</span> x</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 分配一个新的 tiny 内存块</span></span><br><span class="line">            span = c.alloc[tinySpanClass]    </span><br><span class="line">            <span class="comment">// 从 mCache 中获取</span></span><br><span class="line">            v := nextFreeFast(span)        </span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 从 mCache 中获取失败，则从 mCentral 或者 mHeap 中获取进行兜底</span></span><br><span class="line">                v, span, shouldhelpgc = c.nextFree(tinySpanClass)</span><br><span class="line">            &#125;   </span><br><span class="line"><span class="comment">// 分配空间      </span></span><br><span class="line">            x = unsafe.Pointer(v)</span><br><span class="line">           (*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">           (*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">           size = maxTinySize</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 根据对象大小，映射到其所属的 span 的等级(0~66）</span></span><br><span class="line">          <span class="keyword">var</span> sizeclass <span class="type">uint8</span></span><br><span class="line">          <span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">              sizeclass = size_to_class8[divRoundUp(size, smallSizeDiv)]</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              sizeclass = size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]</span><br><span class="line">          &#125;        </span><br><span class="line">          <span class="comment">// 对应 span 等级下，分配给每个对象的空间大小(0~32KB)</span></span><br><span class="line">          size = <span class="type">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">          <span class="comment">// 创建 spanClass 标识，其中前 7 位对应为 span 的等级(0~66)，最后标识表示了这个对象 gc 时是否需要扫描</span></span><br><span class="line">          spc := makeSpanClass(sizeclass, noscan) </span><br><span class="line">          <span class="comment">// 获取 mcache 中的 span</span></span><br><span class="line">          span = c.alloc[spc]  </span><br><span class="line">          <span class="comment">// 从 mcache 的 span 中尝试获取空间        </span></span><br><span class="line">          v := nextFreeFast(span)</span><br><span class="line">          <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">          <span class="comment">// mcache 分配空间失败，则通过 mcentral、mheap 兜底            </span></span><br><span class="line">             v, span, shouldhelpgc = c.nextFree(spc)</span><br><span class="line">          &#125;     </span><br><span class="line">          <span class="comment">// 分配空间  </span></span><br><span class="line">          x = unsafe.Pointer(v)</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">       &#125;      </span><br><span class="line">       <span class="comment">// 大于 32KB 的大对象      </span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 从 mheap 中获取 0 号 span</span></span><br><span class="line">       span = c.allocLarge(size, noscan)</span><br><span class="line">       span.freeindex = <span class="number">1</span></span><br><span class="line">       span.allocCount = <span class="number">1</span></span><br><span class="line">       size = span.elemsize         </span><br><span class="line">       <span class="comment">// 分配空间   </span></span><br><span class="line">        x = unsafe.Pointer(span.base())</span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">return</span> x</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure><h3 id="3-3-步骤（1）：tiny-分配"><a href="#3-3-步骤（1）：tiny-分配" class="headerlink" title="3.3 步骤（1）：tiny 分配"></a>3.3 步骤（1）：tiny 分配</h3><p>每个 P 独有的 mcache 会有个微对象分配器，基于 offset 线性移动的方式对微对象进行分配，每 16B 成块，对象依据其大小，会向上取整为 2 的整数次幂进行空间补齐，然后进入分配流程</p><h3 id="3-4-步骤（2）：mcache-分配"><a href="#3-4-步骤（2）：mcache-分配" class="headerlink" title="3.4 步骤（2）：mcache 分配"></a>3.4 步骤（2）：mcache 分配</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据对象大小，映射到其所属的 span 的等级(0~66）</span></span><br><span class="line"><span class="keyword">var</span> sizeclass <span class="type">uint8</span></span><br><span class="line"><span class="comment">// get size class ....     </span></span><br><span class="line"><span class="comment">// 对应 span 等级下，分配给每个对象的空间大小(0~32KB)</span></span><br><span class="line"><span class="comment">// get span class</span></span><br><span class="line">spc := makeSpanClass(sizeclass, noscan) </span><br><span class="line"><span class="comment">// 获取 mcache 中的 span</span></span><br><span class="line">span = c.alloc[spc]  </span><br><span class="line"><span class="comment">// 从 mcache 的 span 中尝试获取空间        </span></span><br><span class="line">v := nextFreeFast(span)</span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// mcache 分配空间失败，则通过 mcentral、mheap 兜底            </span></span><br><span class="line">   v, span, shouldhelpgc = c.nextFree(spc)</span><br><span class="line">&#125;     </span><br><span class="line"><span class="comment">// 分配空间  </span></span><br><span class="line">x = unsafe.Pointer(v)</span><br></pre></td></tr></table></figure><h3 id="3-5-步骤（3）：mcentral-分配"><a href="#3-5-步骤（3）：mcentral-分配" class="headerlink" title="3.5 步骤（3）：mcentral 分配"></a>3.5 步骤（3）：mcentral 分配</h3><ul><li>当 mspan 无可用的 object 内存块时，会步入 mcache.nextFree 方法进行兜底.</li><li>倘若 mcache 中，对应的 mspan 空间不足，则会在 mcache.refill 方法中，向更上层的 mcentral 乃至 mheap 获取 mspan，填充到 mache 中</li><li>mcentral.cacheSpan 方法中，会加锁（spanClass 级别的 sweepLocker），分别从 partial 和 full 中尝试获取有空间的 mspan</li></ul><h3 id="3-6-步骤（4）：mheap-分配"><a href="#3-6-步骤（4）：mheap-分配" class="headerlink" title="3.6 步骤（4）：mheap 分配"></a>3.6 步骤（4）：mheap 分配</h3><p>在 mcentral.cacheSpan 方法中，倘若从 partial 和 full 中都找不到合适的 mspan 了，则会调用 mcentral 的 grow 方法，将事态继续升级<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> cacheSpan() *mspan &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// mcentral 中也没有可用的 mspan 了，则需要从 mheap 中获取，最终会调用 mheap_.alloc 方法</span></span><br><span class="line">    s = c.grow()</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行到此处时，s 已经指向一个存在 object 空位的 mspan 了</span></span><br><span class="line">havespan:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>经由 mcentral.grow 方法和 mheap.alloc 方法的周转，最终会步入 mheap.allocSpan 方法中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> grow() *mspan &#123;</span><br><span class="line">    npages := <span class="type">uintptr</span>(class_to_allocnpages[c.spanclass.sizeclass()])</span><br><span class="line">    size := <span class="type">uintptr</span>(class_to_size[c.spanclass.sizeclass()])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    s := mheap_.alloc(npages, c.spanclass)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> alloc(npages <span class="type">uintptr</span>, spanclass spanClass) *mspan &#123;</span><br><span class="line">    <span class="keyword">var</span> s *mspan</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        s = h.allocSpan(npages, spanAllocHeap, spanclass)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> allocSpan(npages <span class="type">uintptr</span>, typ spanAllocType, spanclass spanClass) (s *mspan) &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    base, scav := <span class="type">uintptr</span>(<span class="number">0</span>), <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...此处实际上还有一阶缓存，是从每个 P 的页缓存 pageCache 中获取空闲页组装 mspan，此处先略去了...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加上堆全局锁</span></span><br><span class="line">    lock(&amp;h.lock)</span><br><span class="line">    <span class="keyword">if</span> base == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 通过基数树索引快速寻找满足条件的连续空闲页</span></span><br><span class="line">        base, scav = h.pages.alloc(npages)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    unlock(&amp;h.lock)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HaveSpan:</span><br><span class="line">    <span class="comment">// 把空闲页组装成 mspan</span></span><br><span class="line">    s.init(base, npages)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将这批页添加到 heapArena 中，建立由页指向 mspan 的映射</span></span><br><span class="line">    h.setSpans(s.base(), npages, s)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-步骤（5）：向操作系统申请"><a href="#3-7-步骤（5）：向操作系统申请" class="headerlink" title="3.7 步骤（5）：向操作系统申请"></a>3.7 步骤（5）：向操作系统申请</h3><p>倘若 mheap 中没有足够多的空闲页了，会发起 mmap 系统调用，向操作系统申请额外的内存空间</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Channel</title>
      <link href="/2022/07/14/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Channel/"/>
      <url>/2022/07/14/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Channel/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习 golang 中的 chan，并分析其具体实现，包括创建 channel，发送数据，接收数据以及相关调度等。</p></blockquote><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><blockquote><p>A channel provides a mechanism for concurrently executing functions to communicate by sending and receiving values of a specified element type. The value of an uninitialized channel is nil.</p></blockquote><p>chan 提供了一种并发通信机制，用于生产和消费某一指定类型数据，未初始化的 chan 的值是nil。</p><p> <strong>使用场景：</strong> 消息传递、消息过滤，信号广播，事件订阅与广播，请求、响应转发，任务分发，结果汇总，并发控制，限流，同步与异步</p><h2 id="2-特性与实现"><a href="#2-特性与实现" class="headerlink" title="2 特性与实现"></a>2 特性与实现</h2><p>Chan 是 Go 里面的一种数据结构，具有以下特性：</p><ul><li>goroutine-safe，多个 goroutine 可以同时访问一个 channel 而不会出现并发问题</li><li>可以用于在 goroutine 之间存储和传递值</li><li>先入先出（FIFO）</li><li>可以导致 goroutine 的 block 和 unblock<h3 id="2-1-内部结构"><a href="#2-1-内部结构" class="headerlink" title="2.1 内部结构"></a>2.1 内部结构</h3></li></ul><p>主要包含以下几个部分：</p><ul><li>circular queue：循环队列，用于存储数据</li><li>send index 记录发送的位置</li><li>receive index 记录接收的位置</li><li>mutex 锁，用于实现 goroutine safe。</li></ul><p>元素队列的具体实现很简单，就是一个环形队列，使用 sendx 和 recvx 分别用来记录发送、接收的 offset，然后通过 mutex 互斥锁来保证并发安全。</p><h3 id="2-2-创建-chan"><a href="#2-2-创建-chan" class="headerlink" title="2.2 创建 chan"></a>2.2 创建 chan</h3><p>chan 使用 make 进行初始化，第一个参数指定 chan 中的元素类型，第二个参数用于指定 chan 的缓冲区大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>make 返回的 ch 实际上是一个指向 heap 中真正的 chan 对象的指针。<br><strong>chan（即 hchan 结构体） 默认会被分配在堆上，make 返回的只是一个指向该对象的指针</strong>。</p><blockquote><p>可以在函数之间传递 chan，而不是 chan 的指针。 因为 chan 本身就是指针</p></blockquote><h3 id="2-3-发送、接收与关闭"><a href="#2-3-发送、接收与关闭" class="headerlink" title="2.3 发送、接收与关闭"></a>2.3 发送、接收与关闭</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Task, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> _,task := <span class="keyword">range</span> helloTasks &#123;</span><br><span class="line">    taskCh &lt;- task <span class="comment">// 发送</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(tashCh) <span class="comment">// 关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ch)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        task:= &lt;-taskCh <span class="comment">// 接收</span></span><br><span class="line">        process(task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main goroutine 发送 task 到 chan，然后 worker goroutine 从 chan 中接收 task 并处理，最后 main goroutine 发送完成后关闭 chan。<br>具体<strong>发送过程</strong>如下：</p><ul><li>acquire 加锁</li><li>enqueue，将 task 对象<strong>拷贝</strong>到数组里</li><li>release 释放锁</li></ul><p>对于 chan 的关闭，最佳实践是由发送方进行关闭。<br><strong>接收过程</strong>：</p><ul><li>acquire 加锁</li><li>dequeue<ul><li>将 task 对象从 数组 中 <strong>拷贝</strong>出来赋值给用户用于接收的对象</li><li><code>task:= &lt;-taskCh</code>,比如这里就是拷贝出来赋值给 task</li></ul></li><li>release 释放锁</li></ul><p>整个过程中没有任何共享内存，数据都是通过 copy 进行传递,这遵循了 Go 并发设计中很核心的一个理念：</p><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating.</p></blockquote><h3 id="2-4-阻塞与唤醒"><a href="#2-4-阻塞与唤醒" class="headerlink" title="2.4 阻塞与唤醒"></a>2.4 阻塞与唤醒</h3><p>hchan 中的 buf 数组大小就是 make chan 时指定的大小。<br>当 buf 满之后再往 chan 中发送值就会阻塞。</p><blockquote><p>goroutine 调度：G 阻塞之后并不会阻塞 M。M 会先把这个 G 暂停(gopark)，然后把执行栈切换到 g0，g0 会执行 schedule() 函数，从当前 M 绑定的 P 中查找有没有可以执行的G，有就捞出来继续执行。</p></blockquote><h4 id="2-4-1-先发后收"><a href="#2-4-1-先发后收" class="headerlink" title="2.4.1 先发后收"></a>2.4.1 先发后收</h4><p>假设 chan 中已经有 3 个 task 了,然后再往里面发送一个</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskCh &lt;- task </span><br></pre></td></tr></table></figure><p>runtime 会调用 gopark 将这个 goroutine(姑且称作G1) 切换到 wait 状态。<br><em>什么时候会被唤醒呢？</em><br>hchan 结构体中还有 sendq、recvq 两个列表，分别记录了等待发送或者接收的 goroutine：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog</span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>比如前面被阻塞的 G1 就会存入 sendq</p></blockquote><p>假设此时 G2 从 chan 中取走一个消息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task:= &lt;-taskCh </span><br></pre></td></tr></table></figure><p>G2 取走一个消息后就会找到 sendq 中的第一个对象，把待发送的 elem 直接写入 buf 数组。然后 调用 goready 把对应的 goroutine  G1 设置为 runnable 状态。</p><h4 id="2-4-2-先收后发"><a href="#2-4-2-先收后发" class="headerlink" title="2.4.2 先收后发"></a>2.4.2 先收后发</h4><p>之前是先发送，后接收。现在看一下先接收后发送的情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task:= &lt;-taskCh </span><br></pre></td></tr></table></figure><p>G2 直接从空的 chan 中取消息，同样会被阻塞,然后被写入到 hchan 的 recqv 中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskCh &lt;- task </span><br></pre></td></tr></table></figure><p>按照上面的逻辑应该是，将 task 写入 buf 数组后，，再把 recvq 中的第一个 goroutine G2 唤醒。</p><p>但是 Go 官方这里进行了优化。因为 recvq 里的 elem 对象 t 存的就是<strong>接收者的内存地址</strong>。</p><p>所以我们可以直接把 G1 发送来的 task 写入 elem 对应的 t 里，即在 G1 里修改 G2 的栈对象。</p><blockquote><p>因为这个时候 G2 还是 gopark，处于 waiting 状态，所以不会出问题。</p><p>正常情况下因为不知道两个线程谁先谁后，这样改肯定会出问题。但是在 go runtime 这里，肯定是 G2 先执行，满足 happen-before 所以不存在问题。</p></blockquote><p>省去了发送和接收时的两次加解锁和内存拷贝。</p><h3 id="2-5-特性实现原理"><a href="#2-5-特性实现原理" class="headerlink" title="2.5 特性实现原理"></a>2.5 特性实现原理</h3><ul><li><strong>goroutine-safe</strong>.<ul><li>hchan <strong>mutex</strong>，通过加锁来避免数据竞争。</li></ul></li><li>可以用于在 goroutine 之间存储和传递值，以及先入先出（FIFO）语义。<ul><li>copying into and out of hchan <strong>buffer</strong></li></ul></li><li>可以导致 goroutine 的 block 和 unblock<ul><li>通过 <strong>sudog queues</strong> 来记录阻塞的 goroutine。</li><li>通过 <strong>runtime scheduler</strong>(gopark, goready)来实现阻塞与唤醒。</li></ul></li></ul><h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3 源码分析"></a>3 源码分析</h2><p><code>runtime/chan.go</code></p><h3 id="3-1-内部结构"><a href="#3-1-内部结构" class="headerlink" title="3.1 内部结构"></a>3.1 内部结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="type">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">dataqsiz <span class="type">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">elemsize <span class="type">uint16</span></span><br><span class="line">closed   <span class="type">uint32</span></span><br><span class="line">elemtype *_type <span class="comment">// element type</span></span><br><span class="line">sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line">recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog</span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">    g *g</span><br><span class="line">    next *sudog</span><br><span class="line">    prev *sudog</span><br><span class="line">    elem unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line">    isSelect <span class="type">bool</span></span><br><span class="line">    c        *hchan </span><br><span class="line">&#125;<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- qcount：当前 channel 中存在多少个元素；</span></span><br><span class="line"><span class="string">- dataqsize: 当前 channel 能存放的元素容量；</span></span><br><span class="line"><span class="string">- buf：channel 中用于存放元素的环形缓冲区；</span></span><br><span class="line"><span class="string">- elemsize：channel 元素类型的大小；</span></span><br><span class="line"><span class="string">- closed：标识 channel 是否关闭；</span></span><br><span class="line"><span class="string">- elemtype：channel 元素类型；</span></span><br><span class="line"><span class="string">- sendx：发送元素进入环形缓冲区的 index；</span></span><br><span class="line"><span class="string">- recvx：接收元素所处的环形缓冲区的 index；</span></span><br><span class="line"><span class="string">- recvq：因接收而陷入阻塞的协程队列；</span></span><br><span class="line"><span class="string">- sendq：因发送而陷入阻塞的协程队列；</span></span><br><span class="line"><span class="string">- waitq：阻塞的协程队列</span></span><br><span class="line"><span class="string">- first：队列头部</span></span><br><span class="line"><span class="string">- last：队列尾部</span></span><br><span class="line"><span class="string">- sudog：用于包装协程的节点</span></span><br><span class="line"><span class="string">- g：goroutine，协程；</span></span><br><span class="line"><span class="string">- next：队列中的下一个节点；</span></span><br><span class="line"><span class="string">- prev：队列中的前一个节点；</span></span><br><span class="line"><span class="string">- elem: 读取/写入 channel 的数据的容器;</span></span><br><span class="line"><span class="string">- isSelect：标识当前协程是否处在 select 多路复用的流程中；</span></span><br><span class="line"><span class="string">- c：标识与当前 sudog 交互的 chan.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 3.2 构造器函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在源码中通道的创建由 makechan 方法实现：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;&#125;</span><br></pre></td></tr></table></figure><p>然后还有两个包装方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname reflect_makechan reflect.makechan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line"><span class="keyword">return</span> makechan(t, size)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan64</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="type">int64</span>(<span class="type">int</span>(size)) != size &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> makechan(t, <span class="type">int</span>(size))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部都是调用的 makechan 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">elem := t.elem</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器检查 typesize 和 align</span></span><br><span class="line"><span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算存放数据元素的内存大小以及是否溢出</span></span><br><span class="line">mem, overflow := math.MulUintptr(elem.size, <span class="type">uintptr</span>(size))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c *hchan</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line">c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">c.buf = c.raceaddr()</span><br><span class="line"><span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>:</span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">c = <span class="built_in">new</span>(hchan)</span><br><span class="line">c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">c.elemsize = <span class="type">uint16</span>(elem.size)</span><br><span class="line">c.elemtype = elem</span><br><span class="line">c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line">lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体流程如下：</p><ul><li>判断申请内存空间大小是否越界，mem 大小为 element 类型大小与 element 个数相乘后得到，仅当无缓冲型 channel 时，因个数为 0 导致大小为 0；</li><li>根据类型，初始 channel，分为 无缓冲型、有缓冲元素为 struct 型、有缓冲元素为 pointer 型 channel;</li><li>倘若为无缓冲型，则仅申请一个大小为默认值 96 的空间；</li><li>如若有缓冲的 struct 型，则一次性分配好 96 + mem 大小的空间，并且调整 chan 的 buf 指向 mem 的起始位置；</li><li>倘若为有缓冲的 pointer 型，则分别申请 chan 和 buf 的空间，两者无需连续；</li><li>对 channel 的其余字段进行初始化，包括元素类型大小、元素类型、容量以及锁的初始化.</li></ul><h3 id="3-2-写流程"><a href="#3-2-写流程" class="headerlink" title="3.2 写流程"></a>3.2 写流程</h3><p>发送数据到channel时：</p><ul><li>先判断是否有等待接收数据的 groutine，如果有，直接将数据发给 groutine，唤醒 groutine，就不放入队列中了。省去了两次内存拷贝和加锁的开销</li><li>另外一种情况：队列如果满了，那就只能放到队列中等待，直到有数据被取走才能发送。<h4 id="3-2-1-调用链"><a href="#3-2-1-调用链" class="headerlink" title="3.2.1 调用链"></a>3.2.1 调用链</h4></li></ul><p>chan 的发送逻辑涉及到5个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendDirect</span><span class="params">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;…&#125;</span><br></pre></td></tr></table></figure><p>chansend1 方法是 go编译代码中<code>c &lt;- x</code>这种写法的入口点，即当我们编写代码<code>c &lt;- x</code>其实就是调用此方法。<br>这四个方法的调用关系：<code>chansend1 -&gt; chansend -&gt; send -&gt; sendDirect</code><br>具体发送逻辑在<code>chansend</code>这个方法里，然后真正使用的方法其实是对该方法的一层包装。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">chansend(c, elem, <span class="literal">true</span>, getcallerpc())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> chansend(c, elem, <span class="literal">false</span>, getcallerpc())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-chansend"><a href="#3-2-2-chansend" class="headerlink" title="3.2.2 chansend"></a>3.2.2 chansend</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 channel 是否为 nil</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !block &#123;<span class="comment">// 如果非阻塞，直接返回 false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 当向 nil channel 发送数据时，会调用 gopark</span></span><br><span class="line"><span class="comment">// 而 gopark 会将当前的 goroutine 休眠，并用过第一个参数的 unlockf 来回调唤醒</span></span><br><span class="line"><span class="comment">// 但此处传递的参数为 nil，因此向 channel 发送数据的 goroutine 和接收数据的 goroutine 都会阻塞，进而死锁</span></span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racereadpc(c.raceaddr(), callerpc, funcPC(chansend))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于不阻塞的 send，快速检测失败场景</span></span><br><span class="line"><span class="comment">// 如果 channel 未关闭且 channel 没有多余的缓冲空间。这可能是：</span></span><br><span class="line"><span class="comment">// 1. channel 是非缓冲型的，且等待接收队列里没有 goroutine</span></span><br><span class="line"><span class="comment">// 2. channel 是缓冲型的，但循环数组已经装满了元素</span></span><br><span class="line"><span class="comment">// 主要用于 select 语句中，涉及到指令重排队+可观测性</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; full(c) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加锁,避免竞争</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"><span class="comment">// 检查 channel 是否已关闭，不允许向关闭的 channel 发送数据</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>)) <span class="comment">// 直接panic</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从 recvq 队首取出一个接收者，如果存在接收者，就绕过环形队列（buf）直接把 ep 拷贝给 sg，并释放锁</span></span><br><span class="line">    <span class="comment">// 这就是前面提到的，官方做的一个优化，如果有goroutine在等待就直接把数据给该goroutine，没必要在写到buf，然后接收者又从buf中拷贝出来</span></span><br><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 到这里说明当前没有等待状态的接收者</span></span><br><span class="line"><span class="comment">// 如果环形队列还未满</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="comment">// 拿到 sendx 索引的位置</span></span><br><span class="line">qp := chanbuf(c, c.sendx)</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racenotify(c, c.sendx, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 直接把数据从 qp 拷贝到 qp，就是把数据拷贝到环形队列中</span></span><br><span class="line">typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        <span class="comment">// 维护 snedx 的值，因为是环形队列，所以到最大值时就重置为0</span></span><br><span class="line">c.sendx++</span><br><span class="line"><span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">c.sendx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//qcount即当前chan中的元素个数</span></span><br><span class="line">c.qcount++</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 到这里说明环形队列已经满了</span></span><br><span class="line"><span class="comment">// 如果还是要非阻塞的方式发送，就只能返回错误了</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 到这里说明缓存队列满了，然后调用法指定是阻塞方式进行发送</span></span><br><span class="line"><span class="comment">// channel 满了，发送方会被阻塞。接下来会构造一个 sudog</span></span><br><span class="line">gp := getg()<span class="comment">// 获取当前 goroutine</span></span><br><span class="line">mysg := acquireSudog()<span class="comment">// 从对象池获取 sudog</span></span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 把发送的数据(ep)、当前g(gp)、已经当前这个chan(c)都存到sudog中</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">    <span class="comment">// 保存当前 sudog，下面要用到做校验</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">     <span class="comment">// 把这个sudog存入sendq队列</span></span><br><span class="line">c.sendq.enqueue(mysg)</span><br><span class="line">atomic.Store8(&amp;gp.parkingOnChan, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 调用gopark，挂起当前的 g，将当前的 g 移出调度器的队列</span></span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 等到有接收者从chan中取值的时候，这个发送的g又会被重新调度，然后从这里开始继续执行</span></span><br><span class="line">KeepAlive(ep)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检验是否为当前的 sudog</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">gp.activeStackChans = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 这里sudog中的success表示的是当前这个通道上是否进行过通信</span></span><br><span class="line">    <span class="comment">// 为 true 则说明是真正的唤醒，chan上有活动（有数据写进来，或者有数据被读取出去）</span></span><br><span class="line">    <span class="comment">// 为 false 则说明是假的唤醒，即当前唤醒是否关闭chan导致的</span></span><br><span class="line">    <span class="comment">// 这里主要根据这个值判断chan是否被关闭了</span></span><br><span class="line">closed := !mysg.success</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 将 sudog 放回对象池</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">if</span> closed &#123;</span><br><span class="line">        <span class="comment">// 如果chan被关闭了也是直接panic</span></span><br><span class="line"><span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;chansend: spurious wakeup&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心逻辑</p><ul><li>如果recvq不为空，从recvq中取出一个等待接收数据的Groutine，直接将数据发送给该Groutine</li><li>如果recvq为空，才将数据放入buf中</li><li>如果buf已满，则将要发送的数据和当前的Groutine打包成Sudog对象放入sendq，并将groutine置为等待状态</li><li>等goroutine再次被调度时程序继续执行</li></ul><h4 id="3-2-3-send"><a href="#3-2-3-send" class="headerlink" title="3.2.3 send"></a>3.2.3 send</h4><p>然后追踪一下 send 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 忽略 race 检查..</span></span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 直接拷贝到接受者内存，使用写屏障</span></span><br><span class="line">sendDirect(c.elemtype, sg, ep)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g <span class="comment">// 取出sudog中记录的g，这里的g就是被阻塞接收者</span></span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg) <span class="comment">// 更新接收者g的param字段，在recv方法中会用到</span></span><br><span class="line">sg.success = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 最后把被阻塞的接收者g唤醒</span></span><br><span class="line">goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-4-sendDirect"><a href="#3-2-4-sendDirect" class="headerlink" title="3.2.4 sendDirect"></a>3.2.4 sendDirect</h4><p>继续看sendDirect 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendDirect</span><span class="params">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;</span><br><span class="line"><span class="comment">// src 在当前 goroutine 的栈上，dst 是另一个 goroutine 的栈</span></span><br><span class="line">    <span class="comment">// 直接进行内存&quot;搬迁&quot;</span></span><br><span class="line"><span class="comment">// 如果目标地址的栈发生了栈收缩，当我们读出了 sg.elem 后</span></span><br><span class="line"><span class="comment">// 就不能修改真正的 dst 位置的值了</span></span><br><span class="line"><span class="comment">// 因此需要在读和写之前加上一个屏障</span></span><br><span class="line">dst := sg.elem</span><br><span class="line">typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.size)</span><br><span class="line"> <span class="comment">// 拷贝内存</span></span><br><span class="line">memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到一个 goroutine 直接写另一个 goroutine 栈的操作，一般而言，不同 goroutine 的栈是各自独有的。而这也违反了 GC 的一些假设。为了不出问题，写的过程中增加了写屏障，保证正确地完成写操作。这样做的好处是减少了一次内存 copy：不用先拷贝到 channel 的 buf，直接由发送者到接收者。</p><h3 id="3-3-读流程"><a href="#3-3-读流程" class="headerlink" title="3.3 读流程"></a>3.3 读流程</h3><p>从channel读取数据的流程和发送的类似，基本是发送操作的逆操作。<br>这里同样存在和send一样的优化：从channel读取数据时，不是直接去环形队列中去数据，而是先判断是否有等待发送数据的groutine。如果有，直接将groutine出队列，取出数据返回，并唤醒groutine。如果没有等待发送数据的groutine，再从环形队列中取数据。</p><h4 id="3-3-1-调用链"><a href="#3-3-1-调用链" class="headerlink" title="3.3.1 调用链"></a>3.3.1 调用链</h4><p>chan的接收涉及到7个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_chanrecv</span><span class="params">(c *hchan, nb <span class="type">bool</span>, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>, received <span class="type">bool</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span></span> (selected, received <span class="type">bool</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;…&#125;，</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvDirect</span><span class="params">(t *_type, sg *sudog, dst unsafe.Pointer)</span></span> &#123;…&#125;</span><br></pre></td></tr></table></figure><p>按照发送时的套路可知，只有 chanrecv 是具体逻辑，上面几个都是包装方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname reflect_chanrecv reflect.chanrecv</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_chanrecv</span><span class="params">(c *hchan, nb <span class="type">bool</span>, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>, received <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> chanrecv(c, elem, !nb)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) &#123;</span><br><span class="line">_, received = chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收操作有两种写法，一种带 “ok”，反应 channel 是否关闭；</p><p>一种不带 “ok”，这种写法，当接收到相应类型的零值时无法知道是真实的发送者发送过来的值，还是 channel 被关闭后，返回给接收者的默认类型的零值。</p><p>两种写法，都有各自的应用场景。</p><p>经过编译器的处理后，这两种写法最后对应源码里的就是不带<code>ok</code>的<code>chanrecv1</code>和带<code>ok</code>的<code>chanrecv2</code>这两个函数。</p><h4 id="3-3-2-chanrecv"><a href="#3-3-2-chanrecv" class="headerlink" title="3.3.2 chanrecv"></a>3.3.2 chanrecv</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chanrecv 函数接收 channel c 的元素并将其写入 ep 所指向的内存地址。</span></span><br><span class="line"><span class="comment">// 如果 ep 是 nil，说明忽略了接收值。比如 &lt;-ch 这样，没有接收取到的值</span></span><br><span class="line"><span class="comment">// 如果 block == false，即非阻塞型接收，在没有数据可接收的情况下，返回 (false, false)</span></span><br><span class="line"><span class="comment">// 否则，如果 c 处于关闭状态，将 ep 指向的地址清零，返回 (true, false)</span></span><br><span class="line"><span class="comment">// 否则，用返回值填充 ep 指向的内存地址。返回 (true, true)</span></span><br><span class="line"><span class="comment">// 如果 ep 非空，则应该指向堆或者函数调用者的栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="comment">// 如果是一个 nil 的 channel</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不阻塞，直接返回 (false, false)</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 否则，接收一个 nil 的 channel，调用gopark将goroutine 挂起</span></span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>) <span class="comment">// 被挂起之后不会执行到这一句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这块主要用在 select 语句中，先大概了解下，比较难懂。。。</span></span><br><span class="line"><span class="comment">// 快速路径: 在不需要锁的情况下检查失败的非阻塞操作</span></span><br><span class="line"><span class="comment">// 注意到 channel 不能由已关闭转换为未关闭，则失败的条件是：</span></span><br><span class="line"><span class="comment">// 1. channel 是非缓冲型的，recvq 队列为空</span></span><br><span class="line"><span class="comment">// 2. channel 是缓冲型的，buf 为空</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; empty(c) &#123;</span><br><span class="line"><span class="comment">// 此处的 c.closed 必须在条件判断之后进行验证，</span></span><br><span class="line">        <span class="comment">// 因为指令重排后，如果先判断 c.closed，得出 channel 未关闭，无法判断失败条件中channel 是已关闭还是未关闭（从而需要 atomic 操作）</span></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再次检查 channel 是否为空</span></span><br><span class="line"><span class="keyword">if</span> empty(c) &#123;</span><br><span class="line"><span class="comment">// 接收者不为 nil 时返回该类型的零值</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// typedmemclr 逻辑是根据类型清理相应地址的内存</span></span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 返回（true,fasle）</span></span><br><span class="line">            <span class="comment">// 返回值1--true：表示被 select case 选中，</span></span><br><span class="line">            <span class="comment">// 返回值2--fasle 表示是否正常收到数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加锁，保证并发安全</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"><span class="comment">// channel 已关闭，并且循环数组 buf 里没有元素</span></span><br><span class="line"><span class="comment">// 这里可以处理非缓冲型关闭 和 缓冲型关闭但 buf 无元素的情况</span></span><br><span class="line"><span class="comment">// 也就是说即使是关闭状态，但在缓冲型的 channel，</span></span><br><span class="line"><span class="comment">// buf 里有元素的情况下还能接收到元素</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待发送队列里有 goroutine 存在，说明 buf 是满的</span></span><br><span class="line"><span class="comment">// 这有可能是：</span></span><br><span class="line"><span class="comment">// 1. 非缓冲型的 channel</span></span><br><span class="line"><span class="comment">// 2. 缓冲型的 channel，但 buf 满了</span></span><br><span class="line"><span class="comment">// 针对 1，直接进行内存拷贝（从 sender goroutine -&gt; receiver goroutine）</span></span><br><span class="line"><span class="comment">// 针对 2，接收到循环数组头部的元素，并将发送者的元素放到循环数组尾部</span></span><br><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// chan的buf 里有元素，可以正常接收</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 直接从循环数组里找到要接收的元素</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line">        <span class="comment">// ep != nil表示代码里，没有忽略要接收的值</span></span><br><span class="line">        <span class="comment">// 即接收的代码不是 &quot;&lt;- ch&quot;，而是 &quot;val &lt;- ch&quot;这种，ep 指向 val</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 清理掉循环数组里相应位置的值</span></span><br><span class="line">typedmemclr(c.elemtype, qp)</span><br><span class="line">        <span class="comment">// 维护接收游标</span></span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// buf 数组里的元素个数减 1</span></span><br><span class="line">c.qcount--</span><br><span class="line">        <span class="comment">// 处理完成，解锁返回</span></span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 到这里说明chan的buf里没有数据了，如果是非阻塞接收就直接返回了</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来就是要被阻塞的情况了</span></span><br><span class="line">    <span class="comment">// 和发送类似的，构造一个 sudog</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 这里需要注意一下，ep就是我们用来接收值得对象</span></span><br><span class="line">    <span class="comment">// 这里把ep直接存到sudog.elem字段上</span></span><br><span class="line">mysg.elem = ep </span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg <span class="comment">// 这个waiting同样是用来唤醒后做校验的</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 加入到chan的recvq队列里</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line">atomic.Store8(&amp;gp.parkingOnChan, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 将当前 goroutine 挂起</span></span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒后，继续往下执行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同样是进行数据校验</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">gp.activeStackChans = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 又是mysg.success，如果chan活动过就是true，否则是false</span></span><br><span class="line">success := mysg.success</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)<span class="comment">// 将 sudog 放回对象池</span></span><br><span class="line">    <span class="comment">// 到这里如果goroutine被正常唤醒肯定是可以取到数据的</span></span><br><span class="line">    <span class="comment">// 因为recvq的数据是由发送的时候直接copy过来了</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, success</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-3-3-recv"><a href="#3-3-3-recv" class="headerlink" title="3.3.3 recv"></a>3.3.3 recv</h4><p>继续追踪一下 recv 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 非缓冲型的 channel</span></span><br><span class="line"><span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 并且需要接收值</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 直接进行内存拷贝</span></span><br><span class="line">recvDirect(c.elemtype, sg, ep)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 需要注意：进入recv方法说明sendq队列里是有值的</span></span><br><span class="line"><span class="comment">// 那么对缓冲型的 channel来说，sendq有值就意味着buf满了</span></span><br><span class="line">        <span class="comment">// 也就是 recvx和sendx重合了都</span></span><br><span class="line">        <span class="comment">// 这里要做的就是先从buf中读一个数据出来，然后再把发送者发送的数据写入buf</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"><span class="comment">// 将接收游标处的数据拷贝给接收者</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从发送者把数据写入 recvx</span></span><br><span class="line">typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">        <span class="comment">// 然后修改 recvx和sendx 的位置</span></span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">gp := sg.g</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 最后唤醒发送的 goroutine</span></span><br><span class="line">goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-4-recvDirect"><a href="#3-3-4-recvDirect" class="headerlink" title="3.3.4 recvDirect"></a>3.3.4 recvDirect</h4><p>再看一下 recvDirect：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvDirect</span><span class="params">(t *_type, sg *sudog, dst unsafe.Pointer)</span></span> &#123;</span><br><span class="line"><span class="comment">// 如果是非缓冲型的，就直接从发送者的栈拷贝到接收者的栈。</span></span><br><span class="line">    <span class="comment">// 和sendDirect一样的需要加内存屏障</span></span><br><span class="line">src := sg.elem</span><br><span class="line">typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.size)</span><br><span class="line">memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-5-小结"><a href="#3-3-5-小结" class="headerlink" title="3.3.5 小结"></a>3.3.5 小结</h4><ul><li>不管是接收还是发送只要被阻塞了，加入到了 sendq 或者 recvq 之后，那么后续的发送或者接收都是由对方进行处理了。</li><li>比如接收被阻塞了，当前 g 构成一个 sudog 然后加入到 recvq ，接着调用了 gopark 就已经阻塞,只能等到有发送者来的时候直接从 recvq 里把这个 sudog 取出来，并且直接把要他发送的值拷贝到这个 sudog.elem 字段上，也就是调用chan接收方法是传进来的哪个值.</li><li>最后发送方再调用 goready 把这个 g 给唤醒，这样再把剩下的逻辑走完，这个被阻塞了一会的接收者就可以拿着数据返回了。</li></ul><p>核心逻辑：</p><ul><li>如果有等待发送数据的 groutine，从 sendq 中取出一个等待发送数据的 groutine，取出数据</li><li>如果没有等待的 groutine，且环形队列中有数据，从队列中取出数据</li><li>如果没有等待的 groutine，且环形队列中也没有数据，则阻塞该 Groutine，并将 groutine 打包为 sudog 加入到 recevq 等待队列中</li></ul><h3 id="3-4-关闭"><a href="#3-4-关闭" class="headerlink" title="3.4 关闭"></a>3.4 关闭</h3><h4 id="3-4-1-调用链"><a href="#3-4-1-调用链" class="headerlink" title="3.4.1 调用链"></a>3.4.1 调用链</h4><p>close 就比较简单了，相关方法就两个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname reflect_chanclose reflect.chanclose</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_chanclose</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">closechan(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>其中一个还是包装方法，真正逻辑就在 clsoechan 里。</p><blockquote><p>每个逻辑都有一个 reflect_xxx 的方法，根据名字猜测是反射的时候用的。</p></blockquote><h4 id="3-4-2-closechan"><a href="#3-4-2-closechan" class="headerlink" title="3.4.2 closechan"></a>3.4.2 closechan</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 关闭一个nil的chan直接panic</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同样是先加锁</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// 判断一下是否被关闭过了，关闭一个已经关闭的chan也是直接panic</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改closed标记为，表示chan已经被关闭了</span></span><br><span class="line">c.closed = <span class="number">1</span></span><br><span class="line"><span class="comment">// gList 是通过 g.schedlink 链接 G 的列表，一个 G 只能是一次在一个 gQueue 或 gList 上</span></span><br><span class="line"><span class="comment">// gList 模拟的是栈操作（FILO）</span></span><br><span class="line"><span class="comment">// gQueue 模拟的是队列操作（FIFO）</span></span><br><span class="line"><span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放所有的接收者</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.recvq.dequeue()</span><br><span class="line">        <span class="comment">// sg == nil，表示接收队列已为空，跳出循环</span></span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 如果 elem 不为空说明未忽略接收值，赋值为该类型的零值</span></span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放所有的发送者</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.sendq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环读取 glist 里面的数据，挨个唤醒</span></span><br><span class="line"><span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">gp := glist.pop()</span><br><span class="line">gp.schedlink = <span class="number">0</span></span><br><span class="line">goready(gp, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心流程：</p><ul><li>设置关闭状态</li><li>唤醒所有等待读取chanel的协程</li><li>所有等待写入channel的协程，抛出异常</li></ul><h4 id="3-4-3-优雅关闭"><a href="#3-4-3-优雅关闭" class="headerlink" title="3.4.3 优雅关闭"></a>3.4.3 优雅关闭</h4><ul><li>只在发送端关闭 channel。（防止关闭后继续发送）</li><li>存在多个发送者时不要关闭发送者 channel，而是使用专门的 stop channel。 sync.Once，来保证关闭channel的操作只执行一次</li><li>作为函数参数的channel最好带方向</li></ul><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h2><h3 id="4-1-存储实现"><a href="#4-1-存储实现" class="headerlink" title="4.1 存储实现"></a>4.1 存储实现</h3><p>chan 内部使用一个环形队列实现存储，使用 sendx或recvx进行发送或读取。</p><h3 id="4-2-并发安全"><a href="#4-2-并发安全" class="headerlink" title="4.2 并发安全"></a>4.2 并发安全</h3><p>使用 mutex 保证并发安全。</p><h3 id="4-3-调度"><a href="#4-3-调度" class="headerlink" title="4.3 调度"></a>4.3 调度</h3><p>使用 sendq 和 recvq来暂存由于发送或接收而被阻塞的goroutine。<br>send/recv的时候都会判断recvq/sendq是否有goroutine正在等待，有则优先处理。</p><h4 id="4-3-1-发送"><a href="#4-3-1-发送" class="headerlink" title="4.3.1 发送"></a>4.3.1 发送</h4><p><strong>发送</strong>的时候发现recvq有goroutine正在等待，说明此时chan的buf是空的，或者chan是个非缓存chan，根本没有buf。<br>对于发送来说，不管是buf为空还是chan没有buf都是一样的处理逻辑。<br>此时会直接从recvq中取出第一个g，然后把本次要发送的数据直接写给这个接收者g，并调用goready把这个g唤醒。</p><h4 id="4-3-2-接收"><a href="#4-3-2-接收" class="headerlink" title="4.3.2 接收"></a>4.3.2 接收</h4><p>如果接收的时候发现sendq有goroutine正在等待，说明buf满了，或者chan是个非缓存chan，根本没有buf。<br>对于接收来说buf满了或者chan没有buf二者的处理逻辑就不太一样了。</p><blockquote><p>因为需要保证顺序,buf满了就不能直接去读sender的数据了，只能从buf中去。</p></blockquote><p>如果是buf满了：那么会先从buf中读一个值出来(腾一个位置出来)，然后把sender发送的值写入buf，并唤醒这个sender g。<br>如果是没有buf的无缓存chan：那就直接把sender要发送的数据取出来，作为本次取到的数据，然后唤醒sender g。</p><h3 id="4-4-读写特点"><a href="#4-4-读写特点" class="headerlink" title="4.4 读写特点"></a>4.4 读写特点</h3><p>空读写阻塞，写关闭异常，读关闭空零</p><ul><li>读写值 nil 管道会永久阻塞</li><li>关闭的管道读数据仍然可以读数据</li><li>往关闭的管道写数据会 panic</li><li>关闭为 nil 的管道 panic</li><li>关闭已经关闭的管道 panic<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2></li></ul><p><a href="https://about.sourcegraph.com/go/understanding-channels-kavya-joshi/">understanding-channels-kavya-joshi</a><br><a href="https://juejin.cn/post/6875325172249788429">图解Golang channel源码</a><br><a href="https://github.com/talkgo/night/issues/450">Go夜读-第 56 期 channel &amp; select 源码分析</a><br><a href="https://maratrix.cn/post/2020/08/25/go-channel-source-read/">Go源码阅读 | channel 设计与实现</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Context</title>
      <link href="/2022/07/10/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Context/"/>
      <url>/2022/07/10/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Context/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Context 主要用于在异步场景中用于实现并发协调以及对 goroutine 的生命周期控制. 除此之外，context 还兼有一定的数据存储能力.</p></blockquote><span id="more"></span><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h2><h3 id="1-1-context-Context"><a href="#1-1-context-Context" class="headerlink" title="1.1 context.Context"></a>1.1 context.Context</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Context 包提供暴露 Context 接口; </li><li>可以在多个 Goroutine 共享数据，实现多 Goroutine 管理机制; </li><li>Context 是协程安全的；</li></ul><p>Context 接口定义了四个核心 api :</p><ul><li>Deadline 方法返回第一个参数是设置的截止时间，到时间Context会自动发起取消请求； 第二个参数是bool值，为false时表示没有设置截止时间，如果要取消需要调用取消函数;</li><li>Done 方法返回一个只读 Channel，类型为 struct{}, 这个 Channel 会在当前工作完成或者上下文被取消之后关闭， 多次调用 Done 方法会返回同一个 Channel；</li><li>Err 方法会返回当前 Context 结束的原因，它只会在 Done 返回的 Channel 被关闭时才会返回非空的值；<ul><li>如果当前 Context 被取消就会返回 Canceled 错误；</li><li>如果当前 Context 超时就会返回 DeadlineExceeded 错误；</li></ul></li><li>Value 方法会从 Context 中返回键对应的值，对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果，这个功能可以用来传递请求特定的数据；获取Value值时是线程安全的； key 必须为非空，且可比较;</li></ul><h3 id="1-2-标准-error"><a href="#1-2-标准-error" class="headerlink" title="1.2 标准 error"></a>1.2 标准 error</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Canceled = errors.New(<span class="string">&quot;context canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DeadlineExceeded <span class="type">error</span> = deadlineExceededError&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> deadlineExceededError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Error() <span class="type">string</span>   &#123; <span class="keyword">return</span> <span class="string">&quot;context deadline exceeded&quot;</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Timeout() <span class="type">bool</span>   &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Temporary() <span class="type">bool</span> &#123; <span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>Canceled：context 被 cancel 时会报此错误；</li><li>DeadlineExceeded：context 超时时会报此错误.</li></ul><h2 id="2-emptyCtx"><a href="#2-emptyCtx" class="headerlink" title="2 emptyCtx"></a>2 emptyCtx</h2><h3 id="2-1-类实现"><a href="#2-1-类实现" class="headerlink" title="2.1 类实现"></a>2.1 类实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>emptyCtx 是一个不可取消，没有设置截止时间，没有携带任何值的Context;</li><li>emptyCtx 是一个空的 context，本质上类型为一个整型；</li><li>Deadline 方法会返回一个公元元年时间以及 false 的 flag，标识当前 context 不存在过期时间；</li><li>Done 方法返回一个 nil 值，用户无论往 nil 中写入或者读取数据，均会陷入阻塞；</li><li>Err 方法返回的错误永远为 nil；</li><li>Value 方法返回的 value 同样永远为 nil.</li></ul><h3 id="2-2-context-Background-amp-context-TODO"><a href="#2-2-context-Background-amp-context-TODO" class="headerlink" title="2.2 context.Background() &amp; context.TODO()"></a>2.2 context.Background() &amp; context.TODO()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">    todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>内置2个Context实现,通常用来做顶层的parent context; TODO一般在不知道使用什么Context时使用；</li><li>todo 和 background 两者本质上只有名字区别，在按 string 输出的时候会有区别; </li><li>context.Background() 和 context.TODO() 方法返回的均是 emptyCtx 类型的一个实例</li></ul><h2 id="3-cancelCtx"><a href="#3-cancelCtx" class="headerlink" title="3  cancelCtx"></a>3  cancelCtx</h2><h3 id="3-1-cancelCtx-数据结构"><a href="#3-1-cancelCtx-数据结构" class="headerlink" title="3.1 cancelCtx 数据结构"></a>3.1 cancelCtx 数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line"></span><br><span class="line">    mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">    done     atomic.Value          <span class="comment">// of chan struct&#123;&#125;, created lazily, closed by first cancel call</span></span><br><span class="line">    children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">    err      <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">    cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• embed 了一个 context 作为其父 context. cancelCtx 必然为某个 context 的子 context；<br>• 内置了一把锁，用以协调并发场景下的资源获取；<br>• done：实际类型为 chan struct{}，即用以反映 cancelCtx 生命周期的通道；<br>• children：一个 set，指向 cancelCtx 的所有子 context；<br>• err：记录了当前 cancelCtx 的错误. 必然为某个 context 的子 context；</p><h3 id="3-2-Deadline-方法"><a href="#3-2-Deadline-方法" class="headerlink" title="3.2 Deadline 方法"></a>3.2 Deadline 方法</h3><p>cancelCtx 未实现该方法，仅是 embed 了一个带有 Deadline 方法的 Context interface，因此直接调用会报错.</p><h3 id="3-3-Done-方法"><a href="#3-3-Done-方法" class="headerlink" title="3.3 Done 方法"></a>3.3 Done 方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">    d := c.done.Load()</span><br><span class="line">    <span class="keyword">if</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    d = c.done.Load()</span><br><span class="line">    <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">        d = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        c.done.Store(d)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 基于 atomic 包，读取 cancelCtx 中的 chan；倘若已存在，则直接返回；<br>• 加锁后，在此检查 chan 是否存在，若存在则返回；（double check）<br>• 初始化 chan 存储到 aotmic.Value 当中，并返回.（懒加载机制）</p><h3 id="3-4-Err-方法"><a href="#3-4-Err-方法" class="headerlink" title="3.4 Err 方法"></a>3.4 Err 方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    err := c.err</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 加锁；<br>• 读取 cancelCtx.err；<br>• 解锁；<br>• 返回结果.</p><h3 id="3-5-Value-方法"><a href="#3-5-Value-方法" class="headerlink" title="3.5  Value 方法"></a>3.5  Value 方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">    <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 倘若 key 特定值 &amp;cancelCtxKey，则返回 cancelCtx 自身的指针；<br>• 否则遵循 valueCtx 的思路取值返回</p><h3 id="3-6-context-WithCancel"><a href="#3-6-context-WithCancel" class="headerlink" title="3.6 context.WithCancel()"></a>3.6 context.WithCancel()</h3><h4 id="3-6-1-context-WithCancel"><a href="#3-6-1-context-WithCancel" class="headerlink" title="3.6.1 context.WithCancel()"></a>3.6.1 context.WithCancel()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c := newCancelCtx(parent)</span><br><span class="line">    propagateCancel(parent, &amp;c)</span><br><span class="line">    <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 校验父 context 非空；<br>• 注入父 context 构造好一个新的 cancelCtx；<br>• 在 propagateCancel 方法内启动一个守护协程，以保证父 context 终止时，该 cancelCtx 也会被终止；<br>• 将 cancelCtx 返回，连带返回一个用以终止该 cancelCtx 的闭包函数.</p><h4 id="3-6-2-newCancelCtx"><a href="#3-6-2-newCancelCtx" class="headerlink" title="3.6.2 newCancelCtx"></a>3.6.2 newCancelCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span></span> cancelCtx &#123;</span><br><span class="line">    <span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 注入父 context 后，返回一个新的 cancelCtx.</p><h4 id="3-6-3-propagateCancel"><a href="#3-6-3-propagateCancel" class="headerlink" title="3.6.3 propagateCancel"></a>3.6.3 propagateCancel</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">    done := parent.Done()</span><br><span class="line">    <span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        <span class="comment">// parent is already canceled</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">        p.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// parent has already been canceled</span></span><br><span class="line">            child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">                p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.mu.Unlock()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        atomic.AddInt32(&amp;goroutines, +<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">                child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">            <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>propagateCancel 方法传递父子 context 之间的 cancel 事件：<br>• 倘若 parent 是不会被 cancel 的类型（如 emptyCtx），则直接返回；<br>• 倘若 parent 已经被 cancel，则直接终止子 context，并以 parent 的 err 作为子 context 的 err；<br>• 假如 parent 是 cancelCtx 的类型，则加锁，并将子 context 添加到 parent 的 children map 当中；<br>• 假如 parent 不是 cancelCtx 类型，但又存在 cancel 的能力（比如用户自定义实现的 context），则启动一个协程，通过多路复用的方式监控 parent 状态，倘若其终止，则同时终止子 context，并透传 parent 的 err.</p><p><strong>校验 parent 是否为 cancelCtx 的类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span></span> (*cancelCtx, <span class="type">bool</span>) &#123;</span><br><span class="line">    done := parent.Done()</span><br><span class="line">    <span class="keyword">if</span> done == closedchan || done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    pdone, _ := p.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> pdone != done &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 倘若 parent 的 channel 已关闭或者是不会被 cancel 的类型，则返回 false；<br>• 倘若以特定的 cancelCtxKey 从 parent 中取值，取得的 value 是 parent 本身，则返回 true. （基于 cancelCtxKey 为 key 取值时返回 cancelCtx 自身，是 cancelCtx 特有的协议）.</p><h2 id="4-timerCtx"><a href="#4-timerCtx" class="headerlink" title="4 timerCtx"></a>4 timerCtx</h2><h3 id="4-1-类实现"><a href="#4-1-类实现" class="headerlink" title="4.1 类实现"></a>4.1 类实现</h3><ul><li>timerCtx 内部不仅通过嵌入 cancelCtx 的方式承了相关的变量和方法，还通过持有的定时器 <code>timer</code> 和截止时间 <code>deadline</code> 实现了定时取消的功能：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">cancelCtx</span><br><span class="line">timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-timerCtx-Deadline"><a href="#4-2-timerCtx-Deadline" class="headerlink" title="4.2 timerCtx.Deadline()"></a>4.2 timerCtx.Deadline()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.deadline, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>context.Context interface 下的 Deadline api 仅在 timerCtx 中有效，由于展示其过期时间.<h3 id="4-3-timerCtx-cancel"><a href="#4-3-timerCtx-cancel" class="headerlink" title="4.3 timerCtx.cancel"></a>4.3 timerCtx.cancel</h3></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line"><span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">removeChild(c.cancelCtx.Context, c)</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">c.timer.Stop()</span><br><span class="line">c.timer = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>timerCtx.cancel 不仅调用了 cancelCtx.cancel 方法，还会停止持有的定时器减少不必要的资源浪费。</li><li>实际上对外提供了 WithTimeout 方法只是 WithDeadline 的封装</li></ul><h3 id="4-4-context-WithTimeout-amp-context-WithDeadline"><a href="#4-4-context-WithTimeout-amp-context-WithDeadline" class="headerlink" title="4.4 context.WithTimeout &amp; context.WithDeadline"></a>4.4 context.WithTimeout &amp; context.WithDeadline</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line"><span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line"><span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line"><span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">&#125;</span><br><span class="line">c := &amp;timerCtx&#123;</span><br><span class="line">cancelCtx: newCancelCtx(parent),</span><br><span class="line">deadline:  d,</span><br><span class="line">&#125;</span><br><span class="line">propagateCancel(parent, c)</span><br><span class="line">dur := time.Until(d)</span><br><span class="line"><span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line"><span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 校验 parent context 非空；<br>• 校验 parent 的过期时间是否早于自己，若是，则构造一个 cancelCtx 返回即可；<br>• 构造出一个新的 timerCtx；<br>• 启动守护方法，同步 parent 的 cancel 事件到子 context；<br>• 判断过期时间是否已到，若是，直接 cancel timerCtx，并返回 DeadlineExceeded 的错误；<br>• 加锁；<br>• 启动 time.Timer，设定一个延时时间，即达到过期时间后会终止该 timerCtx，并返回 DeadlineExceeded 的错误；<br>• 解锁；<br>• 返回 timerCtx，已经一个封装了 cancel 逻辑的闭包 cancel 函数.</p><h2 id="5-valueCtx"><a href="#5-valueCtx" class="headerlink" title="5 valueCtx"></a>5 valueCtx</h2><h3 id="5-1-类实现"><a href="#5-1-类实现" class="headerlink" title="5.1 类实现"></a>5.1 类实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context</span><br><span class="line">key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• valueCtx 同样继承了一个 parent context；<br>• 一个 valueCtx 中仅有一组 kv 对.</p><h3 id="5-2-valueCtx-Value"><a href="#5-2-valueCtx-Value" class="headerlink" title="5.2 valueCtx.Value()"></a>5.2 valueCtx.Value()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">    <span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">        <span class="keyword">return</span> c.val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 假如当前 valueCtx 的 key 等于用户传入的 key，则直接返回其 value；<br>• 假如不等，则从 parent context 中依次向上寻找.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(c Context, key any)</span></span> any &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> ctx := c.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> *valueCtx:</span><br><span class="line">            <span class="keyword">if</span> key == ctx.key &#123;</span><br><span class="line">                <span class="keyword">return</span> ctx.val</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctx.Context</span><br><span class="line">        <span class="keyword">case</span> *cancelCtx:</span><br><span class="line">            <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">                <span class="keyword">return</span> c</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctx.Context</span><br><span class="line">        <span class="keyword">case</span> *timerCtx:</span><br><span class="line">            <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">                <span class="keyword">return</span> &amp;ctx.cancelCtx</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctx.Context</span><br><span class="line">        <span class="keyword">case</span> *emptyCtx:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> c.Value(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动一个 for 循环，由下而上，由子及父，依次对 key 进行匹配；</li><li>其中 cancelCtx、timerCtx、emptyCtx 类型会有特殊的处理方式；</li><li>找到匹配的 key，则将该组 value 进行返回.</li><li>最终找到根节点（一般是 emptyCtx），直接返回一个 nil。所以用 Value 方法的时候要判断结果是否为 nil。</li></ul><h3 id="5-3-valueCtx-用法小结"><a href="#5-3-valueCtx-用法小结" class="headerlink" title="5.3 valueCtx 用法小结"></a>5.3 valueCtx 用法小结</h3><p>valueCtx 不适合视为存储介质，存放大量的 kv 数据</p><ul><li>一个 valueCtx 实例只能存一个 kv 对，因此 n 个 kv 对会嵌套 n 个 valueCtx，造成空间浪费；</li><li>基于 k 寻找 v 的过程是线性的，时间复杂度 O(N)；</li><li>不支持基于 k 的去重，相同 k 可能重复存在，并基于起点的不同，返回不同的 v. 由此得知，valueContext 的定位类似于请求头，只适合存放少量作用域较大的全局 meta 数据.</li></ul><h3 id="5-4-context-WithValue"><a href="#5-4-context-WithValue" class="headerlink" title="5.4 context.WithValue()"></a>5.4 context.WithValue()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val any)</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>parent context 为空，panic；</li><li>key 为空 panic；</li><li>key 的类型不可比较，panic；</li><li>包括 parent context 以及 kv对，返回一个新的 valueCtx.</li></ul><h2 id="6-使用原则"><a href="#6-使用原则" class="headerlink" title="6 使用原则"></a>6 使用原则</h2><ol><li>不要把 Context 放在结构体中，要以参数的方式传递</li><li>以 Context 作为参数的函数方法，应该把 Context 作为第一个参数，放在第一位。</li><li>给一个函数方法传递 Context 的时候，不要传递 nil，如果不知道传递什么，就使用 context.TODO</li><li>Context 的 Value 相关方法应该传递必须的数据，不要什么数据都使用这个传递</li><li>Context 是线程安全的，可以放心的在多个 goroutine 中传递</li><li>在子 Context 被传递到的 goroutine 中，应该对该子 Context 的 Done（channel）进行监控</li></ol><h2 id="7-Context-Demo"><a href="#7-Context-Demo" class="headerlink" title="7 Context Demo"></a>7 Context Demo</h2><h3 id="7-1-Context控制多个goroutine"><a href="#7-1-Context控制多个goroutine" class="headerlink" title="7.1 Context控制多个goroutine"></a>7.1 Context控制多个goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    valueCtx1 := context.WithValue(ctx, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;goroutine 1&quot;</span>)</span><br><span class="line">    valueCtx2 := context.WithValue(ctx, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;goroutine 2&quot;</span>)</span><br><span class="line">    valueCtx3 := context.WithValue(ctx, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;goroutine 3&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> watch(valueCtx1)</span><br><span class="line">    <span class="keyword">go</span> watch(valueCtx2)</span><br><span class="line">    <span class="keyword">go</span> watch(valueCtx3)</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;cancel &quot;</span>, ctx.String())</span><br><span class="line">    cancel()</span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(ctx.String() ,<span class="string">&quot; done&quot;</span>, ctx.Err())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(ctx.Value(<span class="string">&quot;key&quot;</span>), <span class="string">&quot;wait...&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-Context-http请求超时"><a href="#7-2-Context-http请求超时" class="headerlink" title="7.2 Context http请求超时"></a>7.2 Context http请求超时</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个超时时间为100毫秒的上下文</span></span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    ctx, _ = context.WithTimeout(ctx, <span class="number">100</span>*time.Millisecond)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个访问Google主页的请求</span></span><br><span class="line">    req, _ := http.NewRequest(http.MethodGet, <span class="string">&quot;http://google.com&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 将超时上下文关联到创建的请求上</span></span><br><span class="line">    req = req.WithContext(ctx)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个HTTP客户端并执行请求</span></span><br><span class="line">    client := &amp;http.Client&#123;&#125;</span><br><span class="line">    res, err := client.Do(req)</span><br><span class="line">    <span class="comment">// 如果请求失败了，记录到STDOUT</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Request failed:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求成功后打印状态码</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Response received, status code:&quot;</span>, res.StatusCode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-Context-http服务器"><a href="#7-3-Context-http服务器" class="headerlink" title="7.3 Context http服务器"></a>7.3 Context http服务器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个监听8000端口的服务器</span></span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    ctx := r.Context()</span><br><span class="line">    <span class="comment">// 输出到STDOUT展示处理已经开始</span></span><br><span class="line">    fmt.Fprint(os.Stdout, <span class="string">&quot;processing request\n&quot;</span>)</span><br><span class="line">    <span class="comment">// 通过select监听多个channel</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">        <span class="comment">// 如果两秒后接受到了一个消息后，意味请求已经处理完成</span></span><br><span class="line">        <span class="comment">// 我们写入&quot;request processed&quot;作为响应</span></span><br><span class="line">        w.Write([]<span class="type">byte</span>(<span class="string">&quot;request processed&quot;</span>))</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        <span class="comment">// 如果处理完成前取消了，在STDERR中记录请求被取消的消息</span></span><br><span class="line">        fmt.Fprint(os.Stderr, <span class="string">&quot;request cancelled\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-Context-超时控制多个goroutine"><a href="#7-4-Context-超时控制多个goroutine" class="headerlink" title="7.4 Context 超时控制多个goroutine"></a>7.4 Context 超时控制多个goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ctx context.Context, wg *sync.WaitGroup)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;Timeout &quot;</span>, ctx.Err())</span><br><span class="line">            <span class="keyword">return</span> ctx.Err()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">100</span>*time.Millisecond)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> worker(ctx, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    cancel()</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-Context-取消控制多个goroutine"><a href="#7-5-Context-取消控制多个goroutine" class="headerlink" title="7.5 Context 取消控制多个goroutine"></a>7.5 Context 取消控制多个goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work1</span><span class="params">(ctx context.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 假设这个操作会因为某种原因失败</span></span><br><span class="line">    <span class="comment">// 使用time.Sleep来模拟一个资源密集型操作</span></span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work2</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">500</span> * time.Millisecond):</span><br><span class="line">        fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(<span class="string">&quot;halted work2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    <span class="comment">// cancel context</span></span><br><span class="line">    ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">    <span class="comment">// 在不同的goroutine中运行work2</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        work2(ctx)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        work2(ctx)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    err := work1(ctx)</span><br><span class="line">    <span class="comment">// 如果这个操作返回错误，取消所有使用相同Context的操作</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//发出取消事件</span></span><br><span class="line">        cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-6-Context-控制后台goroutine-生成素数"><a href="#7-6-Context-控制后台goroutine-生成素数" class="headerlink" title="7.6 Context 控制后台goroutine 生成素数"></a>7.6 Context 控制后台goroutine 生成素数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回生成自然数序列的管道: 2, 3, 4, ...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateNatural</span><span class="params">(ctx context.Context)</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">2</span>; ; i++ &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 结束生成自然数</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道过滤器: 删除能被素数整除的数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrimeFilter</span><span class="params">(ctx context.Context, in &lt;-<span class="keyword">chan</span> <span class="type">int</span>, prime <span class="type">int</span>)</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> i := &lt;-in; i%prime != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 结束过滤器</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> out &lt;- i:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通过 Context 控制后台Goroutine状态</span></span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">    ch := GenerateNatural(ctx) <span class="comment">// 自然数序列: 2, 3, 4, ...</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        prime := &lt;-ch <span class="comment">// 新出现的素数</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v: %v\n&quot;</span>, i+<span class="number">1</span>, prime)</span><br><span class="line">        ch = PrimeFilter(ctx, ch, prime) <span class="comment">// 基于新素数构造的过滤器</span></span><br><span class="line">    &#125;</span><br><span class="line">    cancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-参考"><a href="#8-参考" class="headerlink" title="8 参考"></a>8 参考</h2><ul><li><a href="https://pkg.go.dev/context">https://pkg.go.dev/context</a></li><li><a href="https://faiface.github.io/post/context-should-go-away-go2/">https://faiface.github.io/post/context-should-go-away-go2/</a></li><li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/</a></li><li><a href="https://blog.csdn.net/qq_36183935/article/details/81137834">https://blog.csdn.net/qq_36183935/article/details/81137834</a></li><li><a href="https://blog.csdn.net/u011957758/article/details/82948750">https://blog.csdn.net/u011957758/article/details/82948750</a></li><li><a href="https://www.jianshu.com/p/e5df3cd0708bhttps://zhuanlan.zhihu.com/p/68792989">https://www.jianshu.com/p/e5df3cd0708bhttps://zhuanlan.zhihu.com/p/68792989</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] sync.Map</title>
      <link href="/2022/07/09/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Map/"/>
      <url>/2022/07/09/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Map/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在 golang 中, map 并不保证并发安全的安全性, 对 map 进行并发读写会导致严重的错误, sync 标准包下的 sync.Map 解决了这一问题.</p></blockquote><span id="more"></span><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h2><h3 id="1-1-sync-Map"><a href="#1-1-sync-Map" class="headerlink" title="1.1 sync.Map"></a>1.1 sync.Map</h3><p><img src="file-20250307231828243.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu Mutex</span><br><span class="line">    read atomic.Value </span><br><span class="line">    dirty <span class="keyword">map</span>[any]*entry</span><br><span class="line">    misses <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>read：无锁化的只读 map，实际类型为 readOnly</li><li>dirty：加锁处理的读写 map</li><li>misses：记录访问 read 的失效次数，累计达到阈值时，会进行 read map/dirty map 的更新轮换</li><li>mu：一把互斥锁，实现 dirty 和 misses 的并发管理</li><li>sync.Map 的特点是冗余了两份 map：read map 和 dirty map</li></ul><h3 id="1-2-entry-及对应的几种状态"><a href="#1-2-entry-及对应的几种状态" class="headerlink" title="1.2 entry 及对应的几种状态"></a>1.2 entry 及对应的几种状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type entry struct &#123;</span><br><span class="line">p unsafe.Pointer </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>kv 对中的 value，统一采用 unsafe.Pointer 的形式进行存储，通过 entry.p 的指针进行链接</li><li>entry.p 的指向分为三种情况：<ul><li>存活态：正常指向元素</li><li>软删除态：指向 nil, nil 态表示软删除，read map 和 dirty map 底层的 map 结构仍存在 key-entry 对，但在逻辑上该 key-entry 对已经被删除，因此无法被用户查询到</li><li>硬删除态：指向固定的全局变量 expunged, expunged 态表示硬删除，dirty map 中已不存在该 key-entry 对</li></ul></li></ul><h3 id="1-3-readOnly"><a href="#1-3-readOnly" class="headerlink" title="1.3 readOnly"></a>1.3 readOnly</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">    m       <span class="keyword">map</span>[any]*entry</span><br><span class="line">    amended <span class="type">bool</span> <span class="comment">// true if the dirty map contains some key not in m.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync.Map 中的只读 map：read 内部包含两个成员属性：</p><ul><li>m：真正意义上的 read map，实现从 key 到 entry 的映射；</li><li>amended：标识 read map 中的 key-entry 对是否存在缺失，需要通过 dirty map 兜底.</li></ul><h2 id="2-读流程"><a href="#2-读流程" class="headerlink" title="2 读流程"></a>2 读流程</h2><h3 id="2-1-sync-Map-Load"><a href="#2-1-sync-Map-Load" class="headerlink" title="2.1 sync.Map.Load()"></a>2.1 sync.Map.Load()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Load(key any) (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        read, _ = m.read.Load().(readOnly)</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检查  read map 中是否存在 key-entry 对，若存在，则直接读取 entry 返回</li><li>如果第一轮 read map 查询 miss，且 read map 不全，则需要加锁 double check</li><li>如果第二轮 read map 查询仍 miss（加锁后），且 read map 不全，则查询 dirty map 兜底</li><li>查询操作涉及到与 dirty map 的交互，misses 加一</li><li>解锁，返回查得的结果</li></ul><h3 id="2-2-entry-load"><a href="#2-2-entry-load" class="headerlink" title="2.2 entry.load()"></a>2.2 entry.load()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> load() (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *(*any)(p), <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sync.Map 中，kv 对的 value 是基于 entry 指针封装的形式；</li><li>从 map 取得 entry 后，最终需要调用 entry.load 方法读取指针指向的内容；</li><li>如果 entry 的指针状态为 nil 或者 expunged，说明 key-entry 对已被删除，则返回 nil；</li><li>如果 entry 未被删除，则读取指针内容，并且转为 any 的形式进行返回.</li></ul><h3 id="2-3-sync-Map-missLocked"><a href="#2-3-sync-Map-missLocked" class="headerlink" title="2.3 sync.Map.missLocked()"></a>2.3 sync.Map.missLocked()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> missLocked() &#123;</span><br><span class="line">    m.misses++</span><br><span class="line">    <span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.read.Store(readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">    m.dirty = <span class="literal">nil</span></span><br><span class="line">    m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在读流程中，倘若未命中 read map，且由于 read map 内容存在缺失需要和 dirty map 交互时，会走进 missLocked 流程；</li><li>在 missLocked 流程中，首先 misses 计数器累加 1；</li><li>如果 miss 次数小于 dirty map 中存在的 key-entry 对数量，直接返回即可；</li><li>如果 miss 次数大于等于 dirty map 中存在的 key-entry 对数量，则使用 dirty map 覆盖 read map，并将 read map 的 amended flag 置为 false；</li><li>新的 dirty map 置为 nil，misses 计数器清零.</li></ul><h2 id="3-写流程"><a href="#3-写流程" class="headerlink" title="3 写流程"></a>3 写流程</h2><h3 id="3-1-sync-Map-Store"><a href="#3-1-sync-Map-Store" class="headerlink" title="3.1 sync.Map.Store()"></a>3.1 sync.Map.Store()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value any) &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    read, _ = m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">            m.dirty[key] = e</span><br><span class="line">        &#125;</span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">            m.dirtyLocked()</span><br><span class="line">            m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        m.dirty[key] = newEntry(value)</span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> storeLocked(i *any) &#123;</span><br><span class="line">    atomic.StorePointer(&amp;e.p, unsafe.Pointe</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 read map 存在拟写入的 key，且 entry 不为 expunged 状态，说明这次操作属于更新而非插入，直接基于 CAS 操作进行 entry 值的更新，并直接返回（存活态或者软删除，直接覆盖更新）</li><li>如果未命中，则需要加锁 double check</li><li>如果第二轮检查中发现 read map 或者 dirty map 中存在 key-entry 对，则直接将 entry 更新为新值即可（存活态或者软删除，直接覆盖更新）</li><li>如果发现 read map 中该 key-entry 为 expunged 态，需要在 dirty map 先补齐 key-entry 对，再更新 entry 值（从硬删除中恢复，然后覆盖更新）</li><li>如果 read map 和 dirty map 均不存在，则在 dirty map 中插入新 key-entry 对，并且保证 read map 的 amended flag 为 true.（插入）</li><li>如果发现 dirty map 未初始化，需要前置执行 dirtyLocked 流程</li><li>解锁返回</li></ul><h3 id="3-2-entry-tryStore"><a href="#3-2-entry-tryStore" class="headerlink" title="3.2 entry.tryStore()"></a>3.2 entry.tryStore()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value any) &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryStore(i *any) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">        <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在写流程中，如果发现 read map 中已存在对应的 key-entry 对，则会对调用 tryStore 方法尝试进行更新；</li><li>如果 entry 为 expunged 态，说明已被硬删除，dirty 中缺失该项数据，因此 tryStore 执行失败，回归主干流程；</li><li>如果 entry 非 expunged 态，则直接执行 CAS 操作完成值的更新即可.</li></ul><h3 id="3-3-entry-unexpungeLocked"><a href="#3-3-entry-unexpungeLocked" class="headerlink" title="3.3 entry.unexpungeLocked()"></a>3.3 entry.unexpungeLocked()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value any) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    read, _ = m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">            m.dirty[key] = e</span><br><span class="line">        &#125;</span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> unexpungeLocked() (wasExpunged <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> atomic.CompareAndSwapPointer(&amp;e.p, expunged, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在写流程加锁 double check 的过程中，如果发现 read map 中存在对应的 key-entry 对，会执行该方法；</li><li>如果 key-entry 为硬删除 expunged 态，该方法会基于 CAS 操作将其更新为软删除 nil 态，然后进一步在 dirty map 中补齐该 key-entry 对，实现从硬删除到软删除的恢复.</li></ul><h3 id="3-4-entry-storeLocked"><a href="#3-4-entry-storeLocked" class="headerlink" title="3.4 entry.storeLocked()"></a>3.4 entry.storeLocked()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value any) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    read, _ = m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> storeLocked(i *any) &#123;</span><br><span class="line">    atomic.StorePointer(&amp;e.p, unsafe.Pointer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>写流程中，如果 read map 或者 dirty map 存在对应 key-entry，最终会通过原子操作，将新值的指针存储到 entry.p 当中.</li></ul><h3 id="3-5-sync-Map-dirtyLocked"><a href="#3-5-sync-Map-dirtyLocked" class="headerlink" title="3.5 sync.Map.dirtyLocked()"></a>3.5 sync.Map.dirtyLocked()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> dirtyLocked() &#123;</span><br><span class="line">    <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[any]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">    <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">        <span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">            m.dirty[k] = e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryExpungeLocked() (isExpunged <span class="type">bool</span>) &#123;</span><br><span class="line">    p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    <span class="keyword">for</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, <span class="literal">nil</span>, expunged) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在写流程中，如果需要将 key-entry 插入到兜底的 dirty map 中，并且此时 dirty map 为空（从未写入过数据或者刚发生过 missLocked），会进入 dirtyLocked 流程；</li><li>此时会遍历一轮 read map ，将未删除的 key-entry 对拷贝到 dirty map 当中；</li><li>在遍历时，还会将 read map 中软删除 nil 态的 entry 更新为硬删除 expunged 态，因为在此流程中，不会将其拷贝到 dirty map.</li></ul><h2 id="4-删流程"><a href="#4-删流程" class="headerlink" title="4 删流程"></a>4 删流程</h2><h3 id="4-1-sync-Map-Delete"><a href="#4-1-sync-Map-Delete" class="headerlink" title="4.1 sync.Map.Delete()"></a>4.1 sync.Map.Delete()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(key any) &#123;</span><br><span class="line">    m.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadAndDelete(key any) (value any, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        read, _ = m.read.Load().(readOnly)</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            <span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">delete</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 read map 中存在 key，则直接基于 cas 操作将其删除；</li><li>如果 read map 不存在 key，且 read map 有缺失（amended flag 为 true），则加锁 double check；</li><li>如果加锁 double check 时，read map 仍不存在 key 且 read map 有缺失，则从 dirty map 中取元素，并且将 key-entry 对从 dirty map 中物理删除；</li><li>删操作需要和 dirty map 交互，需要 missLocked 流程；</li><li>解锁；</li><li>如果从 read map 或 dirty map 中获取到了 key 对应的 entry，则走入 entry.delete() 方法逻辑删除 entry；</li><li>如果 read map 和 dirty map 中均不存在 key，返回 false 标识删除失败</li></ul><h3 id="4-2-entry-delete"><a href="#4-2-entry-delete" class="headerlink" title="4.2 entry.delete()"></a>4.2 entry.delete()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> <span class="built_in">delete</span>() (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> *(*any)(p), <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 entry 此前已被删除，则直接返回 false 标识删除失败</li><li>如果 entry 当前仍存在，则通过 CAS 将 entry.p 指向 nil，标识其已进入软删除状态</li></ul><h2 id="5-遍历流程"><a href="#5-遍历流程" class="headerlink" title="5 遍历流程"></a>5 遍历流程</h2><ul><li>在遍历过程中，如果发现 read map 数据不全（amended flag 为 true），会额外加一次锁，并使用 dirty map 覆盖 read map</li><li>遍历 read map（通过上个步骤保证 read map 有全量数据），执行用户传入的回调函数，如果某次回调时返回值为 false，则会终止全流程</li></ul><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><h3 id="6-1-entry-的-expunged-态"><a href="#6-1-entry-的-expunged-态" class="headerlink" title="6.1 entry 的 expunged 态"></a>6.1 entry 的 expunged 态</h3><p><strong>为什么需要使用 expunged 态来区分软硬删除？</strong></p><ul><li>无论是软删除(nil)还是硬删除(expunged),都表示在逻辑意义上 key-entry 对已经从 sync.Map 中删除，nil 和 expunged 的区别在于<ul><li>软删除态（nil）：read map 和 dirty map 在物理上仍保有该 key-entry 对，因此如果此时需要对该 entry 执行写操作，可以直接 CAS 操作</li><li>硬删除态（expunged）：dirty map 中已经没有该 key-entry 对，如果执行写操作，必须加锁（dirty map 必须含有全量 key-entry 对数据）</li></ul></li><li>设计 expunged 和 nil 两种状态的原因，就是为了优化在 dirtyLocked 前，针对同一个 key <strong>先删后写</strong>的场景. 通过 expunged 态额外标识出 dirty map 中是否仍具有指向该 entry 的能力，这样能够实现对一部分 nil 态 key-entry 对的解放，能够基于 CAS 完成这部分内容写入操作而无需加锁</li></ul><h3 id="6-2-read-map-和-dirty-map-的数据流转"><a href="#6-2-read-map-和-dirty-map-的数据流转" class="headerlink" title="6.2 read map 和 dirty map 的数据流转"></a>6.2 read map 和 dirty map 的数据流转</h3><p>sync.Map 由两个 map 构成：</p><ul><li>read map：访问时全程无锁；</li><li>dirty map：是兜底的读写 map，访问时需要加锁</li></ul><p>希望能根据对读、删、更新、写操作频次的探测，来实时动态地调整操作方式，希望在读、更新、删频次较高时，更多地采用 CAS 的方式无锁化地完成操作；在写操作频次较高时，则直接了当地采用加锁操作完成.</p><p><strong>两个 map</strong></p><ul><li>总体思想，希望能多用 read map，少用 dirty map，因为操作前者无锁，后者需要加锁</li><li>除了 expunged 态的 entry 之外，read map 的内容为 dirty map 的子集</li></ul><p><strong>dirty map -&gt; read map</strong></p><ul><li>记录读/删流程中，通过 misses 记录访问 read map miss 由 dirty 兜底处理的次数，当 miss 次数达到阈值，则进入 missLocked 流程，进行新老 read/dirty 替换流程；此时将老 dirty 作为新 read，新 dirty map 则暂时为空，直到 dirtyLocked 流程完成对 dirty 的初始化</li></ul><p><strong>read map -&gt; dirty map</strong></p><ul><li>发生 dirtyLocked 的前置条件：I dirty 暂时为空（此前没有写操作或者近期进行过 missLocked 流程）；II 接下来一次写操作访问 read 时 miss，需要由 dirty 兜底</li><li>在 dirtyLocked 流程中，需要对 read 内的元素进行状态更新，因此需要遍历，是一个线性时间复杂度的过程，可能存在性能抖动</li><li>dirtyLocked 遍历中，会将 read 中未被删除的元素（非 nil 非 expunged）拷贝到 dirty 中；会将 read 中所有此前被删的元素统一置为 expunged 态</li></ul><h3 id="6-3-适用场景与注意问题"><a href="#6-3-适用场景与注意问题" class="headerlink" title="6.3 适用场景与注意问题"></a>6.3 适用场景与注意问题</h3><ul><li>sync.Map 适用于读多、更新多、删多、写少的场景；</li><li>如果写操作过多，sync.Map 基本等价于互斥锁 + map；</li><li>sync.Map 可能存在性能抖动问题，主要发生于在读/删流程 miss 只读 map 次数过多时（触发 missLocked 流程），下一次插入操作的过程当中（dirtyLocked 流程）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] GMP</title>
      <link href="/2022/07/03/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP/"/>
      <url>/2022/07/03/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP/</url>
      
        <content type="html"><![CDATA[<blockquote><p>gmp = goroutine + machine + processor</p></blockquote><span id="more"></span><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><h3 id="1-1-线程"><a href="#1-1-线程" class="headerlink" title="1.1 线程"></a>1.1 线程</h3><p>通常指的是内核级线程，核心点如下：</p><ul><li>是操作系统最小调度单元；</li><li>创建、销毁、调度交由内核完成，cpu 需完成用户态与内核态间的切换；</li><li>可充分利用多核，实现并行.<h3 id="1-2-协程"><a href="#1-2-协程" class="headerlink" title="1.2 协程"></a>1.2 协程</h3></li></ul><p>协程，又称为用户级线程，核心点如下：</p><ul><li>与线程存在映射关系，为 M：1；</li><li>创建、销毁、调度在用户态完成，对内核透明，所以更轻；</li><li>从属同一个内核级线程，无法并行；一个协程阻塞会导致从属同一线程的所有协程无法执行.</li></ul><h3 id="1-3-Goroutine"><a href="#1-3-Goroutine" class="headerlink" title="1.3 Goroutine"></a>1.3 Goroutine</h3><p>Goroutine，经 Golang 优化后的特殊“协程”，特点如下：</p><ul><li>与线程存在映射关系，为 M：N；</li><li>创建、销毁、调度在用户态完成，对内核透明，足够轻便；</li><li>可利用多个线程，实现并行；</li><li>通过调度器的，实现和线程间的动态绑定和灵活调度；</li><li>栈空间大小可动态扩缩.</li></ul><h3 id="1-4-对比"><a href="#1-4-对比" class="headerlink" title="1.4 对比"></a>1.4 对比</h3><div class="table-container"><table><thead><tr><th><strong>模型</strong></th><th><strong>弱依赖内核</strong></th><th><strong>可并行</strong></th><th><strong>可应对阻塞</strong></th><th><strong>栈可动态扩缩</strong></th></tr></thead><tbody><tr><td>线程</td><td>❎</td><td>✅</td><td>✅</td><td>❎</td></tr><tr><td>协程</td><td>✅</td><td>❎</td><td>❎</td><td>❎</td></tr><tr><td>goroutine</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table></div><h2 id="2-GMP-模型"><a href="#2-GMP-模型" class="headerlink" title="2 GMP 模型"></a>2 GMP 模型</h2><h3 id="2-1-g"><a href="#2-1-g" class="headerlink" title="2.1 g"></a>2.1 g</h3><ul><li>g 即goroutine，是 golang 中对协程的抽象</li><li>g 有自己的运行栈、状态、以及执行的任务函数（用户通过 go func 指定）</li><li>g 需要绑定到 p 才能执行，在 g 的视角中，p 就是它的 cpu</li></ul><h3 id="2-2-m"><a href="#2-2-m" class="headerlink" title="2.2 m"></a>2.2 m</h3><ul><li>m 即 machine，是 golang 中对线程的抽象</li><li>m 不直接执行 g，而是先和 p 绑定，由其实现代理</li><li>借由 p 的存在，m 无需和 g 绑死，也无需记录 g 的状态信息，因此 g 在全生命周期中可以实现跨 m 执行.</li></ul><h3 id="2-3-p"><a href="#2-3-p" class="headerlink" title="2.3 p"></a>2.3 p</h3><ul><li>p 即 processor，是 golang 中的调度器</li><li>p 是 gmp 的中枢，借由 p 承上启下，实现 g 和 m 之间的动态有机结合</li><li>对 g 而言，p 是其 cpu，g 只有被 p 调度，才得以执行</li><li>对 m 而言，p 是其执行代理，为其提供必要信息的同时（可执行的 g、内存分配情况等），并隐藏了繁杂的调度细节</li><li>p 的数量决定了 g 最大并行数量，可由用户通过 GOMAXPROCS 进行设定（超过 CPU 核数时无意义）</li></ul><h3 id="2-4-GMP"><a href="#2-4-GMP" class="headerlink" title="2.4 GMP"></a>2.4 GMP</h3><ul><li>M 是线程的抽象；G 是 goroutine；P 是承上启下的调度器；</li><li>M调度G前，需要和P绑定；</li><li>全局有多个M和多个P，但同时并行的G的最大数量等于P的数量；</li><li>G的存放队列有三类：P的本地队列；全局队列；和wait队列（图中未展示，为io阻塞就绪态goroutine队列）；</li><li>M调度G时，优先取P本地队列，其次取全局队列，最后取wait队列；这样的好处是，取本地队列时，可以接近于无锁化，减少全局锁竞争；</li><li>为防止不同P的闲忙差异过大，设立work-stealing机制，本地队列为空的P可以尝试从其他P本地队列偷取一半的G补充到自身队列.</li></ul><h2 id="3-核心数据结构"><a href="#3-核心数据结构" class="headerlink" title="3 核心数据结构"></a>3 核心数据结构</h2><blockquote><p>gmp 数据结构定义在 runtime/runtime2.go 文件中</p></blockquote><h3 id="3-1-g"><a href="#3-1-g" class="headerlink" title="3.1 g"></a>3.1 g</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    m         *m      </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sched     gobuf</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    sp   <span class="type">uintptr</span></span><br><span class="line">    pc   <span class="type">uintptr</span></span><br><span class="line">    ret  <span class="type">uintptr</span></span><br><span class="line">    bp   <span class="type">uintptr</span> <span class="comment">// for framepointer-enabled architectures</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>m：在 p 的代理，负责执行当前 g 的 m；</li><li>sched.sp：保存 CPU 的 rsp 寄存器的值，指向函数调用栈栈顶；</li><li>sched.pc：保存 CPU 的 rip 寄存器的值，指向程序下一条执行指令的地址；</li><li>sched.ret：保存系统调用的返回值；</li><li>sched.bp：保存 CPU 的 rbp 寄存器的值，存储函数栈帧的起始位置.</li></ul><p>g的生命周期:未初始化完成 等待被执行  执行  执行系统调用  挂起态  被销毁  栈扩容 被抢占</p><h3 id="3-2-m"><a href="#3-2-m" class="headerlink" title="3.2 m"></a>3.2 m</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    g0      *g     <span class="comment">// goroutine with scheduling stack</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    tls           [tlsSlots]<span class="type">uintptr</span> <span class="comment">// thread-local storage (for x86 extern register)</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>g0：一类特殊的调度协程，不用于执行用户函数，负责执行 g 之间的切换调度. 与 m 的关系为 1:1；</li><li>tls：thread-local storage，线程本地存储，存储内容只对当前线程可见. 线程本地存储的是 m.tls 的地址，m.tls[0] 存储的是当前运行的 g，因此线程可以通过 g 找到当前的 m、p、g0 等信息.<h3 id="3-3-p"><a href="#3-3-p" class="headerlink" title="3.3 p"></a>3.3 p</h3></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    runqhead <span class="type">uint32</span></span><br><span class="line">    runqtail <span class="type">uint32</span></span><br><span class="line">    runq     [<span class="number">256</span>]guintptr</span><br><span class="line">    </span><br><span class="line">    runnext guintptr</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>runq：本地 goroutine 队列，最大长度为 256.</li><li>runqhead：队列头部；</li><li>runqtail：队列尾部；</li><li>runnext：下一个可执行的 goroutine.</li></ul><h3 id="3-4-schedt"><a href="#3-4-schedt" class="headerlink" title="3.4 schedt"></a>3.4 schedt</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lock mutex</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    runq     gQueue</span><br><span class="line">    runqsize <span class="type">int32</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sched 是全局 goroutine 队列的封装：</p><ul><li>lock：一把操作全局队列时使用的锁；</li><li>runq：全局 goroutine 队列；</li><li>runqsize：全局 goroutine 队列的容量.</li></ul><h2 id="4-调度流程"><a href="#4-调度流程" class="headerlink" title="4 调度流程"></a>4 调度流程</h2><h3 id="4-1-g0-和-g-的转换"><a href="#4-1-g0-和-g-的转换" class="headerlink" title="4.1 g0 和 g 的转换"></a>4.1 g0 和 g 的转换</h3><p><strong>goroutine 的类型可分为两类：</strong></p><ul><li>负责调度普通 g 的 g0，执行固定的调度流程，与 m 的关系为一对一</li><li>负责执行用户函数的普通 g<br>m 通过 p 调度执行的 goroutine 永远在普通 g 和 g0 之间进行切换，当 g0 找到可执行的 g 时，会调用 gogo 方法，调度 g 执行用户定义的任务；当 g 需要主动让渡或被动调度时，会触发 mcall 方法，将执行权重新交还给 g0.</li></ul><h3 id="4-2-调度类型"><a href="#4-2-调度类型" class="headerlink" title="4.2 调度类型"></a>4.2 调度类型</h3><blockquote><p>调度器 p 实现从执行一个 g 切换到另一个 g 的过程.</p></blockquote><h4 id="4-2-1-主动调度"><a href="#4-2-1-主动调度" class="headerlink" title="4.2.1 主动调度"></a>4.2.1 主动调度</h4><ul><li>用户主动执行让渡的方式，主要方式是，用户在执行代码中调用了 runtime.Gosched 方法，此时当前 g 会当让出执行权，主动进行队列等待下次被调度执行.</li></ul><h4 id="4-2-2-被动调度"><a href="#4-2-2-被动调度" class="headerlink" title="4.2.2 被动调度"></a>4.2.2 被动调度</h4><ul><li>因当前不满足某种执行条件，g 可能会陷入阻塞态无法被调度，直到关注的条件达成后，g才从阻塞中被唤醒，重新进入可执行队列等待被调度.</li><li><p>常见的被动调度触发方式为因 channel 操作或互斥锁操作陷入阻塞等操作，底层会走进 gopark 方法.</p><h4 id="4-2-3-正常调度"><a href="#4-2-3-正常调度" class="headerlink" title="4.2.3 正常调度"></a>4.2.3 正常调度</h4></li><li><p>g 中的执行任务已完成，g0 会将当前 g 置为死亡状态，发起新一轮调度.</p><h4 id="4-2-4-抢占调度"><a href="#4-2-4-抢占调度" class="headerlink" title="4.2.4 抢占调度"></a>4.2.4 抢占调度</h4></li><li><p>如果 g 执行系统调用超过指定的时长，且全局的 p 资源比较紧缺，此时将 p 和 g 解绑，抢占出来用于其他 g 的调度. 等 g 完成系统调用后，会重新进入可执行队列中等待被调度.</p></li><li>前 3 种调度方式都由 m 下的 g0 完成，唯独抢占调度不同.</li><li>因为发起系统调用时需要打破用户态的边界进入内核态，此时 m 也会因系统调用而陷入僵直，无法主动完成抢占调度的行为.</li><li>因此，在 Golang 进程会有一个全局监控协程 monitor g 的存在，这个 g 会越过 p 直接与一个 m 进行绑定，不断轮询对所有 p 的执行状况进行监控. 倘若发现满足抢占调度的条件，则会从第三方的角度出手干预，主动发起该动作.</li></ul><h3 id="4-3-宏观调度流程"><a href="#4-3-宏观调度流程" class="headerlink" title="4.3 宏观调度流程"></a>4.3 宏观调度流程</h3><ul><li>g0 执行 schedule() 函数，寻找到用于执行的 g</li><li>g0 执行 execute() 方法，更新当前 g、p 的状态信息，并调用 gogo() 方法，将执行权交给 g</li><li>g 因主动让渡( gosche_m() )、被动调度( park_m() )、正常结束( goexit0() )等原因，调用 m_call 函数，执行权重新回到 g0 手中</li><li>g0 执行 schedule() 函数，开启新一轮循环</li></ul><h3 id="4-4-schedule"><a href="#4-4-schedule" class="headerlink" title="4.4 schedule"></a>4.4 schedule</h3><p>调度流程的主干方法是位于 runtime/proc.go 中的 schedule 函数，此时的执行权位于 g0 手中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    gp, inheritTime, tryWakeP := findRunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>寻找到下一个执行的 goroutine</li><li>执行该 goroutine</li></ul><h3 id="4-5-findRunnable"><a href="#4-5-findRunnable" class="headerlink" title="4.5 findRunnable"></a>4.5 findRunnable</h3><p><img src="file-20250303232645826.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRunnable</span><span class="params">()</span></span> (gp *g, inheritTime, tryWakeP <span class="type">bool</span>) &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    _p_ := _g_.m.p.ptr()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> _p_.schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        gp = globrunqget(_p_, <span class="number">1</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> gp, inheritTime := runqget(_p_); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gp, inheritTime, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> list := netpoll(<span class="number">0</span>); !list.empty() &#123; <span class="comment">// non-blocking</span></span><br><span class="line">            gp := list.pop()</span><br><span class="line">            injectglist(&amp;list)</span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    procs := <span class="type">uint32</span>(gomaxprocs)</span><br><span class="line">    <span class="keyword">if</span> _g_.m.spinning || <span class="number">2</span>*atomic.Load(&amp;sched.nmspinning) &lt; procs-atomic.Load(&amp;sched.npidle) &#123;</span><br><span class="line">        <span class="keyword">if</span> !_g_.m.spinning &#123;</span><br><span class="line">            _g_.m.spinning = <span class="literal">true</span></span><br><span class="line">            atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gp, inheritTime, tnow, w, newWork := stealWork(now)</span><br><span class="line">        now = tnow</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// Successfully stole.</span></span><br><span class="line">            <span class="keyword">return</span> gp, inheritTime, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> newWork &#123;</span><br><span class="line">            <span class="comment">// There may be new timer or GC work; restart to</span></span><br><span class="line">            <span class="comment">// discover.</span></span><br><span class="line">            <span class="keyword">goto</span> top</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; (pollUntil == <span class="number">0</span> || w &lt; pollUntil) &#123;</span><br><span class="line">            <span class="comment">// Earlier timer to wait for.</span></span><br><span class="line">            pollUntil = w</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>p 每执行 61 次调度，会从全局队列中获取一个 goroutine 进行执行，并将一个全局队列中的 goroutine 填充到当前 p 的本地队列中<ul><li>取得 p 本地队列队首的索引，同时对本地队列加锁</li><li>倘若 p 的局部队列未满，则成功转移 g，将 p 的对尾索引 runqtail 值加 1 并解锁队列.</li><li>倘若发现本地队列 runq 已经满了，则会返回来将本地队列中一半的 g 放回全局队列中，帮助当前 p 缓解执行压力，这部分内容位于 runqputslow 方法中</li></ul></li><li>尝试从 p 本地队列中获取一个可执行的 goroutine，核心逻辑位于 runqget 方法中<ul><li>倘若当前 p 的 runnext 非空，直接获取即可</li><li>加锁从 p 的本地队列中获取 g, 虽然本地队列是属于 p 独有的，但是由于 work-stealing 机制的存在，其他 p 可能会前来执行窃取动作，因此操作仍需加锁.</li><li>倘若本地队列为空，直接终止并返回</li><li>倘若本地队列存在 g，则取得队首的 g，解锁并返回</li></ul></li><li>倘若本地队列没有可执行的 g，会从全局队列中获取</li><li>倘若本地队列和全局队列都没有 g，则会获取准备就绪的网络协程</li><li>work-stealing: 从其他 p 中偷取 g<ul><li>偷取操作至多会遍历全局的 p 队列 4 次，过程中只要找到可窃取的 p 则会立即返回.</li><li>为保证窃取行为的公平性，遍历的起点是随机的. 窃取动作的核心逻辑位于 runqgrab 方法当中</li><li>每次对一个 p 尝试窃取前，会对其局部队列加锁</li><li>尝试偷取其现有的一半 g，并且返回实际偷取的数量</li></ul></li></ul><h3 id="4-6-execute"><a href="#4-6-execute" class="headerlink" title="4.6 execute"></a>4.6 execute</h3><p>当 g0 为 m 寻找到可执行的 g 之后，接下来就开始执行 g. 这部分内容位于 runtime/proc.go 的 execute 方法中</p><ul><li>更新 g 的状态信息，建立 g 与 m 之间的绑定关系</li><li>更新 p 的总调度次数</li><li>调用 gogo 方法，执行 goroutine 中的任务</li></ul><h3 id="4-7-gosched-m"><a href="#4-7-gosched-m" class="headerlink" title="4.7 gosched_m"></a>4.7 gosched_m</h3><p>g 执行主动让渡时，会调用 mcall 方法将执行权归还给 g0，并由 g0 调用 gosched_m 方法，位于 runtime/proc.go 文件中</p><p><img src="file-20250303234355218.png" alt=""></p><ul><li>将当前 g 的状态由执行中切换为待执行 <code>_Grunnable</code></li><li>调用 dropg() 方法，将当前的 m 和 g 解绑</li><li>将 g 添加到全局队列当中</li><li>开启新一轮的调度</li></ul><h3 id="4-8-park-m-与-ready"><a href="#4-8-park-m-与-ready" class="headerlink" title="4.8 park_m 与 ready"></a>4.8 park_m 与 ready</h3><ul><li>g 需要被动调度时，会调用 mcall 方法切换至 g0，并调用 park_m 方法将 g 置为阻塞态，执行流程位于 runtime/proc.go 的 gopark 方法当中<ul><li>将当前 g 的状态由 running 改为 waiting</li><li>将 g 与 m 解绑</li><li>执行新一轮的调度 schedule</li></ul></li><li>当因被动调度陷入阻塞态的 g 需要被唤醒时，会由其他协程执行 goready 方法将 g 重新置为可执行的状态，方法位于 runtime/proc.go<ul><li>先将 g 的状态从阻塞态改为可执行的状态</li><li>调用 runqput 将当前 g 添加到唤醒者 p 的本地队列中，如果队列满了，会连带 g 一起将一半的元素转移到全局队列</li></ul></li></ul><h3 id="4-9-goexit0"><a href="#4-9-goexit0" class="headerlink" title="4.9 goexit0"></a>4.9 goexit0</h3><ul><li>当 g 执行完成时，会先执行 mcall 方法切换至 g0，然后调用 goexit0 方法<ul><li>将 g 状态置为 dead</li><li>解绑 g 和 m</li><li>开启新一轮的调度</li></ul></li></ul><h3 id="4-10-retake"><a href="#4-10-retake" class="headerlink" title="4.10 retake"></a>4.10 retake</h3><p>抢占调度的执行者不是 g0，而是一个全局的 monitor g，代码位于 runtime/proc.go 的 retake 方法中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retake</span><span class="params">(now <span class="type">int64</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    lock(&amp;allpLock)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(allp); i++ &#123;</span><br><span class="line">        _p_ := allp[i]</span><br><span class="line">        <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// This can happen if procresize has grown</span></span><br><span class="line">            <span class="comment">// allp but not yet created new Ps.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        pd := &amp;_p_.sysmontick</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> s == _Psyscall &#123;            </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">if</span> runqempty(_p_) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; <span class="number">0</span> &amp;&amp; pd.syscallwhen+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &gt; now &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            unlock(&amp;allpLock)</span><br><span class="line">            <span class="keyword">if</span> atomic.Cas(&amp;_p_.status, s, _Pidle) &#123;</span><br><span class="line">                n++</span><br><span class="line">                _p_.syscalltick++</span><br><span class="line">                handoffp(_p_)</span><br><span class="line">            &#125;</span><br><span class="line">            incidlelocked(<span class="number">1</span>)</span><br><span class="line">            lock(&amp;allpLock)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;allpLock)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">uint32</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>加锁后，遍历全局的 p 队列，寻找需要被抢占的目标</li><li>倘若某个 p 同时满足下述条件，则会进行抢占调度<ul><li>执行系统调用超过 10 ms</li><li>p 本地队列有等待执行的 g</li><li>或者当前没有空闲的 p 和 m</li></ul></li><li>抢占调度的步骤是，先将当前 p 的状态更新为 idle，然后步入 handoffp 方法中，判断是否需要为 p 寻找接管的 m（因为其原本绑定的 m 正在执行系统调用）</li><li>当以下条件满足其一时，则需要为 p 获取新的 m<ul><li>当前 p 本地队列还有待执行的 g</li><li>全局繁忙（没有空闲的 p 和 m，全局 g 队列为空）</li><li>需要处理网络 socket 读写请求</li></ul></li><li>获取 m 时，会先尝试获取已有的空闲的 m，若不存在，则会创建一个新的 m</li></ul><h3 id="4-11-reentersyscall-和-exitsyscall"><a href="#4-11-reentersyscall-和-exitsyscall" class="headerlink" title="4.11 reentersyscall 和 exitsyscall"></a>4.11 reentersyscall 和 exitsyscall</h3><p>在 m 需要执行系统调用前，会先执行位于 runtime/proc.go 的 reentersyscall 的方法</p><ul><li>此时执行权同样位于 m 的 g0 手中</li><li>保存当前 g 的执行环境</li><li>将 g 和 p 的状态更新为 syscall</li><li>解除 p 和 当前 m 之间的绑定，因为 m 即将进入系统调用而导致短暂不可用</li><li>将 p 添加到 当前 m 的 oldP 容器当中，后续 m 恢复后，会优先寻找旧的 p 重新建立绑定关系</li></ul><p>当 m 完成了内核态的系统调用之后，此时会步入位于 runtime/proc.go 的 exitsyscall 函数中，尝试寻找 p 重新开始运作</p><ul><li>方法执行之初，此时的执行权是普通 g.倘若此前设置的 oldp 仍然可用，则重新和 oldP 绑定，将当前 g 重新置为 running 状态，然后开始执行后续的用户函数</li><li>old 绑定失败，则调用 mcall 方法切换到 m 的 g0，并执行 exitsyscall0 方法</li><li>将 g 由系统调用状态切换为可运行态，并解绑 g 和 m 的关系</li><li>从全局 p 队列获取可用的 p，如果获取到了，则执行 g</li><li>如若无 p 可用，则将 g 添加到全局队列，当前 m 陷入沉睡. 直到被唤醒后才会继续发起调度.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] 类型断言</title>
      <link href="/2021/12/13/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/"/>
      <url>/2021/12/13/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>类型断言的关键是明确接口的动态类型以及对应的类型实现了哪些方法</p></blockquote><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>类型分类：</p><ul><li>抽象类型：空接口、非空接口</li><li>具体类型：int、string、slice、map ….</li></ul><p>断言表达式：</p><ul><li>类型断言作用在接口值之上，可以是空接口或非空接口；</li><li>而断言的目标类型可以是具体类型或非空接口类型。</li></ul><p>这样一共就有4种断言组合。</p><h2 id="2-具体分析"><a href="#2-具体分析" class="headerlink" title="2 具体分析"></a>2 具体分析</h2><h3 id="2-1-空接口-具体类型"><a href="#2-1-空接口-具体类型" class="headerlink" title="2.1 空接口.(具体类型)"></a>2.1 空接口.(具体类型)</h3><p><strong>空接口只有动态类型，所以只要动态类型相同就能断言成功</strong>。<br><img src="file-20250119063246346.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">r,ok := e.(*os.File)</span><br></pre></td></tr></table></figure><p>这里只需要判定 e 的 _type 是否执行 *os.File 的类型元数据即可。</p><blockquote><p> Go 语言里面每种类型的类型元数据都是唯一的，如果类型元数据相同那就是同一种类型。</p></blockquote><p>如果这样赋值就能断言成功, ok 为 true，r 被赋值为 e 的动态值 f。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eface2Specific</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">f, _ := os.Open(<span class="string">&quot;17x.txt&quot;</span>)</span><br><span class="line">e = f</span><br><span class="line">r, ok := e.(*os.File)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反之则不行，ok 为 false，<strong>r 被赋值为 *os.File 类型(断言的目标类型)的零值 nil</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">f, _ := os.Open(<span class="string">&quot;17x.txt&quot;</span>)</span><br><span class="line">e = <span class="string">&quot;17x&quot;</span></span><br><span class="line">r, ok := e.(*os.File)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-非空接口-具体类型"><a href="#2-2-非空接口-具体类型" class="headerlink" title="2.2 非空接口.(具体类型)"></a>2.2 非空接口.(具体类型)</h3><p><strong>这里需要判断非空接口的动态类型是否等于断言目标类型</strong>。</p><p><img src="file-20250119063407429.png" alt=""></p><p>下面的断言，要求 rw 接口类型为 io.ReadWriter，动态类型为*os.File。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rw io.ReadWriter</span><br><span class="line">r, ok := rw.(*os.File)</span><br></pre></td></tr></table></figure><p>只需要判定非空接口的 itab 是否指向 io.ReadWriter 的 itab 结构体即可。</p><p>这样赋值就能断言成功：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> rw io.ReadWriter</span><br><span class="line">f, _ := os.Open(<span class="string">&quot;17x.txt&quot;</span>)</span><br><span class="line">rw = f</span><br><span class="line">r, ok := rw.(*os.File)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样则不行,接口类型对上了，但是 rw 的动态类型是  <em>MyRW，不是断言目标类型 </em>os.File。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> rw io.ReadWriter</span><br><span class="line">rw = &amp;MyRW&#123;&#125;</span><br><span class="line">r, ok := rw.(*os.File)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyRW <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *MyRW)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)  &#123; <span class="keyword">return</span> <span class="number">0</span>, err &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *MyRW)</span></span> Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>, err &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-空接口-非空接口"><a href="#2-3-空接口-非空接口" class="headerlink" title="2.3 空接口.(非空接口)"></a>2.3 空接口.(非空接口)</h3><p><strong>这里需要判断空接口的动态类型是否实现了非空接口</strong>。<br><img src="file-20250119063351822.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">r, ok := e.(io.ReadWriter)</span><br></pre></td></tr></table></figure><ul><li>1）先去 itab 缓存中找 <strong>&lt;断言目标值接口类型，空接口动态类型&gt;</strong> 这个 Key 对应的 itab 结构体；</li><li>2）如果存在则再次判断 itab.fun[0] 是否等于0<ul><li>等于 0 则断言失败</li><li>不等于 0则断言成功</li></ul></li><li>3）如果不存在则通过 _type 找到方法元数据，校验是否实现了接口类型，且把 itab 添加到哈希表，方便下次断言是比对。<ul><li>如果没有实现该接口类型还要把  itab.fun[0] 置为0</li></ul></li></ul><p><strong>为什么需要判断  itab.fun[0] 是否等于0？</strong></p><p>因为 Go 语言会把断言失败的类型组合也存到哈希表，同时把  itab.fun[0] 置为0，用以标识这里的动态类型并没有实现对应的接口。</p><p><strong>这样下次断言的时候找到 itab 发现  itab.fun[0]=0，就直接返回断言失败</strong>。</p><h3 id="2-4-非空接口-非空接口"><a href="#2-4-非空接口-非空接口" class="headerlink" title="2.4 非空接口.(非空接口)"></a>2.4 非空接口.(非空接口)</h3><p><strong>这里同样是判断非空接口的动态类型是否实现了非空接口</strong>。<br><img src="file-20250119063336492.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">iface2iface</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> w io.Writer</span><br><span class="line">   f, _ := os.Open(<span class="string">&quot;17x.txt&quot;</span>)</span><br><span class="line">   w = f</span><br><span class="line">   r, ok := w.(io.ReadWriter)</span><br><span class="line">   <span class="keyword">if</span> ok &#123;</span><br><span class="line">      fmt.Println(r)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><ul><li>1）空接口.(具体类型)：动态类型等于目标类型的动态类型。</li><li>2）非空接口.(具体类型)：动态类型等于目标类型的动态类型。</li><li>3）空接口.(非空接口)：动态类型是否实现了非空接口的接口类型。</li><li>4）非空接口.(非空接口)：动态类型是否实现了非空接口的接口类型。</li></ul><p>一句话总结：</p><p><strong>断言为具体类型则看动态类型是否相同，断言为非空接口则看是否实现了非空接口的接口类型。</strong></p><p><strong>类型断言的关键是明确接口的动态类型以及对应的类型实现了哪些方法</strong>，明确这些的关键就是<code>类型元数据</code>以及空接口与非空接口的<code>数据结构</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 关键字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] 反射</title>
      <link href="/2021/12/04/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/"/>
      <url>/2021/12/04/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>反射的作用就是将类型元数据暴露给用户使用</p></blockquote><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p> runtime 包中的类型元数据、空接口、非空接口等数据类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_type</span><br><span class="line">typeAlg</span><br><span class="line">uncommontype</span><br><span class="line">interfacetype</span><br><span class="line">eface</span><br><span class="line">iface</span><br><span class="line">slicetype</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但是这些都是未导出的,于是 reflect 包中由定义了一套，这些类型定义在两个包中是保持一致的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rtype</span><br><span class="line">typeAlg</span><br><span class="line">uncommontype</span><br><span class="line">interfaceType</span><br><span class="line">emptyInterface</span><br><span class="line">noneEmptyInterface</span><br><span class="line">sliceType</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>reflect 包提供了 TypeOf 函数用于获取一个变量的类型信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type &#123;</span><br><span class="line">eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line"><span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反射三大法则：</p><ol><li>从 <code>interface&#123;&#125;</code> 变量可以反射出反射对象；</li><li>从反射对象可以获取 <code>interface&#123;&#125;</code> 变量；</li><li>要修改反射对象，其值必须可设置；</li></ol><h2 id="2-反射获取类型信息"><a href="#2-反射获取类型信息" class="headerlink" title="2 反射获取类型信息"></a>2 反射获取类型信息</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> i17x <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i i17x)</span></span> A() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := i17x&#123;Name: <span class="string">&quot;17x&quot;</span>&#125;</span><br><span class="line">t := reflect.TypeOf(i)</span><br><span class="line"><span class="built_in">println</span>(t.Name(), t.NumMethod())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们想要获取这个结构体的类型信息，调用 TypeOf 方法。</p><p><strong>然而 TypeOf 方法的参数是一个空接口，需要的是一个地址</strong>。</p><p>但是我们这里传递的是一个值类型，难道函数里面用的是 i 的地址？</p><p>并不是，因为这样就违反了传参值拷贝的语义，实际上这里是在<strong>编译期生成了临时变量作为 a 的拷贝</strong>，然后参数就用的这个临时变量的地址。</p><p>这样即符合传参值拷贝的语义又满足了空接口类型的参数只能是地址的需求。</p><p><strong>所有参数为空接口类型的情况，都要像这样。通过传递拷贝后临时变量的地址来实现传值的语义。</strong></p><p>然后 TypeOf 函数会把传进去的 eface 类型的参数转换成 reflect.emptyInterface 类型。</p><blockquote><p>这两个类型定义是一致的，转换后方便 reflect 包操作内部元素。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">_type *_type</span><br><span class="line">data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">typ  *rtype</span><br><span class="line">word unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emptyInterface 中的字段 typ 实现了 reflect.Type 接口，所以接下来只需要将 eface 包装成reflect.Type 类型的返回值即可。</p><p>所以 TypeOf 最终返回值就是一个 非空接口 iface，具体如下：</p><ul><li>1）接口类型 reflect.Type，动态类型为 *rtype</li><li>2）Data 指向我们传入的参数 i 。</li></ul><h2 id="3-反射修改值"><a href="#3-反射修改值" class="headerlink" title="3 反射修改值"></a>3 反射修改值</h2><p>修改变量值就要用到 reflect.Value 类型了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">typ *rtype</span><br><span class="line">ptr unsafe.Pointer</span><br><span class="line">flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1）typ：类型元数据指针</li><li>2）ptr：数据地址</li><li>3）flag：位标识符，存储反射值的一些描述信息<ul><li>是否为指针</li><li>是否为方法</li><li>是否只读</li><li>……</li></ul></li></ul><p>通常会使用 reflect.ValueOf 函数来获取reflect.Value，这里参数也是空接口，所以需要和 TypeOf 函数一样处理，唯一不同的是 <strong>这个临时变量会被显式逃逸到堆上</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">escapes(i)</span><br><span class="line"><span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以最后该函数返回的非空接口中的 data 其实指向的堆上的临时变量。</strong></p><p>例如下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a:=<span class="string">&quot;17x&quot;</span></span><br><span class="line">v := reflect.ValueOf(a)</span><br><span class="line">v.SetString(<span class="string">&quot;i17x&quot;</span>)</span><br><span class="line"><span class="built_in">println</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 v 指向的是堆上的临时变量，所以通过 v 直接修改这样一个用户都不知道的临时变量是行不通的，所以会发生 panic。</p><p><strong>既然有临时变量存在，那怎么才能拿到a的指针？</strong></p><p>为了解决这个问题，就只能在 ValueOf 函数的时候传指针进去，就像这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a:=<span class="string">&quot;17x&quot;</span></span><br><span class="line">v := reflect.ValueOf(a)</span><br><span class="line">v=v.Elem()</span><br><span class="line">v.SetString(<span class="string">&quot;i17x&quot;</span>)</span><br><span class="line"><span class="built_in">println</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样执行传入 a 的地址，虽然还是会创建临时变量，然后逃逸到堆上，最后返回的也是指向的临时变量，但是变量中存放的是a的地址，所以我们可以通过<code>v.Elem()</code> 拿到变量a就可以修改了。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><code>https://www.bilibili.com/video/BV1hv411x7we?p=16</code></p><p><code>https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] 闭包</title>
      <link href="/2021/12/04/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E9%97%AD%E5%8C%85/"/>
      <url>/2021/12/04/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<blockquote><p>闭包是有状态函数</p></blockquote><span id="more"></span><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="1-function-value"><a href="#1-function-value" class="headerlink" title="1 function value"></a>1 function value</h2><p>Go 语言中的函数是头等公民。可以做为参数传递，可以做函数返回值、也可以绑定到变量。</p><p>Go 语言称这样的参数、返回值或变量为<strong>function value</strong>。</p><p>function value 不直接指向函数指令入口，而是指向一个 <code>runtime.funcval</code>结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/runtime2.go</span></span><br><span class="line"><span class="keyword">type</span> funcval <span class="keyword">struct</span> &#123;</span><br><span class="line">fn <span class="type">uintptr</span></span><br><span class="line"><span class="comment">// variable-size, fn-specific data here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 funcval 只有一个字段 fn，存储的就是函数指令入口地址。</p><h2 id="2-闭包-Closure"><a href="#2-闭包-Closure" class="headerlink" title="2 闭包 Closure"></a>2 闭包 Closure</h2><p><strong>为什么要用 funcval 结构体来包装函数指令入口地址，然后使用二级指针来调用？</strong></p><p>主要是为了处理闭包的情况。</p><p>维基百科上的<a href="[https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">闭包</a>](<a href="https://zh.wikipedia.org/wiki/闭包_(计算机科学)))定义如下：">https://zh.wikipedia.org/wiki/闭包_(计算机科学)))定义如下：</a></p><ul><li>1）必须要有在函数外部定义但在函数内部引用的<code>自由变量</code></li><li>2）脱离了形成闭包的上下文，闭包也能照常使用这些自由变量。</li></ul><p>就向下面这个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1 := create()</span><br><span class="line">f2 := create()</span><br><span class="line">fmt.Println(f1())</span><br><span class="line">fmt.Println(f2())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">i := <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create() 函数执行结束后，通过 f1()，f2() 依然可以正常调用这个闭包函数，并使用定义在 create() 函数内部的局部变量 i，所以这符合闭包的定义。</p><p>通常称这个变量 i 为<strong>捕获变量</strong>。</p><p><strong>闭包函数的指令在编译阶段生成，但是闭包对象要到执行阶段才创建，因为每个闭包对象都要保存自己的捕获变量</strong>。</p><p>闭包函数指令存放在栈中的代码段上。</p><p>闭包对象则会分配到堆上，闭包对象具体组成如下：</p><ul><li>1）funcval 结构体</li><li>2）捕获变量列表</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1 := create()</span><br><span class="line">f2 := create()</span><br></pre></td></tr></table></figure><p>这里创建了两个闭包对象，其中的 funcval 都指向同一个函数指令入口，但是捕获变量则需要各自维护。</p><p>然后把这两个闭包对象的地址赋值给接收者，即这里的 f1,f2。</p><p>通过f1、f2调用闭包函数会找到各自对应的 funcval 结构体，拿到同一个函数入口，但是却使用的是各自的捕获变量列表。</p><p><strong>这就是称闭包为有状态函数的原因。</strong></p><h2 id="3-获取捕获列表"><a href="#3-获取捕获列表" class="headerlink" title="3 获取捕获列表"></a>3 获取捕获列表</h2><p><strong>闭包函数是如何找到对应的捕获列表呢？</strong></p><p>Go语言中通过一个 function value 调用函数时，会把对应的<strong>funcval 结构体地址</strong>存入特定寄存器。例如 amd64 平台使用的是 DX 寄存器。</p><p>这样在闭包函数中就可以通过寄存器取出 funcval 结构体的地址，然后加上相应的<strong>偏移量</strong>来找到每一个被捕获的变量。</p><p>所以<strong>Go 语言中闭包就是有捕获列表的 function value</strong>，而没有捕获列表的 function value 直接忽略这个寄存器的值就好了。</p><h2 id="4-捕获变量"><a href="#4-捕获变量" class="headerlink" title="4 捕获变量"></a>4 捕获变量</h2><p>被闭包捕获的变量，要在外层函数闭包函数中表现一致，好像它们在使用同一个变量。为此 Go 语言编译器针对不同情况做了不同的处理。</p><blockquote><p>变量逃逸、参数堆分配、返回值</p></blockquote><h3 id="4-1-没有修改"><a href="#4-1-没有修改" class="headerlink" title="4.1 没有修改"></a>4.1 没有修改</h3><p>被捕获变量 i 除了赋值之外没有被其他地方修改，所以直接拷贝到捕获列表即可。</p><p>就像下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementer</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">i := <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-有修改"><a href="#4-2-有修改" class="headerlink" title="4.2 有修改"></a>4.2 有修改</h3><p>除了初始化赋值外还被修改过，则需要进一步细分。</p><p><strong>捕获的是局部变量</strong></p><p>被闭包捕获的局部变量如果除了初始化赋值外还被修改过，就会分配到堆上。</p><p>闭包导致的局部变量堆分配，也是变量逃逸的一种。</p><p>例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fs := create()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(fs); i++ &#123;</span><br><span class="line">fs[i]()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> (fs [<span class="number">2</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">fs[i] = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create() 函数中的局部变量 i 除了初始化之外，还被修改过(i++)，同时还被闭包捕获，所以会分配到堆上，然后栈上只存储该变量的地址。</p><p>每次 i++ 自增的是堆上的变量 i，而闭包捕获的都是变量 i 的地址，都指向堆上的变量 i。</p><p>最后 i 会自增到 2 ，所以最终闭包打印出来的i值都为2。</p><p><strong>捕获的是参数</strong></p><p>由于参数设计到函数原型，就不能像局部变量这样处理了。</p><p>参数依然通过调用者栈帧传入，但是编译器会把栈上参数拷贝一份到堆上。然后外层函数和闭包函数都使用堆上分配的这个。</p><p><strong>捕获的是返回值</strong></p><p>如果捕获的是返回值，则处理又不同。</p><p>调用者栈帧上依然会分配返回值空间，不过闭包的外层函数会在堆上也分配一个，外层函数和闭包函数都使用堆上分配的这个。</p><p>但是在外层函数返回前，需要把堆上的返回值拷贝到栈上的返回值空间。</p><h3 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3 小结"></a>4.3 小结</h3><p>处理方式虽然多种多样，但是目标只有一个，那就是<strong>保持捕获变量在外层函数和闭包函数中的一致性</strong>。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h2><ul><li><strong>闭包由 funcval 结构体和捕获变量组成</strong>。<pre><code>* funcval 结构体中的 fn 字段指向闭包函数的函数入口* 捕获变量则是当前闭包对象的参数，每个闭包对象维护各种的参数列表。</code></pre></li><li>除初始化外还被修改过的局部变量被闭包捕获后会<strong>分配到堆上，栈上保存的是指向堆上变量的指针</strong>。<pre><code>* 局部变量堆分配，变量逃逸的一种。* 所以这个时候闭包中的局部变量其实就是一个地址，都指向堆上的同一个变量。* 这也是为什么各种 for 循环最后打印出的 i 都是一个值</code></pre></li></ul><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6 参考"></a>6 参考</h2><p><code>https://zh.wikipedia.org/wiki/闭包_(计算机科学)</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Golang Test 工具指令</title>
      <link href="/2021/10/26/Golang/4%20%E5%85%B6%E4%BB%96/Golang%20Test%20%E5%B7%A5%E5%85%B7%E6%8C%87%E4%BB%A4/"/>
      <url>/2021/10/26/Golang/4%20%E5%85%B6%E4%BB%96/Golang%20Test%20%E5%B7%A5%E5%85%B7%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Golang Test 工具指令</p></blockquote><span id="more"></span><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>Go test 测试工具包含示例函数测试 (ExampleXXX)、单元测试 (TestXXX)、基准测试 (BenchmarkXXX)。</p><p>命令格式：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Go test [-c] [-i] [build flags] [packages] [flags for test binary]</span><br></pre></td></tr></table></figure><br>参数解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-c : 编译 go test 成为可执行的二进制文件，但是不运行测试。</span><br><span class="line">-i : 安装测试包依赖的 package，但是不运行测试。</span><br><span class="line"></span><br><span class="line">build flags 是编译过程中常用参数，使用命令 `go help build` 查看帮助</span><br><span class="line"></span><br><span class="line">packages 是关于包管理参数，使用命令 `go help packages` 查看帮助</span><br><span class="line"></span><br><span class="line">flags for test binary 是 test 常用参数，使用命令 `go help testflag` 查看帮助, 部分参数如下：</span><br><span class="line">-test. V : 是否输出全部的单元测试用例（不管成功或者失败），默认没有加上，所以只输出失败的单元测试用例。</span><br><span class="line">-test. Run pattern: 指定正则来运行某个/某些测试用例</span><br><span class="line">-test. Bench patten: 只跑那些性能测试用例</span><br><span class="line">-test. Benchmem : 是否在性能测试的时候输出内存情况</span><br><span class="line">-test. Benchtime t : 性能测试运行的时间，默认是 1 s</span><br><span class="line">-test. Cpuprofile cpu. Out : 是否输出 cpu 性能分析文件，为空则不做 cpu 分析</span><br><span class="line">-test. Memprofile mem. Out : 是否输出内存性能分析文件</span><br><span class="line">-test. Blockprofile block. Out : 是否输出内部 goroutine 阻塞的性能分析文件</span><br><span class="line">-test. Memprofilerate n : 内存分析参数，内存分析的抽样率, 默认 512*1024, 可结合 GOGC=off 来关闭内存回收，对每个内存块的分配进行观察。</span><br><span class="line">-test. Blockprofilerate n: 阻塞事件的分析参数，指定抽样频率，控制 goroutine 阻塞时候打点的纳秒数。默认 1。</span><br><span class="line">-test. Parallel n : 性能测试的程序并行 cpu 数，默认等于 GOMAXPROCS。</span><br><span class="line">-test. Timeout t : 如果测试用例运行时间超过 t，则抛出 panic</span><br><span class="line">-test. Cpu 1,2,4 : 程序运行在哪些 CPU 上面</span><br><span class="line">-test. Short : 将那些运行时间较长的测试用例运行时间缩短</span><br><span class="line">-test. Outputdir : 输出目录</span><br><span class="line">-test. Coverprofile : 测试覆盖率参数，指定输出文件</span><br></pre></td></tr></table></figure><p>测试函数示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test 测试函数</span></span><br><span class="line">Func TestXXX (t *testing. T) &#123; … &#125;</span><br><span class="line"><span class="comment">// benchmark 基准函数</span></span><br><span class="line">Func BenchmarkXXX (b *testing. B) &#123; … &#125;</span><br><span class="line"><span class="comment">// examples 示例函数</span></span><br><span class="line">Func ExamplePrintln () &#123;</span><br><span class="line">    Println (“output”)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行测试函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Go test -v -run=<span class="string">&#x27;TestXXX&#x27;</span></span><br><span class="line"></span><br><span class="line">Go test -v xxx_test. Go -run=<span class="string">&#x27;TestXXX&#x27;</span></span><br><span class="line"></span><br><span class="line">Go test -v xxx_test. Go -test. Run TestXXX</span><br><span class="line"></span><br><span class="line">Go test -v xxx_test. Go -bench=.</span><br><span class="line"></span><br><span class="line">Go test -v xxx_test. Go -bench=XXX</span><br><span class="line"></span><br><span class="line">Go test -v xxx_test. Go -bench=BenchmarkXXX</span><br><span class="line"></span><br><span class="line">Go test -v xxx_test. Go -bench=^BenchmarkXXX$ -run=^$</span><br></pre></td></tr></table></figure><p>-v 参数表示是否通过测试都会显示结果，不加-v 表示只显示未通过的测试</p><p>其他参数：-p -cpu=1,2,4 -args= -parallel -timeout -run -short</p><p>执行基准测试:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Go test -bench=.</span><br><span class="line">Go test -c</span><br><span class="line">./xxx. Test -test. Bench=.</span><br><span class="line">Go test -bench=. -benchtime <span class="number">0.1</span> s</span><br><span class="line">./xxx. Test -test. Bench=. -test. Benchtime=<span class="number">1</span> s</span><br><span class="line">Go test -bench=. -count=<span class="number">2</span></span><br><span class="line">./xxx. Test -test. Bench=. -test. Count=<span class="number">2</span></span><br><span class="line"># -benchmem : 打印用于基准测试的内存分配统计数据</span><br><span class="line">Go test -bench=. -benchmem</span><br><span class="line">./xxx. Test -test. Bench -test. Benchmem</span><br></pre></td></tr></table></figure><h2 id="2-参考："><a href="#2-参考：" class="headerlink" title="2 参考："></a>2 参考：</h2><ul><li><a href="https://deepzz.com/post/the-command-flag-of-go-test.html">Go 测试，go test 工具的具体指令 flag</a></li><li><a href="https://sanyuesha.com/2019/08/21/go-test/">Golang 测试</a></li><li><a href="https://studygolang.com/articles/2491">golang test测试使用</a></li><li><a href="http://doc.golang.ltd/">标准库testing</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
          <category> Packages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go-Package </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Golang Connection Reset by Peer 或 EOF 问题</title>
      <link href="/2021/10/26/Golang/4%20%E5%85%B6%E4%BB%96/http.Client%E8%AF%B7%E6%B1%82%E7%A8%8B%E5%BA%8F%E9%81%87%E5%88%B0%20Connection%20Reset%20by%20Peer%20%E6%88%96%20EOF%20%E9%97%AE%E9%A2%98/"/>
      <url>/2021/10/26/Golang/4%20%E5%85%B6%E4%BB%96/http.Client%E8%AF%B7%E6%B1%82%E7%A8%8B%E5%BA%8F%E9%81%87%E5%88%B0%20Connection%20Reset%20by%20Peer%20%E6%88%96%20EOF%20%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Golang http.Client请求程序遇到Connection Reset by peer 或 EOF 问题</p></blockquote><span id="more"></span><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1 问题"></a>1 问题</h2><p>线上服务经常规律性的出现http.Client请求服务器数据和上报数据时报Connection Reset by peer 和 EOF 错误,在测试环境一直没有出现过；</p><h2 id="2-原因"><a href="#2-原因" class="headerlink" title="2 原因"></a>2 原因</h2><p>原因是线上环境是通过代理转发，存在并发连接数限制，当达到限制时服务器会关闭其中一些连接； 同时客户端请求存在连接复用,如果在收到关闭之前复用了连接就会出现Connection Reset by peer; EOF错误发生在请求建立后读取时，此时服务器已经关闭连接，客户端还没有检测到关闭前读取数据；</p><h2 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3 解决方案"></a>3 解决方案</h2><p>在请求时关闭连接复用，每次都使用新的连接；<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">req, err := NewRequest(<span class="string">&quot;POST&quot;</span>, url, body)</span><br><span class="line">req.Close = <span class="literal">true</span></span><br></pre></td></tr></table></figure><br>或者头部设置连接为关闭状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">req, err := NewRequest(<span class="string">&quot;POST&quot;</span>, url, body)</span><br><span class="line">req.Header.Add(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;close&quot;</span>)</span><br></pre></td></tr></table></figure><p>使用 Transport 取消 HTTP利用连接 DisableKeepAlives 为true时，当前连接只会使用一次</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tr := http.Transport&#123;DisableKeepAlives: <span class="literal">true</span>&#125;</span><br><span class="line">client := http.Client&#123;Transport: &amp;tr&#125;</span><br><span class="line">client.Get(url)</span><br></pre></td></tr></table></figure><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><ul><li><a href="https://www.cnblogs.com/jackluo/p/10452026.html">golang http.client 遇到了 Connection reset by peer 问题</a></li><li><a href="https://blog.csdn.net/weixin_34161032/article/details/86360913">connection reset by peer问题总结及解决方案</a></li><li><a href="https://my.oschina.net/shou1156226/blog/808613">Golang 解决”Connection reset by peer”或”EOF”问题</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Defer</title>
      <link href="/2021/10/26/Golang/0%20%E5%9F%BA%E7%A1%80/%E5%85%B3%E9%94%AE%E5%AD%97/Defer/"/>
      <url>/2021/10/26/Golang/0%20%E5%9F%BA%E7%A1%80/%E5%85%B3%E9%94%AE%E5%AD%97/Defer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Defer 和栈比较相似，<strong>先进后出</strong>，即先注册的 defer 会后执行。</p></blockquote><span id="more"></span><h2 id="1-1-12"><a href="#1-1-12" class="headerlink" title="1 1.12"></a>1 1.12</h2><blockquote><p>本节将的是 Go 1.12 版本的 defer。1.13 和1.14 都有不少优化。</p></blockquote><h3 id="1-1-demo"><a href="#1-1-demo" class="headerlink" title="1.1 demo"></a>1.1 demo</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> B()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// dosomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，编译后伪指令如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r = deferproc(<span class="number">8</span>,B)</span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">goto</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"> ret:</span><br><span class="line">     runtime.deferreturn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>deferproc</code>负责把要执行的函数信息保存起来，也叫 <strong>defer 注册</strong>。</p><p>deferproc()函数会返回0，if 分支和 panic，recover有关，暂时忽略。</p><p>首先调用 deferproc() 进行 defer 注册，然后继续执行后面的逻辑， 直到返回之前通过<code>deferreturn</code>执行注册的 defer 函数。</p><blockquote><p>先注册后调用，所以实现了延迟执行的效果。</p></blockquote><p>defer 信息会注册到一个<strong>链表</strong>，而当前执行的 goroutine 会持有这个链表的头指针。，每个goroutine都要一个结构体g，其中有字段 _defer 就指向defer链表头。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go  395行</span></span><br><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">_defer       *_defer <span class="comment">// innermost defer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>defer 链表中存储的是一个一个的 defer 结构体。<strong>每次注册 defer 时会将当前 defer 链接到链表头，同时 Defer 执行时也是从链表头开始执行</strong>。</p><blockquote><p>所以才会有先进后出的感觉。</p></blockquote><p>defer 结构体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">siz     <span class="type">int32</span> <span class="comment">// 参数和返回值共占多少字节</span></span><br><span class="line">started <span class="type">bool</span> <span class="comment">// 标记defer是否已经执行</span></span><br><span class="line">sp        <span class="type">uintptr</span>  <span class="comment">// 调用者栈指针，通过这个调用者可以判断自己注册的defer是否都执行完了</span></span><br><span class="line">pc        <span class="type">uintptr</span>  <span class="comment">// deferproc 的返回地址</span></span><br><span class="line">fn        *funcval <span class="comment">// 要注册的 funcval</span></span><br><span class="line">_panic    *_panic  <span class="comment">// panic that is running defer</span></span><br><span class="line">link      *_defer <span class="comment">// 链接到前一个注册的 _defer 结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-参数与闭包"><a href="#1-2-参数与闭包" class="headerlink" title="1.2 参数与闭包"></a>1.2 参数与闭包</h3><p>需要关注的是 defer 传参和闭包变量捕获机制。</p><p><strong>普通参数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(a) <span class="comment">// 1</span></span><br><span class="line">&#125;(a)</span><br><span class="line">a = a + b</span><br><span class="line">fmt.Println(a, b) <span class="comment">// 3,2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 defer function 只使用到了一个 int 类型的参数。</p><p>所以会直接将参数a的<strong>值</strong>拷贝到 defer function 对应的栈空间中。</p><p>等函数执行完成，返回之前就会执行这个 defer function，将 a 的值打印出来。</p><p>由于是拷贝的<strong>值</strong>，所以后续a=a+b 修改变量a的值和和这个  defer function 中的参数 a 已经完全没有关系了，最终打印出a的值还是传入时的1。</p><p><strong>引入普通参数的 defer function 参数值在执行 defer 时就确定了。</strong></p><p><strong>闭包变量</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">a = a + b</span><br><span class="line">fmt.Println(a, b) <span class="comment">// 5 2</span></span><br><span class="line">&#125;(b)</span><br><span class="line">a = a + b</span><br><span class="line">fmt.Println(a, b) <span class="comment">// 3 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中 defer function 除了参数 b 之外还引用到了 外层局部变量 a。</p><p>这里就形成了<strong>闭包</strong>。</p><blockquote><p>闭包也是一个 function value。</p></blockquote><p>同时由于捕获变量a除了初始化赋值之外，还被修改过，所以局部变量a改为<strong>堆分配</strong>，栈上只存储a的地址。</p><p>所以后续a的修改也会影响到defer function，导致最终打印出a的值为5</p><p><strong>引入闭包变量的 defer function 参数值需要到 defer function 执行时才能确定。</strong></p><h3 id="1-3-缺点"><a href="#1-3-缺点" class="headerlink" title="1.3 缺点"></a>1.3 缺点</h3><ul><li>1）defer 在堆上分配</li><li>2）使用链表注册 defer 信息</li></ul><p>以上两点导致了 defer 很慢。</p><p>go 1.13 1.14 版本分别对上述问题进行了不同的优化。</p><h2 id="2-优化"><a href="#2-优化" class="headerlink" title="2 优化"></a>2 优化</h2><h3 id="2-1-1-13"><a href="#2-1-1-13" class="headerlink" title="2.1 1.13"></a>2.1 1.13</h3><p>Go 1.12 中通过 runtime.deferproc() 函数注册 defer，将 _defer结构体分配在<strong>堆</strong>上。</p><p>Go 1.13 中通过编译器优化，生成局部变量，将 defer 信息分配在<strong>栈</strong>上。然后通过 runtime.deferprocStack() 将 _defer 结构体注册到链表中。</p><p>1.13 主要优化点在于减少 defer 信息的堆分配。由于循环中的 defer 调用无法进行编译器优化，因此只能使用 1.12 版本中的处理方法。所以 defer 结构体中增加了一个字段，用于标识是否为堆分配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 、src/runtime/runtime2.go 861 行</span></span><br><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">heap    <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.13 版本 defer 官方提供的数据是性能提升 30%。</p><h3 id="2-2-1-14"><a href="#2-2-1-14" class="headerlink" title="2.2 1.14"></a>2.2 1.14</h3><p>对于能够显式优化的部分，进行了优化。</p><p>比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> A1(i, <span class="number">2</span>*i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> A2(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">(m, n <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(m, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>A1 优化</strong></p><p>函数A中的第一个 defer，<code>defer A1(i, 2*i)</code>编译器会对其进行优化，直接在函数A return 之前，调用A1函数，直接省去了构造 defer 链表项和注册到 链表的过程。</p><p>编译后代码可以看做如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a,b <span class="type">int</span>=i,<span class="number">2</span>*i</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    A1(a,b)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明了调用A1需要的两个变量，a,b，然后在 return 之前调用了 A1函数。</p><p>降低消耗的同时，也实现了延迟执行的效果。</p><p><strong>A2优化</strong></p><p>第二个 defer <code>defer A2(&quot;hello&quot;, &quot;world&quot;)</code>就不能这样处理了，应该这个defer 需要到执行阶段才能确定是否需要调用。Go 语言用一个标识变量 df 来解决这个问题。</p><p>df 中的每一位都用来标识一个 defer 是否需要被执行。比如之前的 defer A1 需要执行，所以就把第一位置为1，即<code>df|=1</code>。</p><p>执行前判定对应标识位是否为1，同时执行之前还需要将标识位置0，防止重置执行。</p><p>defer A1 调用如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> df <span class="type">byte</span></span><br><span class="line"><span class="keyword">var</span> a,b <span class="type">int</span>=i,<span class="number">2</span>*i</span><br><span class="line"></span><br><span class="line">    df|=<span class="number">1</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> df&amp;<span class="number">1</span>&gt;<span class="number">0</span>&#123;</span><br><span class="line">        df=df&amp;^<span class="number">1</span></span><br><span class="line">        A1(a,b)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的方法处理 defer A2</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> df <span class="type">byte</span></span><br><span class="line"><span class="keyword">var</span> a,b <span class="type">int</span>=i,<span class="number">2</span>*i</span><br><span class="line"><span class="keyword">var</span> m,n <span class="type">int</span>=<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span></span><br><span class="line">    df|=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i&gt;<span class="number">1</span>&#123;</span><br><span class="line">        df |=<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">if</span> df&amp;<span class="number">2</span>&gt;<span class="number">0</span>&#123;</span><br><span class="line">        df=df&amp;^<span class="number">2</span></span><br><span class="line">        A2(m,n)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> df&amp;<span class="number">1</span>&gt;<span class="number">0</span>&#123;</span><br><span class="line">        df=df&amp;^<span class="number">1</span></span><br><span class="line">        A1(a,b)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Go1.14 defer 优化就是通过编译期置入代码，把defer函数的执行逻辑展开在所属函数内，从而免于创建 _defer 结构体，而且不需要注册到 defer 链表。</strong></p><p>Go 语言称这种方式为 open coded defer。</p><p>但是和 1.13 版本一样，这种方式依然不适用于 循环中的 defer，所以1.14中版本还是保留了 1.12 版本的 defer处理方式。</p><p>1.14 版本 defer 性能提升了一个数量级。</p><p><strong>栈扫描</strong></p><p>性能提升也不是没有代价的，像这样展开后的 defer 如果在执行之前，出现了 panic 或者执行了 runtime.Goexit ，此时就会直接跳去执行 defer 链表，所以后面的defer 展开代码就无法执行了。</p><p>于是 Go1.14 又在 defer 中增加了几个字段，同时通过栈扫描的方式，来执行这些原本无法执行的 defer。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 、src/runtime/runtime2.go 861 行</span></span><br><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">openDefer <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">fd   unsafe.Pointer <span class="comment">// funcdata for the function associated with the frame</span></span><br><span class="line">varp <span class="type">uintptr</span>        <span class="comment">// value of varp for the stack frame</span></span><br><span class="line">framepc <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助这些信息，可以找到未注册到链表的 defer 函数并按照正确的顺序执行。</p><p><strong>这就导致 1.14 版本中 defer 变快的同时，panic 变得更慢了。</strong></p><blockquote><p>官方这样优化肯定是有自己的考量，毕竟 panic 发生的几率比 defer 低。</p></blockquote><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p><strong>defer 注册流程</strong></p><ul><li>1）deferproc 进行 defer 注册。</li><li>2）return之前通过 runtime.deferreturn() 调用注册的 defer 函数。</li></ul><p><strong>具体执行逻辑</strong></p><ul><li>1）从当前 goroutine 的字段 defer 中拿到 defer 链表</li><li>2）从链表中拿到第一个要执行的 defer 结构体</li><li>3）根据 defer 结构体的 fn 字段找到对应的 funcval</li><li>4）根据 funcval 找打对应的函数入口地址</li><li>5）执行具体函数</li></ul><p><strong>优化记录</strong></p><ul><li><p>1.1~1.12：堆分配</p><ul><li>编译期将 defer 关键字转换为 deferproc ，并在调用defer关键字的函数返回之前插入 runtime.deferreturn 。</li><li>运行时 runtime.deferproc 会将一个新的<code>runtime._defer</code>结构体追加到当前 Goroutine 的 defer 链表头。</li><li>运行时调用 runtime.deferreturn 会从当前 goroutine 的 defer 链表中取出 <code>runtime._defer</code>结构并依次执行</li></ul></li><li>1.13：栈分配<ul><li>当该关键字在函数体中最多执行一次时，编译期间会将结构体分配到栈上，并调用 runtime.deferprocStack</li></ul></li><li>1.14：开放编码<ul><li>编译期间判断 <code>defer</code> 关键字、<code>return</code> 语句的个数确定是否开启开放编码优化；</li><li>如果 <code>defer</code> 关键字的执行可以在编译期间确定，会在函数返回前直接插入相应的代码，否则会由运行时的  runtime.deferreturn 处理。</li></ul></li></ul><p><strong>问题</strong></p><p><strong>defer 调用时机与执行顺序</strong></p><p>deferproc 注册时是往链表头注册，而调用时也是从链表头开始调用，所以是先进后出的效果。</p><p><strong>参数问题</strong></p><p>注册时就会拷贝 defer 函数的参数(<strong>参数预计算</strong>)，所以如果是参数是值类型，注册时就确定了，如果是指针类型，则后续的修改也会影响到 defer 函数中的参数。</p><blockquote><p>可以简单理解为 defer 参数在调用defer关键字时确定。但是如果传的是指针那被修改也就说得通了。</p></blockquote><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><code>https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 关键字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Map</title>
      <link href="/2021/10/26/Golang/0%20%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Map/"/>
      <url>/2021/10/26/Golang/0%20%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Map/</url>
      
        <content type="html"><![CDATA[<blockquote><p>map 的底层数据结构和实现原理</p></blockquote><span id="more"></span><h2 id="1-基础使用"><a href="#1-基础使用" class="headerlink" title="1 基础使用"></a>1 基础使用</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>核心特征包含下述三点：</p><ul><li>存储基于 key-value 对映射的模式；</li><li>基于 key 维度实现存储数据的去重；</li><li>读、写、删操作控制，时间复杂度 O(1).</li></ul><h3 id="1-2-初始化"><a href="#1-2-初始化" class="headerlink" title="1.2 初始化"></a>1.2 初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myMap1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>,<span class="number">2</span>)</span><br><span class="line">myMap2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">myMap3 :=<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;</span><br><span class="line">  <span class="number">1</span>:<span class="number">2</span>,</span><br><span class="line">  <span class="number">3</span>:<span class="number">4</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>map 中，key 的数据类型必须为可比较的类型，chan、map、func不可比较</li></ul><h3 id="1-3-读"><a href="#1-3-读" class="headerlink" title="1.3 读"></a>1.3 读</h3><ul><li>直接读，倘若 key 存在，则获取到对应的 val，倘若 key 不存在或者 map 未初始化，会返回 val 类型的零值作为兜底.</li><li><p>读的同时添加一个 bool 类型的 flag 标识是否读取成功. 倘若 ok == false，说明读取失败， key 不存在，或者 map 未初始化.</p><h3 id="1-4-写"><a href="#1-4-写" class="headerlink" title="1.4 写"></a>1.4 写</h3></li><li><p>如果 map 未初始化，直接执行写操作会导致 panic</p><h3 id="1-5-删除"><a href="#1-5-删除" class="headerlink" title="1.5 删除"></a>1.5 删除</h3></li><li><p>执行 delete 方法时，倘若 key 存在，则会从 map 中将对应的 key-value 对删除；倘若 key 不存在或 map 未初始化，则方法直接结束，不会产生显式提示</p><h3 id="1-6-遍历"><a href="#1-6-遍历" class="headerlink" title="1.6 遍历"></a>1.6 遍历</h3></li></ul><ul><li>基于 k,v 依次承接 map 中的 key-value 对<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> myMap&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>基于 k 依次承接 map 中的 key，不关注 val 的取值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> myMap&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在执行 map 遍历操作时，获取的 key-value 对并没有一个固定的顺序，因此前后两次遍历顺序可能存在差异</p></li></ul><h3 id="1-7-并发冲突"><a href="#1-7-并发冲突" class="headerlink" title="1.7 并发冲突"></a>1.7 并发冲突</h3><p>map 不是并发安全的数据结构，倘若存在并发读写行为，会抛出 fatal error.<br>具体规则是：</p><ul><li>并发读没有问题；</li><li>并发读写中的“写”是广义上的，包含写入、更新、删除等操作；</li><li>读的时候发现其他 goroutine 在并发写，抛出 fatal error；</li><li>写的时候发现其他 goroutine 在并发写，抛出 fatal error.<blockquote><p>fatal error，是一种比 panic 更严重的错误，无法使用 recover 操作捕获.</p></blockquote></li></ul><h2 id="2-核心原理"><a href="#2-核心原理" class="headerlink" title="2 核心原理"></a>2 核心原理</h2><p>hashmap 就是在算法上基于 hash 实现 key 的映射和寻址；在数据结构上基于桶数组实现 key-value 对的存储.</p><ul><li>通过哈希方法取得 key 的 hash 值</li><li>hash 值对桶数组长度取模，确定其所属的桶；</li><li>在桶中插入 key-value 对.</li><li>相同的 key 必然产生相同的 hash 值，因此能映射到相同的桶中，通过桶内遍历的方式锁定对应的 key-value 对</li></ul><h3 id="2-1-hash"><a href="#2-1-hash" class="headerlink" title="2.1 hash"></a>2.1 hash</h3><blockquote><p>hash 译作散列，是一种将任意长度的输入压缩到某一固定长度的输出摘要的过程，由于这种转换属于压缩映射，输入空间远大于输出空间，因此不同输入可能会映射成相同的输出结果. 此外，hash在压缩过程中会存在部分信息的遗失，因此这种映射关系具有不可逆的特质.</p></blockquote><ul><li>hash 的可重入性：相同的 key，必然产生相同的 hash 值</li><li>hash 的离散性：只要两个 key 不相同，不论其相似度的高低，产生的 hash 值会在整个输出域内均匀地离散化</li><li>hash 的离散性：只要两个 key 不相同，不论其相似度的高低，产生的 hash 值会在整个输出域内均匀地离散化</li><li>hash 冲突：由于输入域（key）无穷大，输出域（hash 值）有限，因此必然存在不同 key 映射到相同 hash 值的情况，称之为 hash 冲突</li></ul><h3 id="2-2-桶数组"><a href="#2-2-桶数组" class="headerlink" title="2.2 桶数组"></a>2.2 桶数组</h3><p>map 中，会通过长度为 2 的整数次幂的桶数组进行 key-value 对的存储：</p><ul><li>每个桶固定可以存放 8 个 key-value 对；</li><li><p>倘若超过 8 个 key-value 对打到桶数组的同一个索引当中，此时会通过创建桶链表的方式来化解这一问题.</p><h3 id="2-3-hash-冲突"><a href="#2-3-hash-冲突" class="headerlink" title="2.3 hash 冲突"></a>2.3 hash 冲突</h3></li><li><p>由于 hash 冲突的存在，不同 key 可能存在相同的 hash 值; hash 值会对桶数组长度取模，因此不同 hash 值可能被打到同一个桶中; 不同的 key-value 可能被映射到 map 的同一个桶当中</p></li><li>拉链法: 将命中同一个桶的元素通过链表的形式进行链接，因此很便于动态扩展.</li><li>开放寻址法: 在插入新条目时，会基于一定的探测策略持续寻找，直到找到一个可用于存放数据的空位为止</li><li>map 的插入写流程, 结合了拉链法和开放寻址法两种思路<ul><li>桶数组中的每个桶，严格意义上是一个单向桶链表，以桶为节点进行串联</li><li>每个桶固定可以存放 8 个 key-value 对</li><li>当 key 命中一个桶时，首先根据开放寻址法，在桶的 8 个位置中寻找空位进行插入</li><li>倘若桶的 8 个位置都已被占满，则基于桶的溢出桶指针，找到下一个桶，重复第（3）步</li><li>倘若遍历到链表尾部，仍未找到空位，则基于拉链法，在桶链表尾部续接新桶，并插入 key-value 对</li></ul></li></ul><h3 id="2-4-扩容优化性能"><a href="#2-4-扩容优化性能" class="headerlink" title="2.4 扩容优化性能"></a>2.4 扩容优化性能</h3><blockquote><p>map 的桶数组长度固定不变，那么随着 key-value 对数量的增长，当一个桶下挂载的 key-value 达到一定的量级，此时操作的时间复杂度会趋于线性, 导致性能不可接受</p></blockquote><p>扩容机制:</p><ul><li>扩容分为增量扩容和等量扩容</li><li>当桶内 key-value 总数/桶数组长度 &gt; 6.5 时发生增量扩容，桶数组长度增长为原值的两倍</li><li>当桶内溢出桶数量大于等于 2^B 时( B 为桶数组长度的指数，B 最大取 15)，发生等量扩容，桶的长度保持为原值</li><li>采用渐进扩容的方式，当桶被实际操作到时，由使用者负责完成数据迁移，避免因为一次性的全量数据迁移引发性能抖动</li></ul><h2 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3 数据结构"></a>3 数据结构</h2><h3 id="3-1-hmap"><a href="#3-1-hmap" class="headerlink" title="3.1 hmap"></a>3.1 hmap</h3><p><img src="StarDust/source/_posts/技术/Golang/0%20基础/数据结构/Map/file-20250305235454430.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="type">int</span> </span><br><span class="line">    flags     <span class="type">uint8</span></span><br><span class="line">    B         <span class="type">uint8</span>  </span><br><span class="line">    noverflow <span class="type">uint16</span> </span><br><span class="line">    hash0     <span class="type">uint32</span> </span><br><span class="line">    buckets    unsafe.Pointer </span><br><span class="line">    oldbuckets unsafe.Pointer </span><br><span class="line">    nevacuate  <span class="type">uintptr</span>       </span><br><span class="line">    extra *mapextra </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>count：map 中的 key-value 总数</li><li>flags：map 状态标识，可以标识出 map 是否被 goroutine 并发读写</li><li>B：桶数组长度的指数，桶数组长度为 2^B</li><li>noverflow：map 中溢出桶的数量</li><li>hash0：hash 随机因子，生成 key 的 hash 值时会使用到</li><li>buckets：桶数组</li><li>oldbuckets：扩容过程中老的桶数组</li><li>nevacuate：扩容时的进度标识，index 小于 nevacuate 的桶都已经由老桶转移到新桶中</li><li>extra：预申请的溢出桶</li></ul><h3 id="3-2-mapextra"><a href="#3-2-mapextra" class="headerlink" title="3.2 mapextra"></a>3.2 mapextra</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">    overflow    *[]*bmap</span><br><span class="line">    oldoverflow *[]*bmap</span><br><span class="line">  </span><br><span class="line">    nextOverflow *bmap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 map 初始化时，如果容量过大，会提前申请好一批溢出桶，方便后续使用，这部分溢出桶存放在 hmap.mapextra 当中</p><ul><li>mapextra.overflow：供桶数组 buckets 使用的溢出桶</li><li>mapextra.oldoverFlow: 扩容流程中，供老桶数组 oldBuckets 使用的溢出桶</li><li>mapextra.nextOverflow：下一个可用的溢出桶</li></ul><h3 id="3-3-bmap"><a href="#3-3-bmap" class="headerlink" title="3.3 bmap"></a>3.3 bmap</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bucketCnt = <span class="number">8</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>bmap 就是 map 中的桶，可以存储 8 组 key-value 对的数据，以及一个指向下一个溢出桶的指针</li><li>每组 key-value 对数据包含 key 高 8 位 hash 值 tophash，key 和 val 三部分</li><li>tophash、key 和 val 的数据长度固定，因此可以通过内存地址偏移的方式寻找到后续的 key 数组、val 数组以及溢出桶指针</li></ul><h2 id="4-构造方法"><a href="#4-构造方法" class="headerlink" title="4 构造方法"></a>4 构造方法</h2><blockquote><p>创建 map 时，会调用 runtime/map.go 文件中的 makemap 方法</p></blockquote><h3 id="4-1-makemap"><a href="#4-1-makemap" class="headerlink" title="4.1 makemap"></a>4.1 makemap</h3><ul><li>hint 为 map 拟分配的容量；在分配前，会提前对拟分配的内存大小进行判断，倘若超限，会将 hint 置为零</li><li>通过 new 方法初始化 hmap</li><li>调用 fastrand，构造 hash 因子：hmap.hash0</li><li>大致上基于 log2(B) &gt;= hint 的思路,计算桶数组的容量 B</li><li>调用 makeBucketArray 方法，初始化桶数组 hmap.buckets</li><li>倘若 map 容量较大，会提前申请一批溢出桶 hmap.extra</li></ul><h3 id="4-2-overLoadFactor"><a href="#4-2-overLoadFactor" class="headerlink" title="4.2 overLoadFactor"></a>4.2 overLoadFactor</h3><p>通过 overLoadFactor 方法，对 map 预分配容量和桶数组长度指数进行判断，决定是否仍需要增长 B 的数值</p><ul><li>map 预分配容量小于等于 8，B 取 0，桶的个数为 1</li><li>保证 map 预分配容量小于等于桶数组长度 * 6.5</li></ul><h3 id="4-3-makeBucketArray"><a href="#4-3-makeBucketArray" class="headerlink" title="4.3 makeBucketArray"></a>4.3 makeBucketArray</h3><ul><li>makeBucketArray 会为 map 的桶数组申请内存，在桶数组的指数 b &gt;= 4时（桶数组的容量 &gt;= 52 ），会需要提前创建溢出桶.</li><li>通过 base 记录桶数组的长度，不包含溢出桶；通过 nbuckets 记录累加上溢出桶后，桶数组的总长度.</li><li>调用 newarray 方法为桶数组申请内存空间，连带着需要初始化的溢出桶</li><li>倘若 base != nbuckets，说明需要创建溢出桶，会基于地址偏移的方式，通过 nextOverflow 指向首个溢出桶的地址</li><li>倘若需要创建溢出桶，会在将最后一个溢出桶的 overflow 指针指向 buckets 数组，以此来标识申请的溢出桶已经用完</li></ul><h2 id="5-读流程"><a href="#5-读流程" class="headerlink" title="5 读流程"></a>5 读流程</h2><blockquote><p>map 读操作最终会走进 runtime/map.go 的 mapaccess 方法中</p><h3 id="5-1-读流程概览"><a href="#5-1-读流程概览" class="headerlink" title="5.1 读流程概览"></a>5.1 读流程概览</h3></blockquote><p>map 读流程主要分为以下几步：</p><ul><li>根据 key 取 hash 值</li><li>根据 hash 值对桶数组取模，确定所在的桶</li><li>沿着桶链表依次遍历各个桶内的 key-value 对</li><li>命中相同的 key，则返回 value；倘若 key 不存在，则返回零值</li></ul><h3 id="5-2-mapaccess-方法"><a href="#5-2-mapaccess-方法" class="headerlink" title="5.2 mapaccess 方法"></a>5.2 mapaccess 方法</h3><ul><li>倘若 map 未初始化，或此时存在 key-value 对数量为 0，直接返回零值</li><li>倘若发现存在其他 goroutine 在写 map，直接抛出并发读写的 fatal error；其中，并发写标记，位于 hmap.flags 的第 3 个 bit 位</li><li>通过 maptype.hasher() 方法计算得到 key 的 hash 值，并对桶数组长度取模，取得对应的桶</li><li>在取桶时，会关注当前 map 是否处于扩容的流程，倘若是的话，需要在老的桶数组 oldBuckets 中取桶，通过 evacuated 方法判断桶数据是已迁到新桶还是仍存留在老桶，倘若仍在老桶，需要取老桶进行遍历<ul><li>在取老桶前，会先判断 map 的扩容流程是否是增量扩容，倘若是的话，说明老桶数组的长度是新桶数组的一半，需要将桶长度值 m 除以 2</li><li>取老桶时，会调用 evacuated 方法判断数据是否已经迁移到新桶. 判断的方式是，取桶中首个 tophash 值，倘若该值为 2,3,4 中的一个，都代表数据已经完成迁移</li></ul></li><li>取 key hash 值的高 8 位值 top. 倘若该值 &lt; 5，会累加 5，以避开 0 ~ 4 的取值. 因为这几个值会用于枚举</li><li>开启两层 for 循环进行遍历流程，外层基于桶链表，依次遍历首个桶和后续的每个溢出桶，内层依次遍历一个桶内的 key-value 对</li></ul><h2 id="6-写流程"><a href="#6-写流程" class="headerlink" title="6 写流程"></a>6 写流程</h2><h3 id="6-1-写流程梳理"><a href="#6-1-写流程梳理" class="headerlink" title="6.1 写流程梳理"></a>6.1 写流程梳理</h3><p>map 写流程主要分为以下几步：</p><ul><li>根据 key 取 hash 值；</li><li>根据 hash 值对桶数组取模，确定所在的桶；</li><li>倘若 map 处于扩容，则迁移命中的桶，帮助推进渐进式扩容；</li><li>沿着桶链表依次遍历各个桶内的 key-value 对；</li><li>倘若命中相同的 key，则对 value 中进行更新；</li><li>倘若 key 不存在，则插入 key-value 对；</li><li>倘若发现 map 达成扩容条件，则会开启扩容模式，并重新返回第（2）步</li></ul><h3 id="6-2-mapassign"><a href="#6-2-mapassign" class="headerlink" title="6.2  mapassign"></a>6.2  mapassign</h3><ul><li>写操作时，倘若 map 未初始化，直接 panic</li><li>倘若其他 goroutine 在进行写或删操作，抛出并发写 fatal error</li><li>通过 maptype.hasher() 方法求得 key 对应的 hash 值</li><li>通过异或位运算，将 map.flags 的第 3 个 bit 位置为 1，添加写标记</li><li>倘若 map 的桶数组 buckets 未空，则对其进行初始化</li><li>找到当前 key 对应的桶索引 bucket</li><li>倘若发现当前 map 正处于扩容过程，则帮助其渐进扩容</li><li>从 map 的桶数组 buckets 出发，结合桶索引和桶容量大小，进行地址偏移，获得对应桶 b</li><li>取得 key 的高 8 位 tophash</li><li>提前声明好的三个指针，用于指向存放 key-value 的空槽</li><li>开启两层 for 循环，外层沿着桶链表依次遍历，内层依次遍历桶内的 key-value 对</li><li>倘若 key 的 tophash 和当前位置 tophash 不同，则会尝试将 inserti、insertk elem 调整指向首个空位，用于后续的插入操作</li><li>倘若找到了相等的 key，则执行更新操作，并且直接跳转到方法的 done 标志位处，进行收尾处理</li><li>倘若没找到相等的 key，会在执行插入操作前，判断 map 是否需要开启扩容模式</li><li>倘若遍历完桶链表，都没有为当前待插入的 key-value 对找到空位，则会创建一个新的溢出桶，挂载在桶链表的尾部，并将 inserti、insertk、elem 指向溢出桶的首个空位</li><li>将 tophash、key、value 插入到取得空位中，并且将 map 的 key-value 对计数器 count 值加 1</li><li>收尾环节，再次校验是否有其他协程并发写，倘若有，则抛 fatal error. 将 hmap.flags 中的写标记抹去，然后退出方法</li></ul><h2 id="7-删流程"><a href="#7-删流程" class="headerlink" title="7 删流程"></a>7 删流程</h2><h3 id="7-1-删流程梳理"><a href="#7-1-删流程梳理" class="headerlink" title="7.1 删流程梳理"></a>7.1 删流程梳理</h3><ul><li>根据 key 取 hash 值</li><li>根据 hash 值对桶数组取模，确定所在的桶</li><li>倘若 map 处于扩容，则迁移命中的桶，帮助推进渐进式扩容</li><li>沿着桶链表依次遍历各个桶内的 key-value 对</li><li>倘若命中相同的 key，删除对应的 key-value 对；并将当前位置的 tophash 置为 emptyOne，表示为空</li><li>倘若当前位置为末位，或者下一个位置的 tophash 为 emptyRest，则沿当前位置向前遍历，将毗邻的 emptyOne 统一更新为 emptyRest</li></ul><h2 id="8-遍历流程"><a href="#8-遍历流程" class="headerlink" title="8 遍历流程"></a>8 遍历流程</h2><p>map 的遍历流程首先会走进 runtime/map.go 的 mapiterinit() 方法当中，初始化用于遍历的迭代器 hiter；接着会调用 runtime/map.go 的 mapiternext() 方法开启遍历流程</p><h3 id="8-1-迭代器数据结构"><a href="#8-1-迭代器数据结构" class="headerlink" title="8.1 迭代器数据结构"></a>8.1 迭代器数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    key         unsafe.Pointer </span><br><span class="line">    elem        unsafe.Pointer </span><br><span class="line">    t           *maptype</span><br><span class="line">    h           *hmap</span><br><span class="line">    buckets     unsafe.Pointer </span><br><span class="line">    bptr        *bmap         </span><br><span class="line">    overflow    *[]*bmap      </span><br><span class="line">    oldoverflow *[]*bmap      </span><br><span class="line">    startBucket <span class="type">uintptr</span>       </span><br><span class="line">    offset      <span class="type">uint8</span>         </span><br><span class="line">    wrapped     <span class="type">bool</span>         </span><br><span class="line">    B           <span class="type">uint8</span></span><br><span class="line">    i           <span class="type">uint8</span></span><br><span class="line">    bucket      <span class="type">uintptr</span></span><br><span class="line">    checkBucket <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>key：指向遍历得到 key 的指针</li><li>value：指向遍历得到 value 的指针</li><li>t：map 类型，包含了 key、value 类型大小等信息</li><li>h：map 的指针</li><li>bptr：当前遍历到的桶</li><li>startBucket：遍历起始位置的桶索引</li><li>offset：遍历起始位置的 key-value 对索引</li><li>wrapped：遍历是否穿越桶数组尾端回到头部了</li><li>i：当前遍历到的 key-value 对在桶中的索引</li><li>checkBucket：因为扩容流程的存在，需要额外检查的桶</li></ul><h2 id="9-扩容流程"><a href="#9-扩容流程" class="headerlink" title="9 扩容流程"></a>9 扩容流程</h2><h3 id="9-1-扩容类型"><a href="#9-1-扩容类型" class="headerlink" title="9.1 扩容类型"></a>9.1 扩容类型</h3><p>map 的扩容类型分为两类，一类叫做增量扩容，一类叫做等量扩容</p><ul><li>增量扩容<ul><li>扩容后，桶数组的长度增长为原长度的 2 倍</li><li>降低每个桶中 key-value 对的数量，优化 map 操作的时间复杂度</li></ul></li><li>等量扩容<ul><li>扩容后，桶数组的长度和之前保持一致；但是溢出桶的数量会下降</li><li>提高桶主体结构的数据填充率，减少溢出桶数量，避免发生内存泄漏</li></ul></li></ul><h3 id="9-2-扩容触发"><a href="#9-2-扩容触发" class="headerlink" title="9.2 扩容触发"></a>9.2 扩容触发</h3><ul><li>只有 map 的写流程可能开启扩容模式</li><li>写 map 新插入 key-value 对之前，会发起是否需要扩容的逻辑判断</li><li>根据 hmap 的 oldbuckets 是否空，可以判断 map 此前是否已开启扩容模式</li><li>倘若此前未进入扩容模式，且 map 中 key-value 对的数量超过 8 个，且大于桶数组长度的 6.5 倍，则进入增量扩容</li><li>倘若溢出桶的数量大于 2^B 个（即桶数组的长度；B 大于 15 时取15），则进入等量扩容</li></ul><h3 id="9-3-扩容迁移规则"><a href="#9-3-扩容迁移规则" class="headerlink" title="9.3 扩容迁移规则"></a>9.3 扩容迁移规则</h3><ul><li>在等量扩容中，新桶数组长度与原桶数组相同；</li><li>key-value 对在新桶数组和老桶数组的中的索引号保持一致；</li><li>在增量扩容中，新桶数组长度为原桶数组的两倍；</li><li>把新桶数组中桶号对应于老桶数组的区域称为 x 区域，新扩展的区域称为 y 区域.</li><li>实际上，一个 key 属于哪个桶，取决于其 hash 值对桶数组长度取模得到的结果，因此依赖于其低位的 hash 值结果.；</li><li>在增量扩容流程中，新桶数组的长度会扩展一位，假定 key 原本从属的桶号为 i，则在新桶数组中从属的桶号只可能是 i （x 区域）或者 i + 老桶数组长度（y 区域）；</li><li>当 key 低位 hash 值向左扩展一位的 bit 位为 0，则应该迁往 x 区域的 i 位置；倘若该 bit 位为 1，应该迁往 y 区域对应的 i + 老桶数组长度的位置.</li></ul><h3 id="9-4-渐进式扩容"><a href="#9-4-渐进式扩容" class="headerlink" title="9.4 渐进式扩容"></a>9.4 渐进式扩容</h3><ul><li>map 采用的是渐进扩容的方式，避免因为一次性的全量数据迁移引发性能抖动.</li><li>当每次触发写、删操作时，会为处于扩容流程中的 map 完成两组桶的数据迁移<ul><li>一组桶是当前写、删操作所命中的桶</li><li>另一组桶是，当前未迁移的桶中，索引最小的那个桶</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Function</title>
      <link href="/2021/10/26/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/Function/"/>
      <url>/2021/10/26/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/Function/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Go 语言中 function 是一等公民，可以用作参数、返回值，也可以赋值给变量。</p></blockquote><span id="more"></span><h1 id="function"><a href="#function" class="headerlink" title="function"></a>function</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">a.name = <span class="string">&quot;Hi &quot;</span> + a.name</span><br><span class="line"><span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := A&#123;name: <span class="string">&quot;17x&quot;</span>&#125;</span><br><span class="line">fmt.Println(a.GetName())</span><br><span class="line">fmt.Println(A.GetName(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>a.Name()</code>和 <code>A.Name(a)</code> 两种写法效果是一样的，前者只是 Go 语言提供的语法糖。</p><p>具体证明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t1 := reflect.TypeOf(A.GetName)</span><br><span class="line">t2 := reflect.TypeOf(NameOfA)</span><br><span class="line">fmt.Println(t1 == t2) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NameOfA</span><span class="params">(a A)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">a.name = <span class="string">&quot;Hi &quot;</span> + a.name</span><br><span class="line"><span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>t1 t2 分别为A.Name方法 和 NameOfA 函数的类型，t1=t2 说明二者是相同的。</p><p><strong>Go 语言中函数类型只与参数和返回值有关</strong>。所以这两个类型值相等就可以证明，<strong>方法本质上就是普通的函数</strong>，而方法接收者就是隐含的第一个参数。</p><h2 id="2-2-值-指针接收者"><a href="#2-2-值-指针接收者" class="headerlink" title="2 2.值/指针接收者"></a>2 2.值/指针接收者</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">a.name = <span class="string">&quot;Hi &quot;</span> + a.name</span><br><span class="line"><span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span></span> SetName() <span class="type">string</span> &#123;</span><br><span class="line">a.name = <span class="string">&quot;Hi &quot;</span> + a.name</span><br><span class="line"><span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经知道了，方法本质上就是普通的函数，而<strong>方法接收者就是隐含的第一个参数</strong>。</p><p>Go 语言中只有值拷贝，不存在引用拷贝的说法。所以 GetName() 第一个参数为 A 类型，SetName 则为 *A 类型。</p><p>虽然都是值拷贝，但是指针接收者拷贝的是地址，所以可以修改外部变量的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := A&#123;name: <span class="string">&quot;17x&quot;</span>&#125;</span><br><span class="line">   pa:=&amp;a</span><br><span class="line">   <span class="comment">// 通过值调用指针接收者的方法</span></span><br><span class="line">   fmt.Println(a.SetName())</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   fmt.Println(pa.GetName())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过值调用指针接收者的方法，通过指针调用值接收者的方法 都是可以的？这又是什么情况？</strong></p><p>如果没有涉及到接口的话，这也是 Go 语言提供的语法糖。</p><p><strong>编译阶段</strong>就会转换成对应的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pa.GetName()--&gt;(*pa).GetName()</span><br><span class="line">a.SetName()--&gt;(&amp;a).SetName()</span><br></pre></td></tr></table></figure><p>由于该语法糖是在<strong>编译期间</strong>发挥作用的，编译期间无法获取地址的字面量，也就不能借助语法糖进行转换了，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法进行转换导致编译失败 </span></span><br><span class="line">A&#123;name: <span class="string">&quot;17x&quot;</span>&#125;.SetName()</span><br></pre></td></tr></table></figure><h2 id="3-赋值给变量"><a href="#3-赋值给变量" class="headerlink" title="3 赋值给变量"></a>3 赋值给变量</h2><p><strong>把 function 赋值给变量是怎么回事？</strong></p><p>Go 语言中把函数作为变量、参数和返回值时都是以 Function Value 的形式存在的，闭包也只是一个有捕获列表的 Function Value 而已。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := A&#123;name: <span class="string">&quot;17x&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 这样赋值后 f1 叫做 方法表达式</span></span><br><span class="line">f1 := A.GetName</span><br><span class="line">    f1(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把 一个类型的方法赋值给变量后，该变量就称之为 <strong>方法表达式</strong>。</p><p>同时方法就是一个带有隐含参数的普通函数，所以以上代码等价于：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetName</span> <span class="params">(a A)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := A&#123;name: <span class="string">&quot;17x&quot;</span>&#125;</span><br><span class="line">f11 := GetName</span><br><span class="line">    f11(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以 f1 本质上也是一个 Function Value。</strong></p><p>之前已经证明了 f1 和 f11 是等价的，所以 调用 f1 的时候也要传入一个 A 类型的变量 a 作为第一个参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fourth</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := A&#123;name: <span class="string">&quot;17x&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 这样赋值后 f2 叫做 方法变量</span></span><br><span class="line">f2 := a.GetName</span><br><span class="line">f2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>f2 以这样的方式赋值，被称作 <strong>方法变量</strong>。</p><p>因为<code>a.GetName()</code> 这样调用的时候，会把变量 a 作为 GetName()的第一个参数传入，所以可以想到 <strong>f2 理论上应该是一个 闭包</strong>，即一个由捕获列表的 Function Value。</p><p>但是因为这里 f2 仅作为局部变量，它的生命周期和a的生命周期相同，所以<strong>编译器会做出优化</strong>。转换为类型A的方法调用并传入a作为参数，具体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.GetName(a)</span><br></pre></td></tr></table></figure><h2 id="4-做为返回值"><a href="#4-做为返回值" class="headerlink" title="4 做为返回值"></a>4 做为返回值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFunc</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">a := A&#123;name: <span class="string">&quot;17x in GetFunc&quot;</span>&#125;</span><br><span class="line"><span class="keyword">return</span> a.GetName</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := A&#123;name: <span class="string">&quot;17x in main&quot;</span>&#125;</span><br><span class="line">f2 := a.GetName</span><br><span class="line">fmt.Println(f2()) <span class="comment">// 17x in main</span></span><br><span class="line"></span><br><span class="line">f3 := GetFunc()</span><br><span class="line">fmt.Println(f3()) <span class="comment">// 17x in GetFunc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>f2 和上个例子相同，会被编译器优化为<code>A.GetName(a)</code> 这样的调用，所以打印出的是 17x in main。</p><p>而 f3 的 GetFunc() 等价于如下函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFunc</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">a := A&#123;name: <span class="string">&quot;17x in GetFunc&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> A.GetName(a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以清晰的看到，<strong>GetFunc() 中的局部变量 a 直接被 A.GetName() 引用而形成了闭包</strong>。</p><blockquote><p>f3 为闭包对象，捕获了GetFunc() 中的局部变量 a 。</p></blockquote><p>所以 f3 打印出的是 17x in GetFunc。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h2><p><strong>从本质上讲，方法表达式 Method Expression 和方法变量 Method Value 都是 Function Value。</strong></p><blockquote><p>一个没有捕获列表，一个有捕获列表。当然有时候编译器会做出优化。</p></blockquote><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6 参考"></a>6 参考</h2><p><code>https://www.bilibili.com/video/BV1hv411x7we?p=8</code></p><p><code>https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-function-call/</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] 接口</title>
      <link href="/2021/10/26/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E6%8E%A5%E5%8F%A3/"/>
      <url>/2021/10/26/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>接口是一组方法的签名</p></blockquote><span id="more"></span><h1 id="Go-接口"><a href="#Go-接口" class="headerlink" title="Go 接口"></a>Go 接口</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>Go 语言中的接口是一组方法的签名，它是 Go 语言的重要组成部分。</p><p>接口的本质是引入一个新的中间层，调用方可以通过接口与具体实现分离，解除上下游的耦合，上层的模块不再需要依赖下层的具体模块，只需要依赖一个约定好的接口。</p><p>除了解耦有依赖关系的上下游，接口还能够帮助我们隐藏底层实现，减少关注点。</p><p>定义接口需要使用 <code>interface</code> 关键字，在接口中我们只能定义方法签名，不能包含成员变量，一个常见的 Go 语言接口是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类型需要实现 <code>error</code> 接口，那么它只需要实现 <code>Error() string</code> 方法，下面的 <code>RPCError</code> 结构体就是 <code>error</code> 接口的一个实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RPCError <span class="keyword">struct</span> &#123;</span><br><span class="line">Code    <span class="type">int64</span></span><br><span class="line">Message <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *RPCError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s, code=%d&quot;</span>, e.Message, e.Code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 语言中<strong>接口的实现都是隐式的</strong>，我们只需要实现 <code>Error() string</code> 方法就实现了 <code>error</code> 接口。</p><h2 id="2-空接口-eface"><a href="#2-空接口-eface" class="headerlink" title="2 空接口 eface"></a>2 空接口 eface</h2><p>空接口可以接收任意类型的数据，只需要记录这个数据的地址的类型就可以了。具体定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go 205行</span></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">_type *_type</span><br><span class="line">data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>_type</strong>：指向接口的动态类型元数据</li><li><strong>data</strong>：指向接口的动态值</li></ul><blockquote><p>_type 结构体存储的类型信息中的通用部分。</p></blockquote><p>空接口类型变量，在被赋值前 _type 和 data 都为 nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>现在给 e 赋值，将 fd 赋值给 e。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd, _ := os.Open(<span class="string">&quot;17x.txt&quot;</span>)</span><br><span class="line">e = fd</span><br></pre></td></tr></table></figure><p>fd 是一个 <code>*os.File</code>类型，根据类型系统章节内容可以知道，<code>*os.File</code> 类型的类型元数据也是由 _type 和 uncommontype 两部分组成。</p><p>赋值给空接口 e 之后，e 的_type就会指向<code>*os.File</code> 类型的类型元数据。</p><p>同时由于 fd 本身就是一个指针，所以 e 的 data 字段就会直接替换为 fd，不用再去取地址了。</p><p>找到类型元数据后再通过偏移量就可以找到<strong>方法元数据数组</strong>了，这里面就有我们常用的 Read 和 Write 这些方法的描述信息。</p><p><img src="file-20250119063022239.png" alt=""></p><h2 id="3-非空接口-iface"><a href="#3-非空接口-iface" class="headerlink" title="3 非空接口 iface"></a>3 非空接口 iface</h2><p>非空接口就是有方法列表的接口类型，由<strong>接口类型</strong>和<strong>动态类型</strong>共同构成。</p><p>一个变量要赋值给非空接口变量，必须要实现该接口要求的所有方法才行。</p><p>具体定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go 200行</span></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">tab  *itab</span><br><span class="line">data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>data</strong>：指向接口的动态值</li><li><strong>tab</strong>：接口要求的方法列表和接口动态类型信息</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">inter *interfacetype</span><br><span class="line">_type *_type <span class="comment">// 动态类型</span></span><br><span class="line">hash  <span class="type">uint32</span> <span class="comment">// 类型哈希值</span></span><br><span class="line">_     [<span class="number">4</span>]<span class="type">byte</span></span><br><span class="line">fun   [<span class="number">1</span>]<span class="type">uintptr</span> <span class="comment">// 方法地址数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>inter</strong>：接口要求的方法列表，接口类型。</li><li><strong>_type</strong>：指向接口的动态类型元数据</li><li><strong>hash</strong>：从动态类型元数据中拷贝出来的类型哈希值，用于快速判断类型是否相等时使用。</li><li><strong>fun</strong>：记录这个动态类型实现的接口要求的方法的地址。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">typ     _type</span><br><span class="line">pkgpath name</span><br><span class="line">mhdr    []imethod <span class="comment">// 方法列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个非空接口类型的变量，赋值前 _type 和 data 也为nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rw io.ReadWriter</span><br></pre></td></tr></table></figure><p>然后给这个变量赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f, _ := os.Open(<span class="string">&quot;17x.txt&quot;</span>)</span><br><span class="line">rw = f</span><br></pre></td></tr></table></figure><p>具体结构如下：</p><p><img src="file-20250119063034887.png" alt=""></p><h2 id="4-itab-复用"><a href="#4-itab-复用" class="headerlink" title="4 itab 复用"></a>4 itab 复用</h2><p>一旦接口类型 itab.inter确定了，动态类型 itab._type也确定了，那么 itab 的内容就不会改变了，所以<strong>这个 itab 结构体是可以复用的</strong>。</p><p>Go 语言会把用到的 itab 结构体缓存起来，并且以接口类型和动态类型的组合为 key,以 itab 结构体指针为 value，构造一个哈希表，用于存储与查询 itab 缓存信息。</p><p>这里用的哈希表和 map 底层的哈希表不一样，这里是一种更为简单的实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/iface.go 22 行</span></span><br><span class="line"><span class="keyword">type</span> itabTableType <span class="keyword">struct</span> &#123;</span><br><span class="line">size    <span class="type">uintptr</span>             <span class="comment">// length of entries array. Always a power of 2.</span></span><br><span class="line">count   <span class="type">uintptr</span>             <span class="comment">// current number of filled entries.</span></span><br><span class="line">entries [itabInitSize]*itab <span class="comment">// really [size] large</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要一个 itab 时会首先去哈希表中查找，</p><ul><li>如果已经有对应的 itab 指针就直接拿来用；</li><li>若没有则创建一个 itab 结构体，然后添加到这个哈希表中</li></ul><p>Key 值哈希方法如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">itabHashFunc</span><span class="params">(inter *interfacetype, typ *_type)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line"><span class="comment">// compiler has provided some good hash codes for us.</span></span><br><span class="line"><span class="keyword">return</span> <span class="type">uintptr</span>(inter.typ.hash ^ typ.hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口类型的类型哈希值与动态类型的类型哈希值进行异或运算。</p><p>这样，如果 Key 值能对应上说明这就是一个类型，所以可以复用 Value 中的 itab 结构体。</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p><code>https://www.bilibili.com/video/BV1hv411x7we?p=13</code></p><p><code>https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Slice</title>
      <link href="/2021/10/22/Golang/0%20%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Slice/"/>
      <url>/2021/10/22/Golang/0%20%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Slice/</url>
      
        <content type="html"><![CDATA[<blockquote><p>切片的实现原理使用</p></blockquote><span id="more"></span><h2 id="1-几个问题"><a href="#1-几个问题" class="headerlink" title="1 几个问题"></a>1 几个问题</h2><h3 id="1-1-问题1"><a href="#1-1-问题1" class="headerlink" title="1.1 问题1"></a>1.1 问题1</h3><ul><li>初始化切片 s 长度和容量均为 10</li><li>在 s 的基础上追加 append 一个元素</li><li>切片s 的内容、长度以及容量分别是什么？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>)  </span><br><span class="line">    s = <span class="built_in">append</span>(s,<span class="number">10</span>)</span><br><span class="line">    t.Logf(<span class="string">&quot;s: %v, len of s: %d, cap of s: %d&quot;</span>,s,<span class="built_in">len</span>(s),<span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s: [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span>], <span class="built_in">len</span> of s: <span class="number">11</span>, <span class="built_in">cap</span> of s: <span class="number">20</span></span><br></pre></td></tr></table></figure><ul><li>基于 make([]int, 10) 的方式初始化切片的话其长度 len 和容量 cap 均为 10，且前10个元素是已经切实被分配过的（虽然会被填充为零值）. 此时进行 append 操作，会在末尾进行元素追加，由于切片的长度和容量是相等的，因此已经没有剩余可用的空间了，于是会进一步引发切片的扩容操作.</li><li>在切片原容量小于 256 的情况下，扩容时会采用原容量的2倍作为新的容量，于是在新切片中，长度增加为 11，而容量则翻倍变成 20.</li></ul><h3 id="1-2-问题2"><a href="#1-2-问题2" class="headerlink" title="1.2 问题2"></a>1.2 问题2</h3><ul><li>初始化切片 s 长度为 0，容量为 10</li><li>在 s 的基础上追加 append 一个元素</li><li>切片s 的内容、长度以及容量分别是什么？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>,<span class="number">10</span>)  </span><br><span class="line">    s = <span class="built_in">append</span>(s,<span class="number">10</span>)</span><br><span class="line">    t.Logf(<span class="string">&quot;s: %v, len of s: %d, cap of s: %d&quot;</span>,s,<span class="built_in">len</span>(s),<span class="built_in">cap</span>(s))</span><br><span class="line"></span><br><span class="line">s: [<span class="number">10</span>], <span class="built_in">len</span> of s: <span class="number">1</span>, <span class="built_in">cap</span> of s: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>make([]int, 0, 10) 的方式使得切片长度为 0，容量为 10，实际上还有长度为 10 的缓存空间. 于是这一次 append 操作，会直接使用已有的空间，不会引发扩容. 结果中，切片长度从 0 增加为 1，容量则维持为 10 不变.</li></ul><h3 id="1-3-问题3"><a href="#1-3-问题3" class="headerlink" title="1.3 问题3"></a>1.3 问题3</h3><ul><li>初始化切片 s 长度为 10，容量为 11</li><li>在 s 的基础上追加 append 一个元素</li><li>切片s 的内容、长度以及容量分别是什么？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>,<span class="number">11</span>)  </span><br><span class="line">    s = <span class="built_in">append</span>(s,<span class="number">10</span>)</span><br><span class="line">    t.Logf(<span class="string">&quot;s: %v, len of s: %d, cap of s: %d&quot;</span>,s,<span class="built_in">len</span>(s),<span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s: [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span>], <span class="built_in">len</span> of s: <span class="number">11</span>, <span class="built_in">cap</span> of s: <span class="number">11</span></span><br></pre></td></tr></table></figure><ul><li>由于容量大于长度，因此仍有足够的空间，这次 append 操作不会引发扩容.</li></ul><h3 id="1-4-问题4"><a href="#1-4-问题4" class="headerlink" title="1.4 问题4"></a>1.4 问题4</h3><ul><li>初始化切片 s 长度为 10，容量为 12</li><li>截取切片 s index = 8 往后的内容赋给 s1</li><li>s1 的内容、长度以及容量分别是什么？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>,<span class="number">12</span>)  </span><br><span class="line">    s1 := s[<span class="number">8</span>:]</span><br><span class="line">    t.Logf(<span class="string">&quot;s1: %v, len of s1: %d, cap of s1: %d&quot;</span>,s1,<span class="built_in">len</span>(s1),<span class="built_in">cap</span>(s1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s1: [<span class="number">0</span> <span class="number">0</span>], <span class="built_in">len</span> of s1: <span class="number">2</span>, <span class="built_in">cap</span> of s1: <span class="number">4</span></span><br></pre></td></tr></table></figure><ul><li>截取操作会以 s[8] 作为内存空间的起点，截取所得新切片 s1 的长度和容量强依赖于原切片 s 的长度和容量，并在此基础上减去头部 8 个未使用到的单位.</li></ul><h3 id="1-5-问题5"><a href="#1-5-问题5" class="headerlink" title="1.5 问题5"></a>1.5 问题5</h3><ul><li>初始化切片 s 长度为 10，容量为 12</li><li>截取切片 s index 为 [8,9) 范围内的元素赋给切片 s1</li><li>s1 的内容、长度以及容量分别是什么？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>,<span class="number">12</span>)  </span><br><span class="line">    s1 := s[<span class="number">8</span>:<span class="number">9</span>]</span><br><span class="line">    t.Logf(<span class="string">&quot;s1: %v, len of s1: %d, cap of s1: %d&quot;</span>,s1,<span class="built_in">len</span>(s1),<span class="built_in">cap</span>(s1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s1: [<span class="number">0</span>], <span class="built_in">len</span> of s1: <span class="number">1</span>, <span class="built_in">cap</span> of s1: <span class="number">4</span></span><br></pre></td></tr></table></figure><ul><li>虽然 s[8:9] 的截取操作限定了 s1 的右边界，但这只是长度意义上的，对于容量，s1 仍然和 s 保持强关联性.</li></ul><h3 id="1-6-问题6"><a href="#1-6-问题6" class="headerlink" title="1.6 问题6"></a>1.6 问题6</h3><ul><li>初始化切片 s 长度为 10，容量为 12</li><li>截取切片 s index = 8 往后的内容赋给 s1</li><li>修改 s1[0] 的值</li><li>这个修改是否会影响到 s？ 此时，s 的内容是什么？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>,<span class="number">12</span>)  </span><br><span class="line">    s1 := s[<span class="number">8</span>:]</span><br><span class="line">    s1[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">    t.Logf(<span class="string">&quot;s: %v&quot;</span>,s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s: [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">-1</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>s1 是在 s 基础上截取得到的，属于一次引用传递，底层共用同一片内存空间，其中 s[x] 等价于 s1[x+8]. 因此修改了 s1[0] 会直接影响到 s[8] .</p><h3 id="1-7-问题7"><a href="#1-7-问题7" class="headerlink" title="1.7 问题7"></a>1.7 问题7</h3><ul><li>初始化切片 s 长度为 10，容量为 12</li><li>访问 s[10] 是否会越界？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>,<span class="number">12</span>)  </span><br><span class="line">    v := s[<span class="number">10</span>]</span><br><span class="line">    <span class="comment">// 此时数组访问是否会越界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>会发生 panic</li><li>初始化时设定了切片长度为10，容量为 12. 容量是物理意义上的，但长度是逻辑意义上的，判断是否越界以逻辑意义为准，因此 index = 10 已经越界</li></ul><h3 id="1-8-问题8"><a href="#1-8-问题8" class="headerlink" title="1.8 问题8"></a>1.8 问题8</h3><ul><li>初始化切片 s 长度为 10，容量为 12</li><li>截取 s 中 index = 8 后面的内容赋给 s1</li><li>在 s1 的基础上追加 []int{10,11,12} 3 个元素</li><li>访问 s[10] 是否会越界？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>,<span class="number">12</span>)  </span><br><span class="line">    s1 := s[<span class="number">8</span>:]</span><br><span class="line">    s1 = <span class="built_in">append</span>(s1,[]<span class="type">int</span>&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;...)</span><br><span class="line">    v := s[<span class="number">10</span>]</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 求问，此时数组访问是否会越界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>会发生 panic.</li><li>在 s 的基础上截取产生了 s1，此时 s1 和 s 会拥有两个独立的 slice header.</li><li>接下来执行 append 操作时，由于 s 预留的空间不足，s1 会发生扩容</li><li>s1 扩容后，会被迁移到新的空间地址，此时 s1 已经和 s 做到真正意义上的完全独立，意味着修改 s1 不再会影响到 s</li><li>s 继续维持原本的长度值 10 和容量值 12，因此访问 s[10] 会panic</li></ul><h3 id="1-9-问题9"><a href="#1-9-问题9" class="headerlink" title="1.9 问题9"></a>1.9 问题9</h3><ul><li>初始化切片 s 长度为 10，容量为 12</li><li>截取切片 s index = 8 往后的内容赋给 s1</li><li>在方法 changeSlice 中，对 s1[0] 进行修改</li><li>经过上述操作之后，s 的内容是什么？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>,<span class="number">12</span>)  </span><br><span class="line">    s1 := s[<span class="number">8</span>:]</span><br><span class="line">    changeSlice(s1)</span><br><span class="line">    t.Logf(<span class="string">&quot;s: %v&quot;</span>,s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(s1 []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">  s1[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s: [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">-1</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul><li>切片在传递时属于引用传递，且 s1[0] 和 s[8] 指向同一个元素. 因此在局部方法中，修改了 s1[0] 会直接影响到 s[8] 的内容.</li></ul><h3 id="1-10-问题10"><a href="#1-10-问题10" class="headerlink" title="1.10 问题10"></a>1.10 问题10</h3><ul><li>初始化切片 s 长度为 10，容量为 12</li><li>截取切片 s index = 8 往后的内容赋给 s1</li><li>在方法 changeSlice 中，对 s1 进行 apend 追加操作</li><li>经过上述操作后，s 以及 s1 的内容、长度和容量分别是什么？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>,<span class="number">12</span>)  </span><br><span class="line">    s1 := s[<span class="number">8</span>:]</span><br><span class="line">    changeSlice(s1)</span><br><span class="line">    t.Logf(<span class="string">&quot;s: %v, len of s: %d, cap of s: %d&quot;</span>,s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">    t.Logf(<span class="string">&quot;s1: %v, len of s1: %d, cap of s1: %d&quot;</span>,s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(s1 []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">  s1 = <span class="built_in">append</span>(s1, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">s: [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>], <span class="built_in">len</span> of s: <span class="number">10</span>, <span class="built_in">cap</span> of s: <span class="number">12</span></span><br><span class="line">s1: [<span class="number">0</span> <span class="number">0</span>], <span class="built_in">len</span> of s1: <span class="number">2</span>, <span class="built_in">cap</span> of s1: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>切片是引用传递，但是在方法调用时，传递的会是一个新的 slice header.</li><li>因此在局部方法 changeSlice 中，虽然对 s1 进行了 append 操作，但这这会在局部方法中这个独立的 slice header 中生效，不会影响到原方法 Test_slice 当中的 s 和 s1 的长度和容量</li></ul><h3 id="1-11-问题11"><a href="#1-11-问题11" class="headerlink" title="1.11 问题11"></a>1.11 问题11</h3><ul><li>初始化切片 s，内容为 []int{0,1,2,3,4}</li><li>截取 s 中 index = 2 前面的内容（不含s[2]），并在此基础上追加 index = 3 后面的内容</li><li>经过上述操作后，s 的内容、长度和内容分别是什么？此时访问 s[4] 是否会越界？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">    s = <span class="built_in">append</span>(s[:<span class="number">2</span>],s[<span class="number">3</span>:]...)</span><br><span class="line">    t.Logf(<span class="string">&quot;s: %v, len: %d, cap: %d&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">    v := s[<span class="number">4</span>] </span><br><span class="line">    <span class="comment">// 是否会数组访问越界</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s: [<span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span>], <span class="built_in">len</span>: <span class="number">4</span>, <span class="built_in">cap</span>: <span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li>会发生 panic</li><li>执行完上述 append 操作之后，s 的实际长度为 4，容量维持不变为 5. 此时访问 s[4]会发生数组越界的错误</li></ul><h3 id="1-12-问题12"><a href="#1-12-问题12" class="headerlink" title="1.12 问题12"></a>1.12 问题12</h3><ul><li>初始化切片 s 长度和容量均为 512</li><li>在 s 的基础上追加 append 一个元素</li><li>经过上述操作后，切片s 的内容、长度以及容量分别是什么？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">512</span>)  </span><br><span class="line">    s = <span class="built_in">append</span>(s,<span class="number">1</span>)</span><br><span class="line">    t.Logf(<span class="string">&quot;len of s: %d, cap of s: %d&quot;</span>,<span class="built_in">len</span>(s),<span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">len</span>: <span class="number">513</span>, <span class="built_in">cap</span>: <span class="number">848</span></span><br></pre></td></tr></table></figure><ul><li>由于切片 s 原有容量为 512，已经超过了阈值 256，因此对其进行扩容操作会采用的计算共识为 512 <em> (512 + 3\</em>256)/4 = 832</li><li>其次，在真正申请内存空间时，我们会根据切片元素大小乘以容量计算出所需的总空间大小，得出所需的空间为 8byte * 832 = 6656 byte</li><li>再进一步，结合分配内存的 mallocgc 流程，为了更好地进行内存空间对其，golang 允许产生一些有限的内部碎片，对拟申请空间的 object 进行大小补齐，最终 6656 byte 会被补齐到 6784 byte 的这一档次</li><li>再终，在 mallocgc 流程中，我们为扩容后的新切片分配到了 6784 byte 的空间，于是扩容后实际的新容量为 cap = 6784/8 = 848.</li></ul><h2 id="2-使用及原理"><a href="#2-使用及原理" class="headerlink" title="2 使用及原理"></a>2 使用及原理</h2><h3 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h3><p>Go 语言中的 Slice 具体实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 指向起点的地址</span></span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="comment">// 切片长度</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">    <span class="comment">// 切片容量</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>array：指向了内存空间地址的起点. 由于 slice 数据存放在连续的内存空间中，后续可以根据索引 index，在起点的基础上快速进行地址偏移，从而定位到目标元素</li><li>len：切片的长度，指的是逻辑意义上 slice 中实际存放了多少个元素</li><li>cap：切片的容量，指的是物理意义上为 slice 分配了足够用于存放多少个元素的空间. 使用 slice 时，要求 cap 永远大于等于 len</li></ul><p>每个 slice header 中存放的是内存空间的地址（array 字段），后续在传递切片的时候，相当于是对 slice header 进行了一次值拷贝，但内部存放的地址是相同的，因此对于 slice 本身属于<strong>引用传递</strong>操作</p><h3 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h3><ul><li>声明但不初始化<ul><li>只是声明了 slice 的类型，但是并没有执行初始化操作，即 s 这个字面量此时是一个空指针 nil，并没有完成实际的内存分配操作.</li><li>`var s []int</li></ul></li><li>基于 make 进行初始化<ul><li><code>s := make([]int,8)</code>将切片的长度 len 和 容量 cap 同时设置为 8. 需要注意，切片的长度一旦被指定了，就代表对应位置已经被分配了元素，尽管设置的会是对应元素类型下的零值.</li><li><code>s := make([]int,8,16)</code> 在切片中设置了 8 个元素，会设置为对应类型的零值；cap = 16 代表为 slice 分配了用于存放 16 个元素的空间. 需要保证 cap &gt;= len. 在 index 为 [len, cap) 的范围内，虽然内存空间已经分配了，但是逻辑意义上不存在元素，直接访问会 panic 报数组访问越界；但是访问 [0,len) 范围内的元素是能够正常访问到的，只不过会是对应元素类型下的零值.</li></ul></li><li>初始化连带赋值<ul><li><code>s := []int&#123;2,3,4&#125;</code> 将 slice 长度 len 和容量 cap 均设置为 3，同时完成对这 3 个元素赋值.</li></ul></li></ul><h3 id="2-3-引用传递"><a href="#2-3-引用传递" class="headerlink" title="2.3 引用传递"></a>2.3 引用传递</h3><ul><li>引用传递，指的是，将实例的地址信息传递到方法中，这样在方法中会直接通过地址追溯到实例所在位置，因此执行的一些修改操作会直接影响到原实例.</li><li>值传递，指的是对实例进行一轮拷贝，得到一个副本，然后将这个副本传递到方法中. 这样在方法内部发生的修改动作都作用于这个副本之上，而副本本身和实例是相互独立的，因此不会影响到原实例.</li><li>slice 属于引用传递的类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">  s := []<span class="type">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">  <span class="comment">// [2,3,4] -&gt; [-1,3,4]</span></span><br><span class="line">  changeSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(s []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">  s[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将主方法 Test_slice 中声明的切片 s 作为 changeSlice 方法的入参进行传递，同时在 changeSlice 方法中对 s 内的元素进行修改，这样是会直接影响到 Test_slice 中的切片 s 的.</li><li>每个切片实例对应一个 slice header，其中存储了三个字段：<ul><li>切片内存空间的起始地址 array；</li><li>切片长度 len；</li><li>以及切片容量 cap.</li></ul></li><li>在方法间传递切片时，会对 slice header 实例本身进行一次值拷贝，然后将 slice header 的副本传递到局部方法中.</li><li>然而，这个 slice header 副本中的 array 和原 slice 指向同一片内存空间，因此在局部方法中执行修改操作时，还会根据这个地址信息影响到原 slice 所属的内存空间，从而对内容发生影响.</li></ul><h3 id="2-4-内容截取"><a href="#2-4-内容截取" class="headerlink" title="2.4 内容截取"></a>2.4 内容截取</h3><p>可以修改 slice 下标的方式，进行 slice 内容的截取，形如 s[a:b] 的格式，其中 a b 代表切片的索引 index，左闭右开，比如 s[a:b] 对应的范围是 [a,b)，代表的是取切片 slice index = a ~ index = b-1 范围的内容.</p><p>此外，这里的 a 和 b 是可以缺省的：</p><ul><li>如果 a 缺省不填则默认取 0 ，则代表从切片起始位置开始截取. 比如 s[:b] 等价于 s[0:b]</li><li>如果 b 缺省不填，则默认取 len(s)，则代表末尾截取到切片长度 len 的终点，比如 s[a:] 等价于 s[a:len(s)]</li><li>a 和 b 均缺省也是可以的，则代表截取整个切片长度的范围，比如 s[:] 等价于 s[0:len(s)]</li></ul><p>在对切片 slice 执行截取操作时，本质上是一次<strong>引用传递</strong>操作，因为不论如何截取，底层复用的都是同一块内存空间中的数据，只不过，截取动作会创建出一个新的 slice header 实例.</p><h3 id="2-5-元素追加"><a href="#2-5-元素追加" class="headerlink" title="2.5 元素追加"></a>2.5 元素追加</h3><p>通过 append 操作，可以在 slice 末尾，额外新增一个元素. 需要注意，这里的末尾指的是针对 slice 的长度 len 而言. 这个过程中倘若发现 slice 的剩余容量已经不足了，则会对 slice 进行扩容.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;  </span><br><span class="line">    s = <span class="built_in">append</span>(s,<span class="number">5</span>)</span><br><span class="line">    <span class="comment">// s: [2,3,4,5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建 slice 时，如果能够预估到其未来所需的容量空间，则应该提前分配好对应容量，避免在运行过程中频繁触发扩容操作，这样会对性能产生不利的影响.</p><h3 id="2-6-切片扩容"><a href="#2-6-切片扩容" class="headerlink" title="2.6 切片扩容"></a>2.6 切片扩容</h3><p>当 slice 当前的长度 len 与容量 cap 相等时，下一次 append 操作就会引发一次切片扩容.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// len:4, cap: 4</span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">// len:5, cap: 8    </span></span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p><strong>扩容流程</strong></p><ul><li>倘若扩容后预期的新容量小于原切片的容量，则 panic</li><li>倘若切片元素大小为 0（元素类型为 struct{}），则直接复用一个全局的 zerobase 实例，直接返回</li><li>倘若预期的新容量超过老容量的两倍，则直接采用预期的新容量</li><li>倘若老容量小于 256，则直接采用老容量的2倍作为新容量</li><li>倘若老容量已经大于等于 256，则在老容量的基础上扩容 1/4 的比例并且累加上 192 的数值，持续这样处理，直到得到的新容量已经大于等于预期的新容量为止</li><li>结合 mallocgc 流程中，对内存分配单元 mspan 的等级制度，推算得到实际需要申请的内存空间大小</li><li>调用 mallocgc，对新切片进行内存初始化</li><li>调用 memmove 方法，将老切片中的内容拷贝到新切片中</li><li>返回扩容后的新切片</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> &lt; old.<span class="built_in">cap</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: cap out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> et.size == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 倘若元素大小为 0，则无需分配空间直接返回</span></span><br><span class="line">        <span class="keyword">return</span> slice&#123;unsafe.Pointer(&amp;zerobase), old.<span class="built_in">len</span>, <span class="built_in">cap</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算扩容后数组的容量</span></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">    <span class="comment">// 取原容量两倍的容量数值</span></span><br><span class="line">    doublecap := newcap + newcap</span><br><span class="line">    <span class="comment">// 倘若新的容量大于原容量的两倍，直接取新容量作为数组扩容后的容量</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">        newcap = <span class="built_in">cap</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> threshold = <span class="number">256</span></span><br><span class="line">        <span class="comment">// 倘若原容量小于 256，则扩容后新容量为原容量的两倍</span></span><br><span class="line">        <span class="keyword">if</span> old.<span class="built_in">cap</span> &lt; threshold &#123;</span><br><span class="line">            newcap = doublecap</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在原容量的基础上，对原容量 * 5/4 并且加上 192</span></span><br><span class="line">            <span class="comment">// 循环执行上述操作，直到扩容后的容量已经大于等于预期的新容量为止</span></span><br><span class="line">            <span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;             </span><br><span class="line">                newcap += (newcap + <span class="number">3</span>*threshold) / <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 倘若数值越界了，则取预期的新容量 cap 封顶</span></span><br><span class="line">            <span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                newcap = <span class="built_in">cap</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> overflow <span class="type">bool</span></span><br><span class="line">    <span class="keyword">var</span> lenmem, newlenmem, capmem <span class="type">uintptr</span></span><br><span class="line">    <span class="comment">// 基于容量，确定新数组容器所需要的内存空间大小 capmem</span></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="comment">// 倘若数组元素的大小为 1，则新容量大小为 1 * newcap.</span></span><br><span class="line">    <span class="comment">// 同时会针对 span class 进行取整</span></span><br><span class="line">    <span class="keyword">case</span> et.size == <span class="number">1</span>:</span><br><span class="line">        lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>)</span><br><span class="line">        newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>)</span><br><span class="line">        capmem = roundupsize(<span class="type">uintptr</span>(newcap))</span><br><span class="line">        overflow = <span class="type">uintptr</span>(newcap) &gt; maxAlloc</span><br><span class="line">        newcap = <span class="type">int</span>(capmem)</span><br><span class="line">    <span class="comment">// 倘若数组元素为指针类型，则根据指针占用空间结合元素个数计算空间大小</span></span><br><span class="line">    <span class="comment">// 并会针对 span class 进行取整</span></span><br><span class="line">    <span class="keyword">case</span> et.size == goarch.PtrSize:</span><br><span class="line">        lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>) * goarch.PtrSize</span><br><span class="line">        newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>) * goarch.PtrSize</span><br><span class="line">        capmem = roundupsize(<span class="type">uintptr</span>(newcap) * goarch.PtrSize)</span><br><span class="line">        overflow = <span class="type">uintptr</span>(newcap) &gt; maxAlloc/goarch.PtrSize</span><br><span class="line">        newcap = <span class="type">int</span>(capmem / goarch.PtrSize)</span><br><span class="line">    <span class="comment">// 倘若元素大小为 2 的指数，则直接通过位运算进行空间大小的计算   </span></span><br><span class="line">    <span class="keyword">case</span> isPowerOfTwo(et.size):</span><br><span class="line">        <span class="keyword">var</span> shift <span class="type">uintptr</span></span><br><span class="line">        <span class="keyword">if</span> goarch.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">            <span class="comment">// Mask shift for better code generation.</span></span><br><span class="line">            shift = <span class="type">uintptr</span>(sys.Ctz64(<span class="type">uint64</span>(et.size))) &amp; <span class="number">63</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            shift = <span class="type">uintptr</span>(sys.Ctz32(<span class="type">uint32</span>(et.size))) &amp; <span class="number">31</span></span><br><span class="line">        &#125;</span><br><span class="line">        lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>) &lt;&lt; shift</span><br><span class="line">        newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>) &lt;&lt; shift</span><br><span class="line">        capmem = roundupsize(<span class="type">uintptr</span>(newcap) &lt;&lt; shift)</span><br><span class="line">        overflow = <span class="type">uintptr</span>(newcap) &gt; (maxAlloc &gt;&gt; shift)</span><br><span class="line">        newcap = <span class="type">int</span>(capmem &gt;&gt; shift)</span><br><span class="line">    <span class="comment">// 兜底分支：根据元素大小乘以元素个数</span></span><br><span class="line">    <span class="comment">// 再针对 span class 进行取整     </span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>) * et.size</span><br><span class="line">        newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">        capmem, overflow = math.MulUintptr(et.size, <span class="type">uintptr</span>(newcap))</span><br><span class="line">        capmem = roundupsize(capmem)</span><br><span class="line">        newcap = <span class="type">int</span>(capmem / et.size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行实际的切片初始化操作</span></span><br><span class="line">    <span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line">    <span class="comment">// 非指针类型</span></span><br><span class="line">    <span class="keyword">if</span> et.ptrdata == <span class="number">0</span> &#123;</span><br><span class="line">        p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 指针类型</span></span><br><span class="line">        p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将切片的内容拷贝到扩容后的位置 p </span></span><br><span class="line">    memmove(p, old.array, lenmem)</span><br><span class="line">    <span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-元素删除"><a href="#2-7-元素删除" class="headerlink" title="2.7 元素删除"></a>2.7 元素删除</h3><p>从切片中删除元素的实现思路，本质上和切片内容截取的思路是一致的.</p><ul><li>比如删除 slice 中的首个元素，在操作上等同于从切片 index = 1 开始向后进行内容截取</li><li>如果删除 slice 的尾部元素，则操作等价于截取切片内容，并将终点设置在 len(s) - 1 的位置</li><li>如果需要删除 slice 中间的某个元素，操作思路则是采用内容截取加上元素追加的复合操作，可以先截取待删除元素的左侧部分内容，然后在此基础上追加上待删除元素后侧部分的内容</li><li>当需要删除 slice 中的所有元素时，也可以采用切片内容截取的操作方式：s[:0]. 这样操作后，slice header 中的指针 array 仍指向远处，但是逻辑意义上其长度 len 已经等于 0，而容量 cap 则仍保留为原值</li></ul><h3 id="2-8-切片拷贝"><a href="#2-8-切片拷贝" class="headerlink" title="2.8 切片拷贝"></a>2.8 切片拷贝</h3><p>slice 的拷贝可以分为简单拷贝和完整拷贝两种类型</p><p>要实现简单拷贝，只需要对切片的字面量进行赋值传递即可，这样相当于创建出了一个新的 slice header 实例，但是其中的指针 array、容量 cap 和长度 len 仍和老的 slice header 实例相同.</p><p>slice 的完整复制，指的是会创建出一个和 slice 容量大小相等的独立的内存区域，并将原 slice 中的元素一一拷贝到新空间中</p><p>在实现上，slice 的完整复制可以调用系统方法 copy，代码示例如下，通过日志打印的方式可以看到，s 和 s1 的地址是相互独立的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    <span class="built_in">copy</span>(s1, s)</span><br><span class="line">    t.Logf(<span class="string">&quot;s: %v, s1: %v&quot;</span>, s, s1)</span><br><span class="line">    t.Logf(<span class="string">&quot;address of s: %p, address of s1: %p&quot;</span>, s, s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-与-String-互转"><a href="#3-与-String-互转" class="headerlink" title="3 与 String 互转"></a>3 与 String 互转</h2><p>Slice 由 Data、Len、Cap 构成，String 由 Data、Len 构成，二者只相差了一个 Cap 属性。</p><p>通过 unsafe 包可以快速进行二者的转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">String2Bytes</span><span class="params">(str <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">sh := (*reflect.SliceHeader)(unsafe.Pointer(&amp;str))</span><br><span class="line"><span class="comment">// slice 比 string 多一个 cap 属性 这里给 cap 单独赋值</span></span><br><span class="line">sh.Cap = sh.Len</span><br><span class="line"><span class="keyword">return</span> *(*[]<span class="type">byte</span>)(unsafe.Pointer(sh))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bytes2String</span><span class="params">(buf []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="type">string</span>)(unsafe.Pointer(&amp;buf))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 语言标准库中 strings.Builder 就使用到了 unsafe.Pointer 来提升效率。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strings/builder.go 47 行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="type">string</span>)(unsafe.Pointer(&amp;b.buf))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 .参考"></a>4 .参考</h2><p><code>https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/</code></p><p><code>https://blog.golang.org/slices-intro</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Golang Benchyou</title>
      <link href="/2021/10/11/Golang/4%20%E5%85%B6%E4%BB%96/Benchyou%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/10/11/Golang/4%20%E5%85%B6%E4%BB%96/Benchyou%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>benchyou is a benchmark tool for MySQL, real-time monitoring TPS and vmstat/iostat</p></blockquote><span id="more"></span><h2 id="1-Build"><a href="#1-Build" class="headerlink" title="1 Build"></a>1 Build</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/xelabs/benchyou</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> benchyou</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make build</span></span><br></pre></td></tr></table></figure><h2 id="2-Usage"><a href="#2-Usage" class="headerlink" title="2 Usage"></a>2 Usage</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bin/benchyou -h</span></span><br></pre></td></tr></table></figure><h2 id="3-Examples"><a href="#3-Examples" class="headerlink" title="3 Examples"></a>3 Examples</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">prepare 64 tables:</span><br><span class="line">./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou  --oltp-tables-count=64 prepare</span><br><span class="line"></span><br><span class="line">cleanup 64 tables:</span><br><span class="line">./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou  --oltp-tables-count=64 cleanup</span><br><span class="line"></span><br><span class="line">random insert(Write/Read Ratio=128:8):</span><br><span class="line"> ./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou --ssh-user=benchyou --ssh-password=benchyou --oltp-tables-count=64 --write-threads=128 --read-threads=8 --max-time=3600 random</span><br><span class="line"></span><br><span class="line">sequential insert(Write/Read Ratio=128:8):</span><br><span class="line"> ./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou --ssh-user=benchyou --ssh-password=benchyou --oltp-tables-count=64 --write-threads=128 --read-threads=8 --max-time=3600 seq</span><br><span class="line"></span><br><span class="line">mix(Write/Read/Update/Delete Ratio=4:4:4:4):</span><br><span class="line"> ./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou --ssh-user=benchyou --ssh-password=benchyou --oltp-tables-count=64 --write-threads=4 --read-threads=4 --update-threads=4 --delete-threads=4 --max-time=3600 random</span><br><span class="line"></span><br><span class="line">insert multiple rows(10 rows per insert):</span><br><span class="line"> ./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou --ssh-user=benchyou --ssh-password=benchyou --oltp-tables-count=64 --write-threads=4 --rows-per-insert=10 --max-time=3600 random</span><br><span class="line"></span><br><span class="line">batch update(10 rows per transaction):</span><br><span class="line"> ./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou --ssh-user=benchyou --ssh-password=benchyou --oltp-tables-count=64 --update-threads=4 --batch-per-commit=10 --max-time=3600 random</span><br><span class="line"></span><br><span class="line">query-range(Write/Read Ratio=128:8):</span><br><span class="line"> ./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou --ssh-user=benchyou --ssh-password=benchyou --oltp-tables-count=64 --write-threads=128 --read-threads=8 --max-time=3600 --mysql-range-order=DESC range</span><br></pre></td></tr></table></figure><h2 id="4-Github"><a href="#4-Github" class="headerlink" title="4 Github"></a>4 Github</h2><ul><li><a href="https://github.com/xelabs/benchyou">benchyou</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
          <category> Packges </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go-Package </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Golang Time/rate使用</title>
      <link href="/2021/10/11/Golang/4%20%E5%85%B6%E4%BB%96/time%20rate%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/10/11/Golang/4%20%E5%85%B6%E4%BB%96/time%20rate%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Time/rate 是基于 Token Bucket (令牌桶) 算法实现的限流</p></blockquote><span id="more"></span><h2 id="1-限流"><a href="#1-限流" class="headerlink" title="1 限流"></a>1 限流</h2><p>限制某个服务每秒的调用本服务的频率 客户端请求太多，超出服务端的服务能力，导致服务不可用。DoS攻击就是根据此原理， 耗尽被攻击对象的资源，让目标系统无法响应甚至崩溃。解决方案：服务端对客户端限流，保护服务端的资源。 限流通常在网关或网络层面实施。对各类请求设置最高的QPS阈值，当请求高于阈值时直接阻断。</p><p>常用的限流算法有滑动计数，漏斗限流和令牌限流三种：</p><ol><li>滑动计数限流：按时间片（比如1秒）定义滑动窗口，计数器记录当前窗口的请求次数， 达到阈值就限流，窗口滑动后计数器归零。可采用循环队列数据结构实现。</li><li>漏斗限流：维护一个队列，所有请求进队列，按FIFO服务，队满溢出则丢弃请求。</li><li>令牌桶限流：按固定速率往桶中存入令牌，服务前先从桶中取令牌，取到令牌才服务。</li></ol><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get golang.org/x/time/rate</span><br></pre></td></tr></table></figure><h3 id="2-2-构造一个限流器"><a href="#2-2-构造一个限流器" class="headerlink" title="2.2 构造一个限流器"></a>2.2 构造一个限流器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewLimiter returns a new Limiter that allows events up to rate r and permits</span></span><br><span class="line"><span class="comment">// bursts of at most b tokens.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLimiter</span><span class="params">(r Limit, b <span class="type">int</span>)</span></span> *Limiter &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Limiter&#123;</span><br><span class="line">        limit: r,</span><br><span class="line">        burst: b,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NewLimiter有两个参数</p><p>第一个r Limit 表示每秒可以放入多少个token到桶中，Limit是float64的别名；</p><p>第二个b int 表示桶容量大小,即同一时刻能取到的最大token数量；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">limiter := NewLimiter(<span class="number">10</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>示例表示每秒放入10个token，桶容量大小为1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">limit := Every(<span class="number">100</span> * time.Millisecond);</span><br><span class="line">limiter := NewLimiter(limit, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>Every表示放入token速率时间粒度;</p><p>示例表示每100ms放入1个token,即1秒放入10个；</p><h3 id="2-3-Wait-WaitN"><a href="#2-3-Wait-WaitN" class="headerlink" title="2.3 Wait/WaitN"></a>2.3 Wait/WaitN</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Wait(ctx context.Context) (err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> WaitN(ctx context.Context, n <span class="type">int</span>) (err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>Wait获取Token时如果数组不足(小于N)，将会阻塞一段时间，直至Token满足条件, 如果充足则直接返回</p><p>阻塞时间可以通过context参数设置Deadline或Timeout控制</p><h3 id="2-4-Allow-AllowN"><a href="#2-4-Allow-AllowN" class="headerlink" title="2.4 Allow/AllowN"></a>2.4 Allow/AllowN</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Allow() <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> AllowN(now time.Time, n <span class="type">int</span>) <span class="type">bool</span></span><br></pre></td></tr></table></figure><p>Allow获取Token充足返回true，同时Token减少，否则返回false，不会阻塞</p><h3 id="2-5-Reserve-ReserveN"><a href="#2-5-Reserve-ReserveN" class="headerlink" title="2.5 Reserve/ReserveN"></a>2.5 Reserve/ReserveN</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Reserve() *Reservation</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> ReserveN(now time.Time, n <span class="type">int</span>) *Reservation</span><br></pre></td></tr></table></figure><p>返回Reservation对象，有如下对象方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> OK() <span class="type">bool</span> <span class="comment">// 判断是否获取到token</span></span><br><span class="line"><span class="comment">// Delay is shorthand for DelayFrom(time.Now()).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> Delay() time.Duration <span class="comment">// 获取延迟等待时间,此时Cancel不起作用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> DelayFrom(now time.Time) time.Duration</span><br><span class="line"><span class="comment">// Cancel is shorthand for CancelAt(time.Now()).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> Cancel() <span class="comment">// 取消，将获取的Token重新放入桶中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> CancelAt(now time.Time)</span><br></pre></td></tr></table></figure><h3 id="2-6-调整速率和桶大小"><a href="#2-6-调整速率和桶大小" class="headerlink" title="2.6 调整速率和桶大小"></a>2.6 调整速率和桶大小</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetLimit(newLimit Limit) <span class="comment">//改变放入Token的速率</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetLimitAt(now time.Time, newLimit Limit)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetBurst(newBurst <span class="type">int</span>) <span class="comment">// 改变Token桶大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetBurstAt(now time.Time, newBurst <span class="type">int</span>)</span><br></pre></td></tr></table></figure><h3 id="2-7-获取速率和桶大小"><a href="#2-7-获取速率和桶大小" class="headerlink" title="2.7 获取速率和桶大小"></a>2.7 获取速率和桶大小</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Limit() Limit <span class="comment">// 获取速率</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Burst() <span class="type">int</span> <span class="comment">//获取桶容量</span></span><br></pre></td></tr></table></figure><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h2><ul><li><a href="https://www.cyhone.com/articles/analisys-of-golang-rate/">Golang 标准库限流器 time/rate 实现剖析</a></li><li><a href="https://www.cyhone.com/articles/usage-of-golang-rate/">Golang 标准库限流器 time/rate 使用介绍</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
          <category> Packages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go-Package </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] 工程实践</title>
      <link href="/2021/09/20/Golang/3%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/Golang%20%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
      <url>/2021/09/20/Golang/3%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/Golang%20%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如何写优雅的 Go 语言代码</p></blockquote><span id="more"></span><h2 id="1-最佳实践"><a href="#1-最佳实践" class="headerlink" title="1 最佳实践"></a>1 最佳实践</h2><h3 id="1-1-目录结构"><a href="#1-1-目录结构" class="headerlink" title="1.1 目录结构"></a>1.1 目录结构</h3><p>目录结构基本上就是一个项目的门面，很多时候我们从目录结构中就能够看出开发者对这门语言是否有足够的经验。</p><p>官方并没有给出一个推荐的目录划分方式，但是社区中还是有一些比较常见的约定：例如：<a href="https://github.com/golang-standards/project-layout">golang-standards/project-layout</a> 项目中就定义了一个比较标准的目录结构。</p><h4 id="1-1-1-pkg"><a href="#1-1-1-pkg" class="headerlink" title="1.1.1 /pkg"></a>1.1.1 /pkg</h4><p><code>/pkg</code> 目录是 Go 语言项目中非常常见的目录，我们几乎能够在所有知名的开源项目（非框架）中找到它的身影。</p><p><strong>这个目录中存放的就是项目中可以被外部应用使用的代码库</strong>，其他的项目可以直接通过 <code>import</code> 引入这里的代码，所以当我们将代码放入 <code>pkg</code> 时一定要慎重。</p><h4 id="1-1-2-internal"><a href="#1-1-2-internal" class="headerlink" title="1.1.2 /internal"></a>1.1.2 /internal</h4><p>私有代码推荐放到 <code>/internal</code> 目录中，真正的项目代码应该写在 <code>/internal/app</code> 里，同时这些内部应用依赖的代码库应该在 <code>/internal/pkg</code> 子目录和 <code>/pkg</code> 中。</p><h4 id="1-1-3-src"><a href="#1-1-3-src" class="headerlink" title="1.1.3 /src"></a>1.1.3 /src</h4><p>作为一个 Go 语言的开发者，我们不应该允许项目中存在 <code>/src</code> 目录。</p><blockquote><p>社区中的一些项目确实有 <code>/src</code> 文件夹，但是这些项目的开发者之前大多数都有 Java 的编程经验。</p></blockquote><p>最重要的原因其实是 Go 语言的项目在默认情况下都会被放置到 <code>$GOPATH/src</code> 目录下，这个目录中存储着我们开发和依赖的全部项目代码，如果我们在自己的项目中使用 <code>/src</code> 目录，该项目的 <code>PATH</code> 中就会出现两个 <code>src</code></p><p> $GOPATH/src/github.com/draveness/project/src/code.go</p><h4 id="1-1-4-cmd"><a href="#1-1-4-cmd" class="headerlink" title="1.1.4 /cmd"></a>1.1.4 /cmd</h4><p><code>/cmd</code> 目录中存储的都是当前项目中的可执行文件，该目录下的每一个子目录都应该包含我们希望有的可执行文件。</p><blockquote><p>如果我们的项目是一个 <code>grpc</code> 服务的话，可能在 <code>/cmd/server/main.go</code> 中就包含了启动服务进程的代码，编译后生成的可执行文件就是 <code>server</code>。</p></blockquote><h4 id="1-1-5-api"><a href="#1-1-5-api" class="headerlink" title="1.1.5 /api"></a>1.1.5 /api</h4><p><code>/api</code> 目录中存放的就是当前项目对外提供的各种不同类型的 API 接口定义文件了。</p><blockquote><p>其中可能包含类似 <code>/api/protobuf-spec</code>、<code>/api/thrift-spec</code> 或者 <code>/api/http-spec</code> 的目录</p></blockquote><p> $ tree ./api<br> api<br> └── protobuf-spec<br>     └── oceanbookpb<br>         ├── oceanbook.pb.go<br>         └── oceanbook.proto</p><h4 id="1-1-6-Makefile"><a href="#1-1-6-Makefile" class="headerlink" title="1.1.6 Makefile"></a>1.1.6 Makefile</h4><p>最后要介绍的 <code>Makefile</code> 文件也非常值得被关注，在任何一个项目中都会存在一些需要运行的脚本，这些脚本文件应该被放到 <code>/scripts</code> 目录中并由 <code>Makefile</code> 触发，将这些经常需要运行的命令固化成脚本减少『祖传命令』的出现。</p><h4 id="1-1-7-小结"><a href="#1-1-7-小结" class="headerlink" title="1.1.7 小结"></a>1.1.7 小结</h4><p>总的来说，每一个项目都应该按照固定的组织方式进行实现，这种约定虽然并不是强制的，但是无论是组内、公司内还是整个 Go 语言社区中，只要达成了一致，对于其他工程师快速梳理和理解项目都是很有帮助的。</p><h3 id="1-2-模块拆分"><a href="#1-2-模块拆分" class="headerlink" title="1.2 模块拆分"></a>1.2 模块拆分</h3><p>Go 语言的一些顶层设计最终导致了它在划分模块上与其他的编程语言有着非常明显的不同。</p><h4 id="1-2-1-按层拆分"><a href="#1-2-1-按层拆分" class="headerlink" title="1.2.1 按层拆分"></a>1.2.1 按层拆分</h4><p><code>Java</code>中的<code>SpringMVC</code>深受 <a href="https://draveness.me/mvx">MVC 架构模式</a> 的影响,这是一种 Web 框架的最常见架构方式，将服务中的不同组件分成了 Model、View 和 Controller 三层。</p><p> app<br> ├── controllers<br> │   ├── application_controller.rb<br> │   └── concerns<br> ├── models<br> │   ├── application_record.rb<br> │   └── concerns<br> └── views<br>     └── layouts</p><h4 id="1-2-2-按职责拆分"><a href="#1-2-2-按职责拆分" class="headerlink" title="1.2.2 按职责拆分"></a>1.2.2 按职责拆分</h4><p>Go 语言在拆分模块时就使用了完全不同的思路，虽然 MVC 架构模式是在我们写 Web 服务时无法避开的，但是相比于横向地切分不同的层级，Go 语言的项目往往都按照职责对模块进行拆分：</p><p>对于一个比较常见的博客系统，使用 Go 语言的项目会按照不同的职责将其纵向拆分成 <code>post</code>、<code>user</code>、<code>comment</code> 三个模块，每一个模块都对外提供相应的功能，<code>post</code> 模块中就包含相关的模型和视图定义以及用于处理 API 请求的控制器（或者服务）：</p><p> $ tree pkg<br> pkg<br> ├── comment<br> ├── post<br> │   ├── handler.go<br> │   └── post.go<br> └── user</p><p>如果我们在 Go 语言中使用 <code>model</code>、<code>view</code> 和 <code>controller</code> 来划分层级，你会在其他的模块中看到非常多的 <code>model.Post</code>、<code>model.Comment</code> 和 <code>view.PostView</code>。</p><blockquote><p>这种划分层级的方法在 Go 语言中会显得非常冗余，并且如果对项目依赖包的管理不够谨慎时，很容易发生引用循环</p></blockquote><h4 id="1-2-3-小结"><a href="#1-2-3-小结" class="headerlink" title="1.2.3 小结"></a>1.2.3 小结</h4><p>项目是按照层级还是按照职责对模块进行拆分其实并没有绝对的好与不好，语言和框架层面的设计最终决定了我们应该采用哪种方式对项目和代码进行组织。</p><p><strong>Go 语言项目的最佳实践就是按照职责对模块进行垂直拆分，将代码按照功能的方式分到多个 <code>package</code> 中。</strong></p><blockquote><p>因为 <code>package</code> 作为一个 Go 语言访问控制的最小粒度，所以我们应该遵循顶层的设计使用这种方式构建高内聚的模块。</p></blockquote><h3 id="1-3-显式与隐式"><a href="#1-3-显式与隐式" class="headerlink" title="1.3 显式与隐式"></a>1.3 显式与隐式</h3><p>Go 语言社区对于<strong>显式的初始化、方法调用和错误处理</strong>非常推崇，类似 Spring Boot 和 Rails 的框架其实都广泛地采纳了『约定优于配置』的中心思想，简化了开发者和工程师的工作量。</p><blockquote><p>虽然是社区达成的共识与约定，但是从语言的设计以及工具上的使用我们就能发现显式地调用方法和错误处理是被鼓励的。</p></blockquote><h4 id="1-3-1-init"><a href="#1-3-1-init" class="headerlink" title="1.3.1 init"></a>1.3.1 init</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> grpcClient *grpc.Client  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;  </span><br><span class="line">     <span class="keyword">var</span> err <span class="type">error</span>  </span><br><span class="line">     grpcClient, err = grpc.Dial(...)  </span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="built_in">panic</span>(err)  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">GetPost</span><span class="params">(postID <span class="type">int64</span>)</span></span> (*Post, <span class="type">error</span>) &#123;  </span><br><span class="line">     post, err := grpcClient.FindPost(context.Background(), &amp;pb.FindPostRequest&#123;PostID: postID&#125;)  </span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, err  </span><br><span class="line">     &#125;  </span><br><span class="line">       </span><br><span class="line">     <span class="keyword">return</span> post, <span class="literal">nil</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这种代码虽然能够通过编译并且正常工作，然而这里的 <code>init</code> 函数其实隐式地初始化了 grpc 的连接资源，如果另一个 <code>package</code> 依赖了当前的包，那么引入这个依赖的工程师可能会在遇到错误时非常困惑，因为在 <code>init</code> 函数中做这种资源的初始化是非常耗时并且容易出现问题的。</p><p><strong>一种更加合理的做法显示地调用初始化方法。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// cmd/grpc/main.go  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">     grpcClient, err := grpc.Dial(...)  </span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="built_in">panic</span>(err)  </span><br><span class="line">     &#125;  </span><br><span class="line">       </span><br><span class="line">     postClient := post.NewClient(grpcClient)  </span><br><span class="line">     <span class="comment">// ...  </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这样我们从 <code>main</code> 函数开始就能梳理出程序启动的整个过程。</p><p>比较合理地用法是这样的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;  </span><br><span class="line">     <span class="keyword">if</span> user == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">         log.Fatal(<span class="string">&quot;$USER not set&quot;</span>)  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">if</span> home == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">         home = <span class="string">&quot;/home/&quot;</span> + user  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">if</span> gopath == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">         gopath = home + <span class="string">&quot;/go&quot;</span>  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">// gopath may be overridden by --gopath flag on command line.  </span></span><br><span class="line">     flag.StringVar(&amp;gopath, <span class="string">&quot;gopath&quot;</span>, gopath, <span class="string">&quot;override default GOPATH&quot;</span>)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>我们不应该在 <code>init</code> 中做过重的初始化逻辑，而是做一些简单、轻量的前置条件判断</strong></p><h4 id="1-3-2-error"><a href="#1-3-2-error" class="headerlink" title="1.3.2 error"></a>1.3.2 error</h4><p>当我们在 Go 语言中处理错误相关的逻辑时，最重要的其实就是以下几点：</p><ul><li><ol><li><strong>使用 <code>error</code> 实现错误处理</strong> — 尽管这看起来非常啰嗦；</li></ol></li><li><ol><li><strong>将错误抛给上层处理</strong> — 对于一个方法是否需要返回 <code>error</code> 也需要我们仔细地思考，向上抛出错误时可以通过 <code>errors.Wrap</code> 携带一些额外的信息方便上层进行判断；</li></ol></li><li><ol><li><strong>处理所有可能返回的错误</strong> — 所有可能返回错误的地方最终一定会返回错误，考虑全面才能帮助我们构建更加健壮的项目；</li></ol></li></ul><h3 id="1-4-面向接口"><a href="#1-4-面向接口" class="headerlink" title="1.4 面向接口"></a>1.4 面向接口</h3><p>接口的作用其实就是为不同层级的模块提供了一个定义好的中间层，上游不再需要依赖下游的具体实现，充分地对上下游进行了解耦。</p><p>这种编程方式不仅是在 Go 语言中是被推荐的，在几乎所有的编程语言中，我们都会推荐这种编程的方式。它为我们的程序提供了非常强的<code>灵活性</code>，想要构建一个稳定、健壮的 Go 语言项目，不使用接口是完全无法做到的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> post  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">var</span> client *grpc.ClientConn  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;  </span><br><span class="line">     <span class="keyword">var</span> err <span class="type">error</span>  </span><br><span class="line">     client, err = grpc.Dial(...）  </span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="built_in">panic</span>(err)  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">ListPosts</span><span class="params">()</span></span> ([]*Post, <span class="type">error</span>) &#123;  </span><br><span class="line">     posts, err := client.ListPosts(...)  </span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> []*Post&#123;&#125;, err  </span><br><span class="line">     &#125;  </span><br><span class="line">       </span><br><span class="line">     <span class="keyword">return</span> posts, <span class="literal">nil</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述代码其实就不是一个设计良好的代码，它不仅在 <code>init</code> 函数中隐式地初始化了 grpc 连接这种全局变量，而且没有将 <code>ListPosts</code> 通过接口的方式暴露出去，这会让依赖 <code>ListPosts</code> 的上层模块难以测试。</p><p>我们可以使用下面的代码改写原有的逻辑，使得同样地逻辑变得更容易测试和维护：</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> post  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;  </span><br><span class="line">     ListPosts() ([]*Post, <span class="type">error</span>)  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> service <span class="keyword">struct</span> &#123;  </span><br><span class="line">     conn *grpc.ClientConn  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">NewService</span><span class="params">(conn *grpc.ClientConn)</span></span> Service &#123;  </span><br><span class="line">     <span class="keyword">return</span> &amp;service&#123;  </span><br><span class="line">         conn: conn,  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *service)</span></span> ListPosts() ([]*Post, <span class="type">error</span>) &#123;  </span><br><span class="line">     posts, err := s.conn.ListPosts(...)  </span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> []*Post&#123;&#125;, err  </span><br><span class="line">     &#125;  </span><br><span class="line">       </span><br><span class="line">     <span class="keyword">return</span> posts, <span class="literal">nil</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><ol><li>通过接口 <code>Service</code> 暴露对外的 <code>ListPosts</code> 方法；</li></ol></li><li><ol><li>使用 <code>NewService</code> 函数初始化 <code>Service</code> 接口的实现并通过私有的结构体 <code>service</code> 持有 grpc 连接；</li></ol></li><li><ol><li><code>ListPosts</code> 不再依赖全局变量，而是依赖接口体 <code>service</code> 持有的连接；</li></ol></li></ul><p>当我们使用这种方式重构代码之后，就可以在 <code>main</code> 函数中显式的初始化 grpc 连接、创建 <code>Service</code> 接口的实现并调用 <code>ListPosts</code> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> main  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">import</span> ...  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">     conn, err = grpc.Dial(...）  </span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="built_in">panic</span>(err)  </span><br><span class="line">     &#125;  </span><br><span class="line">       </span><br><span class="line">     svc := post.NewService(conn)  </span><br><span class="line">     posts, err := svc.ListPosts()  </span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="built_in">panic</span>(err)  </span><br><span class="line">     &#125;  </span><br><span class="line">       </span><br><span class="line">     fmt.Println(posts)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这种使用接口组织代码的方式在 Go 语言中非常常见，我们应该在代码中尽可能地使用这种思想和模式对外提供功能：</p><ul><li><ol><li>使用大写的 <code>Service</code> 对外暴露方法；</li></ol></li><li><ol><li>使用小写的 <code>service</code> 实现接口中定义的方法；</li></ol></li><li><ol><li>通过 <code>NewService</code> 函数初始化 <code>Service</code> 接口；</li></ol></li></ul><p>当我们使用上述方法组织代码之后，其实就对不同模块的依赖进行了解耦，也正遵循了软件设计中经常被提到的一句话 — 『依赖接口，不要依赖实现』，也就是<strong>面向接口编程</strong>。</p><h3 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h3><p>在这一小节中总共介绍了 Go 语言中三个经常会打交道的『元素』— <code>init</code> 函数、<code>error</code> 和接口，我们在这里主要是想通过三个不同的例子为大家传达的一个主要思想就是尽量使用<strong>显式的（explicit）的方式</strong>编写 Go 语言代码。</p><h2 id="2-单元测试"><a href="#2-单元测试" class="headerlink" title="2 单元测试"></a>2 单元测试</h2><p>一个代码质量和工程质量有保证的项目一定有比较合理的单元测试覆盖率，没有单元测试的项目一定是不合格的或者不重要的，单元测试应该是所有项目都必须有的代码，每一个单元测试都表示一个可能发生的情况，<strong>单元测试就是业务逻辑</strong>。</p><h3 id="2-1-可测试性"><a href="#2-1-可测试性" class="headerlink" title="2.1 可测试性"></a>2.1 可测试性</h3><p>如何控制待测试方法中依赖的模块是写单元测试时至关重要的，控制依赖也就是对目标函数的依赖进行 <code>Mock</code> 消灭不确定性，为了减少每一个单元测试的复杂度，我们需要：</p><ul><li>1）尽可能减少目标方法的依赖，让目标方法只依赖必要的模块；</li><li>2）依赖的模块也应该非常容易地进行 <code>Mock</code>；<h4 id="2-1-1-接口"><a href="#2-1-1-接口" class="headerlink" title="2.1.1 接口"></a>2.1.1 接口</h4></li></ul><p>接口的使用能够为我们带来更清晰的抽象，帮助我们思考如何对代码进行设计，也能让我们更方便地对依赖进行 <code>Mock</code>。</p><p>接口常见用法</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123; ... &#125;  </span><br><span class="line"> ​  </span><br><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123; ... &#125;  </span><br><span class="line"> ​  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewService</span><span class="params">(...)</span></span> (Service, <span class="type">error</span>) &#123;  </span><br><span class="line">   <span class="keyword">return</span> &amp;service&#123;...&#125;, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果你不知道应不应该使用接口对外提供服务，这时就应该无脑地使用上述模式对外暴露方法了，这种模式可以在绝大多数的场景下工作。</p><h4 id="函数简单"><a href="#函数简单" class="headerlink" title="函数简单"></a>函数简单</h4><p>另一个建议就是保证每一个函数尽可能简单，这里的简单不止是指功能上的简单、单一，还意味着函数容易理解并且命名能够自解释。</p><h3 id="组织方式"><a href="#组织方式" class="headerlink" title="组织方式"></a>组织方式</h3><p>Go 语言中的单元测试文件和代码都是与源代码放在同一个目录下按照 <code>package</code> 进行组织的，<code>server.go</code> 文件对应的测试代码应该放在同一目录下的 <code>server_test.go</code> 文件中。</p><h4 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h4><p>单元测试的最常见以及默认组织方式就是写在以 <code>_test.go</code> 结尾的文件中，所有的测试方法也都是以 <code>Test</code> 开头并且只接受一个 <code>testing.T</code> 类型的参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">TestAuthor</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">     author := blog.Author()  </span><br><span class="line">     assert.Equal(t, <span class="string">&quot;draveness&quot;</span>, author)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-Suite"><a href="#2-1-2-Suite" class="headerlink" title="2.1.2 Suite"></a>2.1.2 Suite</h4><p>第二种比较常见的方式是按照簇进行组织，其实就是对 Go 语言默认的测试方式进行简单的封装，我们可以使用 <a href="https://github.com/stretchr/testify">stretchr/testify</a> 中的 <code>suite</code> 包对测试进行组织:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> (  </span><br><span class="line">     <span class="string">&quot;testing&quot;</span>  </span><br><span class="line">     <span class="string">&quot;github.com/stretchr/testify/suite&quot;</span>  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> ExampleTestSuite <span class="keyword">struct</span> &#123;  </span><br><span class="line">     suite.Suite  </span><br><span class="line">     VariableThatShouldStartAtFive <span class="type">int</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(suite *ExampleTestSuite)</span></span> SetupTest() &#123;  </span><br><span class="line">     suite.VariableThatShouldStartAtFive = <span class="number">5</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(suite *ExampleTestSuite)</span></span> TestExample() &#123;  </span><br><span class="line">     suite.Equal(suite.VariableThatShouldStartAtFive, <span class="number">5</span>)  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">TestExampleTestSuite</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">     suite.Run(t, <span class="built_in">new</span>(ExampleTestSuite))  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>suite</code> 包，以结构体的方式对测试簇进行组织，<code>suite</code> 提供的 <code>SetupTest</code>/<code>SetupSuite</code> 和 <code>TearDownTest</code>/<code>TearDownSuite</code> 是执行测试前后以及执行测试簇前后的钩子方法，我们能在其中完成一些共享资源的初始化，减少测试中的初始化代码。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
          <category> 代码规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Panic Recover</title>
      <link href="/2021/09/16/Golang/0%20%E5%9F%BA%E7%A1%80/%E5%85%B3%E9%94%AE%E5%AD%97/Panic%20Recover/"/>
      <url>/2021/09/16/Golang/0%20%E5%9F%BA%E7%A1%80/%E5%85%B3%E9%94%AE%E5%AD%97/Panic%20Recover/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以链表形式存储在 goroutine 结构体中。</p></blockquote><span id="more"></span><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1 1.概述"></a>1 1.概述</h2><p>和 defer 一样，<strong>panic 也是以链表形式存储的</strong>,同样是存储在 goroutine 结构体中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go 395行</span></span><br><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">_panic       *_panic <span class="comment">// innermost panic - offset known to liblink</span></span><br><span class="line">_defer       *_defer <span class="comment">// innermost defer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>panic 链表中链的是一个一个 _panic 结构体。</p><p>和 defer 一样，<strong>发生新的 panic 时也是在 _panic 链表头上插入新的 _panic 结构体</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _panic <span class="keyword">struct</span> &#123;</span><br><span class="line">argp      unsafe.Pointer <span class="comment">// defer 的参数空间地址</span></span><br><span class="line">arg       <span class="keyword">interface</span>&#123;&#125;    <span class="comment">// panic 自己的参数</span></span><br><span class="line">link      *_panic        <span class="comment">// 链接到之前发生的panic</span></span><br><span class="line"></span><br><span class="line">recovered <span class="type">bool</span>           <span class="comment">// 标识panic是否被恢复</span></span><br><span class="line">aborted   <span class="type">bool</span>           <span class="comment">// panic是否被终止</span></span><br><span class="line">    pc        <span class="type">uintptr</span>        </span><br><span class="line">sp        unsafe.Pointer </span><br><span class="line">goexit    <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的 pc、sp、goexit 三个字段主要是为了修复 runtime.Goexit 带来的问题引入的。</p><blockquote><p>runtime.Goexit 能够只结束调用该函数的 Goroutine 而不影响其他的 Goroutine，但是该函数会被 <code>defer</code> 中的 <code>panic</code> 和 <code>recover</code> 取消，引入这三个字段就是为了保证该函数的一定会生效。</p></blockquote><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> A1()</span><br><span class="line"><span class="keyword">defer</span> A2()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;panic A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>具体结构如下图所示：</p><p><img src="file-20250119062723162.png" alt=""></p><h2 id="2-正常流程"><a href="#2-正常流程" class="headerlink" title="2 正常流程"></a>2 正常流程</h2><p>编译器会将关键字 <code>panic</code> 转换成<code>runtime.gopanic</code>函数，该函数执行过程包括以下几个步骤：</p><ul><li>1）创建新的 runtime._panic 并添加到 Goroutine 的 _panic 链表头</li><li>2）在循环中不断从当前 Goroutine 的 <code>_defer</code> 中链表获取<code>runtime._defer</code>,并调用  runtime.reflectcall，运行延迟调用函数。</li><li>3）调用 runtime.fatalpanic 中止整个程序。</li></ul><p>不过 panic 导致的 defer 链表执行和正常 defer 执行有所不同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">started <span class="type">bool</span></span><br><span class="line">_panic    *_panic  <span class="comment">// panic that is running defer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>panic 触发defer执行时，会将 _defer 结构体中的 started 字段标记为 true，同时把 _panic 字段指向自己，表示这个 defer 是由这个 panic 触发的。</p><blockquote><p>这样做主要是为了中止panic，因为defer 函数中有可能还会发生panic。</p></blockquote><p><strong>defer 中的 panic</strong></p><p>如果 defer 函数中也发生了 panic，同样的按照上述逻辑，会创建一个 _panic 结构体，并插入到当前 goroutine 的  _panic 链表头，此时正在执行的 panic 就变成了这个刚发生的 panic。</p><p>这个 panic 执行时也会先去执行 defer 链表，然后发现 defer 链表头指向的 defer 的 started 标记为true，而且 _panic 字段指向的也不是自己，所以就会根据 _panic 指针找到对应的 panic，并将其标记为已终止，即将 aborted 字段设置为 true。</p><p><strong>打印 panic信息</strong></p><p>打印 panic 信息的时候，会从 _panic 链表尾部开始打印，也就是按照 panic 发生的顺序逐个输出。</p><p><strong>例子</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> A1()</span><br><span class="line"><span class="keyword">defer</span> A2()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;panic A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;panic A1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体结构如下图所示：</p><p><img src="file-20250119062734853.png" alt=""></p><p><strong>小结</strong></p><p>没有 recover 的 panic 执行流程就是这个样子了，关键点如下：</p><ul><li>1）<strong>panic 执行 defer 函数的方式</strong>：先标记后释放， 目的是为了终止之前发生的 panic。</li><li>2）<strong>异常信息输出方式</strong>：从 _panic 链表尾部开始打印，也就是按照 panic 发生的顺序逐个输出</li></ul><h2 id="3-带-recover-的-panic"><a href="#3-带-recover-的-panic" class="headerlink" title="3 带 recover 的 panic"></a>3 带 recover 的 panic</h2><p>recover 只做一件事，就是把当前执行的 panic 置为已恢复，即把 recovered 字段置为 true。</p><h3 id="3-1-执行流程"><a href="#3-1-执行流程" class="headerlink" title="3.1 执行流程"></a>3.1 执行流程</h3><ul><li>1）触发 panic。</li><li>2）panic 开始执行 defer 链表</li><li>3）defer 中有 recover，把当前 panic 恢复了（将当前 panic 的 recovered 字段置为 true）。</li><li>4）每个 defer 函数执行完成后，panic 处理流程都会检查当前 panic 是否被它(即刚刚执行的defer函数)恢复了。</li><li>5）panic 处理流程发现当前 panic 已经被恢复了，于是将其从 panic 链表移除，同时对应的也会把前面执行过的那个 defer 函数移除，不过移除前需要保存 _defer.pc 和 _defer.sp 这两个字段的值。</li><li>6）根据前面保存的 _defer.pc 和 _defer.sp 跳出当前 panic 的处理流程。</li></ul><h3 id="3-2-recover"><a href="#3-2-recover" class="headerlink" title="3.2 recover"></a>3.2 recover</h3><p>编译器会将关键字 <code>recover</code> 转换成 runtime.gorecover,代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gorecover</span><span class="params">(argp <span class="type">uintptr</span>)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">gp := getg()</span><br><span class="line">p := gp._panic</span><br><span class="line"><span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; !p.recovered &amp;&amp; argp == <span class="type">uintptr</span>(p.argp) &#123;</span><br><span class="line">p.recovered = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> p.arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-恢复流程"><a href="#3-3-恢复流程" class="headerlink" title="3.3 恢复流程"></a>3.3 恢复流程</h3><p>之前 defer 注册的时候，例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> B()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// dosomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪指令大概是这样子的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r = deferproc(<span class="number">8</span>,B)</span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">goto</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"> ret:</span><br><span class="line">     runtime.deferreturn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sp 是当前函数的栈指针，pc 字段就是调用 deferproc函数的返回地址，也就是下面这段逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> r &gt; <span class="number">0</span>&#123;</span><br><span class="line">    <span class="keyword">goto</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 将寄存器的 r 的值改成了 1，然后进入 if 逻辑，通过 goto 跳转到 ret 位置去执行  runtime.deferreturn()。</p><p>这样就退出了 panic 处理流程。然后由于函数退出前要先执行 defer 链表，所以又进入了 defer 链表的调用流程，直到整个 defer 链表执行完毕，函数正常退出，不会打印任何 panic 信息。</p><p><strong>需要注意的是:只有执行 recover 的函数，正常返回后，才会进入 panic 处理流程，去检查 panic 是否被恢复。</strong></p><h3 id="3-4-recover后再次-panic"><a href="#3-4-recover后再次-panic" class="headerlink" title="3.4 recover后再次 panic"></a>3.4 recover后再次 panic</h3><p>如果 recover 执行后，又触发了 panic，情况就又不一样了：</p><ul><li>1）defer 中执行 recover 将当前 panic 标记为已恢复，然后在这个 defer 函数中又触发了 panic。</li><li>2）将当前这个触发的 panic 添加到 _panic 链表头，由这个 panic 开始再次去执行 defer 链表</li><li>3）发现第一个 defer 已经被执行了(就是刚才调用recover的那个)，但是触发的 panic 不是自己，于是把对应的 panic 标记为已终止，然后把这个已执行的 defer 移除。</li><li>4）继续执行后续的 defer。</li><li>5）最后打印出 panic 信息，不过由于其中有个 panic 是被 recover 过的，所以打印的异常信息中也会将其体现出来。</li></ul><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><code>`https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 关键字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] 代码规范</title>
      <link href="/2021/08/19/Golang/3%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/Golang%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2021/08/19/Golang/3%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/Golang%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>主要记录了一些容易犯错的地方，具体规范参考如下:</p></blockquote><span id="more"></span><p><a href="https://github.com/golang/go/wiki/CodeReviewComments">Go Code Review Comments</a><br><a href="https://github.com/uber-go/guide">uber-go</a></p><h2 id="1-原则"><a href="#1-原则" class="headerlink" title="1 原则"></a>1 原则</h2><h3 id="1-1-零值-Mutex-是有效的"><a href="#1-1-零值-Mutex-是有效的" class="headerlink" title="1.1 零值 Mutex 是有效的"></a>1.1 零值 Mutex 是有效的</h3><p>零值 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code> 是有效的。所以指向 mutex 的指针基本是不必要的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> mu := <span class="built_in">new</span>(sync.Mutex)   </span><br><span class="line"> mu.Lock()  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">var</span> mu sync.Mutex   </span><br><span class="line"> mu.Lock()</span><br></pre></td></tr></table></figure><p>如果你使用结构体指针，mutex 可以非指针形式作为结构体的组成字段，或者更好的方式是直接嵌入到结构体中。 如果是私有结构体类型或是要实现 Mutex 接口的类型，我们可以使用嵌入 mutex 的方法：</p><p><strong>为私有类型或需要实现互斥接口的类型嵌入。</strong></p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> smap <span class="keyword">struct</span> &#123;  </span><br><span class="line">   sync.Mutex <span class="comment">// only for unexported types（仅适用于非导出类型）  </span></span><br><span class="line"> ​  </span><br><span class="line">   data <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">newSMap</span><span class="params">()</span></span> *smap &#123;  </span><br><span class="line">   <span class="keyword">return</span> &amp;smap&#123;  </span><br><span class="line">     data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>),  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *smap)</span></span> Get(k <span class="type">string</span>) <span class="type">string</span> &#123;  </span><br><span class="line">   m.Lock()  </span><br><span class="line">   <span class="keyword">defer</span> m.Unlock()  </span><br><span class="line"> ​  </span><br><span class="line">   <span class="keyword">return</span> m.data[k]  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>对于导出的类型，请使用专用字段。</strong></p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> &#123;  </span><br><span class="line">   mu sync.Mutex <span class="comment">// 对于导出类型，请使用私有锁  </span></span><br><span class="line"> ​  </span><br><span class="line">   data <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">NewSMap</span><span class="params">()</span></span> *SMap &#123;  </span><br><span class="line">   <span class="keyword">return</span> &amp;SMap&#123;  </span><br><span class="line">     data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>),  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *SMap)</span></span> Get(k <span class="type">string</span>) <span class="type">string</span> &#123;  </span><br><span class="line">   m.mu.Lock()  </span><br><span class="line">   <span class="keyword">defer</span> m.mu.Unlock()  </span><br><span class="line"> ​  </span><br><span class="line">   <span class="keyword">return</span> m.data[k]  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-在边界处拷贝-Slices-和-Maps"><a href="#1-2-在边界处拷贝-Slices-和-Maps" class="headerlink" title="1.2 在边界处拷贝 Slices 和 Maps"></a>1.2 在边界处拷贝 Slices 和 Maps</h3><p>slices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。</p><h4 id="1-2-1-接收-Slices-和-Maps"><a href="#1-2-1-接收-Slices-和-Maps" class="headerlink" title="1.2.1 接收 Slices 和 Maps"></a>1.2.1 接收 Slices 和 Maps</h4><p>请记住，当 map 或 slice 作为函数参数传入时，如果您存储了对它们的引用，则用户可以对其进行修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span></span> SetTrips(trips []Trip) &#123;  </span><br><span class="line">   <span class="comment">// 直接赋值则和外部指向同一引用 受外部修改影响  </span></span><br><span class="line">   d.trips = trips  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> trips := ...  </span><br><span class="line"> d1.SetTrips(trips)  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 你是要修改 d1.trips 吗？  </span></span><br><span class="line"> trips[<span class="number">0</span>] = ...</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span></span> SetTrips(trips []Trip) &#123;  </span><br><span class="line">   <span class="comment">// 这里copy单独复制一份出来 之后则不受外部修改影响  </span></span><br><span class="line">   d.trips = <span class="built_in">make</span>([]Trip, <span class="built_in">len</span>(trips))  </span><br><span class="line">   <span class="built_in">copy</span>(d.trips, trips)  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> trips := ...  </span><br><span class="line"> d1.SetTrips(trips)  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 这里我们修改 trips[0]，但不会影响到 d1.trips  </span></span><br><span class="line"> trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure><h4 id="1-2-2-返回-slices-或-maps"><a href="#1-2-2-返回-slices-或-maps" class="headerlink" title="1.2.2 返回 slices 或 maps"></a>1.2.2 返回 slices 或 maps</h4><p>同样，请注意用户对暴露内部状态的 map 或 slice 的修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Bad  </span></span><br><span class="line"> <span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;  </span><br><span class="line">   mu sync.Mutex  </span><br><span class="line"> ​  </span><br><span class="line">   counters <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// Snapshot 返回当前状态。  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span></span> Snapshot() <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;  </span><br><span class="line">   s.mu.Lock()  </span><br><span class="line">   <span class="keyword">defer</span> s.mu.Unlock()  </span><br><span class="line">   <span class="comment">// 直接返回引用 如果外部修改后会受到影响  </span></span><br><span class="line">   <span class="keyword">return</span> s.counters  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// snapshot 不再受互斥锁保护  </span></span><br><span class="line"> <span class="comment">// 因此对 snapshot 的任何访问都将受到数据竞争的影响  </span></span><br><span class="line"> <span class="comment">// 影响 stats.counters  </span></span><br><span class="line"> snapshot := stats.Snapshot()</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;  </span><br><span class="line">   mu sync.Mutex  </span><br><span class="line"> ​  </span><br><span class="line">   counters <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span></span> Snapshot() <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;  </span><br><span class="line">   s.mu.Lock()  </span><br><span class="line">   <span class="keyword">defer</span> s.mu.Unlock()  </span><br><span class="line">  <span class="comment">//单独make一个新的map返回  </span></span><br><span class="line">   result := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="built_in">len</span>(s.counters))  </span><br><span class="line">   <span class="keyword">for</span> k, v := <span class="keyword">range</span> s.counters &#123;  </span><br><span class="line">     result[k] = v  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> result  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// snapshot 现在是一个拷贝  </span></span><br><span class="line"> snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure><h3 id="1-3-Channel-的-size-要么是-1，要么是无缓冲的"><a href="#1-3-Channel-的-size-要么是-1，要么是无缓冲的" class="headerlink" title="1.3 Channel 的 size 要么是 1，要么是无缓冲的"></a>1.3 Channel 的 size 要么是 1，要么是无缓冲的</h3><p>channel 通常 size 应为 1 或是无缓冲的。默认情况下，channel 是无缓冲的，其 size 为零。任何其他尺寸都必须经过严格的审查。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bad  </span></span><br><span class="line"> <span class="comment">// 应该足以满足任何情况！  </span></span><br><span class="line"> c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">64</span>)  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="comment">// 大小：1  </span></span><br><span class="line"> c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>) <span class="comment">// 或者  </span></span><br><span class="line"> <span class="comment">// 无缓冲 channel，大小为 0  </span></span><br><span class="line"> c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure><h3 id="4-枚举从-1-开始"><a href="#4-枚举从-1-开始" class="headerlink" title="4. 枚举从 1 开始"></a>4. 枚举从 1 开始</h3><p>由于变量的默认值为 0，因此<code>通常</code>应以非零值开头枚举。</p><blockquote><p>在某些情况下，使用零值是有意义的（枚举从零开始），例如，当零值是理想的默认行为时。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">type</span> Operation <span class="type">int</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">const</span> (  </span><br><span class="line">   Add Operation = <span class="literal">iota</span>  </span><br><span class="line">   Subtract  </span><br><span class="line">   Multiply  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// Add=0, Subtract=1, Multiply=2</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">type</span> Operation <span class="type">int</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">const</span> (  </span><br><span class="line">   Add Operation = <span class="literal">iota</span> + <span class="number">1</span>  </span><br><span class="line">   Subtract  </span><br><span class="line">   Multiply  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// Add=1, Subtract=2, Multiply=3</span></span><br></pre></td></tr></table></figure><h3 id="1-4-使用-time-处理时间"><a href="#1-4-使用-time-处理时间" class="headerlink" title="1.4 使用 time 处理时间"></a>1.4 使用 time 处理时间</h3><h4 id="1-4-1-使用-time-Time-表达瞬时时间"><a href="#1-4-1-使用-time-Time-表达瞬时时间" class="headerlink" title="1.4.1 使用 time.Time 表达瞬时时间"></a>1.4.1 使用 <code>time.Time</code> 表达瞬时时间</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">isActive</span><span class="params">(now, start, stop <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> start &lt;= now &amp;&amp; now &lt; stop  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">isActive</span><span class="params">(now, start, stop time.Time)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> (start.Before(now) || start.Equal(now)) &amp;&amp; now.Before(stop)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-2-使用-time-Duration-表达时间段"><a href="#1-4-2-使用-time-Duration-表达时间段" class="headerlink" title="1.4.2 使用 time.Duration 表达时间段"></a>1.4.2 使用 <code>time.Duration</code> 表达时间段</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">poll</span><span class="params">(delay <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">for</span> &#123;  </span><br><span class="line">     <span class="comment">// ...  </span></span><br><span class="line">     time.Sleep(time.Duration(delay) * time.Millisecond)  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> poll(<span class="number">10</span>) <span class="comment">// 是几秒钟还是几毫秒?</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">poll</span><span class="params">(delay time.Duration)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">for</span> &#123;  </span><br><span class="line">     <span class="comment">// ...  </span></span><br><span class="line">     time.Sleep(delay)  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> poll(<span class="number">10</span>*time.Second)</span><br></pre></td></tr></table></figure><h4 id="1-4-3-对外部系统使用-time-Time-和-time-Duration"><a href="#1-4-3-对外部系统使用-time-Time-和-time-Duration" class="headerlink" title="1.4.3 对外部系统使用 time.Time 和 time.Duration"></a>1.4.3 对外部系统使用 <code>time.Time</code> 和 <code>time.Duration</code></h4><p>尽可能在与外部系统的交互中使用 <code>time.Duration</code> 和 <code>time.Time</code> 例如 :</p><ul><li><p>Command-line 标志: <a href="https://golang.org/pkg/flag/"><code>flag</code></a> 通过 <a href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code></p></li><li><p>JSON: <a href="https://golang.org/pkg/encoding/json/"><code>encoding/json</code></a> 通过其 <a href="https://golang.org/pkg/time/#Time.UnmarshalJSON"><code>UnmarshalJSON</code> method</a> 方法支持将 <code>time.Time</code> 编码为 <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> 字符串</p></li><li><p>SQL: <a href="https://golang.org/pkg/database/sql/"><code>database/sql</code></a> 支持将 <code>DATETIME</code> 或 <code>TIMESTAMP</code> 列转换为 <code>time.Time</code>，如果底层驱动程序支持则返回</p></li><li><p>YAML: <a href="https://godoc.org/gopkg.in/yaml.v2"><code>gopkg.in/yaml.v2</code></a> 支持将 <code>time.Time</code> 作为 <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> 字符串，并通过 <a href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code>。</p></li></ul><p>当不能在这些交互中使用 <code>time.Duration</code> 时，请使用 <code>int</code> 或 <code>float64</code>，<strong>并在字段名称中包含单位</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="comment">// &#123;&quot;interval&quot;: 2&#125;  </span></span><br><span class="line"> <span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;  </span><br><span class="line">   Interval <span class="type">int</span> <span class="string">`json:&quot;interval&quot;`</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="comment">// &#123;&quot;intervalMillis&quot;: 2000&#125;  </span></span><br><span class="line"> <span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;  </span><br><span class="line">   IntervalMillis <span class="type">int</span> <span class="string">`json:&quot;intervalMillis&quot;`</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-Error"><a href="#1-5-Error" class="headerlink" title="1.5 Error"></a>1.5 Error</h3><p>一个（函数/方法）调用失败时，有三种主要的错误传播方式：</p><ul><li><p>如果没有要添加的其他上下文，并且您想要维护原始错误类型，则返回原始错误。</p></li><li><p>添加上下文，使用 <a href="https://godoc.org/github.com/pkg/errors#Wrap"><code>&quot;pkg/errors&quot;.Wrap</code></a> 以便错误消息提供更多上下文 ,<a href="https://godoc.org/github.com/pkg/errors#Cause"><code>&quot;pkg/errors&quot;.Cause</code></a> 可用于提取原始错误。</p></li><li><p>如果调用者不需要检测或处理的特定错误情况，使用 <a href="https://golang.org/pkg/fmt/#Errorf"><code>fmt.Errorf</code></a>。</p></li></ul><p>建议在可能的地方添加上下文，以使您获得诸如“调用服务 foo：连接被拒绝”之类的更有用的错误，而不是诸如“连接被拒绝”之类的模糊错误。</p><p>在将上下文添加到返回的错误时，<strong>请避免使用“failed to”之类的短语</strong>以保持上下文简洁，这些短语会陈述明显的内容，并随着错误在堆栈中的渗透而逐渐堆积：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> s, err := store.New()  </span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">     <span class="keyword">return</span> fmt.Errorf(  </span><br><span class="line">         <span class="string">&quot;failed to create new store: %s&quot;</span>, err)  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//failed to x: failed to y: failed to create new store: the error</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> s, err := store.New()  </span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">     <span class="keyword">return</span> fmt.Errorf(  </span><br><span class="line">         <span class="string">&quot;new store: %s&quot;</span>, err)  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//x: y: new store: the error</span></span><br></pre></td></tr></table></figure><h3 id="1-6-处理类型断言失败"><a href="#1-6-处理类型断言失败" class="headerlink" title="1.6 处理类型断言失败"></a>1.6 处理类型断言失败</h3><p><a href="https://golang.org/ref/spec#Type_assertions">type assertion</a> 的单个返回值形式针对不正确的类型将产生 panic。因此，请始终使用“comma ok”的惯用法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> t := i.(<span class="type">string</span>)  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> t, ok := i.(<span class="type">string</span>)  </span><br><span class="line"> <span class="keyword">if</span> !ok &#123;  </span><br><span class="line">   <span class="comment">// 优雅地处理错误  </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-panic"><a href="#1-7-panic" class="headerlink" title="1.7 panic"></a>1.7 panic</h3><p>在生产环境中运行的代码必须避免出现 panic，程序初始化除外。</p><h3 id="1-8-避免可变全局变量"><a href="#1-8-避免可变全局变量" class="headerlink" title="1.8 避免可变全局变量"></a>1.8 避免可变全局变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="comment">// sign.go  </span></span><br><span class="line"> <span class="keyword">var</span> _timeNow = time.Now  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">sign</span><span class="params">(msg <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;  </span><br><span class="line">   <span class="comment">//这里使用了全局变量    </span></span><br><span class="line">   now := _timeNow()  </span><br><span class="line">   <span class="keyword">return</span> signWithTime(msg, now)  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="comment">// sign.go  </span></span><br><span class="line"> <span class="keyword">type</span> signer <span class="keyword">struct</span> &#123;  </span><br><span class="line">   now <span class="function"><span class="keyword">func</span><span class="params">()</span></span> time.Time  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">newSigner</span><span class="params">()</span></span> *signer &#123;  </span><br><span class="line">   <span class="keyword">return</span> &amp;signer&#123;  </span><br><span class="line">     now: time.Now,  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *signer)</span></span> Sign(msg <span class="type">string</span>) <span class="type">string</span> &#123;  </span><br><span class="line">   <span class="comment">// 通过将全局变量作为signer的依赖来传递  </span></span><br><span class="line">   now := s.now()  </span><br><span class="line">   <span class="keyword">return</span> signWithTime(msg, now)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-9-避免在公共结构中嵌入类型"><a href="#1-9-避免在公共结构中嵌入类型" class="headerlink" title="1.9 避免在公共结构中嵌入类型"></a>1.9 避免在公共结构中嵌入类型</h3><p>这些嵌入的类型泄漏实现细节、禁止类型演化和模糊的文档。</p><p>假设您使用共享的 <code>AbstractList</code> 实现了多种列表类型，请避免在具体的列表实现中嵌入 <code>AbstractList</code>。 相反，只需手动将方法写入具体的列表，该列表将委托给抽象列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">type</span> AbstractList <span class="keyword">struct</span> &#123;&#125;  </span><br><span class="line"> <span class="comment">// 添加将实体添加到列表中。  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span></span> Add(e Entity) &#123;  </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">// 移除从列表中移除实体。  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span></span> Remove(e Entity) &#123;  </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="comment">// ConcreteList 是一个实体列表。  </span></span><br><span class="line"> <span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;  </span><br><span class="line">    <span class="comment">//直接匿名嵌入不推荐   </span></span><br><span class="line">    <span class="comment">//AbstractList中添加新增方法都会直接影响到ConcreteList  </span></span><br><span class="line">   *AbstractList  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="comment">// ConcreteList 是一个实体列表。  </span></span><br><span class="line"> <span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;  </span><br><span class="line">   <span class="comment">// 显示嵌入 同时添加了委托方法   </span></span><br><span class="line">   <span class="comment">// 这样AbstractList中添加新增方法都不会影响到ConcreteList  </span></span><br><span class="line">   list *AbstractList  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">// 添加将实体添加到列表中。  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span></span> Add(e Entity) &#123;  </span><br><span class="line">   <span class="keyword">return</span> l.list.Add(e)  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">// 移除从列表中移除实体。  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span></span> Remove(e Entity) &#123;  </span><br><span class="line">   <span class="keyword">return</span> l.list.Remove(e)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="2-性能"><a href="#2-性能" class="headerlink" title="2 性能"></a>2 性能</h2><h3 id="2-1-优先使用-strconv-而不是-fmt"><a href="#2-1-优先使用-strconv-而不是-fmt" class="headerlink" title="2.1 优先使用 strconv 而不是 fmt"></a>2.1 优先使用 strconv 而不是 fmt</h3><p>将原语转换为字符串或从字符串转换时，<code>strconv</code>速度比<code>fmt</code>快。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;  </span><br><span class="line">   s := fmt.Sprint(rand.Int())  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">// BenchmarkFmtSprint-4    143 ns/op    2 allocs/op  </span></span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;  </span><br><span class="line">   s := strconv.Itoa(rand.Int())  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//BenchmarkStrconv-4    64.2 ns/op    1 allocs/op</span></span><br></pre></td></tr></table></figure><h3 id="2-2-避免字符串到字节的转换"><a href="#2-2-避免字符串到字节的转换" class="headerlink" title="2.2 避免字符串到字节的转换"></a>2.2 避免字符串到字节的转换</h3><p>不要反复从固定字符串创建字节 slice。相反，请执行一次转换并捕获结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;  </span><br><span class="line">   w.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello world&quot;</span>))  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//BenchmarkBad-4   50000000   22.2 ns/op  </span></span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> data := []<span class="type">byte</span>(<span class="string">&quot;Hello world&quot;</span>)  </span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;  </span><br><span class="line">   w.Write(data)  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//BenchmarkGood-4  500000000   3.25 ns/op</span></span><br></pre></td></tr></table></figure><h3 id="2-3-尽量初始化时指定-Map-容量"><a href="#2-3-尽量初始化时指定-Map-容量" class="headerlink" title="2.3 尽量初始化时指定 Map 容量"></a>2.3 尽量初始化时指定 Map 容量</h3><p>在尽可能的情况下，在使用 <code>make()</code> 初始化的时候提供容量信息,这减少了在将元素添加到 map 时增长和分配的开销</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2, hint)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]os.FileInfo)  </span><br><span class="line"> ​  </span><br><span class="line"> files, _ := ioutil.ReadDir(<span class="string">&quot;./files&quot;</span>)  </span><br><span class="line"> <span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;  </span><br><span class="line">     m[f.Name()] = f  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">// m 是在没有大小提示的情况下创建的； 在运行时可能会有更多分配。  </span></span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> files, _ := ioutil.ReadDir(<span class="string">&quot;./files&quot;</span>)  </span><br><span class="line"> ​  </span><br><span class="line"> m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]os.FileInfo, <span class="built_in">len</span>(files))  </span><br><span class="line"> <span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;  </span><br><span class="line">     m[f.Name()] = f  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//m 是有大小提示创建的；在运行时可能会有更少的分配。</span></span><br></pre></td></tr></table></figure><h2 id="3-规范"><a href="#3-规范" class="headerlink" title="3 规范"></a>3 规范</h2><p>最重要的是，<strong>保持一致</strong>。</p><h3 id="3-1-相似的声明放在一组"><a href="#3-1-相似的声明放在一组" class="headerlink" title="3.1 相似的声明放在一组"></a>3.1 相似的声明放在一组</h3><p>导包应该分为两组：</p><ul><li>标准库</li><li>其他库</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">   <span class="string">&quot;os&quot;</span>  </span><br><span class="line">   <span class="string">&quot;go.uber.org/atomic&quot;</span>  </span><br><span class="line">   <span class="string">&quot;golang.org/x/sync/errgroup&quot;</span>  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">   <span class="string">&quot;os&quot;</span>  </span><br><span class="line">     </span><br><span class="line">   <span class="string">&quot;go.uber.org/atomic&quot;</span>  </span><br><span class="line">   <span class="string">&quot;golang.org/x/sync/errgroup&quot;</span>  </span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>常量、变量和类型声明更应该分组。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">const</span> a = <span class="number">1</span>  </span><br><span class="line"> <span class="keyword">const</span> b = <span class="number">2</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">var</span> a = <span class="number">1</span>  </span><br><span class="line"> <span class="keyword">var</span> b = <span class="number">2</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> Area <span class="type">float64</span>  </span><br><span class="line"> <span class="keyword">type</span> Volume <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">const</span> (  </span><br><span class="line">   a = <span class="number">1</span>  </span><br><span class="line">   b = <span class="number">2</span>  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">var</span> (  </span><br><span class="line">   a = <span class="number">1</span>  </span><br><span class="line">   b = <span class="number">2</span>  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> (  </span><br><span class="line">   Area <span class="type">float64</span>  </span><br><span class="line">   Volume <span class="type">float64</span>  </span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>仅将相关的声明放在一组。不要将不相关的声明放在一组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">type</span> Operation <span class="type">int</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">const</span> (  </span><br><span class="line">   Add Operation = <span class="literal">iota</span> + <span class="number">1</span>  </span><br><span class="line">   Subtract  </span><br><span class="line">   Multiply  </span><br><span class="line">   ENV_VAR = <span class="string">&quot;MY_ENV&quot;</span> <span class="comment">//这个很明显不是一组的 不应该放一起  </span></span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">type</span> Operation <span class="type">int</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">const</span> (  </span><br><span class="line">   Add Operation = <span class="literal">iota</span> + <span class="number">1</span>  </span><br><span class="line">   Subtract  </span><br><span class="line">   Multiply  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">const</span> ENV_VAR = <span class="string">&quot;MY_ENV&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-包名"><a href="#3-2-包名" class="headerlink" title="3.2 包名"></a>3.2 包名</h3><p>当命名包时，请按下面规则选择一个名称：</p><ul><li>全部小写。没有大写或下划线。</li><li>大多数使用命名导入的情况下，不需要重命名。</li><li>简短而简洁。请记住，在每个使用的地方都完整标识了该名称。</li><li>不用复数。例如<code>net/url</code>，而不是<code>net/urls</code>。</li><li><p>不要用“common”，“util”，“shared”或“lib”。这些是不好的，信息量不足的名称。</p><h3 id="3-3-函数分组与顺序"><a href="#3-3-函数分组与顺序" class="headerlink" title="3.3 函数分组与顺序"></a>3.3 函数分组与顺序</h3></li><li><p>函数应按粗略的调用顺序排序。</p></li><li>同一文件中的函数应按接收者分组。</li></ul><p>因此，导出的函数应先出现在文件中，放在<code>struct</code>, <code>const</code>, <code>var</code>定义的后面。<br>在定义类型之后，但在接收者的其余方法之前，可能会出现一个 <code>newXYZ()</code>/<code>NewXYZ()</code><br>由于函数是按接收者分组的，因此普通工具函数应在文件末尾出现。</p><h3 id="3-4-减少嵌套"><a href="#3-4-减少嵌套" class="headerlink" title="3.4 减少嵌套"></a>3.4 减少嵌套</h3><p>代码应通过<strong>尽可能先处理错误情况/特殊情况并尽早返回或继续循环</strong>来减少嵌套。减少嵌套多个级别的代码的代码量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;  </span><br><span class="line">   <span class="keyword">if</span> v.F1 == <span class="number">1</span> &#123;  </span><br><span class="line">     v = process(v)  </span><br><span class="line">     <span class="keyword">if</span> err := v.Call(); err == <span class="literal">nil</span> &#123;  </span><br><span class="line">       v.Send()  </span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> err  </span><br><span class="line">     &#125;  </span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">     log.Printf(<span class="string">&quot;Invalid v: %v&quot;</span>, v)  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;  </span><br><span class="line">   <span class="keyword">if</span> v.F1 != <span class="number">1</span> &#123;  </span><br><span class="line">     log.Printf(<span class="string">&quot;Invalid v: %v&quot;</span>, v)  </span><br><span class="line">     <span class="keyword">continue</span>  </span><br><span class="line">   &#125;  </span><br><span class="line"> ​  </span><br><span class="line">   v = process(v)  </span><br><span class="line">   <span class="keyword">if</span> err := v.Call(); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">     <span class="keyword">return</span> err  </span><br><span class="line">   &#125;  </span><br><span class="line">   v.Send()  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-不必要的-else"><a href="#3-5-不必要的-else" class="headerlink" title="3.5 不必要的 else"></a>3.5 不必要的 else</h3><p>如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">var</span> a <span class="type">int</span>  </span><br><span class="line"> <span class="keyword">if</span> b &#123;  </span><br><span class="line">   a = <span class="number">100</span>  </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">   a = <span class="number">10</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> a := <span class="number">10</span>  </span><br><span class="line"> <span class="keyword">if</span> b &#123;  </span><br><span class="line">   a = <span class="number">100</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-顶层变量声明"><a href="#3-6-顶层变量声明" class="headerlink" title="3.6 顶层变量声明"></a>3.6 顶层变量声明</h3><p>在顶层，使用标准<code>var</code>关键字。请勿指定类型，除非它与表达式的类型不同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">var</span> _s <span class="type">string</span> = F()  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">var</span> _s = F()  </span><br><span class="line"> <span class="comment">// 由于 F 已经明确了返回一个字符串类型，因此我们没有必要显式指定_s 的类型  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>如果表达式的类型与所需的类型不完全匹配，请指定类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">type</span> myError <span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(myError)</span></span> Error() <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;error&quot;</span> &#125;  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> myError &#123; <span class="keyword">return</span> myError&#123;&#125; &#125;  </span><br><span class="line"> <span class="keyword">var</span> _e <span class="type">error</span> = F()  </span><br><span class="line"> <span class="comment">// F 返回一个 myError 类型的实例，但是我们要 error 类型</span></span><br></pre></td></tr></table></figure><h3 id="3-7-对于未导出的顶层常量和变量，使用-作为前缀"><a href="#3-7-对于未导出的顶层常量和变量，使用-作为前缀" class="headerlink" title="3.7 对于未导出的顶层常量和变量，使用_作为前缀"></a>3.7 对于未导出的顶层常量和变量，使用<code>_</code>作为前缀</h3><p>在未导出的顶级<code>vars</code>和<code>consts</code>， 前面加上前缀_，以使它们在使用时明确表示它们是全局符号。</p><blockquote><p>例外：未导出的错误值，应以<code>err</code>开头。</p></blockquote><p>基本依据：顶级变量和常量具有包范围作用域。使用通用名称可能很容易在其他文件中意外使用错误的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="comment">// foo.go  </span></span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">const</span> (  </span><br><span class="line">   defaultPort = <span class="number">8080</span>  </span><br><span class="line">   defaultUser = <span class="string">&quot;user&quot;</span>  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// bar.go  </span></span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   defaultPort := <span class="number">9090</span>  </span><br><span class="line">   ...  </span><br><span class="line">   fmt.Println(<span class="string">&quot;Default port&quot;</span>, defaultPort)  </span><br><span class="line"> ​  </span><br><span class="line">   <span class="comment">// We will not see a compile error if the first line of  </span></span><br><span class="line">   <span class="comment">// Bar() is deleted.  </span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="comment">// foo.go  </span></span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">const</span> (  </span><br><span class="line">   _defaultPort = <span class="number">8080</span>  </span><br><span class="line">   _defaultUser = <span class="string">&quot;user&quot;</span>  </span><br><span class="line"> )</span><br></pre></td></tr></table></figure><h3 id="3-8-结构体中的嵌入"><a href="#3-8-结构体中的嵌入" class="headerlink" title="3.8 结构体中的嵌入"></a>3.8 结构体中的嵌入</h3><p>嵌入式类型（例如 mutex）应位于结构体内的字段列表的顶部，并且必须有一个空行将嵌入式字段与常规字段分隔开。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;  </span><br><span class="line">   version <span class="type">int</span>  </span><br><span class="line">   http.Client  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;  </span><br><span class="line">   http.Client  </span><br><span class="line"> ​  </span><br><span class="line">   version <span class="type">int</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-使用字段名初始化结构体"><a href="#3-9-使用字段名初始化结构体" class="headerlink" title="3.9 使用字段名初始化结构体"></a>3.9 使用字段名初始化结构体</h3><p>初始化结构体时，几乎始终应该指定字段名称。现在由 <a href="https://golang.org/cmd/vet/"><code>go vet</code></a> 强制执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> k := User&#123;<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>, <span class="literal">true</span>&#125;  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> k := User&#123;  </span><br><span class="line">     FirstName: <span class="string">&quot;John&quot;</span>,  </span><br><span class="line">     LastName: <span class="string">&quot;Doe&quot;</span>,  </span><br><span class="line">     Admin: <span class="literal">true</span>,  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>例外：如果有 3 个或更少的字段，则可以在测试表中省略字段名称。</p></blockquote><h3 id="3-10-本地变量声明"><a href="#3-10-本地变量声明" class="headerlink" title="3.10 本地变量声明"></a>3.10 本地变量声明</h3><p>如果将变量明确设置为某个值，则应使用短变量声明形式 (<code>:=</code>)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">var</span> s = <span class="string">&quot;foo&quot;</span>  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> s := <span class="string">&quot;foo&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>但是，在某些情况下，<code>var</code> 使用关键字时默认值会更清晰。例如，声明空切片。</p></blockquote><h3 id="3-11-nil-是一个有效的-slice"><a href="#3-11-nil-是一个有效的-slice" class="headerlink" title="3.11 nil 是一个有效的 slice"></a>3.11 nil 是一个有效的 slice</h3><p><code>nil</code> 是一个有效的长度为 0 的 slice，这意味着，</p><ul><li>您不应明确返回长度为零的切片。应该返回<code>nil</code> 来代替。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">if</span> x == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">if</span> x == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>要检查切片是否为空，请始终使用<code>len(s) == 0</code>。而非 <code>nil</code>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> s == <span class="literal">nil</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(s) == <span class="number">0</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>零值切片（用<code>var</code>声明的切片）可立即使用，无需调用<code>make()</code>创建。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="comment">// 这里没必要make  </span></span><br><span class="line"> nums := []<span class="type">int</span>&#123;&#125;  </span><br><span class="line"> <span class="comment">// or, nums := make([]int)  </span></span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">if</span> add1 &#123;  </span><br><span class="line">   nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">if</span> add2 &#123;  </span><br><span class="line">   nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">var</span> nums []<span class="type">int</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">if</span> add1 &#123;  </span><br><span class="line">   nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">if</span> add2 &#123;  </span><br><span class="line">   nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-12-缩小变量作用域"><a href="#3-12-缩小变量作用域" class="headerlink" title="3.12 缩小变量作用域"></a>3.12 缩小变量作用域</h3><p>如果有可能，尽量缩小变量作用范围。除非它与 <a href="https://github.com/xxjwxc/uber_go_guide_cn#%E5%87%8F%E5%B0%91%E5%B5%8C%E5%A5%97">减少嵌套</a>的规则冲突。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> err := ioutil.WriteFile(name, data, <span class="number">0644</span>)  </span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">  <span class="keyword">return</span> err  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">if</span> err := ioutil.WriteFile(name, data, <span class="number">0644</span>); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">  <span class="keyword">return</span> err  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-13-避免参数语义不明确-Avoid-Naked-Parameters"><a href="#3-13-避免参数语义不明确-Avoid-Naked-Parameters" class="headerlink" title="3.13 避免参数语义不明确(Avoid Naked Parameters)"></a>3.13 避免参数语义不明确(Avoid Naked Parameters)</h3><p>函数调用中的<code>意义不明确的参数</code>可能会损害可读性。当参数名称的含义不明显时，请为参数添加 C 样式注释 (<code>/* ... */</code>)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="comment">// func printInfo(name string, isLocal, done bool)  </span></span><br><span class="line"> printInfo(<span class="string">&quot;foo&quot;</span>, <span class="literal">true</span>, <span class="literal">true</span>)  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="comment">// func printInfo(name string, isLocal, done bool)  </span></span><br><span class="line"> printInfo(<span class="string">&quot;foo&quot;</span>, <span class="literal">true</span> <span class="comment">/* isLocal */</span>, <span class="literal">true</span> <span class="comment">/* done */</span>)</span><br></pre></td></tr></table></figure><p>对于上面的示例代码，还有一种更好的处理方式是将上面的 <code>bool</code> 类型换成自定义类型。将来，该参数可以支持不仅仅局限于两个状态（true/false）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">type</span> Region <span class="type">int</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">const</span> (  </span><br><span class="line">   UnknownRegion Region = <span class="literal">iota</span>  </span><br><span class="line">   Local  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> Status <span class="type">int</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">const</span> (  </span><br><span class="line">   StatusReady Status= <span class="literal">iota</span> + <span class="number">1</span>  </span><br><span class="line">   StatusDone  </span><br><span class="line">   <span class="comment">// Maybe we will have a StatusInProgress in the future.  </span></span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">(name <span class="type">string</span>, region Region, status Status)</span></span></span><br></pre></td></tr></table></figure><h3 id="3-14-使用原始字符串字面值，避免转义"><a href="#3-14-使用原始字符串字面值，避免转义" class="headerlink" title="3.14 使用原始字符串字面值，避免转义"></a>3.14 使用原始字符串字面值，避免转义</h3><p>Go 支持使用 <a href="https://golang.org/ref/spec#raw_string_lit">原始字符串字面值</a>，也就是 “ ` “ 来表示原生字符串，在需要转义的场景下，我们应该尽量使用这种方案来替换。</p><p>可以跨越多行并包含引号。使用这些字符串可以避免更难阅读的手工转义的字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> wantError := <span class="string">&quot;unknown name:\&quot;test\&quot;&quot;</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> wantError := <span class="string">`unknown error:&quot;test&quot;`</span></span><br></pre></td></tr></table></figure><h2 id="4-编程模式"><a href="#4-编程模式" class="headerlink" title="4 编程模式"></a>4 编程模式</h2><h3 id="4-1-表驱动测试"><a href="#4-1-表驱动测试" class="headerlink" title="4.1 表驱动测试"></a>4.1 表驱动测试</h3><p>当测试逻辑是重复的时候，通过 <a href="https://blog.golang.org/subtests">subtests</a> 使用 table 驱动的方式编写 case 代码看上去会更简洁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="comment">// func TestSplitHostPort(t *testing.T)  </span></span><br><span class="line"> ​  </span><br><span class="line"> host, port, err := net.SplitHostPort(<span class="string">&quot;192.0.2.0:8000&quot;</span>)  </span><br><span class="line"> require.NoError(t, err)  </span><br><span class="line"> assert.Equal(t, <span class="string">&quot;192.0.2.0&quot;</span>, host)  </span><br><span class="line"> assert.Equal(t, <span class="string">&quot;8000&quot;</span>, port)  </span><br><span class="line"> ​  </span><br><span class="line"> host, port, err = net.SplitHostPort(<span class="string">&quot;192.0.2.0:http&quot;</span>)  </span><br><span class="line"> require.NoError(t, err)  </span><br><span class="line"> assert.Equal(t, <span class="string">&quot;192.0.2.0&quot;</span>, host)  </span><br><span class="line"> assert.Equal(t, <span class="string">&quot;http&quot;</span>, port)  </span><br><span class="line"> ​  </span><br><span class="line"> host, port, err = net.SplitHostPort(<span class="string">&quot;:8000&quot;</span>)  </span><br><span class="line"> require.NoError(t, err)  </span><br><span class="line"> assert.Equal(t, <span class="string">&quot;&quot;</span>, host)  </span><br><span class="line"> assert.Equal(t, <span class="string">&quot;8000&quot;</span>, port)  </span><br><span class="line"> ​  </span><br><span class="line"> host, port, err = net.SplitHostPort(<span class="string">&quot;1:8&quot;</span>)  </span><br><span class="line"> require.NoError(t, err)  </span><br><span class="line"> assert.Equal(t, <span class="string">&quot;1&quot;</span>, host)  </span><br><span class="line"> assert.Equal(t, <span class="string">&quot;8&quot;</span>, port)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="comment">// func TestSplitHostPort(t *testing.T)  </span></span><br><span class="line"> ​  </span><br><span class="line"> tests := []<span class="keyword">struct</span>&#123;  </span><br><span class="line">   give     <span class="type">string</span>  </span><br><span class="line">   wantHost <span class="type">string</span>  </span><br><span class="line">   wantPort <span class="type">string</span>  </span><br><span class="line"> &#125;&#123;  </span><br><span class="line">   &#123;  </span><br><span class="line">     give:     <span class="string">&quot;192.0.2.0:8000&quot;</span>,  </span><br><span class="line">     wantHost: <span class="string">&quot;192.0.2.0&quot;</span>,  </span><br><span class="line">     wantPort: <span class="string">&quot;8000&quot;</span>,  </span><br><span class="line">   &#125;,  </span><br><span class="line">   &#123;  </span><br><span class="line">     give:     <span class="string">&quot;192.0.2.0:http&quot;</span>,  </span><br><span class="line">     wantHost: <span class="string">&quot;192.0.2.0&quot;</span>,  </span><br><span class="line">     wantPort: <span class="string">&quot;http&quot;</span>,  </span><br><span class="line">   &#125;,  </span><br><span class="line">   &#123;  </span><br><span class="line">     give:     <span class="string">&quot;:8000&quot;</span>,  </span><br><span class="line">     wantHost: <span class="string">&quot;&quot;</span>,  </span><br><span class="line">     wantPort: <span class="string">&quot;8000&quot;</span>,  </span><br><span class="line">   &#125;,  </span><br><span class="line">   &#123;  </span><br><span class="line">     give:     <span class="string">&quot;1:8&quot;</span>,  </span><br><span class="line">     wantHost: <span class="string">&quot;1&quot;</span>,  </span><br><span class="line">     wantPort: <span class="string">&quot;8&quot;</span>,  </span><br><span class="line">   &#125;,  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;  </span><br><span class="line">   t.Run(tt.give, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">     host, port, err := net.SplitHostPort(tt.give)  </span><br><span class="line">     require.NoError(t, err)  </span><br><span class="line">     assert.Equal(t, tt.wantHost, host)  </span><br><span class="line">     assert.Equal(t, tt.wantPort, port)  </span><br><span class="line">   &#125;)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们遵循这样的约定：将结构体切片称为<code>tests</code>。 每个测试用例称为<code>tt</code>。此外，我们鼓励使用<code>give</code>和<code>want</code>前缀说明每个测试用例的输入和输出值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> tests := []<span class="keyword">struct</span>&#123;  </span><br><span class="line">   give     <span class="type">string</span>  </span><br><span class="line">   wantHost <span class="type">string</span>  </span><br><span class="line">   wantPort <span class="type">string</span>  </span><br><span class="line"> &#125;&#123;  </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;  </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-功能选项"><a href="#4-2-功能选项" class="headerlink" title="4.2 功能选项"></a>4.2 功能选项</h3><p>功能选项是一种模式，您可以在其中声明一个不透明 Option 类型，该类型在某些内部结构中记录信息。您接受这些选项的可变编号，并根据内部结构上的选项记录的全部信息采取行动。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bad  </span></span><br><span class="line"> <span class="comment">// package db  </span></span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">   addr <span class="type">string</span>,  </span></span></span><br><span class="line"><span class="params"><span class="function">   cache <span class="type">bool</span>,  </span></span></span><br><span class="line"><span class="params"><span class="function">   logger *zap.Logger  </span></span></span><br><span class="line"><span class="params"><span class="function"> )</span></span> (*Connection, <span class="type">error</span>) &#123;  </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//使用  </span></span><br><span class="line"> <span class="comment">//必须始终提供缓存和记录器参数，即使用户希望使用默认值。  </span></span><br><span class="line"> ​  </span><br><span class="line"> db.Open(addr, db.DefaultCache, zap.NewNop())  </span><br><span class="line"> db.Open(addr, db.DefaultCache, log)  </span><br><span class="line"> db.Open(addr, <span class="literal">false</span> <span class="comment">/* cache */</span>, zap.NewNop())  </span><br><span class="line"> db.Open(addr, <span class="literal">false</span> <span class="comment">/* cache */</span>, log)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="comment">// package db  </span></span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;  </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">WithCache</span><span class="params">(c <span class="type">bool</span>)</span></span> Option &#123;  </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">WithLogger</span><span class="params">(log *zap.Logger)</span></span> Option &#123;  </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// Open creates a connection.  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">   addr <span class="type">string</span>,  </span></span></span><br><span class="line"><span class="params"><span class="function">   opts ...Option,  </span></span></span><br><span class="line"><span class="params"><span class="function"> )</span></span> (*Connection, <span class="type">error</span>) &#123;  </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">//使用  </span></span><br><span class="line"> <span class="comment">//只有在需要时才提供选项。  </span></span><br><span class="line"> ​  </span><br><span class="line"> db.Open(addr)  </span><br><span class="line"> db.Open(addr, db.WithLogger(log))  </span><br><span class="line"> db.Open(addr, db.WithCache(<span class="literal">false</span>))  </span><br><span class="line"> db.Open(  </span><br><span class="line">   addr,  </span><br><span class="line">   db.WithCache(<span class="literal">false</span>),  </span><br><span class="line">   db.WithLogger(log),  </span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>我们建议实现此模式的方法是使用一个 <code>Option</code> 接口，该接口保存一个未导出的方法，在一个未导出的 <code>options</code> 结构上记录选项。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">type</span> options <span class="keyword">struct</span> &#123;  </span><br><span class="line">   cache  <span class="type">bool</span>  </span><br><span class="line">   logger *zap.Logger  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;  </span><br><span class="line">   apply(*options)  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> cacheOption <span class="type">bool</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(c cacheOption)</span></span> apply(opts *options) &#123;  </span><br><span class="line">   opts.cache = <span class="type">bool</span>(c)  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">WithCache</span><span class="params">(c <span class="type">bool</span>)</span></span> Option &#123;  </span><br><span class="line">   <span class="keyword">return</span> cacheOption(c)  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> loggerOption <span class="keyword">struct</span> &#123;  </span><br><span class="line">   Log *zap.Logger  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(l loggerOption)</span></span> apply(opts *options) &#123;  </span><br><span class="line">   opts.logger = l.Log  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">WithLogger</span><span class="params">(log *zap.Logger)</span></span> Option &#123;  </span><br><span class="line">   <span class="keyword">return</span> loggerOption&#123;Log: log&#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// Open creates a connection.  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">   addr <span class="type">string</span>,  </span></span></span><br><span class="line"><span class="params"><span class="function">   opts ...Option,  </span></span></span><br><span class="line"><span class="params"><span class="function"> )</span></span> (*Connection, <span class="type">error</span>) &#123;  </span><br><span class="line">   options := options&#123;  </span><br><span class="line">     cache:  defaultCache,  </span><br><span class="line">     logger: zap.NewNop(),  </span><br><span class="line">   &#125;  </span><br><span class="line"> ​  </span><br><span class="line">   <span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;  </span><br><span class="line">     o.apply(&amp;options)  </span><br><span class="line">   &#125;  </span><br><span class="line"> ​  </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
          <category> 代码规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Golang Channel实现互斥锁</title>
      <link href="/2021/08/17/Golang/4%20%E5%85%B6%E4%BB%96/Channel%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E9%94%81/"/>
      <url>/2021/08/17/Golang/4%20%E5%85%B6%E4%BB%96/Channel%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E9%94%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用长度为1的有缓冲channel实现互斥锁</p></blockquote><span id="more"></span><pre><code class="lang-go">package mainimport (    &quot;sync&quot;)// Lock 锁结构type Lock struct &#123;    c chan struct&#123;&#125;&#125;// NewLock 生成一个锁func NewLock() Lock &#123;    var l Lock    l.c = make(chan struct&#123;&#125;, 1)    l.c &lt;- struct&#123;&#125;&#123;&#125; // 放入一把锁用于获取    return l&#125;// TryLock 尝试加锁,成功返回true,失败返回false，不会阻塞等待func (l Lock) TryLock() bool &#123;    var lockResult bool    select &#123;    case &lt;-l.c:        lockResult = true    default:    &#125;    return lockResult&#125;// 加锁,会阻塞竞争func (l Lock) Lock() &#123;    &lt;-l.c&#125;// 解锁,重复解锁会阻塞func (l Lock) Unlock() &#123;    l.c &lt;- struct&#123;&#125;&#123;&#125;&#125;var counter intfunc main() &#123;    l := NewLock()    var wg sync.WaitGroup    for i := 0; i &lt; 10; i++ &#123;        wg.Add(1)        go func() &#123;            defer wg.Done()            if !l.TryLock() &#123;                println(&quot;lock failed&quot;)                return            &#125;            counter++            println(&quot;try lock counter &quot;, counter)            l.Unlock()        &#125;()    &#125;    for i := 0; i &lt; 10; i++ &#123;        wg.Add(1)        go func() &#123;            defer wg.Done()            l.Lock()            counter++            println(&quot;lock counter &quot;, counter)            l.Unlock()        &#125;()    &#125;    wg.Wait()&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Golang Concatenate Strings</title>
      <link href="/2021/08/17/Golang/4%20%E5%85%B6%E4%BB%96/Concatenate%20Strings/"/>
      <url>/2021/08/17/Golang/4%20%E5%85%B6%E4%BB%96/Concatenate%20Strings/</url>
      
        <content type="html"><![CDATA[<blockquote><p>How to Efficiently Concatenate Strings in Go</p></blockquote><span id="more"></span><h2 id="1-种拼接方式"><a href="#1-种拼接方式" class="headerlink" title="1 种拼接方式"></a>1 种拼接方式</h2><h3 id="1-1-String-Concat"><a href="#1-1-String-Concat" class="headerlink" title="1.1 String Concat"></a>1.1 String Concat</h3><p>Str += “hello-world”</p><h3 id="1-2-String-Sprintf"><a href="#1-2-String-Sprintf" class="headerlink" title="1.2 String Sprintf"></a>1.2 String Sprintf</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Str = fmt.Sprintf (<span class="string">&quot;%s%s&quot;</span>, str, <span class="string">&quot;hello-world&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="1-3-String-Join"><a href="#1-3-String-Join" class="headerlink" title="1.3 String Join"></a>1.3 String Join</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Str = strings.Join ([]<span class="type">string</span>&#123;str, <span class="string">&quot;hello-world&quot;</span>&#125;, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="1-4-Buffer-Write"><a href="#1-4-Buffer-Write" class="headerlink" title="1.4 Buffer Write"></a>1.4 Buffer Write</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Buf := <span class="built_in">new</span> (bytes. Buffer)</span><br><span class="line">Buf.WriteString (<span class="string">&quot;hello-world&quot;</span>)</span><br><span class="line">Str := buf.String ()</span><br></pre></td></tr></table></figure><h3 id="1-5-Bytes-Append"><a href="#1-5-Bytes-Append" class="headerlink" title="1.5 Bytes Append"></a>1.5 Bytes Append</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Var b []<span class="type">byte</span></span><br><span class="line">S := <span class="string">&quot;hello-world&quot;</span></span><br><span class="line">b = <span class="built_in">append</span> (b, s...)</span><br><span class="line">Str := <span class="type">string</span> (b)</span><br></pre></td></tr></table></figure><h3 id="1-6-String-Copy"><a href="#1-6-String-Copy" class="headerlink" title="1.6 String Copy"></a>1.6 String Copy</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Ts := <span class="string">&quot;hello-world&quot;</span></span><br><span class="line">N := <span class="number">5</span></span><br><span class="line">Tsl := <span class="built_in">len</span> (ts) * n</span><br><span class="line">Bs := <span class="built_in">make</span> ([]<span class="type">byte</span>, tsl)</span><br><span class="line">Bl := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">For bl &lt; tsl &#123;</span><br><span class="line">    Bl += <span class="built_in">copy</span> (bs[bl:], ts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Str := <span class="type">string</span> (bs)</span><br></pre></td></tr></table></figure><h3 id="1-7-String-Builder"><a href="#1-7-String-Builder" class="headerlink" title="1.7 String Builder"></a>1.7 String Builder</h3><p>From Go 1.10 there is a strings. Builder type</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Var builder strings. Builder</span><br><span class="line">Builder.WriteString (<span class="string">&quot;hello-world&quot;</span>)</span><br><span class="line">Str := builder.String ()</span><br></pre></td></tr></table></figure><h2 id="2-Benchmark"><a href="#2-Benchmark" class="headerlink" title="2 Benchmark"></a>2 Benchmark</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br></pre></td><td class="code"><pre><span class="line">Package main</span><br><span class="line"></span><br><span class="line">Import (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Const (</span><br><span class="line">    Sss = <span class="string">&quot;xfoasneobfasieongasbg&quot;</span></span><br><span class="line">    Cnt = <span class="number">10000</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Var (</span><br><span class="line">    Bbb      = []<span class="type">byte</span> (sss)</span><br><span class="line">    Expected = strings.Repeat (sss, cnt)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Func BenchmarkCopyPreAllocate (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Bs := <span class="built_in">make</span> ([]<span class="type">byte</span>, cnt*<span class="built_in">len</span> (sss))</span><br><span class="line">        Bl := <span class="number">0</span></span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Bl += <span class="built_in">copy</span> (bs[bl:], sss)</span><br><span class="line">        &#125;</span><br><span class="line">        Result = <span class="type">string</span> (bs)</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkAppendPreAllocate (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Data := <span class="built_in">make</span> ([]<span class="type">byte</span>, <span class="number">0</span>, cnt*<span class="built_in">len</span> (sss))</span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Data = <span class="built_in">append</span> (data, sss...)</span><br><span class="line">        &#125;</span><br><span class="line">        Result = <span class="type">string</span> (data)</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkBufferPreAllocate (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Buf := bytes.NewBuffer (<span class="built_in">make</span> ([]<span class="type">byte</span>, <span class="number">0</span>, cnt*<span class="built_in">len</span> (sss)))</span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Buf.WriteString (sss)</span><br><span class="line">        &#125;</span><br><span class="line">        Result = buf.String ()</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkCopy (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Data := <span class="built_in">make</span> ([]<span class="type">byte</span>, <span class="number">0</span>, <span class="number">64</span>) <span class="comment">// same size as bootstrap array of bytes. Buffer</span></span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Off := <span class="built_in">len</span> (data)</span><br><span class="line">            If off+<span class="built_in">len</span> (sss) &gt; <span class="built_in">cap</span> (data) &#123;</span><br><span class="line">                Temp := <span class="built_in">make</span> ([]<span class="type">byte</span>, <span class="number">2</span>*<span class="built_in">cap</span> (data)+<span class="built_in">len</span> (sss))</span><br><span class="line">                Copy (temp, data)</span><br><span class="line">                Data = temp</span><br><span class="line">            &#125;</span><br><span class="line">            Data = data[<span class="number">0</span> : off+<span class="built_in">len</span> (sss)]</span><br><span class="line">            Copy (data[off:], sss)</span><br><span class="line">        &#125;</span><br><span class="line">        Result = <span class="type">string</span> (data)</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkCopyX (b *testing. B) &#123;</span><br><span class="line">    bs := <span class="built_in">make</span> ([]<span class="type">byte</span>, b.N)</span><br><span class="line">    Bl := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        bl += <span class="built_in">copy</span>(bs[bl:], <span class="string">&quot;x&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s := strings.Repeat(<span class="string">&quot;x&quot;</span>, b.N); <span class="type">string</span>(bs) != s &#123;</span><br><span class="line">        b.Errorf(<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span>(bs), s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkAppend (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Data := <span class="built_in">make</span> ([]<span class="type">byte</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Data = <span class="built_in">append</span> (data, sss...)</span><br><span class="line">        &#125;</span><br><span class="line">        Result = <span class="type">string</span> (data)</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkBufferWrite (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Var buf bytes. Buffer</span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Buf.Write (bbb)</span><br><span class="line">        &#125;</span><br><span class="line">        Result = buf.String ()</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkBufferWriteString (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Var buf bytes. Buffer</span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Buf.WriteString (sss)</span><br><span class="line">        &#125;</span><br><span class="line">        Result = buf.String ()</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkConcatString (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Var str <span class="type">string</span></span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Str += sss</span><br><span class="line">        &#125;</span><br><span class="line">        Result = str</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkConcat (b *testing. B) &#123;</span><br><span class="line">    Var str <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Str += <span class="string">&quot;x&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s := strings.Repeat(<span class="string">&quot;x&quot;</span>, b.N); str != s &#123;</span><br><span class="line">        b.Errorf(<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, str, s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkBuffer (b *testing. B) &#123;</span><br><span class="line">    Var buffer bytes. Buffer</span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Buffer.WriteString (<span class="string">&quot;x&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s := strings.Repeat(<span class="string">&quot;x&quot;</span>, b.N); buffer.String() != s &#123;</span><br><span class="line">        b.Errorf(<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, buffer.String(), s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go 1.10</span></span><br><span class="line">Func BenchmarkStringBuilderX (b *testing. B) &#123;</span><br><span class="line">    Var strBuilder strings. Builder</span><br><span class="line"></span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        strBuilder.WriteString(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s := strings.Repeat(<span class="string">&quot;x&quot;</span>, b.N); strBuilder.String() != s &#123;</span><br><span class="line">        b.Errorf(<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, strBuilder.String(), s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkStringBuilder (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Var builder strings. Builder</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            builder.WriteString(sss)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = builder.String()</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer()</span><br><span class="line">    <span class="keyword">if</span> result != expected &#123;</span><br><span class="line">        b.Errorf(<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span>(result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkStringConcat (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Var str <span class="type">string</span></span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Str += sss</span><br><span class="line">        &#125;</span><br><span class="line">        Result = str</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkStringSprintf (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Var str <span class="type">string</span></span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Str = fmt.Sprintf (<span class="string">&quot;%s%s&quot;</span>, str, sss)</span><br><span class="line">        &#125;</span><br><span class="line">        Result = str</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkStringJoin (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Var str <span class="type">string</span></span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Str = strings.Join ([]<span class="type">string</span>&#123;str, sss&#125;, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Result = str</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkBytesAppend (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Var bbb []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            bbb = <span class="built_in">append</span>(bbb, sss...)</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="type">string</span>(bbb)</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer()</span><br><span class="line">    <span class="keyword">if</span> result != expected &#123;</span><br><span class="line">        b.Errorf(<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span>(result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkStringCopy (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Tsl := <span class="built_in">len</span> (sss) * cnt</span><br><span class="line">        Bs := <span class="built_in">make</span> ([]<span class="type">byte</span>, tsl)</span><br><span class="line">        Bl := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> bl &lt; tsl &#123;</span><br><span class="line">            bl += <span class="built_in">copy</span>(bs[bl:], sss)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = <span class="type">string</span>(bs)</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer()</span><br><span class="line">    <span class="keyword">if</span> result != expected &#123;</span><br><span class="line">        b.Errorf(<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span>(result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test Results:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Go test -v strings_concat_benchmark_test. Go -bench=. -benchmem</span><br><span class="line">Goos: darwin</span><br><span class="line">Goarch: amd 64</span><br><span class="line">BenchmarkCopyPreAllocate-4          8043            125464 ns/op          425984 B/op          2 allocs/op</span><br><span class="line">BenchmarkAppendPreAllocate-4        9818            126881 ns/op          425985 B/op          2 allocs/op</span><br><span class="line">BenchmarkBufferPreAllocate-4        7656            161158 ns/op          425984 B/op          2 allocs/op</span><br><span class="line">BenchmarkCopy-4                     4903            250800 ns/op          929185 B/op         13 allocs/op</span><br><span class="line">BenchmarkCopyX-4                263460769                5.19 ns/op            0 B/op          0 allocs/op</span><br><span class="line">BenchmarkAppend-4                   3820            384086 ns/op         1333122 B/op         24 allocs/op</span><br><span class="line">BenchmarkBufferWrite-4              3626            299617 ns/op          929250 B/op         14 allocs/op</span><br><span class="line">BenchmarkBufferWriteString-4        4428            286061 ns/op          929249 B/op         14 allocs/op</span><br><span class="line">BenchmarkConcatString-4                5         210904237 ns/op        1086401044 B/op    10037 allocs/op</span><br><span class="line">BenchmarkConcat-4                1000000            118204 ns/op          503996 B/op          1 allocs/op</span><br><span class="line">BenchmarkBuffer-4               132420037                8.74 ns/op            2 B/op          0 allocs/op</span><br><span class="line">BenchmarkStringBuilderX-4       418325671                5.97 ns/op            6 B/op          0 allocs/op</span><br><span class="line">BenchmarkStringBuilder-4            3890            310115 ns/op         1120224 B/op         25 allocs/op</span><br><span class="line">BenchmarkStringConcat-4                5         229555747 ns/op        1086401641 B/op    10050 allocs/op</span><br><span class="line">BenchmarkStringSprintf-4               3         451219496 ns/op        2068371440 B/op    35040 allocs/op</span><br><span class="line">BenchmarkStringJoin-4                  4         281371101 ns/op        1086401946 B/op    10058 allocs/op</span><br><span class="line">BenchmarkBytesAppend-4              3406            406706 ns/op         1333218 B/op         26 allocs/op</span><br><span class="line">BenchmarkStringCopy-4               9100            133990 ns/op          425984 B/op          2 allocs/op</span><br><span class="line">PASS</span><br><span class="line">Ok      command-line-arguments  148.510 s</span><br></pre></td></tr></table></figure><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h2><ul><li><a href="https://stackoverflow.com/questions/1760757/how-to-efficiently-concatenate-strings-in-go">How to Efficiently Concatenate Strings in Go</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Golang Quic</title>
      <link href="/2021/08/17/Golang/4%20%E5%85%B6%E4%BB%96/Quic/"/>
      <url>/2021/08/17/Golang/4%20%E5%85%B6%E4%BB%96/Quic/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Quick UDP Internet Connection</p></blockquote><span id="more"></span><h2 id="1-QUIC-概述"><a href="#1-QUIC-概述" class="headerlink" title="1 QUIC 概述"></a>1 QUIC 概述</h2><p>QUIC（Quick UDP Internet Connection，快速 UDP 互联网连接协议）是一种以 UDP 为底层传输协议，支持加密、多路复用，工作在用户空间的的低延迟传输协议。</p><p>Quic 相比现在广泛应用的 http2+tcp+tls 协议有如下优势：</p><ol><li>减少了 TCP 三次握手及 TLS 握手时间。</li><li>改进的拥塞控制。</li><li>避免队头阻塞的多路复用。</li><li>连接迁移。</li><li>前向冗余纠错。</li></ol><h2 id="2-server"><a href="#2-server" class="headerlink" title="2 server"></a>2 server</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/rsa&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/tls&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/pem&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;math/big&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/lucas-clemente/quic-go&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> saddr = <span class="string">&quot;localhost:9999&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listener, err := quic.ListenAddr(saddr, generateTLSConfig(), <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sess, err := listener.Accept(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">go</span> dealSession(sess)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dealSession</span><span class="params">(sess quic.Session)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;LocalAddr %s, RemoteAddr %s\n&quot;</span>,</span><br><span class="line">sess.LocalAddr().String(),</span><br><span class="line">sess.RemoteAddr().String())</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line">stream, err := sess.AcceptStream(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//panic(err)</span></span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_, err = io.Copy(loggingWriter&#123;stream&#125;, stream)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;err &quot;</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> loggingWriter <span class="keyword">struct</span>&#123; io.Writer &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w loggingWriter)</span></span> Write(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Server: Got &#x27;%s&#x27;\n&quot;</span>, <span class="type">string</span>(b))</span><br><span class="line"><span class="keyword">return</span> w.Writer.Write(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup a bare-bones TLS config for the server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateTLSConfig</span><span class="params">()</span></span> *tls.Config &#123;</span><br><span class="line">key, err := rsa.GenerateKey(rand.Reader, <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">template := x509.Certificate&#123;SerialNumber: big.NewInt(<span class="number">1</span>)&#125;</span><br><span class="line">certDER, err := x509.CreateCertificate(rand.Reader, &amp;template, &amp;template, &amp;key.PublicKey, key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">keyPEM := pem.EncodeToMemory(&amp;pem.Block&#123;Type: <span class="string">&quot;RSA PRIVATE KEY&quot;</span>, Bytes: x509.MarshalPKCS1PrivateKey(key)&#125;)</span><br><span class="line">certPEM := pem.EncodeToMemory(&amp;pem.Block&#123;Type: <span class="string">&quot;CERTIFICATE&quot;</span>, Bytes: certDER&#125;)</span><br><span class="line"></span><br><span class="line">tlsCert, err := tls.X509KeyPair(certPEM, keyPEM)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;tls.Config&#123;</span><br><span class="line">Certificates: []tls.Certificate&#123;tlsCert&#125;,</span><br><span class="line">NextProtos:   []<span class="type">string</span>&#123;<span class="string">&quot;quic-example&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-client"><a href="#3-client" class="headerlink" title="3 client"></a>3 client</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/tls&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/lucas-clemente/quic-go&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addr = <span class="string">&quot;localhost:9999&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tlsConf := &amp;tls.Config&#123;</span><br><span class="line">InsecureSkipVerify: <span class="literal">true</span>,</span><br><span class="line">NextProtos:         []<span class="type">string</span>&#123;<span class="string">&quot;quic-example&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">session, err := quic.DialAddr(addr, tlsConf, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">stream, err := session.OpenStreamSync(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ticker := time.NewTicker(<span class="number">2000</span> * time.Millisecond)</span><br><span class="line"><span class="keyword">for</span> t := <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">message := fmt.Sprintf(<span class="string">&quot;Client: Sending &#x27;%d&#x27;&quot;</span>, t.Nanosecond())</span><br><span class="line">_, err = stream.Write([]<span class="type">byte</span>(message))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(message))</span><br><span class="line">_, err = io.ReadFull(stream, buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Client: Got &#x27;%s&#x27;\n&quot;</span>, buf)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-运行"><a href="#4-运行" class="headerlink" title="4 运行"></a>4 运行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; go run quic_server.go</span><br><span class="line">LocalAddr 127.0.0.1:9999, RemoteAddr 127.0.0.1:53893</span><br><span class="line">Server: Got &#x27;Client: Sending &#x27;519247000&#x27;&#x27;</span><br><span class="line">Server: Got &#x27;Client: Sending &#x27;522181000&#x27;&#x27;</span><br><span class="line">Server: Got &#x27;Client: Sending &#x27;519381000&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">&gt; go run quic_client.go</span><br><span class="line">Client: Got &#x27;Client: Sending &#x27;519247000&#x27;&#x27;</span><br><span class="line">Client: Got &#x27;Client: Sending &#x27;522181000&#x27;&#x27;</span><br><span class="line">Client: Got &#x27;Client: Sending &#x27;519381000&#x27;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/32553477">QUIC协议原理分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
          <category> Packges </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Packges </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] String</title>
      <link href="/2021/08/15/Golang/0%20%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/String/"/>
      <url>/2021/08/15/Golang/0%20%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/String/</url>
      
        <content type="html"><![CDATA[<blockquote><p>字符串的实现和注意事项</p></blockquote><span id="more"></span><p>以下分析基于 Go1.14 版本。</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>String 具体实现如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// reflect/value.go 1954行  </span></span><br><span class="line"> <span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;  </span><br><span class="line">   Data <span class="type">uintptr</span>  </span><br><span class="line">   Len  <span class="type">int</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><ul><li>Data：指向 真正存储字符串内容的地址</li><li>Len：字符串的长度（字节）<br>通过起始地址换个字符串长度就可以准确定位整个字符串了。</li></ul><blockquote><p>Go 语言没有用 C 语言中的<code>\0</code>标志表示字符串结束，而是为 String 增加了 Len 字段。</p></blockquote><h2 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2 注意事项"></a>2 注意事项</h2><h3 id="2-1-不可变"><a href="#2-1-不可变" class="headerlink" title="2.1 不可变"></a>2.1 不可变</h3><p><strong>Go 语言中认为字符串是不可变的，所以分配在只读内存段。</strong></p><p>虽然可以通过如下方式读取，但是不可修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">&quot;hello指月&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%c \n&quot;</span>, str[<span class="number">1</span>]) <span class="comment">// e</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要修改可以直接给变量赋新值，这样 string 中的 str 字段就会指向新的地址。</p><p>不过也可以通过强转为 byte slice 的方式进行修改。同样会重新分配一段内存，并拷贝原来的内容。</p><blockquote><p>使用 unsafe 包中的方法可以让 slice 依旧使用原来的这段内存，避免内存拷贝。不过这样转换类型后也无法修改这段只读内存的内容。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">&quot;hello指月&quot;</span></span><br><span class="line">bs:=[]<span class="type">byte</span>(str)</span><br><span class="line">bs[<span class="number">1</span>]=<span class="string">&#x27;z&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%c \n&quot;</span>, bs[<span class="number">1</span>]) <span class="comment">// z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-共享内存"><a href="#2-2-共享内存" class="headerlink" title="2.2 共享内存"></a>2.2 共享内存</h3><p>不同字符串可以共享同一个字符串内容，如果其中一个字符串修改了底层字符串内容，这样的影响是不可预测的。</p><p><img src="StarDust/source/_posts/技术/Golang/0%20基础/数据结构/String/file-20250119031144315.png" alt=""></p><p>比如图中的 s1（hello指月） 和 s2（指月）就共享了底层的字符串内容。</p><p>如果其中一个修改后都会导致，其他字符串类容被修改。</p><blockquote><p>所以字符串才被设定为不可修改，分配在只读内存段上。</p></blockquote><h2 id="3-与-bytes-互转"><a href="#3-与-bytes-互转" class="headerlink" title="3 与 bytes 互转"></a>3 与 bytes 互转</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">String2Bytes</span><span class="params">(str <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">sh := (*reflect.SliceHeader)(unsafe.Pointer(&amp;str))</span><br><span class="line"><span class="comment">// slice 比 string 多一个 cap 属性 这里给 cap 单独赋值</span></span><br><span class="line">sh.Cap = sh.Len</span><br><span class="line"><span class="keyword">return</span> *(*[]<span class="type">byte</span>)(unsafe.Pointer(sh))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bytes2String</span><span class="params">(buf []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="type">string</span>)(unsafe.Pointer(&amp;buf))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 语言标准库中 strings.Builder 就使用到了 unsafe.Pointer 来提升效率。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strings/builder.go 47 行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="type">string</span>)(unsafe.Pointer(&amp;b.buf))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能测试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Benchmark_NormalBytes2String<span class="number">-6</span>          <span class="number">33555104</span>                <span class="number">36.7</span> ns/op            <span class="number">64</span> B/op          <span class="number">1</span> allocs/op</span><br><span class="line">Benchmark_UnsafeByte2String<span class="number">-6</span>           <span class="number">1000000000</span>               <span class="number">0.268</span> ns/op           <span class="number">0</span> B/op          <span class="number">0</span> allocs/op</span><br><span class="line">Benchmark_NormalString2Bytes<span class="number">-6</span>          <span class="number">1000000000</span>               <span class="number">0.271</span> ns/op           <span class="number">0</span> B/op          <span class="number">0</span> allocs/op</span><br><span class="line">Benchmark_UnsafeString2Bytes<span class="number">-6</span>          <span class="number">1000000000</span>               <span class="number">0.268</span> ns/op           <span class="number">0</span> B/op          <span class="number">0</span> allocs/op</span><br></pre></td></tr></table></figure><p>Byte2String 的时候 unsafe 包会有明显的优势，String2Bytes的时候二者基本一致。</p><p>[]byte(string)的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/string.go 155行</span></span><br><span class="line"><span class="comment">// The constant is known to the compiler.</span></span><br><span class="line"><span class="comment">// There is no fundamental theory behind this number.</span></span><br><span class="line"><span class="keyword">const</span> tmpStringBufSize = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tmpBuf [tmpStringBufSize]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringtoslicebyte</span><span class="params">(buf *tmpBuf, s <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b []<span class="type">byte</span></span><br><span class="line">    <span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(s) &lt;= <span class="built_in">len</span>(buf) &#123;</span><br><span class="line">        *buf = tmpBuf&#123;&#125;</span><br><span class="line">        b = buf[:<span class="built_in">len</span>(s)]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b = rawbyteslice(<span class="built_in">len</span>(s))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(b, s)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rawbyteslice allocates a new byte slice. The byte slice is not zeroed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rawbyteslice</span><span class="params">(size <span class="type">int</span>)</span></span> (b []<span class="type">byte</span>) &#123;</span><br><span class="line">    <span class="built_in">cap</span> := roundupsize(<span class="type">uintptr</span>(size))</span><br><span class="line">    p := mallocgc(<span class="built_in">cap</span>, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> != <span class="type">uintptr</span>(size) &#123;</span><br><span class="line">        memclrNoHeapPointers(add(p, <span class="type">uintptr</span>(size)), <span class="built_in">cap</span>-<span class="type">uintptr</span>(size))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(*slice)(unsafe.Pointer(&amp;b)) = slice&#123;p, size, <span class="type">int</span>(<span class="built_in">cap</span>)&#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>长度超过 32 的时候就需要通过 mallocgc() 分配一块新内存，然后使用 copy() 复制数据了。</p><p>string([]byte)的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/string.go 75行</span></span><br><span class="line"><span class="comment">// Buf is a fixed-size buffer for the result,</span></span><br><span class="line"><span class="comment">// it is not nil if the result does not escape.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicebytetostring</span><span class="params">(buf *tmpBuf, b []<span class="type">byte</span>)</span></span> (str <span class="type">string</span>) &#123;</span><br><span class="line">    l := <span class="built_in">len</span>(b)</span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Turns out to be a relatively common case.</span></span><br><span class="line">        <span class="comment">// Consider that you want to parse out data between parens in &quot;foo()bar&quot;,</span></span><br><span class="line">        <span class="comment">// you find the indices and convert the subslice to string.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 如果开启了竞态检测 -race</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        racereadrangepc(unsafe.Pointer(&amp;b[<span class="number">0</span>]),</span><br><span class="line">            <span class="type">uintptr</span>(l),</span><br><span class="line">            getcallerpc(),</span><br><span class="line">            funcPC(slicebytetostring))</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 如果开启了memory sanitizer -msan</span></span><br><span class="line">    <span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">        msanread(unsafe.Pointer(&amp;b[<span class="number">0</span>]), <span class="type">uintptr</span>(l))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">1</span> &#123;</span><br><span class="line">        stringStructOf(&amp;str).str = unsafe.Pointer(&amp;staticbytes[b[<span class="number">0</span>]])</span><br><span class="line">        stringStructOf(&amp;str).<span class="built_in">len</span> = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line">    <span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(b) &lt;= <span class="built_in">len</span>(buf) &#123;</span><br><span class="line">        p = unsafe.Pointer(buf)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = mallocgc(<span class="type">uintptr</span>(<span class="built_in">len</span>(b)), <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stringStructOf(&amp;str).str = p</span><br><span class="line">    stringStructOf(&amp;str).<span class="built_in">len</span> = <span class="built_in">len</span>(b)</span><br><span class="line">  <span class="comment">// 拷贝字节数组至字符串</span></span><br><span class="line">    memmove(p, (*(*slice)(unsafe.Pointer(&amp;b))).array, <span class="type">uintptr</span>(<span class="built_in">len</span>(b)))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例stringStruct对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringStructOf</span><span class="params">(sp *<span class="type">string</span>)</span></span> *stringStruct &#123;</span><br><span class="line">    <span class="keyword">return</span> (*stringStruct)(unsafe.Pointer(sp))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，当数组长度超过32时，同样需要调用 mallocgc() 分配一块新内存。最后通过 memmove() 完成拷贝。</p><p><strong>小结</strong></p><p>Go 语言也是在安全和性能之间选择了安全，不过这点性能损失也非常小。</p><p>当不确定会不会出现安全问题的时候就用标准的转换方式。</p><p>在对性能有极高要求，且没有安全隐患（即确定数据是只读的，后续不会有修改操作），就可以使用 unsafe 包。</p><h2 id="4-字符串拼接"><a href="#4-字符串拼接" class="headerlink" title="4 字符串拼接"></a>4 字符串拼接</h2><p>字符串拼接有多种方式：</p><ul><li>1）直接相加</li><li>2）fmt.Sprintf()</li><li>3）strings.Builder</li><li>4）bytes.Buffer</li></ul><p>测试结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2次</span></span><br><span class="line">BenchmarkSprintf-6               5544774               214 ns/op              32 B/op          3 allocs/op</span><br><span class="line">BenchmarkStringBuilder-6        40105342                30.9 ns/op             8 B/op          1 allocs/op</span><br><span class="line">BenchmarkBytesBuf-6             24064540                51.1 ns/op            64 B/op          1 allocs/op</span><br><span class="line">BenchmarkStringAdd-6            30062755                40.6 ns/op             2 B/op          1 allocs/op</span><br><span class="line"><span class="comment"># 100次</span></span><br><span class="line">BenchmarkSprintf-6                 66108             16317 ns/op           12178 B/op        297 allocs/op</span><br><span class="line">BenchmarkStringBuilder-6         1471501               828 ns/op             504 B/op          6 allocs/op</span><br><span class="line">BenchmarkBytesBuf-6              1000000              1122 ns/op             688 B/op          4 allocs/op</span><br><span class="line">BenchmarkStringAdd-6              240511              5032 ns/op            9776 B/op         99 allocs/op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1000次</span></span><br><span class="line">BenchmarkSprintf-6                  3081            367700 ns/op         1518878 B/op       2998 allocs/op</span><br><span class="line">BenchmarkStringBuilder-6           44805             26449 ns/op           13376 B/op        912 allocs/op</span><br><span class="line">BenchmarkBytesBuf-6                41952             28877 ns/op           15344 B/op        908 allocs/op</span><br><span class="line">BenchmarkStringAdd-6                4620            237020 ns/op         1496941 B/op       1899 allocs/op</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> Sprintf 和直接相加 因为每次都生成一个新字符串，所以有大量的内存分配，而 strings.Builder 和 bytes.Buffer 都有缓存,省去了内存分配的开销，所以效率比较高。</p><p>结论：<strong>字符串少推荐直接相加，多则使用 strings.Builder。</strong></p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p><code>https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-string/</code></p><p><code>https://www.bilibili.com/video/BV1hv411x7we?p=1</code></p><p><code>https://www.mdeditor.tw/pl/pDSl</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Golang WorkerPool</title>
      <link href="/2021/08/11/Golang/4%20%E5%85%B6%E4%BB%96/WorkerPool/"/>
      <url>/2021/08/11/Golang/4%20%E5%85%B6%E4%BB%96/WorkerPool/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Golang实现一个工作池处理并发任务</p></blockquote><span id="more"></span><pre><code class="lang-go">package mainimport (    &quot;log&quot;    &quot;time&quot;)// Worker 工作者type Worker struct &#123;    dataCh chan interface&#123;&#125; // worker channel    stopCh chan struct&#123;&#125;    // stop channel&#125;// NewWorker 新建一个工作者func NewWorker(lenght int) *Worker &#123;    return &amp;Worker&#123;        dataCh: make(chan interface&#123;&#125;, lenght),        stopCh: make(chan struct&#123;&#125;),    &#125;&#125;// Run 运行一个工作任务func (w *Worker) Run() &#123;    for &#123;        select &#123;        case msg := &lt;-w.dataCh:            w.handler(msg)        case &lt;-w.stopCh:            return        &#125;    &#125;&#125;func (w *Worker) stop() &#123;    select &#123;    case &lt;-w.stopCh:        return    default:    &#125;    close(w.stopCh)&#125;func (w *Worker) handler(message interface&#123;&#125;) &#123;    switch msg := message.(type) &#123;    case stopEvent: // 停止工作任务        log.Println(&quot;worker exit&quot;)        w.stop()    default:        //TODO 处理工作任务        log.Printf(&quot;unkown msg %#v&quot;, msg)    &#125;&#125;type stopEvent int// Dispatcher 工作调度器type Dispatcher struct &#123;    maxWorkers   int                   // 最大worker数量    workerLength int                   // worker缓冲长度    queue        chan interface&#123;&#125;      // 任务调度队列    workerPool   chan chan interface&#123;&#125; // worker channel pool    stopCh       chan struct&#123;&#125;         // stop channel&#125;// NewDispatcher 创建一个调度器func NewDispatcher(maxQueue, maxWorkers, workerLength int) *Dispatcher &#123;    pool := make(chan chan interface&#123;&#125;, maxWorkers) // 创建最大数量    return &amp;Dispatcher&#123;        workerPool:   pool,        maxWorkers:   maxWorkers,        workerLength: workerLength,        stopCh:       make(chan struct&#123;&#125;),        queue:        make(chan interface&#123;&#125;, maxQueue),    &#125;&#125;func (d *Dispatcher) spawnWorker() &#123;    worker := NewWorker(d.workerLength)    go worker.Run()    d.workerPool &lt;- worker.dataCh&#125;// Run 运行调度器func (d *Dispatcher) Run() &#123;    for i := 0; i &lt; d.maxWorkers; i++ &#123;        d.spawnWorker()    &#125;    go d.dispatch()&#125;func (d *Dispatcher) stop() &#123;    select &#123;    case &lt;-d.stopCh:        return    default:    &#125;    close(d.stopCh)&#125;// 任务分派器func (d *Dispatcher) dispatch() &#123;    for &#123;        select &#123;        case msg := &lt;-d.queue:            d.handler(msg)        case &lt;-d.stopCh:            return        &#125;    &#125;&#125;func (d *Dispatcher) handler(msg interface&#123;&#125;) &#123;    switch msg.(type) &#123;    case stopEvent: // 停止分派任务        d.stop()        log.Println(&quot;dispatcher closed&quot;)        return    &#125;    for workerCh := range d.workerPool &#123;        if (len(workerCh) + 1) == cap(workerCh) &#123;            workerCh &lt;- stopEvent(1)            continue        &#125;        workerCh &lt;- msg        d.workerPool &lt;- workerCh        break    &#125;    if len(d.workerPool) &lt; d.maxWorkers &#123;        d.spawnWorker()    &#125;&#125;func main() &#123;    defaultDispatch := NewDispatcher(4, 5, 100)    defaultDispatch.Run()    for i := 0; i &lt; 100; i++ &#123;        select &#123;        case &lt;-defaultDispatch.stopCh:            return        default:        &#125;        defaultDispatch.queue &lt;- i    &#125;    time.Sleep(5 * time.Second)    //defaultDispatch.queue &lt;- stopEvent(1)&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Golang ldflags</title>
      <link href="/2021/08/09/Golang/4%20%E5%85%B6%E4%BB%96/ldflags/"/>
      <url>/2021/08/09/Golang/4%20%E5%85%B6%E4%BB%96/ldflags/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Golang 在编译时使用ldflags动态设置包中变量的值</p></blockquote><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-X importpath.name=value Set the value of the string variable in importpath named name to value. Note that before Go 1.5 this option took two separate arguments. Now it takes one argument split on the first = sign.</span><br></pre></td></tr></table></figure><p>ldflags用于链接过程，详细见文章<a href="https://tonybai.com/2017/06/27/an-intro-about-go-portability/">也谈Go的可移植性</a><br><a href="http://blog.champbay.com/2019/11/25/%e9%9d%99%e6%80%81%e9%93%be%e6%8e%a5%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e9%9d%99%e6%80%81%e5%ba%93%e5%85%b1%e4%ba%ab%e5%ba%93%e8%bf%99%e4%ba%9b%e6%a6%82%e5%bf%b5%e7%9a%84%e8%af%a6%e8%a7%a3/">静态链接,动态链接,静态库,共享库这些概念的详解</a></p><h2 id="1-参数作用"><a href="#1-参数作用" class="headerlink" title="1 参数作用"></a>1 参数作用</h2><p><code>golang在编译、测试、安装时使用-ldflags -X动态设置包中变量的值 go install/build/test 时可以通过命令行参数设置package中的变量， 其格式为-X importpath.name=val, 其中importpath是变量所在包的的路径， name是包中定义的变量， val 是需要在编译时设置的变量的值(string)， name表示的变量只能是variable，不能是constant, 且不能通过函数调用的方式初始化， 其类型只能是string，不可是int, bool等. 如果val中存在空格,需要用引号括起来,如下date和go version输出结果有空格： go build -ldflags &quot;-X &#39;main.BUILD_TIME=`date`&#39; -X &#39;main.GO_VERSION=`go version`&#39;&quot;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">docker version</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Client: Docker Engine - Community</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Version: 19.03.3</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">API version: 1.40</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Go version: go1.12.10</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Git commit: a872fc2</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Built: Tue Oct 8 00:55:12 2019</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">OS/Arch: darwin/amd64</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Experimental: <span class="literal">false</span></span></span><br></pre></td></tr></table></figure><h2 id="2-编译时使用"><a href="#2-编译时使用" class="headerlink" title="2 编译时使用"></a>2 编译时使用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">version    <span class="type">string</span></span><br><span class="line">build_time <span class="type">string</span></span><br><span class="line">go_version <span class="type">string</span></span><br><span class="line">git_commit <span class="type">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;version:&quot;</span>, version)</span><br><span class="line">fmt.Println(<span class="string">&quot;go version:&quot;</span>, go_version)</span><br><span class="line">fmt.Println(<span class="string">&quot;build time:&quot;</span>, build_time)</span><br><span class="line">fmt.Println(<span class="string">&quot;git log:&quot;</span>, git_commit)</span><br><span class="line">&#125;<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">执行输出：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>shell</span><br><span class="line">&gt; <span class="keyword">go</span> build -ldflags <span class="string">&quot;-X &#x27;main.build_time=$(date)&#x27; -X &#x27;main.git_commit=$(git log --pretty=format:&quot;</span>%h<span class="string">&quot; -1)&#x27; -X main.version=1.0.0 -X &#x27;main.go_version=`go version`&#x27;&quot;</span> main.<span class="keyword">go</span></span><br><span class="line">&gt; ./main</span><br><span class="line">version: <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line"><span class="keyword">go</span> version: <span class="keyword">go</span> version go1<span class="number">.14</span> darwin/amd64</span><br><span class="line">build time: <span class="number">2021</span>年 <span class="number">8</span>月 <span class="number">9</span>日 星期日 <span class="number">19</span>时<span class="number">09</span>分<span class="number">50</span>秒 CST</span><br><span class="line">git log: <span class="number">175</span>a5eb<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 测试时使用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">创建包和文件</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>shell</span><br><span class="line">&gt; mkdir $GOPATH/src/gotest </span><br><span class="line">&gt; touch $GOPATH/src/gotest/go_test.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><pre><code class="lang-go">package gotestimport &quot;testing&quot;var time stringvar version stringfunc TestBuild(t *testing.T) &#123;  t.Log(time)  t.Log(version)&#125;</code></pre><p>执行输出：</p><pre><code class="lang-shell">&gt; cd $GOPATH/src/&gt; GO111MODULE=off go test -ldflags=&quot;-X &#39;gotest.time=`date`&#39; -X gotest.version=1.0.1&quot; gotest -v=== RUN   TestBuild    TestBuild: go_test.go:9: 2021年 8月 9日 星期日 18时57分49秒 CST    TestBuild: go_test.go:10: 1.0.1--- PASS: TestBuild (0.00s)PASSok      gotest  0.009s</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/ahmczsy/p/11512151.html">ldflags使用技巧</a></li><li><a href="https://tonybai.com/2017/06/27/an-intro-about-go-portability/">也谈Go的可移植性</a></li><li><a href="http://blog.champbay.com/2019/11/25/%e9%9d%99%e6%80%81%e9%93%be%e6%8e%a5%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e9%9d%99%e6%80%81%e5%ba%93%e5%85%b1%e4%ba%ab%e5%ba%93%e8%bf%99%e4%ba%9b%e6%a6%82%e5%bf%b5%e7%9a%84%e8%af%a6%e8%a7%a3/">静态链接,动态链接,静态库,共享库这些概念的详解</a></li><li><a href="https://book.douban.com/subject/4141733/">Linux C编程一站式学习</a></li><li><a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/">Linux C编程一站式学习 ebook</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
          <category> Packages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go-Package </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Golang 内存对齐</title>
      <link href="/2021/07/22/Golang/4%20%E5%85%B6%E4%BB%96/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
      <url>/2021/07/22/Golang/4%20%E5%85%B6%E4%BB%96/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内存对齐主要就是为了迎合内存设计, 可以提升内存访问效率</p></blockquote><span id="more"></span><h2 id="1-内存概述"><a href="#1-内存概述" class="headerlink" title="1 内存概述"></a>1 内存概述</h2><h3 id="1-1-内存设计"><a href="#1-1-内存设计" class="headerlink" title="1.1 内存设计"></a>1.1 内存设计</h3><p>内存条上的 8 个黑色小方块称之为 <strong>chip</strong>，整个合起来叫做 <strong>rank</strong>。</p><p>chip 中又分为多个 <strong>bank</strong>，bank 这里就可以通过行列方式来进行访问了。</p><h3 id="1-2-内存访问"><a href="#1-2-内存访问" class="headerlink" title="1.2 内存访问"></a>1.2 内存访问</h3><p>内存访问一般采取<strong>并行</strong>方式，比如 8 Byte 的数据并不会都存在第一个 chip,而是分散到各个 chip 中存储。比如 chip1 存储 Byte1，chip2 存储 Byte2,依次类推。读取的时候分别从 8 个 chip 中读取出 1Byte，拼接起来就是完整的 8 Byte。</p><blockquote><p>可以简单的理解为这样使得内存访问效率提升了 8 倍。</p></blockquote><p><strong>可以看到内存的真实存放情况并不是我们想象的那样是逻辑连续的。</strong></p><h2 id="2-内存字节对齐"><a href="#2-内存字节对齐" class="headerlink" title="2 内存字节对齐"></a>2 内存字节对齐</h2><p>这里说的内存对齐指的是存入内存之前的数据。即分散之前的，或者说是读取出来拼接好后的那一部分数据需要对齐。</p><p>否则就不能迅速的从各个 chip 将对应的数据读取出来，需要分多次读取，这样效率势必会降低不少。</p><h3 id="2-1-例子"><a href="#2-1-例子" class="headerlink" title="2.1 例子"></a>2.1 例子</h3><p>假设有一个 8Byte 的数据，进行内存对齐后地址分别为 0~7。</p><p>然后分别存到 8 个 chip 中，假设是存在 （1,1）这个位置的。</p><p>读取时只需要分别读取8个chip 的（1,1）位置数据然后组合起来就是完成的数据了。</p><p>如果没有内存对齐，比如分配的地址是(1~8)。</p><p>这样分别存到 8 个chip之后就不会是相同的地址了。</p><p>现在 0 这个位置虽然没有数据，但是chip 中还是要给它流出位置来，万一后面会写入数据呢。</p><p>所以现在8个chip的（1，1）这个位置中，chip1的（1,1）是空的，后续7个chip分别存储了（1~7）的数据，剩下的位置8这个数据，会存在下一个坐标，比如(1,2),然后后续的9~15又是空的。chip1的（1,2）存放了数据8，但是其他chip的(1,2)位置暂时还是空的。</p><p>所以最后要读取（1~8）的所有数据就需要分别读取出8个chip上的位置（1,1）和（1，2）然后剔除掉不要的数据最后拼接起来才是完整的数据。</p><blockquote><p>之所以有的 CPU 可能实现随机内存访问，就是因为实现了这个数据过滤拼接的功能，但是这样在内存读取效率会大打折扣。</p></blockquote><h2 id="3-Go-语言内存对齐"><a href="#3-Go-语言内存对齐" class="headerlink" title="3 Go 语言内存对齐"></a>3 Go 语言内存对齐</h2><p>具体对齐方式和平台有关。</p><p><strong>32 位平台指针宽度和寄存器宽度都是4字节，64位平台则都是8字节。</strong></p><p>在Go语言中<strong>寄存器宽度</strong>也称之为<strong>机器字长</strong>或者<strong>最大对齐边界</strong>。</p><h3 id="3-1-对齐规则"><a href="#3-1-对齐规则" class="headerlink" title="3.1 对齐规则"></a>3.1 对齐规则</h3><p>在分析之前，我们先看下内存对齐的规则：</p><h4 id="3-1-1-规则一"><a href="#3-1-1-规则一" class="headerlink" title="3.1.1 规则一"></a>3.1.1 <strong>规则一</strong></h4><p>对于具体类型来说，<strong>对齐值=min(平台最大对齐边界，类型大小Sizeof长度)</strong>。<strong>也就是在平台最大对齐边界和类型的内存占用大小之间，取最小值为该类型的对齐值</strong>。我的电脑默认是8，所以最大值不会超过8.</p><p>为什么不统一按照平台最大对齐边界或者类型大小来对齐？</p><p>主要是为了节约内存。直接按平台最大对齐边界对齐的话，如果数据类型长度小于最大对齐边界的时候就会造成内存浪费，比如 int8占1byte也按照8byte对齐就会浪费7byte空间，按照类型大小长度对齐也有同样的问题，所以才取二者中的最小值。</p><h4 id="3-1-2-规则二"><a href="#3-1-2-规则二" class="headerlink" title="3.1.2 规则二"></a>3.1.2 <strong>规则二</strong></h4><p>struct 在每个字段都内存对齐之后，其本身也要进行对齐，<strong>对齐值为各个成员对齐值中的最大值</strong>。</p><p>结构体对齐是为了保证<strong>结构体数组</strong>中的各个元素能正常访问，由于数组内存是连续的，如果结构体不对齐势必会导致，数组的第二个及其后面的元素无法正常访问。</p><p>在这里再次提醒，对齐值也叫对齐系数、对齐倍数，对齐模数。这就是说，<strong>每个字段在内存中的偏移量是对齐值的倍数即可</strong>。</p><h3 id="3-2-类型长度"><a href="#3-2-类型长度" class="headerlink" title="3.2 类型长度"></a>3.2 类型长度</h3><p>windows 64位系统 编译器默认对齐值=8</p><div class="table-container"><table><thead><tr><th>类型</th><th>大小</th><th>对齐系数</th><th>备注</th></tr></thead><tbody><tr><td>bool</td><td>1</td><td>1</td><td></td></tr><tr><td>byte</td><td>1</td><td>1</td><td></td></tr><tr><td>int8</td><td>1</td><td>1</td><td></td></tr><tr><td>int16</td><td>2</td><td>2</td><td></td></tr><tr><td>int32</td><td>4</td><td>4</td><td></td></tr><tr><td>int64</td><td>8</td><td>8</td><td></td></tr><tr><td>float32</td><td>4</td><td>4</td><td></td></tr><tr><td>float64</td><td>8</td><td>8</td><td></td></tr><tr><td>map</td><td>8</td><td>8</td><td></td></tr><tr><td>string</td><td>16</td><td>8</td><td>对齐系数不会超过编译器默认对齐值</td></tr><tr><td>array ([1]string{“xxx”})</td><td>16</td><td>8</td><td></td></tr><tr><td>slice ([]string{“xxx”})</td><td>24</td><td>8</td></tr></tbody></table></div><h3 id="3-3-例子"><a href="#3-3-例子" class="headerlink" title="3.3 例子"></a>3.3 例子</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Part1 <span class="keyword">struct</span> &#123;</span><br><span class="line">A <span class="type">bool</span>              <span class="comment">// 长度1 偏移0 填充0 总大小1</span></span><br><span class="line">B <span class="type">byte</span>              <span class="comment">// 长度1 偏移1 填充0 总大小2</span></span><br><span class="line">C <span class="type">int8</span>              <span class="comment">// 长度1 偏移2 填充0 总大小3</span></span><br><span class="line">D <span class="type">int16</span>             <span class="comment">// 长度2 偏移3 填充1 总大小6</span></span><br><span class="line">E <span class="type">int32</span>             <span class="comment">// 长度4 偏移5 填充2 总大小12</span></span><br><span class="line">F <span class="type">int64</span>             <span class="comment">// 长度8 偏移11 填充4 总大小22</span></span><br><span class="line">G <span class="type">float32</span>           <span class="comment">// 长度4 偏移21 填充2 总大小28</span></span><br><span class="line">H <span class="type">float64</span>           <span class="comment">// 长度8 偏移27 填充4 总大小40</span></span><br><span class="line">I <span class="type">string</span>            <span class="comment">// 长度16 偏移39 填充0 总大小56</span></span><br><span class="line">J <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> <span class="comment">// 长度8 偏移55 填充0 总大小64</span></span><br><span class="line">K []<span class="type">string</span>          <span class="comment">// 长度24 偏移63 填充0 总大小88</span></span><br><span class="line">L [<span class="number">1</span>]<span class="type">string</span>         <span class="comment">// 长度16 偏移87 填充0 总大小104</span></span><br><span class="line"><span class="comment">//104 刚好是8的倍数 不需要填充</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h2><p>内存对齐主要就是为了迎合内存设计。</p><p>而内存之所以这么设计是为了提升内存访问效率。</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p><code>https://go101.org/article/memory-layout.html</code></p><p><code>https://www.bilibili.com/video/BV1hv411x7we</code></p><p><code>https://xie.infoq.cn/article/594a7f54c639accb53796cfc7</code></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
          <category> Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Golang-Basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Algorithm] Array</title>
      <link href="/2021/06/12/Algorithm/Array/"/>
      <url>/2021/06/12/Algorithm/Array/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="0-1-声明和定义"><a href="#0-1-声明和定义" class="headerlink" title="0.1 声明和定义"></a>0.1 声明和定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] array = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">double</span>[] myList; </span><br><span class="line"><span class="type">double</span>[] myList = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">10</span>];</span><br><span class="line"><span class="comment">// 作为参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">    System.out.print(array[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多维数组 前行后列</span></span><br><span class="line"><span class="type">int</span>[][] a = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure><h3 id="0-2-11-盛最多水的容器"><a href="#0-2-11-盛最多水的容器" class="headerlink" title="0.2 11. 盛最多水的容器"></a>0.2 <a href="https://leetcode-cn.com/problems/container-with-most-water/">11. 盛最多水的容器</a></h3><p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针，每次移动较短的那个边</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = height.length - <span class="number">1</span>; i &lt; j; )&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> height[i] &lt; height[j] ? height[i++] : height[j--];</span><br><span class="line">            ans = Math.max(ans, (j-i+<span class="number">1</span>) * min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-3-15-三数之和"><a href="#0-3-15-三数之和" class="headerlink" title="0.3 15. 三数之和"></a>0.3 <a href="https://leetcode-cn.com/problems/3sum/">15. 三数之和</a></h3><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</p><p>注意：答案中不可以包含重复的三元组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(nums == <span class="literal">null</span> || len &lt; <span class="number">3</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len ; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">// 如果当前数字大于0，则三数之和一定大于0，所以结束循环</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 去重</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> i+<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">R</span> <span class="operator">=</span> len-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(L &lt; R)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[i] + nums[L] + nums[R];</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">0</span>)&#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[i],nums[L],nums[R]));</span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[L] == nums[L+<span class="number">1</span>]) L++; <span class="comment">// 去重</span></span><br><span class="line">                    <span class="keyword">while</span> (L&lt;R &amp;&amp; nums[R] == nums[R-<span class="number">1</span>]) R--; <span class="comment">// 去重</span></span><br><span class="line">                    L++;</span><br><span class="line">                    R--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) L++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) R--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-4-33-搜索旋转排序数组"><a href="#0-4-33-搜索旋转排序数组" class="headerlink" title="0.4 33. 搜索旋转排序数组"></a>0.4 <a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h3><p>整数数组 nums 按升序排列，数组中的值 互不相同 。</p><p>在传递给函数之前，nums 在预先未知的某个下标 k（0 &lt;= k &lt; nums.length）上进行了 旋转，使数组变为 [nums[k], nums[k+1], …, nums[n-1], nums[0], nums[1], …, nums[k-1]]（下标 从 0 开始 计数）。例如， [0,1,2,4,5,6,7] 在下标 3 处经旋转后可能变为 [4,5,6,7,0,1,2] 。</p><p>给你 旋转后 的数组 nums 和一个整数 target ，如果 nums 中存在这个目标值 target ，则返回它的索引，否则返回 -1 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">//第一步，找出哪个半区是有序的，然后判断是不是在这个半区里面，缩小范围</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; nums[right])&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])&#123;</span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                    right = mid - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-5-38-外观数列"><a href="#0-5-38-外观数列" class="headerlink" title="0.5 38. 外观数列"></a>0.5 <a href="https://leetcode-cn.com/problems/count-and-say/">38. 外观数列</a></h3><p>要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">countAndSay</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个外观数列</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;1&quot;</span>;</span><br><span class="line">        <span class="comment">//迭代出第n个外观数列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            <span class="comment">//计数，有几个这样的</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//第一个字符，计数的开始</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">code</span> <span class="operator">=</span> str.charAt(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//遍历整个字符串</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; str.length(); j++) &#123;</span><br><span class="line">                <span class="comment">//如果碰到不一样的，将之前的字符数量和字符加入</span></span><br><span class="line">                <span class="keyword">if</span> (str.charAt(j) != code) &#123;</span><br><span class="line">                    sb.append(count);</span><br><span class="line">                    sb.append(code);</span><br><span class="line">                    <span class="comment">//重新计算下一个字符</span></span><br><span class="line">                    code = str.charAt(j);</span><br><span class="line">                    count = <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(count);</span><br><span class="line">            sb.append(str.charAt(str.length() - <span class="number">1</span>));</span><br><span class="line">            str = sb.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-6-42-接雨水"><a href="#0-6-42-接雨水" class="headerlink" title="0.6 42. 接雨水"></a>0.6 <a href="https://leetcode-cn.com/problems/trapping-rain-water/">42. 接雨水</a></h3><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="comment">// 双指针维护最小值,这个表示的是当前扫描到的可能存雨水的底的高度</span></span><br><span class="line">            min = height[height[l] &lt; height[r] ? l++ : r--];</span><br><span class="line">            <span class="comment">// max等于水位线</span></span><br><span class="line">            max = Math.max(max, min);</span><br><span class="line">            <span class="comment">// 累加差值</span></span><br><span class="line">            res += max - min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-7-寻找数组的中心索引"><a href="#0-7-寻找数组的中心索引" class="headerlink" title="0.7 寻找数组的中心索引"></a>0.7 寻找数组的中心索引</h3><p>题目：给定一个整数类型的数组 nums，请编写一个能够返回数组 “中心索引” 的方法。</p><p>我们是这样定义数组 中心索引 的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。</p><p>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。</p><p>输入：<br>nums = [1, 7, 3, 6, 5, 6]<br>输出：3<br>解释：<br>索引 3 (nums[3] = 6) 的左侧数之和 (1 + 7 + 3 = 11)，与右侧数之和 (5 + 6 = 11) 相等。<br>同时, 3 也是第一个符合要求的中心索引。</p><p>思路：前缀和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>,leftsum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">    sum += nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; nums.length;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(leftsum*<span class="number">2</span> == sum - nums[i])&#123;</span><br><span class="line">        <span class="keyword">return</span> i;&#125;</span><br><span class="line">    leftsum += nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h3 id="0-8-搜索插入位置"><a href="#0-8-搜索插入位置" class="headerlink" title="0.8 搜索插入位置"></a>0.8 搜索插入位置</h3><p>题目：给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p>思路：二分查找相等直接返回，大于mid则left=mid+1；否则right=mid-1；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-9-合并区间"><a href="#0-9-合并区间" class="headerlink" title="0.9 合并区间"></a>0.9 合并区间</h3><p>题目：给出一个区间的集合，请合并所有重叠的区间。</p><p>输入: [[1,3],[2,6],[8,10],[15,18]]<br>输出: [[1,6],[8,10],[15,18]]<br>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</p><p>思路：按照左端点升序排序，然后遍历。</p><p>如果当前遍历到的区间的左端点 &gt; 结果集中最后一个区间的右端点，说明它们没有交集，此时把区间添加到结果集；<br>如果当前遍历到的区间的左端点 &lt;= 结果集中最后一个区间的右端点，说明它们有交集，此时产生合并操作，即：对结果集中最后一个区间的右端点更新（取两个区间的最大值）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> intervals.length;</span><br><span class="line"><span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> intervals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照起点排序</span></span><br><span class="line">Arrays.sort(intervals,Comparator.comparing  <span class="title function_">Int</span><span class="params">(o -&gt; o[<span class="number">0</span>])</span>);</span><br><span class="line">List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">res.add(intervals[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="type">int</span>[] curInterval = intervals[i];</span><br><span class="line">    <span class="comment">// 每次新遍历到的列表与当前结果集中的最后一个区间的末尾端点进行比较</span></span><br><span class="line">    <span class="type">int</span>[] peek = res.get(res.size() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (curInterval[<span class="number">0</span>] &gt; peek[<span class="number">1</span>]) &#123;</span><br><span class="line">        res.add(curInterval);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        peek[<span class="number">1</span>] = Math.max(curInterval[<span class="number">1</span>], peek[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][]);</span><br></pre></td></tr></table></figure><h2 id="1-最大子序和-1385"><a href="#1-最大子序和-1385" class="headerlink" title="1 最大子序和(1385)"></a>1 最大子序和(1385)</h2><p><a href="https://leetcode-cn.com/problems/maximum-subarray/">https://leetcode-cn.com/problems/maximum-subarray/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preSum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> preSum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 注意条件</span></span><br><span class="line">            preSum = preSum &gt; <span class="number">0</span> ? preSum + nums[i] : nums[i];</span><br><span class="line">            maxSum = Math.max(maxSum, preSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-打家劫舍-II-375"><a href="#2-打家劫舍-II-375" class="headerlink" title="2 打家劫舍 II(375)"></a>2 打家劫舍 II(375)</h2><p><a href="https://leetcode-cn.com/problems/house-robber-ii/">https://leetcode-cn.com/problems/house-robber-ii/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span><br><span class="line"></span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</span><br><span class="line"></span><br><span class="line">输入: [2,3,2]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> Math.max(rob(nums, <span class="number">0</span>, n - <span class="number">2</span>), rob(nums, <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> first, <span class="type">int</span> last)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre2</span> <span class="operator">=</span> <span class="number">0</span>, pre1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> first; i &lt;= last; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> Math.max(pre1, pre2 + nums[i]);</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-搜索插入位置-1239"><a href="#3-搜索插入位置-1239" class="headerlink" title="3 搜索插入位置(1239)"></a>3 搜索插入位置(1239)</h2><p><a href="https://leetcode-cn.com/problems/search-insert-position/">https://leetcode-cn.com/problems/search-insert-position/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</span><br><span class="line"></span><br><span class="line">你可以假设数组中无重复元素。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><p>二分法<br>但要考虑边界</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">searchInsert</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= h) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (h - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target) </span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) </span><br><span class="line">                h = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意边界</span></span><br><span class="line">        <span class="keyword">if</span> (h &lt; <span class="number">0</span> &amp;&amp; l == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> (l + h) % <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> (l + h) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-接雨水-1145"><a href="#4-接雨水-1145" class="headerlink" title="4 接雨水(1145)"></a>4 接雨水(1145)</h2><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/">https://leetcode-cn.com/problems/trapping-rain-water/</a></p><p>双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="comment">// 双指针维护最小值</span></span><br><span class="line">            min = height[height[l] &lt; height[r] ? l++ : r--];</span><br><span class="line">            <span class="comment">// 接着维护最大值</span></span><br><span class="line">            max = Math.max(max, min);</span><br><span class="line">            <span class="comment">// 累加差值</span></span><br><span class="line">            res += max - min;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-跳跃游戏-1059"><a href="#5-跳跃游戏-1059" class="headerlink" title="5 跳跃游戏(1059)"></a>5 跳跃游戏(1059)</h2><p><a href="https://leetcode-cn.com/problems/jump-game/">https://leetcode-cn.com/problems/jump-game/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个非负整数数组，你最初位于数组的第一个位置。</span><br><span class="line"></span><br><span class="line">数组中的每个元素代表你在该位置可以跳跃的最大长度。</span><br><span class="line"></span><br><span class="line">判断你是否能够到达最后一个位置。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,1,1,4]</span><br><span class="line">输出: true</span><br><span class="line">解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</span><br><span class="line"></span><br><span class="line">输入: [3,2,1,0,4]</span><br><span class="line">输出: false</span><br><span class="line">解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置。</span><br></pre></td></tr></table></figure><p>贪心</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 注意条件</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt;= max) &#123;</span><br><span class="line">                <span class="comment">// 最远索引</span></span><br><span class="line">                max = Math.max(max, nums[i] + i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意判断</span></span><br><span class="line">        <span class="keyword">return</span> max &gt;= n - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-加一-1254"><a href="#6-加一-1254" class="headerlink" title="6 加一(1254)"></a>6 加一(1254)</h2><p><a href="https://leetcode-cn.com/problems/plus-one/">https://leetcode-cn.com/problems/plus-one/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。</span><br><span class="line"></span><br><span class="line">最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</span><br><span class="line"></span><br><span class="line">你可以假设除了整数 0 之外，这个整数不会以零开头。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br><span class="line"></span><br><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure><p>正常操作<br>加法中常用<br>a = x % 10<br>b = x / 10</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] plusOne(<span class="type">int</span>[] digits) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> digits.length;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[length + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> length - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sums</span> <span class="operator">=</span> digits[i] + carry;</span><br><span class="line">            res[i] = sums % <span class="number">10</span>;</span><br><span class="line">            carry = sums / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOfRange(res,<span class="number">0</span>,length);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-合并两个有序数组-1057"><a href="#7-合并两个有序数组-1057" class="headerlink" title="7 合并两个有序数组(1057)"></a>7 合并两个有序数组(1057)</h2><p><a href="https://leetcode-cn.com/problems/merge-sorted-array/">https://leetcode-cn.com/problems/merge-sorted-array/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。</span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。</span><br><span class="line">你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [1,2,3,0,0,0], m = 3</span><br><span class="line">nums2 = [2,5,6],       n = 3</span><br><span class="line"></span><br><span class="line">输出: [1,2,2,3,5,6]</span><br></pre></td></tr></table></figure><p>三指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] nums1, <span class="type">int</span> m, <span class="type">int</span>[] nums2, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">index1</span> <span class="operator">=</span> m - <span class="number">1</span>, index2 = n - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">indexMerge</span> <span class="operator">=</span> m + n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (index1 &gt;= <span class="number">0</span> || index2 &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index1 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[indexMerge--] = nums2[index2--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index2 &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[indexMerge--] = nums1[index1--];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[index1] &gt; nums2[index2]) &#123;</span><br><span class="line">            nums1[indexMerge--] = nums1[index1--];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nums1[indexMerge--] = nums2[index2--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8-买卖股票的最佳时机-1491"><a href="#8-买卖股票的最佳时机-1491" class="headerlink" title="8 买卖股票的最佳时机(1491)"></a>8 买卖股票的最佳时机(1491)</h2><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</span><br><span class="line"></span><br><span class="line">如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。</span><br><span class="line"></span><br><span class="line">注意：你不能在买入股票前卖出股票。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票</span><br><span class="line"></span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">// 边界</span></span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">// min</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// max</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 一直找最小的股</span></span><br><span class="line">            min = prices[i] &lt; min ? prices[i] : min;</span><br><span class="line">            <span class="comment">// 遍历一圈，存最大的利润</span></span><br><span class="line">            max = Math.max(max, prices[i] - min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="9-多数元素-1096"><a href="#9-多数元素-1096" class="headerlink" title="9 多数元素(1096)"></a>9 多数元素(1096)</h2><h2 id="10-多数元素-1096"><a href="#10-多数元素-1096" class="headerlink" title="10 多数元素(1096)"></a>10 多数元素(1096)</h2><p><a href="https://leetcode-cn.com/problems/majority-element/">https://leetcode-cn.com/problems/majority-element/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于 ⌊ n/2 ⌋ 的元素。</span><br><span class="line"></span><br><span class="line">你可以假设数组是非空的，并且给定的数组总是存在多数元素。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-打家劫舍-1035"><a href="#11-打家劫舍-1035" class="headerlink" title="11 打家劫舍(1035)"></a>11 打家劫舍(1035)</h2><p><a href="https://leetcode-cn.com/problems/house-robber/">https://leetcode-cn.com/problems/house-robber/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span><br><span class="line"></span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br><span class="line"></span><br><span class="line">输入：[2,7,9,3,1]</span><br><span class="line">输出：12</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12 。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre2</span> <span class="operator">=</span> <span class="number">0</span>, pre1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> Math.max(pre2 + nums[i], pre1);</span><br><span class="line">            pre2 = pre1;</span><br><span class="line">            pre1 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-移动零-1008"><a href="#12-移动零-1008" class="headerlink" title="12 移动零(1008)"></a>12 移动零(1008)</h2><p><a href="https://leetcode-cn.com/problems/move-zeroes/">https://leetcode-cn.com/problems/move-zeroes/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0,3,12]</span><br><span class="line">输出: [1,3,12,0,0]</span><br></pre></td></tr></table></figure><ol><li>先把不是0的移动左</li><li>最后陆续加0</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num != <span class="number">0</span>) </span><br><span class="line">                nums[idx++] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (idx &lt; nums.length) &#123;</span><br><span class="line">            nums[idx++] =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-合并区间-950"><a href="#13-合并区间-950" class="headerlink" title="13 合并区间(950)"></a>13 合并区间(950)</h2><p><a href="https://leetcode-cn.com/problems/merge-intervals/">https://leetcode-cn.com/problems/merge-intervals/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给出一个区间的集合，请合并所有重叠的区间。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出: [[1,6],[8,10],[15,18]]</span><br><span class="line">解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br><span class="line"></span><br><span class="line">输入: [[1,4],[4,5]]</span><br><span class="line">输出: [[1,5]]</span><br><span class="line">解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] merge(<span class="type">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals == <span class="literal">null</span> || intervals.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> intervals;</span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> intervals.length;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> intervals[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n - <span class="number">1</span> &amp;&amp; r &gt;= intervals[i + <span class="number">1</span>][<span class="number">0</span>]) &#123;</span><br><span class="line">                r = Math.max(r, intervals[i + <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123;l, r&#125;);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[list.size()][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="14-在排序数组中查找元素的第一个和最后一个位置-935"><a href="#14-在排序数组中查找元素的第一个和最后一个位置-935" class="headerlink" title="14 在排序数组中查找元素的第一个和最后一个位置(935)"></a>14 在排序数组中查找元素的第一个和最后一个位置(935)</h2><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</span><br><span class="line"></span><br><span class="line">你的算法时间复杂度必须是 O(log n) 级别。</span><br><span class="line"></span><br><span class="line">如果数组中不存在目标值，返回 [-1, -1]。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [5,7,7,8,8,10], target = 8</span><br><span class="line">输出: [3,4]</span><br><span class="line"></span><br><span class="line">输入: nums = [5,7,7,8,8,10], target = 6</span><br><span class="line">输出: [-1,-1]</span><br></pre></td></tr></table></figure><p>双指针+二分法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> findFirst(nums, target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">last</span> <span class="operator">=</span> findFirst(nums, target + <span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (first == nums.length || nums[first] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;first, Math.max(first, last)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findFirst</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, h = nums.length; <span class="comment">// h 的初始值和往常不一样</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + ( h - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &gt;= target) h = m;</span><br><span class="line">            <span class="keyword">else</span> l = m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="15-全排列-985"><a href="#15-全排列-985" class="headerlink" title="15 全排列(985)"></a>15 全排列(985)</h2><p><a href="https://leetcode-cn.com/problems/permutations/">https://leetcode-cn.com/problems/permutations/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个 没有重复 数字的序列，返回其所有可能的全排列。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3,2],</span><br><span class="line">  [2,1,3],</span><br><span class="line">  [2,3,1],</span><br><span class="line">  [3,1,2],</span><br><span class="line">  [3,2,1]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>dfs</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; permutes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; permuteList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        backtracking(permuteList, permutes, hasVisited, nums);</span><br><span class="line">        <span class="keyword">return</span> permutes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(List&lt;Integer&gt; permuteList, List&lt;List&lt;Integer&gt;&gt; permutes, <span class="type">boolean</span>[] visited, <span class="keyword">final</span> <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (permuteList.size() == nums.length) &#123;</span><br><span class="line">            permutes.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(permuteList)); <span class="comment">// 重新构造一个List</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; visited.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i]) <span class="keyword">continue</span>;</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            permuteList.add(nums[i]);</span><br><span class="line">            backtracking(permuteList, permutes, visited, nums);</span><br><span class="line">            permuteList.remove(permuteList.size() - <span class="number">1</span>);</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-只出现一次的数字-890"><a href="#16-只出现一次的数字-890" class="headerlink" title="16 只出现一次的数字(890)"></a>16 只出现一次的数字(890)</h2><p><a href="https://leetcode-cn.com/problems/single-number/">https://leetcode-cn.com/problems/single-number/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>异或是一种基于二进制的位运算，用符号XOR或者^表示，其运算法则是对运算符两侧数的每一个二进制位同值则取0，异值则取1<br>简单理解就是不进位加法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) </span><br><span class="line">            ret = ret ^ num;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="17-岛屿数量-853"><a href="#17-岛屿数量-853" class="headerlink" title="17 岛屿数量(853)"></a>17 岛屿数量(853)</h2><p><a href="https://leetcode-cn.com/problems/number-of-islands/">https://leetcode-cn.com/problems/number-of-islands/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给你一个由 &#x27;1&#x27;（陆地）和 &#x27;0&#x27;（水）组成的的二维网格，请你计算网格中岛屿的数量。</span><br><span class="line"></span><br><span class="line">岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。</span><br><span class="line"></span><br><span class="line">此外，你可以假设该网格的四条边均被水包围。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">[&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;],</span><br><span class="line">[&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;0&#x27;],</span><br><span class="line">[&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">[&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;]</span><br><span class="line">]</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">[&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">[&#x27;1&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">[&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;0&#x27;,&#x27;0&#x27;],</span><br><span class="line">[&#x27;0&#x27;,&#x27;0&#x27;,&#x27;0&#x27;,&#x27;1&#x27;,&#x27;1&#x27;]</span><br><span class="line">]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>dfs</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m, n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] direaction = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">islandsNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] != <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">                    dfs(grid, i, j);</span><br><span class="line">                    islandsNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> islandsNum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= m || j &lt; <span class="number">0</span> || j &gt;=n || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] d : direaction) &#123;</span><br><span class="line">            dfs(grid, i + d[<span class="number">0</span>], j + d[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-数组中的第K个最大元素-855"><a href="#18-数组中的第K个最大元素-855" class="headerlink" title="18 数组中的第K个最大元素(855)"></a>18 数组中的第K个最大元素(855)</h2><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>快排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        k = nums.length - k;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> partition(nums, l , h);</span><br><span class="line">            <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j &lt; k) &#123;</span><br><span class="line">                l = j + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                h = j - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> l;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> pivot + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= r; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">                swap(arr, i, index++);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = t; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="19-缺失的第一个正数-751"><a href="#19-缺失的第一个正数-751" class="headerlink" title="19 缺失的第一个正数(751)"></a>19 缺失的第一个正数(751)</h2><p><a href="https://leetcode-cn.com/problems/first-missing-positive/">https://leetcode-cn.com/problems/first-missing-positive/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,0]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,4,-1,1]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [7,8,9,11,12]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>怎么会怎么来，排序，接着遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; ans) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == ans) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="20-最长上升子序列-718"><a href="#20-最长上升子序列-718" class="headerlink" title="20 最长上升子序列(718)"></a>20 最长上升子序列(718)</h2><p><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个无序的整数数组，找到其中最长上升子序列的长度。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [10,9,2,5,3,7,101,18]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。</span><br></pre></td></tr></table></figure><p><strong><code>dp[i]</code> 表示以 <code>nums[i]</code> 这个数结尾的最长递增子序列的长度</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j]) &#123;</span><br><span class="line">                    dp[i] = Math.max(dp[i], dp[j] + <span class="number">1</span>); <span class="comment">// 关键这里，</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(dp).max().orElse(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21-将数组分成和相等的三个部分-798"><a href="#21-将数组分成和相等的三个部分-798" class="headerlink" title="21 将数组分成和相等的三个部分(798)"></a>21 将数组分成和相等的三个部分(798)</h2><p><a href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/">https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 A，只有可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。</span><br><span class="line"></span><br><span class="line">形式上，如果可以找出索引 i+1 &lt; j 且满足 A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1] 就可以将数组三等分。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：[0,2,1,-6,6,-7,9,1,2,0,1]</span><br><span class="line">输出：true</span><br><span class="line">解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1</span><br><span class="line"></span><br><span class="line">输入：[0,2,1,-6,6,7,9,-1,2,0,1]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">输入：[3,3,6,5,-2,2,5,1,-9,4]</span><br><span class="line">输出：true</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canThreePartsEqualSum</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历数组求总和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : A) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组A的和如果不能被3整除直接返回false</span></span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">3</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历数组累加，每累加到目标值cnt加1，表示又找到1段</span></span><br><span class="line">        sum /= <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSum</span> <span class="operator">=</span> <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; A.length; i++) &#123;</span><br><span class="line">            curSum += A[i];</span><br><span class="line">            <span class="keyword">if</span> (curSum == sum) &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                curSum = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后判断是否找到了3段（注意如果目标值是0的话可以大于3段）</span></span><br><span class="line">        <span class="keyword">return</span> cnt == <span class="number">3</span> || (cnt &gt; <span class="number">3</span> &amp;&amp; sum == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="22-拼写单词-705"><a href="#22-拼写单词-705" class="headerlink" title="22 拼写单词(705)"></a>22 拼写单词(705)</h2><p><a href="https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/">https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</span><br><span class="line"></span><br><span class="line">假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</span><br><span class="line"></span><br><span class="line">注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。</span><br><span class="line"></span><br><span class="line">返回词汇表 words 中你掌握的所有单词的 长度之和。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释： </span><br><span class="line">可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 = 6。</span><br><span class="line"></span><br><span class="line">输入：words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot;</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">可以形成字符串 &quot;hello&quot; 和 &quot;world&quot;，所以答案是 5 + 5 = 10。</span><br></pre></td></tr></table></figure><p>类似于map的数组即可。双map</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countCharacters</span><span class="params">(String[] words, String chars)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] hash = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : chars.toCharArray()) &#123;</span><br><span class="line">            hash[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            Arrays.fill(tmp, <span class="number">0</span>);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> ch : word.toCharArray()) &#123;</span><br><span class="line">                tmp[ch - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                <span class="keyword">if</span> (tmp[ch - <span class="string">&#x27;a&#x27;</span>] &gt; hash[ch - <span class="string">&#x27;a&#x27;</span>]) </span><br><span class="line">                    flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            len += flag ? word.length() : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-子集-633"><a href="#23-子集-633" class="headerlink" title="23 子集(633)"></a>23 子集(633)</h2><p><a href="https://leetcode-cn.com/problems/subsets/">https://leetcode-cn.com/problems/subsets/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</span><br><span class="line"></span><br><span class="line">说明：解集不能包含重复的子集。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [3],</span><br><span class="line">  [1],</span><br><span class="line">  [2],</span><br><span class="line">  [1,2,3],</span><br><span class="line">  [1,3],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; subsets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; tempSubset = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; size &lt;= nums.length; size++) &#123;</span><br><span class="line">            backtracking(<span class="number">0</span>, tempSubset, subsets, size, nums); <span class="comment">// 不同的子集大小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subsets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> start, List&lt;Integer&gt; tempSubset, List&lt;List&lt;Integer&gt;&gt; subsets,</span></span><br><span class="line"><span class="params">                            <span class="keyword">final</span> <span class="type">int</span> size, <span class="keyword">final</span> <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tempSubset.size() == size) &#123;</span><br><span class="line">            subsets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempSubset));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            tempSubset.add(nums[i]);</span><br><span class="line">            backtracking(i + <span class="number">1</span>, tempSubset, subsets, size, nums);</span><br><span class="line">            tempSubset.remove(tempSubset.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="24-岛屿的最大面积-648"><a href="#24-岛屿的最大面积-648" class="headerlink" title="24 岛屿的最大面积(648)"></a>24 岛屿的最大面积(648)</h2><p><a href="https://leetcode-cn.com/problems/max-area-of-island/">https://leetcode-cn.com/problems/max-area-of-island/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含了一些 0 和 1 的非空二维数组 grid 。</span><br><span class="line"></span><br><span class="line">一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</span><br><span class="line"></span><br><span class="line">找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[[0,0,1,0,0,0,0,1,0,0,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,1,1,0,1,0,0,0,0,0,0,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,0,1,0,0],</span><br><span class="line"> [0,1,0,0,1,1,0,0,1,1,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,0,0,0,1,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,1,0,0,0],</span><br><span class="line"> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</span><br><span class="line"> 对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m, n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] direaction = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                maxArea = Math.max(maxArea, dfs(grid, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || grid[r][c] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[r][c] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">area</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] d : direaction) &#123;</span><br><span class="line">            area += dfs(grid, r + d[<span class="number">0</span>], c + d[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="25-每日温度-698"><a href="#25-每日温度-698" class="headerlink" title="25 每日温度(698)"></a>25 每日温度(698)</h2><p><a href="https://leetcode-cn.com/problems/daily-temperatures/">https://leetcode-cn.com/problems/daily-temperatures/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。</span><br><span class="line"></span><br><span class="line">例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。</span><br><span class="line"></span><br><span class="line">提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。</span><br></pre></td></tr></table></figure><p>递减栈</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] T) &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[T.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; T.length; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; T[i] &gt; T[stack.peek()]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                res[t] = i - t;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="26-组合总和-582"><a href="#26-组合总和-582" class="headerlink" title="26 组合总和(582)"></a>26 组合总和(582)</h2><p><a href="https://leetcode-cn.com/problems/combination-sum/">https://leetcode-cn.com/problems/combination-sum/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个无重复元素的数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</span><br><span class="line"></span><br><span class="line">candidates 中的数字可以无限制重复被选取。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">输入: candidates = [2,3,6,7], target = 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combinationSum</span><span class="params">(<span class="type">int</span>[] candidates, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; combinations = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backtracking(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), combinations, <span class="number">0</span>, target, candidates);</span><br><span class="line">        <span class="keyword">return</span> combinations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(List&lt;Integer&gt; tempCombination, List&lt;List&lt;Integer&gt;&gt; combinations,</span></span><br><span class="line"><span class="params">                            <span class="type">int</span> start, <span class="type">int</span> target, <span class="keyword">final</span> <span class="type">int</span>[] candidates)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            combinations.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempCombination));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; candidates.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (candidates[i] &lt;= target) &#123;</span><br><span class="line">                tempCombination.add(candidates[i]);</span><br><span class="line">                backtracking(tempCombination, combinations, i, target - candidates[i], candidates);</span><br><span class="line">                tempCombination.remove(tempCombination.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="27-颜色分类-584"><a href="#27-颜色分类-584" class="headerlink" title="27 颜色分类(584)"></a>27 颜色分类(584)</h2><p><a href="https://leetcode-cn.com/problems/sort-colors/">https://leetcode-cn.com/problems/sort-colors/</a><br>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```html</span><br><span class="line">输入: [2,0,2,1,1,0]</span><br><span class="line">输出: [0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p>zero和two作为双指针</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sortColors</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">zero</span> <span class="operator">=</span> -<span class="number">1</span>, one = <span class="number">0</span>, two = nums.length;</span><br><span class="line">        <span class="keyword">while</span> (one &lt; two) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[one] == <span class="number">0</span>) &#123;</span><br><span class="line">                swap(nums, ++zero, one++);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[one] == <span class="number">2</span>)&#123;</span><br><span class="line">                swap(nums, --two, one);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ++one;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="28-三角形最小路径和-523"><a href="#28-三角形最小路径和-523" class="headerlink" title="28 三角形最小路径和(523)"></a>28 三角形最小路径和(523)</h2><p><a href="https://leetcode-cn.com/problems/triangle/">https://leetcode-cn.com/problems/triangle/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。</span><br><span class="line"></span><br><span class="line">相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">     [2],</span><br><span class="line">    [3,4],</span><br><span class="line">   [6,5,7],</span><br><span class="line">  [4,1,8,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>dp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTotal</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; triangle)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(triangle.size() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> triangle.size();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[row][triangle.get(row - <span class="number">1</span>).size()];</span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span><span class="number">0</span>; j &lt; triangle.get(i).size(); j++) &#123;</span><br><span class="line">                dp[i][j] = triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从下往上， 初始化最后一行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; triangle.get(row - <span class="number">1</span>).size(); i++) &#123;</span><br><span class="line">            dp[row - <span class="number">1</span>][i] = triangle.get(row - <span class="number">1</span>).get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; triangle.get(i).size(); j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i+<span class="number">1</span>][j], dp[i+<span class="number">1</span>][j+<span class="number">1</span>]) + triangle.get(i).get(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="29-乘积最大子数组-541"><a href="#29-乘积最大子数组-541" class="headerlink" title="29 乘积最大子数组(541)"></a>29 乘积最大子数组(541)</h2><p><a href="https://leetcode-cn.com/problems/maximum-product-subarray/">https://leetcode-cn.com/problems/maximum-product-subarray/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,3,-2,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 子数组 [2,3] 有最大乘积 6。</span><br><span class="line"></span><br><span class="line">输入: [-2,0,-1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。</span><br></pre></td></tr></table></figure><p>dp</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">int</span>[] dpMax = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] dpMin = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        dpMax[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dpMin[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i-<span class="number">1</span>] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> dpMax[i-<span class="number">1</span>];</span><br><span class="line">                dpMax[i-<span class="number">1</span>] = dpMin[i-<span class="number">1</span>];</span><br><span class="line">                dpMin[i-<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            dpMax[i] = Math.max(dpMax[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>], nums[i-<span class="number">1</span>]);</span><br><span class="line">            dpMin[i] = Math.min(dpMin[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>], nums[i-<span class="number">1</span>]);</span><br><span class="line">            ans = Math.max(ans, dpMax[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="30-两数之和-II-输入有序数组-559"><a href="#30-两数之和-II-输入有序数组-559" class="headerlink" title="30 两数之和 II - 输入有序数组(559)"></a>30 两数之和 II - 输入有序数组(559)</h2><p><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/">https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</span><br><span class="line"></span><br><span class="line">函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">返回的下标值（index1 和 index2）不是从零开始的。</span><br><span class="line">你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers = [2, 7, 11, 15], target = 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] numbers, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span> (numbers == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 双指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>, p2 = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; p2) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> numbers[p1] + numbers[p2];</span><br><span class="line">            <span class="keyword">if</span> (sum == target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;p1+<span class="number">1</span>, p2+<span class="number">1</span>&#125;;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; target) p1++;</span><br><span class="line">            <span class="keyword">else</span> p2--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="31-旋转数组-517"><a href="#31-旋转数组-517" class="headerlink" title="31 旋转数组(517)"></a>31 旋转数组(517)</h2><p><a href="https://leetcode-cn.com/problems/rotate-array/">https://leetcode-cn.com/problems/rotate-array/</a></p><p>给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4,5,6,7] 和 k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右旋转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右旋转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右旋转 3 步: [5,6,7,1,2,3,4]</span><br><span class="line"></span><br><span class="line">输入: [-1,-100,3,99] 和 k = 2</span><br><span class="line">输出: [3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右旋转 1 步: [99,-1,-100,3]</span><br><span class="line">向右旋转 2 步: [3,99,-1,-100]</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        k %= n;</span><br><span class="line">        reverse(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        reverse(nums, k, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[start];</span><br><span class="line">            nums[start++] = nums[end];</span><br><span class="line">            nums[end--] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="32-寻找重复数-515"><a href="#32-寻找重复数-515" class="headerlink" title="32 寻找重复数(515)"></a>32 寻找重复数(515)</h2><p><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">https://leetcode-cn.com/problems/find-the-duplicate-number/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。</span><br><span class="line"></span><br><span class="line">输入: [1,3,4,2,2]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">输入: [3,1,3,4,2]</span><br><span class="line">输出: 3</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们可以使用双指针解决本题，慢指针每次走一步，快指针每次走两步</p><p>快指针走了：a + ( b + c ) m + b a + (b+c)m + b<em>a</em>+(<em>b</em>+<em>c</em>)<em>m</em>+<em>b</em><br>慢指针走了：a + ( b + c ) n + b a + (b+c)n + b<em>a</em>+(<em>b</em>+<em>c</em>)<em>n</em>+<em>b</em><br>根据快走的是慢的两倍，<br>a + ( b + c ) m + b = 2 ( a + ( b + c ) n + b ) a + (b+c)m + b = 2(a + (b+c)n + b)<em>a</em>+(<em>b</em>+<em>c</em>)<em>m</em>+<em>b</em>=2(<em>a</em>+(<em>b</em>+<em>c</em>)<em>n</em>+<em>b</em>) =&gt;<br>a = ( b + c ) ( m − 2 n ) − b a = (b+c)(m-2n) - b<em>a</em>=(<em>b</em>+<em>c</em>)(<em>m</em>−2<em>n</em>)−<em>b</em></p><p>得 a 的距离为（环长度的倍数 - b），即从头节点走到环开头节点等于 slow 指针走到环开头节点的距离</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> nums[<span class="number">0</span>], fast = nums[nums[<span class="number">0</span>]];</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line">        fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="33-存在重复元素-471"><a href="#33-存在重复元素-471" class="headerlink" title="33 存在重复元素(471)"></a>33 存在重复元素(471)</h2><p><a href="https://leetcode-cn.com/problems/contains-duplicate/">https://leetcode-cn.com/problems/contains-duplicate/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组，判断是否存在重复元素。</span><br><span class="line"></span><br><span class="line">如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: true</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.add(num)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="34-除自身以外数组的乘积-467"><a href="#34-除自身以外数组的乘积-467" class="headerlink" title="34 除自身以外数组的乘积(467)"></a>34 除自身以外数组的乘积(467)</h2><p><a href="https://leetcode-cn.com/problems/product-of-array-except-self/">https://leetcode-cn.com/problems/product-of-array-except-self/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</span><br><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] productExceptSelf(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] products = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(products, <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            left *= nums[i - <span class="number">1</span>];</span><br><span class="line">            products[i] *= left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            right *= nums[i + <span class="number">1</span>];</span><br><span class="line">            products[i] *= right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> products;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="35-两个数组的交集-II-402"><a href="#35-两个数组的交集-II-402" class="headerlink" title="35 两个数组的交集 II(402)"></a>35 两个数组的交集 II(402)</h2><p><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/">https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/</a></p><p>给定两个数组，编写一个函数来计算它们的交集。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums1 = [1,2,2,1], nums2 = [2,2]</span><br><span class="line">输出: [2,2]</span><br><span class="line"></span><br><span class="line">输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><br><span class="line">输出: [4,9]</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] intersect(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums1) &#123;</span><br><span class="line">            list1.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1.contains(num)) &#123;</span><br><span class="line">                list2.add(num);</span><br><span class="line">                list1.remove(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list2.stream().mapToInt(Integer::valueOf).toArray();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="36-子集-II-304"><a href="#36-子集-II-304" class="headerlink" title="36 子集 II(304)"></a>36 子集 II(304)</h2><p><a href="https://leetcode-cn.com/problems/subsets-ii/">https://leetcode-cn.com/problems/subsets-ii/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</span><br><span class="line"></span><br><span class="line">说明：解集不能包含重复的子集。</span><br><span class="line"></span><br><span class="line">输入: [1,2,2]</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2],</span><br><span class="line">  [1],</span><br><span class="line">  [1,2,2],</span><br><span class="line">  [2,2],</span><br><span class="line">  [1,2],</span><br><span class="line">  []</span><br><span class="line">]</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; subsets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; tempSubset = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; size &lt;= nums.length; size++) &#123;</span><br><span class="line">            backtracking(<span class="number">0</span>, tempSubset, subsets, hasVisited, size, nums); <span class="comment">// 不同的子集大小</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subsets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(<span class="type">int</span> start, List&lt;Integer&gt; tempSubset, List&lt;List&lt;Integer&gt;&gt; subsets, <span class="type">boolean</span>[] hasVisited,</span></span><br><span class="line"><span class="params">                            <span class="keyword">final</span> <span class="type">int</span> size, <span class="keyword">final</span> <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tempSubset.size() == size) &#123;</span><br><span class="line">            subsets.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(tempSubset));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; !hasVisited[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tempSubset.add(nums[i]);</span><br><span class="line">            hasVisited[i] = <span class="literal">true</span>;</span><br><span class="line">            backtracking(i + <span class="number">1</span>, tempSubset, subsets, hasVisited, size, nums);</span><br><span class="line">            hasVisited[i] = <span class="literal">false</span>;</span><br><span class="line">            tempSubset.remove(tempSubset.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="37-寻找旋转排序数组中的最小值-316"><a href="#37-寻找旋转排序数组中的最小值-316" class="headerlink" title="37 寻找旋转排序数组中的最小值(316)"></a>37 寻找旋转排序数组中的最小值(316)</h2><p><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">假设按照升序排序的数组在预先未知的某个点上进行了旋转。</span><br><span class="line"></span><br><span class="line">( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。</span><br><span class="line"></span><br><span class="line">请找出其中最小的元素。</span><br><span class="line"></span><br><span class="line">你可以假设数组中不存在重复元素。</span><br><span class="line"></span><br><span class="line">输入: [3,4,5,1,2]</span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">输入: [4,5,6,7,0,1,2]</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, h = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; h) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (h - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &lt;= nums[h]) &#123;</span><br><span class="line">                h = m;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="38-有序矩阵中第K小的元素-337"><a href="#38-有序矩阵中第K小的元素-337" class="headerlink" title="38 有序矩阵中第K小的元素(337)"></a>38 有序矩阵中第K小的元素(337)</h2><p><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/">https://leetcode-cn.com/problems/kth-smallest-element-in-a-sorted-matrix/</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">给定一个 n x n 矩阵，其中每行和每列元素均按升序排序，找到矩阵中第 k 小的元素。</span><br><span class="line">请注意，它是排序后的第 k 小元素，而不是第 k 个不同的元素。</span><br><span class="line"></span><br><span class="line">matrix = [</span><br><span class="line">   [ 1,  5,  9],</span><br><span class="line">   [10, 11, 13],</span><br><span class="line">   [12, 13, 15]</span><br><span class="line">],</span><br><span class="line">k = 8,</span><br><span class="line"></span><br><span class="line">返回 13。</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lo</span> <span class="operator">=</span> matrix[<span class="number">0</span>][<span class="number">0</span>], hi = matrix[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n &amp;&amp; matrix[i][j] &lt;= mid; j++) &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cnt &lt; k) lo = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> hi = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Algorithm] Dynamic Programming</title>
      <link href="/2021/06/12/Algorithm/Dynamic%20Programming/"/>
      <url>/2021/06/12/Algorithm/Dynamic%20Programming/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h3 id="0-1-1、思考状态"><a href="#0-1-1、思考状态" class="headerlink" title="0.1 1、思考状态"></a>0.1 1、思考状态</h3><ul><li>状态的定义：题目问什么，把什么设置成状态</li><li>思考状态怎么转移，如果不好转移，尝试修改定义</li><li>状态转移方程：大问题的最优解怎么从小问题的最优解得到</li></ul><h3 id="0-2-2、思考状态转移方程"><a href="#0-2-2、思考状态转移方程" class="headerlink" title="0.2 2、思考状态转移方程"></a>0.2 2、思考状态转移方程</h3><ul><li>推导技巧：分类讨论。即：对状态空间进行分类</li><li>「动态规划」方法依然是「空间换时间」思想的体现，常见的解决问题的过程很像在「填表」</li></ul><h3 id="0-3-3、思考初始化"><a href="#0-3-3、思考初始化" class="headerlink" title="0.3 3、思考初始化"></a>0.3 3、思考初始化</h3><ul><li>角度 1：直接从状态的语义出发；</li><li>角度 2：如果状态的语义不好思考，就考虑「状态转移方程」的边界需要什么样初始化的条件；</li><li>角度 3：从「状态转移方程」方程的下标看是否需要多设置一行、一列表示「哨兵」（sentinel），这样可以避免一些特殊情况的讨论。</li></ul><h3 id="0-4-4、思考输出"><a href="#0-4-4、思考输出" class="headerlink" title="0.4 4、思考输出"></a>0.4 4、思考输出</h3><p>有些时候是最后一个状态，有些时候可能会综合之前所有计算过的状态。</p><h3 id="0-5-5、思考优化空间（也可以叫做表格复用）"><a href="#0-5-5、思考优化空间（也可以叫做表格复用）" class="headerlink" title="0.5 5、思考优化空间（也可以叫做表格复用）"></a>0.5 5、思考优化空间（也可以叫做表格复用）</h3><ul><li>「优化空间」会使得代码难于理解，且是的「状态」丢失原来的语义，初学的时候可以不一步到位。先把代码写正确是更重要；</li><li>「优化空间」在有一种情况下是很有必要的，那就是状态空间非常庞大的时候（处理海量数据），此时空间不够用，就必须「优化空间」；</li><li>非常经典的「优化空间」的典型问题是「0-1 背包」问题和「完全背包」问题。</li></ul><h2 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1 斐波那契数列"></a>1 斐波那契数列</h2><h3 id="1-1-70-爬楼梯"><a href="#1-1-70-爬楼梯" class="headerlink" title="1.1 70.爬楼梯"></a>1.1 70.爬楼梯</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：第i个楼梯可以从i-1或者i-2处再走一步到达；那么dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class="line"><span class="comment">//又因为只和前两步有关，可以用两个变量存储之前的状态，降低时间复杂度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre1</span> <span class="operator">=</span> <span class="number">1</span>,pre2 = <span class="number">2</span>;  <span class="comment">//初始状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> pre1 + pre2;<span class="comment">//当前为前两级的和</span></span><br><span class="line">            pre1 = pre2;<span class="comment">//都前进一步</span></span><br><span class="line">            pre2 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-198-强盗打劫"><a href="#1-2-198-强盗打劫" class="headerlink" title="1.2 198.强盗打劫"></a>1.2 198.强盗打劫</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。</span></span><br><span class="line"><span class="comment">//状态转移方程：dp[i] = Math.max(dp[i-2] + nums[i],dp[i-1]) </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre1</span> <span class="operator">=</span> <span class="number">0</span>,pre2 = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            cur = Math.max(nums[i] + pre1 , pre2);</span><br><span class="line">            pre1 = pre2;</span><br><span class="line">            pre2 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-213-强盗在环型街道打劫"><a href="#1-3-213-强盗在环型街道打劫" class="headerlink" title="1.3 213.强盗在环型街道打劫"></a>1.3 213.强盗在环型街道打劫</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：在打家劫舍的基础上限定了范围，也就是打劫的第一家和最后一家不能相邻[0,n-2] [1,n-1]</span></span><br><span class="line"><span class="comment">//状态转移方程dp[i] = Math.max(dp[i-2] + nums[i],dp[i-1]) </span></span><br><span class="line"><span class="comment">//通过新建打劫方法对范围进行限定和比较</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//抢劫的第一家和最后一家不能相邻[1,n-1] [0,n-2]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> Math.max(robHelper(nums,<span class="number">1</span>,n-<span class="number">1</span>),robHelper(nums,<span class="number">0</span>,n-<span class="number">2</span>)); <span class="comment">//两种不同的打劫方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">robHelper</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre1</span> <span class="operator">=</span> <span class="number">0</span>,pre2=<span class="number">0</span>,cur=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i&lt;=end;i++)&#123;</span><br><span class="line">            cur = Math.max(pre1 + nums[i] , pre2);</span><br><span class="line">            pre1 = pre2;</span><br><span class="line">            pre2 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-信件错排"><a href="#1-4-信件错排" class="headerlink" title="1.4 信件错排"></a>1.4 信件错排</h3><p>题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：</span></span><br><span class="line"><span class="comment">// i==k，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。</span></span><br><span class="line"><span class="comment">// i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。</span></span><br><span class="line">dp[i] = (i-<span class="number">1</span>)*dp[i-<span class="number">2</span>] + (i-<span class="number">1</span>)*dp[i-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="1-5-母牛生产"><a href="#1-5-母牛生产" class="headerlink" title="1.5 母牛生产"></a>1.5 母牛生产</h3><p>题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="2-矩阵路径"><a href="#2-矩阵路径" class="headerlink" title="2 矩阵路径"></a>2 矩阵路径</h2><h3 id="2-1-64-矩阵的最小路径和"><a href="#2-1-64-矩阵的最小路径和" class="headerlink" title="2.1 64.矩阵的最小路径和"></a>2.1 64.矩阵的最小路径和</h3><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前的状态只能从左或者上到达</span></span><br><span class="line"><span class="comment">//状态转移方程dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</span></span><br><span class="line"><span class="comment">//考虑边界，在最左时不可能从左来，在最上时，不可能从上来</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; grid.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>) grid[i][j] = grid[i][j] + grid[i][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) grid[i][j] = grid[i][j] + grid[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] = grid[i][j] + Math.min(grid[i-<span class="number">1</span>][j],grid[i][j-<span class="number">1</span>]);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.length - <span class="number">1</span>][grid[<span class="number">0</span>].length - <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-62-矩阵的总路径数"><a href="#2-2-62-矩阵的总路径数" class="headerlink" title="2.2 62.矩阵的总路径数"></a>2.2 62.矩阵的总路径数</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span><br><span class="line"><span class="comment">//左边界和上边界都是1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-0-1背包"><a href="#3-0-1背包" class="headerlink" title="3 0-1背包"></a>3 0-1背包</h2><p>有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：</span></span><br><span class="line"><span class="comment">//第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。</span></span><br><span class="line"><span class="comment">//第 i 件物品添加到背包中，dp[i][j] = dp[i-1][j-w] + v。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//状态转移方程：dp[i][j] = max(dp[i-1][j], dp[i-1][j-w]+v)</span></span><br><span class="line"><span class="comment">// W 为背包总体积</span></span><br><span class="line"><span class="comment">// N 为物品数量</span></span><br><span class="line"><span class="comment">// weights 数组存储 N 个物品的重量</span></span><br><span class="line"><span class="comment">// values 数组存储 N 个物品的价值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span> N, <span class="type">int</span>[] weights, <span class="type">int</span>[] values)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> weights[i - <span class="number">1</span>], v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= W; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w) &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w] + v);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-空间优化"><a href="#3-1-空间优化" class="headerlink" title="3.1 空间优化"></a>3.1 空间优化</h3><p>观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i] = max(dp[j],dp[j-w]+v)</span></span><br><span class="line"><span class="comment">//因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w]，防止将 dp[i-1][j-w] 覆盖。也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按倒序来循环求解。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span> N, <span class="type">int</span>[] weights, <span class="type">int</span>[] values)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> weights[i - <span class="number">1</span>], v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> W; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - w] + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-完全背包"><a href="#4-完全背包" class="headerlink" title="4 完全背包"></a>4 完全背包</h2><h3 id="4-1-322-找零钱的最少硬币数"><a href="#4-1-322-找零钱的最少硬币数" class="headerlink" title="4.1 322.找零钱的最少硬币数"></a>4.1 322.找零钱的最少硬币数</h3><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//状态转移方程：dp[amount] = Math.min(&#123;dp[amount - coin]|(for(int coin : coins))&#125;)</span></span><br><span class="line"><span class="comment">//也就是根据当前硬币的面值可以抵达的状态中的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> coin : coins)&#123;<span class="comment">//对硬币面值进行遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> coin; i &lt; amount + <span class="number">1</span>; i++)&#123;</span><br><span class="line">                <span class="comment">//如果一个硬币就可以，置为一</span></span><br><span class="line">                <span class="keyword">if</span>(i == coin) dp[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果减一个硬币就可以，在该状态基础上加一</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dp[i] == <span class="number">0</span> &amp;&amp; dp[i-coin] != <span class="number">0</span>) dp[i] = dp[i-coin] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//在遍历硬币的时候，如果发现更优解，重置结果</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dp[i] != <span class="number">0</span> &amp;&amp; dp[i-coin] != <span class="number">0</span>) dp[i] = Math.min(dp[i], dp[i-coin]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == <span class="number">0</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-518-找零钱的硬币数组合"><a href="#4-2-518-找零钱的硬币数组合" class="headerlink" title="4.2 518.找零钱的硬币数组合"></a>4.2 518.找零钱的硬币数组合</h3><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> coin : coins)&#123;   <span class="comment">//遍历硬币面值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> coin; i &lt; amount + <span class="number">1</span>; i++)&#123;</span><br><span class="line">                dp[i] += dp[i-coin];  <span class="comment">//终态是不同状态到达该状态的累加</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-数组区间"><a href="#5-数组区间" class="headerlink" title="5 数组区间"></a>5 数组区间</h2><h3 id="5-1-303-数组区间和"><a href="#5-1-303-数组区间和" class="headerlink" title="5.1 303.数组区间和"></a>5.1 303.数组区间和</h3><p>给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从i到j的区间和可以转化成前缀和之差</span></span><br><span class="line"><span class="comment">//构建一个数组，保存从0到下标处的数组和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] sums;  <span class="comment">//和数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= nums.length;i++)&#123;</span><br><span class="line">            sums[i] = sums[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sums[j+<span class="number">1</span>] - sums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-413-等差数列划分"><a href="#5-2-413-等差数列划分" class="headerlink" title="5.2 413.等差数列划分"></a>5.2 413.等差数列划分</h3><p>数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。</p><p>如果满足以下条件，则称子数组(P, Q)为等差数组：</p><p>元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。</p><p>函数要返回数组 A 中所有为等差数组的子数组个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：dp[i]表示以A[i]结尾的等差递增子区间的个数</span></span><br><span class="line"><span class="comment">//当 A[i] - A[i-1] == A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。</span></span><br><span class="line"><span class="comment">//也就是在 A[i] - A[i-1] == A[i-1] - A[i-2] 时，dp[i] = dp[i-1] + 1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfArithmeticSlices</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> A.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] - A[i-<span class="number">1</span>] == A[i-<span class="number">1</span>] - A[i-<span class="number">2</span>])&#123;<span class="comment">//从头到尾遍历数组</span></span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> cnt : dp)&#123;</span><br><span class="line">            total += cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-分割整数"><a href="#6-分割整数" class="headerlink" title="6 分割整数"></a>6 分割整数</h2><h3 id="6-1-分割整数的最大乘积"><a href="#6-1-分割整数的最大乘积" class="headerlink" title="6.1 分割整数的最大乘积"></a>6.1 分割整数的最大乘积</h3><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//状态转移方程： dp[i] = Math.max(dp[i], Math.max(j*dp[i-j], j*(i-j)))</span></span><br><span class="line"><span class="comment">//和自己比，和不同切的方式比，留下最大值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j*dp[i-j], j*(i-j)));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-最长上升子序列"><a href="#7-最长上升子序列" class="headerlink" title="7 最长上升子序列"></a>7 最长上升子序列</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：动态规划 dp[i]存储当前的最大上升子序列，遍历前序dp，如果大于则dp[j]+1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;<span class="comment">//遍历整数数组</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)&#123;<span class="comment">//计算当前最大上升子序列</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;<span class="comment">//如果当前值比前面遍历到的大，最大上升子序列加一</span></span><br><span class="line">                    max = Math.max(max, dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ret : dp)&#123;</span><br><span class="line">            result = Math.max(ret, result);   <span class="comment">//找出dp数组中的最大</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-1-剑指-Offer-46-把数字翻译成字符串"><a href="#7-1-剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="7.1 剑指 Offer 46. 把数字翻译成字符串"></a>7.1 <a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h3><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(num);</span><br><span class="line">        <span class="comment">//dp[i-2] = b; dp[i-1] = a; dp[i] = c </span></span><br><span class="line">        <span class="comment">//对于一个字符串，如果最后两位可以被翻译，那么</span></span><br><span class="line">        <span class="comment">//dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class="line">        <span class="comment">//否则dp[i] = dp[i-1]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从左往右递推</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> s.substring(i - <span class="number">2</span>, i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> tmp.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; tmp.compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> ? a + b : a;</span><br><span class="line">            b = a;</span><br><span class="line">            a = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-字符串相关"><a href="#8-字符串相关" class="headerlink" title="8 字符串相关"></a>8 字符串相关</h2><h3 id="8-1-72-编辑距离"><a href="#8-1-72-编辑距离" class="headerlink" title="8.1 72. 编辑距离"></a>8.1 <a href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a></h3><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i][j]: word1中前i个单词变换到word2中前j个单词需要的最短操作次数</span></span><br><span class="line"><span class="comment">//考虑某一个单词是空的</span></span><br><span class="line"><span class="comment">//状态转移：</span></span><br><span class="line"><span class="comment">//增：dp[i][j] = dp[i][j-1] + 1</span></span><br><span class="line"><span class="comment">//删：dp[i][j] = dp[i-1][j] + 1</span></span><br><span class="line"><span class="comment">//改：dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> word1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> word2.length();</span><br><span class="line">        <span class="comment">// 多开一行一列是为了保存边界条件，即字符长度为 0 的情况，这一点在字符串的动态规划问题中比较常见</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化：当 word2 长度为 0 时，将 word1 的全部删除即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 word1 长度为 0 时，插入所有 word2 的字符即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 由于 word1.charAt(i) 操作会去检查下标是否越界，因此在 Java 里，将字符串转换成字符数组是常见额操作</span></span><br><span class="line">        <span class="type">char</span>[] word1Array = word1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] word2Array = word2.toCharArray();</span><br><span class="line">        <span class="comment">// 递推开始，注意：填写 dp 数组的时候，由于初始化多设置了一行一列，横纵坐标有个偏移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">                <span class="comment">// 这是最佳情况</span></span><br><span class="line">                <span class="comment">// 多开了一行，所以是 i-1 和 j-1</span></span><br><span class="line">                <span class="keyword">if</span> (word1Array[i - <span class="number">1</span>] == word2Array[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 否则在以下三种情况中选出步骤最少的，这是「动态规划」的「最优子结构」</span></span><br><span class="line">                <span class="comment">// 1、在下标 i 处插入一个字符</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 2、替换一个字符</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">replace</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 3、删除一个字符</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">delete</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = Math.min(Math.min(insert, replace), delete);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-2-5-最长回文子串"><a href="#8-2-5-最长回文子串" class="headerlink" title="8.2 5. 最长回文子串"></a>8.2 <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h3><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义状态 dp[i][j] 表示从 i 到 j 的字串是不是回文的</span></span><br><span class="line"><span class="comment">//状态转移方程 ：dp[i][j] = ( s[j] == s[j] ) &amp;&amp; dp[i+1][j-1]</span></span><br><span class="line"><span class="comment">//或者 j - i &lt; 3 的情况下 s[j] == s[j]</span></span><br><span class="line"><span class="comment">//初始化dp[i][i] = true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录最大长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录开始</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//表示从i到j是不是回文串</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len; i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(charArray[i] != charArray[j])&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - i &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen)&#123;</span><br><span class="line">                maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,start+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Algorithm] Queue&amp;Stack</title>
      <link href="/2021/06/12/Algorithm/Queue&amp;Stack/"/>
      <url>/2021/06/12/Algorithm/Queue&amp;Stack/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="0-1-20-有效的括号"><a href="#0-1-20-有效的括号" class="headerlink" title="0.1 20. 有效的括号"></a>0.1 <a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>用栈实现。如果是左括号直接压入栈，如果遇到右括号则弹出一个，如果不匹配直接输出false，如果匹配则继续。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>( c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">cPop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; cPop != <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; cPop != <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; cPop != <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(b1 || b2 || b3)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-2-42-接雨水"><a href="#0-2-42-接雨水" class="headerlink" title="0.2 42. 接雨水"></a>0.2 <a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于某个位置 i，可以接的雨水是左侧最高和右侧最高的较小 减去当前高度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (height.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 数组充当备忘录</span></span><br><span class="line">        <span class="type">int</span>[] l_max = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] r_max = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 初始化 base case</span></span><br><span class="line">        l_max[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        r_max[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 从左向右计算 l_max 包括 i 位置在内</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            l_max[i] = Math.max(height[i], l_max[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 从右向左计算 r_max</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            r_max[i] = Math.max(height[i], r_max[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 计算答案</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">            res += Math.min(l_max[i], r_max[i]) - height[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l_max</span> <span class="operator">=</span> <span class="number">0</span>, r_max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        l_max = Math.max(l_max, height[left]);</span><br><span class="line">        r_max = Math.max(r_max, height[right]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// res += min(l_max, r_max) - height[i]</span></span><br><span class="line">        <span class="keyword">if</span> (l_max &lt; r_max) &#123;</span><br><span class="line">            res += l_max - height[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += r_max - height[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-3-11-盛最多水的容器"><a href="#0-3-11-盛最多水的容器" class="headerlink" title="0.3 11. 盛最多水的容器"></a>0.3 <a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h3><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// [left, right] 之间的矩形面积</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cur_area</span> <span class="operator">=</span> Math.min(height[left], height[right]) * (right - left);</span><br><span class="line">            res = Math.max(res, cur_area);</span><br><span class="line">            <span class="comment">// 双指针技巧，移动较低的一边</span></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-4-232-用栈实现队列"><a href="#0-4-232-用栈实现队列" class="headerlink" title="0.4 232. 用栈实现队列"></a>0.4 <a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h3><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><p>栈的顺序为后进先出，而队列的顺序为先进先出。使用两个栈实现队列，一个元素需要经过两个栈才能出队列，在经过第一个栈时元素顺序被反转，经过第二个栈时再次被反转，此时就是先进先出顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; in;</span><br><span class="line">    Stack&lt;Integer&gt; out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        in = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        out = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        in.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        in2out();</span><br><span class="line">        <span class="keyword">return</span> out.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        in2out();</span><br><span class="line">        <span class="keyword">return</span> out.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">in2out</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(out.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!in.isEmpty())&#123;</span><br><span class="line">                out.push(in.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> in.isEmpty() &amp;&amp; out.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-5-225-用队列实现栈"><a href="#0-5-225-用队列实现栈" class="headerlink" title="0.5 225. 用队列实现栈"></a>0.5 <a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h3><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p><p>在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        queue.add(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            queue.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-6-1047-删除字符串中的所有相邻重复项"><a href="#0-6-1047-删除字符串中的所有相邻重复项" class="headerlink" title="0.6 1047. 删除字符串中的所有相邻重复项"></a>0.6 <a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h3><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        Deque&lt;Character&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : cs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!d.isEmpty() &amp;&amp; d.peekLast().equals(c)) &#123;</span><br><span class="line">                d.pollLast();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                d.addLast(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (!d.isEmpty()) sb.append(d.pollLast());</span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-7-316-去除重复字母"><a href="#0-7-316-去除重复字母" class="headerlink" title="0.7 316. 去除重复字母"></a>0.7 <a href="https://leetcode.cn/problems/remove-duplicate-letters/">316. 去除重复字母</a></h3><p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p><p>要利用 stack 结构和一个 inStack 布尔数组来满足上述三个条件，具体思路如下：</p><p>通过 inStack 这个布尔数组做到栈 stk 中不存在重复元素，满足要求一。</p><p>我们顺序遍历字符串 s，通过「栈」这种顺序结构的 push/pop 操作记录结果字符串，保证了字符出现的顺序和 s 中出现的顺序一致，满足要求二。</p><p>我们用类似单调栈的思路，配合计数器 count 不断 pop 掉不符合最小字典序的字符，保证了最终得到的结果字典序最小，满足要求三。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicateLetters</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 维护一个计数器记录字符串中字符的数量</span></span><br><span class="line">        <span class="comment">// 因为输入为 ASCII 字符，大小 256 够用了</span></span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            count[s.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] inStack = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">// 每遍历过一个字符，都将对应的计数减一</span></span><br><span class="line">            count[c]--;</span><br><span class="line">            <span class="keyword">if</span> (inStack[c]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 如果当前栈顶的比 c 大，并且还有重复的，那就 pop 出来</span></span><br><span class="line">            <span class="keyword">while</span> (!stk.isEmpty() &amp;&amp; stk.peek() &gt; c) &#123;</span><br><span class="line">                <span class="comment">// 若之后不存在栈顶元素了，则停止 pop</span></span><br><span class="line">                <span class="keyword">if</span> (count[stk.peek()] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 若之后还有，则可以 pop</span></span><br><span class="line">                inStack[stk.pop()] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(c);</span><br><span class="line">            inStack[c] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">            sb.append(stk.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-8-155-最小栈"><a href="#0-8-155-最小栈" class="headerlink" title="0.8 155. 最小栈"></a>0.8 <a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></h3><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>两个栈：保持两个栈的大小相等。压栈时，一个压数据，另一个压目前入栈的最小值；而出栈时，一起弹出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; dataStack;</span><br><span class="line">    Stack&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        dataStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        dataStack.push(x);</span><br><span class="line">        min = Math.min(min,x);</span><br><span class="line">        minStack.push(min);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        dataStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">        <span class="keyword">if</span>(minStack.isEmpty()) min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">else</span> min = minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-9-496-下一个更大元素-I-单调栈"><a href="#0-9-496-下一个更大元素-I-单调栈" class="headerlink" title="0.9 496. 下一个更大元素 I 单调栈"></a>0.9 <a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a> 单调栈</h3><p>nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把 nums2 中每个元素的下一个更大元素算出来存到一个映射里</span></span><br><span class="line"><span class="comment">// 然后再让 nums1 中的元素去查表即可。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// 记录 nums2 中每个元素的下一个更大元素</span></span><br><span class="line">        <span class="type">int</span>[] greater = nextGreaterElement(nums2);</span><br><span class="line">        <span class="comment">// 转化成映射：元素 x -&gt; x 的下一个最大元素</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; greaterMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">            greaterMap.put(nums2[i], greater[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums1 是 nums2 的子集，所以根据 greaterMap 可以得到结果</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            res[i] = greaterMap.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 nums 中每个元素的下一个更大元素</span></span><br><span class="line">    <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 存放答案的数组</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 倒着往栈里放</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 判定个子高矮</span></span><br><span class="line">            <span class="keyword">while</span> (!s.isEmpty() &amp;&amp; s.peek() &lt;= nums[i]) &#123;</span><br><span class="line">                <span class="comment">// 矮个起开，反正也被挡着了。。。</span></span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// nums[i] 身后的下一个更大元素</span></span><br><span class="line">            res[i] = s.isEmpty() ? -<span class="number">1</span> : s.peek();</span><br><span class="line">            s.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-10-503-下一个更大元素-II-单调栈"><a href="#0-10-503-下一个更大元素-II-单调栈" class="headerlink" title="0.10 503. 下一个更大元素 II  单调栈"></a>0.10 <a href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II</a>  单调栈</h3><p>给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里需要迭代两遍，而且输出的是更大的数而不是距离。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElements(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>*n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[i%n] &gt; nums[stack.peek()])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                result[pre] = nums[i%n];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n)&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result[pre] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-11-739-每日温度-单调栈"><a href="#0-11-739-每日温度-单调栈" class="headerlink" title="0.11 739. 每日温度  单调栈"></a>0.11 <a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a>  单调栈</h3><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用单调栈维护一个递减序列, 从后往前进行遍历</span></span><br><span class="line"><span class="comment">// 若当前元素小于栈顶，那么栈顶就是下一个更高温度，</span></span><br><span class="line"><span class="comment">// 再将当前温度入栈,继续寻找下一个</span></span><br><span class="line"><span class="comment">// 若栈空后仍无法找到比当前元素高的温度则为0.</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="comment">// 这里放元素索引，而不是元素</span></span><br><span class="line">    Stack&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); </span><br><span class="line">    <span class="comment">// 倒着入栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 如果不是递减就出栈</span></span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty() &amp;&amp; temperatures[s.peek()] &lt;= temperatures[i]) &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到索引间距</span></span><br><span class="line">        res[i] = s.isEmpty() ? <span class="number">0</span> : (s.peek() - i); </span><br><span class="line">        <span class="comment">// 将索引入栈，而不是元素</span></span><br><span class="line">        s.push(i); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-12-402-移掉-K-位数字"><a href="#0-12-402-移掉-K-位数字" class="headerlink" title="0.12 402. 移掉 K 位数字"></a>0.12 <a href="https://leetcode.cn/problems/remove-k-digits/">402. 移掉 K 位数字</a></h3><p>给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择使用单调栈，使得剩下的数字是单调递增的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeKdigits</span><span class="params">(String num, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Deque&lt;Character&gt; stk = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : num.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.isEmpty() &amp;&amp; c &lt; stk.getLast() &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                stk.pollLast();</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.addLast(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> stk.stream().map(Object::toString).collect(Collectors.joining());</span><br><span class="line">        res = res.substring(<span class="number">0</span>, res.length() - k).replaceAll(<span class="string">&quot;^0+&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res.isEmpty() ? <span class="string">&quot;0&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-13-71-简化路径"><a href="#0-13-71-简化路径" class="headerlink" title="0.13 71. 简化路径"></a>0.13 <a href="https://leetcode.cn/problems/simplify-path/">71. 简化路径</a></h3><p>给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 ‘/‘ 开头），请你将其转化为更加简洁的规范路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simplifyPath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        String[] parts = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        Stack&lt;String&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 借助栈计算最终的文件夹路径</span></span><br><span class="line">        <span class="keyword">for</span> (String part : parts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (part.isEmpty() || part.equals(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (part.equals(<span class="string">&quot;..&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stk.isEmpty()) stk.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(part);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 栈中存储的文件夹组成路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stk.isEmpty()) &#123;</span><br><span class="line">            res = <span class="string">&quot;/&quot;</span> + stk.pop() + res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.isEmpty() ? <span class="string">&quot;/&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-14-394-字符串解码"><a href="#0-14-394-字符串解码" class="headerlink" title="0.14 394. 字符串解码"></a>0.14 <a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">构建辅助栈 stack， 遍历字符串 s 中每个字符 c；</span><br><span class="line">当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；</span><br><span class="line">当 c 为字母时，在 res 尾部添加 c；</span><br><span class="line">当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 <span class="number">00</span>：</span><br><span class="line">记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；</span><br><span class="line">记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。</span><br><span class="line">进入到新 [ 后，res 和 multi 重新记录。</span><br><span class="line">当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:</span><br><span class="line">last_res是上个 [ 到当前 [ 的字符串，例如 <span class="string">&quot;3[a2[c]]&quot;</span> 中的 a；</span><br><span class="line">cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 <span class="string">&quot;3[a2[c]]&quot;</span> 中的 <span class="number">2</span>。</span><br><span class="line">返回字符串 res。</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">multi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack_multi = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        LinkedList&lt;String&gt; stack_res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Character c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                stack_multi.addLast(multi);</span><br><span class="line">                stack_res.addLast(res.toString());</span><br><span class="line">                multi = <span class="number">0</span>;</span><br><span class="line">                res = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="type">int</span> <span class="variable">cur_multi</span> <span class="operator">=</span> stack_multi.removeLast();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cur_multi; i++) tmp.append(res);</span><br><span class="line">                res = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stack_res.removeLast() + tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) multi = multi * <span class="number">10</span> + Integer.parseInt(c + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> res.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-15-84-柱状图中最大的矩形"><a href="#0-15-84-柱状图中最大的矩形" class="headerlink" title="0.15 84. 柱状图中最大的矩形"></a>0.15 <a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h3><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><ul><li>遇到了当前柱形的高度比它上一个柱形的高度严格小的时候，一定可以确定它之前的某些柱形的最大宽度，并且确定的柱形宽度的顺序是从右边向左边。</li><li>这个现象告诉我们，在遍历的时候需要记录的信息就是遍历到的柱形的下标，它一左一右的两个柱形的下标的差就是这个面积最大的矩形对应的最大宽度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="comment">// 特殊情况判断</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] newHeights = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 在两端加上高度为 0 的两根柱子，避免出现栈到最后不为空</span></span><br><span class="line">        newHeights[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        System.arraycopy(heights, <span class="number">0</span>, newHeights, <span class="number">1</span>, len);</span><br><span class="line">        newHeights[len + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        len += <span class="number">2</span>;</span><br><span class="line">        heights = newHeights;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(len);</span><br><span class="line">        <span class="comment">// 先放入哨兵，在循环里就不用做非空判断</span></span><br><span class="line">        stack.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前的高度比之前的小，可以之前的高度对应的面积</span></span><br><span class="line">            <span class="keyword">while</span> (heights[i] &lt; heights[stack.peekLast()]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">curHeight</span> <span class="operator">=</span> heights[stack.pollLast()];</span><br><span class="line">                <span class="type">int</span> <span class="variable">curWidth</span> <span class="operator">=</span> i - stack.peekLast() - <span class="number">1</span>;</span><br><span class="line">                res = Math.max(res, curHeight * curWidth);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果高度继续增加，继续存对应的下标</span></span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// int[] heights = &#123;2, 1, 5, 6, 2, 3&#125;;</span></span><br><span class="line">        <span class="type">int</span>[] heights = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> solution.largestRectangleArea(heights);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-16-85-最大矩形-hard"><a href="#0-16-85-最大矩形-hard" class="headerlink" title="0.16 85. 最大矩形 hard"></a>0.16 <a href="https://leetcode.cn/problems/maximal-rectangle/">85. 最大矩形</a> hard</h3><p>给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历每行的高度,用上一题方法(栈)求出最大矩形!</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// row 行 col 列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] height = <span class="keyword">new</span> <span class="title class_">int</span>[col + <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col + <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="number">1</span> &amp;&amp; j &lt;= col) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[i][j-<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) height[j] += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> height[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[stack.peek()] &gt; height[j]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    res = Math.max(res, (j - stack.peek() - <span class="number">1</span>) * height[cur]);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-17-224-基本计算器"><a href="#0-17-224-基本计算器" class="headerlink" title="0.17 224. 基本计算器"></a>0.17 <a href="https://leetcode.cn/problems/basic-calculator/">224. 基本计算器</a></h3><p>s 由数字、 + 、 -、(  、 )、和 ‘   ‘ 组成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 存放所有的数字</span></span><br><span class="line">        Deque&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 为了防止第一个数为负数，先往 nums 加个 0</span></span><br><span class="line">        nums.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 将所有的空格去掉</span></span><br><span class="line">        s = s.replaceAll(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 存放所有的操作，包括 +/-</span></span><br><span class="line">        Deque&lt;Character&gt; ops = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="comment">// 主逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> cs[i];</span><br><span class="line">            <span class="comment">// 如果是左括号，放入 ops</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ops.addLast(c);</span><br><span class="line">        <span class="comment">// 如果是右括号，计算一轮，直到碰到左括号</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 计算到最近一个左括号为止</span></span><br><span class="line">                <span class="keyword">while</span> (!ops.isEmpty()) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">op</span> <span class="operator">=</span> ops.peekLast();</span><br><span class="line">                    <span class="keyword">if</span> (op != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        calc(nums, ops);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 左括号出栈</span></span><br><span class="line">                        ops.pollLast();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是数字，连续取出，入栈</span></span><br><span class="line">                <span class="keyword">if</span> (isNum(c)) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">                    <span class="comment">// 将从 i 位置开始后面的连续数字整体取出，加入 nums</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; n &amp;&amp; isNum(cs[j])) u = u * <span class="number">10</span> + (<span class="type">int</span>)(cs[j++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    nums.addLast(u);</span><br><span class="line">                    i = j - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果是操作符 入栈</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (cs[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> || cs[i - <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> || cs[i - <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">                        nums.addLast(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 有一个新操作要入栈时，先把栈内可以算的都算了</span></span><br><span class="line">                    <span class="keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="string">&#x27;(&#x27;</span>) calc(nums, ops);</span><br><span class="line">                    ops.addLast(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!ops.isEmpty()) calc(nums, ops);</span><br><span class="line">        <span class="keyword">return</span> nums.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">calc</span><span class="params">(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ops.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> nums.pollLast(), a = nums.pollLast();</span><br><span class="line">        <span class="type">char</span> <span class="variable">op</span> <span class="operator">=</span> ops.pollLast();</span><br><span class="line">        nums.addLast(op == <span class="string">&#x27;+&#x27;</span> ? a + b : a - b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断数字</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNum</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Character.isDigit(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-18-227-基本计算器-II"><a href="#0-18-227-基本计算器-II" class="headerlink" title="0.18 227. 基本计算器 II"></a>0.18 <a href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II</a></h3><p>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。</p><p>整数除法仅保留整数部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">对于「任何表达式」而言，我们都使用两个栈 nums 和 ops：</span><br><span class="line">nums ： 存放所有的数字</span><br><span class="line">ops ：存放所有的数字以外的操作</span><br><span class="line">然后从前往后做，对遍历到的字符做分情况讨论：</span><br><span class="line">空格 : 跳过</span><br><span class="line">( : 直接加入 ops 中，等待与之匹配的 )</span><br><span class="line">) : 使用现有的 nums 和 ops 进行计算，直到遇到左边最近的一个左括号为止，计算结果放到 nums</span><br><span class="line">数字 : 从当前位置开始继续往后取，将整一个连续数字整体取出，加入 nums</span><br><span class="line">+ - * / ^ % : 需要将操作放入 ops 中。在放入之前先把栈内可以算的都算掉（只有「栈内运算符」比「当前运算符」优先级高/同等，才进行运算），使用现有的 nums 和 ops 进行计算，</span><br><span class="line"></span><br><span class="line">    比如当前栈内是➕号，但是后面出现了比如 * ，那就不能先算 <span class="number">1</span>+<span class="number">2</span>*<span class="number">3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 map 维护一个运算符优先级</span></span><br><span class="line">    <span class="comment">// 这里的优先级划分按照「数学」进行划分即可</span></span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()&#123;&#123;</span><br><span class="line">        put(<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        put(<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        put(<span class="string">&#x27;%&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        put(<span class="string">&#x27;^&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 将所有的空格去掉</span></span><br><span class="line">        s = s.replaceAll(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 存放所有的数字</span></span><br><span class="line">        Deque&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 为了防止第一个数为负数，先往 nums 加个 0</span></span><br><span class="line">        nums.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 存放所有「非数字以外」的操作</span></span><br><span class="line">        Deque&lt;Character&gt; ops = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> cs[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ops.addLast(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 计算到最近一个左括号为止</span></span><br><span class="line">                <span class="keyword">while</span> (!ops.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ops.peekLast() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        calc(nums, ops);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ops.pollLast();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isNumber(c)) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">                    <span class="comment">// 将从 i 位置开始后面的连续数字整体取出，加入 nums</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; n &amp;&amp; isNumber(cs[j])) u = u * <span class="number">10</span> + (cs[j++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    nums.addLast(u);</span><br><span class="line">                    i = j - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (cs[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> || cs[i - <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> || cs[i - <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">                        nums.addLast(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 有一个新操作要入栈时，先把栈内可以算的都算了 </span></span><br><span class="line">                    <span class="comment">// 只有满足「栈内运算符」比「当前运算符」优先级高/同等，才进行运算</span></span><br><span class="line">                    <span class="keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        <span class="type">char</span> <span class="variable">prev</span> <span class="operator">=</span> ops.peekLast();</span><br><span class="line">                        <span class="comment">// 判断优先级</span></span><br><span class="line">                        <span class="keyword">if</span> (map.get(prev) &gt;= map.get(c)) &#123;</span><br><span class="line">                            calc(nums, ops);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ops.addLast(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将剩余的计算完</span></span><br><span class="line">        <span class="keyword">while</span> (!ops.isEmpty()) calc(nums, ops);</span><br><span class="line">        <span class="keyword">return</span> nums.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算逻辑</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">calc</span><span class="params">(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ops.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> nums.pollLast(), a = nums.pollLast();</span><br><span class="line">        <span class="type">char</span> <span class="variable">op</span> <span class="operator">=</span> ops.pollLast();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>) ans = a + b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;-&#x27;</span>) ans = a - b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;*&#x27;</span>) ans = a * b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;/&#x27;</span>)  ans = a / b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;^&#x27;</span>) ans = (<span class="type">int</span>)Math.pow(a, b);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;%&#x27;</span>) ans = a % b;</span><br><span class="line">        nums.addLast(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Character.isDigit(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-19-150-逆波兰表达式求值"><a href="#0-19-150-逆波兰表达式求值" class="headerlink" title="0.19 150. 逆波兰表达式求值"></a>0.19 <a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h3><p>根据 逆波兰表示法，求表达式的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;+-*/&quot;</span>.contains(token)) &#123;</span><br><span class="line">                <span class="comment">// 是个运算符，从栈顶拿出两个数字进行运算，运算结果入栈</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> stk.pop(), b = stk.pop();</span><br><span class="line">                <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                        stk.push(a + b);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                        stk.push(a * b);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 对于减法和除法，顺序别搞反了，第二个数是被除（减）数</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                        stk.push(b - a);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                        stk.push(b / a);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 是个数字，直接入栈即可</span></span><br><span class="line">                stk.push(Integer.parseInt(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后栈中剩下一个数字，即是计算结果</span></span><br><span class="line">        <span class="keyword">return</span> stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-20-面试题59-II-队列的最大值"><a href="#0-20-面试题59-II-队列的最大值" class="headerlink" title="0.20 面试题59 - II. 队列的最大值"></a>0.20 <a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/">面试题59 - II. 队列的最大值</a></h3><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建一个递减列表来保存队列 所有递减的元素 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    Deque&lt;Integer&gt; deque;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max_value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deque.isEmpty() ? -<span class="number">1</span> : deque.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        queue.offer(value);</span><br><span class="line">        <span class="comment">// 如果入队的比当前最小的大，不停弹出，知道有序</span></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; value)</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        deque.offerLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop_front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(queue.peek().equals(deque.peekFirst()))</span><br><span class="line">            deque.pollFirst();</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-21-946-验证栈序列"><a href="#0-21-946-验证栈序列" class="headerlink" title="0.21 946. 验证栈序列"></a>0.21 <a href="https://leetcode.cn/problems/validate-stack-sequences/">946. 验证栈序列</a></h3><p>给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。</p><ul><li>根据题意，利用元素各不相同，我们使用一个栈来处理 pushed 数组，每次将 pushed[i] 放入栈中，然后比较当前栈顶元素是否与待弹出元素相同（使用变量 j 来代指当前待弹出元素下标），若相等则弹栈并进行 j 自增，当所有的元素处理完后，栈为空说明栈序列合法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; pushed.length; i++) &#123;</span><br><span class="line">            d.addLast(pushed[i]);</span><br><span class="line">            <span class="keyword">while</span> (!d.isEmpty() &amp;&amp; d.peekLast() == popped[j] &amp;&amp; ++j &gt;= <span class="number">0</span>) d.pollLast(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Algorithm] Binary Search</title>
      <link href="/2021/06/12/Algorithm/Binary%20Search/"/>
      <url>/2021/06/12/Algorithm/Binary%20Search/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>二分查找就是不断缩小搜索区间的过程，要注意到区间内的元素不能遗漏</p><h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1 时间复杂度"></a>1 时间复杂度</h2><p>二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。</p><h2 id="2-二分查找框架"><a href="#2-二分查找框架" class="headerlink" title="2 二分查找框架"></a>2 二分查找框架</h2><p>注意循环不变量</p><h4 id="2-1-1-第一种："><a href="#2-1-1-第一种：" class="headerlink" title="2.1.1 第一种："></a>2.1.1 第一种：</h4><p>如果定义在一个左闭右闭的区间里，也就是[left,right];<br>循环结束条件： left &gt; right</p><p>[left, middle - 1]    [middle + 1, right]</p><p>right = mid - 1</p><p>left = mid + 1</p><h4 id="2-1-2-第二种：在一个在左闭右开的区间里，也就是-left-right"><a href="#2-1-2-第二种：在一个在左闭右开的区间里，也就是-left-right" class="headerlink" title="2.1.2 第二种：在一个在左闭右开的区间里，也就是[left, right)"></a>2.1.2 第二种：在一个在左闭右开的区间里，也就是[left, right)</h4><p>循环结束条件： left &lt; right</p><p>[left, middle)    [middle+1, right)</p><p>right  = mid</p><p>left = mid + 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;  <span class="comment">//防止直接相加出现溢出的情况</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-寻找一个数"><a href="#3-寻找一个数" class="headerlink" title="3 寻找一个数"></a>3 寻找一个数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; </span><br><span class="line">    <span class="comment">//循环跳出时，left = right + 1，搜索区间为[right+1,right],也就是说right取到了，right+1没有取到</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;   <span class="comment">//因为right是可以取到的，所以要有=号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">//因为mid是判断过的，所以可以跳过</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-寻找左侧边界的二分搜索"><a href="#4-寻找左侧边界的二分搜索" class="headerlink" title="4 寻找左侧边界的二分搜索"></a>4 寻找左侧边界的二分搜索</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length; <span class="comment">// 右侧是取不到的，[left,right)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 中止时left==right，但是不是闭区间，可以跳出</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;  </span><br><span class="line">            right = mid;<span class="comment">//找到target后，缩小上界，不断向左收缩</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;  <span class="comment">//[left,mid) [mid+1,right)</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果找不到目标值</span></span><br><span class="line"><span class="comment">// target 比所有数都大</span></span><br><span class="line"><span class="keyword">if</span> (left == nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="5-寻找右侧边界的二分搜索"><a href="#5-寻找右侧边界的二分搜索" class="headerlink" title="5 寻找右侧边界的二分搜索"></a>5 寻找右侧边界的二分搜索</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;  <span class="comment">//[left,right)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;<span class="comment">//[left,mid) [mid+1,right),因为mid已经判断过，所以跳过</span></span><br><span class="line">            left = mid + <span class="number">1</span>;   <span class="comment">//如果找到，缩小下界，同时向右收缩</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;<span class="comment">//[left,mid) [mid+1,right)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>; <span class="comment">//因为更新的是left = mid + 1，所以 mid = left - 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-逻辑统一"><a href="#6-逻辑统一" class="headerlink" title="6 逻辑统一"></a>6 逻辑统一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本二分</span></span><br><span class="line">因为我们初始化 right = nums.length - <span class="number">1</span></span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right]</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">同时也决定了 left = mid+<span class="number">1</span> 和 right = mid-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">因为我们只需找到一个 target 的索引即可</span><br><span class="line">所以当 nums[mid] == target 时可以立即返回</span><br><span class="line">    </span><br><span class="line"><span class="comment">//左侧边界</span></span><br><span class="line">因为我们初始化 right = nums.length</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + <span class="number">1</span> 和 right = mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最左侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧右侧边界以锁定左侧边界</span><br><span class="line"></span><br><span class="line"><span class="comment">//右侧边界</span></span><br><span class="line">因为我们初始化 right = nums.length</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + <span class="number">1</span> 和 right = mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最右侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧左侧边界以锁定右侧边界</span><br><span class="line"></span><br><span class="line">又因为收紧左侧边界时必须 left = mid + <span class="number">1</span></span><br><span class="line">所以最后无论返回 left 还是 right，必须减一                 </span><br></pre></td></tr></table></figure><h3 id="6-1-合并为闭区间"><a href="#6-1-合并为闭区间" class="headerlink" title="6.1 合并为闭区间"></a>6.1 合并为闭区间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接返回</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定左侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后要检查 left 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定右侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后要检查 right 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-例题"><a href="#7-例题" class="headerlink" title="7 例题"></a>7 例题</h2><h3 id="7-1-69-x-的平方根"><a href="#7-1-69-x-的平方根" class="headerlink" title="7.1 69. x 的平方根"></a>7.1 <a href="https://leetcode-cn.com/problems/sqrtx/">69. x 的平方根</a></h3><p>实现 <code>int sqrt(int x)</code> 函数。</p><p>计算并返回 <em>x</em> 的平方根，其中 <em>x</em> 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在left &lt;= right的情况下，结束时 left = right + 1</span></span><br><span class="line"><span class="comment">//需要的是小的那个</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = x;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sqrt</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(sqrt == x/sqrt)&#123;</span><br><span class="line">                <span class="keyword">return</span> sqrt;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sqrt &gt; x/sqrt)&#123;</span><br><span class="line">                right = sqrt - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sqrt &lt; x/sqrt)&#123;</span><br><span class="line">                left = sqrt + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-744-寻找比目标字母大的最小字母"><a href="#7-2-744-寻找比目标字母大的最小字母" class="headerlink" title="7.2 744. 寻找比目标字母大的最小字母"></a>7.2 <a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">744. 寻找比目标字母大的最小字母</a></h3><p>给你一个排序后的字符列表 <code>letters</code> ，列表中只包含小写英文字母。另给出一个目标字母 <code>target</code>，请你寻找在这一有序列表里比目标字母大的最小字母。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">nextGreatestLetter</span><span class="params">(<span class="type">char</span>[] letters, <span class="type">char</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> letters.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span> ,high = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[mid] &lt;= target)&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(low &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span> letters[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> letters[low];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-540-有序数组中的单一元素"><a href="#7-3-540-有序数组中的单一元素" class="headerlink" title="7.3 540. 有序数组中的单一元素"></a>7.3 <a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">540. 有序数组中的单一元素</a></h3><p>给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果前面不包含单个的，那么偶数位置的数肯定是和后面一个相等</span></span><br><span class="line"><span class="comment">//如果相等，说明在后面 left = mid + 2</span></span><br><span class="line"><span class="comment">//如果不相等，说明在前面，right = mid</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNonDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//保证m是偶数</span></span><br><span class="line">            <span class="keyword">if</span>(mid % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                mid--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == nums[mid + <span class="number">1</span>])&#123;</span><br><span class="line">                left = mid + <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-278-第一个错误的版本"><a href="#7-4-278-第一个错误的版本" class="headerlink" title="7.4 278. 第一个错误的版本"></a>7.4 <a href="https://leetcode-cn.com/problems/first-bad-version/">278. 第一个错误的版本</a></h3><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">VersionControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>,right = n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid) == <span class="literal">false</span>)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-153-寻找旋转排序数组中的最小值"><a href="#7-5-153-寻找旋转排序数组中的最小值" class="headerlink" title="7.5 153. 寻找旋转排序数组中的最小值"></a>7.5 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。</p><p>请找出其中最小的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;<span class="comment">//左闭右闭区间，如果用右开区间则不方便判断右值 </span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;<span class="comment">//循环不变式，如果left == right，则循环结束 </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;<span class="comment">//地板除，mid更靠近left</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;<span class="comment">//中值 &gt; 右值，最小值在右半边，收缩左边界</span></span><br><span class="line">                left = mid + <span class="number">1</span>;<span class="comment">//因为中值 &gt; 右值，中值肯定不是最小值，左边界可以跨过mid </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;<span class="comment">//明确中值 &lt; 右值，最小值在左半边，收缩右边界 */ </span></span><br><span class="line">                right = mid;<span class="comment">//因为中值 &lt; 右值，中值也可能是最小值，右边界只能取到mid处 */ </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];<span class="comment">//循环结束，left == right，最小值输出nums[left]或nums[right]均可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-6-34-在排序数组中查找元素的第一个和最后一个位置"><a href="#7-6-34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="7.6 34. 在排序数组中查找元素的第一个和最后一个位置"></a>7.6 <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h3><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//寻找target的最左侧边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> binarySearch(nums,target);</span><br><span class="line">        <span class="comment">//寻找target+1的最左侧边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> binarySearch(nums,target+<span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(start == nums.length || nums[start] != target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start,Math.max(start,end)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//寻找左侧边界</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Algorithm] LinkedList</title>
      <link href="/2021/06/12/Algorithm/LinkedList/"/>
      <url>/2021/06/12/Algorithm/LinkedList/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="1-链表"><a href="#1-链表" class="headerlink" title="1 链表"></a>1 链表</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    SinglyListNode next;</span><br><span class="line">    SinglyListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-206-反转链表"><a href="#1-2-206-反转链表" class="headerlink" title="1.2 206. 反转链表 *"></a>1.2 <a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a> *</h3><p>题目：反转一个单链表</p><p>1.双指针迭代</p><p>从前向后反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// cur 是当前需要翻转的节点</span></span><br><span class="line">        <span class="comment">// pre 是 cur 的前一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head, pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录 cur 的下一个节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后 cur 是 null, pre 是新链表的 head</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.递归</p><p>从后往前反转</p><p>终止条件是当前节点或者下一个节点==null<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"><span class="comment">//递归终止条件是当前为空，或者下一个节点为空</span></span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// cur 从头到尾是不变的 都是指向最后递归结束时的</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">head.next.next = head;</span><br><span class="line"><span class="comment">//防止链表循环，需要将head.next设置为空</span></span><br><span class="line">head.next = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//每层递归函数都返回cur，也就是最后一个节点</span></span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverseList(<span class="number">5</span>) 中 head=<span class="number">5</span>，head.next=<span class="literal">null</span>，返回head=<span class="number">5</span></span><br><span class="line">reverseList(<span class="number">4</span>) cur = <span class="number">5</span>，head=<span class="number">4</span>，head.next=<span class="number">5</span></span><br><span class="line">reverseList(<span class="number">3</span>)</span><br><span class="line">reverseList(<span class="number">2</span>)</span><br><span class="line">reverseList(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><h3 id="1-3-92-反转链表-II"><a href="#1-3-92-反转链表-II" class="headerlink" title="1.3 92. 反转链表 II  *"></a>1.3 <a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a>  *</h3><p>题目：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line">时间复杂度：O(n)</span><br><span class="line">空间复杂度：O(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录第 N+1 个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">mark</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归到变成翻转前n 个节点</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> reverseN(head, right);</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = reverseBetween(head.next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归翻转从 root 开始,长度为 n 的链表</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverseN</span><span class="params">(ListNode root, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// basecase,只有一个节点,也就是第 n 个,返回它本身</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// mark 记录第 n 加一个,避免断链</span></span><br><span class="line">            mark = root.next;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reverseN(root.next, n - <span class="number">1</span>);</span><br><span class="line">        root.next.next = root;</span><br><span class="line">        <span class="comment">// root 是翻转后的最后一个,连上后面</span></span><br><span class="line">        root.next = mark;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代实现,头插法</span></span><br><span class="line">时间复杂度：O(n)</span><br><span class="line">空间复杂度：O(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要翻转的节点数</span></span><br><span class="line">        right = right - left;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// 移动到 left 左侧</span></span><br><span class="line">        <span class="keyword">while</span> (left-- &gt; <span class="number">1</span>) cur = cur.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> cur.next, b = a.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将中间的链表翻转,此时 cur 在前一段最后,a 在第一段最后,b 在最后一段开始</span></span><br><span class="line">        <span class="keyword">while</span> (right-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> b.next;</span><br><span class="line">            b.next = a;</span><br><span class="line">            a = b;</span><br><span class="line">            b = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将第二段开头连上第三段开头</span></span><br><span class="line">        cur.next.next = b;</span><br><span class="line">        <span class="comment">// 第一段末尾连上第二段末尾</span></span><br><span class="line">        cur.next = a;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-25-K-个一组翻转链表-important"><a href="#1-4-25-K-个一组翻转链表-important" class="headerlink" title="1.4 25. K 个一组翻转链表 important"></a>1.4 <a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a> important</h3><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//哑节点辅助反转</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyNode.next = head;</span><br><span class="line">        <span class="comment">//将从pre的下一个节点开始反转</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="comment">//当前已经反转完成的位置</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//需要进行反转的节点</span></span><br><span class="line">        ListNode next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//需要翻转len/k组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len/k; i++)&#123;</span><br><span class="line">            <span class="comment">//每组需要将k-1个节点头插法到pre后面</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; k-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                next = cur.next;</span><br><span class="line">                cur.next = next.next;</span><br><span class="line">                next.next = pre.next;</span><br><span class="line">                pre.next = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//一组反转完成后，重置pre和cur位置</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 区间 [a, b) 包含 k 个待反转元素</span></span><br><span class="line">        ListNode a, b;</span><br><span class="line">        a = b = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">// 不足 k 个，不需要反转，base case</span></span><br><span class="line">            <span class="keyword">if</span> (b == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">            b = b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 反转前 k 个元素</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverse(a, b);</span><br><span class="line">        <span class="comment">// 递归反转后续链表并连接起来</span></span><br><span class="line">        a.next = reverseKGroup(b, k);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 反转区间 [a, b) 的元素，注意是左闭右开 */</span></span><br><span class="line">    ListNode <span class="title function_">reverse</span><span class="params">(ListNode a, ListNode b)</span> &#123;</span><br><span class="line">        ListNode pre, cur, nxt;</span><br><span class="line">        pre = <span class="literal">null</span>;</span><br><span class="line">        cur = a;</span><br><span class="line">        nxt = a;</span><br><span class="line">        <span class="comment">// while 终止的条件改一下就行了</span></span><br><span class="line">        <span class="keyword">while</span> (cur != b) &#123;</span><br><span class="line">            nxt = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回反转后的头结点</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-83-删除排序链表中的重复元素"><a href="#1-5-83-删除排序链表中的重复元素" class="headerlink" title="1.5 83. 删除排序链表中的重复元素"></a>1.5 <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h3><p>题目：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>思路：从头到尾遍历，将结点的值与后面 的结点值比较，如果重复就跳过下一个结点指向之后的结点。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.next.val == current.val) &#123;</span><br><span class="line">            current.next = current.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-82-删除排序链表中的重复元素-II"><a href="#1-6-82-删除排序链表中的重复元素-II" class="headerlink" title="1.6 82. 删除排序链表中的重复元素 II"></a>1.6 <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h3><p>题目：给定一个排序链表，删除所有重复的元素，只保留没有重复出现的结点。</p><p>思路：<br>1.头节点也可能要删除，增加一个哑结点<br>2.双指针a，b；a指向dummy，b指向head，如果a.next！=b.next 那么ab都往前，如果相等则只移动b到不等为止，然后a.next=b.next;b=b.next</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">b</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(b!=<span class="literal">null</span> &amp;&amp; b.next!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//初始化的时a指向的是哑结点，所以比较逻辑应该是a的下一个节点和b的下一个节点</span></span><br><span class="line">            <span class="keyword">if</span>(a.next.val!=b.next.val) &#123;</span><br><span class="line">                a = a.next;</span><br><span class="line">                b = b.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果a、b指向的节点值相等，就不断移动b，直到a、b指向的值不相等 </span></span><br><span class="line">                <span class="keyword">while</span>(b!=<span class="literal">null</span> &amp;&amp; b.next!=<span class="literal">null</span> &amp;&amp; a.next.val==b.next.val) &#123;</span><br><span class="line">                    b = b.next;</span><br><span class="line">                &#125;</span><br><span class="line">                a.next = b.next;</span><br><span class="line">                b = b.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-从尾到头打印链表"><a href="#1-7-从尾到头打印链表" class="headerlink" title="1.7 从尾到头打印链表"></a>1.7 从尾到头打印链表</h3><p>题目：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p><p>思路：<br>1.递归</p><p>每层递归将值加入结果数组</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        recur(head);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[temp.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; res.length;i++)</span><br><span class="line">            res[i] = temp.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recur(head.next);</span><br><span class="line">    temp.add(head.val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.辅助栈</p><p>遍历链表，将结点值入栈，遍历完成后将栈中元素存入数组，实现倒序输出</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="type">Deque</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">           stack.add(head.val);</span><br><span class="line">           head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; res.length ;i++)&#123;</span><br><span class="line">            res[i] = stack.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-链表中的倒数第K个节点"><a href="#1-8-链表中的倒数第K个节点" class="headerlink" title="1.8 链表中的倒数第K个节点 *"></a>1.8 链表中的倒数第K个节点 *</h3><p>题目：输入一个链表，输出该链表中倒数第k个结点。</p><p>思路：双指针法，一个先走k步，另一个也开始走，直到</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;    </span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">b</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k ;i++)&#123;</span><br><span class="line">        b = b.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="literal">null</span>)&#123;</span><br><span class="line">        a = a.next;</span><br><span class="line">        b = b.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-9-19-删除链表的倒数第-N-个结点"><a href="#1-9-19-删除链表的倒数第-N-个结点" class="headerlink" title="1.9 19. 删除链表的倒数第 N 个结点"></a>1.9 <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目:给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 采用两个间隔为n的指针，同时向前移动。当快指针的下一个节点为最后一个节点时，要删除的节点就是慢指针的下一个节点。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 只有一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">        <span class="comment">// fast 先走 n 步,然后一起到最后,slow 指向删除的前一个位置</span></span><br><span class="line">        <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>) fast = fast.next;</span><br><span class="line">      <span class="comment">// 边界:如果有 n 个节点,删倒数第 n 个,也就是头结点</span></span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">null</span>) <span class="keyword">return</span> head.next;</span><br><span class="line">      <span class="comment">// 直到 fast 指向末尾,slow 指向待删除的前一个</span></span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-10-复杂链表的复制"><a href="#1-10-复杂链表的复制" class="headerlink" title="1.10 复杂链表的复制"></a>1.10 复杂链表的复制</h3><p>题目：请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><p>思路：先在原链路中复制，然后建立random连接，最后拆分</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; <span class="comment">//HashMap实现</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">//创建HashMap集合</span></span><br><span class="line">        Node cur=head;</span><br><span class="line">        <span class="comment">//复制结点值</span></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//存储put:</span></span><br><span class="line">            map.put(cur,<span class="keyword">new</span> <span class="title class_">Node</span>(cur.val)); <span class="comment">//顺序遍历，存储老结点和新结点(先存储新创建的结点值)</span></span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//复制结点指向</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//得到get:.value2,3</span></span><br><span class="line">            map.get(cur).next = map.get(cur.next); <span class="comment">//新结点next指向同旧结点的next指向</span></span><br><span class="line">            map.get(cur).random = map.get(cur.random); <span class="comment">//新结点random指向同旧结点的random指向</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;   </span><br><span class="line"><span class="comment">//返回复制的链表</span></span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-11-两个链表的第一个公共节点"><a href="#1-11-两个链表的第一个公共节点" class="headerlink" title="1.11 两个链表的第一个公共节点"></a>1.11 两个链表的第一个公共节点</h3><p>题目：输入两个链表，找出它们的第一个公共节点。</p><p>思路：两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。</p><p>这样，当它们相遇时，所指向的结点就是第一个公共结点。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nodeA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nodeB</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="keyword">while</span>(nodeA!=nodeB)&#123;</span><br><span class="line">            nodeA = nodeA==<span class="literal">null</span>?headB:nodeA.next;</span><br><span class="line">            nodeB = nodeB==<span class="literal">null</span>?headA:nodeB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodeA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-12-环型链表"><a href="#1-12-环型链表" class="headerlink" title="1.12 环型链表"></a>1.12 环型链表</h3><p>题目：给定一个链表，判断链表中是否有环。</p><p>思路：快慢指针</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">low</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span>( fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(low.equals(fast) )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            low = low.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-13-链表中环的入口结点"><a href="#1-13-链表中环的入口结点" class="headerlink" title="1.13 链表中环的入口结点"></a>1.13 <a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&amp;tqId=11208&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">链表中环的入口结点</a></h3><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/submissions/">https://leetcode-cn.com/problems/linked-list-cycle-ii/submissions/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快慢指针</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> &#123;</span><br><span class="line">    <span class="comment">// 设计双指针， 1. 边界都要判断下一个结点也是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="literal">null</span> || pHead.next == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> pHead, fast = pHead;</span><br><span class="line">    <span class="comment">// 2. 快以二倍速前进，慢正常操作</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slow != fast); <span class="comment">// 3. 相遇点</span></span><br><span class="line">    <span class="comment">// 4. fast从头继续和slow正常走</span></span><br><span class="line">    fast = pHead;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123; </span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 返回slow，毕竟二者走在一块</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-14-2-两数相加"><a href="#1-14-2-两数相加" class="headerlink" title="1.14 2. 两数相加  *"></a>1.14 <a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a>  *</h3><p>题目:给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>思路:用一个虚拟头结点 逐位相加,考虑进位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逐位相加,考虑进位</span></span><br><span class="line"><span class="comment">// 复杂度 时间:O(max(m,n));  空间:O(max(m,n))</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> l1 != <span class="literal">null</span> ? l1.val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> l2 != <span class="literal">null</span> ? l2.val : <span class="number">0</span>;</span><br><span class="line">            carry = a + b + carry;</span><br><span class="line">            temp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry % <span class="number">10</span>);</span><br><span class="line">            carry /= <span class="number">10</span>;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="literal">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">null</span>) l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>) temp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-15-445-两数相加-II"><a href="#1-15-445-两数相加-II" class="headerlink" title="1.15 445. 两数相加 II"></a>1.15 <a href="https://leetcode-cn.com/problems/add-two-numbers-ii/">445. 两数相加 II</a></h3><p>题目：给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>思路：两辅助栈</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack1.push(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack2.push(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">//标记是否进位</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>( !stack1.isEmpty() || !stack2.isEmpty() || carry!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> carry;</span><br><span class="line">            sum += stack1.isEmpty() ? <span class="number">0</span> : stack1.pop();</span><br><span class="line">            sum += stack2.isEmpty() ? <span class="number">0</span> : stack2.pop();</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">            node.next = head1.next;<span class="comment">//头插法</span></span><br><span class="line">            head1.next = node;</span><br><span class="line">            carry = sum/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-16-328-奇偶链表"><a href="#1-16-328-奇偶链表" class="headerlink" title="1.16 328. 奇偶链表"></a>1.16 <a href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a></h3><p>题目：给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>思路：三个指针，两个排序，一个标记偶数链表的头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">oddEvenList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">odd</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">even</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">evenHead</span> <span class="operator">=</span> even;</span><br><span class="line">        <span class="keyword">while</span>(even!= <span class="literal">null</span> &amp;&amp; even.next!= <span class="literal">null</span>)&#123;<span class="comment">//偶数在后面，如果偶数有，那么奇数也有</span></span><br><span class="line">            odd.next = odd.next.next;</span><br><span class="line">            odd = odd.next;</span><br><span class="line">            even.next = even.next.next;</span><br><span class="line">            even = even.next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd.next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-17-725-分隔链表"><a href="#1-17-725-分隔链表" class="headerlink" title="1.17 725. 分隔链表"></a>1.17 <a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">725. 分隔链表</a></h3><p>给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。</p><p>每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。</p><p>这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。</p><p>返回一个符合上述规则的链表的列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//链表长度</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            N++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每个部分的基础长度和余数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> N/k;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> N%k;</span><br><span class="line">        cur = root;</span><br><span class="line">        ListNode[] res = <span class="keyword">new</span> <span class="title class_">ListNode</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; cur != <span class="literal">null</span> &amp;&amp; i &lt; k ; i++)&#123;</span><br><span class="line">            <span class="comment">//表头加入</span></span><br><span class="line">            res[i] = cur;</span><br><span class="line">            <span class="comment">//当前的大小取决于基础大小和是否还有余数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">curSize</span> <span class="operator">=</span> size + (mod-- &gt; <span class="number">0</span> ? <span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//需要得到Cursize规模的链表，需要走Cursize - 1步</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; curSize - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//记录下下一个节点，断开链表</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = <span class="literal">null</span>;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-18-21-合并两个有序链表"><a href="#1-18-21-合并两个有序链表" class="headerlink" title="1.18 21. 合并两个有序链表 *"></a>1.18 <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a> *</h3><p>题目：将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p>递归解法：</p><p>终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束</p><p>返回值：每一层调用都返回排序好的链表头</p><p>本级递归内容：如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归  时间 O(n+m)  空间 O(n+m)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 迭代  时间 O(n+m)  空间 O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val)&#123;</span><br><span class="line">                pre.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = l1 == <span class="literal">null</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-19-23-合并K个升序链表"><a href="#1-19-23-合并K个升序链表" class="headerlink" title="1.19 23. 合并K个升序链表 *"></a>1.19 <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a> *</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小堆</span></span><br><span class="line"><span class="comment">// 时间: O(kn×logk)  k 个链表,kn 个点</span></span><br><span class="line"><span class="comment">// 空间: O(k)</span></span><br><span class="line"><span class="comment">// 堆排序,使用大顶堆可以得到升序的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="comment">// 哨兵节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), tail = dummy;</span><br><span class="line">        <span class="comment">//优先队列，每次出堆的都是最小的  小顶堆,输出根节点</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a.val - b.val);</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        <span class="keyword">for</span>(ListNode node : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>) q.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">            tail.next = q.poll();</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            <span class="keyword">if</span>(tail.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.add(tail.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分治实现</span></span><br><span class="line"><span class="comment">// 时间 O(kn×logk)</span></span><br><span class="line"><span class="comment">// 空间 O(logk)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lists == <span class="literal">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//分治实现两两合并</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode[] lists, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span> lists[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> merge(lists, left, mid);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> merge(lists, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//合并两个有序</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-20-234-回文链表-important"><a href="#1-20-234-回文链表-important" class="headerlink" title="1.20 234. 回文链表 important"></a>1.20 <a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a> important</h3><p>请判断一个链表是否为回文链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//只有一个或者两个</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head,fast = head.next;</span><br><span class="line">        <span class="comment">//找出中点</span></span><br><span class="line">        <span class="keyword">while</span>(fast!= <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//考虑只有两个元素的情况</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="literal">null</span>) slow = slow.next;</span><br><span class="line">        cut(head,slow);</span><br><span class="line">        <span class="keyword">return</span> isequal(head,reverse(slow));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//断开链表，断在slow前</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">(ListNode head,ListNode slow)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head.next != slow)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转链表</span></span><br><span class="line">    <span class="keyword">private</span>  ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reverse(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否相等</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isequal</span><span class="params">(ListNode l1,ListNode l2)</span>&#123;</span><br><span class="line">        <span class="comment">//忽略奇数个节点情况</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val != l2.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                l2 = l2.next;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-21-86-分隔链表-important"><a href="#1-21-86-分隔链表-important" class="headerlink" title="1.21 86. 分隔链表  important"></a>1.21 <a href="https://leetcode-cn.com/problems/partition-list/">86. 分隔链表</a>  important</h3><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p><p>你应当 保留 两个分区中每个节点的初始相对位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> dummy1, node2 = dummy2;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val &lt; x)&#123;</span><br><span class="line">                node1.next = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">                <span class="comment">//断开与主链表的联系</span></span><br><span class="line">                node1.next = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node2.next = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">                node2.next = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node1.next = dummy2.next;</span><br><span class="line">        <span class="keyword">return</span> dummy1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-22-剑指46-圆圈中最后剩下的数"><a href="#1-22-剑指46-圆圈中最后剩下的数" class="headerlink" title="1.22 剑指46.圆圈中最后剩下的数"></a>1.22 剑指46.圆圈中最后剩下的数</h3><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) </p><p>如果没有小朋友，请返回-1 </p><p>思路：</p><p>使用List模拟，使用一个指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">LastRemaining_Solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || m == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) list.add(i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(list.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">                cur++;</span><br><span class="line">                <span class="keyword">if</span>(cur == list.size()) cur = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.remove(cur);</span><br><span class="line">            <span class="comment">//删除节点时，cur会指向下一个节点，因此需要减1。</span></span><br><span class="line">            cur--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-23-853-链表的中间结点-important"><a href="#1-23-853-链表的中间结点-important" class="headerlink" title="1.23 853.链表的中间结点  important"></a>1.23 853.链表的中间结点  important</h3><p><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">https://leetcode-cn.com/problems/middle-of-the-linked-list/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双指针（快慢）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head, q = head;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="literal">null</span> &amp;&amp; q.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            q = q.next.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-24-24-两两交换链表中的节点"><a href="#1-24-24-两两交换链表中的节点" class="headerlink" title="1.24 24. 两两交换链表中的节点 *"></a>1.24 <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a> *</h3><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="comment">// temp -&gt; start -&gt; end</span></span><br><span class="line">        <span class="comment">// temp 是要交换的两个的前一个</span></span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="literal">null</span> &amp;&amp; temp.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> temp.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> temp.next.next;</span><br><span class="line">            temp.next = end;</span><br><span class="line">            start.next = end.next;</span><br><span class="line">            end.next = start;</span><br><span class="line">            <span class="comment">// 交换完成,此时 start 后面是需要交换的</span></span><br><span class="line">            temp = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 递归解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前无节点或者只有一个节点，无法进行交换</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// head -&gt; next -&gt; (next.next)</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = swapPairs(next.next);</span><br><span class="line">        next.next = head;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-25-奇数位升序偶数位降序的链表-important"><a href="#1-25-奇数位升序偶数位降序的链表-important" class="headerlink" title="1.25 奇数位升序偶数位降序的链表  important"></a>1.25 奇数位升序偶数位降序的链表  important</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">oddEvenLinkedList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 将偶数链表拆分出来</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">evenHead</span> <span class="operator">=</span> getEvenList(head);</span><br><span class="line">    <span class="comment">// 逆序偶数链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">reEvenHead</span> <span class="operator">=</span> reverseList(evenHead);</span><br><span class="line">    <span class="comment">// 归并奇偶链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">mHead</span> <span class="operator">=</span> mergeList(head, reEvenHead);</span><br><span class="line">    <span class="keyword">return</span> mHead;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">getEvenList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">evenHead</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取next</span></span><br><span class="line">        next = cur.next;</span><br><span class="line">        <span class="comment">// cur奇数，-&gt; next.next (奇数)</span></span><br><span class="line">        cur.next = next.next;</span><br><span class="line">        <span class="comment">// 移动</span></span><br><span class="line">        cur = cur.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始偶数</span></span><br><span class="line">        next.next = cur.next;</span><br><span class="line">        <span class="comment">// 移动</span></span><br><span class="line">        next = next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> evenHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">mergeList</span><span class="params">(ListNode l1, ListNode l2)</span>&#123;</span><br><span class="line">    <span class="comment">// 我用递归</span></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeList(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeList(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Algorithm] Sort</title>
      <link href="/2021/06/12/Algorithm/Sort/"/>
      <url>/2021/06/12/Algorithm/Sort/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="排序算法的比较"><a href="#排序算法的比较" class="headerlink" title="排序算法的比较"></a>排序算法的比较</h2><div class="table-container"><table><thead><tr><th><strong>算法</strong></th><th><strong>稳定性</strong></th><th><strong>时间复杂度</strong></th><th><strong>空间复杂度</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>选择排序</td><td>×</td><td>N2</td><td>1</td><td></td></tr><tr><td>冒泡排序</td><td>√</td><td>N2</td><td>1</td><td></td></tr><tr><td>插入排序</td><td>√</td><td>N ~ N2</td><td>1</td><td>时间复杂度和初始顺序有关</td></tr><tr><td>希尔排序</td><td>×</td><td>N的若干倍乘于递增序列的长度</td><td>1</td><td>改进版插入排序</td></tr><tr><td>快速排序</td><td>×</td><td>NlogN</td><td>logN</td><td></td></tr><tr><td>三向切分快速排序</td><td>×</td><td>N ~ NlogN</td><td>logN</td><td>适用于有大量重复主键</td></tr><tr><td>归并排序</td><td>√</td><td>NlogN</td><td>N</td><td></td></tr><tr><td>堆排序</td><td>×</td><td>NlogN</td><td>1</td><td>无法利用局部性原理</td></tr></tbody></table></div><p>快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 ~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。</p><p>使用三向切分快速排序，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。</p><p>取 a[l] 作为切分元素，从数组的左端向右扫描直到找到第一个大于等于它的元素，再从数组的右端向左扫描找到第一个小于它的元素，交换这两个元素。不断进行这个过程，就可以保证左指针 i 的左侧元素都不大于切分元素，右指针 j 的右侧元素都不小于切分元素。当两个指针相遇时，将切分元素 a[l] 和 a[j] 交换位置。</p><p>为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 快速排序主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quicksort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span></span><br><span class="line">    <span class="comment">// 选择枢纽元素</span></span><br><span class="line">    pivot := arr[<span class="built_in">len</span>(arr)/<span class="number">2</span>]</span><br><span class="line">    <span class="comment">// 分区过程</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        <span class="keyword">for</span> arr[left] &lt; pivot &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> arr[right] &gt; pivot &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left &lt;= right &#123;</span><br><span class="line">            arr[left], arr[right] = arr[right], arr[left]</span><br><span class="line">            left++</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归排序左右两部分</span></span><br><span class="line">    <span class="keyword">if</span> right &gt; <span class="number">0</span> &#123;</span><br><span class="line">        quicksort(arr[:right+<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> left &lt; <span class="built_in">len</span>(arr) &#123;</span><br><span class="line">        quicksort(arr[left:])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Unsorted array:&quot;</span>, data)</span><br><span class="line">    quicksort(data)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Sorted array:&quot;</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> <span class="keyword">extends</span> <span class="title class_">Sort</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(Integer[] nums, <span class="type">int</span> l, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = h+<span class="number">1</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">v</span> <span class="operator">=</span> nums[l];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">     <span class="comment">//从左侧向右扫描找到第一个大于等于基准的，再从数组的右端向左扫描找到第一个小于它的元素，交换这两个元素。</span></span><br><span class="line">            <span class="keyword">while</span> (less(nums[++i],v) &amp;&amp; i != h);</span><br><span class="line">            <span class="keyword">while</span> (less(v,nums[--j]) &amp;&amp; j != l);</span><br><span class="line">            <span class="comment">//当两个指针相遇，结束循环</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; i) <span class="keyword">break</span>;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,l,j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(Integer[] nums)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(nums);</span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        list.toArray(nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">        shuffle(nums);</span><br><span class="line">        sort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums, <span class="type">int</span> l, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= h) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> partition(nums, l, h);</span><br><span class="line">        sort(nums, l, j);</span><br><span class="line">        sort(nums, j+<span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(Integer v, Integer w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v &lt; w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Integer[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于切分的快速选择算法（TopK）"><a href="#基于切分的快速选择算法（TopK）" class="headerlink" title="基于切分的快速选择算法（TopK）"></a>基于切分的快速选择算法（TopK）</h3><p>快速排序的partition()方法，会返回一个索引j，j前面的都小于a[j],后面的都大于，也即是返回第j大的元素</p><p>可以据此找出第k大元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> partition(nums,low,high);</span><br><span class="line">        <span class="keyword">if</span>(j == k) <span class="keyword">return</span> nums[k];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; k)&#123;</span><br><span class="line">            high = j - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">low = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三向切分"><a href="#三向切分" class="headerlink" title="三向切分"></a>三向切分</h3><p>对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。</p><p>三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序。</p><p>Java 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeWayQuickSort</span> <span class="keyword">extends</span> <span class="title class_">QuickSort</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums, <span class="type">int</span> l, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=h) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lt</span> <span class="operator">=</span> l, i = l+<span class="number">1</span>, gt = h;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">v</span> <span class="operator">=</span> nums[l];</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=gt)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> nums[i] - v;</span><br><span class="line">            <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums, lt++, i++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums, i, gt--);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums, l, lt-<span class="number">1</span>);</span><br><span class="line">        sort(nums, gt+<span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>对子数组进行划分，如果划分得到的 q 正好就是我们需要的下标，就直接返回 a[q]；否则，如果 q 比目标下标小，就递归右子区间，否则递归左子区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 转换一下，第 k 大元素的索引是 len - k</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> len - k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (index == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[index];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; target) &#123;</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                swap(nums, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, j, left);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择最小的元素，然后和第一个交换，然后从剩下的元素选最小的和第二个交换，直到将整个数组排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Selection</span> <span class="keyword">extends</span> <span class="title class_">Sort</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; n; j++)&#123;<span class="comment">//从剩下的元素中选出最小的元素</span></span><br><span class="line">                <span class="keyword">if</span>(less(nums[j], nums[min]))&#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, min);<span class="comment">//和最小的交换位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Integer[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(Integer v, Integer w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v &lt; w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆中某个节点的值总是大于等于其子节点的值，并且堆是一颗完全二叉树。</p><p>位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。</p><p>大根堆： 根节点大于叶子节点  根节点是最大的   根据大根堆可以得到几个最小的</p><p>小根堆： 根节点是最小的，输出根节点就是输出最小的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T[] heap;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span> maxN)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.heap = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[maxN + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> heap[i].compareTo(heap[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> heap[i];</span><br><span class="line">        heap[i] = heap[j];</span><br><span class="line">        heap[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上浮和下沉"><a href="#上浮和下沉" class="headerlink" title="上浮和下沉"></a>上浮和下沉</h3><p>在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k / <span class="number">2</span>, k)) &#123;</span><br><span class="line">        swap(k / <span class="number">2</span>, k);</span><br><span class="line">        k = k / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，应当与两个子节点中最大那个节点进行交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * k;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; N &amp;&amp; less(j, j + <span class="number">1</span>))</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (!less(k, j))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>将新元素放到数组末尾，然后上浮到合适的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Comparable v)</span> &#123;</span><br><span class="line">    heap[++N] = v;</span><br><span class="line">    swim(N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除最大元素"><a href="#删除最大元素" class="headerlink" title="删除最大元素"></a>删除最大元素</h3><p>从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> heap[<span class="number">1</span>];</span><br><span class="line">    swap(<span class="number">1</span>, N--);</span><br><span class="line">    heap[N + <span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line">    sink(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p>把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序。</p><p>从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。</p><p>交换堆顶元素与最后一个元素</p><p>交换之后需要进行下沉操作维持堆的有序状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; <span class="keyword">extends</span> <span class="title class_">Sort</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组第 0 个位置不能有元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">            sink(nums, k, N);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            swap(nums, <span class="number">1</span>, N--);</span><br><span class="line">            sink(nums, <span class="number">1</span>, N);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(T[] nums, <span class="type">int</span> k, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; N &amp;&amp; less(nums, j, j + <span class="number">1</span>))</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span> (!less(nums, k, j))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(nums, k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(T[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i].compareTo(nums[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bubble</span> <span class="keyword">extends</span> <span class="title class_">Sort</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>; i &gt; <span class="number">0</span> &amp;&amp; flag; i--)&#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(less(nums[j+<span class="number">1</span>],nums[j]))&#123;</span><br><span class="line">                    swap(nums,j,j+<span class="number">1</span>);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。</p><p>插入排序每次只能交换相邻元素，令逆序数量减少 1，因此插入排序需要交换的次数为逆序数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Insertion</span> <span class="keyword">extends</span> <span class="title class_">Sort</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span> &amp;&amp; less(nums[j],nums[j-<span class="number">1</span>]); j--)&#123;</span><br><span class="line">                swap(nums,j,j-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>插入排序的优化</p><p>通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p><p>使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shell</span> <span class="keyword">extends</span> <span class="title class_">Sort</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; n/<span class="number">3</span>)&#123;</span><br><span class="line">            h = <span class="number">3</span>*h + <span class="number">1</span>;<span class="comment">//1,4,9,13</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span> &amp;&amp; less(nums[j],nums[j-h]); j -= h)&#123;</span><br><span class="line">                    swap(nums,j,j-h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并算法"><a href="#归并算法" class="headerlink" title="归并算法"></a>归并算法</h2><p>将数组分成两部分，分别进行排序，然后归并起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> <span class="keyword">extends</span> <span class="title class_">Sort</span> &#123;</span><br><span class="line">    <span class="comment">//合并时，需要辅助数组，空间复杂度为 O(N)</span></span><br><span class="line">    <span class="keyword">private</span> Integer[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并方法：将数组中两个已经排序的部分归并成一个。</span></span><br><span class="line">    <span class="comment">//l需要合并的数组左端，m中点，h需要合并的数组右端</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Integer[] nums, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= h; k++)&#123;</span><br><span class="line">            aux[k] = nums[k];<span class="comment">//将数据复制到辅助数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= h; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; m)&#123;</span><br><span class="line">                nums[k] = aux[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; h)&#123;</span><br><span class="line">                nums[k] = aux[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aux[i]&lt;=aux[j])&#123;</span><br><span class="line">                nums[k] = aux[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k] = aux[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个大数组分成两个小数组去求解。</span></span><br><span class="line">    <span class="comment">//因为每次都将问题对半分成两个子问题，这种对半分的算法复杂度一般为 O(NlogN)。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="title class_">Integer</span>[nums.length];</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums, <span class="type">int</span> l, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(h&lt;=l)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (h - l)/<span class="number">2</span>;</span><br><span class="line">        sort(nums, l, mid);</span><br><span class="line">        sort(nums, mid+<span class="number">1</span>, h);</span><br><span class="line">        merge(nums, l, mid, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指35-数组的逆序对"><a href="#剑指35-数组的逆序对" class="headerlink" title="剑指35.数组的逆序对"></a>剑指35.数组的逆序对</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p><p>在两个子序列left、right合并过程中，当left中当前元素A大于right中当前元素B时，因为left序列已经有序，所以A后面所有元素都可以与B组成逆序对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] aux;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">InversePairs</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="title class_">int</span>[array.length];</span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= h; k++)&#123;</span><br><span class="line">            aux[k] = array[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= h; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; m)&#123;</span><br><span class="line">                array[k] = aux[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; h)&#123;</span><br><span class="line">                array[k] = aux[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aux[i] &lt;= aux[j])&#123;</span><br><span class="line">                array[k] = aux[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                array[k] = aux[j++];</span><br><span class="line">                count = (count + m + <span class="number">1</span> - i)%<span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> l, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=h) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (h-l)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(array,l,m);</span><br><span class="line">        mergeSort(array,m+<span class="number">1</span>,h);</span><br><span class="line">        merge(array,l,m,h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Algorithm] String</title>
      <link href="/2021/06/12/Algorithm/String/"/>
      <url>/2021/06/12/Algorithm/String/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="0-1-字符串常用方法"><a href="#0-1-字符串常用方法" class="headerlink" title="0.1 字符串常用方法"></a>0.1 字符串常用方法</h3><ul><li>不必考虑到线程同步问题，我们应该优先使用StringBuilder类；如果要保证线程安全，自然是StringBuffer。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String的方法</span></span><br><span class="line"><span class="type">char</span>  <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span> <span class="comment">//返回指定索引处的值</span></span><br><span class="line">String  <span class="title function_">concat</span><span class="params">(String str)</span>  <span class="comment">//将指定的字符串连接到该字符串的末尾</span></span><br><span class="line"><span class="type">boolean</span>   <span class="title function_">contentEquals</span><span class="params">(StringBuffer sb)</span>  <span class="comment">//将此字符串与指定的StringBuffer进行比较</span></span><br><span class="line"><span class="type">int</span>   <span class="title function_">indexOf</span><span class="params">(<span class="type">int</span> ch)</span>  <span class="comment">//返回指定字符第一次出现的字符串内的索引</span></span><br><span class="line"><span class="type">int</span>   <span class="title function_">indexOf</span><span class="params">(String str)</span>  <span class="comment">//返回指定子字符串第一次出现的字符串内的索引</span></span><br><span class="line"><span class="type">boolean</span>  <span class="title function_">isEmpty</span><span class="params">()</span> </span><br><span class="line"><span class="type">int</span>  <span class="title function_">length</span><span class="params">()</span></span><br><span class="line">String   <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span>  <span class="comment">//将 int 变量 i 转换成字符串(使用于其他数据类型)</span></span><br><span class="line">String[]  split(String regex)  <span class="comment">//按regex将String切分成数组</span></span><br><span class="line"><span class="type">char</span>[]   toCharArray()  <span class="comment">//将此字符串转换为新的字符数组</span></span><br><span class="line">String   <span class="title function_">trim</span><span class="params">()</span>  <span class="comment">//删除前后的空格</span></span><br><span class="line">String    <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span>  <span class="comment">//获得子串，是左闭右开区间</span></span><br><span class="line">  </span><br><span class="line">StringBuffer  方法</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="number">50</span>);  <span class="comment">// 容量为50</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot; World&quot;</span>);  <span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line">sb.insert(<span class="number">5</span>, <span class="string">&quot; Java&quot;</span>);  <span class="comment">// &quot;Hello Java World&quot;</span></span><br><span class="line">sb.replace(<span class="number">6</span>, <span class="number">10</span>, <span class="string">&quot;Beautiful&quot;</span>);  <span class="comment">// &quot;Hello Beautiful World&quot;</span></span><br><span class="line">sb.delete(<span class="number">6</span>, <span class="number">15</span>);  <span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line">sb.deleteCharAt(<span class="number">5</span>);  <span class="comment">// &quot;HelloWorld&quot;</span></span><br><span class="line">sb.reverse();  <span class="comment">// &quot;dlroWolleH&quot;</span></span><br><span class="line">sb.setCharAt(<span class="number">0</span>, <span class="string">&#x27;h&#x27;</span>);  <span class="comment">// &quot;helloWorld&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> sb.substring(<span class="number">5</span>);  <span class="comment">// &quot;World&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> sb.substring(<span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sb.length();  <span class="comment">// 10</span></span><br><span class="line">res.toString()   <span class="comment">//转换成string</span></span><br></pre></td></tr></table></figure><h3 id="0-2-剑指-Offer-58-I-翻转单词顺序"><a href="#0-2-剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="0.2 剑指 Offer 58 - I. 翻转单词顺序"></a>0.2 <a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a></h3><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//split()将字符串按空格分割，倒序遍历，将单词拼接到StringBuilder，去空格后返回</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        String[] strs = s.trim().split(<span class="string">&quot; &quot;</span>); <span class="comment">// 删除首尾空格，分割字符串</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> strs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒序遍历单词列表</span></span><br><span class="line">            <span class="keyword">if</span>(strs[i].equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">continue</span>; <span class="comment">// 遇到空单词则跳过</span></span><br><span class="line">            res.append(strs[i] + <span class="string">&quot; &quot;</span>); <span class="comment">// 将单词拼接至 StringBuilder</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim(); <span class="comment">// 转化为字符串，删除尾部空格，并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//倒序，逐个确定每个单词的边界</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        s = s.trim(); <span class="comment">// 删除首尾空格</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, i = j;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != <span class="string">&#x27; &#x27;</span>) i--; <span class="comment">// 搜索首个空格</span></span><br><span class="line">            res.append(s.substring(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="string">&quot; &quot;</span>); <span class="comment">// 添加单词</span></span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27; &#x27;</span>) i--; <span class="comment">// 跳过单词间空格</span></span><br><span class="line">            j = i; <span class="comment">// j 指向下个单词的尾字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim(); <span class="comment">// 转化为字符串并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-3-409-最长回文串"><a href="#0-3-409-最长回文串" class="headerlink" title="0.3 409. 最长回文串"></a>0.3 <a href="https://leetcode-cn.com/problems/longest-palindrome/">409. 最长回文串</a></h3><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计每个字符的个数</span></span><br><span class="line"><span class="comment">//每对字符都可以组成回文串，因为中间的可以是单个，如果还有剩余的单个，可以加一个上去</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; s.length() ; i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            map.put(c, map.getOrDefault(c,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: map.keySet())&#123;</span><br><span class="line">            res += (map.get(c) / <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res &lt; s.length())&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用数组统计</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            cnt[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : cnt)&#123;</span><br><span class="line">            result += (i/<span class="number">2</span>)*<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(result &lt; s.length())&#123;</span><br><span class="line">            result++;<span class="comment">//这种情况有单独的字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-4-205-同构字符串"><a href="#0-4-205-同构字符串" class="headerlink" title="0.4 205. 同构字符串"></a>0.4 <a href="https://leetcode-cn.com/problems/isomorphic-strings/">205. 同构字符串</a></h3><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p><p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p><p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录一个字符上次出现的位置，如果两个字符串中上次出现的位置一样，那么就是同构</span></span><br><span class="line"><span class="comment">//如 egg add g上次出现在2，d也上次出现在2，那么它们就是同构的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIsomorphic</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] indexOft = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="type">int</span>[] indexOfs = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">cs</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="type">char</span> <span class="variable">ct</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(indexOfs[cs] != indexOft[ct])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//防止一开始放进去的是0，无法区分</span></span><br><span class="line">            indexOfs[cs] = i + <span class="number">1</span>;</span><br><span class="line">            indexOft[ct] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-5-647-回文子串"><a href="#0-5-647-回文子串" class="headerlink" title="0.5 647. 回文子串"></a>0.5 <a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a></h3><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 中心扩展法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//可以从一个字符向两侧扩展，也可以从两个相邻字符开始扩展，这样可以覆盖所有可能的子串</span></span><br><span class="line">        <span class="comment">//这样的单个字符有n个，两个有n-1个，所以合计有2n-1个中心点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> <span class="number">0</span>; center &lt; <span class="number">2</span> * s.length() - <span class="number">1</span>; center++) &#123;</span><br><span class="line">            <span class="comment">// left和right指针和中心点的关系是？</span></span><br><span class="line">            <span class="comment">// 首先是left，有一个很明显的2倍关系的存在，其次是right，可能和left指向同一个（偶数时），也可能往后移动一个（奇数）</span></span><br><span class="line">            <span class="comment">// 大致的关系出来了，可以选择带两个特殊例子进去看看是否满足。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> center / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + center % <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//在字符串范围内向两侧拓展</span></span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-6-696-计数二进制子串"><a href="#0-6-696-计数二进制子串" class="headerlink" title="0.6 696. 计数二进制子串"></a>0.6 <a href="https://leetcode-cn.com/problems/count-binary-substrings/">696. 计数二进制子串</a></h3><p>给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计相同连续数字的个数，取其中的较小</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countBinarySubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//统计当前数字连续的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curCnt</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//记录上一个数字连续的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//如果和前一个一样，当前连续个数++</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == s.charAt(i-<span class="number">1</span>))&#123;</span><br><span class="line">                curCnt++;</span><br><span class="line">            <span class="comment">//否则，记录下，作为前一个连续数字个数，然后重置当前</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                preCnt = curCnt;</span><br><span class="line">                curCnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//前一个数连续的个数大于当前，那么就多一种子串</span></span><br><span class="line">            <span class="keyword">if</span>(preCnt &gt;= curCnt)&#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-7-剑指-Offer-19-正则表达式匹配"><a href="#0-7-剑指-Offer-19-正则表达式匹配" class="headerlink" title="0.7 剑指 Offer 19. 正则表达式匹配"></a>0.7 <a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配</a></h3><p>请实现一个函数用来匹配包含’. ‘和’/<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&#x27;.&#x27;可以表示任意一个字符</span></span><br><span class="line"><span class="comment">//&#x27;*&#x27;表示前面的字符可以出现任意次</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有三种情况：</span></span><br><span class="line"><span class="comment">1.B的最后一个是正常字符，那么比较AB最后一个，相等则往前一位</span></span><br><span class="line"><span class="comment">2.B的最后是&#x27;.&#x27;，可以直接往前一位</span></span><br><span class="line"><span class="comment">3.B的最后是&#x27;*&#x27;，代表B的倒数第二个可以重复一次，或者多次</span></span><br><span class="line"><span class="comment">如果A的最后匹配失败，那么B往前两位</span></span><br><span class="line"><span class="comment">如果匹配成功，那么A匹配完往前，B继续</span></span><br><span class="line"><span class="comment">f[i][j] 代表 A 的前 i 个和 B 的前 j 个能否匹配</span></span><br><span class="line"><span class="comment">对于前面两个情况，可以合并成一种情况 f[i][j] = f[i-1][j-1]</span></span><br><span class="line"><span class="comment">对于第三种情况，对于 c*c∗ 分为看和不看两种情况</span></span><br><span class="line"><span class="comment">不看：直接砍掉正则串的后面两个， f[i][j] = f[i][j-2]</span></span><br><span class="line"><span class="comment">看：正则串不动，主串前移一个，f[i][j] = f[i-1][j] </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> p.length();</span><br><span class="line">        <span class="type">boolean</span>[][] f = <span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n ; i++ )&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="comment">//如果j=0，那么只有i也是0的情况匹配成功</span></span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>) f[i][j] = i == <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果p最后一位不是&#x27;*&#x27;</span></span><br><span class="line">                    <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">//如果相等，或者p的最后是&#x27;.&#x27;，那么都向前</span></span><br><span class="line">                        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>) || p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>))&#123;</span><br><span class="line">                            f[i][j] = f[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//碰到&#x27;*&#x27;</span></span><br><span class="line">                        <span class="comment">//不看，能否匹配取决于B串砍两位后能否匹配成功</span></span><br><span class="line">                        <span class="keyword">if</span>(j &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                            <span class="comment">//只要有一个成立就都成立</span></span><br><span class="line">                            f[i][j] |= f[i][j-<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"><span class="comment">//看，正则串不动，主串前移</span></span><br><span class="line">                        <span class="keyword">if</span>(i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">2</span>) || p.charAt(j-<span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>))&#123;</span><br><span class="line">                            f[i][j] |= f[i-<span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-8-剑指-Offer-48-最长不含重复字符的子字符串"><a href="#0-8-剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="0.8 剑指 Offer 48. 最长不含重复字符的子字符串"></a>0.8 <a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h3><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//滑动窗口实现</span></span><br><span class="line"><span class="comment">//维护一个left，表示窗口的最左侧</span></span><br><span class="line"><span class="comment">//维护一个HashMap，记录窗口内的元素和位置</span></span><br><span class="line"><span class="comment">//当加入了一个当前窗口内已有的值，直接通过HashMap获取位置，重置left</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i ++)&#123;</span><br><span class="line">            <span class="comment">//如果这个元素出现过</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                <span class="comment">//如果在窗口内，left跳转到它的下一个</span></span><br><span class="line">                left = Math.max(left,map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//放入当前</span></span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">            <span class="comment">//计算当前窗口值是否最大</span></span><br><span class="line">            max = Math.max(max,i-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-9-剑指-Offer-67-把字符串转换成整数"><a href="#0-9-剑指-Offer-67-把字符串转换成整数" class="headerlink" title="0.9 剑指 Offer 67. 把字符串转换成整数"></a>0.9 <a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">剑指 Offer 67. 把字符串转换成整数</a></h3><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strToInt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">//去除两端空格</span></span><br><span class="line">        str = str.trim();</span><br><span class="line">        <span class="comment">//判空</span></span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>  <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//标记是否为负</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//记录当前所指字符位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span>) flag = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//有符号，前进一位</span></span><br><span class="line">        <span class="keyword">if</span> (str.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span> || str.charAt(<span class="number">0</span>) == <span class="string">&#x27;+&#x27;</span>) i++;</span><br><span class="line">        <span class="comment">//如果是数字，循环继续 </span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; str.length() &amp;&amp; isNum(str.charAt(i)))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> str.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">//判断在加上之后是否会越界</span></span><br><span class="line">            <span class="keyword">if</span> ((res &gt; Integer.MAX_VALUE/<span class="number">10</span>) || (res == Integer.MAX_VALUE/<span class="number">10</span> &amp;&amp; r &gt; <span class="number">7</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> flag &gt; <span class="number">0</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res *<span class="number">10</span> + r;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag&gt;<span class="number">0</span>? res:-res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是不是数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isNum</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c - <span class="string">&#x27;0&#x27;</span> &gt;=<span class="number">0</span> &amp;&amp; c - <span class="string">&#x27;9&#x27;</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-10-剑指-Offer-44-数字序列中某一位的数字"><a href="#0-10-剑指-Offer-44-数字序列中某一位的数字" class="headerlink" title="0.10 剑指 Offer 44. 数字序列中某一位的数字"></a>0.10 <a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">剑指 Offer 44. 数字序列中某一位的数字</a></h3><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//特殊情况</span></span><br><span class="line">       <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(n&gt;=<span class="number">0</span> &amp;&amp; n&lt;=<span class="number">9</span>) <span class="keyword">return</span> n; </span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//防止越界</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> n;</span><br><span class="line">   <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">           <span class="comment">//当前数字的长度</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">           <span class="comment">//当前数字的个数</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">   <span class="type">char</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           <span class="comment">//当前占的位数，循环到包含第n位数字</span></span><br><span class="line">   <span class="keyword">while</span>((temp+base*num) &lt; m) &#123;</span><br><span class="line">               <span class="comment">//长度</span></span><br><span class="line">   temp += base*num;</span><br><span class="line">               <span class="comment">//数字长度加一</span></span><br><span class="line">   base += <span class="number">1</span>;</span><br><span class="line">               <span class="comment">//长度为base的数字个数</span></span><br><span class="line">   num *= <span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line">           <span class="comment">//a用来确定所在数字的大小</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> (m-temp)/base;</span><br><span class="line">           <span class="comment">//b用来确定在这个数字的第几位</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> (m-temp)%base;</span><br><span class="line">           </span><br><span class="line">   <span class="keyword">if</span>(b!=<span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//计算出这个数</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">long</span>) (Math.pow(<span class="number">10</span>, base-<span class="number">1</span>) + a);</span><br><span class="line">               <span class="comment">//找到答案</span></span><br><span class="line">   res = String.valueOf(c).charAt((<span class="type">int</span>)b-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//b=0，说明是在前一个数的最后一位上</span></span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">long</span>) (Math.pow(<span class="number">10</span>, base-<span class="number">1</span>) + a - <span class="number">1</span>);</span><br><span class="line">   res = String.valueOf(c).charAt((<span class="type">int</span>)base-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> Integer.parseInt(String.valueOf(res));</span><br><span class="line">   &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-11-无重复的最长子串"><a href="#0-11-无重复的最长子串" class="headerlink" title="0.11 无重复的最长子串"></a>0.11 无重复的最长子串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针，如果已经包含就不断前移</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>,i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j));</span><br><span class="line">                j++;</span><br><span class="line">                res = Math.max(res,j-i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.remove(s.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复</span></span><br><span class="line"><span class="comment">//我们定义不重复子串的开始位置为 start，结束位置为 end</span></span><br><span class="line"><span class="comment">//随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符</span></span><br><span class="line"><span class="comment">//无论是否更新 start，都会更新其 map 数据结构和结果 ans。</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span> ,left = <span class="number">0</span>; right &lt; n ;right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(right)))&#123;</span><br><span class="line">                left = Math.max(map.get(s.charAt(right)),left);  </span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,right-left+<span class="number">1</span>);</span><br><span class="line">            map.put(s.charAt(right),right+<span class="number">1</span>);  <span class="comment">//加一是为了返回重复字符的后一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-12-最小覆盖子串"><a href="#0-12-最小覆盖子串" class="headerlink" title="0.12 最小覆盖子串"></a>0.12 最小覆盖子串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s == <span class="string">&quot;&quot;</span> || t == <span class="literal">null</span> || t == <span class="string">&quot;&quot;</span> || s.length() &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用来统计t中每个字符出现次数  char型可以转换成0-128的int，对应字符的ASCII码,也就是用字符对应的int值作为下标</span></span><br><span class="line">        <span class="type">int</span>[] needs = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];    <span class="comment">//标记字符串t中字符</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] window = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];  <span class="comment">//标记滑动窗口中的字符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;<span class="comment">//加入数组中</span></span><br><span class="line">            needs[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//当前有多少个字符匹配成功</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来记录最短需要多少个字符。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> s.length() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            window[ch]++;</span><br><span class="line">            <span class="keyword">if</span> (needs[ch] &gt; <span class="number">0</span> &amp;&amp; needs[ch] &gt;= window[ch]) &#123;<span class="comment">//如果字符匹配成功，count++</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (count == t.length()) &#123;<span class="comment">//当匹配整个字符串都匹配成功，记录下当前的最短覆盖子串，然后从左侧缩小窗口，如果最左是有效的字符，右移右侧的指针直到再次匹配成功</span></span><br><span class="line">                ch = s.charAt(left);</span><br><span class="line">                <span class="keyword">if</span> (needs[ch] &gt; <span class="number">0</span> &amp;&amp; needs[ch] &gt;= window[ch]) &#123;<span class="comment">//如果最左的元素属于有效字符，减少count</span></span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; minLength) &#123;<span class="comment">//如果当前窗口的大小小于最短，更新minlength</span></span><br><span class="line">                    minLength = right - left + <span class="number">1</span>;</span><br><span class="line">                    res = s.substring(left, right + <span class="number">1</span>);<span class="comment">//截取当前最短的子串作为答案</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                window[ch]--;<span class="comment">//将最左元素从窗口中去除</span></span><br><span class="line">                left++;<span class="comment">//左指针右移</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            right++;<span class="comment">//右指针右移</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="0-13-剑指-Offer-57-II-和为s的连续正数序列"><a href="#0-13-剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="0.13 剑指 Offer 57 - II. 和为s的连续正数序列"></a>0.13 <a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为s的连续正数序列</a></h3><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] findContinuousSequence(<span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//左右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(i &lt;= target / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//如果和小于目标，右边界右移</span></span><br><span class="line">            <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                sum += j;</span><br><span class="line">                j++;</span><br><span class="line">            <span class="comment">//如果和大于目标，左边界右移</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                sum -= i;</span><br><span class="line">                i++;</span><br><span class="line">            <span class="comment">//否则，将答案加入</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[j-i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i ; k &lt; j; k++)&#123;</span><br><span class="line">                    a[k - i] = k;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(a);</span><br><span class="line">                <span class="comment">//以i为起点已经没有答案了，左边界右移</span></span><br><span class="line">                sum -= i;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-14-剑指-Offer-59-I-滑动窗口的最大值"><a href="#0-14-剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="0.14 剑指 Offer 59 - I. 滑动窗口的最大值"></a>0.14 <a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer 59 - I. 滑动窗口的最大值</a></h3><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p><p>思路：怎么样在每次窗口滑动后在O(1)的时间获得最大值——-单调队列，队列头就是最大的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//维护一个单调递减的双端队列</span></span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>,i = <span class="number">1</span>-k ; j &lt; nums.length ; i++,j++)&#123;</span><br><span class="line">            <span class="comment">//如果窗口已经成型，并且滑动时移除的是最大值</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; deque.peekFirst() == nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//移除队列中所有小于新加入的值</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j])&#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//加入队列</span></span><br><span class="line">            deque.add(nums[j]);</span><br><span class="line">            <span class="comment">//记录最大值</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                res[i] = deque.peekFirst();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Algorithm] Search</title>
      <link href="/2021/06/12/Algorithm/Search/"/>
      <url>/2021/06/12/Algorithm/Search/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="1-BFS"><a href="#1-BFS" class="headerlink" title="1 BFS"></a>1 BFS</h2><p>广度优先搜索一层一层的进行遍历，每次遍历以上层遍历的结果作为起点，遍历一个距离能达到的节点，注意去除重复遍历的情况</p><h3 id="1-1-279-完全平方数"><a href="#1-1-279-完全平方数" class="headerlink" title="1.1 279. 完全平方数"></a>1.1 <a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h3><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    HashSet&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    queue.add(n);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        level++; <span class="comment">// 开始生成下一层</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">//依次减 1, 4, 9... 生成下一层的节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j * j &lt;= cur; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> cur - j * j;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> level;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(next)) &#123;</span><br><span class="line">                    queue.offer(next);</span><br><span class="line">                    visited.add(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-127-单词接龙"><a href="#1-2-127-单词接龙" class="headerlink" title="1.2 127. 单词接龙"></a>1.2 <a href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a></h3><p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p><p>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典中的单词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">        <span class="comment">// 第 1 步：先将 wordList 放到哈希表里，便于判断某个单词是否在 wordList 里</span></span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordList);</span><br><span class="line">        <span class="keyword">if</span> (wordSet.size() == <span class="number">0</span> || !wordSet.contains(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        wordSet.remove(beginWord);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第 2 步：图的广度优先遍历，必须使用队列和表示是否访问过的 visited 哈希表</span></span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        visited.add(beginWord);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第 3 步：开始广度优先遍历，包含起点，因此初始化的时候步数为 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; currentSize; i++) &#123;</span><br><span class="line">                <span class="comment">// 依次遍历当前队列中的单词</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">currentWord</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="comment">// 如果 currentWord 能够修改 1 个字符与 endWord 相同，则返回 step + 1</span></span><br><span class="line">                <span class="keyword">if</span> (changeWordEveryOneLetter(currentWord, endWord, queue, visited, wordSet)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 尝试对 currentWord 修改每一个字符，看看是不是能与 endWord 匹配</span></span><br><span class="line"><span class="comment">     * @param currentWord</span></span><br><span class="line"><span class="comment">     * @param endWord</span></span><br><span class="line"><span class="comment">     * @param queue</span></span><br><span class="line"><span class="comment">     * @param visited</span></span><br><span class="line"><span class="comment">     * @param wordSet</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">changeWordEveryOneLetter</span><span class="params">(String currentWord, String endWord,</span></span><br><span class="line"><span class="params">                                             Queue&lt;String&gt; queue, Set&lt;String&gt; visited, Set&lt;String&gt; wordSet)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] charArray = currentWord.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; endWord.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 先保存，然后恢复</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">originChar</span> <span class="operator">=</span> charArray[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">k</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; k &lt;= <span class="string">&#x27;z&#x27;</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k == originChar) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                charArray[i] = k;</span><br><span class="line">                <span class="type">String</span> <span class="variable">nextWord</span> <span class="operator">=</span> String.valueOf(charArray);</span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(nextWord)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nextWord.equals(endWord)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(nextWord)) &#123;</span><br><span class="line">                        queue.add(nextWord);</span><br><span class="line">                        <span class="comment">// 注意：添加到队列以后，必须马上标记为已经访问</span></span><br><span class="line">                        visited.add(nextWord);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 恢复</span></span><br><span class="line">            charArray[i] = originChar;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-542-01-矩阵"><a href="#1-3-542-01-矩阵" class="headerlink" title="1.3 542. 01 矩阵"></a>1.3 <a href="https://leetcode-cn.com/problems/01-matrix/">542. 01 矩阵</a></h3><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] updateMatrix(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt; matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;);<span class="comment">//源点入队</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    matrix[i][j] = -<span class="number">1</span>;  <span class="comment">//标记未访问到的1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dir = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;; <span class="comment">//用来循环访问源点的上下左右</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] point = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> point[<span class="number">0</span>],y = point[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>[] d:dir)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> x+d[<span class="number">0</span>],y1 = y +d[<span class="number">1</span>];<span class="comment">//源点的四周的点</span></span><br><span class="line">                <span class="keyword">if</span>(x1 &gt;= <span class="number">0</span> &amp;&amp; x1 &lt; matrix.length &amp;&amp; y1 &gt;=<span class="number">0</span> &amp;&amp; y1 &lt; matrix[<span class="number">0</span>].length &amp;&amp; matrix[x1][y1] == -<span class="number">1</span>)&#123;  <span class="comment">//这个1在矩阵内且未被访问过</span></span><br><span class="line">                    matrix[x1][y1] = matrix[x][y] + <span class="number">1</span>; <span class="comment">//距离加一</span></span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x1,y1&#125;); <span class="comment">//将源点四周的点入队</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-DFS"><a href="#2-DFS" class="headerlink" title="2 DFS"></a>2 DFS</h2><p>从一个节点出发，使用DFS对一个图进行遍历，能到达的都是从初始节点可达的，DFS用来解决可达性问题</p><p>注意：</p><p>用栈保存当前节点信息</p><h3 id="2-1-200-岛屿数量"><a href="#2-1-200-岛屿数量" class="headerlink" title="2.1 200. 岛屿数量"></a>2.1 <a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h3><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dir = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="comment">//空矩阵</span></span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">islands</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; n ;j++)&#123;</span><br><span class="line">                <span class="comment">//有一个1，进行dfs，将与它相连的全部沉没</span></span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    islands++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> islands;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid,<span class="type">int</span> r,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件：在范围外或者是0；</span></span><br><span class="line">        <span class="keyword">if</span>(r&gt;=m||r&lt;<span class="number">0</span>||c&gt;=n||c&lt;<span class="number">0</span>||grid[r][c]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//沉没当前</span></span><br><span class="line">        grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">//沉没四周</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] d :dir)&#123;</span><br><span class="line">            dfs(grid,r+d[<span class="number">0</span>],c+d[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-695-岛屿的最大面积"><a href="#2-2-695-岛屿的最大面积" class="headerlink" title="2.2 695. 岛屿的最大面积"></a>2.2 <a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></h3><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p><p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dir = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="literal">null</span> ||grid.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m ;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    maxArea = Math.max(maxArea,dfs(grid,i,j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid,<span class="type">int</span> r,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span> || r&gt;=grid.length || c&lt; <span class="number">0</span> || c&gt;=grid[<span class="number">0</span>].length || grid[r][c]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[r][c] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] d : dir)&#123;</span><br><span class="line">            max += dfs(grid,r+d[<span class="number">0</span>],c+d[<span class="number">1</span>]);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-547-朋友圈"><a href="#2-3-547-朋友圈" class="headerlink" title="2.3 547. 朋友圈"></a>2.3 <a href="https://leetcode-cn.com/problems/friend-circles/">547. 朋友圈</a></h3><p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p><p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求无向图的连通分量</span></span><br><span class="line"><span class="comment">//如果ij两人是朋友，那么ij之间有边相连</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] M)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[M.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                dfs(M, i, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] M, <span class="type">int</span> i, <span class="type">boolean</span>[] visited)</span> &#123;</span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; M.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; M[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                dfs(M, j, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-130-被围绕的区域"><a href="#2-4-130-被围绕的区域" class="headerlink" title="2.4 130. 被围绕的区域"></a>2.4 <a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></h3><p>给定一个二维的矩阵，包含 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code>（<strong>字母 O</strong>）。</p><p>找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先填充最外侧，因为最外侧的O肯定不能被围绕，将它置为T，然后DFS它附近的O，标记</span></span><br><span class="line"><span class="comment">//全部标记完成后，遍历将O置为X，T置为O</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dir = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="literal">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        m = board.length;</span><br><span class="line">        n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            dfs(board,i,<span class="number">0</span>);</span><br><span class="line">            dfs(board,i,n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dfs(board,<span class="number">0</span>,i);</span><br><span class="line">            dfs(board,m-<span class="number">1</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; n ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board , <span class="type">int</span> r, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || board[r][c] != <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[r][c] = <span class="string">&#x27;T&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] d : dir)&#123;</span><br><span class="line">            dfs(board , r+d[<span class="number">0</span>] , c+d[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-417-太平洋大西洋水流问题"><a href="#2-5-417-太平洋大西洋水流问题" class="headerlink" title="2.5 417. 太平洋大西洋水流问题"></a>2.5 <a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a></h3><p>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。</p><p>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</p><p>请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反过来，从大西洋和太平洋向里面爬，两个区域的交点就是所需要的坐标</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">pacificAtlantic</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] dires = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m, n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] matrix;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pacificAtlantic</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        m = matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">this</span>.matrix = matrix;</span><br><span class="line">        <span class="type">boolean</span>[][] canReachP = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="type">boolean</span>[][] canReachA = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(<span class="number">0</span>, i, canReachP);</span><br><span class="line">            dfs(m - <span class="number">1</span>, i, canReachA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dfs(i, <span class="number">0</span>, canReachP);</span><br><span class="line">            dfs(i, n - <span class="number">1</span>, canReachA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(canReachA[i][j] &amp;&amp; canReachP[i][j])&#123;</span><br><span class="line">                    List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    temp.add(i);</span><br><span class="line">                    temp.add(j);</span><br><span class="line">                    res.add(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//换一种思路，从边界往里面走，只能走到比自己更高或者等高的地方。边界能走到的地方，就是能流入对应海洋的地方。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">boolean</span>[][] canReach)</span> &#123;</span><br><span class="line">        canReach[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> x + dires[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">newY</span> <span class="operator">=</span> y + dires[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (isIn(newX, newY) &amp;&amp; matrix[x][y] &lt;= matrix[newX][newY] &amp;&amp; !canReach[newX][newY]) &#123;</span><br><span class="line">                dfs(newX, newY, canReach);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isIn</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Backtracking"><a href="#3-Backtracking" class="headerlink" title="3 Backtracking"></a>3 Backtracking</h2><h3 id="3-1-1-DFS与回溯的区别"><a href="#3-1-1-DFS与回溯的区别" class="headerlink" title="3.1 1.DFS与回溯的区别"></a>3.1 1.DFS与回溯的区别</h3><p>回溯属于DFS，普通的DFS用来求解可达性问题，而回溯建立在DFS基础上，在搜索过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索。区别就在于有没有状态的重置。</p><p>回溯问题都可以抽象成树形结构，都是在集合中递归查找子集</p><p><strong>集合的大小决定数的宽度，递归的深度决定树的深度</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-回溯算法的使用场景"><a href="#3-2-2-回溯算法的使用场景" class="headerlink" title="3.2 2.回溯算法的使用场景"></a>3.2 2.回溯算法的使用场景</h3><p>当问题需要找出所有的解时，比如求解排列组合问题。</p><p>满足结束条件或者发现不是正确的路径的时候，<strong>撤销选择</strong>，回退到上一个状态，继续尝试。</p><h3 id="3-3-3-使用的步骤"><a href="#3-3-3-使用的步骤" class="headerlink" title="3.3 3.使用的步骤"></a>3.3 3.使用的步骤</h3><ul><li>画出递归树，找到状态变量（回溯函数的参数）</li><li>确定结束条件</li><li>找出选择列表，与函数参数相关</li><li>判断是否需要剪枝</li><li>做出选择，递归调用，进入下一层</li><li>撤销选择</li></ul><h3 id="3-4-4-回溯的类型"><a href="#3-4-4-回溯的类型" class="headerlink" title="3.4 4.回溯的类型"></a>3.4 4.回溯的类型</h3><div class="table-container"><table><thead><tr><th>类型</th><th>概念</th></tr></thead><tbody><tr><td>组合问题</td><td>N个数里面按一定规则找出k个数的集合</td></tr><tr><td>排列</td><td>N个数按一定规则全排列，求出所有的排列方式</td></tr><tr><td>切割问题</td><td>一个字符串按一定规则有多少种切割方式</td></tr><tr><td>子集问题</td><td>N个数的集合里有多少种符合条件的子集</td></tr><tr><td>棋盘问题</td><td>N皇后，数独等</td></tr></tbody></table></div><p>组合不强调元素顺序，排列强调元素顺序</p><p>“排列”类型问题和“子集、组合”问题不同在于：“排列”问题使用used数组来标识选择列表，而“子集、组合”问题则使用start参数。另外还需注意两种问题的判重剪枝！</p><h4 id="3-4-1-组合问题"><a href="#3-4-1-组合问题" class="headerlink" title="3.4.1 组合问题"></a>3.4.1 组合问题</h4><p>如果是一个集合求组合，需要 start 来控制 for 循环的起始位置</p><p>如果是多个集合取组合，他们互不影响，就不用 start</p><h5 id="3-4-1-1-去重："><a href="#3-4-1-1-去重：" class="headerlink" title="3.4.1.1 去重："></a>3.4.1.1 去重：</h5><p>当 candidate[i] == candidate[i-1] 时，有两种情况</p><p>两个维度：同一个递归层的重复和递归枝的重复，可以根据 used[i-1] 进行判断</p><p>如果是同一层上的重复，used[i-1]  == false 不可以进行重复的选取</p><p>如果是同一枝上的重复，used[i-1]  == true 可以进行重复的选取</p><h4 id="3-4-2-切割问题"><a href="#3-4-2-切割问题" class="headerlink" title="3.4.2 切割问题"></a>3.4.2 切割问题</h4><ul><li>如何模拟那些切割线</li><li>切割问题中递归如何终止</li><li>在递归循环中如何截取子串</li><li>如何判断回文</li></ul><h4 id="3-4-3-子集问题"><a href="#3-4-3-子集问题" class="headerlink" title="3.4.3 子集问题"></a>3.4.3 子集问题</h4><p>子集问题是收集所有节点的结果，组合是收集叶子节点的结果</p><h5 id="3-4-3-1-递增子序列的去重不能先排序"><a href="#3-4-3-1-递增子序列的去重不能先排序" class="headerlink" title="3.4.3.1 递增子序列的去重不能先排序"></a>3.4.3.1 递增子序列的去重不能先排序</h5><h5 id="3-4-3-2-子集类的剪枝："><a href="#3-4-3-2-子集类的剪枝：" class="headerlink" title="3.4.3.2 子集类的剪枝："></a>3.4.3.2 子集类的剪枝：</h5><p>判断是否需要剪枝，先排序</p><p>去除从重复的集合，也就是去除当前的选择列表中，与上一个重复的数，所引出的分支</p><h4 id="3-4-4-排列问题"><a href="#3-4-4-排列问题" class="headerlink" title="3.4.4 排列问题"></a>3.4.4 排列问题</h4><p>排列的有序的，因此不需要 start，每次都是从0开始</p><p>需要一个 used 数组对已经使用的进行记录</p><h5 id="3-4-4-1-排列的去重：使用-used-i-1-false-，即树层去重，效率更高"><a href="#3-4-4-1-排列的去重：使用-used-i-1-false-，即树层去重，效率更高" class="headerlink" title="3.4.4.1 排列的去重：使用(used[i - 1] == false)，即树层去重，效率更高"></a>3.4.4.1 排列的去重：<strong>使用(used[i - 1] == false)，即树层去重，效率更高</strong></h5><p>因为对于树层，如果重复元素相邻，那么如果前面的是false，肯定就已经是用过了</p><h4 id="3-4-5-去重问题"><a href="#3-4-5-去重问题" class="headerlink" title="3.4.5 去重问题"></a>3.4.5 去重问题</h4><p>用set和数组都可以，数组效率更高</p><h4 id="3-4-6-棋盘问题"><a href="#3-4-6-棋盘问题" class="headerlink" title="3.4.6 棋盘问题"></a>3.4.6 棋盘问题</h4><h5 id="3-4-6-1-N皇后："><a href="#3-4-6-1-N皇后：" class="headerlink" title="3.4.6.1 N皇后："></a>3.4.6.1 N皇后：</h5><p>二维矩阵中矩阵的高就是这颗树的高度，矩阵的宽就是树形结构中每一个节点的宽度。</p><p><strong>棋盘的宽度就是for循环的长度，递归的深度就是棋盘的高度</strong></p><h5 id="3-4-6-2-数独："><a href="#3-4-6-2-数独：" class="headerlink" title="3.4.6.2 数独："></a>3.4.6.2 数独：</h5><p>相较于N皇后，每一列每一行都只要放一个数字，只需要一层 for 循环遍历一行，递归来遍历列，然后一行一列确定皇后的唯一位置。</p><p><strong>棋盘的每一个位置都要放一个数字，并检查数字是否合法，解数独的树形结构要比N皇后更宽更深</strong></p><h3 id="3-5-17-电话号码的字母组合"><a href="#3-5-17-电话号码的字母组合" class="headerlink" title="3.5 17. 电话号码的字母组合"></a>3.5 <a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h3><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//记录数字对应字符串的映射</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] Keys = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        BackTracking(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), res, digits);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">BackTracking</span><span class="params">(StringBuilder prefix, List&lt;String&gt; res, <span class="keyword">final</span> String digits)</span>&#123;</span><br><span class="line">        <span class="comment">//递归中止条件</span></span><br><span class="line">        <span class="keyword">if</span>(prefix.length() == digits.length())&#123;</span><br><span class="line">            <span class="comment">//作为答案加入</span></span><br><span class="line">            res.add(prefix.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前应当映射的数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> digits.charAt(prefix.length()) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">//数字对应的字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> Keys[cur];</span><br><span class="line">        <span class="comment">//遍历其中的字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : letters.toCharArray())&#123;</span><br><span class="line">            <span class="comment">//添加字符</span></span><br><span class="line">            prefix.append(c);</span><br><span class="line">            <span class="comment">//以添加后的为基础递归</span></span><br><span class="line">            BackTracking(prefix,res,digits);</span><br><span class="line">            <span class="comment">//递归结束，回溯，移除当前的字符</span></span><br><span class="line">            prefix.deleteCharAt(prefix.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-93-复原IP地址"><a href="#3-6-93-复原IP地址" class="headerlink" title="3.6 93. 复原IP地址"></a>3.6 <a href="https://leetcode-cn.com/problems/restore-ip-addresses/">93. 复原IP地址</a></h3><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “192.168@1.1” 是 无效的 IP 地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//记录答案</span></span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//记录当前ip地址</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">curAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        backTracking(<span class="number">0</span>,curAddress,res,s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> k, StringBuilder curAddress, List&lt;String&gt; res, String s)</span>&#123;</span><br><span class="line">        <span class="comment">//递归中止条件，ip地址有四个数或者字符串为空</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">4</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//如果是有效的ip地址，加入答案中</span></span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">4</span> &amp;&amp; s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(curAddress.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//针对1，2，3位的ip地址逐个判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() &amp;&amp; i &lt;= <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//如果首位是零并且不是一位数，那么是无效的</span></span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从字符串中取出相应长度的数字</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">part</span> <span class="operator">=</span> s.substring(<span class="number">0</span>,i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//判断是否有效</span></span><br><span class="line">            <span class="keyword">if</span>(Integer.valueOf(part) &lt;= <span class="number">255</span>)&#123;</span><br><span class="line">                <span class="comment">//累加方式</span></span><br><span class="line">                <span class="keyword">if</span>(curAddress.length() != <span class="number">0</span>)&#123;</span><br><span class="line">                    part = <span class="string">&#x27;.&#x27;</span> + part;</span><br><span class="line">                &#125;</span><br><span class="line">                curAddress.append(part);</span><br><span class="line">                <span class="comment">//进行下一步的递归</span></span><br><span class="line">                backTracking(k+<span class="number">1</span>,curAddress,res,s.substring(i+<span class="number">1</span>));</span><br><span class="line">                <span class="comment">//取消上一层的状态</span></span><br><span class="line">                curAddress.delete(curAddress.length() - part.length(), curAddress.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-257-二叉树的所有路径"><a href="#3-7-257-二叉树的所有路径" class="headerlink" title="3.7 257. 二叉树的所有路径"></a>3.7 <a href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h3><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        helper(root,<span class="string">&quot;&quot;</span>,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//前序遍历，根-&gt;左-&gt;右</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(TreeNode root,String path,List&lt;String&gt; list)</span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)   <span class="keyword">return</span>;</span><br><span class="line">        path += Integer.toString(root.val);</span><br><span class="line">        <span class="comment">//如果到底了，复制path，加入答案</span></span><br><span class="line">        <span class="keyword">if</span>((root.left == <span class="literal">null</span>) &amp;&amp; (root.right == <span class="literal">null</span>))&#123; </span><br><span class="line">            list.add(path.toString());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            helper(root.left,path,list);</span><br><span class="line">            helper(root.right,path,list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-46-全排列"><a href="#3-8-46-全排列" class="headerlink" title="3.8 46. 全排列"></a>3.8 <a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h3><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//全排列</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//当前排列</span></span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//标记是否已经访问过</span></span><br><span class="line">        <span class="type">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        backTracking (cur, res, hasVisited, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">boolean</span>[] hasVisited, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="comment">//加入结果</span></span><br><span class="line">        <span class="keyword">if</span>(cur.size() == nums.length)&#123;</span><br><span class="line">            <span class="comment">//要新建，不然后面会被修改</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cur));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历可能的组合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hasVisited.length; i++)&#123;</span><br><span class="line">            <span class="comment">//如果已经访问过的，通过</span></span><br><span class="line">           <span class="keyword">if</span>(hasVisited[i])&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//加入答案，将访问标记置为true</span></span><br><span class="line">           hasVisited[i] = <span class="literal">true</span>;</span><br><span class="line">           cur.add(nums[i]); </span><br><span class="line">           <span class="comment">//回溯剩下的部分</span></span><br><span class="line">           backTracking(cur,res,hasVisited,nums);</span><br><span class="line">           <span class="comment">//移除之前回溯的状态</span></span><br><span class="line">           cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">           hasVisited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-47-全排列-II"><a href="#3-9-47-全排列-II" class="headerlink" title="3.9 47. 全排列 II"></a>3.9 <a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></h3><p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先进行排序，在遍历的时候判断这个元素是否等于上一个元素，如果等于，并且前一个元素还没有访问，那么跳过这个元素，或者是访问了跳过当前元素，需要跳过一个</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//全排列</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//当前排列</span></span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//标记是否已经访问过</span></span><br><span class="line">        <span class="type">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTracking(cur, res, hasVisited, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">boolean</span>[] hasVisited, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="comment">//加入结果</span></span><br><span class="line">        <span class="keyword">if</span>(cur.size() == nums.length)&#123;</span><br><span class="line">            <span class="comment">//要新建，不然后面会被修改</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cur));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历可能的组合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hasVisited.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !hasVisited[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果已经访问过的，通过</span></span><br><span class="line">           <span class="keyword">if</span>(hasVisited[i])&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//加入答案，将访问标记置为true</span></span><br><span class="line">           hasVisited[i] = <span class="literal">true</span>;</span><br><span class="line">           cur.add(nums[i]); </span><br><span class="line">           <span class="comment">//回溯剩下的部分</span></span><br><span class="line">           backTracking(cur,res,hasVisited,nums);</span><br><span class="line">           <span class="comment">//移除之前回溯的状态</span></span><br><span class="line">           cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">           hasVisited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-10-77-组合"><a href="#3-10-77-组合" class="headerlink" title="3.10 77. 组合"></a>3.10 <a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></h3><p>给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backTracking(cur, res, <span class="number">1</span>, k, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span> start, <span class="type">int</span> k, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">//如果有k个数了</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从起点开始遍历，因为有k个数那么作为起点，肯定不会大于n-k+1，可以用来剪枝</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n-k+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            cur.add(i);</span><br><span class="line">            <span class="comment">//下次递归起点加一</span></span><br><span class="line">            backTracking(cur, res, i+<span class="number">1</span>, k-<span class="number">1</span>, n);</span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-11-78-子集"><a href="#3-11-78-子集" class="headerlink" title="3.11 78. 子集"></a>3.11 <a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h3><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//对应不同长度的子集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; size &lt;= nums.length; size++)&#123;</span><br><span class="line">            backTracking(<span class="number">0</span>,size,nums,cur,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//start：状态变量，用来标识当前的选择列表的起始位置，控制选择列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> size, <span class="type">int</span>[] nums, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.size() == size)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            cur.add(nums[i]);</span><br><span class="line">            backTracking(i+<span class="number">1</span>,size,nums,cur,res);</span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-12-90-子集-II"><a href="#3-12-90-子集-II" class="headerlink" title="3.12 90. 子集 II"></a>3.12 <a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></h3><p>给定一个可能包含重复元素的整数数组 <strong><em>nums</em></strong>，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong>解集不能包含重复的子集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//对应不同长度的子集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; size &lt;= nums.length; size++)&#123;</span><br><span class="line">            backTracking(<span class="number">0</span>,size,nums,cur,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//start：状态变量，用来标识当前的选择列表的起始位置，控制选择列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> size, <span class="type">int</span>[] nums, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.size() == size)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从start到末尾，就是当前的选择列表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//去除当前选择列表中，与上一个数重复的数</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.add(nums[i]);</span><br><span class="line">            backTracking(i+<span class="number">1</span>,size,nums,cur,res);</span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-13-491-递增子序列"><a href="#3-13-491-递增子序列" class="headerlink" title="3.13 491. 递增子序列"></a>3.13 <a href="https://leetcode-cn.com/problems/increasing-subsequences/">491. 递增子序列</a></h3><p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意与子集的区别</span></span><br><span class="line"><span class="comment">//这里只要本层重复使用元素，递增子序列就会重复：如&#123;4，7，6，7&#125;，如果重复使用，会有两个&#123;4，7&#125;</span></span><br><span class="line"><span class="comment">//子集问题是看排序后相邻的相同元素是否重复使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//答案</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//路径</span></span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backTracking(res, path, <span class="number">0</span>,  nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, <span class="type">int</span> start,<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只负责记录本层是否重复使用了，新的一层会清空</span></span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">201</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((path.size() &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; path.get(path.size() - <span class="number">1</span>)) || used[nums[i]+<span class="number">100</span>] == <span class="literal">true</span>   )&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[nums[i] + <span class="number">100</span>] = <span class="literal">true</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(res,path,i+<span class="number">1</span>,nums);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-14-51-N-皇后"><a href="#3-14-51-N-皇后" class="headerlink" title="3.14 51. N 皇后"></a>3.14 <a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a></h3><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>二维矩阵中矩阵的高就是这颗树的高度，矩阵的宽就是树型结构中每一个节点的宽度。</p><p><strong>递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。</strong></p><p><strong>只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径：board 中小于 row 的那些行都已经成功放置了皇后</span></span><br><span class="line"><span class="comment">// 选择列表：第 row 行的所有列都是放置皇后的选择</span></span><br><span class="line"><span class="comment">// 结束条件：row 超过 board 的最后一行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] board = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c:board)&#123;</span><br><span class="line">            Arrays.fill(c,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        backTracking(board,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> row)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == board.length)&#123;</span><br><span class="line">            res.add(arrayToList(board));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; board.length; col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isValid(board,row,col))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            backTracking(board,row+<span class="number">1</span>);</span><br><span class="line">            board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">arrayToList</span><span class="params">(<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">        List&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c : board)&#123;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> i : c)&#123;</span><br><span class="line">                sb.append(i);</span><br><span class="line">            &#125;</span><br><span class="line">            temp.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为在每次递归的 for 循环中只会在同一行选一个，所有不用去重</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="comment">//因为下面的还没有放置，只需要检查上面即可</span></span><br><span class="line">        <span class="comment">// 检查列是否有皇后互相冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查右上方是否有皇后互相冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>;</span><br><span class="line">             i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查左上方是否有皇后互相冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>;</span><br><span class="line">             i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-15-时间复杂度"><a href="#3-15-时间复杂度" class="headerlink" title="3.15 时间复杂度"></a>3.15 时间复杂度</h3><p>子集问题分析：</p><ul><li>时间复杂度：O(n <em> 2^n)，因为每一个元素的状态无外乎取与不取，所以时间复杂度为O(2^n)，构造每一组子集都需要填进数组，又有需要O(n)，最终时间复杂度：O(n </em> 2^n)</li><li>空间复杂度：O(n)，递归深度为n，所以系统栈所用空间为O(n)，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为O(n)</li></ul><p>排列问题分析：</p><ul><li>时间复杂度：O(n!)，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n <em> n-1 </em> n-2 * ….. 1 = n!。</li><li>空间复杂度：O(n)，和子集问题同理。</li></ul><p>组合问题分析：</p><ul><li>时间复杂度：O(n * 2^n)，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。</li><li>空间复杂度：O(n)，和子集问题同理。</li></ul><p>N皇后问题分析：</p><ul><li>时间复杂度：O(n!) ，其实如果看树形图的话，直觉上是O(n^n)，但皇后之间不能见面所以在搜索的过程中是有剪枝的，最差也就是O（n!），n!表示n <em> (n-1) </em> …. * 1。</li><li>空间复杂度：O(n)，和子集问题同理。</li></ul><p>解数独问题分析：</p><ul><li>时间复杂度：O(9^m) , m是’.’的数目。</li><li>空间复杂度：O(n^2)，递归的深度是n^2</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Algorithm] Tree</title>
      <link href="/2021/06/12/Algorithm/Tree/"/>
      <url>/2021/06/12/Algorithm/Tree/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置  进入节点的时候 </span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    <span class="comment">// 中序位置左子树遍历完成</span></span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">// 后序位置  离开节点的时候</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历一遍二叉树得出答案  </span></span><br><span class="line"><span class="comment">// 通过分解问题计算出答案 定义递归函数完成</span></span><br><span class="line"><span class="comment">// 只有后序位置才能通过返回值获取子树的信息。</span></span><br><span class="line"><span class="comment">// 二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，</span></span><br><span class="line"><span class="comment">// 去达到自己的目的，你只需要单独思考每一个节点应该做什么</span></span><br></pre></td></tr></table></figure><p>[toc]</p><h2 id="1-遍历"><a href="#1-遍历" class="headerlink" title="1 遍历"></a>1 遍历</h2><h3 id="1-1-前序遍历"><a href="#1-1-前序遍历" class="headerlink" title="1.1 前序遍历"></a>1.1 前序遍历</h3><p>思路：根节点-&gt;左子树-&gt;右子树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            preorderTraversal(root.left);</span><br><span class="line">            preorderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归，用栈实现，先访问父节点，先压右再压左</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="comment">// 倒过来，因为栈后面压入先出</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-中序遍历"><a href="#1-2-中序遍历" class="headerlink" title="1.2 中序遍历"></a>1.2 中序遍历</h3><p>思路：左子树-&gt;根节点-&gt;右子树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            inorderTraversal(root.left);</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            inorderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归 先压左节点，然后从最后一个左节点开始访问，如果有右节点则访问</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//中序遍历结束的条件是栈空，并且树中全部节点都已经被压入栈</span></span><br><span class="line">        <span class="keyword">while</span>(stack.size() &gt; <span class="number">0</span> || root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//从root开始，将root的左节点全部压入</span></span><br><span class="line">            <span class="comment">//这里是为了剔除右节点为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//压入后，从最左开始访问</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                res.add(node.val);</span><br><span class="line">                root = node.right;<span class="comment">//如果有右节点，那么将在下一个循环中被压入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-后序遍历"><a href="#1-3-后序遍历" class="headerlink" title="1.3 后序遍历"></a>1.3 后序遍历</h3><p>思路：左子树-&gt;右子树-&gt;根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归的比较简单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归，可以将前序修改成根右左，倒序就是后序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val); <span class="comment">//根节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) stack.push(node.left);<span class="comment">//先压左再压右</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);<span class="comment">//倒序结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-987-二叉树的垂序遍历"><a href="#1-4-987-二叉树的垂序遍历" class="headerlink" title="1.4 987. 二叉树的垂序遍历"></a>1.4 <a href="https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/">987. 二叉树的垂序遍历</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录每个节点和对应的坐标 (row, col)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Triple</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> row, col;</span><br><span class="line">        <span class="keyword">public</span> TreeNode node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Triple</span><span class="params">(TreeNode node, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.node = node;</span><br><span class="line">            <span class="built_in">this</span>.row = row;</span><br><span class="line">            <span class="built_in">this</span>.col = col;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">verticalTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历二叉树，并且为所有节点生成对应的坐标</span></span><br><span class="line">        traverse(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 根据题意，根据坐标值对所有节点进行排序：</span></span><br><span class="line">        <span class="comment">// 按照 col 从小到大排序，col 相同的话按 row 从小到大排序，</span></span><br><span class="line">        <span class="comment">// 如果 col 和 row 都相同，按照 node.val 从小到大排序。</span></span><br><span class="line">        Collections.sort(nodes, (Triple a, Triple b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.col == b.col &amp;&amp; a.row == b.row) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.node.val - b.node.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a.col == b.col) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.row - b.row;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a.col - b.col;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 将排好序的节点组装成题目要求的返回格式</span></span><br><span class="line">        LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 记录上一列编号，初始化一个特殊值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preCol</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">            <span class="type">Triple</span> <span class="variable">cur</span> <span class="operator">=</span> nodes.get(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.col != preCol) &#123;</span><br><span class="line">                <span class="comment">// 开始记录新的一列</span></span><br><span class="line">                res.addLast(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">                preCol = cur.col;</span><br><span class="line">            &#125;</span><br><span class="line">            res.getLast().add(cur.node.val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Triple&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 二叉树遍历函数，记录所有节点对应的坐标</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录坐标</span></span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">Triple</span>(root, row, col));</span><br><span class="line">        <span class="comment">// 二叉树遍历框架</span></span><br><span class="line">        traverse(root.left, row + <span class="number">1</span>, col - <span class="number">1</span>);</span><br><span class="line">        traverse(root.right, row + <span class="number">1</span>, col + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-236-二叉树的最近公共祖先"><a href="#1-5-236-二叉树的最近公共祖先" class="headerlink" title="1.5 236. 二叉树的最近公共祖先"></a>1.5 <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果root是最近的公共祖先，那么有三种情况：</span></span><br><span class="line"><span class="comment">//p和q在root的左右子树中；p=root，q在p的子树中；q=root，p在q的子树中</span></span><br><span class="line"><span class="comment">//递归对二叉树进行后序遍历：（左右中）遇到p或q返回</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">//中止条件：越过了叶子节点或者找到了p或q</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">//如果都为空，都没有，返回</span></span><br><span class="line">        <span class="comment">//都不空，返回root</span></span><br><span class="line">        <span class="comment">//有一个空，另一个就是最近公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-993-二叉树的堂兄弟节点"><a href="#1-6-993-二叉树的堂兄弟节点" class="headerlink" title="1.6 993. 二叉树的堂兄弟节点"></a>1.6 <a href="https://leetcode.cn/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a></h3><p>如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">parentX</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">parentY</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">depthX</span> <span class="operator">=</span> <span class="number">0</span>, depthY = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCousins</span><span class="params">(TreeNode root, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        traverse(root, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (depthX == depthY &amp;&amp; parentX != parentY) &#123;</span><br><span class="line">            <span class="comment">// 判断 x，y 是否是表兄弟节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> depth, TreeNode parent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == x) &#123;</span><br><span class="line">            <span class="comment">// 找到 x，记录它的深度和父节点</span></span><br><span class="line">            parentX = parent;</span><br><span class="line">            depthX = depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == y) &#123;</span><br><span class="line">            <span class="comment">// 找到 y，记录它的深度和父节点</span></span><br><span class="line">            parentY = parent;</span><br><span class="line">            depthY = depth;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root.left, depth + <span class="number">1</span>, root);</span><br><span class="line">        traverse(root.right, depth + <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-二叉树的下一个节点"><a href="#1-7-二叉树的下一个节点" class="headerlink" title="1.7 二叉树的下一个节点"></a>1.7 二叉树的下一个节点</h3><p>给定二叉树其中的一个结点，请找出其中序遍历顺序的下一个结点并且返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;TreeLinkNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeLinkNode <span class="title function_">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeLinkNode</span> <span class="variable">root</span> <span class="operator">=</span> pNode;</span><br><span class="line">        <span class="comment">// 找到父节点</span></span><br><span class="line">        <span class="keyword">while</span>(root.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            root = root.next;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size()-<span class="number">1</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list.get(i) == pNode) <span class="keyword">return</span> list.get(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeLinkNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        list.add(root);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有右子树，则找右子树的最左节点</span></span><br><span class="line"><span class="comment">//没右子树</span></span><br><span class="line"><span class="comment">//若x是父节点的左孩子。则x的父节点就是x的下一个节点。</span></span><br><span class="line"><span class="comment">//若x是父节点的右孩子。则沿着父节点向上，直到找到一个节点的父节点的左孩子是该节点，</span></span><br><span class="line"><span class="comment">//则该节点的父节点就是x的下一个节点</span></span><br></pre></td></tr></table></figure><h3 id="1-8-剑指-Offer-07-重建二叉树"><a href="#1-8-剑指-Offer-07-重建二叉树" class="headerlink" title="1.8 剑指 Offer 07. 重建二叉树"></a>1.8 <a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h3><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序第一个是根节点，而在中序的该值的左边是左子树，右边是右子树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder[<span class="number">0</span>] == inorder[i])&#123;</span><br><span class="line">                root.left = buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(inorder,<span class="number">0</span>,i));</span><br><span class="line">                root.right = buildTree(Arrays.copyOfRange(preorder,i+<span class="number">1</span>,preorder.length),Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Arrays.copyOfRange(T[ ] original,int from,int to)将一个原始的数组original，从下标from开始复制，复制到上标to，生成一个新的数组。注意这里包括下标from，不包括上标to。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] preorder;</span><br><span class="line">    <span class="comment">//可以用来查找根节点在中序中的对应位置</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++)</span><br><span class="line">            dic.put(inorder[i], i);</span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//root是根节点在前序中的位置，left，right是中序遍历中的边界</span></span><br><span class="line">    TreeNode <span class="title function_">recur</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;                          <span class="comment">// 递归终止</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[root]);          <span class="comment">// 建立根节点</span></span><br><span class="line">        <span class="comment">//找到左右子树的划分点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dic.get(preorder[root]);                       <span class="comment">// 划分根节点、左子树、右子树</span></span><br><span class="line">        <span class="comment">//左子树的根节点，左边界不变</span></span><br><span class="line">        node.left = recur(root + <span class="number">1</span>, left, i - <span class="number">1</span>);              <span class="comment">// 开启左子树递归</span></span><br><span class="line">        <span class="comment">//右子树的根节点就是根节点加上左子树长度加一</span></span><br><span class="line">        node.right = recur(root + i - left + <span class="number">1</span>, i + <span class="number">1</span>, right); <span class="comment">// 开启右子树递归</span></span><br><span class="line">        <span class="keyword">return</span> node;                                           <span class="comment">// 回溯返回根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-9-106-从中序与后序遍历序列构造二叉树"><a href="#1-9-106-从中序与后序遍历序列构造二叉树" class="headerlink" title="1.9 106. 从中序与后序遍历序列构造二叉树"></a>1.9 <a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h3><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储 inorder 中值到索引的映射</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; valToIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            valToIndex.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>,</span><br><span class="line">                    postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       定义：</span></span><br><span class="line"><span class="comment">       中序遍历数组为 inorder[inStart..inEnd]，</span></span><br><span class="line"><span class="comment">       后序遍历数组为 postorder[postStart..postEnd]，</span></span><br><span class="line"><span class="comment">       构造这个二叉树并返回该二叉树的根节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd,</span></span><br><span class="line"><span class="params">                <span class="type">int</span>[] postorder, <span class="type">int</span> postStart, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// root 节点对应的值就是后序遍历数组的最后一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> postorder[postEnd];</span><br><span class="line">        <span class="comment">// rootVal 在中序遍历数组中的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> valToIndex.get(rootVal);</span><br><span class="line">        <span class="comment">// 左子树的节点个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - inStart;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">// 递归构造左右子树</span></span><br><span class="line">        root.left = build(inorder, inStart, index - <span class="number">1</span>,</span><br><span class="line">                         postorder, postStart, postStart + leftSize - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        root.right = build(inorder, index + <span class="number">1</span>, inEnd,</span><br><span class="line">                          postorder, postStart + leftSize, postEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-10-257-二叉树的所有路径"><a href="#1-10-257-二叉树的所有路径" class="headerlink" title="1.10 257. 二叉树的所有路径"></a>1.10 <a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h3><p>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        helper(root,<span class="string">&quot;&quot;</span>,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(TreeNode root,String path,List&lt;String&gt; list)</span>&#123;  <span class="comment">//前序遍历，根-&gt;左-&gt;右</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)   <span class="keyword">return</span>;</span><br><span class="line">        path += Integer.toString(root.val);</span><br><span class="line">        <span class="keyword">if</span>((root.left == <span class="literal">null</span>) &amp;&amp; (root.right == <span class="literal">null</span>))&#123;  <span class="comment">//如果到底了，复制path，加入答案</span></span><br><span class="line">            list.add(path.toString());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            helper(root.left,path,list);</span><br><span class="line">            helper(root.right,path,list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-11-297-二叉树的序列化与反序列化"><a href="#1-11-297-二叉树的序列化与反序列化" class="headerlink" title="1.11 297. 二叉树的序列化与反序列化"></a>1.11 <a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">SEP</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">NULL</span> <span class="operator">=</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主函数，将二叉树序列化为字符串 */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        serialize(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 辅助函数，将二叉树存入 StringBuilder */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            sb.append(NULL).append(SEP);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/******前序遍历位置******/</span></span><br><span class="line">        sb.append(root.val).append(SEP);</span><br><span class="line">        serialize(root.left, sb);</span><br><span class="line">        serialize(root.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主函数，将字符串反序列化为二叉树结构 */</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="comment">// 将字符串转化成列表</span></span><br><span class="line">        LinkedList&lt;String&gt; nodes = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : data.split(SEP)) &#123;</span><br><span class="line">            nodes.addLast(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(nodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 辅助函数，通过 nodes 列表构造二叉树 */</span></span><br><span class="line">    TreeNode <span class="title function_">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/******前序遍历位置******/</span></span><br><span class="line">        <span class="comment">// 列表最左侧就是根节点</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> nodes.removeFirst();</span><br><span class="line">        <span class="keyword">if</span> (first.equals(NULL)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(first));</span><br><span class="line">        <span class="comment">// 会把左子树的元素全部移除</span></span><br><span class="line">        root.left = deserialize(nodes);</span><br><span class="line">        root.right = deserialize(nodes);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-12-124-二叉树中的最大路径和"><a href="#1-12-124-二叉树中的最大路径和" class="headerlink" title="1.12 124. 二叉树中的最大路径和"></a>1.12 <a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h3><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在后序遍历的时候顺便计算题目要求的最大路径和。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算单边路径和时顺便计算最大路径和</span></span><br><span class="line">        oneSideMax(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：计算从根节点 root 为起点的最大单边路径和</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">oneSideMax</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMaxSum</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, oneSideMax(root.left));</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMaxSum</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, oneSideMax(root.right));</span><br><span class="line">        <span class="comment">// 后序遍历位置，顺便更新最大路径和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pathMaxSum</span> <span class="operator">=</span> root.val + leftMaxSum + rightMaxSum;</span><br><span class="line">        res = Math.max(res, pathMaxSum);</span><br><span class="line">        <span class="comment">// 实现函数定义，左右子树的最大单边路径和加上根节点的值</span></span><br><span class="line">        <span class="comment">// 就是从根节点 root 为起点的最大单边路径和</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftMaxSum, rightMaxSum) + root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-13-114-二叉树展开为链表"><a href="#1-13-114-二叉树展开为链表" class="headerlink" title="1.13 114. 二叉树展开为链表"></a>1.13 <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h3><p>给你二叉树的根结点 root ，请你将它展开为一个单链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：将以 root 为根的树拉平为链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 先递归拉平左右子树</span></span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/****后序遍历位置****/</span></span><br><span class="line">        <span class="comment">// 1、左右子树已经被拉平成一条链表</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、将左子树作为右子树</span></span><br><span class="line">        root.left = <span class="literal">null</span>;</span><br><span class="line">        root.right = left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、将原先的右子树接到当前右子树的末端</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (p.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        p.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-14-623-在二叉树中增加一行"><a href="#1-14-623-在二叉树中增加一行" class="headerlink" title="1.14 623. 在二叉树中增加一行"></a>1.14 <a href="https://leetcode.cn/problems/add-one-row-to-tree/">623. 在二叉树中增加一行</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> targetVal, targetDepth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">addOneRow</span><span class="params">(TreeNode root, <span class="type">int</span> val, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        targetVal = val;</span><br><span class="line">        targetDepth = depth;</span><br><span class="line">        <span class="comment">// 插入到第一行的话特殊对待一下</span></span><br><span class="line">        <span class="keyword">if</span> (targetDepth == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">newRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(targetVal);</span><br><span class="line">            newRoot.left = root;</span><br><span class="line">            <span class="keyword">return</span> newRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历二叉树，走到对应行进行插入</span></span><br><span class="line">        traverse(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">curDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        curDepth++;</span><br><span class="line">        <span class="keyword">if</span> (curDepth == targetDepth - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 进行插入</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">newLeft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(targetVal);</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">newRight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(targetVal);</span><br><span class="line">            newLeft.left = root.left;</span><br><span class="line">            newRight.right = root.right;</span><br><span class="line">            root.left = newLeft;</span><br><span class="line">            root.right = newRight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        curDepth--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-15-654-最大二叉树"><a href="#1-15-654-最大二叉树" class="headerlink" title="1.15 654. 最大二叉树"></a>1.15 <a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/* 主函数 */</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义：将 nums[lo..hi] 构造成符合条件的树，返回根节点 */</span></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (lo &gt; hi) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到数组中的最大值和对应的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>, maxVal = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxVal &lt; nums[i]) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxVal);</span><br><span class="line">        <span class="comment">// 递归调用构造左右子树</span></span><br><span class="line">        root.left = build(nums, lo, index - <span class="number">1</span>);</span><br><span class="line">        root.right = build(nums, index + <span class="number">1</span>, hi);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-16-814-二叉树剪枝"><a href="#1-16-814-二叉树剪枝" class="headerlink" title="1.16 814. 二叉树剪枝"></a>1.16 <a href="https://leetcode.cn/problems/binary-tree-pruning/">814. 二叉树剪枝</a></h3><p>给你二叉树的根结点 root ，此外树的每个结点的值要么是 0 ，要么是 1 。</p><p>返回移除了所有不包含 1 的子树的原二叉树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：输入一棵二叉树，返回的二叉树叶子节点都是 1</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">pruneTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二叉树递归框架</span></span><br><span class="line">        root.left = pruneTree(root.left);</span><br><span class="line">        root.right = pruneTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历位置，判断自己是否是值为 0 的叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == <span class="number">0</span> &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回值会被父节点接收，相当于把自己删掉了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不是，正常返回</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-层序遍历"><a href="#2-层序遍历" class="headerlink" title="2 层序遍历"></a>2 层序遍历</h2><h3 id="2-1-102-二叉树的层序遍历"><a href="#2-1-102-二叉树的层序遍历" class="headerlink" title="2.1 102. 二叉树的层序遍历"></a>2.1 <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="comment">// 记录当前层的节点，并将下一层的入队</span></span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                level.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>)</span><br><span class="line">                    q.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>)</span><br><span class="line">                    q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-103-二叉树的锯齿形层序遍历"><a href="#2-2-103-二叉树的锯齿形层序遍历" class="headerlink" title="2.2 103. 二叉树的锯齿形层序遍历"></a>2.2 <a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h3><p>即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt;  queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            queue.offer(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置标记，记录顺序</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;   </span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    level.add(node.val);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 倒过来添加到队列里面</span></span><br><span class="line">                    level.add(<span class="number">0</span>,node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">            flag = !flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-662-二叉树最大宽度"><a href="#2-3-662-二叉树最大宽度" class="headerlink" title="2.3 662. 二叉树最大宽度"></a>2.3 <a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a></h3><p>给你一棵二叉树的根节点 root ，返回树的 <strong>最大宽度</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据完全二叉树的概念，i位置节点的左子节点位置为2i，右子节点位置为2i+1；</span></span><br><span class="line"><span class="comment">//通过一个list记录节点对应的完全二叉树中的位置</span></span><br><span class="line"><span class="comment">//按层BFS二叉树，记录下list中每一层的前后位置之差，返回最大</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//节点队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();   </span><br><span class="line">        <span class="comment">//节点位置队列</span></span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        res.add(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">cur</span> <span class="operator">=</span> res.removeFirst();</span><br><span class="line">                <span class="comment">// 相应的位置也加入辅助队列</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                    res.add(cur*<span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                    res.add(cur * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最大宽度</span></span><br><span class="line">            <span class="keyword">if</span>(res.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                ans = Math.max(ans,res.getLast() - res.getFirst() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-958-二叉树的完全性检验"><a href="#2-4-958-二叉树的完全性检验" class="headerlink" title="2.4 958. 二叉树的完全性检验"></a>2.4 <a href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">958. 二叉树的完全性检验</a></h3><p>给定一个二叉树的 root ，确定它是否是一个 <em>完全二叉树</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历，判断是否出现过null</span></span><br><span class="line"><span class="comment">//通过一个 flag 进行记录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompleteTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//判断是否出现过null</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size ; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;<span class="comment">//如果当前节点不是null</span></span><br><span class="line">                    <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果之前出现就直接返回</span></span><br><span class="line">                    queue.add(node.left);<span class="comment">//不管有没有子节点，都加入</span></span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-222-完全二叉树的节点个数"><a href="#2-5-222-完全二叉树的节点个数" class="headerlink" title="2.5 222. 完全二叉树的节点个数"></a>2.5 <a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h3><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> countLevel(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> countLevel(root.right);</span><br><span class="line">        <span class="comment">// 层数一样，左边满，不一样，右边满</span></span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="comment">// 位运算 2^left</span></span><br><span class="line">            <span class="keyword">return</span> countNodes(root.right) + (<span class="number">1</span>&lt;&lt;left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> countNodes(root.left) + (<span class="number">1</span>&lt;&lt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countLevel</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            level++;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-199-二叉树的右视图"><a href="#2-6-199-二叉树的右视图" class="headerlink" title="2.6 199. 二叉树的右视图"></a>2.6 <a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h3><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* BFS 层序遍历解法 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// BFS 层序遍历，计算右侧视图</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="comment">// while 循环控制从上向下一层层遍历</span></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="comment">// 每一层头部就是最右侧的元素</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">last</span> <span class="operator">=</span> q.peek();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="comment">// 控制每一层从右向左遍历</span></span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每一层的最后一个节点就是二叉树的右侧视图</span></span><br><span class="line">            res.add(last.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DFS 递归遍历解法 */</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录递归的层数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView_DFS</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二叉树遍历函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历位置</span></span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">if</span> (res.size() &lt; depth) &#123;</span><br><span class="line">            <span class="comment">// 这一层还没有记录值</span></span><br><span class="line">            <span class="comment">// 说明 root 就是右侧视图的第一个节点</span></span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意，这里反过来，先遍历右子树再遍历左子树</span></span><br><span class="line">        <span class="comment">// 这样首先遍历的一定是右侧节点</span></span><br><span class="line">        traverse(root.right);</span><br><span class="line">        traverse(root.left);</span><br><span class="line">        <span class="comment">// 后序遍历位置</span></span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-递归"><a href="#3-递归" class="headerlink" title="3 递归"></a>3 递归</h2><h3 id="3-1-112-路径总和"><a href="#3-1-112-路径总和" class="headerlink" title="3.1 112. 路径总和"></a>3.1 <a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h3><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//为空节点，false</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; root.val == sum)&#123; <span class="comment">//当路径总和等于目标且为叶子节点时，true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left,sum - root.val) || hasPathSum(root.right,sum - root.val);</span><br><span class="line">    &#125;  <span class="comment">//从当前节点的左右继续往下递归，目标值减去当前节点值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-113-路径总和-II"><a href="#3-2-113-路径总和-II" class="headerlink" title="3.2 113. 路径总和 II"></a>3.2 <a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h3><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java 文档中 Stack 类建议使用 Deque 代替 Stack，注意：只使用栈的相关接口</span></span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dfs(root, sum, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pathSum</span><span class="params">(TreeNode node, <span class="type">int</span> sum, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归终止条件 1：遇到空结点不再递归调用</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 沿途结点必须选择，这个时候要做两件事：1、sum 减去这个结点的值；2、添加到 path 里</span></span><br><span class="line">        sum -= node.val;</span><br><span class="line">        path.addLast(node.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归终止条件 2：遇到叶子结点，sum 恰好为 0，说明从根结点到叶子结点的路径是一个符合要求的解</span></span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span> &amp;&amp; node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// path 全局只有一份，必须做拷贝</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="comment">// 注意：这里 return 之前必须重置</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pathSum(node.left, sum, path, res);</span><br><span class="line">        pathSum(node.right, sum, path, res);</span><br><span class="line">        <span class="comment">// 递归完成以后，必须重置变量</span></span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    dfs(root, sum, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> sum, List&lt;Integer&gt; list,</span></span><br><span class="line"><span class="params">                List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">    <span class="comment">//如果节点为空直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//因为list是引用传递，为了防止递归的时候分支污染，我们要在每个路径</span></span><br><span class="line">    <span class="comment">//中都要新建一个subList</span></span><br><span class="line">    List&lt;Integer&gt; subList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">    <span class="comment">//把当前节点值加入到subList中</span></span><br><span class="line">    subList.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(root.val));</span><br><span class="line">    <span class="comment">//如果到达叶子节点，就不能往下走了，直接return</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果到达叶子节点，并且sum等于叶子节点的值，说明我们找到了一组，</span></span><br><span class="line">        <span class="comment">//要把它放到result中</span></span><br><span class="line">        <span class="keyword">if</span> (sum == root.val)</span><br><span class="line">            result.add(subList);</span><br><span class="line">        <span class="comment">//到叶子节点之后直接返回，因为在往下就走不动了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没到达叶子节点，就继续从他的左右两个子节点往下找，注意到</span></span><br><span class="line">    <span class="comment">//下一步的时候，sum值要减去当前节点的值</span></span><br><span class="line">    dfs(root.left, sum - root.val, subList, result);</span><br><span class="line">    dfs(root.right, sum - root.val, subList, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-437-路径总和-III"><a href="#3-3-437-路径总和-III" class="headerlink" title="3.3 437. 路径总和 III"></a>3.3 <a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h3><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 <strong>路径</strong> 的数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//因为未必是要从根节点开始，因此需要对所有节点进行递归判断</span></span><br><span class="line">        <span class="keyword">return</span> pathSumFromRoot(root,sum) + pathSum(root.left,sum) + pathSum(root.right,sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">pathSumFromRoot</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span>&#123; <span class="comment">//递归判断从当前节点是否有满足条件的路径</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum == root.val) ret++;</span><br><span class="line">        ret += pathSumFromRoot(root.left, sum - root.val) + pathSumFromRoot(root.right, sum - root.val);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-572-另一棵树的子树"><a href="#3-4-572-另一棵树的子树" class="headerlink" title="3.4 572. 另一棵树的子树"></a>3.4 <a href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></h3><p>给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//因为未必是要从根节点开始，因此需要对所有节点进行递归判断</span></span><br><span class="line">        <span class="keyword">return</span> isSubtree(s.left,t) || isSubtree(s.right,t) || isSubtreeFromRoot(s,t);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSubtreeFromRoot</span><span class="params">(TreeNode s, TreeNode t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> &amp;&amp; t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> || t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.val != t.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSubtreeFromRoot(s.left,t.left) &amp;&amp; isSubtreeFromRoot(s.right,t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-111-二叉树的最小深度"><a href="#3-5-111-二叉树的最小深度" class="headerlink" title="3.5 111. 二叉树的最小深度"></a>3.5 <a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h3><p>给定一个二叉树，找出其最小深度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> minDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> minDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> || right == <span class="number">0</span>) <span class="keyword">return</span> left+right+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.min(left , right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-101-对称二叉树"><a href="#3-6-101-对称二叉树" class="headerlink" title="3.6 101. 对称二叉树"></a>3.6 <a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMirror</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> &amp;&amp; t2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> || t2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">            (t1.val == t2.val)</span><br><span class="line">            &amp;&amp; isMirror(t1.right, t2.left)</span><br><span class="line">            &amp;&amp; isMirror(t1.left, t2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-404-左叶子之和"><a href="#3-7-404-左叶子之和" class="headerlink" title="3.7 404. 左叶子之和"></a>3.7 <a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h3><p>给定二叉树的根节点 root ，返回所有左叶子之和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是不是左叶子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(isLeaf(root.left))&#123;</span><br><span class="line">            left = root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">(TreeNode root)</span>&#123; <span class="comment">//判断是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-687-最长同值路径"><a href="#3-8-687-最长同值路径" class="headerlink" title="3.8 687. 最长同值路径"></a>3.8 <a href="https://leetcode.cn/problems/longest-univalue-path/">687. 最长同值路径</a></h3><p>给定一个二叉树的 root ，返回 <em>最长的路径的长度</em> ，这个路径中的 <em>每个节点具有相同值</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestUnivaluePath</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在后序遍历的位置更新 res</span></span><br><span class="line">        maxLen(root, root.val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：计算以 root 为根的这棵二叉树中，从 root 开始值为 parentVal 的最长树枝长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">maxLen</span><span class="params">(TreeNode root, <span class="type">int</span> parentVal)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用函数定义，计算左右子树值为 root.val 的最长树枝长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLen</span> <span class="operator">=</span> maxLen(root.left, root.val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLen</span> <span class="operator">=</span> maxLen(root.right, root.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历位置顺便更新全局变量</span></span><br><span class="line">        <span class="comment">// 同值路径就是左右同值树枝长度之和</span></span><br><span class="line">        res = Math.max(res, leftLen + rightLen);</span><br><span class="line">        <span class="comment">// 如果 root 本身和上级值不同，那么整棵子树都不可能有同值树枝</span></span><br><span class="line">        <span class="keyword">if</span> (root.val != parentVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现函数的定义：</span></span><br><span class="line">        <span class="comment">// 以 root 为根的二叉树从 root 开始值为 parentVal 的最长树枝长度</span></span><br><span class="line">        <span class="comment">// 等于左右子树的最长树枝长度的最大值加上 root 节点本身</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span> + Math.max(leftLen, rightLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-337-打家劫舍-III"><a href="#3-9-337-打家劫舍-III" class="headerlink" title="3.9 337. 打家劫舍 III"></a>3.9 <a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h3><p>给定二叉树的 root 。返回 <strong><em>在不触动警报的情况下\</em></strong> <em>，小偷能够盗取的最高金额</em> 。</p><p>如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//设置备忘录，记录打劫该点的最大收益</span></span><br><span class="line">    Map&lt;TreeNode, Integer&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 移除子问题</span></span><br><span class="line">        <span class="keyword">if</span>(memo.containsKey(root)) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo.get(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">doRob</span> <span class="operator">=</span> root.val</span><br><span class="line">                + (root.left == <span class="literal">null</span> ?</span><br><span class="line">                <span class="number">0</span> : rob(root.left.left) + rob(root.left.right))</span><br><span class="line">                + (root.right == <span class="literal">null</span> ?</span><br><span class="line">                <span class="number">0</span> : rob(root.right.left) + rob(root.right.right));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">notRob</span> <span class="operator">=</span> rob(root.left) + rob(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(doRob, notRob);</span><br><span class="line">        memo.put(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-10-671-二叉树中第二小的节点"><a href="#3-10-671-二叉树中第二小的节点" class="headerlink" title="3.10 671. 二叉树中第二小的节点"></a>3.10 <a href="https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/">671. 二叉树中第二小的节点</a></h3><p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归中止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">//如果为空节点，返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">//如果没有子节点，返回-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> root.left.val;  <span class="comment">//左节点的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> root.right.val;  <span class="comment">//右节点的值</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == left) left = findSecondMinimumValue(root.left);  <span class="comment">//如果左节点和根节点的值相同，第二小的从左子树上寻找</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == right) right = findSecondMinimumValue(root.right);  <span class="comment">//如果和右节点还是相同，则找出右子树的第二小</span></span><br><span class="line">        </span><br><span class="line">       <span class="comment">//返回情况</span></span><br><span class="line">        <span class="keyword">if</span>(left != -<span class="number">1</span> &amp;&amp; right != -<span class="number">1</span>) <span class="keyword">return</span> Math.min(left,right);  <span class="comment">//如果左右都不是-1，返回其中的最小</span></span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>) <span class="keyword">return</span> right;  <span class="comment">//如果左边没有，那就返回右边</span></span><br><span class="line">        <span class="keyword">return</span> left;<span class="comment">//否则返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-11-110-平衡二叉树"><a href="#3-11-110-平衡二叉树" class="headerlink" title="3.11 110. 平衡二叉树"></a>3.11 <a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxDepth(root);</span><br><span class="line">        <span class="keyword">return</span> isBalanced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录二叉树是否平衡</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isBalanced</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入一个节点，返回以该节点为根的二叉树的最大深度</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMaxDepth</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMaxDepth</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历位置</span></span><br><span class="line">        <span class="comment">// 如果左右最大深度大于 1，就不是平衡二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (Math.abs(rightMaxDepth - leftMaxDepth) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            isBalanced = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftMaxDepth, rightMaxDepth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-12-104-二叉树的最大深度"><a href="#3-12-104-二叉树的最大深度" class="headerlink" title="3.12 104. 二叉树的最大深度"></a>3.12 <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 前序遍历位置</span></span><br><span class="line">        depth++;</span><br><span class="line">        res = Math.max(res, depth);</span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line">        <span class="comment">// 后序遍历位置</span></span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：输入一个节点，返回以该节点为根的二叉树的最大深度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="comment">// 根据左右子树的最大深度推出原二叉树的最大深度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftMax, rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-13-129-求根节点到叶节点数字之和"><a href="#3-13-129-求根节点到叶节点数字之和" class="headerlink" title="3.13 129. 求根节点到叶节点数字之和"></a>3.13 <a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历一遍二叉树就能出结果</span></span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二叉树遍历函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历位置，记录节点值</span></span><br><span class="line">        path.append(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 到达叶子节点，累加路径和</span></span><br><span class="line">            res += Integer.parseInt(path.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二叉树递归框架，遍历左右子树</span></span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后续遍历位置，撤销节点值</span></span><br><span class="line">        path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-14-543-二叉树的直径"><a href="#3-14-543-二叉树的直径" class="headerlink" title="3.14 543. 二叉树的直径"></a>3.14 <a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDiameter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxDepth(root);</span><br><span class="line">        <span class="keyword">return</span> maxDiameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="comment">// 后序遍历位置顺便计算最大直径</span></span><br><span class="line">        maxDiameter = Math.max(maxDiameter, leftMax + rightMax);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftMax, rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-15-226-翻转二叉树"><a href="#3-15-226-翻转二叉树" class="headerlink" title="3.15 226. 翻转二叉树"></a>3.15 <a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 「遍历」的思路</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历二叉树，交换每个节点的子节点</span></span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二叉树遍历函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**** 前序位置 ****/</span></span><br><span class="line">        <span class="comment">// 每一个节点需要做的事就是交换它的左右子节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历框架，去遍历左右子树的节点</span></span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 「分解问题」的思路</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：将以 root 为根的这棵二叉树翻转，返回翻转后的二叉树的根节点</span></span><br><span class="line">    TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用函数定义，先翻转左右子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后交换左右子节点</span></span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和定义逻辑自恰：以 root 为根的这棵二叉树已经被翻转，返回 root</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-16-863-二叉树中所有距离为-K-的结点"><a href="#3-16-863-二叉树中所有距离为-K-的结点" class="headerlink" title="3.16 863. 二叉树中所有距离为 K 的结点"></a>3.16 <a href="https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/">863. 二叉树中所有距离为 K 的结点</a></h3><p>给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 k 。</p><p>返回到目标结点 target 距离为 k 的所有结点的值的列表。 答案可以以 任何顺序 返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录父节点：node.val -&gt; parentNode</span></span><br><span class="line">    <span class="comment">// 题目说了树中所有节点值都是唯一的，所以可以用 node.val 代表 TreeNode</span></span><br><span class="line">    HashMap&lt;Integer, TreeNode&gt; parent = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历所有节点，记录每个节点的父节点</span></span><br><span class="line">        traverse(root, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始从 target 节点施放 BFS 算法，找到距离为 k 的节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        q.offer(target);</span><br><span class="line">        visited.add(target.val);</span><br><span class="line">        <span class="comment">// 记录离 target 的距离</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dist</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span> (dist == k) &#123;</span><br><span class="line">                    <span class="comment">// 找到距离起点 target 距离为 k 的节点</span></span><br><span class="line">                    res.add(cur.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 向父节点、左右子节点扩散</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">parentNode</span> <span class="operator">=</span> parent.get(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (parentNode != <span class="literal">null</span> &amp;&amp; !visited.contains(parentNode.val)) &#123;</span><br><span class="line">                    visited.add(parentNode.val);</span><br><span class="line">                    q.offer(parentNode);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span> &amp;&amp; !visited.contains(cur.left.val)) &#123;</span><br><span class="line">                    visited.add(cur.left.val);</span><br><span class="line">                    q.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span> &amp;&amp; !visited.contains(cur.right.val)) &#123;</span><br><span class="line">                    visited.add(cur.right.val);</span><br><span class="line">                    q.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向外扩展一圈</span></span><br><span class="line">            dist++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, TreeNode parentNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parent.put(root.val, parentNode);</span><br><span class="line">        <span class="comment">// 二叉树递归框架</span></span><br><span class="line">        traverse(root.left, root);</span><br><span class="line">        traverse(root.right, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-17-617-合并二叉树"><a href="#3-17-617-合并二叉树" class="headerlink" title="3.17 617. 合并二叉树"></a>3.17 <a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果一棵树有，另一棵树没有，接上去</span></span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两棵树都有的节点，叠加节点值</span></span><br><span class="line">        root1.val += root2.val;</span><br><span class="line">        <span class="comment">// 递归合并左右子树</span></span><br><span class="line">        root1.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">        root1.right = mergeTrees(root1.right, root2.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-二叉搜索树"><a href="#4-二叉搜索树" class="headerlink" title="4 二叉搜索树"></a>4 二叉搜索树</h2><p>对于 BST 的每一个节点 node，左子树节点的值都比 node 的值要小，右子树节点的值都比 node 的值大。</p><h3 id="4-1-98-验证二叉搜索树"><a href="#4-1-98-验证二叉搜索树" class="headerlink" title="4.1 98. 验证二叉搜索树"></a>4.1 <a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 限定以 root 为根的子树节点必须满足 max.val &gt; root.val &gt; min.val */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST</span></span><br><span class="line">        <span class="keyword">if</span> (min != <span class="literal">null</span> &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (max != <span class="literal">null</span> &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 限定左子树的最大值是 root.val，右子树的最小值是 root.val</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left, min, root)</span><br><span class="line">            &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-230-二叉搜索树中第K小的元素"><a href="#4-2-230-二叉搜索树中第K小的元素" class="headerlink" title="4.2 230. 二叉搜索树中第K小的元素"></a>4.2 <a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h3><p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 利用 BST 的中序遍历特性</span></span><br><span class="line">    traverse(root, k);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 记录当前元素的排名</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rank</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traverse(root.left, k);</span><br><span class="line">    <span class="comment">/* 中序遍历代码位置 */</span></span><br><span class="line">    rank++;</span><br><span class="line">    <span class="keyword">if</span> (k == rank) &#123;</span><br><span class="line">        <span class="comment">// 找到第 k 小的元素</span></span><br><span class="line">        res = root.val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traverse(root.right, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-450-删除二叉搜索树中的节点"><a href="#4-3-450-删除二叉搜索树中的节点" class="headerlink" title="4.3 450. 删除二叉搜索树中的节点"></a>4.3 <a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h3><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种情况：</span></span><br><span class="line"><span class="comment">//无左子：其右子顶替其位置，删除了该节点；</span></span><br><span class="line"><span class="comment">//无右子：其左子顶替其位置，删除了该节点；</span></span><br><span class="line"><span class="comment">//左右子节点都有：左子树转移到其右子树的最左节点的左子树上</span></span><br><span class="line"><span class="comment">//然后右子树顶替其位置，由此删除了该节点。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">            <span class="comment">// 这两个 if 把情况 1 和 2 都正确处理了</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="comment">// 处理情况 3</span></span><br><span class="line">            <span class="comment">// 获得右子树最小的节点</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">minNode</span> <span class="operator">=</span> getMin(root.right);</span><br><span class="line">            <span class="comment">// 删除右子树最小的节点</span></span><br><span class="line">            root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">            <span class="comment">// 用右子树最小的节点替换 root 节点</span></span><br><span class="line">            minNode.left = root.left;</span><br><span class="line">            minNode.right = root.right;</span><br><span class="line">            root = minNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode <span class="title function_">getMin</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="comment">// BST 最左边的就是最小的</span></span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="literal">null</span>) node = node.left;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-96-不同的二叉搜索树"><a href="#4-4-96-不同的二叉搜索树" class="headerlink" title="4.4 96. 不同的二叉搜索树"></a>4.4 <a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h3><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录</span></span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 备忘录的值初始化为 0</span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> count(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt; hi) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 查备忘录</span></span><br><span class="line">        <span class="keyword">if</span> (memo[lo][hi] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[lo][hi];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo; mid &lt;= hi; mid++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> count(lo, mid - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> count(mid + <span class="number">1</span>, hi);</span><br><span class="line">            res += left * right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将结果存入备忘录</span></span><br><span class="line">        memo[lo][hi] = res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-108-将有序数组转换为二叉搜索树"><a href="#4-5-108-将有序数组转换为二叉搜索树" class="headerlink" title="4.5 108. 将有序数组转换为二叉搜索树"></a>4.5 <a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h3><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将闭区间 [left, right] 中的元素转化成 BST，返回根节点</span></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="comment">// 区间为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造根节点</span></span><br><span class="line">        <span class="comment">// BST 节点左小右大，中间的元素就是根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        <span class="comment">// 递归构建左子树</span></span><br><span class="line">        root.left = build(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归构造右子树</span></span><br><span class="line">        root.right = build(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-449-序列化和反序列化二叉搜索树"><a href="#4-6-449-序列化和反序列化二叉搜索树" class="headerlink" title="4.6 449. 序列化和反序列化二叉搜索树"></a>4.6 <a href="https://leetcode.cn/problems/serialize-and-deserialize-bst/">449. 序列化和反序列化二叉搜索树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="comment">// 分隔符，区分每个节点的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SEP</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        serialize(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历位置进行序列化</span></span><br><span class="line">        sb.append(root.val).append(SEP);</span><br><span class="line">        serialize(root.left, sb);</span><br><span class="line">        serialize(root.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 转化成前序遍历结果</span></span><br><span class="line">        LinkedList&lt;Integer&gt; inorder = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : data.split(SEP)) &#123;</span><br><span class="line">            inorder.offer(Integer.parseInt(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(inorder, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：将 nodes 中值在闭区间 [min, max] 的节点构造成一棵 BST</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">deserialize</span><span class="params">(LinkedList&lt;Integer&gt; nodes, <span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 前序遍历位置进行反序列化</span></span><br><span class="line">        <span class="comment">// 前序遍历结果第一个节点是根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> nodes.getFirst();</span><br><span class="line">        <span class="keyword">if</span> (rootVal &gt; max || rootVal &lt; min) &#123;</span><br><span class="line">            <span class="comment">// 超过闭区间 [min, max]，则返回空指针</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nodes.removeFirst();</span><br><span class="line">        <span class="comment">// 生成 root 节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">// 构建左右子树</span></span><br><span class="line">        <span class="comment">// BST 左子树都比根节点小，右子树都比根节点大</span></span><br><span class="line">        root.left = deserialize(nodes, min, rootVal);</span><br><span class="line">        root.right = deserialize(nodes, rootVal, max);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-669-修剪二叉搜索树"><a href="#4-7-669-修剪二叉搜索树" class="headerlink" title="4.7 669. 修剪二叉搜索树"></a>4.7 <a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h3><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据二叉搜索树的性质</span></span><br><span class="line"><span class="comment">// 一个节点小于 low，则左子树都要减掉</span></span><br><span class="line"><span class="comment">// 同样的处理大于情况</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：删除 BST 中小于 low 和大于 high 的所有节点，返回结果 BST</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; low) &#123;</span><br><span class="line">            <span class="comment">// 直接返回 root.right</span></span><br><span class="line">            <span class="comment">// 等于删除 root 以及 root 的左子树</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; high) &#123;</span><br><span class="line">            <span class="comment">// 直接返回 root.left</span></span><br><span class="line">            <span class="comment">// 等于删除 root 以及 root 的右子树</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 闭区间 [lo, hi] 内，不处理当前节点，递归子树</span></span><br><span class="line">        root.left = trimBST(root.left, low, high);</span><br><span class="line">        root.right = trimBST(root.right, low, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-173-二叉搜索树迭代器"><a href="#4-8-173-二叉搜索树迭代器" class="headerlink" title="4.8 173. 二叉搜索树迭代器"></a>4.8 <a href="https://leetcode.cn/problems/binary-search-tree-iterator/">173. 二叉搜索树迭代器</a></h3><p>实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟递归栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;TreeNode&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一路到底，把根节点和它的所有左节点放到栈中；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushLeftBranch</span><span class="params">(TreeNode p)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            stk.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        pushLeftBranch(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 弹出栈顶节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> stk.pop();</span><br><span class="line">        pushLeftBranch(p.right);</span><br><span class="line">        <span class="keyword">return</span> p.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !stk.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-9-1305-两棵二叉搜索树中的所有元素"><a href="#4-9-1305-两棵二叉搜索树中的所有元素" class="headerlink" title="4.9 1305. 两棵二叉搜索树中的所有元素"></a>4.9 <a href="https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/">1305. 两棵二叉搜索树中的所有元素</a></h3><p>给你 root1 和 root2 这两棵二叉搜索树。请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getAllElements</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">// BST 有序迭代器</span></span><br><span class="line">        <span class="type">BSTIterator</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSTIterator</span>(root1);</span><br><span class="line">        <span class="type">BSTIterator</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSTIterator</span>(root2);</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 类似合并有序链表的算法逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (t1.hasNext() &amp;&amp; t2.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t1.peek() &gt; t2.peek()) &#123;</span><br><span class="line">                res.add(t2.next());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(t1.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有一棵 BST 还剩元素，添加到最后</span></span><br><span class="line">        <span class="keyword">while</span> (t1.hasNext()) &#123;</span><br><span class="line">            res.add(t1.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (t2.hasNext()) &#123;</span><br><span class="line">            res.add(t2.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BST 有序迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 左侧树枝一撸到底</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushLeftBranch</span><span class="params">(TreeNode p)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            stk.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        pushLeftBranch(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stk.peek().val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> stk.pop();</span><br><span class="line">        pushLeftBranch(p.right);</span><br><span class="line">        <span class="keyword">return</span> p.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !stk.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-10-1038-从二叉搜索树到更大和树"><a href="#4-10-1038-从二叉搜索树到更大和树" class="headerlink" title="4.10 1038. 从二叉搜索树到更大和树"></a>4.10 <a href="https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/">1038. 从二叉搜索树到更大和树</a></h3><p>给定一个二叉搜索树 root (BST)，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">bstToGst</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录累加和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root.right);</span><br><span class="line">        <span class="comment">// 维护累加和</span></span><br><span class="line">        sum += root.val;</span><br><span class="line">        <span class="comment">// 将 BST 转化成累加树</span></span><br><span class="line">        root.val = sum;</span><br><span class="line">        traverse(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-11-1373-二叉搜索子树的最大键值和"><a href="#4-11-1373-二叉搜索子树的最大键值和" class="headerlink" title="4.11 1373. 二叉搜索子树的最大键值和"></a>4.11 <a href="https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/">1373. 二叉搜索子树的最大键值和</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、左右子树是否是 BST。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、左子树的最大值和右子树的最小值。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、左右子树的节点值之和。</span><br><span class="line"></span><br><span class="line">想要获得子树的信息，就要用到前文 手把手刷二叉树总结篇 说过的后序位置的妙用了。</span><br><span class="line"></span><br><span class="line">我们定义一个 traverse 函数，traverse(root) 返回一个大小为 <span class="number">4</span> 的 <span class="type">int</span> 数组，我们暂且称它为 res，其中：</span><br><span class="line"></span><br><span class="line">res[<span class="number">0</span>] 记录以 root 为根的二叉树是否是 BST，若为 <span class="number">1</span> 则说明是 BST，若为 <span class="number">0</span> 则说明不是 BST；</span><br><span class="line"></span><br><span class="line">res[<span class="number">1</span>] 记录以 root 为根的二叉树所有节点中的最小值；</span><br><span class="line"></span><br><span class="line">res[<span class="number">2</span>] 记录以 root 为根的二叉树所有节点中的最大值；</span><br><span class="line"></span><br><span class="line">res[<span class="number">3</span>] 记录以 root 为根的二叉树所有节点值之和。</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 全局变量，记录 BST 最大节点之和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主函数 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] traverse(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;</span><br><span class="line">                    <span class="number">1</span>, Integer.MAX_VALUE, Integer.MIN_VALUE, <span class="number">0</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归计算左右子树</span></span><br><span class="line">        <span class="type">int</span>[] left = traverse(root.left);</span><br><span class="line">        <span class="type">int</span>[] right = traverse(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*******后序遍历位置*******/</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">// 这个 if 在判断以 root 为根的二叉树是不是 BST</span></span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; right[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp;</span><br><span class="line">                root.val &gt; left[<span class="number">2</span>] &amp;&amp; root.val &lt; right[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">// 以 root 为根的二叉树是 BST</span></span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 计算以 root 为根的这棵 BST 的最小值</span></span><br><span class="line">            res[<span class="number">1</span>] = Math.min(left[<span class="number">1</span>], root.val);</span><br><span class="line">            <span class="comment">// 计算以 root 为根的这棵 BST 的最大值</span></span><br><span class="line">            res[<span class="number">2</span>] = Math.max(right[<span class="number">2</span>], root.val);</span><br><span class="line">            <span class="comment">// 计算以 root 为根的这棵 BST 所有节点之和</span></span><br><span class="line">            res[<span class="number">3</span>] = left[<span class="number">3</span>] + right[<span class="number">3</span>] + root.val;</span><br><span class="line">            <span class="comment">// 更新全局变量</span></span><br><span class="line">            maxSum = Math.max(maxSum, res[<span class="number">3</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 以 root 为根的二叉树不是 BST</span></span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 其他的值都没必要计算了，因为用不到</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**************************/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-12-面试题-04-06-后继者"><a href="#4-12-面试题-04-06-后继者" class="headerlink" title="4.12 面试题 04.06. 后继者"></a>4.12 <a href="https://leetcode.cn/problems/successor-lcci/">面试题 04.06. 后继者</a></h3><p>找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。</p><ul><li>若有 root.val &lt;= p.val : 根据 BST 特性可知当前节点 root 及其左子树子节点均满足「值小于等于 p.val」，因此不可能是 p 点的后继，我们直接到 root 的右子树搜索 p 的后继（递归处理）；</li><li>若有 root.val &gt; p.val : 当第一次搜索到满足此条件的节点时，在以 root 为根节点的子树中「位于最左下方」的值为 p 的后继，但也有可能 root 没有左子树，因此 p 的后继要么在 root 的左子树中（若有），要么是 root 本身，此时我们可以直接到 root 的左子树搜索，若搜索结果为空返回 root，否则返回搜索结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= p.val) <span class="keyword">return</span> inorderSuccessor(root.right, p);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">ans</span> <span class="operator">=</span> inorderSuccessor(root.left, p);</span><br><span class="line">        <span class="keyword">return</span> ans == <span class="literal">null</span> ? root : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-13-109-有序链表转换二叉搜索树"><a href="#4-13-109-有序链表转换二叉搜索树" class="headerlink" title="4.13 109. 有序链表转换二叉搜索树"></a>4.13 <a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></h3><p>给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用快慢指针寻找中间值（需要找到中间节点的前一个节点）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedListToBST</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//有下面两种边界问题</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(head.val);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">preMid</span> <span class="operator">=</span> helper(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> preMid.next;</span><br><span class="line">        preMid.next = <span class="literal">null</span>;<span class="comment">//从这里断开链表</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(mid.val);</span><br><span class="line">        root.left = sortedListToBST(head);</span><br><span class="line">        root.right = sortedListToBST(mid.next);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//寻找preMid</span></span><br><span class="line">    ListNode <span class="title function_">helper</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next.next;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-14-剑指26-二叉搜索树与双向链表"><a href="#4-14-剑指26-二叉搜索树与双向链表" class="headerlink" title="4.14 剑指26.二叉搜索树与双向链表"></a>4.14 剑指26.二叉搜索树与双向链表</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><p>思路：</p><p>线索化二叉树。类似于中序遍历构建。</p><p>由于正向构建时，指针会移动到尾部，因此反向构建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Convert</span><span class="params">(TreeNode pRootOfTree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">            pRootOfTree.right = pre;</span><br><span class="line">            pre.left = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pRootOfTree;</span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-15-653-给定一个二叉搜索树和一个目标结果，如果-BST-中存在两个元素且它们的和等于给定的目标结果，则返回-true。"><a href="#4-15-653-给定一个二叉搜索树和一个目标结果，如果-BST-中存在两个元素且它们的和等于给定的目标结果，则返回-true。" class="headerlink" title="4.15 653.给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。"></a>4.15 653.给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findTarget</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; inOrder = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inOrder(root, inOrder);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = inOrder.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> inOrder.get(left) + inOrder.get(right);</span><br><span class="line">            <span class="keyword">if</span>(sum == k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; k) right--;</span><br><span class="line">            <span class="keyword">else</span> left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; inOrder)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left, inOrder);</span><br><span class="line">        inOrder.add(root.val);</span><br><span class="line">        inOrder(root.right, inOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-16-501-给定一个有相同值的二叉搜索树（BST），找出-BST-中的所有众数（出现频率最高的元素）。"><a href="#4-16-501-给定一个有相同值的二叉搜索树（BST），找出-BST-中的所有众数（出现频率最高的元素）。" class="headerlink" title="4.16 501.给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。"></a>4.16 501.给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</h3><p>如果众数超过1个，不需考虑输出顺序。</p><p>你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><p>思路：</p><p>毫无疑问，同样使用中序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">//存储最小值</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">preNode</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//存储前一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="keyword">if</span>(preNode != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//后一个节点肯定大于前一个节点</span></span><br><span class="line">            min = Math.min(cur - preNode.val, min);</span><br><span class="line">        preNode = root;</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 常用操作</title>
      <link href="/2021/06/12/Basic/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/06/12/Basic/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="一、git-工作流程"><a href="#一、git-工作流程" class="headerlink" title="一、git 工作流程"></a>一、git 工作流程</h1><p>git 有四个区域:</p><ul><li>3个本地区域<ul><li>工作区(Workspace): 存放项目代码的地方。</li><li>暂存区(Stage): 存放临时的改动, 事实上它只是一个文件, 保存即将提交的文件列表信息。</li><li>资源库(Repository): 安全存放数据的位置, 这里面有提交到所有版本的数据。其中 HEAD 指向最新放入仓库的版本。</li></ul></li><li>1个远程区域<ul><li>远程库(Remote): 托管代码的服务器。</li></ul></li></ul><p><img src="../../img/git/git区域.png" alt="git区域"></p><h1 id="二、git-初始化"><a href="#二、git-初始化" class="headerlink" title="二、git 初始化"></a>二、git 初始化</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> git-study &amp;&amp; <span class="built_in">cd</span> git-study</span><br><span class="line">$ git init</span><br><span class="line">$ <span class="built_in">ls</span> -la</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x   3 kino  staff   96 11 23 17:18 .</span><br><span class="line">drwxr-xr-x  16 kino  staff  512 11 23 17:18 ..</span><br><span class="line">drwxr-xr-x   9 kino  staff  288 11 23 17:18 .git</span><br></pre></td></tr></table></figure><p>创建成功之后, 会出现一个 <code>.git</code> 的隐藏文件夹, 这个就是这个项目的 git 仓库, 以后所有的 git 操作历史提交记录信息全都在此, 只要这个文件夹还存在, 就可以记住我们所有的 git 操作。</p><h1 id="三、git-配置相关常用命令"><a href="#三、git-配置相关常用命令" class="headerlink" title="三、git 配置相关常用命令"></a>三、git 配置相关常用命令</h1><h2 id="1-git-config"><a href="#1-git-config" class="headerlink" title="1 git config"></a>1 git config</h2><p>查看 git 配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">credential.helper=osxkeychain</span><br><span class="line">user.name=kino</span><br><span class="line">user.email=kino@gmail.com</span><br><span class="line">core.autocrlf=input</span><br><span class="line">core.quotepath=<span class="literal">false</span></span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=<span class="literal">true</span></span><br><span class="line">core.bare=<span class="literal">false</span></span><br><span class="line">core.logallrefupdates=<span class="literal">true</span></span><br><span class="line">core.ignorecase=<span class="literal">true</span></span><br><span class="line">core.precomposeunicode=<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>修改 git 配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config -e            <span class="comment"># 针对当前仓库</span></span><br><span class="line">$ git config -e --global   <span class="comment"># 针对系统上的所有仓库</span></span><br></pre></td></tr></table></figure><br>设置提交代码时的用户信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;yourUserName&quot;</span>     <span class="comment"># 去掉 --global 就只对当前仓库生效</span></span><br><span class="line">$ git config --gloabl user.email <span class="string">&quot;yourEmail&quot;</span>       <span class="comment"># 去掉 --global 就只对当前仓库生效</span></span><br></pre></td></tr></table></figure></p><h1 id="四、git-日常操作"><a href="#四、git-日常操作" class="headerlink" title="四、git 日常操作"></a>四、git 日常操作</h1><p><a href="#411-git-add"><code>git add</code>: 将文件添加到暂存区</a></p><p><a href="#412-git-status"><code>git status</code>: 查看在你上次提交之后是否有对文件进行再次修改</a></p><p><a href="#413-git-diff"><code>git diff</code>: 比较文件在暂存区和工作区的差异</a></p><p><a href="#414-git-status"><code>git ls-files</code>: 查看暂存区的文件</a></p><p><a href="#415-git-status"><code>git cat-file -p</code>: 查看暂存区文件中的内容</a></p><p><a href="#416-git-status"><code>git commit</code>: 提交暂存区文件到本地仓库</a></p><p><a href="#417-git-rm"><code>git rm</code>: 删除文件</a></p><h2 id="1-提交代码"><a href="#1-提交代码" class="headerlink" title="1 提交代码"></a>1 提交代码</h2><h3 id="1-1-git-add"><a href="#1-1-git-add" class="headerlink" title="1.1 git add"></a>1.1 git add</h3><p>语法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 该命令可以将文件添加到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加指定目录到暂存区</span></span><br><span class="line">$ git add [<span class="built_in">dir</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 添加当前目录下所有文件进入暂存区</span></span><br><span class="line">$ git add .</span><br></pre></td></tr></table></figure><br>示例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> 1.txt 2.txt 3.txt 4.txt</span><br><span class="line">$ ll </span><br><span class="line">total 8</span><br><span class="line">-rw-r--r--  1 kino  staff   0  7  5 18:30 1.txt</span><br><span class="line">-rw-r--r--  1 kino  staff   0  7  5 18:30 2.txt</span><br><span class="line">-rw-r--r--  1 kino  staff   0  7  5 18:31 3.txt</span><br><span class="line">-rw-r--r--  1 kino  staff   0  7  5 18:31 4.txt</span><br><span class="line">-rw-r--r--  1 kino  staff  13  7  5 18:30 README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 1.txt 和 2.txt 进入暂存区</span></span><br><span class="line">$ git add 1.txt 2.txt</span><br></pre></td></tr></table></figure></p><h3 id="1-2-git-status"><a href="#1-2-git-status" class="headerlink" title="1.2 git status"></a>1.2 git status</h3><p>查看在你上次提交之后是否有对文件进行再次修改。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$ git status </span><br><span class="line">On branch main</span><br><span class="line">Your branch is up to <span class="built_in">date</span> with <span class="string">&#x27;origin/main&#x27;</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">new file:   1.txt</span><br><span class="line">new file:   2.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">3.txt</span><br><span class="line">4.txt</span><br><span class="line"></span><br><span class="line">$ git status -s </span><br><span class="line">A  1.txt</span><br><span class="line">A  2.txt</span><br><span class="line">?? 3.txt</span><br><span class="line">?? 4.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;提交&quot;</span></span><br><span class="line">[main 26c1139] 提交</span><br><span class="line"> 2 files changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 1.txt</span><br><span class="line"> create mode 100644 2.txt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> 11111 &gt;&gt; 1.txt</span><br><span class="line">$ <span class="built_in">echo</span> 33333 &gt;&gt; 3.txt</span><br><span class="line">$ git add 3.txt</span><br><span class="line"></span><br><span class="line">$ git status -s </span><br><span class="line"> M 1.txt</span><br><span class="line">AM 3.txt</span><br><span class="line">?? 4.txt</span><br></pre></td></tr></table></figure></p><ul><li>A 表示新提交</li><li>M 表示提交过，并且本地又修改了</li><li>AM 表示有改动</li></ul><h3 id="1-3-git-diff"><a href="#1-3-git-diff" class="headerlink" title="1.3 git diff"></a>1.3 git diff</h3><p>比较文件的不同, 即比较文件在暂存区和工作区的差异</p><p>git diff 显示已经写入暂存区和已经被修改但尚未写入暂存区文件的区别</p><p>应用场景:</p><ol><li>尚未缓存的改动: git diff</li><li>查看已经缓存的改动: git diff —cached</li><li>查看缓存成功和未缓存的所有改动: git diff HEAD</li><li>显示摘要而非整个diff: git diff —stat</li></ol><p>删除原来的项目重新clone<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> -rf git-study</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> git-study</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> 1111 &gt;&gt; README.md</span><br><span class="line">$ git add . &amp;&amp; git commit -m <span class="string">&quot;readme&quot;</span> </span><br><span class="line">$ <span class="built_in">echo</span> 2222 &gt;&gt; README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看暂未添加至缓存区的改动</span></span><br><span class="line">$ git diff</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 5f2f16b..4f142ee 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> 1111</span><br><span class="line">+2222</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示简略信息</span></span><br><span class="line">$ git diff --<span class="built_in">stat</span></span><br><span class="line"> README.md | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已经添加至缓存区的改动</span></span><br><span class="line">$ git add README.md</span><br><span class="line">$ git diff --cached</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 5f2f16b..4f142ee 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> 1111</span><br><span class="line">+2222</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看不在缓存区 &amp; 在缓存区的改动</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 5f2f16b..4f142ee 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> 1111</span><br><span class="line">+2222</span><br></pre></td></tr></table></figure></p><h3 id="1-4-git-ls-files"><a href="#1-4-git-ls-files" class="headerlink" title="1.4 git ls-files"></a>1.4 git ls-files</h3><p>查看暂存区的文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-files</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure><br>可选参数:</p><ul><li>-c: 默认</li><li>-d: 显示删除的文件</li><li>-m: 显示被修改过的文件</li><li>-o: 显示没有被 git 跟踪过的文件</li><li>-s: 显示 mode 以及对应的 Blog对象, 进而可以获取暂存区中对应文件的内容</li></ul><h3 id="1-5-git-cat-file-p"><a href="#1-5-git-cat-file-p" class="headerlink" title="1.5 git cat-file -p"></a>1.5 git cat-file -p</h3><p>查看暂存区文件中的内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-files -s</span><br><span class="line">100644 5cf7833392d65968a05971b9923f36a1ec46d7f7 0       README.md</span><br><span class="line"></span><br><span class="line">$ git cat-file -p  5cf7</span><br><span class="line">1111</span><br><span class="line">2222</span><br></pre></td></tr></table></figure></p><h3 id="1-6-git-commit"><a href="#1-6-git-commit" class="headerlink" title="1.6 git commit"></a>1.6 git commit</h3><p>提交暂存区文件到本地仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m [message]</span><br></pre></td></tr></table></figure><br>提交暂存区的指定文件到本地仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br></pre></td></tr></table></figure></p><h3 id="1-7-git-rebase"><a href="#1-7-git-rebase" class="headerlink" title="1.7 git rebase"></a>1.7 git rebase</h3><ul><li>变基提交,用来重写提交历史</li><li>基于 master 的 a 新建的分支,后面 master 又有了 c 提交,rebase 后分支的更新就是基于 c 了<h3 id="1-8-git-stash"><a href="#1-8-git-stash" class="headerlink" title="1.8 git stash"></a>1.8 git stash</h3></li><li>保存当前工作进度，会把暂存区和工作区的改动保存到一个未完结变更的堆栈中；执行完这个命令后，在运行 <code>git status</code> 命令，就会发现当前是一个干净的工作区，没有任何改动<h3 id="1-9-git-rm"><a href="#1-9-git-rm" class="headerlink" title="1.9 git rm"></a>1.9 git rm</h3><code>git rm</code> 用于删除文件</li></ul><p>1、将文件从暂存区和工作区中删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">rm</span> 1.txt 2.txt</span><br></pre></td></tr></table></figure><br>2、将文件从暂存区和工作区中强制删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以加上 -f, 表示强制删除之前修改过而且 add 到暂存区的文件</span></span><br><span class="line">$ git <span class="built_in">rm</span> -f 1.txt 2.txt</span><br></pre></td></tr></table></figure><br>3、将文件从暂存区删除，在工作区保留<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached 1.txt 2.txt</span><br></pre></td></tr></table></figure></p><h2 id="2-分支操作"><a href="#2-分支操作" class="headerlink" title="2 分支操作"></a>2 分支操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看分支</span></span><br><span class="line">$ git branch -a </span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于当前分支创建一个新分支</span></span><br><span class="line">$ git checkout -b feature/hotfix-001</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于指定分支创建一个新的分支</span></span><br><span class="line">$ git checkout -b feature/hotfix-002 master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换分支</span></span><br><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d feature/hotfix-001</span><br></pre></td></tr></table></figure><h2 id="3-更新操作"><a href="#3-更新操作" class="headerlink" title="3 更新操作"></a>3 更新操作</h2><p>@TODO</p><h2 id="4-合并冲突"><a href="#4-合并冲突" class="headerlink" title="4 合并冲突"></a>4 合并冲突</h2><p>简单制造一个冲突<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 再迁出一个分支(模拟其他人的修改操作)</span></span><br><span class="line">$ git checkout -b feature/hotfix-001 feature/hotfix-002</span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line">$ <span class="built_in">echo</span> 3333 &gt;&gt; README.md</span><br><span class="line">$ git add README.md</span><br><span class="line">$ git commit -m <span class="string">&quot;hotfix-001: add newline&quot;</span></span><br><span class="line"><span class="comment"># 合并到master</span></span><br><span class="line">$ git checkout master </span><br><span class="line">$ git merge feature/hotfix-001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git checkout feature/hotfix-002</span><br><span class="line">$ vim README.md</span><br><span class="line"><span class="comment"># 在第三行添加</span></span><br><span class="line">3344</span><br><span class="line">$ git add README.md</span><br><span class="line">$ git commit -m <span class="string">&quot;hotfix-002: add newline&quot;</span></span><br><span class="line"></span><br><span class="line">$ git checkout master</span><br><span class="line"><span class="comment"># 再合并代码就会出现冲突提示</span></span><br><span class="line"><span class="comment"># 这个时候不可以进行任何分支切换和commit操作，需要按照提示将冲突解决。</span></span><br><span class="line">$ git merge feature/hotfix-002</span><br><span class="line">Auto-merging README.md</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> README.md</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><br>查看冲突文件内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vim README.md</span><br><span class="line">1111</span><br><span class="line">2222</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string">3333</span></span><br><span class="line"><span class="string">=======</span></span><br><span class="line"><span class="string">3344</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/hotfix-002</span></span><br></pre></td></tr></table></figure></p><ul><li>从 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> 开始, 到 <code>=======</code> 都是主分支已经存在的内容。</li><li>从 <code>=======</code> 开始, 到 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/hotfix-002</code> 都是 merge 过来的分支的内容。</li></ul><p>解决冲突，视情况保留(删除)记录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ vim README.md</span><br><span class="line">1111</span><br><span class="line">2222</span><br><span class="line">3333</span><br><span class="line">3344</span><br><span class="line"></span><br><span class="line"><span class="comment"># 冲突解决完成之后, 再次提交代码</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看变更记录</span></span><br><span class="line">commit 8715c66d8ca756077040ce6d783c6caf470d115e (HEAD -&gt; master)</span><br><span class="line">Merge: b89c0c5 ba903ae</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Wed Nov 23 18:29:17 2022 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">&#x27;feature/hotfix-002&#x27;</span></span><br><span class="line"></span><br><span class="line">commit ba903aebecb447d6f485108f0321b15f6c009886 (feature/hotfix-002)</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Wed Nov 23 18:19:54 2022 +0800</span><br><span class="line"></span><br><span class="line">    hotfix-002: add newline</span><br><span class="line"></span><br><span class="line">commit b89c0c592ba11894acb2cd93564c5e43934065fb (feature/hotfix-001)</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Wed Nov 23 18:16:23 2022 +0800</span><br><span class="line"></span><br><span class="line">    hotfix-001: add newline</span><br></pre></td></tr></table></figure></p><h2 id="5-暂存代码保护现场"><a href="#5-暂存代码保护现场" class="headerlink" title="5 暂存代码保护现场"></a>5 暂存代码保护现场</h2><p>项目经理提了一个新的需求, 开发就需要从 master 分支迁出一个新的分支进行功能开发(例如迁出新分支为dev), 如果在开发过程工, 生产上有紧急 bug 需要修复, 就可以用到 <code>git stash</code> 了。</p><p><code>git stash</code> 可以将现在的 <strong>工作区</strong>全部的修改、新增、删除等操作，全部保存起来。</p><p><code>git stash</code> 的常用命令:</p><ol><li><code>git stash save &#39;save message&#39;</code>: 执行存储时, 添加备注, 方便查找, 当然只执行 <code>git stash</code> 也是可以的, 但查找时不方便。</li><li><code>git stash list</code>: 查看 stash 了哪些存储。</li><li><code>git stash show</code>: 显示做了哪些改动, 默认 show 第一个存储, 如果要显示其他的存储, 后面加 <code>stash@&#123;$num&#125;</code>, 比如第二个: <code>git stash show stash@&#123;1&#125;</code></li><li><code>git stast show -p</code>: 显示第一个存储的改动, 如果想显示其他存储, 则: <code>git stash show stash@&#123;$num&#125; -p</code>, 比如第二个: <code>git stash show stash@&#123;1&#125; -p</code></li><li><code>git stash apply</code>: 应用某个存储, 但不会把存储从存储列表中删除, 默认使用第一个存储, 即 <code>stash@&#123;0&#125;</code>, 如果要是用其他, 则: <code>git stash apply stash@&#123;$num&#125;</code>, 比如第二个: <code>git stash apply stash@&#123;1&#125;</code></li><li><code>git stash pop</code>: 恢复之前缓存的工作目录, 将缓存列表中对应的 stash 删除, 并将对应修改应用到当前的工作目录下, 默认为第一个 stash, 即 <code>stash@&#123;0&#125;</code>, 如果要应用并删除其他 stash, 则: <code>git stash pop stash@&#123;$num&#125;</code>, 比如应用并删除第二个: <code>git stash pop stash@&#123;1&#125;</code></li><li><code>git stash drop stash@&#123;num&#125;</code>: 丢弃 <code>stash@&#123;num&#125;</code> 存储, 从列表中删除这个存储</li><li><code>git stash clear</code>: 删除所有缓存的 stash</li></ol><p>开始模拟现场<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git 初始化</span></span><br><span class="line">$ <span class="built_in">cd</span> .. &amp;&amp; <span class="built_in">rm</span> -rf git-study &amp;&amp; <span class="built_in">mkdir</span> git-study &amp;&amp; <span class="built_in">cd</span> git-study &amp;&amp; git init</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;file1 init&#x27;</span> &gt; file1.txt</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;file2 init&#x27;</span> &gt; file2.txt</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&#x27;change: add file1 &amp; file2&#x27;</span></span><br><span class="line">[master (root-commit) 525c358] change: add file1 &amp; file2</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 file1.txt</span><br><span class="line"> create mode 100644 file2.txt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 然后从 master 分支创建两个新的 feature 分支</span></span><br><span class="line">$ git branch feature1</span><br><span class="line">$ git branch feature2</span><br><span class="line"></span><br><span class="line"><span class="comment"># checkout feature1, 修改 file1.txt, 并在 feature1 上创建两次提交</span></span><br><span class="line">$ git checkout feature1</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;add file1.txt code 1&#x27;</span> &gt;&gt; file1.txt</span><br><span class="line">$ git add file1.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;change file1 no.1&#x27;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;add file2.txt code 2&#x27;</span> &gt;&gt; file1.txt</span><br><span class="line">$ git add file1.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;change file1 no.2&#x27;</span></span><br><span class="line"><span class="comment"># 目前 feature1 上的改动内容</span></span><br><span class="line">$ <span class="built_in">cat</span> file1.txt</span><br><span class="line">file1 init</span><br><span class="line">add file1.txt code 1</span><br><span class="line">add file2.txt code 2</span><br><span class="line">$ <span class="built_in">cat</span> file2.txt</span><br><span class="line">file2 init</span><br><span class="line"></span><br><span class="line"><span class="comment"># checkout feature2, 修改 file2.tx</span></span><br><span class="line">$ git checkout feature2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;add file2.txt code 1&#x27;</span> &gt;&gt; file2.txt</span><br><span class="line">$ git add file2.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;change file2 no.1&#x27;</span></span><br><span class="line"><span class="comment"># 目前 feature2 上的改动内容</span></span><br><span class="line">$ <span class="built_in">cat</span> file1.txt</span><br><span class="line">file1 init</span><br><span class="line">$ <span class="built_in">cat</span> file2.txt</span><br><span class="line">file2 init</span><br><span class="line">add file2.txt code 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设不小心将 feature2 合并到了 feature1, 并在 feature1 继续进行了代码开发并提交</span></span><br><span class="line">$ git checkout feature1</span><br><span class="line">$ git merge feature2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;add file1.txt no.3 &amp; code end&#x27;</span> &gt;&gt; file1.txt</span><br><span class="line">$ git add file1.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;change file1 no.3&#x27;</span></span><br><span class="line"><span class="comment"># 此时 feature1 上所有文件的内容</span></span><br><span class="line">$ <span class="built_in">cat</span> file1.txt</span><br><span class="line">file1 init</span><br><span class="line">add file1.txt code 1</span><br><span class="line">add file2.txt code 2</span><br><span class="line">add file1.txt no.3 &amp; code end</span><br><span class="line">$ <span class="built_in">cat</span> file2.txt</span><br><span class="line">file2 init</span><br><span class="line">add file2.txt code 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时我们发现了不小心 merge 进来的 feature2, 而且在这基础上我们还有新的 commit, 如果我们想将 merge 剔除, 可以做如下操作</span></span><br><span class="line"><span class="comment"># 先查看需要还原 commit 的版本号</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">8a1454f (HEAD -&gt; feature1) change file1 no.3</span><br><span class="line">422a454 Merge branch <span class="string">&#x27;feature2&#x27;</span> into feature1</span><br><span class="line">4978e2c (feature2) change file2 no.1</span><br><span class="line">ee4a50e change file1 no.2</span><br><span class="line">dc397c1 change file1 no.1</span><br><span class="line">525c358 (master) change: add file1 &amp; file2</span><br><span class="line"><span class="comment"># 其中, 422a454 就是误合并的 commitid</span></span><br><span class="line"><span class="comment"># 目前我们需要做的就是撤销已提交的 commit, 回滚到 feature2 误合并到 feature1 分支的 commit 版本。</span></span><br><span class="line">$ git reset --mixed 422a454</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">Mfile1.txt</span><br><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">422a454 (HEAD -&gt; feature1) Merge branch <span class="string">&#x27;feature2&#x27;</span> into feature1</span><br><span class="line">4978e2c (feature2) change file2 no.1</span><br><span class="line">ee4a50e change file1 no.2</span><br><span class="line">dc397c1 change file1 no.1</span><br><span class="line">525c358 (master) change: add file1 &amp; file2</span><br><span class="line">$ git diff file1.txt</span><br><span class="line">diff --git a/file1.txt b/file1.txt</span><br><span class="line">index 4a1ca46..6954af7 100644</span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ b/file1.txt</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> file1 init</span><br><span class="line"> add file1.txt code 1</span><br><span class="line"> add file2.txt code 2</span><br><span class="line">+add file1.txt no.3 &amp; code end   <span class="comment">## 可以看见, feature1 最后一次提交已经是未暂存状态了</span></span><br><span class="line"><span class="comment"># 此时, 我们就可以使用 git stash, 将撤销的代码存储起来, </span></span><br><span class="line">$ git stash save <span class="string">&#x27;save file1.txt reset code&#x27;</span></span><br><span class="line">Saved working directory and index state On feature1: save file1.txt reset code</span><br><span class="line"><span class="comment"># 查看 stash 列表</span></span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: On feature1: save file1.txt reset code</span><br><span class="line"><span class="comment"># 查看 status, 可以看见在工作空间已经没有了</span></span><br><span class="line">$ git status </span><br><span class="line">On branch feature1</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后再撤销 merge 相关的信息</span></span><br><span class="line">$ git reset --hard HEAD~</span><br><span class="line"><span class="comment"># 再查看此时本地的文件内容</span></span><br><span class="line">$ <span class="built_in">cat</span> file1.txt</span><br><span class="line">file1 init</span><br><span class="line">add file1.txt code 1</span><br><span class="line">add file2.txt code 2</span><br><span class="line">$ <span class="built_in">cat</span> file2.txt</span><br><span class="line">file2 init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来恢复 feature1 上被撤销的代码</span></span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: On feature1: save file1.txt reset code</span><br><span class="line">$ git stash apply stash&#123;0&#125;</span><br><span class="line">On branch feature1</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">modified:   file1.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line"><span class="comment"># 此时代码就恢复回来了</span></span><br><span class="line">$ <span class="built_in">cat</span> file1.txt</span><br><span class="line">file1 init</span><br><span class="line">add file1.txt code 1</span><br><span class="line">add file2.txt code 2</span><br><span class="line">add file1.txt no.3 &amp; code end</span><br></pre></td></tr></table></figure><br>说明: git stash会贮存及不会贮存的文件范围</p><ul><li>会贮存: <ul><li>添加到暂存区的修改（staged changes）</li><li>git跟踪的但并未添加到暂存区的修改（unstaged changes）</li></ul></li><li>不会贮存:<ul><li>在工作目录中新的文件（untracked files）</li><li>被忽略的文件（ignored files）</li></ul></li></ul><p>当然, 如果仅仅需要 删除某个 commit, 其实有更好的方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设, 当前已经到了 git commit -m &#x27;change file1 no.3&#x27;, 当前 log </span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 3e6be928866581f1779bb0f0e84d29d068d698e8 (HEAD -&gt; feature1)</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 24 23:30:31 2022 +0800</span><br><span class="line"></span><br><span class="line">    change file1 no.3</span><br><span class="line"></span><br><span class="line">commit ef733ffec4e80ed851f353f2d8b2dba46b831bb6</span><br><span class="line">Merge: 5e96765 7d9cebd</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 24 23:30:29 2022 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">&#x27;feature2&#x27;</span> into feature1</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以直接 git revert 指定的 commit, 例如 上面 merge 的 commit id 是 ef733ffec4e80ed851f353f2d8b2dba46b831bb6</span></span><br><span class="line">$ git revert -i ef733ffec4e80ed851f353f2d8b2dba46b831bb6 -m 1</span><br><span class="line"><span class="comment"># 注意, 已经要加上 -m 1, 否则会报如下错:</span></span><br><span class="line"><span class="comment">#   error: commit ef733ffec4e80ed851f353f2d8b2dba46b831bb6 is a merge but no -m option was given.</span></span><br><span class="line"><span class="comment">#   fatal: revert failed</span></span><br><span class="line"><span class="comment"># 在这里解释下 -m 1 的含义:</span></span><br><span class="line"><span class="comment">#   从上面的 git log 可以看见 &quot;Merge: 5e96765 7d9cebd&quot; 的信息, 这代表着, 本次 merge 是使用当前分支的 5e96765(commit) 和 feature2 分支的 7d9cebd(commit) 合并而来, 我们可以做一下验证:</span></span><br><span class="line"><span class="comment">#     # 首先 cat-file 5e96765</span></span><br><span class="line"><span class="comment">#     $ git cat-file -p 5e96765</span></span><br><span class="line"><span class="comment">#     tree fa6ff2fd55be9834b45f0be9d347b1670594ed17</span></span><br><span class="line"><span class="comment">#     parent d27c172b6e876938eb39094801ca5e436a30b3c3</span></span><br><span class="line"><span class="comment">#     author kino &lt;kino@gmail.com&gt; 1669303829 +0800</span></span><br><span class="line"><span class="comment">#     committer kino &lt;kino@gmail.com&gt; 1669303829 +0800</span></span><br><span class="line"><span class="comment">#     change file1 no.2</span></span><br><span class="line"><span class="comment">#    # 然后取 tree 的 id 继续查看, 可以看到, 这个 tree 记录该 commit 的两个文件</span></span><br><span class="line"><span class="comment">#    $ git cat-file -p fa6ff2fd55be9834b45f0be9d347b1670594ed17</span></span><br><span class="line"><span class="comment">#    100644 blob 4a1ca461271ec4e0041822373470703dca5d0626file1.txt</span></span><br><span class="line"><span class="comment">#    100644 blob 18ffc0add953f06f00be32437b9f79e09af27d32file2.txt</span></span><br><span class="line"><span class="comment">#    # 然后取 file2.txt 的 id 继续查看, 可以看到, 这个 tree 记录 该 file2.txt 的内容为: file2 init</span></span><br><span class="line"><span class="comment">#    $ git cat-file -p 18ffc0add953f06f00be32437b9f79e09af27d32</span></span><br><span class="line"><span class="comment">#    file2 init</span></span><br><span class="line"><span class="comment">#    # 然后我们再 cat-file 7d9cebd</span></span><br><span class="line"><span class="comment">#    tree 1b5c42acd113046ec223223affe7b3ef579a293b</span></span><br><span class="line"><span class="comment">#    parent 9acd7882175075c0f3e2f44dfa0d91f3d0a673d1</span></span><br><span class="line"><span class="comment">#    author kino &lt;kino@gmail.com&gt; 1669303829 +0800</span></span><br><span class="line"><span class="comment">#    committer kino &lt;kino@gmail.com&gt; 1669303829 +0800</span></span><br><span class="line"><span class="comment">#    change file2 no.1</span></span><br><span class="line"><span class="comment">#    # 然后取 tree 的 id 继续查看, 可以看到, 这个 tree 记录该 commit 的两个文件</span></span><br><span class="line"><span class="comment">#    git cat-file -p 1b5c42acd113046ec223223affe7b3ef579a293b</span></span><br><span class="line"><span class="comment">#    100644 blob 0c481f7fe4602d041634c353e31846bf1b638c37file1.txt</span></span><br><span class="line"><span class="comment">#    100644 blob c6b0b29e598db81ef8e54ec955df78cfac4ae316file2.txt</span></span><br><span class="line"><span class="comment">#    # 然后取 file2.txt 的 id 继续查看, 可以看到, 这个 tree 记录 该 file2.txt 的内容</span></span><br><span class="line"><span class="comment">#    git cat-file -p c6b0b29e598db81ef8e54ec955df78cfac4ae316</span></span><br><span class="line"><span class="comment">#    file2 init</span></span><br><span class="line"><span class="comment">#    add file2.txt code 1</span></span><br><span class="line"><span class="comment"># 由此我们可以得出结论, 5e96765 就是 feature1 在 Merge 之前的状态, 而 7d9cebd 就是 feature2 在 Merge 之前的状态。</span></span><br><span class="line"><span class="comment"># 因为 一个 Merge 记录了两个分支的 commit 信息, 所以, 在 revert merge 的时候,需要明确的支出, 要revert 到哪个commit, 因为我们是想取消 feature2 里面的内容, 所以就是 -m 1 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ok, 回到正题, git revert 之后, 我们再查看 log</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">b4dde93 (HEAD -&gt; feature1) Revert <span class="string">&quot;Merge branch &#x27;feature2&#x27; into feature1&quot;</span></span><br><span class="line">3e6be92 change file1 no.3</span><br><span class="line">ef733ff Merge branch <span class="string">&#x27;feature2&#x27;</span> into feature1</span><br><span class="line">5e96765 change file1 no.2</span><br><span class="line">7d9cebd (feature2) change file2 no.1</span><br><span class="line">d27c172 change file1 no.1</span><br><span class="line">9acd788 (master) change: add file1 &amp; file2</span><br><span class="line"><span class="comment"># 然后查看 file2.txt</span></span><br><span class="line">$ <span class="built_in">cat</span> file2.txt</span><br><span class="line">file2 init</span><br></pre></td></tr></table></figure></p><h1 id="五、git-高级操作"><a href="#五、git-高级操作" class="headerlink" title="五、git 高级操作"></a>五、git 高级操作</h1><h2 id="1-git-撤销操作"><a href="#1-git-撤销操作" class="headerlink" title="1 git 撤销操作"></a>1 git 撤销操作</h2><p><strong>disk</strong></p><div class="table-container"><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>查看修改</td><td><code>git diff</code></td></tr><tr><td>查看状态</td><td><code>git status</code> -&gt; <code>Changes not staged for comit</code></td></tr><tr><td>撤销文件修改</td><td><code>git checkout &lt;change_file&gt;  or git restore &lt;change_file&gt;</code></td></tr><tr><td>提交暂存区</td><td>git add <change_file></td></tr></tbody></table></div><p><strong>暂存区</strong></p><div class="table-container"><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>查看状态</td><td><code>git status</code> -&gt; <code>Changes to be committed(绿色)</code></td></tr><tr><td>从暂存区移除，但保留硬盘上的修改</td><td><code>git reset &lt;change_file&gt;</code> or <code>git restore --staged &lt;change_file&gt;</code></td></tr><tr><td>从暂存区移除，不保留硬盘上的修改</td><td><code>git checkout HEAD &lt;change_file&gt;</code></td></tr><tr><td>提交本地git</td><td><code>git commit</code></td></tr></tbody></table></div><p><strong>local</strong></p><div class="table-container"><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>撤销commit(保留磁盘上的修改和暂存区记录)</td><td><code>git reset --soft HEAD~1</code></td></tr><tr><td>撤销commit(清除暂存区记录, 只保留磁盘上的修改)</td><td><code>git reset HEAD~1</code> == <code>git reset --mixed HEAS~1</code></td></tr><tr><td>撤销commit(清除暂存区记录, 清除磁盘上的修改)</td><td><code>git reset --hard HEAD~1</code></td></tr><tr><td>生成新的<code>commitId</code>,将上一个<code>commit+</code>的内容变成<code>commit-</code></td><td><code>git revert HEAD</code></td></tr><tr><td>提交远端git</td><td><code>git push</code></td></tr></tbody></table></div><p><code>git reset</code> &amp; <code>git revert</code>:</p><ol><li><code>git reset</code>: 只能回到之前某一个commit的状态。</li><li><code>git revert</code>:撤销中间任意一个commit。<code>git revert 70a0;(git revert HEAD~1)</code></li></ol><p>如果操作项目的分支是公共分支，只能通过 <code>git revert</code> 生成一个新的 commitId，从这个结果上撤销我们之前的修改。</p><ol><li><code>git revert HEAD</code></li><li><code>git push</code></li></ol><p>如果操作项目的分支是个人分支，可以通过<code>git reset</code>撤销我们之前的修改</p><ol><li><code>git reset --hard HEAD~1</code></li><li><code>git push -f</code></li></ol><h2 id="2-git-找回丢失文件-commit了"><a href="#2-git-找回丢失文件-commit了" class="headerlink" title="2 git 找回丢失文件(commit了)"></a>2 git 找回丢失文件(commit了)</h2><p>恢复因为执行 <code>git reset --hard COMMITID</code> 丢失的文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新创建一个项目</span></span><br><span class="line">$ <span class="built_in">cd</span> .. &amp;&amp; <span class="built_in">rm</span> -rf git-study &amp;&amp; <span class="built_in">mkdir</span> git-study &amp;&amp; <span class="built_in">cd</span> git-study &amp;&amp; git init</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;master message 1&#x27;</span> &gt;&gt; master_1.txt</span><br><span class="line">$ git add master_1.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;first commit&#x27;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;master message 2&#x27;</span> &gt;&gt; master_2.txt</span><br><span class="line">$ git add master_2.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;No.2 commit&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这两次commit的基础上, reset 到第一次(first commit)上</span></span><br><span class="line">$ git <span class="built_in">log</span>   <span class="comment"># 获取第一次commitid</span></span><br><span class="line">$ git reset --hard 4a9bcb880db85a1ca77807dea9b3adce29dc4fda</span><br><span class="line"><span class="comment"># 再次查看 log 信息, 此时可以看见只有一次commit了, 第二次 commit(No.2 commit) 已经丢失</span></span><br><span class="line">$ git <span class="built_in">log</span> -n 2</span><br></pre></td></tr></table></figure><br>git 提供了 <code>git reflog</code> 用来记录你的每一次改变目录树的命令，使用好他就可以很方便的恢复你的提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4a9bcb8 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 4a9bcb880db85a1ca77807dea9b3adce29dc4fda</span><br><span class="line">80258ce HEAD@&#123;1&#125;: commit: No.2 commit</span><br><span class="line">4a9bcb8 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): first commit</span><br></pre></td></tr></table></figure><br>可以看到最上面一条记录是将 HEAD 重新指向第一次的commit了, 同时也有显示第二次 commit 的 commitid, 有了这个 commitid, 就可以回滚了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 80258ce</span><br><span class="line">HEAD is now at 80258ce No.2 commit</span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 80258ce0146f373d15a1991d61af4061687782bc (HEAD -&gt; master)</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 24 02:26:10 2022 +0800</span><br><span class="line"></span><br><span class="line">    No.2 commit</span><br><span class="line"></span><br><span class="line">commit 4a9bcb880db85a1ca77807dea9b3adce29dc4fda</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 24 02:25:06 2022 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure><br>可以看到, commit 已被找回.</p><p>但是通常情况下, 可能会出现在 <code>git reset</code> 之后, 还有新的 commit, 如果直接 <code>reset</code> 恢复的 commit, 肯定会造成新的 commit 又丢失, 所以如果我们只是想恢复这个一个 commit, 可以使用 <code>git cherry-pick commitid</code> 来单独将这个 commitid 恢复到当前分支或者用 <code>git merge</code> 来做合并<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git cherry-pick 04b0396</span><br><span class="line">[master fbf401a] No.2 commit</span><br><span class="line"> Date: Thu Nov 24 02:38:14 2022 +0800</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 master_2.txt</span><br><span class="line"> </span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit fbf401a96bd9831c18ed02e9ee852cef8111ccb1 (HEAD -&gt; master)</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 24 02:38:14 2022 +0800</span><br><span class="line"></span><br><span class="line">    No.2 commit</span><br><span class="line"></span><br><span class="line">commit 1b5bfdb36ad01fb86d94b76654347f5de5475f37</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 24 02:38:05 2022 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure></p><h2 id="3-git-找回丢失文件-未commit-但添加暂存区了"><a href="#3-git-找回丢失文件-未commit-但添加暂存区了" class="headerlink" title="3 git 找回丢失文件(未commit,但添加暂存区了)"></a>3 git 找回丢失文件(未commit,但添加暂存区了)</h2><p>如果只 <code>git add</code> 了没有 <code>git commit</code>(如果连 <code>git add</code>都没有, 那只能找磁盘数据恢复的方式了), 这就不是仅仅一个 <code>git reflog</code> 就能找回的了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> .. &amp;&amp; <span class="built_in">rm</span> -rf git-study &amp;&amp; <span class="built_in">mkdir</span> git-study &amp;&amp; <span class="built_in">cd</span> git-study &amp;&amp; git init</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;master message 1&#x27;</span> &gt;&gt; master_1.txt</span><br><span class="line">$ git add master_1.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;first commit&#x27;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;master message 2&#x27;</span> &gt;&gt; master_2.txt</span><br><span class="line">$ git add master_2.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;No.2 commit&#x27;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;master message 3&#x27;</span> &gt;&gt; master_3.txt</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 log</span></span><br><span class="line">$ git <span class="built_in">log</span> -n 2</span><br><span class="line"><span class="comment"># 取最新的一次 commit id</span></span><br><span class="line">$ git reset --hard ee614a48f753479a111723ae7ad926e0750ffa6c</span><br><span class="line"><span class="comment"># 查看 status</span></span><br><span class="line">$ git status </span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"><span class="comment"># 查看本地文件</span></span><br><span class="line">total 16</span><br><span class="line">-rw-r--r--  1 kino  staff    17B 11 24 02:43 master_1.txt</span><br><span class="line">-rw-r--r--  1 kino  staff    17B 11 24 02:43 master_2.txt</span><br><span class="line"><span class="comment"># 可以看见文件已经丢了</span></span><br></pre></td></tr></table></figure><br>git 提供了 <code>git fsck --lost-found</code> 命令, 他会通过一些神奇的方式把历史操作过的文件以某种算法算出来加到.git/lost-found文件夹里，输出的记录就像下面这个样子。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ git fsck --lost-found</span><br><span class="line">Checking object directories: 100% (256/256), <span class="keyword">done</span>.</span><br><span class="line">dangling blob adbd4c8bf64367fb685336a67f02c5716dc47d73</span><br></pre></td></tr></table></figure><br>这里返回的第一行带有 <code>blob</code> 的信息，我们可以用 <code>git show</code>来查看里面的内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git show adbd4c8bf64367fb685336a67f02c5716dc47d73</span><br><span class="line">master message 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比如可以将内容追加到新文件中 </span></span><br><span class="line">$ git show adbd4c8bf64367fb685336a67f02c5716dc47d73 &gt; master_3.txt</span><br></pre></td></tr></table></figure></p><p>小记: 如果你的提交记录多的话, <code>git fsck --lost-found</code> 可以看见很多内容, 如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ git fsck --lost-found</span><br><span class="line">Checking object directories: 100% (256/256), <span class="keyword">done</span>.</span><br><span class="line">Checking objects: 100% (35559/35559), <span class="keyword">done</span>.</span><br><span class="line">dangling blob 601e8abff177a0b2f8a31944654c0cdf0dd1f197</span><br><span class="line">dangling tree 6c247c35ae51aa86736f745802bb59b97b6598ee</span><br><span class="line">dangling blob 7a379e6f07391f3bca1fbcc076fcde8f719ffb69</span><br><span class="line">dangling blob c66fa02bf74853789b63615a80998b3fbd3d8823</span><br><span class="line">dangling blob 4996ec43a907f8f6312c3bf137e2f76c7f4c9c9c</span><br><span class="line">dangling commit 69a110054ca792e6b1060d20ec24ddc9710ada4d</span><br><span class="line">dangling blob 87ed1263b56d0a98cd163440f872f135a34b61da</span><br><span class="line">dangling blob aff0bc224d142929e3f82b8855dd1e97d8b3635b</span><br><span class="line">dangling blob eef114f8614a15a11ccfbb7cf5e34302072176e1</span><br><span class="line">dangling blob b50db5dad43e13fde45141039f684be48e293739</span><br><span class="line">dangling blob 820f0136b61394e482fd18e28a7ba81fbb31f688</span><br><span class="line">dangling blob 2d26cd809139b86218d3460c85baed90d018f007</span><br><span class="line">dangling blob 603ca9d770947939d8da7ff3aef3775bb27c427e</span><br><span class="line">dangling blob e54821ed942c6582d01f60b6715e16301cdcfc4d</span><br><span class="line">dangling blob e06be73bb272c7837ab38226c1c1bb13f845574e</span><br><span class="line">dangling blob 399aede4e687465bf7c895251bef685b0de089b6</span><br><span class="line">dangling blob 5ea2239d63a9a119a54a52fde6ebf208a940832a</span><br><span class="line">dangling blob 35ab95c7faf42b7dbbf4e0992527c719ffd4acbd</span><br><span class="line">dangling blob 9bb609de693b78eb1dc0e3dca7a9d684effd3f4a</span><br><span class="line">dangling blob aac499592477199b2630791aecde2db8a608dfa9</span><br><span class="line">dangling commit 10c581dcdf08ea1bed594a359e09698afd4f794e</span><br><span class="line">dangling blob 06eb7790a9f71bf796749940102030c6e9503022</span><br></pre></td></tr></table></figure><br>可以看到这里有<code>blob</code>、<code>commit</code>、<code>tree</code>类型的数据，其实还有<code>tag</code>等类型的, 这里需要了解下 git 的底层存储</p><ul><li><code>commit</code> 数据结构在每次提交之后都会生成一个, 当我们进行 <code>commit</code> 之后, 首先会创建一个 <code>commit</code> 组件, 之后创建一个 <code>tree</code> 组件, 把所有的文件信息都存在里面, 每个 <code>blob</code> 都代表一个文件, 都可以在 <code>tree</code> 里面找到。</li><li><code>blob</code> 组件并不会对文件信息进行存储, 而是只对文件的内容进行记录, 文件信息存储在 <code>tree</code> 里.</li></ul><h2 id="4-终极大招"><a href="#4-终极大招" class="headerlink" title="4 终极大招"></a>4 终极大招</h2><p>如果 5.3 并没有找到你想要的内容, 那只能再去看看最近修改的文件了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects -<span class="built_in">type</span> f | xargs <span class="built_in">ls</span> -lt | sed 3q</span><br><span class="line">-r--r--r--  1 kino  staff   33 11 24 02:43 .git/objects/ad/bd4c8bf64367fb685336a67f02c5716dc47d73</span><br><span class="line">-r--r--r--  1 kino  staff   33 11 24 02:43 .git/objects/cc/6e4eeea4f70e784fade7a18bdba6c28f7642e8</span><br><span class="line">-r--r--r--  1 kino  staff   33 11 24 02:43 .git/objects/24/b6cb352efeff7a2b24b99e8ff814ab1fc2a2fd</span><br></pre></td></tr></table></figure><br>使用 <code>git cat-file -t commitid</code> 可以看见是什么类型的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t adbd4c8bf64367fb685336a67f02c5716dc47d73</span><br><span class="line">blob</span><br><span class="line"></span><br><span class="line">$ git cat-file -t cc6e4eeea4f70e784fade7a18bdba6c28f7642e8</span><br><span class="line">blob</span><br><span class="line"></span><br><span class="line">$ git cat-file -t 24b6cb352efeff7a2b24b99e8ff814ab1fc2a2fd</span><br><span class="line">blob</span><br></pre></td></tr></table></figure><br>再使用 <code>git cat-file -p commitid</code> 查看内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p adbd4c8bf64367fb685336a67f02c5716dc47d73</span><br><span class="line">master message 3</span><br><span class="line"></span><br><span class="line">$ git cat-file -p cc6e4eeea4f70e784fade7a18bdba6c28f7642e8</span><br><span class="line">master message 2</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 24b6cb352efeff7a2b24b99e8ff814ab1fc2a2fd</span><br><span class="line">master message 1</span><br></pre></td></tr></table></figure></p><h2 id="5-git-迁移-保留-commit"><a href="#5-git-迁移-保留-commit" class="headerlink" title="5 git 迁移(保留 commit)"></a>5 git 迁移(保留 commit)</h2><h3 id="5-1-clone-原来的项目"><a href="#5-1-clone-原来的项目" class="headerlink" title="5.1 clone 原来的项目"></a>5.1 clone 原来的项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --bare git://github.com/username/project.git</span><br></pre></td></tr></table></figure><h3 id="5-2-推送到新的gitlab"><a href="#5-2-推送到新的gitlab" class="headerlink" title="5.2 推送到新的gitlab"></a>5.2 推送到新的gitlab</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> project</span><br><span class="line">$ git push --mirror git@example.com/username/newproject.git</span><br></pre></td></tr></table></figure><p>会提示没有权限, 在gitlab中把项目的权限保护关掉就好了</p><h3 id="5-3-本地代码更换gitlab地址"><a href="#5-3-本地代码更换gitlab地址" class="headerlink" title="5.3 本地代码更换gitlab地址"></a>5.3 本地代码更换gitlab地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote set-url origin git@example.com/username/newproject.git</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>links</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
