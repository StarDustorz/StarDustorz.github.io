<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[DDIA] 批处理</title>
      <link href="/2023/08/10/DDIA/09%20%E6%89%B9%E5%A4%84%E7%90%86/"/>
      <url>/2023/08/10/DDIA/09%20%E6%89%B9%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<blockquote><p>批处理系统通常会接受大量数据作为输入，然后基于这些数据执行任务，进而产生一些数据作为输出。</p></blockquote><span id="more"></span><p>web 服务和日趋增长的基于 HTTP/REST 的 API，让请求/应答风格的交互如此普遍，以至于我们理所当然的认为系统就应该长这样。但须知，这并非构建系统的唯一方式，其他方法也各有其应用场景。我们来对下面三种类型系统进行考察：</p><ul><li><strong>服务（在线系统，online systems）</strong> 服务（service）类型的系统会等待客户端发来的请求或指令。当收到一个请求时，服务会试图尽快的处理它，然后将返回应答。<strong>响应时间</strong>通常是衡量一个服务性能的最主要指标，且<strong>可用性</strong>通常很重要（如果客户端不能够触达服务，则用户可能会收到一条报错消息）。之前章节我们主要在讨论此类系统。</li><li><strong>批处理系统（离线系统，offline systems）</strong> 一个批处理系统通常会接受大量数据作为输入，然后在这批数据上跑<strong>任务</strong>（job），进而产生一些数据作为输出。任务通常会运行一段时间（从数分钟到数天不等），因此一般来说没有用户会死等任务结束。相反，批处理任务通常会周期性的执行（例如，每天一次）。<strong>吞吐量</strong>（throughput，处理单位数据量所耗费的时间）通常是衡量批处理任务最主要指标。本章会主要围绕该类型系统进行讨论。</li><li><strong>流式系统（近实时系统，near-real-time systems）</strong> 流式处理介于在线处理和离线处理（批处理）之间（因此也被称为<strong>近实时</strong>，near-real-time，或者<strong>准在线处理</strong>，nearline processing）。和批处理系统一样，流式处理系统接受输入，产生一些输出（而不是对请求做出响应，因此更像批处理而非服务）。然而，一个流式任务通常会在事件产生不久后就对其进行处理，与之相对，一个批处理任务通常会<strong>攒够一定尺寸</strong>的输入数据才会进行处理。这种区别让流式处理系统比同样功能的批处理系统具有更低的延迟。由于流式处理基于批处理，因此我们下一章再讨论它。</li></ul><p>批处理是寻求构建<strong>可靠的、可扩展的、可维护</strong>的应用的重要组成部分。</p><h2 id="1-使用Unix工具进行批处理"><a href="#1-使用Unix工具进行批处理" class="headerlink" title="1 使用Unix工具进行批处理"></a>1 使用Unix工具进行批处理</h2><p>有一个 web 服务器，并且当有请求进来时，服务器就会向日志文件中追加一行日志：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">216.58</span><span class="number">.210</span><span class="number">.78</span> - - [<span class="number">27</span>/Feb/<span class="number">2015</span>:<span class="number">17</span>:<span class="number">55</span>:<span class="number">11</span> +<span class="number">0000</span>] <span class="string">&quot;GET /css/typography.css HTTP/1.1&quot;</span> <span class="number">200</span> <span class="number">3377</span> <span class="string">&quot;http://martin.kleppmann.com/&quot;</span> <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_9_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/40.0.2214.115 Safari/537.36&quot;</span></span><br></pre></td></tr></table></figure></p><p>在 2015 年的 2 月 27 号，UTC 时间 ，服务器从 IP 为 216.58.210.78 的客户端收到了一条请求，请求路径为 <code>/css/typography.css</code>。该用户没有经过认证，因此用户位置显示了一个连字符（-）。响应状态码是 200（即，该请求成功了），响应大小是 3377 字节。web 浏览器是 Chrome 49，由于该资源在 <a href="http://martin.kleppmann.com/">http://martin.kleppmann.com/</a> 网站中被引用，因此浏览器加载了该 CSS 文件。</p><h3 id="1-1-简单的日志分析"><a href="#1-1-简单的日志分析" class="headerlink" title="1.1 简单的日志分析"></a>1.1 简单的日志分析</h3><p>获取<strong>网站上访问频次最高的五个页面</strong>，则可以在 Unix Shell 中输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> /var/log/nginx/access.log | <span class="comment">#(1)</span></span><br><span class="line">      awk <span class="string">&#x27;&#123;print $7&#125;&#x27;</span> |        <span class="comment">#(2)</span></span><br><span class="line">      <span class="built_in">sort</span>             |        <span class="comment">#(3)</span></span><br><span class="line">      <span class="built_in">uniq</span> -c          |        <span class="comment">#(4)</span></span><br><span class="line">      <span class="built_in">sort</span> -r -n       |        <span class="comment">#(5)</span></span><br><span class="line">      <span class="built_in">head</span> -n 5                 <span class="comment">#(6)</span></span><br></pre></td></tr></table></figure></p><p>每一行作用如下：</p><ol><li>读取给定日志文件</li><li>将每一行按空格分成多个字段，然后取出第七个，即我们关心的 URL 字段。在上面的例子中，即：<code>/css/typography.css</code></li><li>按字符序对所有 url 进行排序。如果某个 url 出现了 n 次，则排序后他们会连着出现 n 次。</li><li><code>uniq</code> 命令会将输入中相邻的重复行过滤掉。<code>-c</code> 选项告诉命令输出一个计数：对于每个 URL，输出其重复的次数。</li><li>第二个 <code>sort</code> 命令会按每行起始数字进行排序（<code>-n</code>），即按请求次数多少进行排序。<code>-r</code> 的意思是按出现次数降序排序，不加该参数默认是升序的。</li><li>最后，<code>head</code> 命令会只输出前 5 行，丢弃其他多余输入。<br>比如，如果你想<strong>在输出中跳过 CSS 文件</strong>，可以将 awk 的参数改成 <code>&#39;$7 !~ /\.css$/ &#123;print $7&#125;&#39;</code> 。如果你想<strong>统计最常访问的 IP 数</strong>而非访问网页，则可以将 awk 的参数变为 <code>&#39;&#123;print $1&#125;&#39;</code>。如此种种。</li></ol><h4 id="1-1-1-排序-vs-内存聚合"><a href="#1-1-1-排序-vs-内存聚合" class="headerlink" title="1.1.1 排序 vs 内存聚合"></a>1.1.1 排序 vs 内存聚合</h4><p>Ruby 脚本在内存中保存了 URL 的<strong>哈希表</strong>，记录每个 URL 到其出现次数的映射。Unix 管道例子中并没有这样一个哈希表。作为替代，它将所有 URL 进行<strong>排序</strong>，从而让所有相同的 URL 聚集到一块，从而对 URL 出现次数进行统计。</p><p>如果工作集足够小，则基于内存的哈希表能够很好地工作<br>但如果，任务的工作集大于可用内存，则排序方式更有优势，因为能够充分利用磁盘空间。</p><h3 id="1-2-Unix-哲学"><a href="#1-2-Unix-哲学" class="headerlink" title="1.2 Unix 哲学"></a>1.2 Unix 哲学</h3><ol><li><strong>每一个程序专注干一件小事</strong>。在想做一个新任务时，新造一个轮子，而非向已有的程序中增加新的“功能”。</li><li><strong>每个程序的输出成为其他程序（即便下一个程序还没有确定）的输入</strong>。不要在输出中混入无关信息（比如在数据中混入日志信息），避免使用严格的列式数据（数据要面向行，以行为最小粒度？）或者二进制数据格式。不要使用<strong>交互式输入</strong>。</li><li><strong>尽快的设计和构建软件</strong>，即便复杂如操作系统，也最好在几周内完成（译注：这里翻译稍微有些歧义，即到底是尽快迭代还是尽早让用户试用，当然他们最终思想差不多，即构造最小可用模型，试用-迭代）。对于丑陋部分，不要犹豫，立即推倒重构。</li><li>（Q：unskilled help是指？这一条没太理解）<strong>相比不成熟的帮助，更倾向于使用工具完成编程任务</strong>，即使可能会进行反复构建相似的工具，并且在用完之后大部分工具就再也不会用到。<br>尽可能自动化、快速原型验证、小步增量迭代、易于实验测试，将大型工程拆解成一组易于管理的模块</li></ol><h4 id="1-2-1-统一的接口"><a href="#1-2-1-统一的接口" class="headerlink" title="1.2.1 统一的接口"></a>1.2.1 统一的接口</h4><p>如果你想让任意程序的输出能接到任意程序的输入上，则意味着<strong>所有</strong>这些程序必须使用同样的<strong>输入输出</strong>接口。<br>在 Unix 中，这种接口是<strong>文件</strong>（a file，更准确的说，是文件描述符，file descriptor）。文件本质上是一种<strong>有序的字节序列</strong>。<br><code>awk</code>，<code>sort</code>，<code>uniq</code> 和 <code>head</code> 都将其输入文件视为由 <code>\n</code>（换行符，ASCII 码是 0x0A）分割的一系列记录。</p><h2 id="2-MapReduce和分布式文件系统"><a href="#2-MapReduce和分布式文件系统" class="headerlink" title="2 MapReduce和分布式文件系统"></a>2 MapReduce和分布式文件系统</h2><p>一个 MapReduce 任务就像一个 Unix 进程：<strong>接受一到多个输入，产生一到多个输出</strong>。<br>和 Unix 工具一样，执行一个 MapReduce 任务<strong>不会修改输入文件</strong>，并且除了产生输出<strong>没有其他的副作用</strong>。输出文件都是<strong>单次写入、顺序追加</strong>而成（即 ，一旦文件写完，就不会再有任何改动）。<br>相比 Unix 工具使用 stdin 和 stdout 作为输入和输出，MapReduce 任务的输入和输出都是<strong>分布式文件系统上的文件</strong>。在 Hadoop 的 MapReduce 实现中，该文件系统被称为 HDFS（Hadoop Distributed File System），是谷歌文件系统（GFS，Google File System）的一个开源实现。</p><p>HDFS 基本设计理念是：<strong>shared-nothing</strong> （机器间不共享任何特殊硬件，纯通过网络来通信）架构。HDFS 和<strong>对象存储</strong>不同点之一是，HDFS 能够将计算<strong>就近的</strong>调度到存储所在的机器上（调度亲和性，本质原因在于计算和存储在同一个集群，有好处也有劣势），但对象存储会将存储和计算分离。</p><p>HDFS 由一组运行在每个主机上的<strong>守护进程</strong>（Daemon Process）组成，对外暴露网络接口，以使其他的节点可以访问存储于本机的数据文件（假设数据中心中的通用机器节点上都附有一定数量的磁盘）。一个叫做 <strong>NameNode</strong> 的<strong>中心节点</strong>会保存文件块和其所在机器的映射（也即文件块的 placement 信息）。因此，HDFS 可以利用所有运行有守护进程的机器上（<strong>DataNode</strong>）存储空间，在逻辑上对外提供单一且巨大的文件系统抽象。</p><h3 id="2-1-MapReduce-任务执行"><a href="#2-1-MapReduce-任务执行" class="headerlink" title="2.1 MapReduce 任务执行"></a>2.1 MapReduce 任务执行</h3><ol><li><strong>读取一组输入文件，将其切分为记录（records）</strong>。在网站服务器日志的例子中，每个记录就是日志中的一行（即，使用 \n 作为记录分隔符）</li><li><strong>调用 Mapper 函数从每个记录中抽取 key 和 value</strong>。在之前的例子中，mapper 函数是 <code>awk &#39;&#123;print $7&#125;&#39;</code> ：抽取 URL（$7）作为 key，value 留空。</li><li><strong>将所有的 key-value 对按 key 进行排序</strong>。在前面例子中，该环节由 sort 承担。</li><li><strong>调用 Reducer 函数对排好序的 kv 列表迭代处理</strong>。如果某个 key 出现了多次，排序环节会让其在在列表中集中到一块，因此可以在不在内存中保存过多状态的的情况下，对具有相同 key 的数据进行汇总处理。在前面例子中，reducer 对应命令 <code>uniq -c</code> ，功能是对所有具有相同 key 的记录值进行计数。<br>这四个步骤（split-map-sort-reduce）可以通过一个 MapReduce 任务来实现。你可以在步骤 2 （map）和步骤 4（reduce）编写代码来自定义数据处理逻辑。步骤 1 （将文件拆分成记录）由<strong>输入格式解析器</strong>（input format parser）来完成。步骤 3，排序阶段，由 MapReduce 框架<strong>隐式完成</strong>，所有 Mapper 的输出在给到 Reducer 前，框架都会对其进行排序。</li></ol><p>需要实现两个回调函数：mapper 和 reducer，其行为如下：</p><ul><li><strong>Mapper</strong> 对于每个输入<strong>记录</strong>都会调用一次 Mapper 函数，其任务是从记录中抽取 key 和 value。对于每一个输入记录，都有可能产生任意数量（包括 0 个）的 kv 对。框架不会保存任何<strong>跨记录的状态</strong>，因此每个记录都可以独立的被处理（即 Mapper 可以进行任意并发的运行）。</li><li><strong>Reducer</strong> MapReduce 框架会拿到 Mapper 输出的 kv 对，通过排序将具有相同 key 的 value 聚集到一块，以迭代器的形式给到 Reducer 函数。reducer 会继续输出一组新的记录（如 URL 的出现频次）。</li></ul><h4 id="2-1-1-MapReduce-的分布式执行"><a href="#2-1-1-MapReduce-的分布式执行" class="headerlink" title="2.1.1 MapReduce 的分布式执行"></a>2.1.1 MapReduce 的分布式执行</h4><p>与 Unix 工具流水线的相比，MapReduce 的最大区别在于可以在<strong>多台机器上</strong>进行分布式的执行，但并不需要用户显式地写处理并行的代码。mapper 和 Reducer 函数每次只处理一个记录；他们不必关心输入从哪里来，输出要到哪里去，框架会处理分布式系统所带来的的复杂度</p><p>每个输入文件通常有数百 M，每个输入通常有多个副本，分散在多个机器上。MapReduce 的调度器（图中没有显示）在调度时，会在这多个副本所在机器上选择一个具有足够内存和 CPU 资源运行该 Mapper 任务的机器，将 map 任务调度过去。这个策略也被称为：<strong>将计算调度到数据上</strong>。从而省去在网络中拷贝数据的环节，提高了局部性，减少了网络带宽消耗。</p><p>多数情况下，<strong>应用层的代码</strong>通常不会存在于 map 任务调度到的机器上。因此，MapReduce 框架首先会将用户代码（如对于 Java 来说就是 Jar 包）<strong>序列化后</strong>复制过去。然后在对应机器上，动态加载这些代码，继而执行 map 任务。读取输入文件，逐个解析数据记录（record），传给 Mapper 回调函数执行。每个 Mapper 会产生一组 key-value 对。</p><p>reduce 侧的计算也是分片的。对于 MapReduce 任务来说，<strong>map 任务的数量</strong>，取决于该任务的输入文件数（或者文件 block 数）的数量；<strong>但 reduce 任务的多少</strong>，可以由用户显式的配置（可以不同于 map 任务的数量）。为了保证所有具有相同 key 的 kv 对被同一个 Reducer 函数处理，框架会使用哈希函数，将所有 Mapper 的输出的 kv 对进行分桶（桶的数量就是 Reducer 的数量），进而路由到对应的 Reducer 函数。</p><p>根据 MapReduce 的设定，reducer 接受的 kv 对需要是有序的，但任何传统的排序算法都无法在单机上对如此大尺度的数据进行排序。为了解决这个问题，mapper 和 Reducer 间的<strong>排序被分成多个阶段</strong>。</p><p>首先，每个 map 任务在输出时，会先将所有输出哈希后分片（一个分片对应一个 reducer），然后在每个分片内对输出进行排序。由于每个分片的数据量仍然可能很大，因此使用外排算法。</p><p>当某个 Mapper 任务读取结束，并将输出排好了序，MapReduce 调度器就会通知所有 reducers 来该 Mapper 机器上拉取各自对应的输出。最终，每个 Reducer 会去所有 Mapper 上<strong>拉取</strong>一遍其对应分片数据数据。这里有个推还是拉的设计权衡，拉的好处在于 reducuer 失败后，可以很方便地进行重试，再次拉取计算即可。</p><p>这个<strong>分片</strong>（partitioning by reducer）-<strong>排序</strong>（sorting）-<strong>复制</strong>（coping）过程也被称为<strong>数据重排</strong>（<strong>shuffle</strong>，虽然英文是洗牌的意思，但该过程并没有任何随机性，都是确定的）。</p><p>框架会在 Reducer 处将所有从 Mapper 处拿来的 kv 文件进行归并排序，然后在所有数据拉取完毕后，将排好序数据送给 reducer。这样一来，不同 Mapper 产生的具有相同 key 的记录就会被聚集到一块。</p><p>总结来说，map 和 reduce 间的排序分为<strong>两个阶段</strong>：</p><ol><li>在每个 Mapper 上对<strong>输出</strong>分片后各自排序。</li><li>在每个 Reducer 上对<strong>输入</strong>（有序文件）进行归并排序。<br>Reducer 在调用时会传入一个 key 一个 Iterator（迭代器），使用该迭代器能够访问所有具有相同 key 的记录（极端情况下，内存可能放不下这些记录，因此是给一个迭代器，而非内存数组）。reducer 函数可以使用任意的逻辑对这些记录进行处理，并可以产生任意数量的输出。这些输出最终会被写到分布式文件系统中的文件里（通常该输出文件会在 Reducer 机器上放一个副本，在另外一些机器上放其他副本）。</li></ol><h4 id="2-1-2-MapReduce-工作流"><a href="#2-1-2-MapReduce-工作流" class="headerlink" title="2.1.2 MapReduce 工作流"></a>2.1.2 MapReduce 工作流</h4><p>将多个 MapReduce 首尾相接（前面任务的输出作为后面任务的输入）地串成<strong>工作流</strong>（workflow）极为常见。Hadoop MapReduce 框架本身没有提供任何关于工作流的支持，因此通常依赖文件夹名进行<strong>隐式的链式调用</strong>：</p><ol><li>第一个 MapReduce 任务将其输出写入特定的文件夹。</li><li>第二个 MapReduce 任务读取这些文件夹中文件作为输入。</li></ol><p>仅当一个任务完全成功的执行后，其输出才被认为是有效的（也即，MapReduce 任务会丢掉失败任务的不完整输出）。因此，工作流中的任务只有在前一个任务成功结束后才能启动——即，前驱任务必须<strong>成功地</strong>将输出写入到对应文件夹中。为了处理多个任务间执行的依赖关系（比如 DAG 依赖），人们开发了很多针对 Hadoop的工作流调度框架，如 Oozie，Azkaban，Luigi，Airflow 和 Pinball。</p><h3 id="2-2-Reduce-侧的-Join-和-Group"><a href="#2-2-Reduce-侧的-Join-和-Group" class="headerlink" title="2.2 Reduce 侧的 Join 和 Group"></a>2.2 Reduce 侧的 Join 和 Group</h3><p>在很多数据集中，一个记录和其他记录有<strong>关联</strong>（association）是一个很常见的现象：关系模型中的<strong>外键</strong>（foreign key），文档模型中的<strong>文档引用</strong>（document reference），图模型中的<strong>边</strong>（edge）。在代码需要访问有关联的双方记录（引用记录和被引用记录）时，Join 是必须的</p><p>当一个 MapReduce 任务拿到一组输入文件时，会读取文件中的所有内容；在数据库中，这种操作称为<strong>全表扫描</strong>（full table scan）。如果你进项访问一小部分记录，相比索引查找，全表扫描操作会非常的重。</p><h4 id="2-2-1-基于排序-合并的-Join"><a href="#2-2-1-基于排序-合并的-Join" class="headerlink" title="2.2.1 基于排序-合并的 Join"></a>2.2.1 基于排序-合并的 Join</h4><p> Mapper 的职责：从所有输入记录中提取 key 和 value。</p><p> 当 MapReduce 框架将所有 Mapper 的输出按照 key（也就是用户 ID）进行排序后，所有具有同样的用户 ID 的记录就会聚集到一块，作为输入给到 reducer。MapReduce 任务甚至可以将输出进行特殊组织，以使 Reducer 先看到同一个用户的资料信息，再看到其行为信息——这种技术也被称为<strong>二级排序</strong>（secondary sort，使用多个字段进行排序）。</p><p>在此基础上，reducer 可以进行轻松的进行 join：reducer 函数会在每一个用户 ID 上进行调用，由于使用了二级排序，reducer 会先看到该用户的资料信息。在实现 Reducer 时，可以首先将用户<strong>资料信息</strong>（比如生日）保存在局部变量里，然后对其所有<strong>行为信息</strong>进行迭代，提取相关信息，输出 <viewed-url, viewed age in years> kv 对。之后可以再接一个 MapReduce 任务，对每个 url 访问用户的年龄分布进行统计，并按年龄段进行聚集。</p><p>由于 Reducer 会在单个函数里处理所有同一个 user ID 的记录，因此一次只需要在内存中保存一个用户的资料信息，并且不用进行任何网络请求。这种算法也被称为<strong>基于排序和归并的连接</strong>（sort-merge join），由于 Mapper 的输出是按 key 有序的，则 reducers 可将来自多方的同一个 key 的输入轻松的进行合并。</p><h4 id="2-2-2-将相关数据聚到一块"><a href="#2-2-2-将相关数据聚到一块" class="headerlink" title="2.2.2 将相关数据聚到一块"></a>2.2.2 将相关数据聚到一块</h4><p>在排序-归并 join 中，mappers 和排序会确保同一个用户 id 所有用于 join 必要输入会被放到一起：<strong>即作为一个输入给到某次 Reducer 中</strong>。预先让所有相关数据聚集到一起，可以让 Reducer 逻辑非常简单，并且可以仅使用单个线程，就能进行高吞吐、低耗存地执行。</p><p>我们可以从另外一种角度来理解这种架构：mapper <strong>发消息</strong>给 reducer。当某个 Mapper 发出一个 key-value 对时，<strong>key 是投递地址，value 就是要投递的内容</strong>。尽管 key 在物理上仅是一个任意的字符串（而非像网络中的 IP 和端口号那样真的网络地址），但在逻辑上充当<strong>地址</strong>的作用：所有具有相同 key 的 kv 对都会被投递到同一个目的地（某个 Reducer 的调用处）。</p><p>MapReduce 编程模型，可以将计算的<strong>物理拓扑</strong>（将数据放到合适的机器上）与<strong>应用逻辑</strong>（当有了数据后就进行处理）<strong>解耦</strong>开来。这种解耦与数据库形成对比——在使用数据库的场景中，进行数据库连接（物理）通常藏在应用代码（逻辑）深处。由于 MapReduce 框架会处理所有网络通信细节，它也会让应用层代码免于关心<strong>部分失败</strong>（partial failure），如某些节点宕机：MapReduce 框架会透明的（应用代码无感）的对失败的子任务进行重试，而不会影响应用逻辑。</p><h4 id="2-2-3-Group-By"><a href="#2-2-3-Group-By" class="headerlink" title="2.2.3 Group By"></a>2.2.3 Group By</h4><p>将所有记录按某些 key 进行<strong>分组</strong>（对应 SQL 中的 <code>GROUP BY</code> 子句）。首先将具有相同 key 的所有记录被分到一组，然后对这些分组分别执行某些<strong>聚集</strong>操作（aggregation）</p><p>使用 MapReduce 实现 Group By 语义，最简单的方法是在 Mapper 中<strong>抽取 key 为待分组的 key</strong>。MapReduce 框架就会按照这些 key 将所有 Mapper 的输出记录进行分区和排序，然后按 key 聚集给到 reducer。本质上，使用 MapReduce 来实现 group 和 join ，逻辑是极为相似的。</p><p>分组的另外一个使用场景是：收集某个用户会话中的所有用户活动——也称为<strong>会话化</strong>（sessionization）。例如，可以用来对比用户对于新老版本网站的分别购买意愿（A/B 测试）或者统计某些市场推广活动是否起作用。</p><p>假设你的 web 服务架设在多台服务器上，则某个特定用户的活动日志大概率会分散在不同服务器上。这时，你可以实现一个会话化的 MapReduce 程序，使用会话 cookie、用户 ID或者其他类似的 ID 作为分组 key，以将相<strong>同用户</strong>的所有活动记录聚集到一块、并将<strong>不同用户</strong>分散到多个分区进行处理。</p><h4 id="2-2-4-处理偏斜（skew）"><a href="#2-2-4-处理偏斜（skew）" class="headerlink" title="2.2.4 处理偏斜（skew）"></a>2.2.4 处理偏斜（skew）</h4><p>如果某个 key 的数据量超级大，则“将相同 key 的数据聚集到一块” 的模型将不再适用。例如，在社交网络中，绝大多数的人都只会连接到较少的其他人，但数量较少的名人会有高达数百万的关注者。数据库中这种不成比例的记录常被称为<strong>关键对象</strong>（<em>linchpin objects</em> ）或者<strong>热键</strong>（<em>hot keys</em>）。<br>在单个 Reducer 中收集处理名人（celebrity）所有的活动事件（比如他们发布信息的回复），可能会造成严重的<strong>数据倾斜</strong>（<strong>skew</strong>，有时也被称为热点，hot spots）——即，一个 Reducer 处理的数据量远超其他。由于只有其所属的所有 mappers 和 reducers 执行完时，该 MapReduce 任务才算完成，该 MapReduce 之后的任何任务都需要等待最慢的 Reducer （长尾任务）完成后才能启动。</p><p>如果某个 join 的输入存在热点数据，你可以借助一些算法来进行缓解。例如，Pig 中的偏斜 join（skewed join）方法会事先对所有 key 的分布进行<strong>采样</strong>，以探测是否有热点 key。然后，在执行真正的 Join 时，对于 Join 有热点 key 的这一测，mapper 会将含有热点 key 的记录发送到多个 reducer（每次随机挑选一个，相比之下，常规的 MapReduce 只会根据 key 的哈希确定性的选择一个 reducer）；对于 Join 的另一侧输入，所有包含热点 key 的相关记录需要每个给每个具有该 key 的 Reducer 都发一份。</p><p>该技术将处理热点 key 的工作分摊到多个 Reducer 上，从而可以让其更好的并行，当然代价就是需要将 join 的非热点侧的数据冗余多份。Crunch 中的<strong>分片连接</strong>（shared join）也使用类似的技术，但需要<strong>显式地指定</strong>热点 key，而非通过采样来<strong>自动获取</strong>。</p><p>当对热点 key 进行分组聚集（group）时，可以将分组过程拆成<strong>两个阶段</strong>，即使用两个相接的 MapReduce。第一个 MapReduce 会将记录随机得发给不同的 reducer，则每个 Reducer 会对热点 key 的一个子集执行分组操作，并且产生一个更为紧凑的<strong>聚合值</strong>（aggregated value，如 count，sum，max 等等）。第二个 MapReduce 操作会将第一阶段中 MapReduce 产生的同一个 key 的多个聚合值进行真正的归并。总结来说，就是第一阶段进行<strong>预分组，减小数据量</strong>；第二阶段真正的全局分组，可以想象这种方式，要求聚合操作满足<strong>交换律和结合律</strong>。</p><h3 id="2-3-Map-侧的连接"><a href="#2-3-Map-侧的连接" class="headerlink" title="2.3 Map 侧的连接"></a>2.3 Map 侧的连接</h3><p>上一节讲到的 join 算法是在 reduce 阶段真正执行的 join 逻辑，因此也被称为 <strong>reduce 侧连接</strong>（<em>reduce-side join</em>）。其中，mapper 仅扮演准备数据的角色：从每个输入记录中提取 key 和 value，并且将每个 kv 对发给合适的 Reducer 分区，并将其进行排序。</p><p>reduce 侧的连接的好处在于，你不需要对输入数据有任何的假设：不管输入数据具有怎样的属性和结构，mappers 都可以进行合适的预处理后送给 reducers 进行连接。然而，缺点在于排序、复制到 reducers、将 Reducer 的输入进行合并等过程代价十分高昂。根据可用内存缓存大小不同，数据在流经 MapReduce 中各阶段时可能会被写入多次（写放大）。</p><p>但如果，输入数据满足某种假设，就可以利用所谓的 <strong>map 侧连接</strong>（map-side join）进行更快的连接。这种方式利用了一种简化过的 MapReduce 任务，去掉了 reducer，从而也去掉了对 Mapper 输出的排序阶段。此时，每个 Mapper 只需要从分布式文件系统中的输入文件块中读取记录、处理、并将输出写回到文件系统，即可。</p><h4 id="2-3-1-广播哈希连接"><a href="#2-3-1-广播哈希连接" class="headerlink" title="2.3.1 广播哈希连接"></a>2.3.1 广播哈希连接</h4><p>使用 map 侧连接的一个最常见的场景是一个大数据集和一个小数据集进行连接时。此种情况下，小数据集需要小到能全部装进 Mapper 进程所在机器的内存。<br>但仍然会有多个 Mapper 任务：join 的<strong>大数据量输入侧</strong> 每个文件块一个 mapper。其中 MapReduce 任务中的每个 Mapper 都会将小输入侧的数据全部加载进内存。</p><p>称为<strong>广播哈希连接</strong>（broadcast hash joins）：</p><ol><li><strong>广播（broadcast）</strong>：处理大数据侧每个分片的 Mapper 都会将小数据侧数据全部载入内存。从另外一个角度理解，就是将小数据集<strong>广播到了</strong>所有相关 Mapper 机器上。</li><li><strong>哈希（hash）</strong>：即在将小数据集在内存中组织为哈希表。</li></ol><h4 id="2-3-2-分区哈希连接"><a href="#2-3-2-分区哈希连接" class="headerlink" title="2.3.2 分区哈希连接"></a>2.3.2 分区哈希连接</h4><p>如果待 join 的多个输入，能够以同样的方式进行分区，则每个分区在处理时可以独立地进行 join。</p><p>如果分区方式正确，则所有需要连接的双方都会落到同一个分区内，因此每个 Mapper 只需要读取一个分区就可以获取待连接双方的所有记录。这样做的好处是，每个 Mapper 所需构建哈希表的数据集要小很多。</p><p>在 Hive 中，分区哈希连接也被称为<strong>分桶 map 侧连接</strong>（ bucketed map join）。</p><h4 id="2-3-3-Map-侧合并连接"><a href="#2-3-3-Map-侧合并连接" class="headerlink" title="2.3.3 Map 侧合并连接"></a>2.3.3 Map 侧合并连接</h4><p>当 map 的输入数据集不仅以相同的方式分片过了，而且每个分片是<strong>按该 key 有序的</strong>。在这种情况下，是否有足够小的、能够载入内存的输入已经无关紧要，因为 Mapper 可以以类似普通 Reducer 的方式对输入数据进行<strong>归并</strong>：都以 key 递增（都递减也可以，取决于输入文件中 key 的顺序）的顺序，增量式（迭代式）的读取两个输入文件，对相同的 key 进行匹配连接。</p><h3 id="2-4-批处理工作流的输出"><a href="#2-4-批处理工作流的输出" class="headerlink" title="2.4 批处理工作流的输出"></a>2.4 批处理工作流的输出</h3><p>对于数据库查询场景，我们会区分事务型处理场景（OLTP）和分析性场景（OLAP）</p><p>OLTP 场景下的查询通常只会涉及很小的一个数据子集，因此通常会使用索引加速查询，然后将结果<strong>展示</strong>给用户（例如，使用网页展示）。另一方面，分析型查询通常会扫描大量的数据记录，执行<strong>分组</strong>（grouping）和<strong>聚集</strong>（aggregating）等统计操作，然后以<strong>报表</strong>的形式呈现给用户。</p><p>一组 MapReduce 任务组成的执行流通常和用于分析型的 SQL 查询并不相同（参见 Hadoop 和分布式数据库的对比）。批处理的输出通常不是一个报表，而是<strong>另外某种格式的数据</strong>。</p><h4 id="2-4-1-构建查询索引"><a href="#2-4-1-构建查询索引" class="headerlink" title="2.4.1 构建查询索引"></a>2.4.1 构建查询索引</h4><p>倒排索引是一个<strong>词表</strong>（the term dictionary），利用该词表，你可以针对关键词快速地查出对应<strong>文档列表</strong>（the postings list）。</p><p>在一个<strong>固定文档集合</strong>上构建全文索引，批处理非常合适且高效：</p><ol><li>Mapper 会将文档集合按合适的方式进行分区</li><li>Reducer 会对每个分区构建索引</li><li>最终将索引文件写回分布式文件系统</li></ol><p>由于使用关键词进行索引查询是一种只读操作，因此，这些索引文件一旦构建完成，就是不可变的（immutable）。</p><p>如果被索引的文档集发生变动，一种应对策略是，定期针对所有文档重跑全量索引构建工作流（workflow），并在索引构建完时使用新的索引对旧的进行整体替换。如果两次构建之间，仅有一小部分文档发生了变动，则这种方法代价实在有点高。但也有优点，索引构建过程很好理解：<strong>文档进去，索引出来</strong>。</p><h4 id="2-4-2-以-KV-存储承接批处理输出"><a href="#2-4-2-以-KV-存储承接批处理输出" class="headerlink" title="2.4.2 以 KV 存储承接批处理输出"></a>2.4.2 以 KV 存储承接批处理输出</h4><p>搜索索引只是批处理工作流一种可能的输出。批处理其他的用途还包括构建机器学习系统，如<strong>分类器</strong>（classifiers，如 垃圾邮件过滤，同义词检测，图片识别）和<strong>推荐系统</strong>（recommendation system，如你可能认识的人，可能感兴趣的产品或者相关的检索）。</p><p>在批处理任务内部生成全新的数据库，并将其以文件的形式写入分布式系统的文件夹中。一旦任务成功执行，这些数据文件就会称为<strong>不可变的</strong>（immutable），并且可以<strong>批量加载</strong>（bulk loading）进只处理只读请求的服务中。很多 KV 存储都支持使用 MapReduce 任务构建数据库文件，比如 Voldemort，Terrapin， ElephantDB 和 HBase bulk loading。另外 RocksDB 支持 ingest SST 文件，也是类似的情况。</p><p><strong>直接构建数据库底层文件</strong>，就是一个 MapReduce 应用的绝佳案例：使用 Mapper 抽取 key，然后利用该 key 进行排序，已经<strong>覆盖了</strong>构建索引中的大部分流程。由于大部 KV 存储都是只读的（通过批处理任务一次写入后，即不可变），这些存储的底层数据结构可以设计的非常简单。</p><p>当数据加载进 Voldemort 时，服务器可以利用老文件<strong>继续对外提供服务</strong>，新文件会从分布式文件系统中拷贝的 Voldemort 服务本地。一旦拷贝完成，服务器可以立即将外部查询请求<strong>原子地</strong>切到新文件上。如果导入过程中发生了任何问题，也可以<strong>快速地切回</strong>，使用老文件提供服务。因为老文件是不可变的，且没有立即被删除。</p><h4 id="2-4-3-批处理输出的哲学"><a href="#2-4-3-批处理输出的哲学" class="headerlink" title="2.4.3 批处理输出的哲学"></a>2.4.3 批处理输出的哲学</h4><ul><li><strong>容忍人为错误</strong>。如果你在代码中不小心引入了 bug，使得输出出错，你可以简单地将代码回滚到最近一个正确的版本，然后重新运行任务，则输出就会变正确。或者，更简单地，你可将之前正确的输出保存在其他的文件夹，然后在遇到问题时简单的切回去即可。使用读写事务的数据库是没法具有这种性质的：如果你部署了有 bug 的代码，并且因此往数据库中写入了错误的数据，回滚代码版本也并不能<strong>修复这些损坏的数据</strong>。（从有 bug 的代码中恢复，称为容忍人为错误，human fault tolerance）。这其实是通过牺牲空间换来的，也是经典的增量更新而非原地更新。</li><li><strong>便于敏捷开发</strong>。相比可能会造成不可逆损坏的环境，由于能够很方便地进行回滚，可以大大加快功能迭代的速度（因为不需要进行严密的测试即可上生产）。<strong>最小化不可逆性</strong>（<em>minimizing irreversibility</em>）的原则，有助于敏捷软件开发。</li><li><strong>简单重试就可以容错</strong>。如果某个 map 或者 reduce 任务失败了，MapReduce 框架会自动在相同输入上对其重新调度。如果失败是由代码 bug 引起的，在重试多次后（可以设置某个阈值），会最终引起任务失败；但如果失败是暂时的，该错误就能够被容忍。这种自动重试的机制之所以安全，是因为输入是不可变的，且失败子任务的输出会被自动抛弃。</li><li><strong>数据复用</strong>。同一个文件集能够作为不同任务的输入，包括用于计算指标的监控任务、评估任务的输出是否满足预期性质（如，和之前一个任务的比较并计算差异）。</li><li><strong>逻辑布线分离</strong>。和 Unix 工具一样，MapReduce 也将逻辑和接线分离（通过配置输入、输出文件夹），从而分拆复杂度并且提高代码复用度：一些团队可以专注于实现干好单件事的任务开发；另一些团队可以决定在哪里、在何时来组合跑这些代码。</li></ul><h3 id="2-5-对比-Hadoop-和分布式数据库"><a href="#2-5-对比-Hadoop-和分布式数据库" class="headerlink" title="2.5 对比 Hadoop 和分布式数据库"></a>2.5 对比 Hadoop 和分布式数据库</h3><p>Hadoop 很像一个<strong>分布式形态的 Unix</strong>。其中，HDFS 对标 Unix 中的文件系统，MapReduce 类似于 Unix 进程的一个奇怪实现（在 map 阶段和 reduce 阶段间必须要进行排序）。</p><h4 id="2-5-1-存储类型更为多样"><a href="#2-5-1-存储类型更为多样" class="headerlink" title="2.5.1 存储类型更为多样"></a>2.5.1 存储类型更为多样</h4><p>Hadoop 允许你以<strong>任意格式</strong>的数据灌入 HDFS，将如何处理的灵活性推到之后</p><p>Hadoop 经常用于 <strong>ETL 处理</strong>：将数据以某种原始的格式从事务型的处理系统中引入到分布式文件系统中，然后编写 MapReduce 任务以处理这些数据，将其转换回关系形式</p><h4 id="2-5-2-处理模型更为多样"><a href="#2-5-2-处理模型更为多样" class="headerlink" title="2.5.2 处理模型更为多样"></a>2.5.2 处理模型更为多样</h4><p>基于 Hadoop 实现的各种处理模型可以<strong>共享集群并行运行</strong>，且不同的处理模型都可以访问 HDFS 上的相同文件。在 Hadoop 生态中，无需将数据在不同的特化系统间倒来倒去以进行不同类型的处理：<strong>Hadoop 系统足够开放，能够以单一集群支持多种负载类型</strong>。<strong>无需移动数据</strong>让我们更容易的从数据中挖掘价值，也更容易开发新的处理模型。</p><h4 id="2-5-3-面向频繁出错设计"><a href="#2-5-3-面向频繁出错设计" class="headerlink" title="2.5.3 面向频繁出错设计"></a>2.5.3 面向频繁出错设计</h4><p>MapReduce 在遇到某个 map 或 reduce 子任务运行出错时，可以单独、自动地进行重试，而不会引起整个 MapReduce 任务的重试。此外，MapReduce 倾向于将数据（甚至是 map 到 reduce 中间环节的数据）进行落盘，一方面是为了容错，另一方面是因为 MapReduce 在设计时假设面对的数据量足够大，内存通常装不下。</p><p>因此，MapReduce 通常更适合<strong>大任务</strong>：即那些需要处理大量数据、运行较长时间的任务。而巨量的数据、过长的耗时，都会使得处理过程中遇到故障司空见惯。在这种情况下，由于一个<strong>子任务（task）</strong> 的故障而重试整个<strong>任务（job）</strong> 就非常得不偿失。当然，即使只在子任务粒度进行重试，也会让那些并不出错的任务运行的更慢（数据要持久化）。但对于频繁出错的任务场景来说，这个取舍是合理的。</p><h3 id="2-6-MapReduce之外"><a href="#2-6-MapReduce之外" class="headerlink" title="2.6 MapReduce之外"></a>2.6 MapReduce之外</h3><h4 id="2-6-1-中间状态的物化"><a href="#2-6-1-中间状态的物化" class="headerlink" title="2.6.1 中间状态的物化"></a>2.6.1 中间状态的物化</h4><p>在大多数情况下，我们事先就明确地知道某个任务的输出<strong>只会为</strong>同一团队的另一个任务所使用。在这种情况下，保存到分布式文件系统上的两个任务间的数据其实只是一种<strong>中间状态</strong>（intermediate state）：只是一种将数据从前序任务传递到后继任务的方式。在诸如推荐系统等复杂的<strong>数据流</strong>中，通常会包含 50~100 个 MapReduce 任务，其中绝大部分任务间的数据都属于数据流中间状态。</p><p>将中间状态写入文件的过程称为<strong>物化</strong>（materialization）。</p><p>MapReduce 将工作流中间结果进行物化的方式有很多缺点：</p><ul><li><strong>无谓等待</strong>。一个 MapReduce 任务只能在所有前置依赖任务完成后才能启动。然而由 Unix 管道缀连起来的命令却能够并行运行，只要一个任务开始产生输出，下一个任务就可以开始消费处理。由于机器配置和负载的不同，总会在某些机器上出现一些执行时间过长<strong>拖后腿的任务</strong>（struggler）。而 MapReduce 的这种等待机制，会让单个任务拖垮整个工作流。</li><li><strong>Mapper 冗余</strong>。Mapper 职责非常简单，仅是读出前置 Reducer 产生的数据，并为之后 Reducer 的分片和排序做准备。在很多情况下，mapper 的职责其实可以并到前序任务的 Reducer 中：如果可以将 Reducer 的输出按照后继 Reducer 的要求准备好，则可将 Reducer 直接串起来，从而省去中间夹杂的 Mapper 阶段。</li><li><strong>数据冗余</strong>。在分布式文件系统中存储中间结果，意味着将数据在不同机器上冗余了几份。对于并不需要共享的中间结果来说，这种方式太过奢侈。</li></ul><h4 id="2-6-2-数据流引擎"><a href="#2-6-2-数据流引擎" class="headerlink" title="2.6.2 数据流引擎"></a>2.6.2 数据流引擎</h4><p>针对分布式系统中的批处理负载，人们开发了很多新的执行引擎。将<strong>整个数据流看做一个任务，而非将其拆分成几个相对独立的子任务</strong>。和 MapReduce 一样，这些引擎也会对每个数据记录在单个线程中，重复调用用户的定制函数（包裹用户逻辑）。并且会将输入数据集进行<strong>切片</strong>（partition），并行地执行（数据并行），然后将一个函数的输出通过网络传递给下一个函数作为输入。</p><p>和 MapReduce 不同的是，这些函数可以进行更灵活地组织，而不需要严格遵循 map 或者 reduce 格式。我们成这些函数为<strong>算子</strong>（operators），且 dataflow 引擎会提供多种选择，以将一个算子的数据输出导入到下一个算子（<strong>类似数据流接线方式</strong>）：</p><ul><li><strong>repartition + sort（sort merge join）</strong>：一种方法是进行 repartition 并按 key 对 record 进行排序，就像 MapReduce 的 shuffle 阶段一样。该功能能够提供像 MapReduce 一样的 <strong>sort-merge join</strong> 和分区方式。</li><li><strong>only repartition（partition hash join）</strong>：另一种可能是接受多个输入，并且用同样的方式进行<strong>分区</strong>（partitioning），但是会跳过排序阶段。这对于分区哈希 join 很有用，因为该算子只关心记录的分区，但其顺序并不重要，因为总会过哈希表重新组织。</li><li><strong>broadcast（broadcast hash join）</strong>：对于广播哈希 join，一个算子的输出会被发送到多个待 join 分区算子。</li></ul><ul><li><strong>按需 shuffle</strong>：对于排序等高代价负载，只有在需要的时候才会执行，而不是总强制发生在 map 和 reduce 之间。</li><li><strong>省掉无用 Mapper</strong>：由于 map 本身并没有进行 repartition，因此可以将其合并到前一个算子中的 reduceer 阶段。</li><li><strong>数据传输优化</strong>：由于所有 join 和依赖等数据拓扑是显式声明的，调度器可以事先知道哪些数据在哪里被需要。因此可以尽可能地做<strong>局部性优化</strong>（locality optimization）。例如，可以尽量将消费某分区数据的任务放到生产该数据的机器上执行，从而通过共享内存而非网络来共享数据。</li><li><strong>中间结果只存一份</strong>：通常来说，只需要将算子的中间结果，在内存中或者本地硬盘中放一份就够了，而不用写到分布式文件系统中。在 MapReduce 中 Mapper 的输出其实也是用了此优化，只不过 dataflow 引擎将该思想扩展到了所有中间状态的存储中。</li><li><strong>算子执行流水化</strong>：大部分算子只要有输入了就可以执行，而不用等到前置任务都完成了才能够执行。</li><li><strong>进程复用</strong>：同一个工作流中，前面算子所使用的 JVM 进程池可以为之后算子所复用，而不用像 MapReduce 一样每个任务都要开一个新的 JVM 进程。</li></ul><p><strong>算子</strong>是 map 和 reduce 的泛化</p><h4 id="2-6-3-容错"><a href="#2-6-3-容错" class="headerlink" title="2.6.3 容错"></a>2.6.3 容错</h4><p>将所有中间状态持久化到分布式文件系统中的一个好处是——<strong>持久性</strong>（durable），这会使得 MapReduce 的容错方式变得非常简单：如果某个任务挂了，仅需要在其他机器上重新启动，并从文件系统中读取相同的输入即可。</p><p>Spark、Flink 和 Tez 都会避免将中间状态写到 HDFS 中，因此他们采用了完全不同的容错方式：<strong>如果某个机器上的中间结果丢了，就回溯工作流的算子依赖（DAG 依赖），找到最近可用的数据按照工作流重新计算</strong>（最差的情况会一直找到输入数据，而输入数据通常存在于 HDFS 上）。</p><p>为了能够通过重新计算来容错，框架必须跟踪每一部分数据的<strong>计算轨迹</strong>（DGA 依赖，或者说数据谱系，data lineage）——涉及哪些输入分片、应用了哪些算子。Spark 使用<strong>弹性分区数据集</strong>（RDD）抽象来追踪数据的祖先；Flink 使用了快照来记录所有算子状态，以从最近的<strong>检查点</strong>（checkpoint）重启运行出错的算子。</p><p>当通过重算来容错时，最重要的是要明确<strong>计算过程</strong>（即算子）是否为<strong>确定性的</strong>（deterministic）：即，<strong>给定同样的输入数据，多次运行同一算子总会产生同样的输出吗</strong>？当算子的数据已经发到下游后出错时，该问题变的非常重要。如果算子重新运行时产生的数据和之前不一致，则下游算子很难在新老数据间进行冲突处理。对于非确定性算子的容错方案，通常是将下游算子也都清空状态一并重启。</p><h4 id="2-6-4-分布式处理框架最主要解决的两个问题是："><a href="#2-6-4-分布式处理框架最主要解决的两个问题是：" class="headerlink" title="2.6.4 分布式处理框架最主要解决的两个问题是："></a>2.6.4 分布式处理框架最主要解决的两个问题是：</h4><ul><li><strong>分片</strong> 在 MapReduce 中，会根据输入数据的文件块（file chunk）的数量来调度 mappers。mappers 的输出会在<strong>二次分片、排序、合并</strong>（我们通常称之为 shuffle）到用户指定数量的 Reducer 中。该过程是为了将所有相关的数据（如具有相同 key）集结到一块。 后 MapReduce 时代的数据流工具会尽量避免不必要的排序（因为代价太高了），但他们仍然使用了和 MapReduce 类似的分区方式。</li><li><strong>容错</strong> MapReduce 通过频繁的（每次 MapReduce 后）<strong>刷盘</strong>，从而可以避免重启整个任务，而只重新运行相关子任务就可以从其故障中快速恢复过来。但在错误频率很低的情况下，这种频繁刷盘做法代价很高。数据流工具通过尽可能的减少中间状态的刷盘（当然，shuffle 之后还是要刷的），并将其尽可能的保存在内存中，但这意味着一旦出现故障就要从头重算。算子的<strong>确定性</strong>可以减少重算的数据范围（确定性能保证只需要算失败分区，并且结果和其他分区仍然一致）。</li></ul><p>批处理任务的基本特点是——读取输入，进行处理，产生输出的过程中，<strong>不会修改原数据</strong>。换句话说，输出是输入的衍生数据。其中一个重要特点是，输入数据是<strong>有界的</strong>（bounded）：<strong>输入的大小是固定的、事先确定的</strong>（比如输入是包含一组日志的数据或者一个快照点的数据）。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> DDIA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDIA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[DDIA] 一致性和共识协议</title>
      <link href="/2023/07/22/DDIA/08%20%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/"/>
      <url>/2023/07/22/DDIA/08%20%E4%B8%80%E8%87%B4%E6%80%A7%E5%92%8C%E5%85%B1%E8%AF%86%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>共识</strong>（consensus），即，<em>让所有节点在<strong>某件事情</strong>上达成一致</em>。</p></blockquote><span id="more"></span><p>大部分<strong>数据系统</strong>都可以抽象为一系列<strong>数据操作</strong>的依次施加，即状态机模型。而共识协议可以让多机对某个<strong>确定</strong>的<strong>操作序列</strong>达成共识，进而对系统的任意状态达成共识。</p><h2 id="1-一致性保证"><a href="#1-一致性保证" class="headerlink" title="1 一致性保证"></a>1 一致性保证</h2><p><strong>收敛性</strong>（<em>convergence</em>），即最终，所有副本都会收敛到相同的值。</p><h2 id="2-线性一致性"><a href="#2-线性一致性" class="headerlink" title="2 线性一致性"></a>2 线性一致性</h2><p>一个系统对外表现的像所有数据<strong>只有一个副本</strong>，作用于数据上的操作都可以<strong>原子地完成</strong>。<br>在一个提供线性一致性的系统中，只要某个客户端成功的进行了写入某值，其他所有客户端都可以在数据库中读到该值。提供单副本的抽象，意味着客户端任何时刻读到的都是<strong>最近、最新</strong>（up-to-date）的值，而不会是过期缓存、副本中的旧值。换句话说，线性一致性是一种数据<strong>新鲜度保证</strong>（recency guarantee）。</p><h3 id="2-1-如何让系统满足线性一致？"><a href="#2-1-如何让系统满足线性一致？" class="headerlink" title="2.1 如何让系统满足线性一致？"></a>2.1 如何让系统满足线性一致？</h3><p><strong>让系统表现得好像只有一个数据副本</strong>。</p><p>线性一致性要求所有操作标记组成序列是<strong>永远向前的</strong>，即满足数据<strong>新鲜度要求：一旦我们写入或者读取到某值，所有稍后的读请求都能看到该值，直到有人再次将其改写。</strong></p><p><strong>线性一致性和可串行化</strong></p><p><strong>线性一致性</strong>（Linearizability）很容易和<strong>可串行化</strong>（serializability）相混淆，因为他们看起来都像是：可以进行拓扑化组织。但他们是不同维度的约束，我们很有必要对其进行区分：</p><p><strong>可串行化</strong>（Serializability）。可串行化是事务的一种隔离级别。每个事务可能会涉及<strong>多个数据对象</strong>（行、文档、记录）的读写，<a href="https://ddia.qtmuniao.com/#/ch07?id=%e5%8d%95%e5%af%b9%e8%b1%a1%e5%92%8c%e5%a4%9a%e5%af%b9%e8%b1%a1%e6%93%8d%e4%bd%9c">之前</a>有讨论过单对象和多对象。可串行化可以保证所有事务好像按<strong>某种顺序依次执行</strong>（后一个事务在前一个事务结束后才开始）。需要注意的是，如果某种串行顺序和实际执行顺序不一致也没事，只要是串行执行就行。举个例子，如果 A、B、C 三个事务并发执行，真实顺序是 A-&gt;B-&gt;C，但如果对应用层表现为 C-&gt;A-&gt;B 的执行顺序（可能由于多机时间戳不同步），也可以叫可串行化，但 C-&gt;A-&gt;B 的执行顺序在<strong>某个</strong>对象上可能不满足线性一致性。</p><p><strong>线性一致性</strong>（Linearizability）。线性一致性是一种针对寄存器（register，<strong>单个数据对象</strong>）的读写新鲜度保证。它不会将多个操作打包成事务，因此不能避免像之前提到的<a href="https://ddia.qtmuniao.com/#/ch07?id=%e5%86%99%e5%81%8f%e5%ba%8f%e5%92%8c%e5%b9%bb%e8%af%bb">写偏序</a>等问题，除非使用某些辅助手段，如<a href="https://ddia.qtmuniao.com/#/ch07?id=%e7%89%a9%e5%8c%96%e5%86%b2%e7%aa%81">物化冲突</a>。</p><p>一个数据库可以同时提供可串行化和线性一致性保证，我们称之为<strong>严格可串行化</strong>（<em>strict serializability</em>）或者<strong>单副本可串行化</strong>（strong one-copy serializability）。使用两阶段锁或者真正串行化执行实现的可串行化，通常都是线性一致的。</p><p>然而，基于快照隔离的串行化<strong>通常</strong>不是线性一致的。为了避免读写互相阻塞，所有的读取都会基于某个一致性的快照，则该快照之后的写入不会反映到读请求上，因此，快照读不满足线性一致性。</p><h3 id="2-2-应用线性一致性"><a href="#2-2-应用线性一致性" class="headerlink" title="2.2 应用线性一致性"></a>2.2 应用线性一致性</h3><p>在使用单主模型的系统中，需要保证任何时刻只有一个主副本，而非多个（脑裂）。一种进行主选举的方法是使用锁：每个节点在启动时都试图去获取锁，最终只有一个节点会成功并且变为主。不论使用什么方式实现锁，都必须<strong>满足线性一致性</strong>：所有节点必须就某节点拥有锁达成一致，否则这样的锁服务是不能用的。</p><p><strong>唯一性约束</strong>在数据库中很常见：比如用户名和邮箱可以用来唯一的标识一个用户、在同一个文件系统中不可能有多个文件具有相同的路径和文件名。如果你想在数据写入时<strong>维持这些约束</strong>（比如两个人使用相同的用户名并发地创建账户，其中一个会失败而报错），你需要线性一致性。</p><p>要求所有节点在<strong>单个最新值</strong>（账户余额、股票水位、座位预定）上达成一致。</p><h3 id="2-3-实现线性一致的系统"><a href="#2-3-实现线性一致的系统" class="headerlink" title="2.3 实现线性一致的系统"></a>2.3 实现线性一致的系统</h3><p>可以通过牺牲部分性能来让 Dynamo 风格的 Quorum 读写变成线性一致的：</p><ol><li>每个读请求必须进行同步的<a href="https://ddia.qtmuniao.com/#/ch05?id=%e8%af%bb%e6%97%b6%e4%bf%ae%e5%a4%8d%e5%92%8c%e5%8f%8d%e7%86%b5">读取修复</a>。</li><li>发送任意写请求之前要先读取最新值。</li></ol><h3 id="2-4-线性一致性的代价"><a href="#2-4-线性一致性的代价" class="headerlink" title="2.4 线性一致性的代价"></a>2.4 线性一致性的代价</h3><p>如果应用层要求线性一致的读写，则<strong>数据中心间的网络中断会造成服务的不可用</strong>。</p><h4 id="2-4-1-CAP-定理"><a href="#2-4-1-CAP-定理" class="headerlink" title="2.4.1 CAP 定理"></a>2.4.1 CAP 定理</h4><ul><li>如果应用层要求系统提供线性一致性，此时如果某些数据副本由于网络问题和系统其他部分<strong>断开了连接</strong>，则这些数据副本就<strong>不再能够正常地处理请求</strong>：要么等待网络恢复、要么进行报错。但这都意味着系统不可用。</li><li>如果应用不要求系统的线性一致，则即使多副本间遇到连接问题，每个副本可以独立的进行写入。从而，即使出现了网络故障，系统仍然能够保持可用，但其行为不是线性一致的。</li></ul><p>CAP 有时候被表述为，在做系统设计时，一致性（consistency）、可用性（Availability）、分区容错性（Partition tolerance），只能三取其二。<br><strong>当网络出现分区时，一致性和可用性只能二选其一</strong>（<em>either Consistent or Available when Partitioned</em>）。</p><h4 id="2-4-2-线性一致性和网络延迟"><a href="#2-4-2-线性一致性和网络延迟" class="headerlink" title="2.4.2 线性一致性和网络延迟"></a>2.4.2 线性一致性和网络延迟</h4><p>很多分布式系统选择不提供线性一致性的原因也在于此：<strong>是为了提升系统性能而非进行容错</strong>。在任何时候，提供线性一致性都会严重拖慢系统。而非在网络故障发生时，才需要对线性一致性进行牺牲。</p><p>如果你想要保证线性一致，读写请求的响应时间是<strong>正比于网络延迟</strong>的。</p><p><strong>顺序性</strong>（ordering）、<strong>线性一致性</strong>（linearizability）和<strong>共识协议</strong>（consensus）三个概念间有很深的联系。</p><h2 id="3-顺序保证"><a href="#3-顺序保证" class="headerlink" title="3 顺序保证"></a>3 顺序保证</h2><h3 id="3-1-顺序和因果（Ordering-and-Causality）"><a href="#3-1-顺序和因果（Ordering-and-Causality）" class="headerlink" title="3.1 顺序和因果（Ordering and Causality）"></a>3.1 顺序和因果（Ordering and Causality）</h3><p><strong>顺序可以维持因果性</strong><br>因果将顺序施加于<strong>事件</strong>（event）：</p><ol><li>先有因，后有果</li><li>先有消息发送，然后该消息被收到</li><li>先有问题，后有答案<br>如果一个系统遵循因果约束，则我们称其为<strong>因果一致的</strong>（<em>causally consistent</em>）。比如，快照隔离就可以提供因果一致性：当从数据库读取数据的时候，如果你能读到某个时间点的数据，就一定能读到其之前的数据</li></ol><h4 id="3-1-1-因果序非全序"><a href="#3-1-1-因果序非全序" class="headerlink" title="3.1.1 因果序非全序"></a>3.1.1 因果序非全序</h4><p><strong>全序</strong>（total order）意味着<strong>系统内任意两个元素可比大小</strong>。<br>反之，集合是<strong>偏序</strong>（partially ordered）：在某些情况下，我们可以说一个集合比另一个集合大（两个集合间有包含关系）；但在另外一些情况下，两个集合间没有可比关系。</p><p><strong>线性一致性</strong>（Linearizability）：对于任意两个操作，我们总是可以确定其发生的先后关系，也即在可线性化系统中，所有的操作顺序满足全序关系。<br><strong>因果一致性</strong>（Causality）。如果我们无从判定两个操作的先后关系，则称之为<strong>并发的</strong>（concurrent，参见<a href="https://ddia.qtmuniao.com/#/ch05?id=%e5%8f%91%e7%94%9f%e4%ba%8e%e4%b9%8b%e5%89%8d%ef%bc%88happens-before%ef%bc%89%e5%92%8c%e5%b9%b6%e5%8f%91%e5%85%b3%e7%b3%bb">发生于之前和并发关系</a>）。因果性定义了一种<strong>偏序</strong>（partial order）关系，而非全序关系：有些操作存在因果，因此可比；而另外一些操作则是并发的，即不可比。</p><h3 id="3-2-序列号定序"><a href="#3-2-序列号定序" class="headerlink" title="3.2 序列号定序"></a>3.2 序列号定序</h3><p><strong>使用序列号（sequence numbers）或者时间戳（timestamps）来给事件定序</strong>。<br>在使用单主模型的多副本系统中，主节点上<strong>操作日志的追加顺序</strong>确定了一个对所有操作的全序，且满足操作发生的因果关系。主节点可以为每条日志按顺序关联一个全局递增的序列号，如果从节点上也按都按此序列号顺序应用操作日志到状态机，则每个副本总能保持一致的状态（但有可能稍落后于主节点）。</p><h4 id="3-2-1-非因果序生成器"><a href="#3-2-1-非因果序生成器" class="headerlink" title="3.2.1 非因果序生成器"></a>3.2.1 非因果序生成器</h4><p>如果系统中没有唯一的单主节点（比如你用的是多主模型或无主模型，又或者你的系统存在多个分区），则如何为每个操作产生一个序列号就变得不那么简单直观了。常用的方式有以下几种：</p><ol><li><strong>每个节点独立地生成不相交的序列集</strong>。如，你的系统中有两个节点，一个节点只产生奇数序号，另一个节点只产生偶数序号。更通用一些，我们可以在生成的序号中保留一些位来编码对节点的标识，从而让不同的节点永远不会产生相同的序号。</li><li><strong>可以为每个操作关联一个日历时钟</strong>（或者说物理时钟）。这些时间戳不是有序的（因为回拨？），但如果有足够的精读，就可以让任意两个操作关联的时间戳不同，依次也可以达到全序的目的。此种方法有时候会被用在解决冲突使用后者胜的策略（但会有风险）。</li><li><strong>每次可以批量产生一组序列号</strong>。比如，在请求序列号时，节点 A 可以一次性声明占用 1 ~ 1000 的序列号，节点 B 会一次占用 1001~2000 的序列号。则本地的操作可以从拿到的这批序列号中直接分配，仅在快耗尽时再去请求一批。这种方法常被用在 TSO（timestamp oracle，单点授时）的优化中。<br><strong>都存在因果问题：</strong></li><li><strong>不同节点上处理操作的速率很难完全同步</strong>。因此，如果一个节点使用奇数序号，另一个节点时用偶数序号，则两个序号消耗的速率也会不一致。此时，当你有两个奇偶性不同的序号时，就难以通过比较大小来确定操作发生的先后顺序。</li><li><strong>物理时间戳会由于多机时钟偏差，而不满足因果一致</strong>。例如，在图 8-3 中（参见<a href="https://ddia.qtmuniao.com/#/ch08?id=%e6%97%b6%e9%97%b4%e6%88%b3%e4%bb%a5%e5%ae%9a%e5%ba%8f">时间戳以定序</a>），就出现了发生在之后的操作被分配了一个较小的时间戳。</li><li>对于批量分配方式，有可能发生较早的操作被分配了 1001-2000 的序列号，而较晚的操作被分配了 1-1000 的序列号。如此一来，序列号的分配不满足因果一致。</li></ol><h4 id="3-2-2-Lamport-时间戳"><a href="#3-2-2-Lamport-时间戳" class="headerlink" title="3.2.2 Lamport 时间戳"></a>3.2.2 Lamport 时间戳</h4><p>在该系统中，每个节点有一个唯一的 <strong>id</strong> 和一个记录处理过多少个操作的计数器，Lamport 时间戳是上述两者组成的二元组：<code>(counter, node ID)</code> 。不同的节点可能会有相同的 counter 值，但通过引入 node ID，可以使所有时间戳都是全局唯一的。</p><p>让 Lamport 时间戳能够满足因果一致性的核心点在于：<strong>每个节点和客户端都会让 counter 追踪当前所看到（包括本机的和通信的）的最大值</strong>。当节点看到请求或者回复中携带的 counter 值比自己大，就会立即用其值设置本地 counter。</p><p><strong>只有在收集到系统中所有操作之后，才能真正确定所有操作的全序</strong>。</p><h3 id="3-3-全序广播"><a href="#3-3-全序广播" class="headerlink" title="3.3 全序广播"></a>3.3 全序广播</h3><p>使用单主模型的系统会面临两个问题：</p><ol><li>当系统负载超过单机可以处理的尺度，如何进行扩容。</li><li>当主节点宕机时如何进行故障转移（failover）。<br>在分布式系统的语境下，该问题也被称为<strong>全序广播</strong>（total order broadcast）或者<strong>原子广播</strong>（atomic broadcast）。</li></ol><p>全序广播是一种多个节点间交换消息的协议。它要求系统满足两个安全性质：</p><ol><li><strong>可靠交付</strong>。如果一个节点收到了消息，则系统内所有的相关节点都要收到该消息。</li><li><strong>全序交付</strong>。每个节点接收到消息的顺序一致。</li></ol><p>全序广播的一个重要性质是：<strong>当收到消息时，其顺序已经确定</strong>。</p><p>可以从另外一个角度来理解全序广播——用来写日志（比如复制日志、事务日志或者写前日志）：<strong>投递消息就像追加日志</strong>。由于所有节点都会按照同样的顺序发送消息，则所有节点在读取日志的时候也会得到同样的消息序列。</p><h4 id="3-3-1-使用全序广播实现线性一致性存储"><a href="#3-3-1-使用全序广播实现线性一致性存储" class="headerlink" title="3.3.1 使用全序广播实现线性一致性存储"></a>3.3.1 使用全序广播实现线性一致性存储</h4><p>全序广播是<strong>异步的</strong>：系统保证以同样的<strong>顺序</strong>交付消息，但并不保证消息的交付<strong>时刻</strong>（即，有的消息接收者间可能存在着滞后）。与之相对，线性一致性是一种<strong>新鲜度保证</strong>：读取一定能看到最新成功的写。</p><ol><li>向服务中追加一个带有某用户名的消息条目，表明你想使用该用户名。</li><li>（由于全序广播是异步的）不断读取日志，直到能够读到刚才你追加的消息条目。</li><li>检查所有想要使用该用户名的消息，这时你可能会得到多条消息，如果你当初写下的消息在第一条，则你是成功的。此时，你可以“确认”（持久化，比如追加日志，比如写入数据库）占有该用户名的信息，然后给客户端返回成功。如果第一条消息不是你的，则终止请求。</li></ol><h4 id="3-3-2-使用线性一致存储实现全序广播"><a href="#3-3-2-使用线性一致存储实现全序广播" class="headerlink" title="3.3.2 使用线性一致存储实现全序广播"></a>3.3.2 使用线性一致存储实现全序广播</h4><p>对于每一个发给全序广播系统的消息，使用整数寄存器 increment-and-get 操作关联一个序列号；然后将消息发送给所有节点（重试任何丢失的消息）。每个节点接收到消息后利用序列号顺序对外交付消息。这种机制很像 TCP，但并不是描述通信双方，而是一个分布式系统。</p><h2 id="4-分布式事务和共识协议"><a href="#4-分布式事务和共识协议" class="headerlink" title="4 分布式事务和共识协议"></a>4 分布式事务和共识协议</h2><p>在很多场景下让多个节点达成共识是非常重要的。比如：</p><ul><li><strong>Leader 选举</strong> 在使用单主模型的数据库中，所有节点需要对谁是主节点达成一致。当网络问题导致有些节点不能正常通信时，领导权就会出现争议。在这种情形下，共识对于避免错误的故障转移非常重要。引入如果出现两个领导者可以同时接受写入（<strong>脑裂</strong>），所有副本上的数据就会产生分叉，从而变得不一致甚而数据丢失。</li><li><strong>原子提交</strong> 在一个横跨多节点或具有多分区的数据库中，可能会出现某个事务在一些节点执行成功，但在另外一些节点却运行失败。如果我们想保持事务的原子性（ACID 中的 A，参见<a href="https://ddia.qtmuniao.com/#/ch07?id=%e5%8e%9f%e5%ad%90%e6%80%a7%ef%bc%88atomicity%ef%bc%89">原子性</a>），我们就必须让所有节点就事务的结果达成一致：要么全部回滚（只要有故障），要么提交（没有任何故障）。这个共识的特例也被称为<strong>原子提交</strong>（atomic commit）。<h3 id="4-1-原子提交和两阶段提交"><a href="#4-1-原子提交和两阶段提交" class="headerlink" title="4.1 原子提交和两阶段提交"></a>4.1 原子提交和两阶段提交</h3>原子性能够避免失败的事务通过半完成（half-finished）或者半更新（half-updated）的结果来破坏数据库系统。</li></ul><p>二级索引是独立于<strong>原始数据</strong>的一种数据结构，因此如果你更新了原始数据，对应的二级索引也需要进行同步更新。原子性能够保证二级索引和原始数据时刻保持一致。</p><h4 id="4-1-1-从单机到分布式的原子提交"><a href="#4-1-1-从单机到分布式的原子提交" class="headerlink" title="4.1.1 从单机到分布式的原子提交"></a>4.1.1 从单机到分布式的原子提交</h4><p>简单地在提交事务时给每个节点发送提交请求让其提交事务，是不能够满足事务基本要求的。这是因为，可能有的节点成功提交了，有的节点却提交失败了，从而违反了原子性保证：</p><ul><li>有些节点在提交时检测到完整性约束被破坏了，因此中止事务；但另外一些节点却能够成功提交。</li><li>有些提交请求由于网络过慢而超时丢弃，另外一些提交请求却成功抵达。</li><li>有一些节点在写入提交记录前宕机重启，导致事务回滚；另外一些节点却成功提交。</li></ul><p><strong>事务提交后是不可撤销的</strong>——在事务提交后，你不能再改变主意说，我要重新中止这个事务。这是因为，一旦事务提交了，就会对其他事务可见，从而可能让其他事务依赖于该事务的结果做出一些新的决策；这个原则构成了<strong>读已提交</strong>（read commited）隔离级别的基础（参见<a href="https://ddia.qtmuniao.com/#/ch07?id=%e8%af%bb%e5%b7%b2%e6%8f%90%e4%ba%a4">读已提交</a>）。如果事务允许在提交后中止，其他已经读取了该事务结果的事务也会失效，从而引起事务的级联中止。</p><p>当然，事务所造成的<strong>结果</strong>在事实上是可以被撤销的，比如，通过<strong>补偿事务</strong>（<em>compensating transaction</em>）。但，从数据库的视角</p><h4 id="4-1-2-两阶段提交"><a href="#4-1-2-两阶段提交" class="headerlink" title="4.1.2 两阶段提交"></a>4.1.2 <em>两阶段提交</em></h4><p><strong>两阶段提交</strong>（2PC，two-phase commit）是一种在多个节点上实现原子事务的算法——即，保证所有节点要么都提交，要么都中止。   相比单机事务的一次提交请求，2PC 中的提交、中止过程被拆分成了两个阶段</p><p><strong>2PC</strong> 引入了一个单机事务中没有的角色：<strong>协调者</strong>（coordinator，有时也被称为事务管理器，transaction manager）。</p><p><strong>2PC 事务</strong>通常也由应用层对多个节点上的数据读写开始。和协调者相对，我们将这些数据节点称为事务的<strong>参与者</strong>（participants）。当应用层准备好提交后，协调者开始阶段一：向每个参与者发送 <strong>prepare</strong> 请求，询问他们是否能够提交。然后，协调者会根据参与者的返回而进行下一步动作：</p><ol><li>如果<strong>所有参与者</strong>都回复“可以”（yes），表示能够提交，则协调者就会进入第二阶段发出<strong>提交</strong>（ <strong>commit</strong> ）请求，此时，提交事实上才开始执行。</li><li><p>如果有任何参与者回复“不行”（no），或者请求超时了，协调者就会进入第二阶段并发送一个 <strong>中止</strong>（abort）请求，中止事务。</p><h4 id="4-1-3-基于承诺的系统"><a href="#4-1-3-基于承诺的系统" class="headerlink" title="4.1.3 基于承诺的系统"></a>4.1.3 基于承诺的系统</h4></li><li><p>当应用想开启一个分布式事务时，它会首先向协调者要一个<strong>事务 ID</strong>。该事务 ID 是全局唯一的。</p></li><li>应用会使用前述事务 ID 向所有的参与者发起一个单机事务，所有节点会各自完成读写请求，在此过程中，如果有任何出错（比如节点宕机或者请求超时），协调者或者任意参与者都可以中止事务。</li><li>当应用层准备好提交事务时，协调者会向所有参与者发送<strong>准备提交</strong>（prepare）请求，并在请求中打上事务 ID 标记。如果有请求失败或者超时，则协调者会对所有参与者发送带有该事务 ID 的中止请求。</li><li>当参与者收到<strong>准备提交</strong>请求时，它必须确认该事务能够在任何情况下都能被提交，才能回复“<strong>可以</strong>”。这包括，将所有写入刷到磁盘（一旦承诺了，就不能反悔，即使之后遇到宕机、断电或者磁盘空间不足）、检查是否有冲突或者违反约束的情况。换句话说，如果回复“可以”，意味着参与者<strong>让渡了中止事务的权利（给协调者）</strong>，但此时并没有真正地提交。</li><li>当协调者收到所有参与者准备提交的回复后，会决定提交还是中止该事务（只有在所有参与者都回复“可以”时，才会提交）。协调者需要将该决策写入事务日志，并下刷到磁盘，以保证即使宕机重启，该决策也不会丢失。这被称为<strong>提交点</strong>（commit point）。</li><li>协调者将决策刷入了磁盘后，就会将决策（提交或者中止）请求发给所有参与方。如果某个请求失败或者超时，则协调者会对其进行无限重试，直到成功。不允许走回头路：如果协调者决定了提交，则不管要进行多少次的重试，也必须要保证该决策的执行。如果参与者在此时宕机了，则当重启时也必须进行提交——因为它<strong>承诺过要提交</strong>，因此在重启后不能拒绝提交。</li></ol><p>该协议有两个重要的“不可回退点”：</p><ol><li>当某个参与者回复“可以”时，就做出了（将来无论发生什么）肯定可以提交的承诺。（当然，协调者可以中止事务）</li><li>当协调者决定提交时，该决定一旦做出（写入磁盘），就是不可撤回的。</li></ol><h4 id="4-1-4-协调者故障"><a href="#4-1-4-协调者故障" class="headerlink" title="4.1.4 协调者故障"></a>4.1.4 协调者故障</h4><p>如果协调者在准备提交请求发送前故障，则参与者可以放心的中止事务。然而，一旦参与者收到准备提交请求，并且回复“可以”，则根据 2PC 设定，它<strong>不能单方面的中止事务</strong>——而必须等待协调者的提交或者中止请求。如果此时协调者宕机或者网络故障，则参与者只能<strong>死等</strong>。参与者事务的这种状态称为<strong>存疑</strong>（in doubt）或者<strong>未定</strong>（uncertain）。</p><p>在 2PC 中，唯一使算法能够完成的方法就是等待协调者恢复。这也是为什么，协调者在给参与者发送提交或者中止消息时，需要先将该决策写入事务日志中：当协调者恢复时，他就能从事务日志中读取该决策，以让所有处于未决状态的参与者状态确定下来。如果协调者恢复了，发现并没有写入任何决策到事务日志中，则中止该事务。因此，2PC 的<strong>提交点</strong>（commit point）最终可以归结到协调者上的单机原子提交。</p><h4 id="4-1-5-三阶段提交"><a href="#4-1-5-三阶段提交" class="headerlink" title="4.1.5 三阶段提交"></a>4.1.5 三阶段提交</h4><p>由于 2PC 在等待协调者宕机恢复时系统可能会卡住，因此两阶段提交又称为<strong>阻塞式原子提交协议</strong>（blocking atomic commit protocol）。<br>作为 2PC 的替代，人们又提出了三阶段提交（three-phase commit）。然而，3PC 对系统有一定假设：网络具有有界延迟，请求延迟也是有界的（bounded，参见<a href="https://ddia.qtmuniao.com/#/ch08?id=%e8%b6%85%e6%97%b6%e5%92%8c%e6%97%a0%e7%95%8c%e5%bb%b6%e8%bf%9f%ef%bc%88unbounded-delays%ef%bc%89">超时和无界延迟</a>）。在具有无界网络延迟进程停顿的实际系统中，3PC 无法保证原子性。<br>在具有无界延迟的网络中，超时机制就不是一个可靠的故障检测方法，即使没有任何节点故障，一个请求仍会由于网络问题而超时。出于这个原因，即使 2PC 可能会因为协调者宕机卡住，但人们仍然在使用它，而没有转向 3PC。</p><h3 id="4-2-实践中的分布式事务"><a href="#4-2-实践中的分布式事务" class="headerlink" title="4.2 实践中的分布式事务"></a>4.2 实践中的分布式事务</h3><p>分布式事务，尤其是使用两阶段提交实现的分布式事务，毁誉参半。一方面，他们可以提供其他方式难以实现的<strong>安全保证</strong>；另一方面，由于运维复杂、降低性能、承诺过多，他们广受诟病。为了避免分布式事务带来的运维复杂度，很多云服务选择不支持分布式事务。</p><p>两种完全不同的分布式事务经常被混淆：</p><ul><li><strong>数据库内部分布式事务</strong> 在一些分布式数据中（标配支持多分区和多副本的数据库），支持跨节点的<strong>内部分布式事务</strong>。如，VoltDB 和 MySQL 集群的 NDB 存储引擎就有这样的内部事务支持。在这种情况下，所有事务参与节点都运行着同样的二进制代码。</li><li><strong>异构的分布式事务</strong> 在异构的分布式事务中，所有参与者使用了两种以上的技术栈：如，来自不同厂家的两种数据库实例，甚至可能包含非数据库系统，如消息队列。即使每个子系统内部实现完全不同，构建于其上的分布式事务也能够保证原子提交。</li></ul><p>数据库内部的事务不需要考虑和其他系统的相容性，因此在实现时可以使用任何协议、可以针对特定技术栈进行任何优化。因此，数据库内部的分布式事务通常能够很好地工作。相反，横跨多个异构系统的事务实现则充满了挑战。</p><h4 id="4-2-1-恰好一次的消息处理"><a href="#4-2-1-恰好一次的消息处理" class="headerlink" title="4.2.1 恰好一次的消息处理"></a>4.2.1 恰好一次的消息处理</h4><p>异构的分布式事务系统可以将多种异构的系统，以强大的方式进行整合。例如，<strong>当且仅当</strong>数据库中处理消息的事务成功提交时，消息队列才会将该消息标记为<strong>已处理</strong>。可以将消息确认和数据库写入打包在单个事务里进行原子提交，来实现上述行为。</p><h4 id="4-2-2-XA-事务"><a href="#4-2-2-XA-事务" class="headerlink" title="4.2.2 XA 事务"></a>4.2.2 XA 事务</h4><p>XA 不是一个网络协议——它定义了一组和事务协调者交互的 C 语言 API 接口。<br>使用事务的<strong>应用层</strong>会以网络驱动（network driver）或者客户端库（client library）来使用 XA 的 API 与参与者服务（数据库或者消息队列）进行交互。如果驱动程序支持 XA 协议，则意味着应用侧可以调用 XA 的 API 来确定一个操作是否是分布式事务的一部分（即通过 XA 定义的接口来确定事务所涵盖<strong>操作的边界</strong>）；如果是，则会发送必要的消息给参与者。XA 驱动也提供了一些回调，协调者可以使用这些回调要求参与者进行准备、提交或者中止。</p><p>事务的<strong>协调者</strong>实现了 XA API。XA 的标椎并没规定协调者该如何实现，并且在实践中协调者通常以<strong>库的形式</strong>被加载进应用程序中（作为应用程序的一部分，而非额外单独的一个服务）。它会追踪事务中的所有参与者，在要求参与者准备提交（prepare）后收集其回复，使用本地磁盘上的日志来跟踪每个事务的<strong>提交/中止</strong>决策。</p><h4 id="4-2-3-阻塞时持有锁"><a href="#4-2-3-阻塞时持有锁" class="headerlink" title="4.2.3 阻塞时持有锁"></a>4.2.3 阻塞时持有锁</h4><p>问题的关键点在于存在<strong>锁</strong>（locking）。数据库中的事务通常会使用行级别的互斥锁来保护对某一行的修改，以防止脏写。更进一步，如果想获得可串行化隔离级别，数据库在使用两阶段锁进行实现时，会对事务所有读过的行加共享锁（参见<a href="https://ddia.qtmuniao.com/#/ch07?id=%e4%b8%a4%e9%98%b6%e6%ae%b5%e9%94%81">两阶段锁</a>）。<br>数据库在提交或者中止事务前<strong>不能够释放获取的这些锁</strong>。因此，在使用两阶段提交时，一个事务必须在其处于未定状态期间一直持有锁。如果协调者在宕机后花了 20 分钟才重新启动起来，则对应参与者的锁就要持有 20 分钟。如果参与者日志由于某种原因丢掉了，这些锁会被永远的持有——除非系统管理员会手动释放它们。</p><h4 id="4-2-4-从协调者故障中恢复"><a href="#4-2-4-从协调者故障中恢复" class="headerlink" title="4.2.4 从协调者故障中恢复"></a>4.2.4 从协调者故障中恢复</h4><p>在实践中，常会产生一些孤立的（orphaned）未定事务——即，由于某种原因，<strong>事务的协调者</strong>（比如由于软件 bug 事务日志丢失或者损坏）<strong>无从判断事务的最终结果是提交还是回滚</strong>。由是，这些事务不能够被自动的处理，从而永久的卡在那里，持有锁并且阻塞其他事务。<br>唯一的出路是让管理员手动的来提交或者中止事务。<br>很多 XA 事务的实现会留有紧急后门，称为<strong>启发式决策</strong>（<em>heuristic decisions</em>）：允许一个参与者不用等待协调者的决策，而<strong>单方面</strong>决定中止还是提交一个未定事务。需要说明的是，这里的启发式仅仅是<strong>可能打破原子性</strong>（probably breaking atomicity）的一种委婉说法。因为这么做可能会违反两阶段提交所提供的保证。因此这种启发式决策仅是为了救急，而不能进行日常使用。<em>**</em></p><h4 id="4-2-5-分布式事务的限制"><a href="#4-2-5-分布式事务的限制" class="headerlink" title="4.2.5 分布式事务的限制"></a>4.2.5 分布式事务的限制</h4><p>分布式事务有<strong>放大故障</strong>的嫌疑，这与我们构建容错系统的目标背道而驰（这就是 tradeoff，为上层提供的更多的一致性保证，就会牺牲性能，降低可用性）。</p><h3 id="4-3-容错的共识算法"><a href="#4-3-容错的共识算法" class="headerlink" title="4.3 容错的共识算法"></a>4.3 容错的共识算法</h3><p>共识协议通常被描述为：一个或者多个节点可能会各自<strong>提议</strong>（propose）一些值，共识协议需要在这些值中间做出唯一的<strong>决策</strong>（decide）。</p><ul><li><strong>全局一致性</strong>（<em>Uniform agreement</em>） 没有任何两个节点最终做出不同决策。</li><li><strong>正直性</strong>（<em>Integrity</em>） 没有任何节点会做出两次决策（不会反复横跳）</li><li><strong>有效性</strong>（<em>Validity</em>） 如果一个节点做出了决策，该决策所对应的值一定来自系统内某个节点的提议</li><li><strong>可终止性</strong>（<em>Termination</em>） 任何没有宕机的节点，最终都会给出对某个值的决策<br>全局一致和正直性定义了共识协议的核心概念：<strong>所有节点都要决策出同样的结果，并且一旦做出决策，就不能反悔</strong>。加入有效性更多的是为了排除一些无效（trivial）结果</li></ul><p><strong>可终止性是对容错的一种形式化描述</strong>（从结果来描述）。它本质上是在说，一个共识算法不能让系统陷入一种卡在那、啥也不干，直到永远的状态。换句话说，系统必须能够正常运作，即使有些节点宕机，其他节点也必须能够继续做出决策。（可结束性是存活性，liveness，而其他三个性质是安全性，safety，</p><p>可终止性受限于少于半数节点宕机或不可达的假设。然而，大多数共识算法的实现在大多数节点都宕机或者网络出现大范围故障时仍然能保持安全性——一致性，正直性和有效性。也即，大范围的节点下线可能会让系统<strong>不能继续处理请求</strong>，但<strong>不会因此破坏共识协议</strong>，让其做出不合法决策。</p><h4 id="4-3-1-全序广播中的共识算法"><a href="#4-3-1-全序广播中的共识算法" class="headerlink" title="4.3.1 全序广播中的共识算法"></a>4.3.1 全序广播中的共识算法</h4><p>全序广播等价于多轮次的共识协议（每个轮次，会使用共识协议对全序广播中的一条消息的全局顺序做出决策）：</p><p>由于共识协议的全局一致性，所有节点会以同样的顺序投递同样的消息。<br>由于正直性，具有同样 id 的消息不会重复。<br>由于有效性，消息不会是损坏的，也不会是凭空捏造的。<br>由于可终止性，消息不会丢失。</p><h4 id="4-3-2-单主复制和共识协议"><a href="#4-3-2-单主复制和共识协议" class="headerlink" title="4.3.2 单主复制和共识协议"></a>4.3.2 单主复制和共识协议</h4><p>核心点在于<strong>主节点（领导者）是怎样选出的</strong>。如果主节点由运维团队的管理员手动配置，你本质上就获得了一个“共识算法”的独裁变种：只有一个节点允许接受写入（决定复制日志中所有日志的顺序），并且一旦该主节点宕机，系统便会陷入不可用的状态，直到运维人员手动的配置另外一个节点为主节点。这样的系统在实践中也可以正常运作，但是并不满足共识算法中的可终止性，因为它在停顿后要求运维人员的干预，才能继续运转。</p><p>有些数据库在遇到主节点故障时，会自动地重新进行主选举，将一个从节点提升为新的主节点（参见<a href="https://ddia.qtmuniao.com/#/ch05?id=%e5%ae%95%e6%9c%ba%e5%a4%84%e7%90%86">宕机处理</a>）。这就让我们进一步逼近了可容错的全序广播，并且解决了共识问题。</p><h4 id="4-3-3-纪元编号和法定人数"><a href="#4-3-3-纪元编号和法定人数" class="headerlink" title="4.3.3 纪元编号和法定人数"></a>4.3.3 纪元编号和法定人数</h4><p>协议会定义一个<strong>纪元编号</strong>，且保证在每一个纪元（epoch）内，主节点是唯一的。</p><p>每次当前的主节点被认为下线时（可能是宕机，也可能只是网络不通），所有认为该主下线的节点就会发起选举，以选出新的主节点。每次选举会使用一个更高的纪元编号，因此所有的纪元编号是全序且单调递增的。如果不同纪元中有两个节点都认为自己是主（比如之前的主节点并没有宕机），则具有较高纪元编号的主节点胜出。</p><p>在一个主节点被授权做任何事之前，它必须要确认不会有更权威的主节点（具有更高的纪元编号）会做出不同决策</p><p>因此，主节点在决策前需要首先从所有节点获得法定票数（参见<a href="https://ddia.qtmuniao.com/#/ch05?id=quorum-%e8%af%bb%e5%86%99">Quorum 读写</a>）。对于每个决策，主节点都必须将其作为提案发给其他所有节点，并且等待法定节点的同意。法定节点通常来说，会包含多数派节点，但也不绝对（<a href="https://arxiv.org/abs/1608.06696">Flexible Paxos</a>介绍了一种不需要多数节点的放宽的 Paxos 算法）。如果法定节点的回复中没有任何更高纪元的，则当前主节点可以放心的认为没有发生新纪元的主选举，并可以据此认为他仍然“握有领导权”。从而，可以安全的对提案进行决策。</p><p>投票过程非常像两阶段提交提交算法。最大的区别在于：</p><ol><li>2PC 中的协调者不是被选出来的。</li><li>2PC 要求每一个参与者都回复“可以”，而可容错的共识算法只要求多数节点的投票。</li></ol><h4 id="4-3-4-共识算法的局限性"><a href="#4-3-4-共识算法的局限性" class="headerlink" title="4.3.4 共识算法的局限性"></a>4.3.4 共识算法的局限性</h4><p><strong>同步复制损失性能</strong>。每次进行决策（更改数据）前都要让多数节点进行投票，意味着这是一个同步复制系统。在<a href="https://ddia.qtmuniao.com/#/ch05?id=%e5%90%8c%e6%ad%a5%e5%a4%8d%e5%88%b6%e5%92%8c%e5%bc%82%e6%ad%a5%e5%a4%8d%e5%88%b6">同步复制和异步复制</a>一节中我们讲过，很多数据库都会配置为异步复制。在这种配置下，有些已经提交的数据在进行恢复时可能会丢失，但很多人仍然选择这种模式——承担这种风险，以换取更好的性能。</p><p><strong>多数派会增加系统冗余</strong>。共识系统总是要求有<strong>严格多数节点</strong>存活才能正常运行。这意味着，如果你要容忍单节点故障就至少需要三个节点（三节点中的两个节点可以组成多数派），如果要容忍两个节点故障就至少需要五个节点（五个节点中的三个节点组成多数派）。如果网络故障切断了其中一些节点和其他节点的联系，则只有连通的多数派节点可以正常运行，其他节点都会被阻塞。</p><p><strong>动态成员变更复杂</strong>。很多共识算法会假定有固定的数目节点参与投票，这意味着你不能往集群中增删节点。共识算法的<strong>动态成员变更</strong>（dynamic membership）扩展允许集群的节点集随时间推移而发生变动，但相对于静态成员算法，这种扩展版本非常难以理解。</p><p><strong>复杂网络环境性能很差</strong>。共识系统通常通过超时机制来对故障节点进行检测。在延迟高度变化的网络中，尤其是多地部署的分布式系统中，某些存活节点由于网络的瞬时抖动常被误认为发生了故障。尽管这些问题并不会破坏安全性，但频繁的领导者选举会导致极差的性能表现——系统可能会大部分时间都在选主而不是正常干活上。</p><p><strong>共识算法对网络故障非常敏感</strong>。</p><h3 id="4-4-成员关系和协调服务"><a href="#4-4-成员关系和协调服务" class="headerlink" title="4.4 成员关系和协调服务"></a>4.4 成员关系和协调服务</h3><p>Zookeeper 和 etcd 设计目标为<strong>存储小尺度的数据</strong>，比如能装进内存里的</p><p>这些系统使用可容错的全序广播算法，将小尺寸的数据被复制到所有节点上。如前所述，我们做数据库复制的时候真正需要的东西其实是全序广播：如果每条消息代表针对数据库的一个修改，以相同的顺序对所有副本应用相同的改动，能够将数据库保持在一致的状态。</p><p>Zookeeper 是模仿 Google 的 Chunk 锁服务实现的，不仅实现了全序广播算法（进而实现了共识），也实现了其他一些对分布式系统非常有用的功能集：</p><ul><li><strong>线性化的原子操作（lock）</strong> 使用原子的 CAS 操作，可以实现锁：如果多个节点并发执行同一个操作，只有一个会成功。共识协议能够保证，即使随时可能出现节点宕机或者网络故障，操作仍然是原子和线性化的。一个分布式锁通常实现为具有<strong>过期时间的“租约”</strong>（lease），这样即使客户端宕机，锁也能够被最终释放。</li><li><strong>操作的全序保证（zxid）</strong> 在<a href="https://ddia.qtmuniao.com/#/ch08?id=%e9%a2%86%e5%af%bc%e8%80%85%e5%92%8c%e9%94%81">领导者和锁</a>一节中我们讨论过，当某个资源被锁或者租约保护时，你需要<strong>防护令牌机制</strong>来防止由于进程停顿而造成的加锁冲突。防护令牌一个在每次获取锁都会单调自增的数值。Zookeeper 通过给每个操作赋予一个全局自增的事务 id（zxid）和一个版本号（cversion）来提供该功能。</li><li><strong>故障检测（ephemeral node）</strong> 客户端和 ZooKeeper 的服务器间维持着一个长会话，客户端和服务端通过周期性的心跳来检测对端是否仍然存活。即使该连接短暂断掉，或者 ZooKeeper 节点故障，该会话仍然能够存活。但如果，心跳停顿间隔过长，超过了会话的超时阈值，ZooKeeper 会标记该会话死亡。所有该会话关联的锁在超时都将会被释放（ZooKeeper 将其称为<strong>暂态节点</strong>，ephemeral nodes，这类节点可以将生命周期与会话进行绑定）。</li><li><strong>变动通知（watch）</strong> 客户端不仅可以读取其他节点创建的锁或者值，也可以直接对这些对象的变化进行<strong>守望</strong>（watch）。通过守望机制，客户端可以立即发现是否有其他客户端加入集群（通过这些客户端写入 ZooKeeper 的值）、其他客户端是否故障（通过这些客户端注册到 ZooKeeper 中的暂态节点的消失）。通过订阅这些通知，客户端可以避免频繁地去 ZooKeeper 拉取信息，比对以确定是否发生了某些变化。</li></ul><h4 id="4-4-1-为节点分配任务"><a href="#4-4-1-为节点分配任务" class="headerlink" title="4.4.1 为节点分配任务"></a>4.4.1 为节点分配任务</h4><p>ooKeeper 通常运行在固定节点的集群上（通常是三个或者五个），并且只须在这几个节点间达成共识，然后就可以支持非常多的客户端访问。这样，ZooKeeper 提供了一种可以将<strong>部分功能</strong>（共识算法、外包定序、故障检测）“<strong>外包</strong>”（outsouring）给外部服务的方法。</p><h4 id="4-4-2-服务发现"><a href="#4-4-2-服务发现" class="headerlink" title="4.4.2 服务发现"></a>4.4.2 服务发现</h4><p>即根据服务名称找到其对应的 IP 地址以进行连接。在数据中心的环境中，虚拟机的来来去去非常普遍，因此很难事先知道某个服务的 IP 地址。因此，你可以对服务进行配置，让其在启动的时候在<strong>某个服务</strong>（通常是名字服务器，nameserver）注册自己的地址和端口，其他人就能使用名字来找到该服务的最终地址。</p><h4 id="4-4-3-成员服务"><a href="#4-4-3-成员服务" class="headerlink" title="4.4.3 成员服务"></a>4.4.3 成员服务</h4><p>成员服务可以确定当前<strong>集群中哪些节点当前是存活的</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> DDIA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDIA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[DDIA] 分布式系统中的麻烦事</title>
      <link href="/2023/07/14/DDIA/07%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%BA%BB%E7%83%A6%E4%BA%8B/"/>
      <url>/2023/07/14/DDIA/07%20%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%BA%BB%E7%83%A6%E4%BA%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>是否要在目标场景下解决这些问题、还是为了降低系统复杂度忽略这些问题</p></blockquote><span id="more"></span><h2 id="1-故障和部分失败"><a href="#1-故障和部分失败" class="headerlink" title="1 故障和部分失败"></a>1 故障和部分失败</h2><p>单机系统通常具有一种很好地特性：<strong>要么正常运行、要么出错崩溃，而不会处于一种中间状态</strong>。</p><p><strong>部分失败</strong>（partial failure），即系统的一部分正常工作，另一部分却以某种诡异的方式出错。这些问题，多数都是由于连接不同主机的<strong>异步网络</strong>所引入的。</p><h3 id="1-1-云计算和超算"><a href="#1-1-云计算和超算" class="headerlink" title="1.1 云计算和超算"></a>1.1 云计算和超算</h3><ul><li>在线离线， 故障常态化，  容错</li><li>为了让分布式系统能够工作，就必须假设故障一定会存在，并在设计层面考虑各种出错处理。即，<strong>我们要基于不可靠的组件构建一个可靠系统</strong>。</li></ul><h3 id="1-2-基于不可靠组件构建可靠系统"><a href="#1-2-基于不可靠组件构建可靠系统" class="headerlink" title="1.2 基于不可靠组件构建可靠系统"></a>1.2 基于不可靠组件构建可靠系统</h3><ol><li>纠错码能够容忍信道中偶尔一两个比特的误传。</li><li>IP 层不可靠，但 TCP 层却基于 IP 层提供了相对可靠的传输保证。</li></ol><h2 id="2-不可靠的网络"><a href="#2-不可靠的网络" class="headerlink" title="2 不可靠的网络"></a>2 不可靠的网络</h2><p><strong>所有机器不共享资源（如内存、磁盘），通信的唯一途径就是网络</strong>。<br>互联网和数据中心（多是以太网）的内部网络多是<strong>异步封包网络</strong>（<strong>asynchronous packet networks</strong>）。</p><ol><li>请求没有发出去就丢了（比如你的网线可能被拔了）</li><li>请求可能先排了会队，稍后才被发出去（比如网络或接收方负载过高）</li><li>对端节点挂了（比如遇到异常宕机或者断电了）</li><li>对端节点临时无响应（比如正在进行 GC），但稍后又能正常工作</li><li>对端节点处理了你的请求，但应答在网络回程中丢了（比如网关配错了）</li><li>对端节点处理了你的请求，但应答被推迟了（比如网络或你的机器负载过高）</li></ol><p>在异步网络中，当你发送出一个请求，并在一段时间内没有收到应答，任何事情都有可能发生：由于没有收到任何信息，你无从得知具体原因是什么。甚至，你都不知道你的请求是否已被送达处理。</p><p>应对这种情况的惯常做法是——<strong>超时</strong>（timeout）。即，设定一个时限，到点后，我们便认为这个请求废了。但在实际上，该请求可能只是还在排队、可能稍后到到达远端节点、甚至可能最终还会收到应答。</p><h3 id="2-1-故障检测"><a href="#2-1-故障检测" class="headerlink" title="2.1 故障检测"></a>2.1 故障检测</h3><p><strong>自动检测故障节点</strong>，并据此做出一些决策：</p><ul><li>负载均衡器需要停止对故障节点流量的分发。</li><li>在单主模型的分布式数据库中，如果主节点故障，需要选出一个从节点顶上。</li></ul><ul><li><strong>操作系统通知</strong>。如果你能触达<strong>服务</strong>所在<strong>机器</strong>，但发现没有进程在监听预期端口（比如对应服务进程挂了），操作系统会通过发送 RST 或 FIN 包来关闭 TCP 连接。但是如果对端节点在处理你的请求时整个宕机了，就很难得知你请求的具体处理进度。</li><li><strong>daemon 脚本通知</strong>。可以通过一些 daemon <strong>脚本</strong>，在本机服务进程死掉之后，主动通知其他节点。来避免其他节点通过发送请求超时来判断此节点宕机。当然这前提是，服务进程挂了，但所在节点没挂。</li><li><strong>数据链路层面</strong>。如果你是管理员，并且能访问到你数据中心的网络交换机，可以在数据链路层判断远端机器是否宕机。当然如果你访问不到交换机，那这种方法就不太行。</li><li><strong>IP 不可达</strong>。如果路由器发现你要发送请求的 IP 地址不可达，它会直接回你一个 ICMP 不可达包。但路由器也并不能真正判断是否该机器不可用了。</li></ul><p>设置一个<strong>合理的超时时限</strong>和重试次数。直到，你确认没有再重试的必要——即不管远端节点是否存活，我在重试几次后，都认为它不可用了（或者暂时不可用）。</p><h3 id="2-2-超时和无界延迟（unbounded-delays）"><a href="#2-2-超时和无界延迟（unbounded-delays）" class="headerlink" title="2.2 超时和无界延迟（unbounded delays）"></a>2.2 超时和无界延迟（unbounded delays）</h3><p><strong>超时间隔</strong>要设置多久呢？总的来说：</p><ol><li>不能太长：过长会浪费很多时间在等待上。</li><li>不能太短：太短会造成误判，误将网络抖动也视为远端节点失败。</li></ol><p>设有一个理想的网络系统，能够保证所有的网络<strong>通信延迟不超过 d</strong>：所有的网络包要么在 d 时间内送达对端、要么就会丢失，即不可能在超过 d 的时限后才到。如果网络能提供此种保证，则应用层可大为简化：假设我们预估出单个请求最大处理时间 r，则 2d+r 是一个很好超时间隔。</p><h4 id="2-2-1-网络拥塞和数据包排队"><a href="#2-2-1-网络拥塞和数据包排队" class="headerlink" title="2.2.1 网络拥塞和数据包排队"></a>2.2.1 网络拥塞和数据包排队</h4><p><strong>网络流量越满，单个请求延迟抖动越大</strong>。</p><h4 id="2-2-2-同步网络和异步网络"><a href="#2-2-2-同步网络和异步网络" class="headerlink" title="2.2.2 同步网络和异步网络"></a>2.2.2 同步网络和异步网络</h4><p>固话网会为每一次通话预留<strong>稳定低延迟</strong>和<strong>充足的带宽</strong>链路以传输语音。</p><h2 id="3-不可靠的时钟"><a href="#3-不可靠的时钟" class="headerlink" title="3 不可靠的时钟"></a>3 不可靠的时钟</h2><p>实践中，常通过 <strong>NTP</strong>（网络时间协议）对机器进行自动校准。其大致原理是，首先使用更精确时钟（如 GPS 接收器）构建一组<strong>可信服务器</strong>作为时钟源（比如阿里云的源），</p><h3 id="3-1-单调时钟"><a href="#3-1-单调时钟" class="headerlink" title="3.1 单调时钟"></a>3.1 单调时钟</h3><p>单调时钟主用于取两个时间点的<strong>差值</strong>来测量时间间隔，如服务器的超时间隔和响应时间。</p><h3 id="3-2-时间戳以定序"><a href="#3-2-时间戳以定序" class="headerlink" title="3.2 时间戳以定序"></a>3.2 时间戳以定序</h3><ol><li><strong>写入谜之丢失</strong>。一个具有落后时钟的节点产生的写入数据，无法覆盖一个具有超前时钟节点先前写入的数据，造成后写入的数据反而被没有任何提醒的丢弃。</li><li><strong>无法区分先后和并行</strong>。两者主要区别在于，一个是有明显的依赖关系，如上图中自增依赖于之前的初始化；另一个是相关的几个操作互相并不关心。为了解决这个问题，需要引入额外的时间戳机制进行因果关系追踪，如 version vector（一种逻辑时钟）。</li><li><strong>两个独立节点可能会产生相同时间戳的事件</strong>。尤其是在时钟精读不太够的情况下（比如最低只能给到毫秒），可以使用额外的随机数来对其进一步区分，但这样也会导致一些时间上的因果问题。</li></ol><h3 id="3-3-进程停顿"><a href="#3-3-进程停顿" class="headerlink" title="3.3 进程停顿"></a>3.3 进程停顿</h3><p>分布式系统中的节点可能在<strong>任意时刻</strong>的<strong>任意代码位置</strong>停顿<strong>任何时长</strong>，而在此间，系统的其他节点仍在正常往前执行，甚至由于该节点不响应而将其标记为死亡。最终，该停顿节点可能会继续执行</p><p>有一些手段可以用来减轻进程停顿现象，且不必借助代价高昂的强实时系统。比如<strong>垃圾回收器</strong>（GC 进程）可以实时追踪<strong>对象分配速率</strong>和剩余<strong>可利用内存</strong>，利用这些信息，GC 进程可以给应用程序提供一些信号。然后我们在构造系统时捕获这些信号，然后拒绝服务一段时间，等待 GC 结束。就跟临时故障或者下线的节点一样，别的节点会来接管请求。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> DDIA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDIA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[DDIA] 事务</title>
      <link href="/2023/06/20/DDIA/06%20%E4%BA%8B%E5%8A%A1/"/>
      <url>/2023/06/20/DDIA/06%20%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>从<strong>时间</strong>和<strong>空间</strong>两个角度来理解事务，从生命周期（时间）来讲，事务要保证一组操作的整体性；从并发控制（空间），事务要做好多个事务间的并发控制。</p></blockquote><span id="more"></span><p>在分布式数据系统中，任何问题都有可能发生：</p><ol><li>系统侧：数据库系统和硬件系统任何时间都有可能发生故障</li><li>应用侧：使用数据库的应用程序任何时刻都有可能故障。</li><li>网络侧：应用程序和数据库间，数据库的多个节点间，随时都有可能断开连接。</li><li>多个客户端：并发写入时，可能会有竞态条件和相互覆盖。</li><li>半读：一个客户端可能会读到部分更新的数据库。</li></ol><p><strong>事务</strong>，就是数据库为了解决类似的问题，所提供的一种保证，以<strong>简化应用层的编程模型</strong>。</p><p><strong>事务</strong>就是将一组语句（或者说操作）打包成一个逻辑单元进行执行，并提供一种保证，这一组操作要么全部成功（ <strong>commit</strong>，应用到数据库里），要么全部失败（被动 <strong>abort</strong>，或者主动 <strong>rollback</strong>），而不会存在只执行了一半的中间状态。此外，如果多个客户端的事务并发执行，会涉及到隔离性的问题，一般来说，数据库允许用户在隔离级别和性能之间做选择。</p><p>用户在发现事务失败后，可以放心的进行重试，直到成功，就可以确定事务中的所有操作都生效了。但任何便利性都是有代价的，事务便是在一定程度上牺牲了性能和可用性。</p><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><h3 id="1-1-ACID"><a href="#1-1-ACID" class="headerlink" title="1.1 ACID"></a>1.1 ACID</h3><p>Atomicity、Consistency、Isolation 和 Durability</p><h4 id="1-1-1-原子性"><a href="#1-1-1-原子性" class="headerlink" title="1.1.1 原子性"></a>1.1.1 原子性</h4><p>原子性所提供的保证是：<strong>在发生错误时，会回滚该事务所有已经写入的变更</strong>。</p><h4 id="1-1-2-一致性"><a href="#1-1-2-一致性" class="headerlink" title="1.1.2 一致性"></a>1.1.2 一致性</h4><p>一致性是对某些<strong>不变性（invariants）</strong> 的维持，所谓不变性，即某些约束条件。如，在银行账户中，在任何时刻，账户余额须等于收入减去支出。</p><p>不同于 ACID 中其他性质，一致性是需要<strong>应用侧</strong>和<strong>数据库侧</strong>共同维护的：</p><ol><li>应用侧需要写入满足应用侧视角约束要求的数据。</li><li>数据库侧需要保证多次写入前后，尤其是遇到问题时，维持该约束。<h4 id="1-1-3-隔离性"><a href="#1-1-3-隔离性" class="headerlink" title="1.1.3 隔离性"></a>1.1.3 隔离性</h4>每个事务的执行是互相隔离的，每个事务都可以认为自己是系统中唯一正在运行的事务，因此传统上，教科书将事务隔离形式称为：<strong>可串行化（Serializability）</strong>。即，如果所有事务都串行执行，则任意时刻必然只有一个事务在执行，从而在根本上消除任何并发问题。<h4 id="1-1-4-持久性"><a href="#1-1-4-持久性" class="headerlink" title="1.1.4 持久性"></a>1.1.4 持久性</h4>持久性是一种保证，即事务一旦提交，即使服务器宕机重启、甚至发生硬件故障，已经提交的事务所写入的数据就不会丢失。</li></ol><p><strong>持久性</strong>都只能做到某种程度的保证，而非绝对保证，比如：</p><ol><li>对于单机，可以容忍宕机。但磁盘坏了就完犊子。</li><li>对于多机，可以容忍少数副本损坏，但是多数副本完后也没辙。</li></ol><h3 id="1-2-单对象和多对象操作"><a href="#1-2-单对象和多对象操作" class="headerlink" title="1.2 单对象和多对象操作"></a>1.2 单对象和多对象操作</h3><p>对象事务中，一个关键点是如何确定多个操作是否属于同一事务：</p><ol><li>从<strong>物理上来考虑</strong>。可以通过 TCP 连接来确定，在同一个连接中，<code>BEGIN TRANSACTION</code> 和  <code>COMMIT</code>语句之间的所有内容，可以认为属于同一个事务。但会有一些 corner case，如在客户端提交请求后，服务器确认提交之前，网络中断，连接断开，此时客户端则无从得知事务是否被成功提交。</li><li><strong>从逻辑上来考虑</strong>。使用事务管理器，为每个事务分配一个唯一标识符，从而对操作进行分组。</li></ol><p>实际中基本上使用第二种方法。</p><h4 id="1-2-1-单对象写入"><a href="#1-2-1-单对象写入" class="headerlink" title="1.2.1 单对象写入"></a>1.2.1 单对象写入</h4><p>当只更改单个对象时，仍会面临原子性和隔离性的问题<br>一般的数据库哪怕不支持完整的事务，也会提供针对单个对象的原子性和隔离性。比如，可以使用写前日志来保证原子性，使用锁来保证隔离性。</p><p>其他一些数据库，也会提供更复杂的原子支持，如原子的自增操作，从而避免交错更新。另一种更泛化的原子性保证是提供单个对象上的 CAS 操作，允许用户原子的执行针对单个对象的 read-modify-write 操作。当然，如果咬文嚼字一下，<strong>原子自增</strong>（atomic increment），在 ACID 中应该是属于隔离性（Isolation）的范畴，此处的原子自增其实是多线程的概念。</p><h4 id="1-2-2-界定对多对象事务的需求"><a href="#1-2-2-界定对多对象事务的需求" class="headerlink" title="1.2.2 界定对多对象事务的需求"></a>1.2.2 界定对多对象事务的需求</h4><p>跨机器的分布式事务很难实现、且非常损失性能（可能在一个数量级），很多分布式数据库选择不支持多对象事务。但有些场景确实需要多对象事务，因此一些数据库多将是否打开事务设为一个开关。</p><p>需要协同更新多个对象：</p><ol><li>在关系型数据库中，一些表通常会有一些外键。在更新时，需要进行同步更新。</li><li>在文档型数据库中，相关的数据通常会放到一个文档中，但由于大部分文档数据库不支持 Join，因此不得不使用前文提到的 denormalization 对信息进行冗余存储，便产生了同步更新需求。</li><li>在支持次级索引的数据库中，数据和对应的多个索引需要进行同步更新。</li></ol><h4 id="1-2-3-故障和终止"><a href="#1-2-3-故障和终止" class="headerlink" title="1.2.3 故障和终止"></a>1.2.3 故障和终止</h4><p>事务的一个重要特点是在执行到一半时，可以安全的终止并重试。事务的设计哲学是：当出现违反原子性、隔离性和持久性的危险时，就<strong>丢弃而非保留</strong>已经发生的修改。</p><p>另一些场景，如多副本中的无主模型，就采用了“<strong>尽力而为</strong>”的模型，即尽可能的保证完成任务，如不能完成，也不会回滚已经发生的修改。因此，应用侧需要处理这种半完成的状态。</p><ol><li>事务已经被成功提交，但返回给用户时出错。用户如果简单重试，就会使该事务中的操作执行两次，从而造成数据冗余，除非用户在应用代码侧进行去重（如多次执行这些语句，效果一样）。</li><li>由于系统负载过高，而造成事务执行失败。如果无脑重试，会进一步加重系统负担。此时可以使用指数后退方式重试，并且限制最大重试次数。</li><li>一些临时错误，如死锁、异常、网络抖动和故障切换时，重试才有效；对于一些永久故障，重试是没有意义的。</li><li>某事务在数据库之外如有副作用，重试事务时，会造成副作用的多次发生。如果某个事务的副作用是发送邮件，则肯定不希望事务每次重试时都发送一次电子邮件。如果想进行多个系统间的协同，可以考虑两阶段提交。</li><li>如果客户端在写入数据时故障，则所有该客户端正在执行的事务所涉及的数据修改都会丢失。</li></ol><h2 id="2-几种弱隔离级别"><a href="#2-几种弱隔离级别" class="headerlink" title="2 几种弱隔离级别"></a>2 几种弱隔离级别</h2><p>数据库试图通过<strong>事务隔离</strong>（transaction isolation）来给用户提供一种隔离保证，从而降低应用侧的编程复杂度。</p><p>最强的隔离性——可串行化，可以理解为全局一把大排它锁，每个事务在启动时获取，在提交、回滚或终止时释放，但无疑这种隔离级别性能最差。而其他几种弱隔离级别，可以理解为是为了提高性能，缩小了加锁的粒度、减小了加锁的时间，从而牺牲部分一致性换取性能。从上锁的强弱考虑，我们有<strong>互斥锁</strong>（Mutex Lock，又称写锁）和<strong>共享锁</strong>（Shared Lock，又称读锁）；从上锁的长短来考虑，我们有<strong>长时锁</strong>（Long Period Lock，事务开始获取锁，到事务结束时释放）和<strong>短时锁</strong>（Short Period Lock，访问时获取，用完旋即释放）；从上锁的粗细来考虑，我们有对象锁（Row Lock，锁一行）和谓词锁（Predicate Lock，锁一个范围）。</p><p>但这没有覆盖到到另一个常见的隔离级别——<strong>快照隔离</strong>（Snapshot Isolation），因为它引出了另一种实现族——MVCC。由于属于不同的实现，快照隔离和可重复读在隔离级别的光谱上属于一个偏序关系，不能说谁强于谁。</p><h3 id="2-1-读已提交"><a href="#2-1-读已提交" class="headerlink" title="2.1 读已提交"></a>2.1 读已提交</h3><p>性能最好的隔离级别就是不上任何锁，但会存在<strong>脏读</strong>和<strong>脏写</strong>的问题。为了避免脏写，可以给要更改的对象加长时写锁，但读数据时并不加锁，此时的隔离级别称为<strong>读未提交</strong>（RU，Read Uncommitted）。但此时仍然会有脏读，为了避免脏读，可以对要读取的对象加<strong>短时读锁</strong>，此时的隔离级别是<strong>读已提交</strong>（RC，Read Committed），他提供了两个保证：</p><ol><li>从数据库读取时，只能读到已经提交的数据（即没有脏读，no dirty reads）</li><li>往数据库写入时，只能覆盖已经提交的数据（即没有脏写，no dirty writes）</li></ol><h3 id="2-2-快照隔离和重复读"><a href="#2-2-快照隔离和重复读" class="headerlink" title="2.2 快照隔离和重复读"></a>2.2 快照隔离和重复读</h3><p>Alice 分两个账户，各存了 500 块钱，但如果其两次分别查看两个账户期间，发生了一笔转账交易，则两次查看的余额加起来并不等于 1000。<br><strong>同一个操作期间，两次读取到的数据不一致。</strong> 也就是在事务a执行中，事务b修改了数据并提交了</p><p>这种异常被称为<strong>不可重复读</strong>（non-repeatable read）或者<strong>读倾斜</strong>（read skew）。读已提交的隔离级别允许出现不可重复读问题，如上述例子，每次读取到的都是已提交的内容。</p><p>在某些情况下，这种暂时的不一致也是不可接受的：</p><ol><li><strong>备份</strong>。备份可能需要花费很长时间，而备份过程中可能会有读写存在，从而造成备份时的不一致。如果之后再利用此备份进行恢复，则会造成永久的不一致。</li><li><strong>分析型查询和完整性检查</strong>。这个操作和备份一样，耗时都会比较长，如果中间有其他事务并发导致出现不一致的现象，就会导致返回的结果有问题。</li><li><strong>快照隔离</strong>（snapshot isolation）级别能够解决上述问题，使用此级别，每个事务都可以取得一个某个时间点的<strong>一致性快照</strong>（consistent snapshot），在整个事务期间，读到的状态都是该时间点的快照。其他事务的修改并不会影响到该快照上。</li></ol><h4 id="2-2-1-快照隔离的实现"><a href="#2-2-1-快照隔离的实现" class="headerlink" title="2.2.1 快照隔离的实现"></a>2.2.1 快照隔离的实现</h4><p>快照隔离也使用加锁的方式来防止脏写，但在进行读取不使用锁。快照隔离的一个关键原则是“读不阻塞写，写不阻塞读”，从而允许用户在进行长时间查询时，不影响新的写入。</p><p>为了实现快照隔离，保证读不阻塞写，且避免脏读，数据库需要对同一个对象保留多个已提交的版本，我们称之为<strong>多版本并发控制</strong>（<strong>MVCC，multi-version concurrency control</strong>）。</p><ol><li><strong>读已提交</strong>在查询语句粒度使用单独的快照，快照粒度更小，因此性能更好。</li><li><strong>快照隔离</strong>在事务粒度使用相同的快照（主要解决<strong>不可重复读</strong>问题）。</li></ol><p><strong>MVCC 的基本要点为：</strong></p><ol><li>每个事务开始时会获取一个自增的、唯一的事务 ID（txid），该 txid = max(existing tx id) + 1。</li><li>该事务在修改数据时，不会修改以前版本，而会新增一个具有 txid 版本的数据。</li><li>该事务只能访问到所有版本 ≤ txid 的数据。</li><li>在写入时，如果发现某个数据存在 &gt; txid 的版本，则存在写写冲突。</li></ol><h4 id="2-2-2-可见性规则"><a href="#2-2-2-可见性规则" class="headerlink" title="2.2.2 可见性规则"></a>2.2.2 可见性规则</h4><p>在事务中进行读取时，对于每个对象来说，需要<strong>控制</strong>其版本对事务的可见性，以保证该事务能够看到一致性的视图。</p><ol><li>事务开始时，所有正在进行（已经开始但未提交或中止）的事务，所做的任何写入都会被忽略。</li><li>被中止的事务，所做的任何写入都会被忽略。</li><li>具有较晚事务 ID 的事务所做的任何写入都会被忽略。</li><li>剩余其他的数据，对此事务都可见。</li></ol><h3 id="2-3-索引和快照隔离"><a href="#2-3-索引和快照隔离" class="headerlink" title="2.3 索引和快照隔离"></a>2.3 索引和快照隔离</h3><p>当数据有多个版本时，如何给数据建立索引？一个简单的方法是将索引指向对象的所有版本，然后在查询时使用再进行版本过滤。当某个对象的所有版本对任何事务都不再可见时，相应的索引条目也可以被同时删除。</p><h3 id="2-4-防止更新丢失"><a href="#2-4-防止更新丢失" class="headerlink" title="2.4 防止更新丢失"></a>2.4 防止更新丢失</h3><p>更新丢失发生的关键在于，两个事务中都有读后写序列（读取 - 修改 - 写入序列，写偏序也是这个序列，但是针对多个对象），即<strong>写依赖于之前的读</strong>。如果读到的内容被其他事务修改，则本事务稍后的依赖于此读的写就会发生问题。如：</p><ol><li>并发更新计数器和账户余额。</li><li>复合值的并发修改（如 json 文档中的列表字段，需要先读出，加一个字段后写回）。</li><li>两个用户同时修改 wiki 页面，并且都是修改后将页面完整覆写回。<h4 id="2-4-1-原子写"><a href="#2-4-1-原子写" class="headerlink" title="2.4.1 原子写"></a>2.4.1 原子写</h4>有些数据库提供原子的（<strong>针对单个对象的</strong>）read-modify-write 操作，因此，如果应用层逻辑能用这个原子操作表达，就可以避免更新丢失。<br>原子操作的通常实现方式为，在读取某对象时，获取其互斥锁，从而阻止其他事务读取该对象。</li></ol><h4 id="2-4-2-显式上锁"><a href="#2-4-2-显式上锁" class="headerlink" title="2.4.2 显式上锁"></a>2.4.2 显式上锁</h4><p>应用在有针对单个对象的 read-modify-write 序列时，将是否上锁的决策交给应用层</p><h4 id="2-4-3-自动检测更新丢失"><a href="#2-4-3-自动检测更新丢失" class="headerlink" title="2.4.3 自动检测更新丢失"></a>2.4.3 自动检测更新丢失</h4><p>使用<strong>乐观</strong>方式，允许其并发执行，检测到更新丢失后进行重试。</p><h4 id="2-4-4-Compare-and-set"><a href="#2-4-4-Compare-and-set" class="headerlink" title="2.4.4 Compare-and-set"></a>2.4.4 Compare-and-set</h4><p>使用 CAS 操作也能避免更新丢失，保证 read-modify-write 的原子性。<br>仅当发现内容没有被修改时，才写会修改后的内容。</p><h4 id="2-4-5-多副本和冲突解决"><a href="#2-4-5-多副本和冲突解决" class="headerlink" title="2.4.5 多副本和冲突解决"></a>2.4.5 多副本和冲突解决</h4><p>在多副本数据库中，解决更新丢失问题会更难一些，尤其如果多个副本允许并发写入。<br>可以允许并发写入和异步更新，如果有冲突就用多版本来解决，最后使用用户代码或者特殊数据结构来合并冲突。</p><h3 id="2-5-写偏序和幻读"><a href="#2-5-写偏序和幻读" class="headerlink" title="2.5 写偏序和幻读"></a>2.5 写偏序和幻读</h3><p>假定数据库运行在快照隔离级别下，Alice 和 Bob 同时查询了今天值班情况，发现有多于一人值班，然后先后提交了休假申请，并且都通过了。这并没有违反快照隔离级别，但确实造成了问题——今天没有人值班了。</p><h4 id="2-5-1-写偏序的特点"><a href="#2-5-1-写偏序的特点" class="headerlink" title="2.5.1 写偏序的特点"></a>2.5.1 写偏序的特点</h4><p>写偏序可以算作是更新丢失的一种泛化。写偏序本质也是 read-modify-write，虽然是涉及多个对象，但本质仍然是<strong>一个事务的写入会导致另外一个事务读取到的信息失效</strong>。<br>写偏序是由 MVCC 实现的快照隔离级别的特有的缺陷，它是由于读依赖同一个不变的快照引起的。</p><p>如果没有办法使用可串行的化的隔离级别，还可以利用数据库提供的（for update）机制进行显式的加锁。</p><h4 id="2-5-2-幻读导致写偏序"><a href="#2-5-2-幻读导致写偏序" class="headerlink" title="2.5.2 幻读导致写偏序"></a>2.5.2 幻读导致写偏序</h4><p>都可以归纳为以下模式：</p><ol><li>通过 select 语句 + 条件过滤出符合条件的所有行。</li><li>依赖上述结果，应用侧代码决定是否继续。</li><li>如果应用侧决定继续，就执行更改（插入、更新或者删除），并提交事务。<br>步骤 3 会导致另一个事务的步骤 1 失效，即如果另一个事务此时重新执行 1 的 select 查询，会得到不同的结果，进而影响步骤 2 是否继续的决策。</li></ol><h4 id="2-5-3-物化冲突"><a href="#2-5-3-物化冲突" class="headerlink" title="2.5.3 物化冲突"></a>2.5.3 物化冲突</h4><p>将幻读转化为数据库物理中实实在在的表和行。但如何对冲突进行合理的物化，很难且易出错。并且，此方法会将解决冲突的细节暴露给了应用层（因为应用层需要感知物化出来的表）。因此，这是最不得以的一种方法，如果数据库本就支持可串行化，则大多数情况下，可以直接使用可串行隔离级别。</p><h2 id="3-可串行化"><a href="#3-可串行化" class="headerlink" title="3 可串行化"></a>3 可串行化</h2><p>可串行化当前主要实现方法：</p><ol><li>物理上真正的对所有事务进行串行的执行。</li><li><strong>两阶段锁</strong>（2PL，two-phase locking），曾经几十年中唯一的可用选项。</li><li><strong>乐观并发控制</strong>（OCC，Optimistic concurrency control），如可串行化的快照隔离。</li></ol><h3 id="3-1-物理上串行"><a href="#3-1-物理上串行" class="headerlink" title="3.1 物理上串行"></a>3.1 物理上串行</h3><p>将所有事务串行的执行</p><h3 id="3-2-将事务封装成存储过程"><a href="#3-2-将事务封装成存储过程" class="headerlink" title="3.2 将事务封装成存储过程"></a>3.2 将事务封装成存储过程</h3><p>线程串行事务系统不允许交互式的多语句事务。用户需要将多语句封装为存储过程一次性提交给数据库。如果数据都在内存中，则存储过程可以被快速的执行。</p><h4 id="3-2-1-存储过程的优缺点"><a href="#3-2-1-存储过程的优缺点" class="headerlink" title="3.2.1 存储过程的优缺点"></a>3.2.1 存储过程的优缺点</h4><p>对于内存数据库的单线程事务，使用存储过程可以获得不错的吞吐：</p><ol><li>内存数据库和存储过程避免了 IO</li><li>单线程避免了锁开销</li></ol><h4 id="3-2-2-对数据进行分区"><a href="#3-2-2-对数据进行分区" class="headerlink" title="3.2.2 对数据进行分区"></a>3.2.2 对数据进行分区</h4><h3 id="3-3-两阶段锁"><a href="#3-3-两阶段锁" class="headerlink" title="3.3 两阶段锁"></a>3.3 两阶段锁</h3><p>两阶段锁，其实就是将使用锁的过程分为两个阶段，通常称为<strong>扩张阶段</strong>和<strong>收缩阶段</strong>。在扩张阶段（事务的整个执行过程），只会申请锁，在收缩阶段（事务提交时），只会释放锁。从另一个角度理解，每个事务都是访问数据库的一个数据对象子集，扩张阶段就是逐渐拿到该子集所有相关对象的所有权，收缩阶段就是将持有对象所有权释放。而 <strong>S2PL</strong>（Strict 2PL），是在 2PL 的基础上，将写锁保持到事务结束； <strong>SS2PL</strong>（Strong 2PL 或 Strong Strict 2PL）是将读写锁都保持到事务结束。</p><ol><li>如果所有事务都没有写入，允许多事务并发读取一个对象。</li><li>只要任何一个事务有写入，就会将其<strong>独占</strong>到事务<strong>结束</strong>，不允许其他任何事务<strong>读或写</strong>。</li></ol><p>2PL 不允许读写并发、写写并发，而快照隔离却正好相反，即读写互相不阻塞。另一方面，2PL 通过阻止读写并发，可以避免<strong>更新丢失</strong>和<strong>写偏序</strong>等并发问题。</p><h4 id="3-3-1-实现"><a href="#3-3-1-实现" class="headerlink" title="3.3.1 实现"></a>3.3.1 实现</h4><p>通过对每个对象进行加锁，可以实现单个对象的读写互斥。锁可以处于<strong>共享模式</strong>（shared mode）或者<strong>互斥模式</strong>（exclusive mode），具体来说：</p><ol><li>如果某个事务想<strong>读取</strong>一个对象，需要首先获取该对象的<strong>共享锁</strong>。多个事务可以同时获取同一个对象的共享锁。但若某个事务持有该对象的互斥锁，则所有需要读写该对象的事务都得等待。</li><li>如果某个事务想<strong>写入</strong>一个对象，需要首先获取该对象的<strong>互斥锁</strong>。任何其他事务都不能同时持有该对象的任何种类的锁。因此，如果该对象上已经有锁，该事务必须先等待其释放。</li><li>如果某个事务要先<strong>读取</strong>，再<strong>写入</strong>某个对象，可以先获取其共享锁，然后将其升级为互斥锁。升级互斥锁和获取互斥锁的条件相同。</li><li>当某个事务获取锁之后，必须<strong>持有</strong>到事务结束（中止或者提交）。这也是上面两阶段定义的由来。</li></ol><p>由于每个对象都要上锁，而一个事务通常会访问多个对象，因此很可能造成<strong>死锁</strong>：多个事务持有锁，并且互相等待对方的锁。</p><h4 id="3-3-2-两阶段锁的性能"><a href="#3-3-2-两阶段锁的性能" class="headerlink" title="3.3.2 两阶段锁的性能"></a>3.3.2 两阶段锁的性能</h4><p>两阶段锁的实现下，事务的吞吐要比其他弱隔离级别低的多。维护大量锁的开销是一个原因，更重要的原因是<strong>并发性</strong>的降低。<br><strong>死锁更加频繁</strong>。尽管基于锁实现的<strong>读已提交</strong>隔离级别会发生死锁，但其发生频次远不如基于 2PL 实现的<strong>可串行化</strong>隔离级别。这也会造成额外的性能问题：死锁被检测到，会引发重试；如果死锁频繁，则会浪费巨大的性能。</p><h4 id="3-3-3-谓词锁"><a href="#3-3-3-谓词锁" class="headerlink" title="3.3.3 谓词锁"></a>3.3.3 谓词锁</h4><p>和共享锁类似，只不过粒度更大一些。</p><ol><li>当某个事务需要读取匹配条件的所有对象时，需要获得该查询条件的<strong>共享谓词锁</strong>。如果有任何其他事务持有该范围内对象的互斥锁，则该事务需要等待其结束。</li><li>当某个事务想要写入（插入、更新或者删除）某个对象时，上互斥锁前，需要检查是否有其他事务持有包含该对象的谓词锁。如果有，则该事务需要等待其结束。</li></ol><p>谓词锁的一个关键点是，可以锁住一个对象集合，该对象集中的对象甚至不必已存在，但将来可能会被添加。通过谓词锁，2PL 可以解决幻读问题。</p><h4 id="3-3-4-索引范围锁"><a href="#3-3-4-索引范围锁" class="headerlink" title="3.3.4 索引范围锁"></a>3.3.4 索引范围锁</h4><p>大多数 2PL 的数据库使用了谓词锁的一个近似——<strong>索引范围锁</strong>（index-range locking，也称为 next-key locking）。<br>通过适当<strong>放大锁住的对象集</strong>来简化谓词锁。如当有多个条件进行<strong>与</strong>的时候，只锁一个条件。<br>只锁定单个条件的好处在于，你可能在该条件上有索引。则可以将谓词锁，转化为一个在该索引上的范围锁、甚至单个索引对象锁。相比谓词锁，可以更快的判断冲突<br>这种方式也可以避免幻读和写偏序。相比谓词锁，索引范围锁虽然锁住的范围大，但实现开销较低。但谓词相关的索引并不总是能找到，此时可以简单的退化成整张表上的共享锁。这样做虽然有损性能，但是实现简单且安全。</p><h3 id="3-4-可串行的快照隔离"><a href="#3-4-可串行的快照隔离" class="headerlink" title="3.4 可串行的快照隔离"></a>3.4 可串行的快照隔离</h3><p>数据库中隔离级别的图景：</p><ol><li>在光谱一侧，我们有很好的隔离级别——可串行化，但其实现要么性能差（两阶段锁），要么不可扩展（物理上串行执行）。</li><li>在光谱另一个侧，我们有一些相对较弱的隔离级别，它们性能较好，但会有各种竞态条件（更新丢失、写偏序、幻读等等）。</li></ol><h4 id="3-4-1-乐悲观并发控制"><a href="#3-4-1-乐悲观并发控制" class="headerlink" title="3.4.1 乐悲观并发控制"></a>3.4.1 乐悲观并发控制</h4><p>SSI 是一种<strong>乐观</strong>（<em>optimistic</em>）的并发控制机制，类比多线程编程中的乐观锁。其相应哲学是，当存在潜在危险时，仍然不做任何检查去大胆的执行。当事务提交时，再进行冲突检测，如果存在冲突，则回退重试。</p><h4 id="3-4-2-基于失效前提的决策"><a href="#3-4-2-基于失效前提的决策" class="headerlink" title="3.4.2 基于失效前提的决策"></a>3.4.2 基于失效前提的决策</h4><p><strong>读取 - 决策 - 写入</strong>。</p><ol><li>读取：事务首先从数据库中读取到一些数据。</li><li>决策：考察读到的数据，做出某种决策。</li><li>写入：将对应决策造成结果写回数据库。</li></ol><p>如何检测前提是否失效</p><ol><li>在读取时，要检测读到的数据版本是否为最新版本。（读之前，可能有未提交的写入）</li><li>在写入时，要检测写入的数据是否覆盖了其他事务的读取。（读之后，可能发生了写入）</li></ol><h4 id="3-4-3-MVCC-读取的过时检测"><a href="#3-4-3-MVCC-读取的过时检测" class="headerlink" title="3.4.3 MVCC 读取的过时检测"></a>3.4.3 MVCC 读取的过时检测</h4><p>快照隔离通常通过<strong>多版本并发控制</strong>（MVCC）来实现。当事务基于 MVCC 数据库中的某个一致性的快照进行读取时，会忽略其他事务潜在的任何修写入。</p><p><strong>读取时，检测写读冲突，延到提交时，看有冲突的写入是否已提交</strong>。</p><h4 id="3-4-4-影响之前读取的写入检测"><a href="#3-4-4-影响之前读取的写入检测" class="headerlink" title="3.4.4 影响之前读取的写入检测"></a>3.4.4 影响之前读取的写入检测</h4><p>在一个事务写入某对象时，需要检测是否该数据被另一个事务读取过<br><strong>在写入时，利用之前在对应索引范围记下的读取事务编号记录冲突，在提交时，看有冲突的读取是否已经提交</strong>。</p><h4 id="3-4-5-可串行快照隔离的性能"><a href="#3-4-5-可串行快照隔离的性能" class="headerlink" title="3.4.5 可串行快照隔离的性能"></a>3.4.5 可串行快照隔离的性能</h4><p>和 2PL 相比，SSI 的最大优点是，不会通过锁来阻塞有依赖关系的事务并发执行。SSI 就想运行在快照隔离级别一样，读不阻塞写，写不阻塞读。只是追踪记录，在提交时决定是否提交或重试。这种设计是的查询延迟更可预测。尤其是，只读事务可以工作在一致性快照上，而不受影响，这对读负载很重的场景很有吸引力。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> DDIA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDIA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[DDIA] 分区</title>
      <link href="/2023/06/18/DDIA/05%20%E5%88%86%E5%8C%BA/"/>
      <url>/2023/06/18/DDIA/05%20%E5%88%86%E5%8C%BA/</url>
      
        <content type="html"><![CDATA[<blockquote><p>解决数据集尺度与单机容量、负载不匹配的问题</p></blockquote><span id="more"></span><ol><li><strong>分片（Partition）</strong>：解决数据集尺度与单机容量、负载不匹配的问题，分片之后可以利用多机容量和负载。</li><li><strong>复制（Replication</strong>）：系统机器一多，单机故障概率便增大，为了防止数据丢失以及服务高可用，需要做多副本。<br>通常来说，数据系统在分布式系统中会有三级划分：数据集（如 Database、Bucket）——分片（Partition）——数据条目（Row、KV）。通常，每个分片只属于一个数据集，每个数据条目只属于一个分片。单个分片，就像一个小点的数据库。但是，跨分区的操作的，就要复杂的多。</li></ol><h2 id="1-分片和复制"><a href="#1-分片和复制" class="headerlink" title="1 分片和复制"></a>1 分片和复制</h2><p>分片通常和复制结合使用。每个分片有多个副本，可以分散到多机上去（更泛化一点：多个容错阈）；同时，每个机器含有多个分片，但通常不会有一个分片的两个副本放到一个机器上。<br><strong>如果使用多副本使用主从模型，则分片、副本、机器关系如下：</strong></p><ol><li>从一个分片的角度看，主副本在一个机器上，从副本们在另外机器上。</li><li>从一个机器的角度看，既有一些主副本分片，也有一些从副本分片。实践中，也会尽量保证主副本在集群中均匀分布，避免过多的集中到一台机器上。</li></ol><h2 id="2-键值对集的分片"><a href="#2-键值对集的分片" class="headerlink" title="2 键值对集的分片"></a>2 键值对集的分片</h2><p>键值对是数据的一种最通用、泛化的表示，其他种类数据库都可以转化为键值对表示<br><strong>分片（Partition）</strong> 的本质是对数据集合的划分。但在实践中，可以细分为两个步骤：</p><ol><li>对数据集进行<strong>逻辑</strong>划分</li><li>将逻辑分片调度到<strong>物理</strong>节点<br><strong>一些基本要求：</strong></li><li>分片过程中，要保证每个分片的数据量多少尽量均匀，否则会有<strong>数据偏斜</strong>（<strong>skew</strong>），甚而形成<strong>数据热点</strong>。</li><li>分片后，需要保存路由信息，给一个 KV 条目，能知道去<strong>哪个</strong>机器上去查；稍差一些，可以知道去<strong>哪几个</strong>机器上去找；最差的，如果需要去所有机器逐一查询，但性能一般不可接受。</li></ol><p>有三种常用的策略：</p><ol><li>通过某种固定规则，比如哈希，算出一个位置。</li><li>使用内存，保存所有数据条目到机器的映射。</li><li>结合两种，首先通过规则算出到逻辑分片的映射，然后通过内存保存逻辑分片到物理节点的映射。</li></ol><h3 id="2-1-按键范围分区"><a href="#2-1-按键范围分区" class="headerlink" title="2.1 按键范围分区"></a>2.1 按键范围分区</h3><p>对于 KV 数据来说，Key 通常会有个定义域，且在定义域内可（按某种维度）排序。则，将该连续的定义域进行切分，保存每个切分的上下界，在给出某个 Key 时，就能通过比较，定位其所在分区。<br>好处在于可以进行<strong>快速的范围查询（Rang Query）</strong><br>坏处在于，数据分散不均匀，且容易造成热点。可能需要动态的调整的分区边界，以维护分片的相对均匀。<br>一个解决办法是<strong>分级</strong>或者<strong>混合</strong>，使用拼接主键，分散到不同的机器上</p><h3 id="2-2-按键散列分区"><a href="#2-2-按键散列分区" class="headerlink" title="2.2 按键散列分区"></a>2.2 按键散列分区</h3><ul><li>选择散列函数的<strong>依据</strong>是，使得数据散列尽量均匀：即给定一个 Key，经过散列函数后，以等概率在哈希区间（如 <code>[0, 2^32-1)</code>）内产生一个值。即使原 Key 相似，他的散列值也能均匀分布。</li><li>选定哈希函数后，将原 Key 定义域映射到新的散列值阈，而散列值是均匀的，因此可以对散列值阈按给定分区数进行等分。</li><li>还有一种常提的哈希方法叫做<a href="https://zh.m.wikipedia.org/zh-hans/%E4%B8%80%E8%87%B4%E5%93%88%E5%B8%8C">一致性哈希</a> 。其特点是，会考虑逻辑分片和物理拓扑，将数据和物理节点按同样的哈希函数进行哈希，来决定如何将哈希分片路由到不同机器上。它可以避免在内存中维护<strong>逻辑分片到物理节点的映射</strong>，而是每次计算出来。即用一套算法同时解决了我们在最初提出的逻辑分片和物理路由的两个问题。<br>两种分区方式区别在于，一个使用应用相关值（ <code>Key</code> ）分区，一个使用应用无关值（<code>Hash(key)</code>）分区，前者支持高效范围查询，后者可以均摊负载。但可使用多个字段，组合使用两种方式，使用一个字段进行分区，使用另一个字段在分区内进行排序，兼取两者优点。</li></ul><h3 id="2-3-负载偏斜和热点消除"><a href="#2-3-负载偏斜和热点消除" class="headerlink" title="2.3 负载偏斜和热点消除"></a>2.3 负载偏斜和热点消除</h3><ul><li>在数据层，可以通过哈希将数据均匀散列，以期将对数据的请求均摊；但如果在应用层，不同数据条目的负载本就有倾斜，存在对某些键的热点。那么仅在数据层哈希，就不能起到消除热点的作用。<ul><li>在社交网络中的大 V，其发布的信息，天然会引起同一个键（假设键是用户 id）大量数据的写入，因为可能会有针对该用户信息的大量评论和互动。</li></ul></li><li>只能在应用层进行热点消除，如可以用拼接主键，对这些大 V 用户主键进行“分身”，即在用户主键开始或者结尾添加一个随机数，两个十进制后缀就可以增加 100 中拆分可能。但这无疑需要应用层做额外的工作，请求时需要进行拆分，返回时需要进行合并。</li></ul><h2 id="3-分片和次级索引"><a href="#3-分片和次级索引" class="headerlink" title="3 分片和次级索引"></a>3 分片和次级索引</h2><p><strong>次级索引（secondary index）</strong>，即主键以外的列的索引；由于分区都是基于主键的，在针对有分区的数据建立次级索引时，就会遇到一些困难。<br>常见的建立次级索引的方法有：</p><ol><li>本地索引（local index），书中又称 document-based index</li><li>全局索引（global index），书中又称 term-based index<h3 id="3-1-本地索引"><a href="#3-1-本地索引" class="headerlink" title="3.1 本地索引"></a>3.1 本地索引</h3>次级索引会对每个数据条目建立一个索引条目，这给数据库的实现带来了一些问题：</li><li>当数据库已有数据时，建立索引，何时针对存量数据构建索引。</li><li>当数据库中数据条目发生更改时，如何维护数据和索引的一致性，尤其是多客户端并发修改时。</li></ol><p>本地<strong>索引（local index）</strong>，就是对<strong>每个数据分区独立地建立次级索引</strong>，即，次级索引只针对本分区数据，而不关心其他分区数据。本地索引的<strong>优点</strong>是维护方便，在更新数据时，只需要在该分区所在机器同时更新索引即可。但<strong>缺点</strong>是，查询效率相对较低，所有基于索引的查询请求，都要发送到所有分区，并将结果合并，该过程也称为 <strong>scatter/gather</strong> 。但即使用多分区并发（而非顺序）进行索引查询优化，也仍然容易在某些机器上发生<strong>长尾请求</strong>（由于机器负载过高或者网络问题，导致改请求返回特别慢，称为长尾请求），导致整个请求过程变慢。</p><h3 id="3-2-全局索引"><a href="#3-2-全局索引" class="headerlink" title="3.2 全局索引"></a>3.2 全局索引</h3><p>为了避免查询索引时将请求发到所有分区，可以建立<strong>全局索引</strong>，即每个次级索引条目都是针对全局数据。但为了避免索引查询热点，我们会将索引数据本身也分片，分散到多个机器上。</p><p>全局索引能避免索引查询时的 scatter/gather 操作，但维护起来较为复杂，因为每个数据的插入，可能会影响多个索引分区</p><p>为了避免增加写入延迟，在实践中，全局索引多为异步更新。但由此会带来短暂（有时可能会比较长）的数据和索引不一致。如果想要保证强一致性，需要引入跨分区的分布式事务（实现复杂度高，且会带来较大的性能损耗）</p><h2 id="4-分片均衡"><a href="#4-分片均衡" class="headerlink" title="4 分片均衡"></a>4 分片均衡</h2><p>数据库在运行过程中，数据和机器都会发生一些变化：</p><ol><li>查询吞吐增加，需要增加机器以应对增加的负载。</li><li>数据集变大，需要增加磁盘和 RAM 来存储增加数据。</li><li>有机器故障，需要其他机器来接管故障机器数据。</li></ol><p>这些问题都会引起数据分片在节点间的迁移，我们将之称为：<strong>均衡（rebalancing）</strong>。对于 rebalancing 我们期望：</p><ol><li>均衡后负载（存储、读写）在节点间均匀分布</li><li>均衡时不能禁止读写，并且尽量减小影响</li><li>尽量减少不必要的数据移动，尽量降低网络和磁盘 IO</li></ol><h3 id="4-1-均衡策略"><a href="#4-1-均衡策略" class="headerlink" title="4.1 均衡策略"></a>4.1 均衡策略</h3><p>分区策略会影响均衡策略。比如动态分区、静态分区，对应的均衡策略就不太一样；此外，分区的粒度和数量也会影响均衡策略。</p><h3 id="4-2-不要使用：hash-mod-N"><a href="#4-2-不要使用：hash-mod-N" class="headerlink" title="4.2 不要使用：hash mod N"></a>4.2 不要使用：hash mod N</h3><p>不能应对机器数量的变化，如果要增删节点，就会有大量的数据需要发生迁移，否则，就不能保证数据在 <code>hash(key) mod N</code> 标号的机器上。在大规模集群中，机器节点增删比较频繁，这种策略更是不可接受。</p><h3 id="4-3-静态分区"><a href="#4-3-静态分区" class="headerlink" title="4.3 静态分区"></a>4.3 静态分区</h3><p>静态分区，即，逻辑分区阶段的<strong>分区数量是固定的</strong>，并且最好让分区数量大于（比如高一个数量级）机器节点。相比<strong>动态分区</strong>策略（比如，允许分区分裂和合并），固定数量分区更容易实现和维护。<br>对于数据量会超预期增长的数据集，静态分区策略就会让用户进退两难，已经有很多数据，重新分区代价很大，不重新分区又难以应对数据量的进一步增长。</p><h3 id="4-4-动态分区"><a href="#4-4-动态分区" class="headerlink" title="4.4 动态分区"></a>4.4 动态分区</h3><p>动态分区好处在于，小数据量使用少量分区，减少开销；大数据量增加分区，以均摊负载。</p><h3 id="4-5-与节点成比例分区"><a href="#4-5-与节点成比例分区" class="headerlink" title="4.5 与节点成比例分区"></a>4.5 与节点成比例分区</h3><ol><li>静态均衡的分区数量一开始就固定的，但是单分区尺寸会随着总数量增大而增大。</li><li>动态均衡会按着数据量多少进行动态切合，单分区尺寸相对保持不变，一直于某个设定的上下界。<br>他们的分区数量都和集群节点数量没有直接关系。而另一种均衡策略，则是保持<strong>总分区数量</strong>和节点数量成正比，也即，保持每个节点分区数量不变。</li></ol><h2 id="5-请求路由"><a href="#5-请求路由" class="headerlink" title="5 请求路由"></a>5 请求路由</h2><p>将分区放到节点上去后，当客户端请求到来时，我们如何决定将请求路由到哪台机器？这势必要求我们<strong>以某种方式</strong>记下：</p><ol><li>数据条目到逻辑分区的映射。</li><li>逻辑分区到物理机器的映射。</li></ol><p>其次，是在哪里记下这些路由（映射）信息，泛化一下，是一个<strong>服务发现</strong>（service discovery）问题。概括来说，由内而外，有几种方案：</p><ol><li><strong>每个节点都有全局路由表</strong>。客户端可以连接集群中任意一个节点，如该节点恰有该分区，则处理后返回；否则，根据路由信息，将其路由合适节点。</li><li><strong>由一个专门的路由层来记录</strong>。客户端所有请求都打到路由层，路由层依据分区路由信息，将请求转发给相关节点。路由层只负责请求路由，并不处理具体逻辑。</li><li><strong>让客户端感知分区到节点映射</strong>。客户端可以直接根据该映射，向某个节点发送请求。</li></ol><p>如何让所有节点就路由信息快速达成一致？</p><ul><li><strong>依赖外部协调组件</strong>。如 Zookeeper、Etcd，他们各自使用某种共识协议保持高可用，可以维护轻量的路由表，并提供发布订阅接口，在有路由信息更新时，让外部所有节点快速达成一致。</li><li><strong>使用内部元数据服务器</strong>。如三节点的 Meta 服务器，每个节点都存储一份路由数据，使用某种共识协议达成一致。如 TiDB 的 Placement Driver。</li><li><strong>使用某种协议点对点同步</strong>。如 Dynamo、Cassandra 和 Riak 使用流言协议（Gossip Protocol），在集群内所有机器节点间就路由信息进行传播，并最终达成一致</li></ul><h3 id="5-1-并行查询执行"><a href="#5-1-并行查询执行" class="headerlink" title="5.1 并行查询执行"></a>5.1 并行查询执行</h3><p>对于关系型数据库产品，尤其是支持 <strong>大规模并行处理（MPP, Massively parallel processing）</strong> 数仓，一个查询语句在执行层要复杂的多，可能会：</p><ol><li>Stage：由多个阶段组成。</li><li>Partition：每个阶段包含多个针对每个分区的并行的子查询计划。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> DDIA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDIA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[DDIA] 冗余</title>
      <link href="/2023/06/14/DDIA/04%20%E5%86%97%E4%BD%99/"/>
      <url>/2023/06/14/DDIA/04%20%E5%86%97%E4%BD%99/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>冗余（Replication）</strong> 是指将同一份数据复制多份，放到通过网络互联的多个机器上去。</p></blockquote><span id="more"></span><p>其好处有：</p><ol><li><strong>降低延迟</strong>：可以在地理上同时接近不同地区的用户。</li><li><strong>提高可用性</strong>：当系统部分故障时仍然能够正常提供服务。</li><li><strong>提高读吞吐</strong>：平滑扩展可用于查询的机器。</li></ol><ul><li>如果只读，直接复制即可。可以利用这个特性，使用分治策略，将数据分为只读部分和读写部分，则只读部分的冗余就会容易处理的多</li><li>允许数据变更时，如何维护多机冗余且一致。常用的冗余控制算法有：<ul><li>单领导者（single leader）</li><li>多领导者（multi-leader）</li><li>无领导者（leaderless）</li></ul></li><li>需要在多方面做取舍<ul><li>使用同步复制还是异步复制</li><li>如何处理失败的副本</li></ul></li></ul><h2 id="1-领导与跟随者"><a href="#1-领导与跟随者" class="headerlink" title="1 领导与跟随者"></a>1 领导与跟随者</h2><p><strong>副本</strong>：冗余的每份数据。  如何保证所有的数据都同步到了所有的副本上？<br>基于<strong>领导者（leader-based）</strong> 的同步算法：也就是主从同步</p><ol><li>其中一个副本称为<strong>领导者</strong>（leader），别称<strong>主副本</strong>（primary、master）。主副本作为写入的协调者，所有写入都要发给主副本。</li><li>其他副本称为<strong>跟随者</strong>（follower），也称为<strong>只读副本</strong>（read replicas）、<strong>从副本</strong>（slaves）、<strong>次副本</strong>（secondaries）、<strong>热备</strong>（hot-standby）。主副本将改动写到本地后，将其发送给各个从副本，从副本收变动到后应用到自己状态机，这个过程称为<strong>日志同步</strong>（replication log）、<strong>变更流</strong>（change steam）。</li><li>对于读取，客户端可以从主副本和从副本中读取；但写入，客户端只能将请求发到主副本。<h3 id="1-1-同步和异步复制"><a href="#1-1-同步和异步复制" class="headerlink" title="1.1 同步和异步复制"></a>1.1 同步和异步复制</h3><strong>同步（synchronously）复制</strong>和<strong>异步（asynchronously）复制</strong>和关键区别在于：请求何时返回给客户端。</li><li>如果等待某副本写完成后，则该副本为同步复制。</li><li>如果不等待某副本写完成，则该副本为异步复制。</li></ol><p>对比：</p><ol><li>同步复制牺牲了<strong>响应延迟</strong>和<strong>部分可用性</strong>（在某些副本有问题时不能完成写入操作），换取了所有副本的一致性（但并不能严格保证）。</li><li>异步复制放松了<strong>一致性</strong>，而换来了较低的写入延迟和较高的可用性。</li></ol><p>取舍：</p><ol><li><strong>全同步</strong>：所有的从副本都同步写入。如果副本数过多，可能性能较差，当然也可以做并行化、流水线化处理。</li><li><strong>半同步</strong>：（<strong>semi-synchronous</strong>），有一些副本为同步，另一些副本为异步。</li><li><strong>全异步</strong>：所有的从副本都异步写入。网络环境比较好的话，可以这么配置。</li></ol><h3 id="1-2-新增副本"><a href="#1-2-新增副本" class="headerlink" title="1.2 新增副本"></a>1.2 新增副本</h3><p>如果原副本是只读（read-only）的，只需要简单拷贝即可。但是如果是可写副本，则问题要复杂很多。因此，比较简单的一种解决方法是：禁止写入，然后拷贝。这在某些情况下很有用，比如夜间没有写入流量，同时一晚上肯定能复制完。<br>如果要不停机，可以：</p><ol><li>主副本在本地做<strong>一致性</strong>快照。何谓一致性？</li><li>将快照复制到从副本节点。</li><li>从主副本拉取快照之后的操作日志，应用到从副本。如何知道快照与其后日志的对应关系？序列号。</li><li>当从副本赶上主副本进度后，就可以正常跟随主副本了。</li></ol><h3 id="1-3-宕机处理"><a href="#1-3-宕机处理" class="headerlink" title="1.3 宕机处理"></a>1.3 宕机处理</h3><p>系统中任何节点都可能在计划内或者计划外宕机。那么如何应对这些宕机情况，保持整个系统的可用性呢？</p><h4 id="1-3-1-主副本宕机：故障转移"><a href="#1-3-1-主副本宕机：故障转移" class="headerlink" title="1.3.1 主副本宕机：故障转移"></a>1.3.1 主副本宕机：故障转移</h4><p>首先要选出新的主副本，然后要通知所有客户端主副本变更：</p><ol><li><strong>确认主副本故障</strong>。要防止由于网络抖动造成的误判。一般会用心跳探活，并设置合理超时（timeout）阈值，超过阈值后没有收到该节点心跳，则认为该节点故障。</li><li><strong>选择新的主副本</strong>。新的主副本可以通过<strong>选举</strong>（共识问题）或者<strong>指定</strong>（外部控制程序）来产生。选主时，要保证备选节点数据尽可能的新，以最小化数据损失。</li><li><strong>让系统感知新主副本</strong>。系统其他参与方，包括从副本、客户端和旧主副本。前两者不多说，旧主副本在恢复时，需要通过某种手段，让其知道已经失去领导权，避免<strong>脑裂</strong>。</li></ol><p><strong>主副切换问题</strong>：</p><ol><li><strong>新老主副本数据冲突</strong>。新主副本在上位前没有同步完所有日志，旧主副本恢复后，可能会发现和新主副本数据冲突。</li><li><strong>相关外部系统冲突</strong>。即新主副本，和使用该副本数据的外部系统冲突。书中举了 github 数据库 MySQL 和缓存系统 redis 冲突的例子。</li><li><strong>新老主副本角色冲突</strong>。即新老主副本都以为自己才是主副本，称为<strong>脑裂（split brain）</strong>。如果他们两个都能接受写入，且没有冲突解决机制，数据会丢失或者损坏。有的系统会在检测到脑裂后，关闭其中一个副本，但设计的不好可能将两个主副本都关闭。</li><li><strong>超时阈值选取</strong>。如果超时阈值选取的过小，在不稳定的网络环境中（或者主副本负载过高）可能会造成主副本频繁的切换；如果选取过大，则不能及时进行故障切换，且恢复时间也增长，从而造成服务长时间不可用。</li></ol><p>节点故障；不可靠网络；在一致性、持久化、可用性和延迟间的取舍；等等问题，都是设计分布式系统时，所面临的的基本问题。根据实际情况，对这些问题进行艺术化的取舍，便是分布式系统之美。</p><h4 id="1-3-2-从副本宕机：追赶恢复。"><a href="#1-3-2-从副本宕机：追赶恢复。" class="headerlink" title="1.3.2 从副本宕机：追赶恢复。"></a>1.3.2 从副本宕机：追赶恢复。</h4><p>类似于新增从副本。如果落后的多，可以直接向主副本拉取快照 + 日志；如果落后的少，可以仅拉取缺失日志。</p><h3 id="1-4-日志复制"><a href="#1-4-日志复制" class="headerlink" title="1.4 日志复制"></a>1.4 日志复制</h3><p>在数据库中，基于领导者的多副本是如何实现的？在不同层次有多种方法，包括：</p><ol><li><strong>语句层面的复制。</strong></li><li><strong>预写日志的复制</strong>。</li><li><strong>逻辑日志的复制</strong>。</li><li><strong>触发器的复制</strong>。</li></ol><p>对于一个<strong>系统</strong>来说，多副本同步的是什么？<strong>增量修改</strong>。<br>具体到一个由数据库构成的<strong>数据系统</strong>，通常由数据库外部的<strong>应用层</strong>、数据库内部<strong>查询层</strong>和<strong>存储层</strong>组成。<strong>修改</strong>在查询层表现为：语句；在存储层表现为：存储引擎相关的预写日志、存储引擎无关的逻辑日志；修改完成后，在应用层表现为：触发器逻辑。</p><h4 id="1-4-1-基于语句"><a href="#1-4-1-基于语句" class="headerlink" title="1.4.1 基于语句"></a>1.4.1 基于语句</h4><p>主副本记录下所有更新语句：<code>INSERT</code>、<code>UPDATE</code>  或  <code>DELETE</code> 然后发给从库。主副本在这里类似于充当其他从副本的<strong>伪客户端</strong>。</p><h4 id="1-4-2-传输预写日志（WAL）"><a href="#1-4-2-传输预写日志（WAL）" class="headerlink" title="1.4.2 传输预写日志（WAL）"></a>1.4.2 传输预写日志（WAL）</h4><p>主流的存储引擎都有<strong>预写日志</strong>（WAL，为了宕机恢复）：</p><ol><li>对于日志流派（LSM-Tree，如 LevelDB），每次修改先写入 log 文件，防止写入 MemTable 中的数据丢失。</li><li>对于原地更新流派（B+ Tree），每次修改先写入 WAL，以进行崩溃恢复。<br>所有用户层面的改动，最终都要作为状态落到存储引擎里，而存储引擎通常会维护一个：</li><li>追加写入</li><li>可重放<br>这种结构，天然适合备份同步。本质是因为磁盘的读写特点和网络类似：<strong>磁盘是顺序写比较高效，网络是只支持流式写</strong>。具体来说，主副本在写入 WAL 时，会同时通过网络发送对应的日志给所有从副本。</li></ol><h4 id="1-4-3-逻辑日志"><a href="#1-4-3-逻辑日志" class="headerlink" title="1.4.3 逻辑日志"></a>1.4.3 逻辑日志</h4><p>和具体的存储引擎物理格式解耦，在做数据同步时，可以使用不同的日志格式：<strong>逻辑日志</strong>。<br>对于关系型数据库来说，行是一个合适的粒度：</p><ol><li><strong>对于插入行</strong>：日志需包含所有列值。</li><li><strong>对于删除行</strong>：日志需要包含待删除行标识，可以是主键，也可以是其他任何可以唯一标识行的信息。</li><li><strong>对于更新行</strong>：日志需要包含待更新行的标志，以及所有列值（至少是要更新的列值）<br>对于多行修改来说，比如事务，可以在修改之后增加一条事务提交的记录。MySQL 的 binlog 就是这么干的。<br>使用逻辑日志的<strong>好处</strong>有：</li><li>方便新旧版本的代码兼容，更好的进行滚动升级。</li><li>允许不同副本使用不同的存储引擎。</li><li>允许导出变动做各种<strong>变换</strong>。如导出到数据仓库进行离线分析、建立索引、增加缓存等等。</li></ol><h2 id="2-复制滞后问题"><a href="#2-复制滞后问题" class="headerlink" title="2 复制滞后问题"></a>2 复制滞后问题</h2><p>使用多副本的好处有：</p><ol><li><strong>可用性</strong>：容忍部分节点故障</li><li><strong>可伸缩性</strong>：增加读副本处理更多读请求</li><li><strong>低延迟</strong>：让用户选择一个就近的副本访问<br>对于读多写少的场景，想象中，可以通过使劲增加读副本来均摊流量。但有个<strong>隐含</strong>的条件是，多副本间的同步得做成<strong>异步</strong>的，否则，读副本一多，某些副本就很容易出故障，进而阻塞写入。<h3 id="2-1-读你所写"><a href="#2-1-读你所写" class="headerlink" title="2.1 读你所写"></a>2.1 读你所写</h3>在一个<strong>异步复制</strong>的分布式数据库里，同一个客户端，写入<strong>主副本</strong>后返回；稍后再去读一个落后的<strong>从副本</strong>，就会发现：读不到自己刚写的内容！<br>为了避免这种反直觉的事情发生，我们引入一种新的一致性：<strong>读写一致性（read-after-write consistency）</strong>，或者  <strong>读你所写一致性（read-your-writes consistency）</strong>。<br><strong>列举几种方案：</strong></li><li><strong>按内容分类</strong>。对于客户端可能修改的内容集，<strong>只从主副本读取</strong>。如社交网络上的个人资料，读自己的资料时，从主副本读取；但读其他人资料时，可以向从副本读。</li><li><strong>按时间分类</strong>。如果每个客户端都能访问基本所有数据，则方案一就会退化成所有数据都要从主副本读取，这显然不可接受。此时，可以按时间分情况讨论，近期内有过改动的数据，从主副本读，其他的，向从副本读。那这个区分是否最近的<strong>时间阈值</strong>（比如一分钟）如何选取呢？可以监控从副本一段时间内的最大延迟这个经验值，来设置。</li><li><strong>利用时间戳</strong>。客户端记下本客户端上次改动时的时间戳，在读从副本时，利用此时间戳来看某个从副本是否已经同步了改时间戳之前内容。可以在所有副本中找到一个已同步了的；或者阻塞等待某个副本同步到改时间戳后再读取。时间戳可以是逻辑时间戳，也可以是物理时间戳（此时多机时钟同步非常重要）。</li></ol><h3 id="2-2-单调读"><a href="#2-2-单调读" class="headerlink" title="2.2 单调读"></a>2.2 单调读</h3><p>对于一个客户端来说，系统可能会发生<strong>时光倒流（moving backward in time）</strong>。<br>再引入一种一致性保证：<strong>单调读（Monotonic reads）</strong>。</p><ul><li>读写一致性和单调读有什么区别？ 写后读保证的是写后读顺序，单调读保证的是<strong>多次读</strong>之间的顺序。<br>如何实现单调读？</li></ul><ol><li>只从一个副本读数据。</li><li>前面提到的时间戳机制。<h3 id="2-3-一致前缀读"><a href="#2-3-一致前缀读" class="headerlink" title="2.3 一致前缀读"></a>2.3 一致前缀读</h3>异步复制所带来的第三个问题：有时候会违反因果关系。<br>本质在于：如果数据库由多个分区（Partition）组成，而分区间的事件顺序无法保证。此时，如果有因果关系的两个事件落在了不同分区，则有可能会出现<strong>果在前，因在后</strong>。<br>为了防止这种问题，我们又引入了一种一致性：<strong>一致前缀读（consistent prefix reads）</strong>。奇怪的名字。<br>实现这种一致性保证的方法：</li><li>不分区。</li><li>让所有有因果关系的事件路由到一个分区</li></ol><h3 id="2-4-终极解决方案"><a href="#2-4-终极解决方案" class="headerlink" title="2.4 终极解决方案"></a>2.4 终极解决方案</h3><p><strong>事务！</strong><br>多副本异步复制所带来的一致性问题，都可以通过<strong>事务（transaction）</strong> 来解决。单机事务已经存在了很长时间，但在数据库走向分布式时代，一开始很多 NoSQL 系统抛弃了事务。</p><ul><li>这是为什么？<ol><li>更容易的实现。2. 更好的性能。3. 更好的可用性。<br>于是复杂度被转移到了应用层。<br>这是数据库系统刚大规模步入分布式（<strong>多副本、多分区</strong>）时代的一种妥协，在经验积累的够多之后，事务必然会被引回。<br>于是近年来越来越多的分布式数据库开始支持事务，是为<strong>分布式事务</strong>。</li></ol></li></ul><h2 id="3-多主模型"><a href="#3-多主模型" class="headerlink" title="3 多主模型"></a>3 多主模型</h2><p><strong>单主模型一个最大问题</strong>：所有写入都要经过它，如果由于任何原因，客户端无法连接到主副本，就无法向数据库写入。<br><strong>多主复制（multi-leader replication）</strong>：有多个可以接受写入的主副本，每个主副本在接收到写入之后，都要转给所有其他副本。即一个系统，有多个<strong>写入点</strong>。</p><ol><li>数据库横跨多个数据中心</li><li>需要离线工作的客户端</li><li>协同编辑<h2 id="4-无主模型"><a href="#4-无主模型" class="headerlink" title="4 无主模型"></a>4 无主模型</h2>通常来说，在无主模型中，写入时可以：</li><li>由客户端直接写入副本。</li><li>由<strong>协调者（coordinator）</strong> 接收写入，转发给多副本。但与主副本不同，协调者并不负责定序。<h3 id="4-1-有节点故障时的写入"><a href="#4-1-有节点故障时的写入" class="headerlink" title="4.1 有节点故障时的写入"></a>4.1 有节点故障时的写入</h3>多数派写入，多数派读取，以及读时修复。<br>由于写入时，简单的忽略了宕机副本；在读取时，就要多做些事情了：<strong>同时读取多个副本，选取最新<em>版本</em>的值</strong>。</li></ol><h4 id="4-1-1-读时修复和反熵"><a href="#4-1-1-读时修复和反熵" class="headerlink" title="4.1.1 读时修复和反熵"></a>4.1.1 读时修复和反熵</h4><p>无主模型也需要维持多个副本数据的一致性。在某些节点宕机重启后，如何让其弥补错过的数据？</p><ol><li><strong>读时修复（read repair）</strong>，本质上是一种捎带修复，在读取时发现旧的就顺手修了。</li><li><strong>反熵过程（Anti-entropy process）</strong>，本质上是一种兜底修复，读时修复不可能覆盖所有过期数据，因此需要一些后台进程，持续进行扫描，寻找陈旧数据，然后更新</li></ol><h4 id="4-1-2-Quorum-读写"><a href="#4-1-2-Quorum-读写" class="headerlink" title="4.1.2 Quorum 读写"></a>4.1.2 Quorum 读写</h4><p>如果副本总数为 n，写入 w 个副本才认定写入成功，并且在查询时最少需要读取 r 个节点。只要满足 w + r &gt; n，我们就能读到最新的数据（<strong>鸽巢原理</strong>）。此时 r 和 w 的值称为 <strong>quorum 读写</strong>。即这个约束是保证数据有效所需的最低（法定）票数。</p><p>在 Dynamo 流派的存储中，n、r 和 w 通常是可以配置的：</p><ol><li>n 越大冗余度就越高，也就越可靠。</li><li>r 和 w 都常都选择超过半数，如 <code>(n+1)/2</code></li><li>w = n 时，可以让 r = 1。此时是牺牲写入性能换来读取性能。</li></ol><p>考量满足 w+r &gt; n 系统对节点故障的容忍性：</p><ol><li>如果 w &lt; n，则有节点不可用时，仍然能正常写入。</li><li>如果 r &lt; n，则有节点不可用时，仍然能正常读取。</li></ol><p>通常来说，我们会将读或者写并行的发到全部 n 个副本，但是只要等到法定个副本的结果，就可以返回。<br>如果由于某种原因，可用节点数少于 r 或者 w，则读取或者写入就会出错。</p><h3 id="4-2-quorum-一致性的局限"><a href="#4-2-quorum-一致性的局限" class="headerlink" title="4.2 quorum 一致性的局限"></a>4.2 quorum 一致性的局限</h3><ol><li>使用宽松的 Quorum 时（n 台机器范围可以发生变化），w 和 r 可能并没有交集。</li><li>对于写入并发，如果处理冲突不当时。比如使用 last-win 策略，根据本地时间戳挑选时，可能由于时钟偏差造成数据丢失。</li><li>对于读写并发，写操作仅在部分节点成功就被读取，此时不能确定应当返回新值还是旧值。</li><li>如果写入节点数 &lt; w 导致写入失败，但并没有对数据进行回滚时，客户端读取时，仍然会读到旧的数据。</li><li>虽然写入时，成功节点数 &gt; w，但中间有故障造成了一些副本宕机，导致成功副本数 &lt; w，则在读取时可能会出现问题。</li><li>即使都正常工作，也有可能出现一些关于时序（timing）的边角情况。</li></ol><h4 id="4-2-1-一致性监控"><a href="#4-2-1-一致性监控" class="headerlink" title="4.2.1 一致性监控"></a>4.2.1 一致性监控</h4><p>对于无主模型，由于没有固定写入顺序，副本的落后进度变得难以界定。如果系统只使用读时修复策略，则对于一个副本的落后程度是没有限制的。读取频率很低数据可能版本很老。</p><p>最终一致性是一种很模糊的保证，但通过监控能够量化“最终”（比如到一个阈值），也是很棒的。</p><h3 id="4-3-放松的-Quorum-和提示转交"><a href="#4-3-放松的-Quorum-和提示转交" class="headerlink" title="4.3 放松的 Quorum 和提示转交"></a>4.3 放松的 Quorum 和提示转交</h3><p>正常的 Quorum 能够容忍一些副本节点的宕机。但在大型集群（总节点数目 &gt; n）中，可能最初选中的 n 台机器，由于种种原因（宕机、网络问题），导致无法达到法定读写数目，则此时有两种选择：</p><ol><li>对于所有无法达到 r 或 w 个法定数目的读写，直接报错。</li><li>仍然接受写入，并且将新的写入暂时交给一些正常节点。<br>后者被认为是一种<strong>宽松的法定数目</strong> （<strong>sloppy quorum</strong>）：写和读仍然需要 w 和 r 个成功返回，但是其所在节点集合可以发生变化。</li></ol><p>一旦问题得到解决，数据将会根据线索移回其应该在的节点（D—&gt; B），我们称之为<strong>提示移交</strong>（hinted handoff）。这个移交过程是由反熵 anti-entropy 后台进程完成的。</p><p>这是一种典型的牺牲部分一致性，换取更高可用性的做法。在常见的 Dynamo 实现中，放松的法定人数是可选的。在 Riak 中，它们默认是启用的，而在 Cassandra 和 Voldemort 中它们默认是禁用的</p><h4 id="4-3-1-多数据中心"><a href="#4-3-1-多数据中心" class="headerlink" title="4.3.1 多数据中心"></a>4.3.1 多数据中心</h4><p>为了同时兼顾<strong>多数据中心</strong>和<strong>写入的低延迟</strong>，有一些不同的基于无主模型的多数据中心的策略：</p><ol><li>其中 Cassandra 和 Voldemort 将 n 配置到所有数据中心，但写入时只等待本数据中心副本完成就可以返回。</li><li>Riak 将 n 限制在一个数据中心内，因此所有客户端到存储节点的通信可以限制到单个数据中心内，而数据复制在后台异步进行。</li></ol><h3 id="4-4-并发写入检测"><a href="#4-4-并发写入检测" class="headerlink" title="4.4 并发写入检测"></a>4.4 并发写入检测</h3><p>由于 Dynamo 允许多个客户端并发写入相同 Key，则即使使用严格的 Quorum 读写，也会产生冲突：<strong>对于时间间隔很短（并发）的相同 key 两个写入，不同副本上收到的顺序可能不一致</strong>。<br>此外，读时修复和提示移交时，也可能产生冲突。<br>为了使所有副本最终一致，需要有一种手段来解决并发冲突。</p><h4 id="4-4-1-后者胜"><a href="#4-4-1-后者胜" class="headerlink" title="4.4.1 后者胜"></a>4.4.1 后者胜</h4><p>后者胜（LWW，last write wins）的策略是，通过某种手段确定一种全局唯一的顺序，然后让后面的修改覆盖之前的修改。</p><p>如，为所有写入附加一个全局时间戳，如果对于某个 key 的写入有冲突，可以挑选具有最大时间戳的数据保留，并丢弃较早时间戳的写入。<br>使用 LWW 唯一安全的方法是：key 是一次可写，后变为只读。</p><h4 id="4-4-2-发生于之前（Happens-before）和并发关系"><a href="#4-4-2-发生于之前（Happens-before）和并发关系" class="headerlink" title="4.4.2 发生于之前（Happens-before）和并发关系"></a>4.4.2 发生于之前（Happens-before）和并发关系</h4><ol><li>服务器为每个键分配一个版本号 V，每次该键有写入时，将 V + 1，并将版本号与写入的值一块保存。</li><li>当客户端读取该键时，服务器将返回所有未被覆盖的值以及最新的版本号。</li><li>客户端在进行下次写入时，必须<strong>包含</strong>之前读到的版本号 Vx（说明基于哪个版本进行新的写入），并将读取的值合并到一块。</li><li>当服务器收到特定版本号 Vx 的写入时，可以用其值覆盖所有 V ≤ Vx 的值。</li></ol><h4 id="4-4-3-版本向量"><a href="#4-4-3-版本向量" class="headerlink" title="4.4.3 版本向量"></a>4.4.3 版本向量</h4><p>每个副本在遇到写入时，会增加对应键的版本号，同时跟踪从其他副本中看到的版本号，通过比较版本号大小，来决定哪些值要覆盖哪些值要保留。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> DDIA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDIA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[DDIA] 编码和演进</title>
      <link href="/2023/05/28/DDIA/03%20%E7%BC%96%E7%A0%81%E5%92%8C%E6%BC%94%E8%BF%9B/"/>
      <url>/2023/05/28/DDIA/03%20%E7%BC%96%E7%A0%81%E5%92%8C%E6%BC%94%E8%BF%9B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>编码主要涉及两方面问题：如何编码能够节省空间、提高性能;<br> 如何编码以适应数据的演化和兼容。</p></blockquote><span id="more"></span><p>所有涉及跨进程通信的地方，都需要对数据进行<strong>编码</strong>（<strong>Encoding</strong>），或者说<strong>序列化</strong>（<strong>Serialization</strong>）。因为持久化存储和网络传输都是面向字节流的。序列化本质上是一种“<strong>降维</strong>”操作，将内存中高维的数据结构降维成单维的字节流，于是底层硬件和相关协议，只需要处理一维信息即可。<br><strong>编码主要涉及两方面问题：</strong></p><ol><li>如何编码能够节省空间、提高性能。</li><li>如何编码以适应数据的演化和兼容。</li></ol><h2 id="1-数据编码的格式"><a href="#1-数据编码的格式" class="headerlink" title="1 数据编码的格式"></a>1 数据编码的格式</h2><h3 id="1-1-JSON、XML-及其二进制变体"><a href="#1-1-JSON、XML-及其二进制变体" class="headerlink" title="1.1 JSON、XML 及其二进制变体"></a>1.1 JSON、XML 及其二进制变体</h3><p>JSON，XML 和 CSV 属于常用的<strong>文本编码</strong>格式，其好处在于肉眼可读，坏处在于不够紧凑，占空间较多。<br>除了不够紧凑外，<strong>文本编码（text encoding）</strong> 还有以下缺点：</p><ol><li>对<strong>数值类型支持不够</strong>。CSV 和 XML 直接不支持，万物皆字符串。JSON 虽区分字符串和数值，但是不进一步区分细分数值类型。可以理解，毕竟文本编码嘛，主要还是面向字符串。</li><li><strong>对二进制数据支持不够</strong>。支持 Unicode，但是对二进制串支持不够，可能会显示为乱码。虽然可以通过 Base64 编码来绕过，但有点做无用功的感觉。</li><li><strong>XML 和 JSON 支持额外的模式</strong>。模式会描述数据的类型，告诉你如何理解数据。配合这些模式语言，虽然可以让 XML 和 JSON 变得强大，但是大大增加了复杂度。</li><li><strong>CSV 没有任何模式</strong>。</li></ol><h4 id="1-1-1-二进制编码"><a href="#1-1-1-二进制编码" class="headerlink" title="1.1.1 二进制编码"></a>1.1.1 二进制编码</h4><p>JSON 有很多二进制变种：MessagePack、BSON、BJSON、UBJSON、BISON 和 Smile 等。</p><h3 id="1-2-Thrift-和-Protocol-Buffers"><a href="#1-2-Thrift-和-Protocol-Buffers" class="headerlink" title="1.2 Thrift 和 Protocol Buffers"></a>1.2 Thrift 和 Protocol Buffers</h3><p>在编码前都需要由接口定义语言（IDL）来描述模式：<br>IDL 是编程语言无关的，可以利用相关代码生成工具，可以将上述 IDL 翻译为指定语言的代码。即，集成这些生成的代码，无论什么样的语言，都可以使用同样的格式编解码。<br>这也是不同 service 可以使用不同编码语言，且能够互相通信的基础。</p><h4 id="1-2-1-字段标号和模式演变"><a href="#1-2-1-字段标号和模式演变" class="headerlink" title="1.2.1 字段标号和模式演变"></a>1.2.1 字段标号和模式演变</h4><p><strong>模式</strong>，即有哪些字段，字段分别为什么类型。<br>在模式发生改变后，需要：</p><ol><li><strong>向后兼容</strong>：新的代码，在处理新的增量数据格式的同时，也得处理旧的存量数据。</li><li><strong>向前兼容</strong>：旧的代码，如果遇到新的数据格式，不能 crash。</li><li>ProtoBuf 和 Thrift 是怎么处理？ <ol><li><strong>字段标号</strong> + <strong>限定符</strong>（optional、required） </li><li>向后兼容：新加的字段需为 optional。这样在解析旧数据时，才不会出现字段缺失的情况。 </li><li>向前兼容：字段标号不能修改，只能追加。这样旧代码在看到不认识的标号时，省略即可。</li></ol></li></ol><h4 id="1-2-2-数据类型和模式演变"><a href="#1-2-2-数据类型和模式演变" class="headerlink" title="1.2.2 数据类型和模式演变"></a>1.2.2 数据类型和模式演变</h4><ul><li>修改数据类型比较麻烦：只能够在相容类型中进行修改。</li><li>如不能将字符串修改为整形，但是可以在整形内修改：32 bit 到 64 bit 整形。</li><li>ProtoBuf 没有列表类型，而有一个 repeated 类型。其好处在于<strong>兼容数组类型</strong>的同时，支持将可选（optional）<strong>单值字段</strong>，修改为<strong>多值字段</strong>。修改后，旧代码在看到新的多值字段时，只会使用最后一个元素。</li></ul><h3 id="1-3-模式的优点"><a href="#1-3-模式的优点" class="headerlink" title="1.3 模式的优点"></a>1.3 模式的优点</h3><p>模式的本质是显式类型约束， 先有模式，再有数据<br><strong>基于显式定义二进制编码优点有：</strong></p><ol><li>省去字段名，从而更加紧凑。</li><li>模式是数据的注释或者文档，并且总是最新的。</li><li>数据模式允许不读取数据，仅比对模式来做低成本的兼容性检查。</li><li>对于静态类型来说，可以利用代码生成做编译时的类型检查。<h2 id="2-几种数据流模式"><a href="#2-几种数据流模式" class="headerlink" title="2 几种数据流模式"></a>2 几种数据流模式</h2></li></ol><ul><li>数据可以以很多种形式从一个系统流向另一个系统，但不变的是，流动时都需要编码与解码。</li><li>在数据流动时，会涉及编解码双方模式匹配问题</li><li>几种进程间典型的数据流方式：<ul><li>通过数据库</li><li>通过服务调用</li><li>通过异步消息传递</li></ul></li></ul><h3 id="2-1-数据库"><a href="#2-1-数据库" class="headerlink" title="2.1 数据库"></a>2.1 数据库</h3><ol><li><strong>只由同一个进程访问</strong>。则数据库可以理解为该进程向将来发送数据的中介。</li><li><strong>由多个进程访问</strong>。则多个进程可能有的是旧版本，有的是新版本，此时数据库需要考虑向前和向后兼容的问题。</li></ol><p>对于应用程序，可能很短时间就可以由旧版本替换为新版本。但是对于数据，旧版本的代码写入的数据量，经年累月，可能很大。在变更了模式之后，由于这些旧模式的数据量很大，全部更新对齐到新版本的代价很高。<br>这种情况我们称之为：<strong>数据的生命周期超过了其对应代码的生命周期</strong>。<br>在读取时，数据库一般会对缺少对应列的旧数据：</p><ol><li>填充新版本字段的<strong>默认值</strong>（default value）</li><li>如果没有默认值则填充<strong>空值</strong>（nullable）<br>后返回给用户。一般来说，在更改模式时（比如 alter table），数据库不允许增加既没有默认值、也不允许为空的列。</li></ol><p>有时候需要对数据库做备份到外存。在做备份（或者说快照）时，虽然会有不同时间点生成的数据，但通常会将各种版本数据转化、对齐到最新版本。毕竟，总是要全盘拷贝数据，那就顺便做下转换好了。</p><h3 id="2-2-经由服务的数据流：REST-和-RPC"><a href="#2-2-经由服务的数据流：REST-和-RPC" class="headerlink" title="2.2 经由服务的数据流：REST 和 RPC"></a>2.2 经由服务的数据流：REST 和 RPC</h3><ul><li>通过网络通信时，通常涉及两种角色：服务器（server）和客户端（client）。</li><li>通常来说，暴露于公网的多为 HTTP 服务，而 RPC 服务常在内部使用。</li><li>服务器也可以同时是客户端：<ol><li>作为客户端访问数据库。</li><li>作为客户端访问其他服务。</li></ol></li><li>对于后者，是因为我们常把一个大的服务拆成一组功能独立、相对解耦的服务，这就是 <strong>面向服务的架构（service-oriented architecture，SOA）</strong>，或者最近比较火的<strong>微服务架构（micro-services architecture）</strong>。</li><li>服务在某种程度上和数据库类似：允许客户端以某种方式存储和查询数据。但不同的是，数据库通常提供某种灵活的查询语言，而服务只能提供相对死板的 API。</li></ul><h4 id="2-2-1-web-服务"><a href="#2-2-1-web-服务" class="headerlink" title="2.2.1 web 服务"></a>2.2.1 web 服务</h4><p>两种设计 HTTP API 的方法：REST 和 SOAP。</p><ol><li><strong>REST 并不是一种协议，而是一种设计哲学</strong>。它强调简单的 API 格式，使用 URL 来标识资源，使用 HTTP 的动作（GET、POST、PUT、DELETE）来对资源进行增删改查。由于其简洁风格，越来越受欢迎。</li><li>SOAP 是基于 XML 的协议。虽然使用 HTTP，但目的在于独立于 HTTP。现在提的比较少了。</li></ol><h4 id="2-2-2-RPC-面临的问题"><a href="#2-2-2-RPC-面临的问题" class="headerlink" title="2.2.2 RPC 面临的问题"></a>2.2.2 RPC 面临的问题</h4><ol><li>本地函数调用要么成功、要么不成功。但是 RPC 由于经过网络，可能会有各种复杂情况，比如请求丢失、响应丢失、hang 住以至于超时等等。因此，可能需要重试。</li><li>如果重试，需要考虑<strong>幂等性</strong>问题。因为上一次的请求可能已经到达了服务端，只是请求没有成功返回。那么多次调用远端函数，就要保证不会造成额外副作用。</li><li>远端调用延迟不可用，受网络影响较大。</li><li>客户端与服务端使用的编程语言可能不同，但如果有些类型不是两种语言都有，就会出一些问题<h4 id="2-2-3-RPC-当前方向"><a href="#2-2-3-RPC-当前方向" class="headerlink" title="2.2.3 RPC 当前方向"></a>2.2.3 RPC 当前方向</h4></li><li>比如局域网的网络通常比较快速、可控。</li><li>多次调用，使用幂等性来解决。</li><li>跨语言，可以使用 RPC 框架的 IDL 来解决。</li></ol><h4 id="2-2-4-数据编码和-RPC-的演化"><a href="#2-2-4-数据编码和-RPC-的演化" class="headerlink" title="2.2.4 数据编码和 RPC 的演化"></a>2.2.4 数据编码和 RPC 的演化</h4><p>通过服务的数据流通常可以假设：所有的服务端先更新，然后客户端再更新。因此，只需要在请求里考虑后向兼容性，在响应中考虑前向兼容性：</p><ol><li>Thrift、gRPC（Protobuf）和 Avro RPC 可以根据编码格式的兼容性规则进行演变。</li><li>RESTful API 通常使用 JSON 作为请求响应的格式，JSON 比较容易添加新的字段来进行演进和兼容。</li><li>SOAP 按下不表。<br>对于 RPC，服务的兼容性比较困难，因为一旦 RPC 服务的 SDK 提供出去之后，你就无法对其生命周期进行控制：总有用户因为各种原因，不会进行主动升级。因此可能需要长期保持兼容性，或者提前通知和不断预告，或者维护多个版本 SDK 并逐渐对早期版本进行淘汰。<br>对于 RESTful API，常用的兼容方法是，将版本号做到 URL 或者 HTTP 请求头中。</li></ol><h3 id="2-3-经由消息传递的数据流"><a href="#2-3-经由消息传递的数据流" class="headerlink" title="2.3 经由消息传递的数据流"></a>2.3 经由消息传递的数据流</h3><p>介于数据库和 RPC 间的<strong>异步消息系统</strong>：一个存储（消息 broker、消息队列来临时存储消息）+ 两次 RPC（生产者一次，消费者一次）。<br>与 RPC 相比，使用消息队列的优点：</p><ol><li>如果消费者暂时不可用，可以充当暂存系统。</li><li>当消费者宕机重启后，自动地重新发送消息。</li><li>生产者不必知道消费者 IP 和端口。</li><li>能将一条消息发送给多个消费者。</li><li>将生产者和消费者解耦。</li></ol><h4 id="2-3-1-消息队列"><a href="#2-3-1-消息队列" class="headerlink" title="2.3.1 消息队列"></a>2.3.1 消息队列</h4><p>消息队列的<strong>送达保证</strong>因实现和配置而异，包括：</p><ol><li><strong>最少一次（at-least-once）</strong>：同一条数据可能会送达多次给消费者。</li><li><strong>最多一次（at-most-once）</strong>：同一条数据最多会送达一次给消费者，有可能丢失。</li><li><strong>严格一次（exactly-once）</strong>：同一条数据保证会送达一次，且最多一次给消费者。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> DDIA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDIA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[DDIA] 存储和查询</title>
      <link href="/2023/05/24/DDIA/02%20%E5%AD%98%E5%82%A8%E5%92%8C%E6%9F%A5%E8%AF%A2/"/>
      <url>/2023/05/24/DDIA/02%20%E5%AD%98%E5%82%A8%E5%92%8C%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>数据库底层如何处理查询和存储。</p></blockquote><span id="more"></span><p>数据库底层如何处理查询和存储。这其中，有个<strong>逻辑链条</strong>：</p><blockquote><p>使用场景 → 查询类型 → 存储格式。</p></blockquote><p><strong>查询类型</strong></p><ul><li><strong>OLTP</strong><ul><li>侧重在线交易，数据量不大，瓶颈为寻找数据</li><li>行存储</li><li>流派<ul><li>log-structured： 只追加，把随机写改成顺序，类似LevelDB等</li><li>update-in-place：以页为单位修改，主流的关系型数据库，采用b族树的</li></ul></li></ul></li><li><strong>OLAP</strong><ul><li>侧重离线分析，数据量大</li><li>列存储逐渐流行</li></ul></li></ul><h2 id="1-底层数据结构"><a href="#1-底层数据结构" class="headerlink" title="1 底层数据结构"></a>1 底层数据结构</h2><blockquote><p>为了加快读，我们需要构建<strong>索引</strong>：一种允许基于某些字段查找的额外数据结构。</p></blockquote><p>存储引擎设计和选择时最常见的<strong>权衡（trade off）</strong>：</p><ol><li>恰当的<strong>存储格式</strong>能加快写（日志结构），但是会让读取很慢；也可以加快读（查找树、B 族树），但会让写入较慢。</li><li>为了弥补读性能，可以构建索引。但是会牺牲写入性能和耗费额外空间。</li></ol><h3 id="1-1-哈希索引"><a href="#1-1-哈希索引" class="headerlink" title="1.1 哈希索引"></a>1.1 哈希索引</h3><p>所有数据顺序追加到磁盘上。为了加快查询，我们在内存中构建一个哈希索引：</p><ol><li>Key 是查询 Key</li><li>Value 是 KV 条目的起始位置和长度。</li><li><strong>以顺序写代替随机写</strong>。对于磁盘和 SSD，顺序写都要比随机写快几个数量级。</li><li><strong>简易的并发控制</strong>。由于大部分的文件都是<strong>不可变（immutable）</strong> 的，因此更容易做并发读取和紧缩。也不用担心原地更新会造成新老数据交替。</li><li><strong>更少的内部碎片</strong>。每次紧缩会将垃圾完全挤出。但是原地更新就会在 page 中留下一些不可用空间。</li></ol><h3 id="1-2-SSTables-和-LSM-Trees"><a href="#1-2-SSTables-和-LSM-Trees" class="headerlink" title="1.2 SSTables 和 LSM-Trees"></a>1.2 SSTables 和 LSM-Trees</h3><blockquote><p>加一个限制，让这些文件按 key 有序。我们称这种格式为：SSTable（Sorted String Table）</p></blockquote><h4 id="1-2-1-构建和维护"><a href="#1-2-1-构建和维护" class="headerlink" title="1.2.1 构建和维护"></a>1.2.1 构建和维护</h4><p><strong>构建 SSTable 文件</strong>。将乱序数据在外存（磁盘 or SSD）中上整理为有序文件，是比较难的。但是在内存就方便的多。于是一个大胆的想法就形成了：</p><ol><li>在内存中维护一个有序结构（称为 <strong>MemTable</strong>）。红黑树、AVL 树、跳表。</li><li>到达一定阈值之后全量 dump 到外存。<br><strong>维护 SSTable 文件</strong>。为什么需要维护呢？首先要问，对于上述复合结构，我们怎么进行查询：</li><li>先去 MemTable 中查找，如果命中则返回。</li><li>再去 SSTable 按时间顺序由新到旧逐一查找。<br>如果 SSTable 文件越来越多，则查找代价会越来越大。因此需要将多个 SSTable 文件合并，以减少文件数量，同时进行 GC，我们称之为<strong>紧缩</strong>（ Compaction）。</li></ol><h4 id="1-2-2-从-SSTables-到-LSM-Tree"><a href="#1-2-2-从-SSTables-到-LSM-Tree" class="headerlink" title="1.2.2 从 SSTables 到 LSM-Tree"></a>1.2.2 从 SSTables 到 LSM-Tree</h4><ul><li>将前面几节的一些碎片有机的组织起来，便是时下流行的存储引擎 LevelDB 和 RocksDB 后面的存储结构：LSM-Tree</li><li>LSM-Tree 的核心思想——<strong>保存一组合理组织、后台合并的 SSTables</strong> ——简约而强大。可以方便的进行范围遍历，可以变大量随机为少量顺序。<h4 id="1-2-3-性能优化"><a href="#1-2-3-性能优化" class="headerlink" title="1.2.3 性能优化"></a>1.2.3 性能优化</h4><strong>优化 SSTable 的查找</strong>。常用 <a href="https://www.qtmuniao.com/2020/11/18/leveldb-data-structures-bloom-filter/"><strong>Bloom Filter</strong></a>。该数据结构可以使用较少的内存为每个 SSTable 做一些指纹，起到一些初筛的作用。<br><strong>层级化组织 SSTable</strong>。以控制 Compaction 的顺序和时间。常见的有 size-tiered 和 leveled compaction。LevelDB 便是支持后者而得名。前者比较简单粗暴，后者性能更好，也因此更为常见。</li></ul><h3 id="1-3-B-族树"><a href="#1-3-B-族树" class="headerlink" title="1.3 B 族树"></a>1.3 B 族树</h3><ol><li>以页（在磁盘上叫 page，在内存中叫 block，通常为 4k）为单位进行组织。</li><li>页之间以页 ID 来进行逻辑引用，从而组织成一颗磁盘上的树。</li></ol><ul><li><strong>查找</strong>。从根节点出发，进行二分查找，然后加载新的页到内存中，继续二分，直到命中或者到叶子节点。查找复杂度，树的高度—— O(lgn)，影响树高度的因素：分支因子（分叉数，通常是几百个）。</li><li><strong>插入 or 更新</strong>。和查找过程一样，定位到原 Key 所在页，插入或者更新后，将页完整写回。如果页剩余空间不够，则分裂后写入。</li></ul><h4 id="1-3-1-可靠保证："><a href="#1-3-1-可靠保证：" class="headerlink" title="1.3.1 可靠保证："></a>1.3.1 可靠保证：</h4><p>在树结构调整时，可能会级联修改很多 Page。比如叶子节点分裂后，就需要写入两个新的叶子节点，和一个父节点（更新叶子指针）。</p><ol><li>增加预写日志（WAL），将所有修改操作记录下来，预防宕机时中断树结构调整而产生的混乱现场。</li><li>使用 latch 对树结构进行并发控制。</li></ol><h4 id="1-3-2-优化"><a href="#1-3-2-优化" class="headerlink" title="1.3.2 优化"></a>1.3.2 优化</h4><ol><li>不使用 WAL，而在写入时利用 Copy On Write 技术。同时，也方便了并发控制。如 LMDB、BoltDB。</li><li>对中间节点的 Key 做压缩，保留足够的路由信息即可。以此，可以节省空间，增大分支因子。</li><li>为了优化范围查询，有的 B 族树将叶子节点存储时物理连续。但当数据不断插入时，维护此有序性的代价非常大。</li><li>为叶子节点增加兄弟指针，以避免顺序遍历时的回溯。即 B+ 树的做法，但远不局限于 B+ 树。</li><li>B 树的变种，分形树，从 LSM-tree 借鉴了一些思想以优化 seek。</li></ol><h4 id="1-3-3-对比"><a href="#1-3-3-对比" class="headerlink" title="1.3.3 对比"></a>1.3.3 对比</h4><ul><li>LSM-Tree  写入更快，更加紧凑  但是同一个 Key 存多遍</li><li>B Tree 读取更快，范围锁更方便</li></ul><h3 id="1-4-其他索引结构"><a href="#1-4-其他索引结构" class="headerlink" title="1.4 其他索引结构"></a>1.4 其他索引结构</h3><p><strong>次级索引（secondary indexes）</strong>。即，非主键的其他属性到该元素（SQL 中的行，MongoDB 中的文档和图数据库中的点和边）的映射。</p><h4 id="1-4-1-聚集索引和非聚集索引（cluster-indexes-and-non-cluster-indexes）"><a href="#1-4-1-聚集索引和非聚集索引（cluster-indexes-and-non-cluster-indexes）" class="headerlink" title="1.4.1 聚集索引和非聚集索引（cluster indexes and non-cluster indexes）"></a>1.4.1 聚集索引和非聚集索引（cluster indexes and non-cluster indexes）</h4><ol><li>数据本身<strong>无序</strong>的存在文件中，称为 <strong>堆文件（heap file）</strong>，索引的值指向对应数据在 heap file 中的位置。这样可以避免多个索引时的数据拷贝。</li><li>数据本身按某个字段有序存储，该字段通常是主键。则称基于此字段的索引为<strong>聚集索引</strong>（clustered index），从另外一个角度理解，即将索引和数据存在一块。则基于其他字段的索引为<strong>非聚集索引</strong>，在索引中仅存数据的引用。</li><li>一部分列内嵌到索引中存储，一部分列数据额外存储。称为<strong>覆盖索引（covering index）</strong>   或  <strong>包含列的索引（index with included columns）</strong>。</li></ol><h4 id="1-4-2-多列索引"><a href="#1-4-2-多列索引" class="headerlink" title="1.4.2 多列索引"></a>1.4.2 多列索引</h4><ol><li>将二维编码为一维，然后按普通索引存储。</li><li>使用特殊数据结构，如 R 树。</li></ol><h4 id="1-4-3-全文索引和模糊索引"><a href="#1-4-3-全文索引和模糊索引" class="headerlink" title="1.4.3 全文索引和模糊索引"></a>1.4.3 全文索引和模糊索引</h4><p>前述索引只提供全字段的精确匹配，而不提供类似搜索引擎的功能。比如，按字符串中包含的单词查询，针对笔误的单词查询。</p><p>在工程中常用 <a href="https://lucene.apache.org/" title="Apace Lucene">Apace Lucene</a> 库，和其包装出来的服务：<a href="https://www.elastic.co/cn/" title="Elasticsearch">Elasticsearch</a>。他也使用类似 LSM-tree 的日志存储结构，但使用其索引进行模糊匹配的过程，本质上是一个有限状态自动机，在行为上类似 Trie 树。</p><h4 id="1-4-4-全内存数据结构"><a href="#1-4-4-全内存数据结构" class="headerlink" title="1.4.4 全内存数据结构"></a>1.4.4 全内存数据结构</h4><p>根据是否需要持久化，内存数据大概可以分为两类：</p><ol><li><strong>不需要持久化</strong>。如只用于缓存的 Memcached。</li><li><strong>需要持久化</strong>。通过 WAL、定期 snapshot、远程备份等等来对数据进行持久化。但使用内存处理全部读写，因此仍是内存数据库。</li></ol><h2 id="2-事务型还是分析型"><a href="#2-事务型还是分析型" class="headerlink" title="2 事务型还是分析型"></a>2 事务型还是分析型</h2><p>术语 <strong>OL</strong>（Online）主要是指交互式的查询。<br>术语<strong>事务</strong>（transaction）由来有一些历史原因。早期的数据库使用方多为商业交易（commercial），比如买卖、发工资等等。但是随着数据库应用不断扩大，交易\事务作为名词保留了下来。</p><p>事务不一定具有 ACID 特性，事务型处理多是随机的以较低的延迟进行读写，与之相反，分析型处理多为定期的批处理，延迟较高。</p><h4 id="2-1-1-数据仓库"><a href="#2-1-1-数据仓库" class="headerlink" title="2.1.1 数据仓库"></a>2.1.1 数据仓库</h4><p>需要一种手段将数据从原库导入到专门的<strong>数仓</strong>。<br>我们称之为 <strong>ETL：extract-transform-load</strong>。</p><h3 id="2-2-AP-建模：星状型和雪花型"><a href="#2-2-AP-建模：星状型和雪花型" class="headerlink" title="2.2 AP 建模：星状型和雪花型"></a>2.2 AP 建模：星状型和雪花型</h3><p>星状模型通常包含一张<strong>事件表（<em>fact table</em>）</strong> 和多张<strong>维度表（<em>dimension tables</em>）</strong>。事件表以事件流的方式将数据组织起来，然后通过外键指向不同的维度。</p><p>星状模型的一个变种是雪花模型，可以类比雪花（❄️）图案，其特点是在维度表中会进一步进行二次细分，讲一个维度分解为几个子维度。比如品牌和产品类别可能有单独的表格。星状模型更简单，雪花模型更精细，具体应用中会做不同取舍。</p><p>在典型的数仓中，事件表可能会非常宽，即有很多的列：一百到数百列。</p><h2 id="3-列存"><a href="#3-列存" class="headerlink" title="3 列存"></a>3 列存</h2><p><strong>维度表</strong>和<strong>事实表</strong>，对于后者来说，有可能达到数十亿行和数 PB 大。虽然事实表可能通常有几十上百列，但是单次查询通常只关注其中几个维度（列）。</p><h3 id="3-1-列压缩"><a href="#3-1-列压缩" class="headerlink" title="3.1 列压缩"></a>3.1 列压缩</h3><p>将所有数据分列存储在一块，带来了一个意外的好处，由于同一属性的数据相似度高，因此更易压缩。</p><p>如果每一列中值阈相比行数要小的多，可以用<strong>位图编码（<em><a href="https://en.wikipedia.org/wiki/Bitmap_index" title="bitmap encoding">bitmap encoding</a></em>）</strong>。举个例子，零售商可能有数十亿的销售交易，但只有 100,000 个不同的产品。</p><h3 id="3-2-列式存储的排序"><a href="#3-2-列式存储的排序" class="headerlink" title="3.2 列式存储的排序"></a>3.2 列式存储的排序</h3><p>可以如 LSM-Tree 一样，对所有行按某一列进行排序后存储。</p><ul><li>不同副本，不同排序</li></ul><h3 id="3-3-列式存储的写入"><a href="#3-3-列式存储的写入" class="headerlink" title="3.3 列式存储的写入"></a>3.3 列式存储的写入</h3><ol><li>将新写入的数据在<strong>内存</strong>中 Batch 好，按行按列，选什么数据结构可以看需求。</li><li>然后达到一定阈值后，批量刷到<strong>外存</strong>，并与老数据合并。</li></ol><h3 id="3-4-聚合：数据立方和物化视图"><a href="#3-4-聚合：数据立方和物化视图" class="headerlink" title="3.4 聚合：数据立方和物化视图"></a>3.4 聚合：数据立方和物化视图</h3><p>数据仓库查询通常涉及聚合函数，如 SQL 中的 COUNT、SUM、AVG、MIN 或 MAX。如果这些函数被多次用到，每次都即时计算显然存在巨大浪费。因此一个想法就是，能不能将其缓存起来。</p><p>其与关系数据库中的<strong>视图</strong>（View）区别在于，视图是<strong>虚拟的、逻辑存在</strong>的，只是对用户提供的一种抽象，是一个查询的中间结果，并没有进行持久化（有没有缓存就不知道了）。</p><p>物化视图本质上是对数据的一个摘要存储，如果原数据发生了变动，该视图要被重新生成。因此，如果<strong>写多读少</strong>，则维持物化视图的代价很大。但在数仓中往往反过来，因此物化视图才能较好的起作用。</p><p>物化视图一个特化的例子，是<strong>数据立方</strong>（data cube，或者 OLAP cube）：按不同维度对量化数据进行聚合。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> DDIA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDIA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[DDIA] 可靠、可拓展、可维护</title>
      <link href="/2023/05/17/DDIA/01%20%E5%8F%AF%E9%9D%A0%E3%80%81%E5%8F%AF%E6%8B%93%E5%B1%95%E3%80%81%E5%8F%AF%E7%BB%B4%E6%8A%A4/"/>
      <url>/2023/05/17/DDIA/01%20%E5%8F%AF%E9%9D%A0%E3%80%81%E5%8F%AF%E6%8B%93%E5%B1%95%E3%80%81%E5%8F%AF%E7%BB%B4%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如何评价一个好数据系统，如何构建一个好的数据系统，有哪些可以遵循的设计模式？有哪些通常需要考虑的方面？</p></blockquote><span id="more"></span><h2 id="Why-Data-System"><a href="#Why-Data-System" class="headerlink" title="Why Data System"></a>Why Data System</h2><h3 id="常见的数据系统"><a href="#常见的数据系统" class="headerlink" title="常见的数据系统"></a>常见的数据系统</h3><ul><li>存储数据，以便之后再次使用——<strong>数据库</strong></li><li>记住一些非常“重”的操作结果，方便之后加快读取速度——<strong>缓存</strong></li><li>允许用户以各种关键字搜索、以各种条件过滤数据——<strong>搜索引擎</strong></li><li>源源不断的产生数据、并发送给其他进程进行处理——<strong>流式处理</strong></li><li>定期处理累积的大量数据——<strong>批处理</strong></li><li>进行消息的传送与分发——<strong>消息队列</strong></li></ul><h3 id="数据系统的复杂化"><a href="#数据系统的复杂化" class="headerlink" title="数据系统的复杂化"></a>数据系统的复杂化</h3><blockquote><p>如何评价一个好数据系统，如何构建一个好的数据系统，有哪些可以遵循的设计模式？有哪些通常需要考虑的方面？</p><ol><li><strong>Kafka</strong>：可以作为存储持久化一段时间日志数据、可以作为消息队列对数据进行分发、可以作为流式处理组件对数据反复蒸馏等等。</li><li><strong>Spark</strong>：可以对数据进行批处理、也可以化小批为流，对数据进行流式处理。</li><li><strong>Redis</strong>：可以作为缓存加速对数据库的访问、也可以作为事件中心对消息的发布订阅。<br><strong>常见的问题：</strong></li><li>使用何种缓存策略？是旁路还是写穿透？</li><li>部分组件机器出现问题时，是保证可用性还是保证一致性？</li><li>当机器一时难以恢复，如何保证数据的正确性和完整性？</li><li>当负载增加时，是增加机器还是提升单机性能？</li><li>设计对外的 API 时，是力求简洁还是追求强大？</li></ol></blockquote><h2 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h2><p>如何衡量？</p><ul><li><strong>功能上</strong><ol><li>正常情况下，应用行为满足 API 给出的行为</li><li>在用户误输入/误操作时，能够正常处理</li></ol></li><li><strong>性能上</strong> 在给定硬件和数据量下，能够满足承诺的性能指标。</li><li><strong>安全上</strong> 能够阻止未授权、恶意破坏。</li><li>可用性也是可靠性的一个侧面，云服务通常以多少个 9 来衡量可用性。<br>两个易混淆的概念：<strong>Fault（系统出现问题）</strong> 和 <strong>Failure（系统不能提供服务）</strong></li></ul><h3 id="硬件故障"><a href="#硬件故障" class="headerlink" title="硬件故障"></a>硬件故障</h3><p>网络抖动、不通， 硬盘损坏， 机房断电等情况</p><p>数据系统中常见的需要考虑的硬件指标：</p><ul><li><strong>MTTF mean time to failure</strong> 单块盘 平均故障时间 5 ~10 年，如果你有 1w+ 硬盘，则均匀期望下，每天都有坏盘出现。当然事实是硬盘会一波一波坏。<br>解决办法，增加冗余度：机房多路供电，双网络等等。<br>对于数据：</li><li><strong>单机</strong>：可以做 RAID 冗余。如：EC 编码。</li><li><strong>多机</strong>：多副本 或 EC 编码。</li></ul><h3 id="软件错误"><a href="#软件错误" class="headerlink" title="软件错误"></a>软件错误</h3><ol><li>不能处理特定输入，导致系统崩溃。</li><li>失控进程（如循环未释放资源）耗尽 CPU、内存、网络资源。</li><li>系统依赖组件变慢甚至无响应。</li><li>级联故障。</li></ol><p>在设计软件时，我们通常有一些<strong>环境假设</strong>，和一些<strong>隐性约束</strong>。随着时间的推移、系统的持续运行，如果这些假设不能够继续被满足；如果这些约束被后面维护者增加功能时所破坏；都有可能让一开始正常运行的系统，突然崩溃。</p><h3 id="人为问题"><a href="#人为问题" class="headerlink" title="人为问题"></a>人为问题</h3><ul><li><strong>设计编码</strong><ol><li>尽可能消除所有不必要的假设，提供合理的抽象，仔细设计 API</li><li>进程间进行隔离，对尤其容易出错的模块使用沙箱机制</li><li>对服务依赖进行熔断设计</li></ol></li><li><strong>测试阶段</strong><ol><li>尽可能引入第三方成员测试，尽量将测试平台自动化</li><li>单元测试、集成测试、e2e 测试、混沌测试</li></ol></li><li><strong>运行阶段</strong><ol><li>详细的仪表盘</li><li>持续自检</li><li>报警机制</li><li>问题预案</li></ol></li><li><strong>针对组织</strong><ol><li>科学的培训和管理</li></ol></li></ul><h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><h3 id="衡量负载"><a href="#衡量负载" class="headerlink" title="衡量负载"></a>衡量负载</h3><p>应对负载之前，要先找到合适的方法来衡量负载，如<strong>负载参数（load parameters）</strong>：</p><ul><li>应用日活月活</li><li>每秒向 Web 服务器发出的请求</li><li>数据库中的读写比率</li><li>聊天室中同时活跃的用户数量</li></ul><p>以 2012 年 11 月 推特为例</p><ul><li>主营业务：发布推文、首页 Feed 流</li><li>请求量级：发布推文（平均 4.6k 请求/秒，峰值超过 12k 请求/秒），查看其他人推文（300k 请求/秒）</li><li>需要根据用户之间的关注与被关注关系来对数据进行多次处理。常见的有推拉两种方式：<ol><li><strong>拉</strong>。每个人查看其首页 Feed 流时，从数据库现<strong>拉取</strong>所有关注用户推文，合并后呈现。</li><li><strong>推</strong>。为每个用户保存一个 Feed 流视图，当用户发推文时，将其插入所有关注者 Feed 流视图中。</li></ol></li></ul><h3 id="描述性能"><a href="#描述性能" class="headerlink" title="描述性能"></a>描述性能</h3><p>注意和系统负载区分，系统负载是从用户视角来审视系统，是一种<strong>客观指标</strong>。而系统性能则是描述的系统的一种<strong>实际能力</strong>。比如：</p><ol><li><strong>吞吐量（throughput）</strong>：每秒可以处理的单位数据量，通常记为 QPS。</li><li><strong>响应时间（response time）</strong>：从用户侧观察到的发出请求到收到回复的时间。</li><li><strong>延迟（latency）</strong>：日常中，延迟经常和响应时间混用指代响应时间；但严格来说，延迟只是指请求过程中排队等休眠时间，虽然其在响应时间中一般占大头；但只有我们把请求真正处理耗时认为是瞬时，延迟才能等同于响应时间。<br>响应时间通常以百分位点来衡量，比如 p95，p99 和 p999，它们意味着 95％，99％或 99.9％ 的请求都能在该阈值内完成。在实际中，通常使用滑动窗口滚动计算最近一段时间的响应时间分布，并通常以折线图或者柱状图进行呈现。</li></ol><h3 id="应对负载"><a href="#应对负载" class="headerlink" title="应对负载"></a>应对负载</h3><p>如何应对负载的不断增长，即使系统具有可扩展性。</p><ol><li><strong>纵向扩展（scaling up）或 垂直扩展（vertical scaling）</strong>：换具有更强大性能的机器。e.g. 大型机机器学习训练。</li><li><strong>横向扩展（scaling out）或 水平扩展（horizontal scaling）</strong>：“并联”很多廉价机，分摊负载。e.g. 马斯克造火箭。<br>负载扩展的两种方式：</li></ol><ul><li><strong>自动</strong> 如果负载不好预测且多变，则自动较好。坏处在于不易跟踪负载，容易抖动，造成资源浪费。</li><li><strong>手动</strong> 如果负载容易预测且不长变化，最好手动。设计简单，且不容易出错。</li></ul><p>两种服务类型：</p><ul><li><strong>无状态服务</strong> 比较简单，多台机器，外层罩一个 gateway 就行。</li><li><strong>有状态服务</strong> 根据需求场景，如读写负载、存储量级、数据复杂度、响应时间、访问模式，来进行取舍，设计合乎需求的架构。</li></ul><h2 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h2><ol><li>友好的文档和一致的运维规范。</li><li>细致的监控仪表盘、自检和报警。</li><li>通用的缺省配置。</li><li>出问题时的自愈机制，无法自愈时允许管理员手动介入。</li><li>将维护过程尽可能的自动化。</li><li>避免单点依赖，无论是机器还是人。</li></ol><h3 id="简洁性"><a href="#简洁性" class="headerlink" title="简洁性"></a>简洁性</h3><p>复杂度表现：</p><ol><li>状态空间的膨胀。</li><li>组件间的强耦合。</li><li>不一致的术语和<a href="https://www.qtmuniao.com/2021/12/12/how-to-write-code-scrutinize-names/">命名</a>。</li><li>为了提升性能的 hack。</li><li>随处可见的补丁（workaround）。</li></ol><h3 id="可演化性"><a href="#可演化性" class="headerlink" title="可演化性"></a>可演化性</h3><p>需求一定是不断在变，引起变化的原因多种多样：</p><ol><li>对问题阈了解更全面</li><li>出现了之前未考虑到的用例</li><li>商业策略的改变</li><li>客户爸爸要求新功能</li><li>依赖平台的更迭</li><li>合规性要求</li><li>体量的改变</li></ol><p>合理抽象，合理封装，对修改关闭，对扩展开放。</p>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> DDIA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDIA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[DDIA] 数据模型和查询语言</title>
      <link href="/2023/05/16/DDIA/00%20%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/"/>
      <url>/2023/05/16/DDIA/00%20%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%9F%A5%E8%AF%A2%E8%AF%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如何分析一个数据模型 &amp; 如何考量查询语言</p></blockquote><span id="more"></span><h2 id="1-概要"><a href="#1-概要" class="headerlink" title="1 概要"></a>1 概要</h2><p>如何分析一个<strong>数据模型</strong>：</p><ol><li>基本考察点：数据基本元素，和元素之间的对应关系（一对多，多对多）</li><li>利用几种常用模型来比较：（最为流行的）关系模型，（树状的）文档模型，（极大自由度的）图模型。</li><li>schema 模式：强 Schema（写时约束）；弱 Schema（读时解析）</li></ol><p>如何考量<strong>查询语言</strong>：</p><ol><li>如何与数据模型关联、匹配</li><li>声明式（declarative）和命令式（imperative）</li></ol><h3 id="1-1-数据模型"><a href="#1-1-数据模型" class="headerlink" title="1.1 数据模型"></a>1.1 数据模型</h3><blockquote><p>A data model is an abstract model that organizes elements of data and standardizes how they relate to one another and to the properties of real-world entities. —<a href="https://en.wikipedia.org/wiki/Data_model">https://en.wikipedia.org/wiki/Data_model</a></p></blockquote><p><strong>数据模型</strong>：如何组织数据，如何标准化关系，如何关联现实。</p><ol><li>作为<strong>应用开发者，</strong> 你将现实中的具体问题抽象为一组对象、<strong>数据结构（data structure）</strong> 以及作用于其上的 API。</li><li>作为<strong>数据库管理员（DBA）</strong>，为了持久化上述数据结构，你需要将他们表达为通用的<strong>数据模型（data model）</strong>，如文档数据库中的 XML/JSON、关系数据库中的表、图数据库中的图。</li><li>作为<strong>数据库系统开发者</strong>，你需要将上述数据模型组织为内存中、硬盘中或者网络中的<strong>字节（Bytes）</strong> 流，并提供多种操作数据集合的方法。</li><li>作为<strong>硬件工程师</strong>，你需要将字节流表示为二极管的电位（内存）、磁场中的磁极（磁盘）、光纤中的光信号（网络）。</li></ol><h2 id="2-关系模型与文档模型"><a href="#2-关系模型与文档模型" class="headerlink" title="2 关系模型与文档模型"></a>2 关系模型与文档模型</h2><h3 id="2-1-关系模型"><a href="#2-1-关系模型" class="headerlink" title="2.1 关系模型"></a>2.1 关系模型</h3><p>特点如下：</p><ol><li>将数据以<strong>关系</strong>呈现给用户（比如：一组包含行列的二维表）。</li><li><p>提供操作数据集合的<strong>关系算子</strong>。<br><strong>常见分类</strong></p></li><li><p>事务型（TP）：银行交易、火车票</p></li><li>分析型（AP）：数据报表、监控表盘</li><li>混合型（HTAP）：</li></ol><h3 id="2-2-NoSQL"><a href="#2-2-NoSQL" class="headerlink" title="2.2 NoSQL"></a>2.2 NoSQL</h3><ol><li>处理更大数据集：更强伸缩性、更高吞吐量</li><li>开源免费的兴起：冲击了原来把握在厂商的标准</li><li>特化的查询操作：关系数据库难以支持的，比如图中的多跳分析</li><li>表达能力更强：关系模型约束太严，限制太多<h3 id="2-3-面向对象和关系模型的不匹配"><a href="#2-3-面向对象和关系模型的不匹配" class="headerlink" title="2.3 面向对象和关系模型的不匹配"></a>2.3 面向对象和关系模型的不匹配</h3>核心冲突在于面向对象的<strong>嵌套性</strong>和关系模型的<strong>平铺性</strong><br>关系模型很难直观的表示<strong>一对多</strong>的关系。比如简历上，一个人可能有多段教育经历和多段工作经历。<br><strong>文档模型</strong>：使用 Json 和 XML 的天然嵌套。<br><strong>关系模型</strong>：使用 SQL 模型就得将职位、教育单拎一张表，然后在用户表中使用外键关联。<br>在简历的例子中，文档模型还有几个优势：</li><li><strong>模式灵活</strong>：可以动态增删字段，如工作经历。</li><li><strong>更好的局部性</strong>：一个人的所有属性被集中访问的同时，也被集中存储。</li><li><strong>结构表达语义</strong>：简历与联系信息、教育经历、职业信息等隐含一对多的树状关系可以被 JSON 的树状结构明确表达出来。</li></ol><h3 id="2-4-文档模型"><a href="#2-4-文档模型" class="headerlink" title="2.4 文档模型"></a>2.4 文档模型</h3><p>文档型数据库使用场景特点：</p><ol><li>有多种类型的数据，但每个放一张表又不合适。</li><li>数据类型和结构由外部决定，你没办法控制数据的变化。</li></ol><h2 id="3-图模型"><a href="#3-图模型" class="headerlink" title="3 图模型"></a>3 图模型</h2><ul><li>文档模型的适用场景？ 你的建模场景中存在着大量<strong>一对多</strong>（one-to-many）的关系。</li><li>图模型的适用场景？ 你的建模场景中存在大量的<strong>多对多</strong>（many-to-many）的关系。</li><li>图数据模型（属性图）的基本概念一般有三个：<strong>点</strong>，<strong>边</strong>和附着于两者之上的<strong>属性</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 阅读笔记 </category>
          
          <category> DDIA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DDIA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] 垃圾回收</title>
      <link href="/2022/09/12/Golang/2%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2022/09/12/Golang/2%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<blockquote><p>垃圾回收（Garbage Collection，简称 GC）是一种内存管理策略，由垃圾收集器以类似守护协程的方式在后台运作，按照既定的策略为用户回收那些不再被使用的对象，释放对应的内存空间.</p></blockquote><span id="more"></span><h2 id="1-垃圾回收算法"><a href="#1-垃圾回收算法" class="headerlink" title="1 垃圾回收算法"></a>1 垃圾回收算法</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p><strong>GC 带来的优势</strong></p><ul><li>屏蔽内存回收的细节, 使用户更好地聚焦于核心的业务逻辑</li><li>以全局视野执行任务</li></ul><p><strong>GC 带来的劣势</strong></p><ul><li>提高了下限但降低了上限</li><li>增加了额外的成本</li></ul><h3 id="1-2-标记清扫"><a href="#1-2-标记清扫" class="headerlink" title="1.2 标记清扫"></a>1.2 标记清扫</h3><p>标记清扫（Mark-Sweep）算法, 分为两步实现:</p><ul><li>标记：标记出当前还存活的对象</li><li>清扫：清扫掉未被标记到的垃圾对象</li></ul><p>标记清扫通过标记存活对象，从而取补集推断出垃圾对象, 它的缺点在于会产生内存碎片, 这些碎片分散分布的话, 会影响大对象的内存分配.</p><h3 id="1-3-标记压缩"><a href="#1-3-标记压缩" class="headerlink" title="1.3 标记压缩"></a>1.3 标记压缩</h3><p>标记压缩（Mark-Compact）算法，是在标记清扫算法的基础上做了升级，在第二步”清扫“的同时还会对存活对象进行压缩整合，使得整体空间更为紧凑，从而解决内存碎片问题<br>缺陷在于实现时会有很高的复杂度.</p><h3 id="1-4-半空间复制"><a href="#1-4-半空间复制" class="headerlink" title="1.4 半空间复制"></a>1.4 半空间复制</h3><p><strong>半空间复制（Semispace Copy）算法主要实现如下:</strong></p><ul><li>分配两片相等大小的空间，称为 fromspace 和 tospace</li><li>每轮只使用 fromspace 空间，以GC作为分水岭划分轮次</li><li>GC时，将fromspace存活对象转移到tospace中，并以此为契机对空间进行压缩整合</li><li>GC后，交换fromspace和tospace，开启新的轮次</li></ul><p>半空间复制算法应用了以空间换取时间的优化策略，解决了内存碎片的问题，也在一定程度上降低了压缩空间的复杂度. 但其缺点也同样很明显——比较浪费空间<br>Java 所采用的就是半空间复制的升级版</p><h3 id="1-5-引用计数"><a href="#1-5-引用计数" class="headerlink" title="1.5 引用计数"></a>1.5 引用计数</h3><p><strong>引用计数（Reference Counting）主要实现如下:</strong></p><ul><li>对象每被引用一次，计数器加1</li><li>对象每被删除引用一次，计数器减1</li><li>GC时，把计数器等于 0 的对象删除</li></ul><p>缺陷在于无法解决循环引用和自引用的问题</p><h2 id="2-Golang-中的垃圾回收"><a href="#2-Golang-中的垃圾回收" class="headerlink" title="2 Golang 中的垃圾回收"></a>2 Golang 中的垃圾回收</h2><blockquote><p>在 1.8版本之后，Golang 的 GC 策略主要为并发三色标记法+混合写屏障机制</p></blockquote><h3 id="2-1-三色标记法"><a href="#2-1-三色标记法" class="headerlink" title="2.1 三色标记法"></a>2.1 三色标记法</h3><p>Golang GC 中用到的三色标记法属于标记清扫-算法下的一种实现, 主要思路如下:</p><ul><li>对象分为三种颜色标记：黑、灰、白</li><li>黑对象代表，对象自身存活，且其指向对象都已标记完成</li><li>灰对象代表，对象自身存活，但其指向对象还未标记完成</li><li>白对象代表，对象尙未被标记到，可能是垃圾对象</li><li>标记开始前，将根对象（全局对象、栈上局部变量等）置黑，将其所指向的对象置灰</li><li>标记规则是: 从灰对象出发，将其所指向的对象都置灰. 所有指向对象都置灰后，当前灰对象置黑</li><li>标记结束后，白色对象就是不可达的垃圾对象，需要进行清扫</li></ul><h3 id="2-2-并发垃圾回收"><a href="#2-2-并发垃圾回收" class="headerlink" title="2.2 并发垃圾回收"></a>2.2 并发垃圾回收</h3><ul><li>Golang 1.5 版本是个分水岭，在此之前，GC时需要停止全局的用户协程，专注完成GC工作后，再恢复用户协程，这样做在实现上简单直观，但是会对用户造成不好的体验</li><li>自1.5版本以来，Golang引入了并发垃圾回收机制，允许用户协程和后台的GC协程并发运行，大大地提高了用户体验. 但用户协程并发运行时可能对对象间的引用关系进行调整，这会严重打乱GC三色标记时的标记秩序</li></ul><h3 id="2-3-可能的问题"><a href="#2-3-可能的问题" class="headerlink" title="2.3 可能的问题"></a>2.3 可能的问题</h3><ul><li><strong>漏标问题</strong><ul><li>假设只有对象 B 持有对象 C 的引用,如果 GC 协程在 B 删除 C 的引用后才开始扫描 B，就会无法到达 C.  此时从扫描结果上看，C 是不可达的</li><li>针对漏标问题，Golang 给出的解决方案是屏障机制</li></ul></li><li><strong>多标问题</strong><ul><li>假设对象 A 持有对象 B 的引用</li><li>GC协程下，对象 A 被扫描完成，置黑；对象 B 被对象 A 引用，因此被置灰</li><li>用户协程下，对象 A 删除指向对象 B 的引用</li><li>B 在被 A 删除引用后，已成为垃圾对象，但由于其事先已被置灰，因此最终会更新为黑色，不会被 GC 删除</li><li>错标问题对比于漏标问题而言，是相对可以接受的, 至多到下一轮 GC，这部分对象就会被 GC 回收</li></ul></li><li><strong>内存碎片问题</strong><ul><li>Golang采用 TCMalloc 机制，依据对象的大小将其归属为到事先划分好的spanClass当中，这样能够消解外部碎片的问题，将问题限制在相对可控的内部碎片当中</li></ul></li><li><strong>为什么不学 Java 用分代?</strong><ul><li>分代算法指的是，将对象分为年轻代和老年代两部分（或者更多），采用不同的GC策略进行分类管理. 分代GC算法有效的前提是，绝大多数年轻代对象都是朝生夕死，拥有更高的GC回收率，因此适合采用特别的策略进行处理.</li><li>Golang中存在内存逃逸机制，会在编译过程中将生命周期更长的对象转移到堆中，将生命周期短的对象分配在栈上，并以栈为单位对这部分对象进行回收</li><li>综上，内存逃逸机制减弱了分代算法对Golang GC所带来的优势，考虑分代算法需要产生额外的成本（如不同年代的规则映射、状态管理以及额外的写屏障），Golang 选择不采用分代GC算法</li></ul></li></ul><h2 id="3-屏障机制"><a href="#3-屏障机制" class="headerlink" title="3 屏障机制"></a>3 屏障机制</h2><blockquote><p>主要是为了解决2.3小节中提及的并发GC下的漏标问题</p></blockquote><h3 id="3-1-强弱三色不变式"><a href="#3-1-强弱三色不变式" class="headerlink" title="3.1 强弱三色不变式"></a>3.1 强弱三色不变式</h3><p>漏标问题的本质就是，一个已经扫描完成的黑对象指向了一个被灰\白对象删除引用的白色对象. 构成这一场景的要素拆分如下：</p><ol><li>黑色对象指向了白色对象</li><li>灰、白对象删除了白色对象</li><li>（1）、（2）步中谈及的白色对象是同一个对象</li><li>（1）发生在（2）之前</li></ol><p>通过破坏这些要素,可以解决漏标问题, 称为强弱三色不变式:</p><ul><li>强三色不变式：白色对象不能被黑色对象直接引用（直接破坏（1））</li><li>弱三色不变式：白色对象可以被黑色对象引用，但要从某个灰对象出发仍然可达该白对象（间接破坏了（1）、（2）的联动）</li></ul><h3 id="3-2-插入写屏障"><a href="#3-2-插入写屏障" class="headerlink" title="3.2 插入写屏障"></a>3.2 插入写屏障</h3><ul><li>屏障机制类似于一个回调保护机制，指的是在完成某个特定动作前，会先完成屏障成设置的内容</li><li>插入写屏障（Dijkstra）的目标是实现<strong>强三色不变式</strong>，保证当一个黑色对象指向一个白色对象前，会先触发屏障将白色对象置为灰色，再建立引用</li></ul><h3 id="3-3-删除写屏障"><a href="#3-3-删除写屏障" class="headerlink" title="3.3 删除写屏障"></a>3.3 删除写屏障</h3><ul><li>删除写屏障（Yuasa barrier）的目标是实现<strong>弱三色不变式</strong>，保证当一个白色对象即将被上游删除引用前，会触发屏障将其置灰，之后再删除上游指向其的引用</li><li>也就是保证在删除到这个对象 A 的引用后,  对象 A对于 GC 来说依旧是可见的</li></ul><h3 id="3-4-混合写屏障"><a href="#3-4-混合写屏障" class="headerlink" title="3.4 混合写屏障"></a>3.4 混合写屏障</h3><ul><li>插入写屏障、删除写屏障二者择其一，即可解决并发GC的漏标问题，至于错标问题，则采用容忍态度，放到下一轮GC中进行延后处理即可</li><li>但是, 屏障机制无法作用于栈对象, 因为栈对象可能涉及频繁的轻量操作，高频率的触发屏障机制，带来的成本将是无法接受的.</li><li>在 Go1.8 前, 栈上的垃圾对象通过引入额外的Stop the world（STW）阶段解决, 1.18 后,  引入了混合写屏障机制来消除 STW 成本, 主要思路如下:<ul><li>GC 开始前，以栈为单位分批扫描，将栈中所有对象置黑</li><li>GC 期间，栈上新创建对象直接置黑</li><li>堆对象正常启用插入写屏障</li><li>堆对象正常启用删除写屏障</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] 内存分配</title>
      <link href="/2022/09/08/Golang/2%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>/2022/09/08/Golang/2%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Golang的内存管理是基于TCMalloc的核心思想来构建的，内存管理本质上是一个<strong>内存池和多级对象管理</strong></p></blockquote><span id="more"></span><h2 id="1-内存模型"><a href="#1-内存模型" class="headerlink" title="1 内存模型"></a>1 内存模型</h2><h3 id="1-1-操作系统存储模型"><a href="#1-1-操作系统存储模型" class="headerlink" title="1.1 操作系统存储模型"></a>1.1 操作系统存储模型</h3><p><strong>多级存储模型</strong></p><ul><li>寄存器      1ns</li><li>高速缓存   2ns</li><li>内存           10ns</li><li>磁盘            10ms</li></ul><p>速度越快, 空间越小, 价格越贵</p><h3 id="1-2-虚拟内存与物理内存"><a href="#1-2-虚拟内存与物理内存" class="headerlink" title="1.2 虚拟内存与物理内存"></a>1.2 虚拟内存与物理内存</h3><p>虚拟内存作用如下：</p><ul><li>在用户与硬件间添加中间代理层</li><li>优化用户体验（进程感知到获得的内存空间是“连续”的）</li><li>“放大”可用内存（虚拟内存可以由物理内存+磁盘补足，并根据冷热动态置换，用户无感知）</li></ul><h3 id="1-3-分页管理"><a href="#1-3-分页管理" class="headerlink" title="1.3 分页管理"></a>1.3 分页管理</h3><p>操作系统中通常会将虚拟内存和物理内存切割成固定的尺寸，于虚拟内存而言叫作“页”，于物理内存而言叫作“帧”，原因如下：</p><ul><li>提高内存空间利用（以页为粒度后，消灭了不稳定的外部碎片，取而代之的是相对可控的内部碎片）</li><li>提高内外存交换效率（更细的粒度带来了更高的灵活度）</li><li>与虚拟内存机制呼应，便于建立虚拟地址-&gt;物理地址的映射关系（聚合映射关系的数据结构，称为页表）</li><li>linux 页/帧的大小固定，为 4KB（这实际是由实践推动的经验值，太粗会增加碎片率，太细会增加分配频率影响效率）</li></ul><h3 id="1-4-Golang-内存模型"><a href="#1-4-Golang-内存模型" class="headerlink" title="1.4 Golang 内存模型"></a>1.4 Golang 内存模型</h3><p><strong>Golang 的内存模型设计的思路：</strong></p><ul><li>以空间换时间，一次缓存，多次复用<ul><li>由于每次向操作系统申请内存的操作很重，那么不妨一次多申请一些，以备后用, 因此产生了堆 mheap<ul><li>对操作系统而言，这是用户进程中缓存的内存</li><li>对于 Go 进程内部，堆是所有对象的内存起源</li></ul></li></ul></li><li><strong>多级缓存，实现无/细锁化</strong><ul><li>堆是 Go 运行时中最大的临界共享资源，这意味着每次存取都要加锁，在性能层面是一件很可怕的事情.</li><li>因此 Golang 在堆 mheap 之上，依次细化粒度，建立了 mcentral、mcache 的模型:<ul><li>mheap：全局的内存起源，访问要加全局锁</li><li>mcentral：每种对象大小规格（全局共划分为 68 种）对应的缓存，锁的粒度也仅限于同一种规格以内</li><li>mcache：每个 P（正是 GMP 中的 P）持有一份的内存缓存，访问时无锁</li></ul></li></ul></li><li>多级规格，提高利用率<ul><li>page：最小的存储单元, Golang 借鉴操作系统分页管理的思想，每个最小的存储单元也称之为页 page，但大小为 8 KB</li><li>mspan：最小的管理单元. mspan 大小为 page 的整数倍，且从 8B 到 80 KB 被划分为 67 种不同的规格，分配对象时，会根据大小映射到不同规格的 mspan，从中获取空间, 多规格 mspan 特点如下:<ul><li>根据规格大小，产生了等级的制度</li><li>消除了外部碎片，但不可避免会有内部碎片</li><li>宏观上能提高整体空间利用率</li><li>正是因为有了规格等级的概念，才支持 mcentral 实现细锁化</li></ul></li></ul></li></ul><h2 id="2-核心概念"><a href="#2-核心概念" class="headerlink" title="2 核心概念"></a>2 核心概念</h2><h3 id="2-1-内存单元-mspan"><a href="#2-1-内存单元-mspan" class="headerlink" title="2.1 内存单元 mspan"></a>2.1 内存单元 mspan</h3><p><strong>mspan 的特质</strong>:</p><ul><li>mspan 是 Golang 内存管理的最小单元</li><li>mspan 大小是 page 的整数倍（Go 中的 page 大小为 8KB），且内部的页是连续的（至少在虚拟内存的视角中是这样）</li><li>每个 mspan 根据空间大小以及面向分配对象的大小，会被划分为不同的等级</li><li>同等级的 mspan 会从属同一个 mcentral，最终会被组织成链表，因此带有前后指针（prev、next）</li><li>同等级的 mspan 内聚于同一个 mcentral，所以会基于同一把互斥锁管理</li><li>mspan 会基于 bitMap 辅助快速找到空闲内存块（块大小为对应等级下的 object 大小），此时需要使用到 Ctz64 算法</li></ul><h3 id="2-2-内存单元等级-spanClass"><a href="#2-2-内存单元等级-spanClass" class="headerlink" title="2.2 内存单元等级 spanClass"></a>2.2 内存单元等级 spanClass</h3><p>mspan 根据空间大小和面向分配对象的大小，被划分为 67 种等级（1-67，实际上还有一种隐藏的 0 级，用于处理更大的对象，上不封顶）</p><div class="table-container"><table><thead><tr><th><strong>class</strong></th><th><strong>bytes/obj</strong></th><th><strong>bytes/span</strong></th><th><strong>objects</strong></th><th><strong>tail waste</strong></th><th><strong>max waste</strong></th></tr></thead><tbody><tr><td>1</td><td>8</td><td>8192</td><td>1024</td><td>0</td><td>87.50%</td></tr><tr><td>2</td><td>16</td><td>8192</td><td>512</td><td>0</td><td>43.75%</td></tr><tr><td>3</td><td>24</td><td>8192</td><td>341</td><td>8</td><td>29.24%</td></tr><tr><td>4</td><td>32</td><td>8192</td><td>256</td><td>0</td><td>21.88%</td></tr><tr><td>…</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>66</td><td>28672</td><td>57344</td><td>2</td><td>0</td><td>4.91%</td></tr><tr><td>67</td><td>32768</td><td>32768</td><td>1</td><td>0</td><td>12.50%</td></tr></tbody></table></div><ul><li>class：mspan 等级标识，1-67</li><li>bytes/obj：该大小规格的对象会从这一 mspan 中获取空间. 创建对象过程中，大小会向上取整为 8B 的整数倍，因此该表可以直接实现 object 到 mspan 等级 的映射</li><li>bytes/span：该等级的 mspan 的总空间大小</li><li>object：该等级的 mspan 最多可以 new 多少个对象，结果等于 （3）/（2）</li><li>tail waste：（3）/（2）可能除不尽，于是该项值为（3）%（2）</li><li>max waste：最不利的情况下浪费的空间比例</li></ul><h3 id="2-3-线程缓存-mcache"><a href="#2-3-线程缓存-mcache" class="headerlink" title="2.3 线程缓存 mcache"></a>2.3 线程缓存 mcache</h3><p><strong>特点</strong></p><ul><li>mcache 是每个 P 独有的缓存，因此交互无锁</li><li>mcache 将每种 spanClass 等级的 mspan 各缓存了一个，总数为 2（nocan 维度） * 68（大小维度）= 136</li><li>mcache 中还有一个为对象分配器 tiny allocator，用于处理小于 16B 对象的内存分配</li></ul><h3 id="2-4-中心缓存-mcentral"><a href="#2-4-中心缓存-mcentral" class="headerlink" title="2.4 中心缓存 mcentral"></a>2.4 中心缓存 mcentral</h3><p><strong>特点:</strong></p><ul><li>每个 mcentral 对应一种 spanClass</li><li>每个 mcentral 下聚合了该 spanClass 下的 mspan</li><li>mcentral 下的 mspan 分为两个链表，分别为有空间 mspan 链表 partial 和满空间 mspan 链表 full</li><li>每个 mcentral 一把锁</li></ul><h3 id="2-5-全局堆缓存-mheap"><a href="#2-5-全局堆缓存-mheap" class="headerlink" title="2.5 全局堆缓存 mheap"></a>2.5 全局堆缓存 mheap</h3><p><strong>特点:</strong></p><ul><li>对于 Golang 上层应用而言，堆是操作系统虚拟内存的抽象</li><li>以页（8KB）为单位，作为最小内存存储单元</li><li>负责将连续页组装成 mspan</li><li>全局内存基于 bitMap 标识其使用情况，每个 bit 对应一页，为 0 则自由，为 1 则已被 mspan 组装</li><li>通过 heapArena 聚合页，记录了页到 mspan 的映射信息</li><li>建立空闲页基数树索引 radix tree index，辅助快速寻找空闲页</li><li>是 mcentral 的持有者，持有所有 spanClass 下的 mcentral，作为自身的缓存</li><li>内存不够时，向操作系统申请，申请单位为 heapArena（64M）</li></ul><h3 id="2-6-空闲页索引-pageAlloc"><a href="#2-6-空闲页索引-pageAlloc" class="headerlink" title="2.6 空闲页索引 pageAlloc"></a>2.6 空闲页索引 pageAlloc</h3><ul><li>mheap 会基于 bitMap 标识内存中各页的使用情况，bit 位为 0 代表该页是空闲的，为 1 代表该页已被 mspan 占用</li><li>每棵基数树聚合了 16 GB 内存空间中各页使用情况的索引信息，用于帮助 mheap 快速找到指定长度的连续空闲页的所在位置</li><li>mheap 持有 2^14 棵基数树，因此索引全面覆盖到 2^14 * 16 GB = 256 T 的内存空间</li><li>基数树中，每个节点称之为 PallocSum，是一个 uint64 类型，体现了索引的聚合信息，包含以下四部分：<ul><li>start：最右侧 21 个 bit，标识了当前节点映射的 bitMap 范围中首端有多少个连续的 0 bit（空闲页），称之为 start；</li><li>max：中间 21 个 bit，标识了当前节点映射的 bitMap 范围中最多有多少个连续的 0 bit（空闲页），称之为 max；</li><li>end：左侧 21 个 bit，标识了当前节点映射的 bitMap 范围中最末端有多少个连续的 0 bit（空闲页），称之为 end.</li><li>最左侧一个 bit，弃置不用</li></ul></li><li>基数树父子关系<ul><li>每个父 pallocSum 有 8 个子 pallocSum</li><li>根 pallocSum 总览全局，映射的 bitMap 范围为全局的 16 GB 空间（其 max 最大值为 2^21，因此总空间大小为 2^21*8KB=16GB）</li><li>从首层向下是一个依次八等分的过程，每一个 pallocSum 映射其父节点 bitMap 范围的八分之一，因此第二层 pallocSum 的 bitMap 范围为 16GB/8 = 2GB，以此类推，第五层节点的范围为 16GB / (8^4) = 4 MB，已经很小</li><li>聚合信息时，自底向上. 每个父 pallocSum 聚合 8 个子 pallocSum 的 start、max、end 信息，形成自己的信息，直到根 pallocSum，坐拥全局 16 GB 的 start、max、end 信息</li><li>mheap 寻页时，自顶向下. 对于遍历到的每个 pallocSum，先看起 start 是否符合，是则寻页成功；再看 max 是否符合，是则进入其下层孩子 pallocSum 中进一步寻访；最后看 end 和下一个同辈 pallocSum 的 start 聚合后是否满足，是则寻页成功</li></ul></li></ul><h3 id="2-7-heapArena"><a href="#2-7-heapArena" class="headerlink" title="2.7 heapArena"></a>2.7 heapArena</h3><ul><li>每个 heapArena 包含 8192 个页，大小为 8192 * 8KB = 64 MB</li><li>heapArena 记录了页到 mspan 的映射. 因为 GC 时，通过地址偏移找到页很方便，但找到其所属的 mspan 不容易. 因此需要通过这个映射信息进行辅助.</li><li>heapArena 是 mheap 向操作系统申请内存的单位（64MB）</li></ul><h2 id="3-对象分配流程"><a href="#3-对象分配流程" class="headerlink" title="3 对象分配流程"></a>3 对象分配流程</h2><p>串联 Golang 中分配对象的流程，不论是以下哪种方式，最终都会殊途同归步入 mallocgc 方法中，并且根据 3.1 小节中的策略执行分配流程:</p><ul><li>new(T)</li><li>&amp;T{}</li><li>make(xxxx)</li></ul><h3 id="3-1-分配流程总览"><a href="#3-1-分配流程总览" class="headerlink" title="3.1 分配流程总览"></a>3.1 分配流程总览</h3><p>Golang 中，依据 object 的大小，会将其分为下述三类:</p><ul><li>tiny 微对象 0-16B</li><li>small 小对象 16B-32KB</li><li>large 大对象 32KB+</li></ul><p>不同类型的对象，会有着不同的分配策略, 核心流程类似于读多级缓存的过程，由上而下，每一步只要成功则直接返回. 若失败，则由下层方法兜底.</p><p><strong>微对象的分配流程：</strong></p><ol><li>从 P 专属 mcache 的 tiny 分配器取内存（无锁）</li><li>根据所属的 spanClass，从 P 专属 mcache 缓存的 mspan 中取内存（无锁）</li><li>根据所属的 spanClass 从对应的 mcentral 中取 mspan 填充到 mcache，然后从 mspan 中取内存（spanClass 粒度锁）</li><li>根据所属的 spanClass，从 mheap 的页分配器 pageAlloc 取得足够数量空闲页组装成 mspan 填充到 mcache，然后从 mspan 中取内存（全局锁）</li><li>mheap 向操作系统申请内存，更新页分配器的索引信息，然后重复 4</li></ol><p>对于小对象的分配流程是跳过（1）步，执行上述流程的（2）-（5）步<br>对于大对象的分配流程是跳过（1）-（3）步，执行上述流程的（4）-（5）步</p><h3 id="3-2-主干方法-mallocgc"><a href="#3-2-主干方法-mallocgc" class="headerlink" title="3.2 主干方法 mallocgc"></a>3.2 主干方法 mallocgc</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="type">uintptr</span>, typ *_type, needzero <span class="type">bool</span>)</span></span> unsafe.Pointer &#123;</span><br><span class="line">    <span class="comment">// ...    </span></span><br><span class="line">    <span class="comment">// 获取 m</span></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    <span class="comment">// 获取当前 p 对应的 mcache</span></span><br><span class="line">    c := getMCache(mp)</span><br><span class="line">    <span class="keyword">var</span> span *mspan</span><br><span class="line">    <span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">    <span class="comment">// 根据当前对象是否包含指针，标识 gc 时是否需要展开扫描</span></span><br><span class="line">    noscan := typ == <span class="literal">nil</span> || typ.ptrdata == <span class="number">0</span></span><br><span class="line">    <span class="comment">// 是否是小于 32KB 的微、小对象</span></span><br><span class="line">    <span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line">    <span class="comment">// 小于 16 B 且无指针，则视为微对象</span></span><br><span class="line">        <span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">        <span class="comment">// tiny 内存块中，从 offset 往后有空闲位置</span></span><br><span class="line">          off := c.tinyoffset</span><br><span class="line">          <span class="comment">// 如果大小为 5 ~ 8 B，size 会被调整为 8 B，此时 8 &amp; 7 == 0，会走进此分支</span></span><br><span class="line">          <span class="keyword">if</span> size&amp;<span class="number">7</span> == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="comment">// 将 offset 补齐到 8 B 倍数的位置</span></span><br><span class="line">                off = alignUp(off, <span class="number">8</span>)</span><br><span class="line">                <span class="comment">// 如果大小为 3 ~ 4 B，size 会被调整为 4 B，此时 4 &amp; 3 == 0，会走进此分支  </span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">           <span class="comment">// 将 offset 补齐到 4 B 倍数的位置</span></span><br><span class="line">                off = alignUp(off, <span class="number">4</span>)</span><br><span class="line">                <span class="comment">// 如果大小为 1 ~ 2 B，size 会被调整为 2 B，此时 2 &amp; 1 == 0，会走进此分支  </span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> size&amp;<span class="number">1</span> == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 将 offset 补齐到 2 B 倍数的位置</span></span><br><span class="line">                off = alignUp(off, <span class="number">2</span>)</span><br><span class="line">           &#125;</span><br><span class="line"><span class="comment">// 如果当前 tiny 内存块空间还够用，则直接分配并返回</span></span><br><span class="line">            <span class="keyword">if</span> off+size &lt;= maxTinySize &amp;&amp; c.tiny != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 分配空间</span></span><br><span class="line">                x = unsafe.Pointer(c.tiny + off)</span><br><span class="line">                c.tinyoffset = off + size</span><br><span class="line">                c.tinyAllocs++</span><br><span class="line">                mp.mallocing = <span class="number">0</span></span><br><span class="line">                releasem(mp)  </span><br><span class="line">                <span class="keyword">return</span> x</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 分配一个新的 tiny 内存块</span></span><br><span class="line">            span = c.alloc[tinySpanClass]    </span><br><span class="line">            <span class="comment">// 从 mCache 中获取</span></span><br><span class="line">            v := nextFreeFast(span)        </span><br><span class="line">            <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 从 mCache 中获取失败，则从 mCentral 或者 mHeap 中获取进行兜底</span></span><br><span class="line">                v, span, shouldhelpgc = c.nextFree(tinySpanClass)</span><br><span class="line">            &#125;   </span><br><span class="line"><span class="comment">// 分配空间      </span></span><br><span class="line">            x = unsafe.Pointer(v)</span><br><span class="line">           (*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">           (*[<span class="number">2</span>]<span class="type">uint64</span>)(x)[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">           size = maxTinySize</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 根据对象大小，映射到其所属的 span 的等级(0~66）</span></span><br><span class="line">          <span class="keyword">var</span> sizeclass <span class="type">uint8</span></span><br><span class="line">          <span class="keyword">if</span> size &lt;= smallSizeMax<span class="number">-8</span> &#123;</span><br><span class="line">              sizeclass = size_to_class8[divRoundUp(size, smallSizeDiv)]</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              sizeclass = size_to_class128[divRoundUp(size-smallSizeMax, largeSizeDiv)]</span><br><span class="line">          &#125;        </span><br><span class="line">          <span class="comment">// 对应 span 等级下，分配给每个对象的空间大小(0~32KB)</span></span><br><span class="line">          size = <span class="type">uintptr</span>(class_to_size[sizeclass])</span><br><span class="line">          <span class="comment">// 创建 spanClass 标识，其中前 7 位对应为 span 的等级(0~66)，最后标识表示了这个对象 gc 时是否需要扫描</span></span><br><span class="line">          spc := makeSpanClass(sizeclass, noscan) </span><br><span class="line">          <span class="comment">// 获取 mcache 中的 span</span></span><br><span class="line">          span = c.alloc[spc]  </span><br><span class="line">          <span class="comment">// 从 mcache 的 span 中尝试获取空间        </span></span><br><span class="line">          v := nextFreeFast(span)</span><br><span class="line">          <span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line">          <span class="comment">// mcache 分配空间失败，则通过 mcentral、mheap 兜底            </span></span><br><span class="line">             v, span, shouldhelpgc = c.nextFree(spc)</span><br><span class="line">          &#125;     </span><br><span class="line">          <span class="comment">// 分配空间  </span></span><br><span class="line">          x = unsafe.Pointer(v)</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">       &#125;      </span><br><span class="line">       <span class="comment">// 大于 32KB 的大对象      </span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 从 mheap 中获取 0 号 span</span></span><br><span class="line">       span = c.allocLarge(size, noscan)</span><br><span class="line">       span.freeindex = <span class="number">1</span></span><br><span class="line">       span.allocCount = <span class="number">1</span></span><br><span class="line">       size = span.elemsize         </span><br><span class="line">       <span class="comment">// 分配空间   </span></span><br><span class="line">        x = unsafe.Pointer(span.base())</span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">return</span> x</span><br><span class="line">&#125;      </span><br></pre></td></tr></table></figure><h3 id="3-3-步骤（1）：tiny-分配"><a href="#3-3-步骤（1）：tiny-分配" class="headerlink" title="3.3 步骤（1）：tiny 分配"></a>3.3 步骤（1）：tiny 分配</h3><p>每个 P 独有的 mcache 会有个微对象分配器，基于 offset 线性移动的方式对微对象进行分配，每 16B 成块，对象依据其大小，会向上取整为 2 的整数次幂进行空间补齐，然后进入分配流程</p><h3 id="3-4-步骤（2）：mcache-分配"><a href="#3-4-步骤（2）：mcache-分配" class="headerlink" title="3.4 步骤（2）：mcache 分配"></a>3.4 步骤（2）：mcache 分配</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据对象大小，映射到其所属的 span 的等级(0~66）</span></span><br><span class="line"><span class="keyword">var</span> sizeclass <span class="type">uint8</span></span><br><span class="line"><span class="comment">// get size class ....     </span></span><br><span class="line"><span class="comment">// 对应 span 等级下，分配给每个对象的空间大小(0~32KB)</span></span><br><span class="line"><span class="comment">// get span class</span></span><br><span class="line">spc := makeSpanClass(sizeclass, noscan) </span><br><span class="line"><span class="comment">// 获取 mcache 中的 span</span></span><br><span class="line">span = c.alloc[spc]  </span><br><span class="line"><span class="comment">// 从 mcache 的 span 中尝试获取空间        </span></span><br><span class="line">v := nextFreeFast(span)</span><br><span class="line"><span class="keyword">if</span> v == <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// mcache 分配空间失败，则通过 mcentral、mheap 兜底            </span></span><br><span class="line">   v, span, shouldhelpgc = c.nextFree(spc)</span><br><span class="line">&#125;     </span><br><span class="line"><span class="comment">// 分配空间  </span></span><br><span class="line">x = unsafe.Pointer(v)</span><br></pre></td></tr></table></figure><h3 id="3-5-步骤（3）：mcentral-分配"><a href="#3-5-步骤（3）：mcentral-分配" class="headerlink" title="3.5 步骤（3）：mcentral 分配"></a>3.5 步骤（3）：mcentral 分配</h3><ul><li>当 mspan 无可用的 object 内存块时，会步入 mcache.nextFree 方法进行兜底.</li><li>倘若 mcache 中，对应的 mspan 空间不足，则会在 mcache.refill 方法中，向更上层的 mcentral 乃至 mheap 获取 mspan，填充到 mache 中</li><li>mcentral.cacheSpan 方法中，会加锁（spanClass 级别的 sweepLocker），分别从 partial 和 full 中尝试获取有空间的 mspan</li></ul><h3 id="3-6-步骤（4）：mheap-分配"><a href="#3-6-步骤（4）：mheap-分配" class="headerlink" title="3.6 步骤（4）：mheap 分配"></a>3.6 步骤（4）：mheap 分配</h3><p>在 mcentral.cacheSpan 方法中，倘若从 partial 和 full 中都找不到合适的 mspan 了，则会调用 mcentral 的 grow 方法，将事态继续升级<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> cacheSpan() *mspan &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// mcentral 中也没有可用的 mspan 了，则需要从 mheap 中获取，最终会调用 mheap_.alloc 方法</span></span><br><span class="line">    s = c.grow()</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行到此处时，s 已经指向一个存在 object 空位的 mspan 了</span></span><br><span class="line">havespan:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>经由 mcentral.grow 方法和 mheap.alloc 方法的周转，最终会步入 mheap.allocSpan 方法中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *mcentral)</span></span> grow() *mspan &#123;</span><br><span class="line">    npages := <span class="type">uintptr</span>(class_to_allocnpages[c.spanclass.sizeclass()])</span><br><span class="line">    size := <span class="type">uintptr</span>(class_to_size[c.spanclass.sizeclass()])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    s := mheap_.alloc(npages, c.spanclass)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> alloc(npages <span class="type">uintptr</span>, spanclass spanClass) *mspan &#123;</span><br><span class="line">    <span class="keyword">var</span> s *mspan</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        s = h.allocSpan(npages, spanAllocHeap, spanclass)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *mheap)</span></span> allocSpan(npages <span class="type">uintptr</span>, typ spanAllocType, spanclass spanClass) (s *mspan) &#123;</span><br><span class="line">    gp := getg()</span><br><span class="line">    base, scav := <span class="type">uintptr</span>(<span class="number">0</span>), <span class="type">uintptr</span>(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...此处实际上还有一阶缓存，是从每个 P 的页缓存 pageCache 中获取空闲页组装 mspan，此处先略去了...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加上堆全局锁</span></span><br><span class="line">    lock(&amp;h.lock)</span><br><span class="line">    <span class="keyword">if</span> base == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 通过基数树索引快速寻找满足条件的连续空闲页</span></span><br><span class="line">        base, scav = h.pages.alloc(npages)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    unlock(&amp;h.lock)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HaveSpan:</span><br><span class="line">    <span class="comment">// 把空闲页组装成 mspan</span></span><br><span class="line">    s.init(base, npages)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将这批页添加到 heapArena 中，建立由页指向 mspan 的映射</span></span><br><span class="line">    h.setSpans(s.base(), npages, s)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-步骤（5）：向操作系统申请"><a href="#3-7-步骤（5）：向操作系统申请" class="headerlink" title="3.7 步骤（5）：向操作系统申请"></a>3.7 步骤（5）：向操作系统申请</h3><p>倘若 mheap 中没有足够多的空闲页了，会发起 mmap 系统调用，向操作系统申请额外的内存空间</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 内存管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Channel</title>
      <link href="/2022/07/14/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Channel/"/>
      <url>/2022/07/14/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Channel/</url>
      
        <content type="html"><![CDATA[<blockquote><p>学习 golang 中的 chan，并分析其具体实现，包括创建 channel，发送数据，接收数据以及相关调度等。</p></blockquote><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><blockquote><p>A channel provides a mechanism for concurrently executing functions to communicate by sending and receiving values of a specified element type. The value of an uninitialized channel is nil.</p></blockquote><p>chan 提供了一种并发通信机制，用于生产和消费某一指定类型数据，未初始化的 chan 的值是nil。</p><p> <strong>使用场景：</strong> 消息传递、消息过滤，信号广播，事件订阅与广播，请求、响应转发，任务分发，结果汇总，并发控制，限流，同步与异步</p><h2 id="2-特性与实现"><a href="#2-特性与实现" class="headerlink" title="2 特性与实现"></a>2 特性与实现</h2><p>Chan 是 Go 里面的一种数据结构，具有以下特性：</p><ul><li>goroutine-safe，多个 goroutine 可以同时访问一个 channel 而不会出现并发问题</li><li>可以用于在 goroutine 之间存储和传递值</li><li>先入先出（FIFO）</li><li>可以导致 goroutine 的 block 和 unblock<h3 id="2-1-内部结构"><a href="#2-1-内部结构" class="headerlink" title="2.1 内部结构"></a>2.1 内部结构</h3></li></ul><p>主要包含以下几个部分：</p><ul><li>circular queue：循环队列，用于存储数据</li><li>send index 记录发送的位置</li><li>receive index 记录接收的位置</li><li>mutex 锁，用于实现 goroutine safe。</li></ul><p>元素队列的具体实现很简单，就是一个环形队列，使用 sendx 和 recvx 分别用来记录发送、接收的 offset，然后通过 mutex 互斥锁来保证并发安全。</p><h3 id="2-2-创建-chan"><a href="#2-2-创建-chan" class="headerlink" title="2.2 创建 chan"></a>2.2 创建 chan</h3><p>chan 使用 make 进行初始化，第一个参数指定 chan 中的元素类型，第二个参数用于指定 chan 的缓冲区大小。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">string</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>make 返回的 ch 实际上是一个指向 heap 中真正的 chan 对象的指针。<br><strong>chan（即 hchan 结构体） 默认会被分配在堆上，make 返回的只是一个指向该对象的指针</strong>。</p><blockquote><p>可以在函数之间传递 chan，而不是 chan 的指针。 因为 chan 本身就是指针</p></blockquote><h3 id="2-3-发送、接收与关闭"><a href="#2-3-发送、接收与关闭" class="headerlink" title="2.3 发送、接收与关闭"></a>2.3 发送、接收与关闭</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> Task, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> _,task := <span class="keyword">range</span> helloTasks &#123;</span><br><span class="line">    taskCh &lt;- task <span class="comment">// 发送</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(tashCh) <span class="comment">// 关闭</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ch)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        task:= &lt;-taskCh <span class="comment">// 接收</span></span><br><span class="line">        process(task)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main goroutine 发送 task 到 chan，然后 worker goroutine 从 chan 中接收 task 并处理，最后 main goroutine 发送完成后关闭 chan。<br>具体<strong>发送过程</strong>如下：</p><ul><li>acquire 加锁</li><li>enqueue，将 task 对象<strong>拷贝</strong>到数组里</li><li>release 释放锁</li></ul><p>对于 chan 的关闭，最佳实践是由发送方进行关闭。<br><strong>接收过程</strong>：</p><ul><li>acquire 加锁</li><li>dequeue<ul><li>将 task 对象从 数组 中 <strong>拷贝</strong>出来赋值给用户用于接收的对象</li><li><code>task:= &lt;-taskCh</code>,比如这里就是拷贝出来赋值给 task</li></ul></li><li>release 释放锁</li></ul><p>整个过程中没有任何共享内存，数据都是通过 copy 进行传递,这遵循了 Go 并发设计中很核心的一个理念：</p><blockquote><p>Do not communicate by sharing memory; instead, share memory by communicating.</p></blockquote><h3 id="2-4-阻塞与唤醒"><a href="#2-4-阻塞与唤醒" class="headerlink" title="2.4 阻塞与唤醒"></a>2.4 阻塞与唤醒</h3><p>hchan 中的 buf 数组大小就是 make chan 时指定的大小。<br>当 buf 满之后再往 chan 中发送值就会阻塞。</p><blockquote><p>goroutine 调度：G 阻塞之后并不会阻塞 M。M 会先把这个 G 暂停(gopark)，然后把执行栈切换到 g0，g0 会执行 schedule() 函数，从当前 M 绑定的 P 中查找有没有可以执行的G，有就捞出来继续执行。</p></blockquote><h4 id="2-4-1-先发后收"><a href="#2-4-1-先发后收" class="headerlink" title="2.4.1 先发后收"></a>2.4.1 先发后收</h4><p>假设 chan 中已经有 3 个 task 了,然后再往里面发送一个</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskCh &lt;- task </span><br></pre></td></tr></table></figure><p>runtime 会调用 gopark 将这个 goroutine(姑且称作G1) 切换到 wait 状态。<br><em>什么时候会被唤醒呢？</em><br>hchan 结构体中还有 sendq、recvq 两个列表，分别记录了等待发送或者接收的 goroutine：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog</span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>比如前面被阻塞的 G1 就会存入 sendq</p></blockquote><p>假设此时 G2 从 chan 中取走一个消息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task:= &lt;-taskCh </span><br></pre></td></tr></table></figure><p>G2 取走一个消息后就会找到 sendq 中的第一个对象，把待发送的 elem 直接写入 buf 数组。然后 调用 goready 把对应的 goroutine  G1 设置为 runnable 状态。</p><h4 id="2-4-2-先收后发"><a href="#2-4-2-先收后发" class="headerlink" title="2.4.2 先收后发"></a>2.4.2 先收后发</h4><p>之前是先发送，后接收。现在看一下先接收后发送的情况。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task:= &lt;-taskCh </span><br></pre></td></tr></table></figure><p>G2 直接从空的 chan 中取消息，同样会被阻塞,然后被写入到 hchan 的 recqv 中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">taskCh &lt;- task </span><br></pre></td></tr></table></figure><p>按照上面的逻辑应该是，将 task 写入 buf 数组后，，再把 recvq 中的第一个 goroutine G2 唤醒。</p><p>但是 Go 官方这里进行了优化。因为 recvq 里的 elem 对象 t 存的就是<strong>接收者的内存地址</strong>。</p><p>所以我们可以直接把 G1 发送来的 task 写入 elem 对应的 t 里，即在 G1 里修改 G2 的栈对象。</p><blockquote><p>因为这个时候 G2 还是 gopark，处于 waiting 状态，所以不会出问题。</p><p>正常情况下因为不知道两个线程谁先谁后，这样改肯定会出问题。但是在 go runtime 这里，肯定是 G2 先执行，满足 happen-before 所以不存在问题。</p></blockquote><p>省去了发送和接收时的两次加解锁和内存拷贝。</p><h3 id="2-5-特性实现原理"><a href="#2-5-特性实现原理" class="headerlink" title="2.5 特性实现原理"></a>2.5 特性实现原理</h3><ul><li><strong>goroutine-safe</strong>.<ul><li>hchan <strong>mutex</strong>，通过加锁来避免数据竞争。</li></ul></li><li>可以用于在 goroutine 之间存储和传递值，以及先入先出（FIFO）语义。<ul><li>copying into and out of hchan <strong>buffer</strong></li></ul></li><li>可以导致 goroutine 的 block 和 unblock<ul><li>通过 <strong>sudog queues</strong> 来记录阻塞的 goroutine。</li><li>通过 <strong>runtime scheduler</strong>(gopark, goready)来实现阻塞与唤醒。</li></ul></li></ul><h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3 源码分析"></a>3 源码分析</h2><p><code>runtime/chan.go</code></p><h3 id="3-1-内部结构"><a href="#3-1-内部结构" class="headerlink" title="3.1 内部结构"></a>3.1 内部结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="type">uint</span>           <span class="comment">// total data in the queue</span></span><br><span class="line">dataqsiz <span class="type">uint</span>           <span class="comment">// size of the circular queue</span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// points to an array of dataqsiz elements</span></span><br><span class="line">elemsize <span class="type">uint16</span></span><br><span class="line">closed   <span class="type">uint32</span></span><br><span class="line">elemtype *_type <span class="comment">// element type</span></span><br><span class="line">sendx    <span class="type">uint</span>   <span class="comment">// send index</span></span><br><span class="line">recvx    <span class="type">uint</span>   <span class="comment">// receive index</span></span><br><span class="line">recvq    waitq  <span class="comment">// list of recv waiters</span></span><br><span class="line">sendq    waitq  <span class="comment">// list of send waiters</span></span><br><span class="line">lock mutex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog</span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> sudog <span class="keyword">struct</span> &#123;</span><br><span class="line">    g *g</span><br><span class="line">    next *sudog</span><br><span class="line">    prev *sudog</span><br><span class="line">    elem unsafe.Pointer <span class="comment">// data element (may point to stack)</span></span><br><span class="line">    isSelect <span class="type">bool</span></span><br><span class="line">    c        *hchan </span><br><span class="line">&#125;<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">- qcount：当前 channel 中存在多少个元素；</span></span><br><span class="line"><span class="string">- dataqsize: 当前 channel 能存放的元素容量；</span></span><br><span class="line"><span class="string">- buf：channel 中用于存放元素的环形缓冲区；</span></span><br><span class="line"><span class="string">- elemsize：channel 元素类型的大小；</span></span><br><span class="line"><span class="string">- closed：标识 channel 是否关闭；</span></span><br><span class="line"><span class="string">- elemtype：channel 元素类型；</span></span><br><span class="line"><span class="string">- sendx：发送元素进入环形缓冲区的 index；</span></span><br><span class="line"><span class="string">- recvx：接收元素所处的环形缓冲区的 index；</span></span><br><span class="line"><span class="string">- recvq：因接收而陷入阻塞的协程队列；</span></span><br><span class="line"><span class="string">- sendq：因发送而陷入阻塞的协程队列；</span></span><br><span class="line"><span class="string">- waitq：阻塞的协程队列</span></span><br><span class="line"><span class="string">- first：队列头部</span></span><br><span class="line"><span class="string">- last：队列尾部</span></span><br><span class="line"><span class="string">- sudog：用于包装协程的节点</span></span><br><span class="line"><span class="string">- g：goroutine，协程；</span></span><br><span class="line"><span class="string">- next：队列中的下一个节点；</span></span><br><span class="line"><span class="string">- prev：队列中的前一个节点；</span></span><br><span class="line"><span class="string">- elem: 读取/写入 channel 的数据的容器;</span></span><br><span class="line"><span class="string">- isSelect：标识当前协程是否处在 select 多路复用的流程中；</span></span><br><span class="line"><span class="string">- c：标识与当前 sudog 交互的 chan.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### 3.2 构造器函数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">在源码中通道的创建由 makechan 方法实现：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span><span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;&#125;</span><br></pre></td></tr></table></figure><p>然后还有两个包装方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname reflect_makechan reflect.makechan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line"><span class="keyword">return</span> makechan(t, size)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan64</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="type">int64</span>(<span class="type">int</span>(size)) != size &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> makechan(t, <span class="type">int</span>(size))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部都是调用的 makechan 方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">elem := t.elem</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译器检查 typesize 和 align</span></span><br><span class="line"><span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算存放数据元素的内存大小以及是否溢出</span></span><br><span class="line">mem, overflow := math.MulUintptr(elem.size, <span class="type">uintptr</span>(size))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c *hchan</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> mem == <span class="number">0</span>:</span><br><span class="line">c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">c.buf = c.raceaddr()</span><br><span class="line"><span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>:</span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>))</span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">c = <span class="built_in">new</span>(hchan)</span><br><span class="line">c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line">c.elemsize = <span class="type">uint16</span>(elem.size)</span><br><span class="line">c.elemtype = elem</span><br><span class="line">c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line">lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>具体流程如下：</p><ul><li>判断申请内存空间大小是否越界，mem 大小为 element 类型大小与 element 个数相乘后得到，仅当无缓冲型 channel 时，因个数为 0 导致大小为 0；</li><li>根据类型，初始 channel，分为 无缓冲型、有缓冲元素为 struct 型、有缓冲元素为 pointer 型 channel;</li><li>倘若为无缓冲型，则仅申请一个大小为默认值 96 的空间；</li><li>如若有缓冲的 struct 型，则一次性分配好 96 + mem 大小的空间，并且调整 chan 的 buf 指向 mem 的起始位置；</li><li>倘若为有缓冲的 pointer 型，则分别申请 chan 和 buf 的空间，两者无需连续；</li><li>对 channel 的其余字段进行初始化，包括元素类型大小、元素类型、容量以及锁的初始化.</li></ul><h3 id="3-2-写流程"><a href="#3-2-写流程" class="headerlink" title="3.2 写流程"></a>3.2 写流程</h3><p>发送数据到channel时：</p><ul><li>先判断是否有等待接收数据的 groutine，如果有，直接将数据发给 groutine，唤醒 groutine，就不放入队列中了。省去了两次内存拷贝和加锁的开销</li><li>另外一种情况：队列如果满了，那就只能放到队列中等待，直到有数据被取走才能发送。<h4 id="3-2-1-调用链"><a href="#3-2-1-调用链" class="headerlink" title="3.2.1 调用链"></a>3.2.1 调用链</h4></li></ul><p>chan 的发送逻辑涉及到5个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendDirect</span><span class="params">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;…&#125;</span><br></pre></td></tr></table></figure><p>chansend1 方法是 go编译代码中<code>c &lt;- x</code>这种写法的入口点，即当我们编写代码<code>c &lt;- x</code>其实就是调用此方法。<br>这四个方法的调用关系：<code>chansend1 -&gt; chansend -&gt; send -&gt; sendDirect</code><br>具体发送逻辑在<code>chansend</code>这个方法里，然后真正使用的方法其实是对该方法的一层包装。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">chansend(c, elem, <span class="literal">true</span>, getcallerpc())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbsend</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> chansend(c, elem, <span class="literal">false</span>, getcallerpc())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-chansend"><a href="#3-2-2-chansend" class="headerlink" title="3.2.2 chansend"></a>3.2.2 chansend</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 判断 channel 是否为 nil</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !block &#123;<span class="comment">// 如果非阻塞，直接返回 false</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 当向 nil channel 发送数据时，会调用 gopark</span></span><br><span class="line"><span class="comment">// 而 gopark 会将当前的 goroutine 休眠，并用过第一个参数的 unlockf 来回调唤醒</span></span><br><span class="line"><span class="comment">// 但此处传递的参数为 nil，因此向 channel 发送数据的 goroutine 和接收数据的 goroutine 都会阻塞，进而死锁</span></span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racereadpc(c.raceaddr(), callerpc, funcPC(chansend))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于不阻塞的 send，快速检测失败场景</span></span><br><span class="line"><span class="comment">// 如果 channel 未关闭且 channel 没有多余的缓冲空间。这可能是：</span></span><br><span class="line"><span class="comment">// 1. channel 是非缓冲型的，且等待接收队列里没有 goroutine</span></span><br><span class="line"><span class="comment">// 2. channel 是缓冲型的，但循环数组已经装满了元素</span></span><br><span class="line"><span class="comment">// 主要用于 select 语句中，涉及到指令重排队+可观测性</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; full(c) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加锁,避免竞争</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"><span class="comment">// 检查 channel 是否已关闭，不允许向关闭的 channel 发送数据</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>)) <span class="comment">// 直接panic</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从 recvq 队首取出一个接收者，如果存在接收者，就绕过环形队列（buf）直接把 ep 拷贝给 sg，并释放锁</span></span><br><span class="line">    <span class="comment">// 这就是前面提到的，官方做的一个优化，如果有goroutine在等待就直接把数据给该goroutine，没必要在写到buf，然后接收者又从buf中拷贝出来</span></span><br><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 到这里说明当前没有等待状态的接收者</span></span><br><span class="line"><span class="comment">// 如果环形队列还未满</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line">        <span class="comment">// 拿到 sendx 索引的位置</span></span><br><span class="line">qp := chanbuf(c, c.sendx)</span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">racenotify(c, c.sendx, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 直接把数据从 qp 拷贝到 qp，就是把数据拷贝到环形队列中</span></span><br><span class="line">typedmemmove(c.elemtype, qp, ep)</span><br><span class="line">        <span class="comment">// 维护 snedx 的值，因为是环形队列，所以到最大值时就重置为0</span></span><br><span class="line">c.sendx++</span><br><span class="line"><span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">c.sendx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//qcount即当前chan中的元素个数</span></span><br><span class="line">c.qcount++</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 到这里说明环形队列已经满了</span></span><br><span class="line"><span class="comment">// 如果还是要非阻塞的方式发送，就只能返回错误了</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 到这里说明缓存队列满了，然后调用法指定是阻塞方式进行发送</span></span><br><span class="line"><span class="comment">// channel 满了，发送方会被阻塞。接下来会构造一个 sudog</span></span><br><span class="line">gp := getg()<span class="comment">// 获取当前 goroutine</span></span><br><span class="line">mysg := acquireSudog()<span class="comment">// 从对象池获取 sudog</span></span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 把发送的数据(ep)、当前g(gp)、已经当前这个chan(c)都存到sudog中</span></span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">    <span class="comment">// 保存当前 sudog，下面要用到做校验</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">     <span class="comment">// 把这个sudog存入sendq队列</span></span><br><span class="line">c.sendq.enqueue(mysg)</span><br><span class="line">atomic.Store8(&amp;gp.parkingOnChan, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 调用gopark，挂起当前的 g，将当前的 g 移出调度器的队列</span></span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 等到有接收者从chan中取值的时候，这个发送的g又会被重新调度，然后从这里开始继续执行</span></span><br><span class="line">KeepAlive(ep)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检验是否为当前的 sudog</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">gp.activeStackChans = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// 这里sudog中的success表示的是当前这个通道上是否进行过通信</span></span><br><span class="line">    <span class="comment">// 为 true 则说明是真正的唤醒，chan上有活动（有数据写进来，或者有数据被读取出去）</span></span><br><span class="line">    <span class="comment">// 为 false 则说明是假的唤醒，即当前唤醒是否关闭chan导致的</span></span><br><span class="line">    <span class="comment">// 这里主要根据这个值判断chan是否被关闭了</span></span><br><span class="line">closed := !mysg.success</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 将 sudog 放回对象池</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">if</span> closed &#123;</span><br><span class="line">        <span class="comment">// 如果chan被关闭了也是直接panic</span></span><br><span class="line"><span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;chansend: spurious wakeup&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心逻辑</p><ul><li>如果recvq不为空，从recvq中取出一个等待接收数据的Groutine，直接将数据发送给该Groutine</li><li>如果recvq为空，才将数据放入buf中</li><li>如果buf已满，则将要发送的数据和当前的Groutine打包成Sudog对象放入sendq，并将groutine置为等待状态</li><li>等goroutine再次被调度时程序继续执行</li></ul><h4 id="3-2-3-send"><a href="#3-2-3-send" class="headerlink" title="3.2.3 send"></a>3.2.3 send</h4><p>然后追踪一下 send 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 忽略 race 检查..</span></span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 直接拷贝到接受者内存，使用写屏障</span></span><br><span class="line">sendDirect(c.elemtype, sg, ep)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g <span class="comment">// 取出sudog中记录的g，这里的g就是被阻塞接收者</span></span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg) <span class="comment">// 更新接收者g的param字段，在recv方法中会用到</span></span><br><span class="line">sg.success = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 最后把被阻塞的接收者g唤醒</span></span><br><span class="line">goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-4-sendDirect"><a href="#3-2-4-sendDirect" class="headerlink" title="3.2.4 sendDirect"></a>3.2.4 sendDirect</h4><p>继续看sendDirect 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendDirect</span><span class="params">(t *_type, sg *sudog, src unsafe.Pointer)</span></span> &#123;</span><br><span class="line"><span class="comment">// src 在当前 goroutine 的栈上，dst 是另一个 goroutine 的栈</span></span><br><span class="line">    <span class="comment">// 直接进行内存&quot;搬迁&quot;</span></span><br><span class="line"><span class="comment">// 如果目标地址的栈发生了栈收缩，当我们读出了 sg.elem 后</span></span><br><span class="line"><span class="comment">// 就不能修改真正的 dst 位置的值了</span></span><br><span class="line"><span class="comment">// 因此需要在读和写之前加上一个屏障</span></span><br><span class="line">dst := sg.elem</span><br><span class="line">typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.size)</span><br><span class="line"> <span class="comment">// 拷贝内存</span></span><br><span class="line">memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到一个 goroutine 直接写另一个 goroutine 栈的操作，一般而言，不同 goroutine 的栈是各自独有的。而这也违反了 GC 的一些假设。为了不出问题，写的过程中增加了写屏障，保证正确地完成写操作。这样做的好处是减少了一次内存 copy：不用先拷贝到 channel 的 buf，直接由发送者到接收者。</p><h3 id="3-3-读流程"><a href="#3-3-读流程" class="headerlink" title="3.3 读流程"></a>3.3 读流程</h3><p>从channel读取数据的流程和发送的类似，基本是发送操作的逆操作。<br>这里同样存在和send一样的优化：从channel读取数据时，不是直接去环形队列中去数据，而是先判断是否有等待发送数据的groutine。如果有，直接将groutine出队列，取出数据返回，并唤醒groutine。如果没有等待发送数据的groutine，再从环形队列中取数据。</p><h4 id="3-3-1-调用链"><a href="#3-3-1-调用链" class="headerlink" title="3.3.1 调用链"></a>3.3.1 调用链</h4><p>chan的接收涉及到7个方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_chanrecv</span><span class="params">(c *hchan, nb <span class="type">bool</span>, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>, received <span class="type">bool</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span></span> (selected, received <span class="type">bool</span>) &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;…&#125;，</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;…&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvDirect</span><span class="params">(t *_type, sg *sudog, dst unsafe.Pointer)</span></span> &#123;…&#125;</span><br></pre></td></tr></table></figure><p>按照发送时的套路可知，只有 chanrecv 是具体逻辑，上面几个都是包装方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname reflect_chanrecv reflect.chanrecv</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_chanrecv</span><span class="params">(c *hchan, nb <span class="type">bool</span>, elem unsafe.Pointer)</span></span> (selected <span class="type">bool</span>, received <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> chanrecv(c, elem, !nb)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selectnbrecv</span><span class="params">(elem unsafe.Pointer, c *hchan)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> chanrecv(c, elem, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:nosplit</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv2</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> (received <span class="type">bool</span>) &#123;</span><br><span class="line">_, received = chanrecv(c, elem, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收操作有两种写法，一种带 “ok”，反应 channel 是否关闭；</p><p>一种不带 “ok”，这种写法，当接收到相应类型的零值时无法知道是真实的发送者发送过来的值，还是 channel 被关闭后，返回给接收者的默认类型的零值。</p><p>两种写法，都有各自的应用场景。</p><p>经过编译器的处理后，这两种写法最后对应源码里的就是不带<code>ok</code>的<code>chanrecv1</code>和带<code>ok</code>的<code>chanrecv2</code>这两个函数。</p><h4 id="3-3-2-chanrecv"><a href="#3-3-2-chanrecv" class="headerlink" title="3.3.2 chanrecv"></a>3.3.2 chanrecv</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// chanrecv 函数接收 channel c 的元素并将其写入 ep 所指向的内存地址。</span></span><br><span class="line"><span class="comment">// 如果 ep 是 nil，说明忽略了接收值。比如 &lt;-ch 这样，没有接收取到的值</span></span><br><span class="line"><span class="comment">// 如果 block == false，即非阻塞型接收，在没有数据可接收的情况下，返回 (false, false)</span></span><br><span class="line"><span class="comment">// 否则，如果 c 处于关闭状态，将 ep 指向的地址清零，返回 (true, false)</span></span><br><span class="line"><span class="comment">// 否则，用返回值填充 ep 指向的内存地址。返回 (true, true)</span></span><br><span class="line"><span class="comment">// 如果 ep 非空，则应该指向堆或者函数调用者的栈</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="comment">// 如果是一个 nil 的 channel</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不阻塞，直接返回 (false, false)</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 否则，接收一个 nil 的 channel，调用gopark将goroutine 挂起</span></span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>) <span class="comment">// 被挂起之后不会执行到这一句</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这块主要用在 select 语句中，先大概了解下，比较难懂。。。</span></span><br><span class="line"><span class="comment">// 快速路径: 在不需要锁的情况下检查失败的非阻塞操作</span></span><br><span class="line"><span class="comment">// 注意到 channel 不能由已关闭转换为未关闭，则失败的条件是：</span></span><br><span class="line"><span class="comment">// 1. channel 是非缓冲型的，recvq 队列为空</span></span><br><span class="line"><span class="comment">// 2. channel 是缓冲型的，buf 为空</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; empty(c) &#123;</span><br><span class="line"><span class="comment">// 此处的 c.closed 必须在条件判断之后进行验证，</span></span><br><span class="line">        <span class="comment">// 因为指令重排后，如果先判断 c.closed，得出 channel 未关闭，无法判断失败条件中channel 是已关闭还是未关闭（从而需要 atomic 操作）</span></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 再次检查 channel 是否为空</span></span><br><span class="line"><span class="keyword">if</span> empty(c) &#123;</span><br><span class="line"><span class="comment">// 接收者不为 nil 时返回该类型的零值</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// typedmemclr 逻辑是根据类型清理相应地址的内存</span></span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">// 返回（true,fasle）</span></span><br><span class="line">            <span class="comment">// 返回值1--true：表示被 select case 选中，</span></span><br><span class="line">            <span class="comment">// 返回值2--fasle 表示是否正常收到数据</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t0 <span class="type">int64</span></span><br><span class="line"><span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">t0 = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 加锁，保证并发安全</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"><span class="comment">// channel 已关闭，并且循环数组 buf 里没有元素</span></span><br><span class="line"><span class="comment">// 这里可以处理非缓冲型关闭 和 缓冲型关闭但 buf 无元素的情况</span></span><br><span class="line"><span class="comment">// 也就是说即使是关闭状态，但在缓冲型的 channel，</span></span><br><span class="line"><span class="comment">// buf 里有元素的情况下还能接收到元素</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待发送队列里有 goroutine 存在，说明 buf 是满的</span></span><br><span class="line"><span class="comment">// 这有可能是：</span></span><br><span class="line"><span class="comment">// 1. 非缓冲型的 channel</span></span><br><span class="line"><span class="comment">// 2. 缓冲型的 channel，但 buf 满了</span></span><br><span class="line"><span class="comment">// 针对 1，直接进行内存拷贝（从 sender goroutine -&gt; receiver goroutine）</span></span><br><span class="line"><span class="comment">// 针对 2，接收到循环数组头部的元素，并将发送者的元素放到循环数组尾部</span></span><br><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// chan的buf 里有元素，可以正常接收</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 直接从循环数组里找到要接收的元素</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line">        <span class="comment">// ep != nil表示代码里，没有忽略要接收的值</span></span><br><span class="line">        <span class="comment">// 即接收的代码不是 &quot;&lt;- ch&quot;，而是 &quot;val &lt;- ch&quot;这种，ep 指向 val</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 清理掉循环数组里相应位置的值</span></span><br><span class="line">typedmemclr(c.elemtype, qp)</span><br><span class="line">        <span class="comment">// 维护接收游标</span></span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// buf 数组里的元素个数减 1</span></span><br><span class="line">c.qcount--</span><br><span class="line">        <span class="comment">// 处理完成，解锁返回</span></span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 到这里说明chan的buf里没有数据了，如果是非阻塞接收就直接返回了</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接下来就是要被阻塞的情况了</span></span><br><span class="line">    <span class="comment">// 和发送类似的，构造一个 sudog</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 这里需要注意一下，ep就是我们用来接收值得对象</span></span><br><span class="line">    <span class="comment">// 这里把ep直接存到sudog.elem字段上</span></span><br><span class="line">mysg.elem = ep </span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg <span class="comment">// 这个waiting同样是用来唤醒后做校验的</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 加入到chan的recvq队列里</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line">atomic.Store8(&amp;gp.parkingOnChan, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 将当前 goroutine 挂起</span></span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒后，继续往下执行</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同样是进行数据校验</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">gp.activeStackChans = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 又是mysg.success，如果chan活动过就是true，否则是false</span></span><br><span class="line">success := mysg.success</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)<span class="comment">// 将 sudog 放回对象池</span></span><br><span class="line">    <span class="comment">// 到这里如果goroutine被正常唤醒肯定是可以取到数据的</span></span><br><span class="line">    <span class="comment">// 因为recvq的数据是由发送的时候直接copy过来了</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, success</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-3-3-recv"><a href="#3-3-3-recv" class="headerlink" title="3.3.3 recv"></a>3.3.3 recv</h4><p>继续追踪一下 recv 方法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 非缓冲型的 channel</span></span><br><span class="line"><span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 并且需要接收值</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// 直接进行内存拷贝</span></span><br><span class="line">recvDirect(c.elemtype, sg, ep)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 需要注意：进入recv方法说明sendq队列里是有值的</span></span><br><span class="line"><span class="comment">// 那么对缓冲型的 channel来说，sendq有值就意味着buf满了</span></span><br><span class="line">        <span class="comment">// 也就是 recvx和sendx重合了都</span></span><br><span class="line">        <span class="comment">// 这里要做的就是先从buf中读一个数据出来，然后再把发送者发送的数据写入buf</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"><span class="comment">// 将接收游标处的数据拷贝给接收者</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从发送者把数据写入 recvx</span></span><br><span class="line">typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">        <span class="comment">// 然后修改 recvx和sendx 的位置</span></span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">gp := sg.g</span><br><span class="line">    <span class="comment">// 解锁</span></span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 最后唤醒发送的 goroutine</span></span><br><span class="line">goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-4-recvDirect"><a href="#3-3-4-recvDirect" class="headerlink" title="3.3.4 recvDirect"></a>3.3.4 recvDirect</h4><p>再看一下 recvDirect：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvDirect</span><span class="params">(t *_type, sg *sudog, dst unsafe.Pointer)</span></span> &#123;</span><br><span class="line"><span class="comment">// 如果是非缓冲型的，就直接从发送者的栈拷贝到接收者的栈。</span></span><br><span class="line">    <span class="comment">// 和sendDirect一样的需要加内存屏障</span></span><br><span class="line">src := sg.elem</span><br><span class="line">typeBitsBulkBarrier(t, <span class="type">uintptr</span>(dst), <span class="type">uintptr</span>(src), t.size)</span><br><span class="line">memmove(dst, src, t.size)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-5-小结"><a href="#3-3-5-小结" class="headerlink" title="3.3.5 小结"></a>3.3.5 小结</h4><ul><li>不管是接收还是发送只要被阻塞了，加入到了 sendq 或者 recvq 之后，那么后续的发送或者接收都是由对方进行处理了。</li><li>比如接收被阻塞了，当前 g 构成一个 sudog 然后加入到 recvq ，接着调用了 gopark 就已经阻塞,只能等到有发送者来的时候直接从 recvq 里把这个 sudog 取出来，并且直接把要他发送的值拷贝到这个 sudog.elem 字段上，也就是调用chan接收方法是传进来的哪个值.</li><li>最后发送方再调用 goready 把这个 g 给唤醒，这样再把剩下的逻辑走完，这个被阻塞了一会的接收者就可以拿着数据返回了。</li></ul><p>核心逻辑：</p><ul><li>如果有等待发送数据的 groutine，从 sendq 中取出一个等待发送数据的 groutine，取出数据</li><li>如果没有等待的 groutine，且环形队列中有数据，从队列中取出数据</li><li>如果没有等待的 groutine，且环形队列中也没有数据，则阻塞该 Groutine，并将 groutine 打包为 sudog 加入到 recevq 等待队列中</li></ul><h3 id="3-4-关闭"><a href="#3-4-关闭" class="headerlink" title="3.4 关闭"></a>3.4 关闭</h3><h4 id="3-4-1-调用链"><a href="#3-4-1-调用链" class="headerlink" title="3.4.1 调用链"></a>3.4.1 调用链</h4><p>close 就比较简单了，相关方法就两个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname reflect_chanclose reflect.chanclose</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reflect_chanclose</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">closechan(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>其中一个还是包装方法，真正逻辑就在 clsoechan 里。</p><blockquote><p>每个逻辑都有一个 reflect_xxx 的方法，根据名字猜测是反射的时候用的。</p></blockquote><h4 id="3-4-2-closechan"><a href="#3-4-2-closechan" class="headerlink" title="3.4.2 closechan"></a>3.4.2 closechan</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 关闭一个nil的chan直接panic</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 同样是先加锁</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line">    <span class="comment">// 判断一下是否被关闭过了，关闭一个已经关闭的chan也是直接panic</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 修改closed标记为，表示chan已经被关闭了</span></span><br><span class="line">c.closed = <span class="number">1</span></span><br><span class="line"><span class="comment">// gList 是通过 g.schedlink 链接 G 的列表，一个 G 只能是一次在一个 gQueue 或 gList 上</span></span><br><span class="line"><span class="comment">// gList 模拟的是栈操作（FILO）</span></span><br><span class="line"><span class="comment">// gQueue 模拟的是队列操作（FIFO）</span></span><br><span class="line"><span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放所有的接收者</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.recvq.dequeue()</span><br><span class="line">        <span class="comment">// sg == nil，表示接收队列已为空，跳出循环</span></span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 如果 elem 不为空说明未忽略接收值，赋值为该类型的零值</span></span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放所有的发送者</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.sendq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line">sg.success = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环读取 glist 里面的数据，挨个唤醒</span></span><br><span class="line"><span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">gp := glist.pop()</span><br><span class="line">gp.schedlink = <span class="number">0</span></span><br><span class="line">goready(gp, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>核心流程：</p><ul><li>设置关闭状态</li><li>唤醒所有等待读取chanel的协程</li><li>所有等待写入channel的协程，抛出异常</li></ul><h4 id="3-4-3-优雅关闭"><a href="#3-4-3-优雅关闭" class="headerlink" title="3.4.3 优雅关闭"></a>3.4.3 优雅关闭</h4><ul><li>只在发送端关闭 channel。（防止关闭后继续发送）</li><li>存在多个发送者时不要关闭发送者 channel，而是使用专门的 stop channel。 sync.Once，来保证关闭channel的操作只执行一次</li><li>作为函数参数的channel最好带方向</li></ul><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h2><h3 id="4-1-存储实现"><a href="#4-1-存储实现" class="headerlink" title="4.1 存储实现"></a>4.1 存储实现</h3><p>chan 内部使用一个环形队列实现存储，使用 sendx或recvx进行发送或读取。</p><h3 id="4-2-并发安全"><a href="#4-2-并发安全" class="headerlink" title="4.2 并发安全"></a>4.2 并发安全</h3><p>使用 mutex 保证并发安全。</p><h3 id="4-3-调度"><a href="#4-3-调度" class="headerlink" title="4.3 调度"></a>4.3 调度</h3><p>使用 sendq 和 recvq来暂存由于发送或接收而被阻塞的goroutine。<br>send/recv的时候都会判断recvq/sendq是否有goroutine正在等待，有则优先处理。</p><h4 id="4-3-1-发送"><a href="#4-3-1-发送" class="headerlink" title="4.3.1 发送"></a>4.3.1 发送</h4><p><strong>发送</strong>的时候发现recvq有goroutine正在等待，说明此时chan的buf是空的，或者chan是个非缓存chan，根本没有buf。<br>对于发送来说，不管是buf为空还是chan没有buf都是一样的处理逻辑。<br>此时会直接从recvq中取出第一个g，然后把本次要发送的数据直接写给这个接收者g，并调用goready把这个g唤醒。</p><h4 id="4-3-2-接收"><a href="#4-3-2-接收" class="headerlink" title="4.3.2 接收"></a>4.3.2 接收</h4><p>如果接收的时候发现sendq有goroutine正在等待，说明buf满了，或者chan是个非缓存chan，根本没有buf。<br>对于接收来说buf满了或者chan没有buf二者的处理逻辑就不太一样了。</p><blockquote><p>因为需要保证顺序,buf满了就不能直接去读sender的数据了，只能从buf中去。</p></blockquote><p>如果是buf满了：那么会先从buf中读一个值出来(腾一个位置出来)，然后把sender发送的值写入buf，并唤醒这个sender g。<br>如果是没有buf的无缓存chan：那就直接把sender要发送的数据取出来，作为本次取到的数据，然后唤醒sender g。</p><h3 id="4-4-读写特点"><a href="#4-4-读写特点" class="headerlink" title="4.4 读写特点"></a>4.4 读写特点</h3><p>空读写阻塞，写关闭异常，读关闭空零</p><ul><li>读写值 nil 管道会永久阻塞</li><li>关闭的管道读数据仍然可以读数据</li><li>往关闭的管道写数据会 panic</li><li>关闭为 nil 的管道 panic</li><li>关闭已经关闭的管道 panic<h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2></li></ul><p><a href="https://about.sourcegraph.com/go/understanding-channels-kavya-joshi/">understanding-channels-kavya-joshi</a><br><a href="https://juejin.cn/post/6875325172249788429">图解Golang channel源码</a><br><a href="https://github.com/talkgo/night/issues/450">Go夜读-第 56 期 channel &amp; select 源码分析</a><br><a href="https://maratrix.cn/post/2020/08/25/go-channel-source-read/">Go源码阅读 | channel 设计与实现</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] sync.Cond</title>
      <link href="/2022/07/14/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.Cond/"/>
      <url>/2022/07/14/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.Cond/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>Golang 的 sync 包中的 Cond 实现了一种条件变量，可以使用在<strong>多个Reader</strong>等待共享资源 ready 的场景（如果只有一读一写，一个锁或者channel就搞定了）。<br>Cond的汇合点：多个goroutines等待、1个goroutine通知事件发生。<br>比较适合任务调用场景，一个 Master goroutine 通知事件发生，多个 Worker goroutine 在资源没准备好的时候就挂起，等待通知。<br><strong>使用方法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Cond</span></span><br><span class="line">cond := sync.NewCond(<span class="built_in">new</span>(sync.Mutex))</span><br><span class="line"><span class="comment">// 挂起goroutine</span></span><br><span class="line">cond.L.Lock()</span><br><span class="line">cond.Wait()</span><br><span class="line"><span class="comment">// 唤醒一个</span></span><br><span class="line">cond.Signal()</span><br><span class="line"><span class="comment">// 唤醒所有</span></span><br><span class="line">cond.Broadcast()</span><br></pre></td></tr></table></figure><blockquote><p>基本使用大概是需要等待的时候通过 Wait() 将 Goroutine 挂起，资源准备好的时候再通过 Signal() 或者 Broadcast() 将挂起中的 Goroutine 唤醒。</p></blockquote><p>一个简单的 Demo<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">locker sync.Mutex</span><br><span class="line">cond   = sync.NewCond(&amp;locker)</span><br><span class="line">wg     sync.WaitGroup</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">wg.Add(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(number <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// wait()方法内部是先释放锁 然后在加锁 所以这里需要先 Lock()</span></span><br><span class="line">cond.L.Lock()</span><br><span class="line"><span class="keyword">defer</span> cond.L.Unlock()</span><br><span class="line">cond.Wait() <span class="comment">// 等待通知,阻塞当前 goroutine</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;g %v ok~ \n&quot;</span>, number)</span><br><span class="line">wg.Done()</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line"><span class="comment">// 每过 50毫秒 唤醒一个 goroutine</span></span><br><span class="line">cond.Signal()</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line">&#125;</span><br><span class="line">time.Sleep(time.Millisecond * <span class="number">50</span>)</span><br><span class="line"><span class="comment">// 剩下5个 goroutine 一起唤醒</span></span><br><span class="line">cond.Broadcast()</span><br><span class="line">fmt.Println(<span class="string">&quot;Broadcast...&quot;</span>)</span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><blockquote><p>go version 1.14.7</p></blockquote><h3 id="2-1-Cond"><a href="#2-1-Cond" class="headerlink" title="2.1 Cond"></a>2.1 Cond</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 21</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Cond <span class="keyword">struct</span> &#123;</span><br><span class="line">    noCopy noCopy</span><br><span class="line">    L Locker</span><br><span class="line">    notify  notifyList</span><br><span class="line">    checker copyChecker</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewCond() 返回指针，保证多 goroutine 获取到的是同一个实例。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCond</span><span class="params">(l Locker)</span></span> *Cond &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;Cond&#123;L: l&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>noCopy</strong>：noCopy对象，实现了<code>sync.Locker</code>接口，使得内嵌 noCopy 的对象在进行 go vet 静态检查的时候，可以检查出是否被复制。</p><blockquote><p>noCopy 具体见 <a href="https://github.com/golang/go/issues/8005">Go issues 8005</a></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 94</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> noCopy <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*noCopy)</span></span> Lock()   &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*noCopy)</span></span> Unlock() &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>L</strong>：实现了 <code>sync.Locker</code> 接口的锁对象，通常使用 Mutex 或 RWMutex 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： mutex.go</span></span><br><span class="line"><span class="comment">line: 31</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> Locker <span class="keyword">interface</span> &#123;</span><br><span class="line">     Lock()</span><br><span class="line">     Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>notify</strong>：notifyList 对象，维护等待唤醒的 goroutine 队列,使用链表实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： runtime.go</span></span><br><span class="line"><span class="comment">line: 33    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">type</span> notifyList <span class="keyword">struct</span> &#123;</span><br><span class="line">wait   <span class="type">uint32</span></span><br><span class="line">notify <span class="type">uint32</span></span><br><span class="line">lock   <span class="type">uintptr</span></span><br><span class="line">head   unsafe.Pointer</span><br><span class="line">tail   unsafe.Pointer</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>checker</strong>：copyChecker 对象，实际上是 uintptr 对象，保存自身对象地址。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 79    </span></span><br><span class="line"><span class="comment">*/</span>    </span><br><span class="line"><span class="keyword">type</span> copyChecker <span class="type">uintptr</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *copyChecker)</span></span> check() &#123;</span><br><span class="line">     <span class="keyword">if</span> <span class="type">uintptr</span>(*c) != <span class="type">uintptr</span>(unsafe.Pointer(c)) &amp;&amp;</span><br><span class="line">            !atomic.CompareAndSwapUintptr((*<span class="type">uintptr</span>)(c), <span class="number">0</span>, <span class="type">uintptr</span>(unsafe.Pointer(c))) &amp;&amp;</span><br><span class="line">            <span class="type">uintptr</span>(*c) != <span class="type">uintptr</span>(unsafe.Pointer(c)) &#123;</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;sync.Cond is copied&quot;</span>)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>1）检查当前 checker 对象的地址是否等于保存在 checker 中的地址</p><ul><li>由于第一次比较的时候 checker 中没有存地址所以第一次比较肯定是不相等的，于是有了后续 2 3步。</li></ul></li><li><p>2）对 checker 进行 CAS 操作，如果 checker 中存储的地址值为空（就是0）就把当前 checker 对象的地址值存进去</p></li><li>3）第三步和第一步一样，再比较一下。<ul><li>主要是防止在第一步比较发现不相等之后，第二步 CAS 之前，其他 goroutine 也在执行这个方法，并发的将 checker 赋值了，导致这里判定的时候第二步 CAS 失败，返回 false，然后错误的抛出一个 panic，所以执行第三步在比较一下是否相等。如果其他 goroutine 抢先执行 CAS 修改了 checker 中的值导致这里第二步也返回 false 的话，第三步的判定也会是相等的，不会抛出 panic</li></ul></li><li>4）如果 3 个条件都成立，那 checker 肯定是被复制了，就是由于 cond 被复制引起的。</li></ul><blockquote><p>check 方法在第一次调用的时候，会将 checker 对象地址赋值给 checker，也就是将自身内存地址赋值给自身。<br>再次调用 checker 方法的时候，会将当前 checker 对象地址值与 checker 中保存的地址值（原始地址）进行比较，若不相同则表示当前 checker 的地址不是第一次调用 check 方法时候的地址，即 cond 对象被复制了，导致checker 被重新分配了内存地址。</p></blockquote><h3 id="2-2-Wait"><a href="#2-2-Wait" class="headerlink" title="2.2 Wait"></a>2.2 Wait</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 52    </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Wait() &#123;</span><br><span class="line">    <span class="comment">// 1.每次操作之前都要检测一下 cond 是否被复制了。</span></span><br><span class="line">    c.checker.check() </span><br><span class="line">    <span class="comment">// 2.将 notifyList 中的 wait 值加1并返回之前的值</span></span><br><span class="line">    t := runtime_notifyListAdd(&amp;c.notify) </span><br><span class="line">    <span class="comment">// 3.释放锁，因此在调用Wait方法前，必须保证获取到了cond的锁，否则会报错</span></span><br><span class="line">    c.L.Unlock()</span><br><span class="line">    <span class="comment">// 4.将当前goroutine挂起，等待唤醒信号</span></span><br><span class="line">    runtime_notifyListWait(&amp;c.notify, t) </span><br><span class="line">    <span class="comment">// 5.gorountine被唤醒，重新获取锁</span></span><br><span class="line">    c.L.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二步代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> package: runtime</span></span><br><span class="line"><span class="comment"> file： sema.go</span></span><br><span class="line"><span class="comment"> line: 479  </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListAdd</span><span class="params">(l *notifyList)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> atomic.Xadd(&amp;l.wait, <span class="number">1</span>) - <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第四步代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: runtime</span></span><br><span class="line"><span class="comment">file： sema.go</span></span><br><span class="line"><span class="comment">line: 488  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 获取当前 goroutine 添加到链表末端，然后 goparkunlock 函数休眠阻塞当前 goroutine</span></span><br><span class="line"><span class="comment">// goparkunlock 函数会让出当前处理器的使用权并等待调度器的唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListWait</span><span class="params">(l *notifyList, t <span class="type">uint32</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.锁住 notify 队列</span></span><br><span class="line">    lock(&amp;l.lock)</span><br><span class="line">    <span class="comment">// 2.判断传入的等待序号t是否小于当前已经唤醒的序号notify</span></span><br><span class="line">    <span class="comment">// 如果是则说明当前 goroutine 不需要阻塞了 直接解锁并返回</span></span><br><span class="line">    <span class="comment">// 有可能执行这步之前 goroutine 就已经被唤醒了</span></span><br><span class="line">    <span class="keyword">if</span> less(t, l.notify) &#123;</span><br><span class="line">        unlock(&amp;l.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.获取当前 goroutine，设置相关参数，将当前等待数赋值给 ticket</span></span><br><span class="line">    s := acquireSudog()</span><br><span class="line">    s.g = getg()</span><br><span class="line">    s.ticket = t</span><br><span class="line">    s.releasetime = <span class="number">0</span></span><br><span class="line">    t0 := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> blockprofilerate &gt; <span class="number">0</span> &#123;</span><br><span class="line">        t0 = cputicks()</span><br><span class="line">        s.releasetime = <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.将当前 goroutine 写入到链表尾部</span></span><br><span class="line">    <span class="keyword">if</span> l.tail == <span class="literal">nil</span> &#123;</span><br><span class="line">        l.head = s</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l.tail.next = s</span><br><span class="line">    &#125;</span><br><span class="line">    l.tail = s</span><br><span class="line">    <span class="comment">// 5. 调用 goparkunlock 函数将当前 goroutine 挂起，等待唤醒信号</span></span><br><span class="line">    goparkunlock(&amp;l.lock, <span class="string">&quot;semacquire&quot;</span>, traceEvGoBlockCond, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">        blockevent(s.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    releaseSudog(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-Signal"><a href="#2-3-Signal" class="headerlink" title="2.3 Signal"></a>2.3 Signal</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 64  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Signal() &#123;</span><br><span class="line">    <span class="comment">// 1.复制检查</span></span><br><span class="line">    c.checker.check() </span><br><span class="line">    <span class="comment">// 2.顺序唤醒一个等待的gorountine</span></span><br><span class="line">    runtime_notifyListNotifyOne(&amp;c.notify)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: runtime</span></span><br><span class="line"><span class="comment">file： sema.go</span></span><br><span class="line"><span class="comment">line: 554  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyOne</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 1.等待序号和唤醒序号相同则说明没有需要唤醒的 goroutine 直接返回</span></span><br><span class="line">   <span class="keyword">if</span> atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 2.锁住队列后再检查一遍等待序号和唤醒序号是否相同即判断有没有需要唤醒的 goroutine，没有则解锁后直接返回</span></span><br><span class="line">   lock(&amp;l.lock) </span><br><span class="line">   t := l.notify</span><br><span class="line">   <span class="keyword">if</span> t == atomic.Load(&amp;l.wait) &#123;</span><br><span class="line">        unlock(&amp;l.lock)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 3.到这里就说明有需要唤醒的 goroutine，于是先将 notify序号+1</span></span><br><span class="line">   atomic.Store(&amp;l.notify, t+<span class="number">1</span>)  </span><br><span class="line">   <span class="comment">// 4.然后就开始唤醒 goroutine 了</span></span><br><span class="line">   <span class="keyword">for</span> p, s := (*sudog)(<span class="literal">nil</span>), l.head; s != <span class="literal">nil</span>; p, s = s, s.next &#123;</span><br><span class="line">        <span class="comment">// 4.1 找到 ticket等于当前唤醒序号的 goroutine</span></span><br><span class="line">        <span class="keyword">if</span> s.ticket == t &#123;</span><br><span class="line">           <span class="comment">// 4.2 然后将其从等待唤醒链表中移除（因为这个 goroutine 马上就要被唤醒了）</span></span><br><span class="line">           n := s.next</span><br><span class="line">           <span class="keyword">if</span> p != <span class="literal">nil</span> &#123;</span><br><span class="line">               p.next = n</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               l.head = n</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span> n == <span class="literal">nil</span> &#123;</span><br><span class="line">               l.tail = p</span><br><span class="line">           &#125;</span><br><span class="line">           unlock(&amp;l.lock)</span><br><span class="line">           s.next = <span class="literal">nil</span></span><br><span class="line">           <span class="comment">// 4.3 然后唤醒这个 goroutine </span></span><br><span class="line">           readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">           <span class="keyword">return</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 4.4 最后解锁队列 </span></span><br><span class="line">   unlock(&amp;l.lock)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-Broadcast"><a href="#2-4-Broadcast" class="headerlink" title="2.4 Broadcast"></a>2.4 Broadcast</h3><p>唤醒链表中所有的阻塞中的goroutine，还是使用readyWithTime来实现这个功能</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: sync</span></span><br><span class="line"><span class="comment">file： cond.go</span></span><br><span class="line"><span class="comment">line: 73  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Cond)</span></span> Broadcast() &#123;</span><br><span class="line">    <span class="comment">// 1.复制检查</span></span><br><span class="line">    c.checker.check()</span><br><span class="line">    <span class="comment">// 2.唤醒所有在等待的 goroutine</span></span><br><span class="line">    runtime_notifyListNotifyAll(&amp;c.notify)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里和 <code>notifyListNotifyOne()</code>差不多，只是一次性唤醒所有 goroutine。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">package: runtime</span></span><br><span class="line"><span class="comment">file： sema.go</span></span><br><span class="line"><span class="comment">line: 522 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">notifyListNotifyAll</span><span class="params">(l *notifyList)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 1.等待序号和唤醒序号相同则说明没有需要唤醒的 goroutine 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> atomic.Load(&amp;l.wait) == atomic.Load(&amp;l.notify) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将链表头尾指针置为空（可以看做是清空整个等待队列）</span></span><br><span class="line">    <span class="comment">// 但是需要将当前的链表头保存下来，不然等会找不到链表中的数据了</span></span><br><span class="line">    lock(&amp;l.lock)</span><br><span class="line">    s := l.head</span><br><span class="line">    l.head = <span class="literal">nil</span></span><br><span class="line">    l.tail = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.直接将notify需要赋值成等待序号（这样表示当前没有需要唤醒的 goroutine 了）</span></span><br><span class="line">    <span class="comment">// 前面唤醒一个的时候这里是+1</span></span><br><span class="line">    atomic.Store(&amp;l.notify, atomic.Load(&amp;l.wait))</span><br><span class="line">    unlock(&amp;l.lock)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 4.最后 for 循环唤醒链表中所有等待状态的 goroutine</span></span><br><span class="line">    <span class="keyword">for</span> s != <span class="literal">nil</span> &#123;</span><br><span class="line">        next := s.next</span><br><span class="line">        s.next = <span class="literal">nil</span></span><br><span class="line">        readyWithTime(s, <span class="number">4</span>)</span><br><span class="line">        s = next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p><strong>基本使用</strong></p><ul><li>1）资源未准备好时，使用 Wait() 方法将 goroutine 挂起，由底层实现，会让出 CPU 时间片，从而避免使用无意义的循环浪费系统资源。</li><li>2）资源准备好时通过 Signal() 或者 Broadcast() 方法唤醒一个或多个被挂起的 goroutine。</li></ul><p><strong>等待唤醒流程</strong></p><ul><li>1）所有相关数据都是存在 notifyList 中的，包括 goroutine 和一些计数信息。</li><li>2）其中的 wait 和 notify 可以理解为等待序号和唤醒序号，都是自增值，wait 在有新 goroutine 等待时+1，notify 则在唤醒一个 goroutine 时+1。</li><li>3）等待状态的 goroutine 信息则存放在链表中，等待时加入链表尾部，唤醒时移除。</li><li>4）每个等待链表的 goroutine  都会将当前的 wait（等待序号）赋值给 ticket 字段，唤醒的时候会将 ticket=唤醒序号的 goroutine 唤醒。</li><li>5）当 wait==notify 时表示没有 goroutine 需要被唤醒，wait&gt;notify 时表示有 goroutine 需要被唤醒，wait 恒大于等于 notify。</li></ul><p><strong>noCopy</strong><br>Cond在内部持有一个等待队列 notifyList ，这个队列维护所有等待在这个 Cond 的 goroutine。如果 Cond 被复制则会导致其中的等待队列也被复制，最终可能会导致在唤醒 goroutine 的时候出现错误。<br>Kubernetes 的调度中也用到了 sync.Cond 有兴趣的可以研究一下。</p><blockquote><p><a href="https://mp.weixin.qq.com/s/rKLiazgWzneJfpfgHay8cA">https://mp.weixin.qq.com/s/rKLiazgWzneJfpfgHay8cA</a><br><a href="https://github.com/kubernetes/kubernetes/blob/0599ca2bcfcae7d702f95284f3c2e2c2978c7772/pkg/scheduler/internal/queue/scheduling_queue.go">https://github.com/kubernetes/kubernetes/blob/0599ca2bcfcae7d702f95284f3c2e2c2978c7772/pkg/scheduler/internal/queue/scheduling_queue.go</a></p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><code>https://ieevee.com/tech/2019/06/15/cond.html</code></p></blockquote><p><code>https://segmentfault.com/a/1190000019957459</code></p><p><code>https://www.jianshu.com/p/7b59d1d92a95</code></p><p><code>http://www.pydevops.com/2016/12/04/go-cond源码剖析-3/</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Context</title>
      <link href="/2022/07/10/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Context/"/>
      <url>/2022/07/10/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/Context/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Context 主要用于在异步场景中用于实现并发协调以及对 goroutine 的生命周期控制. 除此之外，context 还兼有一定的数据存储能力.</p></blockquote><span id="more"></span><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h2><h3 id="1-1-context-Context"><a href="#1-1-context-Context" class="headerlink" title="1.1 context.Context"></a>1.1 context.Context</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">    Deadline() (deadline time.Time, ok <span class="type">bool</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    Err() <span class="type">error</span></span><br><span class="line">    Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Context 包提供暴露 Context 接口; </li><li>可以在多个 Goroutine 共享数据，实现多 Goroutine 管理机制; </li><li>Context 是协程安全的；</li></ul><p>Context 接口定义了四个核心 api :</p><ul><li>Deadline 方法返回第一个参数是设置的截止时间，到时间Context会自动发起取消请求； 第二个参数是bool值，为false时表示没有设置截止时间，如果要取消需要调用取消函数;</li><li>Done 方法返回一个只读 Channel，类型为 struct{}, 这个 Channel 会在当前工作完成或者上下文被取消之后关闭， 多次调用 Done 方法会返回同一个 Channel；</li><li>Err 方法会返回当前 Context 结束的原因，它只会在 Done 返回的 Channel 被关闭时才会返回非空的值；<ul><li>如果当前 Context 被取消就会返回 Canceled 错误；</li><li>如果当前 Context 超时就会返回 DeadlineExceeded 错误；</li></ul></li><li>Value 方法会从 Context 中返回键对应的值，对于同一个上下文来说，多次调用 Value 并传入相同的 Key 会返回相同的结果，这个功能可以用来传递请求特定的数据；获取Value值时是线程安全的； key 必须为非空，且可比较;</li></ul><h3 id="1-2-标准-error"><a href="#1-2-标准-error" class="headerlink" title="1.2 标准 error"></a>1.2 标准 error</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Canceled = errors.New(<span class="string">&quot;context canceled&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> DeadlineExceeded <span class="type">error</span> = deadlineExceededError&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> deadlineExceededError <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Error() <span class="type">string</span>   &#123; <span class="keyword">return</span> <span class="string">&quot;context deadline exceeded&quot;</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Timeout() <span class="type">bool</span>   &#123; <span class="keyword">return</span> <span class="literal">true</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(deadlineExceededError)</span></span> Temporary() <span class="type">bool</span> &#123; <span class="keyword">return</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>Canceled：context 被 cancel 时会报此错误；</li><li>DeadlineExceeded：context 超时时会报此错误.</li></ul><h2 id="2-emptyCtx"><a href="#2-emptyCtx" class="headerlink" title="2 emptyCtx"></a>2 emptyCtx</h2><h3 id="2-1-类实现"><a href="#2-1-类实现" class="headerlink" title="2.1 类实现"></a>2.1 类实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>emptyCtx 是一个不可取消，没有设置截止时间，没有携带任何值的Context;</li><li>emptyCtx 是一个空的 context，本质上类型为一个整型；</li><li>Deadline 方法会返回一个公元元年时间以及 false 的 flag，标识当前 context 不存在过期时间；</li><li>Done 方法返回一个 nil 值，用户无论往 nil 中写入或者读取数据，均会陷入阻塞；</li><li>Err 方法返回的错误永远为 nil；</li><li>Value 方法返回的 value 同样永远为 nil.</li></ul><h3 id="2-2-context-Background-amp-context-TODO"><a href="#2-2-context-Background-amp-context-TODO" class="headerlink" title="2.2 context.Background() &amp; context.TODO()"></a>2.2 context.Background() &amp; context.TODO()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">    todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>内置2个Context实现,通常用来做顶层的parent context; TODO一般在不知道使用什么Context时使用；</li><li>todo 和 background 两者本质上只有名字区别，在按 string 输出的时候会有区别; </li><li>context.Background() 和 context.TODO() 方法返回的均是 emptyCtx 类型的一个实例</li></ul><h2 id="3-cancelCtx"><a href="#3-cancelCtx" class="headerlink" title="3  cancelCtx"></a>3  cancelCtx</h2><h3 id="3-1-cancelCtx-数据结构"><a href="#3-1-cancelCtx-数据结构" class="headerlink" title="3.1 cancelCtx 数据结构"></a>3.1 cancelCtx 数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> cancelCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">    Context</span><br><span class="line"></span><br><span class="line">    mu       sync.Mutex            <span class="comment">// protects following fields</span></span><br><span class="line">    done     atomic.Value          <span class="comment">// of chan struct&#123;&#125;, created lazily, closed by first cancel call</span></span><br><span class="line">    children <span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125; <span class="comment">// set to nil by the first cancel call</span></span><br><span class="line">    err      <span class="type">error</span>                 <span class="comment">// set to non-nil by the first cancel call</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> canceler <span class="keyword">interface</span> &#123;</span><br><span class="line">    cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>)</span><br><span class="line">    Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• embed 了一个 context 作为其父 context. cancelCtx 必然为某个 context 的子 context；<br>• 内置了一把锁，用以协调并发场景下的资源获取；<br>• done：实际类型为 chan struct{}，即用以反映 cancelCtx 生命周期的通道；<br>• children：一个 set，指向 cancelCtx 的所有子 context；<br>• err：记录了当前 cancelCtx 的错误. 必然为某个 context 的子 context；</p><h3 id="3-2-Deadline-方法"><a href="#3-2-Deadline-方法" class="headerlink" title="3.2 Deadline 方法"></a>3.2 Deadline 方法</h3><p>cancelCtx 未实现该方法，仅是 embed 了一个带有 Deadline 方法的 Context interface，因此直接调用会报错.</p><h3 id="3-3-Done-方法"><a href="#3-3-Done-方法" class="headerlink" title="3.3 Done 方法"></a>3.3 Done 方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125; &#123;</span><br><span class="line">    d := c.done.Load()</span><br><span class="line">    <span class="keyword">if</span> d != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line">    d = c.done.Load()</span><br><span class="line">    <span class="keyword">if</span> d == <span class="literal">nil</span> &#123;</span><br><span class="line">        d = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">        c.done.Store(d)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d.(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 基于 atomic 包，读取 cancelCtx 中的 chan；倘若已存在，则直接返回；<br>• 加锁后，在此检查 chan 是否存在，若存在则返回；（double check）<br>• 初始化 chan 存储到 aotmic.Value 当中，并返回.（懒加载机制）</p><h3 id="3-4-Err-方法"><a href="#3-4-Err-方法" class="headerlink" title="3.4 Err 方法"></a>3.4 Err 方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Err() <span class="type">error</span> &#123;</span><br><span class="line">    c.mu.Lock()</span><br><span class="line">    err := c.err</span><br><span class="line">    c.mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 加锁；<br>• 读取 cancelCtx.err；<br>• 解锁；<br>• 返回结果.</p><h3 id="3-5-Value-方法"><a href="#3-5-Value-方法" class="headerlink" title="3.5  Value 方法"></a>3.5  Value 方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *cancelCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">    <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">        <span class="keyword">return</span> c</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 倘若 key 特定值 &amp;cancelCtxKey，则返回 cancelCtx 自身的指针；<br>• 否则遵循 valueCtx 的思路取值返回</p><h3 id="3-6-context-WithCancel"><a href="#3-6-context-WithCancel" class="headerlink" title="3.6 context.WithCancel()"></a>3.6 context.WithCancel()</h3><h4 id="3-6-1-context-WithCancel"><a href="#3-6-1-context-WithCancel" class="headerlink" title="3.6.1 context.WithCancel()"></a>3.6.1 context.WithCancel()</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span></span> (ctx Context, cancel CancelFunc) &#123;</span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    c := newCancelCtx(parent)</span><br><span class="line">    propagateCancel(parent, &amp;c)</span><br><span class="line">    <span class="keyword">return</span> &amp;c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 校验父 context 非空；<br>• 注入父 context 构造好一个新的 cancelCtx；<br>• 在 propagateCancel 方法内启动一个守护协程，以保证父 context 终止时，该 cancelCtx 也会被终止；<br>• 将 cancelCtx 返回，连带返回一个用以终止该 cancelCtx 的闭包函数.</p><h4 id="3-6-2-newCancelCtx"><a href="#3-6-2-newCancelCtx" class="headerlink" title="3.6.2 newCancelCtx"></a>3.6.2 newCancelCtx</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newCancelCtx</span><span class="params">(parent Context)</span></span> cancelCtx &#123;</span><br><span class="line">    <span class="keyword">return</span> cancelCtx&#123;Context: parent&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 注入父 context 后，返回一个新的 cancelCtx.</p><h4 id="3-6-3-propagateCancel"><a href="#3-6-3-propagateCancel" class="headerlink" title="3.6.3 propagateCancel"></a>3.6.3 propagateCancel</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">propagateCancel</span><span class="params">(parent Context, child canceler)</span></span> &#123;</span><br><span class="line">    done := parent.Done()</span><br><span class="line">    <span class="keyword">if</span> done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">// parent is never canceled</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-done:</span><br><span class="line">        <span class="comment">// parent is already canceled</span></span><br><span class="line">        child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> p, ok := parentCancelCtx(parent); ok &#123;</span><br><span class="line">        p.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> p.err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// parent has already been canceled</span></span><br><span class="line">            child.cancel(<span class="literal">false</span>, p.err)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> p.children == <span class="literal">nil</span> &#123;</span><br><span class="line">                p.children = <span class="built_in">make</span>(<span class="keyword">map</span>[canceler]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">            p.children[child] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p.mu.Unlock()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        atomic.AddInt32(&amp;goroutines, +<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-parent.Done():</span><br><span class="line">                child.cancel(<span class="literal">false</span>, parent.Err())</span><br><span class="line">            <span class="keyword">case</span> &lt;-child.Done():</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>propagateCancel 方法传递父子 context 之间的 cancel 事件：<br>• 倘若 parent 是不会被 cancel 的类型（如 emptyCtx），则直接返回；<br>• 倘若 parent 已经被 cancel，则直接终止子 context，并以 parent 的 err 作为子 context 的 err；<br>• 假如 parent 是 cancelCtx 的类型，则加锁，并将子 context 添加到 parent 的 children map 当中；<br>• 假如 parent 不是 cancelCtx 类型，但又存在 cancel 的能力（比如用户自定义实现的 context），则启动一个协程，通过多路复用的方式监控 parent 状态，倘若其终止，则同时终止子 context，并透传 parent 的 err.</p><p><strong>校验 parent 是否为 cancelCtx 的类型</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">parentCancelCtx</span><span class="params">(parent Context)</span></span> (*cancelCtx, <span class="type">bool</span>) &#123;</span><br><span class="line">    done := parent.Done()</span><br><span class="line">    <span class="keyword">if</span> done == closedchan || done == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    p, ok := parent.Value(&amp;cancelCtxKey).(*cancelCtx)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    pdone, _ := p.done.Load().(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">if</span> pdone != done &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 倘若 parent 的 channel 已关闭或者是不会被 cancel 的类型，则返回 false；<br>• 倘若以特定的 cancelCtxKey 从 parent 中取值，取得的 value 是 parent 本身，则返回 true. （基于 cancelCtxKey 为 key 取值时返回 cancelCtx 自身，是 cancelCtx 特有的协议）.</p><h2 id="4-timerCtx"><a href="#4-timerCtx" class="headerlink" title="4 timerCtx"></a>4 timerCtx</h2><h3 id="4-1-类实现"><a href="#4-1-类实现" class="headerlink" title="4.1 类实现"></a>4.1 类实现</h3><ul><li>timerCtx 内部不仅通过嵌入 cancelCtx 的方式承了相关的变量和方法，还通过持有的定时器 <code>timer</code> 和截止时间 <code>deadline</code> 实现了定时取消的功能：</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timerCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">cancelCtx</span><br><span class="line">timer *time.Timer <span class="comment">// Under cancelCtx.mu.</span></span><br><span class="line"></span><br><span class="line">deadline time.Time</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-timerCtx-Deadline"><a href="#4-2-timerCtx-Deadline" class="headerlink" title="4.2 timerCtx.Deadline()"></a>4.2 timerCtx.Deadline()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> Deadline() (deadline time.Time, ok <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c.deadline, <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>context.Context interface 下的 Deadline api 仅在 timerCtx 中有效，由于展示其过期时间.<h3 id="4-3-timerCtx-cancel"><a href="#4-3-timerCtx-cancel" class="headerlink" title="4.3 timerCtx.cancel"></a>4.3 timerCtx.cancel</h3></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *timerCtx)</span></span> cancel(removeFromParent <span class="type">bool</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">c.cancelCtx.cancel(<span class="literal">false</span>, err)</span><br><span class="line"><span class="keyword">if</span> removeFromParent &#123;</span><br><span class="line">removeChild(c.cancelCtx.Context, c)</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">if</span> c.timer != <span class="literal">nil</span> &#123;</span><br><span class="line">c.timer.Stop()</span><br><span class="line">c.timer = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">c.mu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>timerCtx.cancel 不仅调用了 cancelCtx.cancel 方法，还会停止持有的定时器减少不必要的资源浪费。</li><li>实际上对外提供了 WithTimeout 方法只是 WithDeadline 的封装</li></ul><h3 id="4-4-context-WithTimeout-amp-context-WithDeadline"><a href="#4-4-context-WithTimeout-amp-context-WithDeadline" class="headerlink" title="4.4 context.WithTimeout &amp; context.WithDeadline"></a>4.4 context.WithTimeout &amp; context.WithDeadline</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line"><span class="keyword">return</span> WithDeadline(parent, time.Now().Add(timeout))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, d time.Time)</span></span> (Context, CancelFunc) &#123;</span><br><span class="line"><span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) &#123;</span><br><span class="line"><span class="keyword">return</span> WithCancel(parent)</span><br><span class="line">&#125;</span><br><span class="line">c := &amp;timerCtx&#123;</span><br><span class="line">cancelCtx: newCancelCtx(parent),</span><br><span class="line">deadline:  d,</span><br><span class="line">&#125;</span><br><span class="line">propagateCancel(parent, c)</span><br><span class="line">dur := time.Until(d)</span><br><span class="line"><span class="keyword">if</span> dur &lt;= <span class="number">0</span> &#123;</span><br><span class="line">c.cancel(<span class="literal">true</span>, DeadlineExceeded) <span class="comment">// deadline has already passed</span></span><br><span class="line"><span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">false</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br><span class="line">c.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> c.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> c.err == <span class="literal">nil</span> &#123;</span><br><span class="line">c.timer = time.AfterFunc(dur, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">c.cancel(<span class="literal">true</span>, DeadlineExceeded)</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> c, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; c.cancel(<span class="literal">true</span>, Canceled) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 校验 parent context 非空；<br>• 校验 parent 的过期时间是否早于自己，若是，则构造一个 cancelCtx 返回即可；<br>• 构造出一个新的 timerCtx；<br>• 启动守护方法，同步 parent 的 cancel 事件到子 context；<br>• 判断过期时间是否已到，若是，直接 cancel timerCtx，并返回 DeadlineExceeded 的错误；<br>• 加锁；<br>• 启动 time.Timer，设定一个延时时间，即达到过期时间后会终止该 timerCtx，并返回 DeadlineExceeded 的错误；<br>• 解锁；<br>• 返回 timerCtx，已经一个封装了 cancel 逻辑的闭包 cancel 函数.</p><h2 id="5-valueCtx"><a href="#5-valueCtx" class="headerlink" title="5 valueCtx"></a>5 valueCtx</h2><h3 id="5-1-类实现"><a href="#5-1-类实现" class="headerlink" title="5.1 类实现"></a>5.1 类实现</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> valueCtx <span class="keyword">struct</span> &#123;</span><br><span class="line">Context</span><br><span class="line">key, val <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• valueCtx 同样继承了一个 parent context；<br>• 一个 valueCtx 中仅有一组 kv 对.</p><h3 id="5-2-valueCtx-Value"><a href="#5-2-valueCtx-Value" class="headerlink" title="5.2 valueCtx.Value()"></a>5.2 valueCtx.Value()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *valueCtx)</span></span> Value(key any) any &#123;</span><br><span class="line">    <span class="keyword">if</span> c.key == key &#123;</span><br><span class="line">        <span class="keyword">return</span> c.val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value(c.Context, key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>• 假如当前 valueCtx 的 key 等于用户传入的 key，则直接返回其 value；<br>• 假如不等，则从 parent context 中依次向上寻找.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">value</span><span class="params">(c Context, key any)</span></span> any &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> ctx := c.(<span class="keyword">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> *valueCtx:</span><br><span class="line">            <span class="keyword">if</span> key == ctx.key &#123;</span><br><span class="line">                <span class="keyword">return</span> ctx.val</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctx.Context</span><br><span class="line">        <span class="keyword">case</span> *cancelCtx:</span><br><span class="line">            <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">                <span class="keyword">return</span> c</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctx.Context</span><br><span class="line">        <span class="keyword">case</span> *timerCtx:</span><br><span class="line">            <span class="keyword">if</span> key == &amp;cancelCtxKey &#123;</span><br><span class="line">                <span class="keyword">return</span> &amp;ctx.cancelCtx</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctx.Context</span><br><span class="line">        <span class="keyword">case</span> *emptyCtx:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> c.Value(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>启动一个 for 循环，由下而上，由子及父，依次对 key 进行匹配；</li><li>其中 cancelCtx、timerCtx、emptyCtx 类型会有特殊的处理方式；</li><li>找到匹配的 key，则将该组 value 进行返回.</li><li>最终找到根节点（一般是 emptyCtx），直接返回一个 nil。所以用 Value 方法的时候要判断结果是否为 nil。</li></ul><h3 id="5-3-valueCtx-用法小结"><a href="#5-3-valueCtx-用法小结" class="headerlink" title="5.3 valueCtx 用法小结"></a>5.3 valueCtx 用法小结</h3><p>valueCtx 不适合视为存储介质，存放大量的 kv 数据</p><ul><li>一个 valueCtx 实例只能存一个 kv 对，因此 n 个 kv 对会嵌套 n 个 valueCtx，造成空间浪费；</li><li>基于 k 寻找 v 的过程是线性的，时间复杂度 O(N)；</li><li>不支持基于 k 的去重，相同 k 可能重复存在，并基于起点的不同，返回不同的 v. 由此得知，valueContext 的定位类似于请求头，只适合存放少量作用域较大的全局 meta 数据.</li></ul><h3 id="5-4-context-WithValue"><a href="#5-4-context-WithValue" class="headerlink" title="5.4 context.WithValue()"></a>5.4 context.WithValue()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val any)</span></span> Context &#123;</span><br><span class="line">    <span class="keyword">if</span> parent == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;cannot create context from nil parent&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> key == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;nil key&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !reflectlite.TypeOf(key).Comparable() &#123;</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;key is not comparable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;valueCtx&#123;parent, key, val&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>parent context 为空，panic；</li><li>key 为空 panic；</li><li>key 的类型不可比较，panic；</li><li>包括 parent context 以及 kv对，返回一个新的 valueCtx.</li></ul><h2 id="6-使用原则"><a href="#6-使用原则" class="headerlink" title="6 使用原则"></a>6 使用原则</h2><ol><li>不要把 Context 放在结构体中，要以参数的方式传递</li><li>以 Context 作为参数的函数方法，应该把 Context 作为第一个参数，放在第一位。</li><li>给一个函数方法传递 Context 的时候，不要传递 nil，如果不知道传递什么，就使用 context.TODO</li><li>Context 的 Value 相关方法应该传递必须的数据，不要什么数据都使用这个传递</li><li>Context 是线程安全的，可以放心的在多个 goroutine 中传递</li><li>在子 Context 被传递到的 goroutine 中，应该对该子 Context 的 Done（channel）进行监控</li></ol><h2 id="7-Context-Demo"><a href="#7-Context-Demo" class="headerlink" title="7 Context Demo"></a>7 Context Demo</h2><h3 id="7-1-Context控制多个goroutine"><a href="#7-1-Context控制多个goroutine" class="headerlink" title="7.1 Context控制多个goroutine"></a>7.1 Context控制多个goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line">    valueCtx1 := context.WithValue(ctx, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;goroutine 1&quot;</span>)</span><br><span class="line">    valueCtx2 := context.WithValue(ctx, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;goroutine 2&quot;</span>)</span><br><span class="line">    valueCtx3 := context.WithValue(ctx, <span class="string">&quot;key&quot;</span>, <span class="string">&quot;goroutine 3&quot;</span>)</span><br><span class="line">    <span class="keyword">go</span> watch(valueCtx1)</span><br><span class="line">    <span class="keyword">go</span> watch(valueCtx2)</span><br><span class="line">    <span class="keyword">go</span> watch(valueCtx3)</span><br><span class="line"></span><br><span class="line">    time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">    fmt.Println(<span class="string">&quot;cancel &quot;</span>, ctx.String())</span><br><span class="line">    cancel()</span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(ctx.String() ,<span class="string">&quot; done&quot;</span>, ctx.Err())</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            fmt.Println(ctx.Value(<span class="string">&quot;key&quot;</span>), <span class="string">&quot;wait...&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-Context-http请求超时"><a href="#7-2-Context-http请求超时" class="headerlink" title="7.2 Context http请求超时"></a>7.2 Context http请求超时</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个超时时间为100毫秒的上下文</span></span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    ctx, _ = context.WithTimeout(ctx, <span class="number">100</span>*time.Millisecond)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个访问Google主页的请求</span></span><br><span class="line">    req, _ := http.NewRequest(http.MethodGet, <span class="string">&quot;http://google.com&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line">    <span class="comment">// 将超时上下文关联到创建的请求上</span></span><br><span class="line">    req = req.WithContext(ctx)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个HTTP客户端并执行请求</span></span><br><span class="line">    client := &amp;http.Client&#123;&#125;</span><br><span class="line">    res, err := client.Do(req)</span><br><span class="line">    <span class="comment">// 如果请求失败了，记录到STDOUT</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Request failed:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求成功后打印状态码</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Response received, status code:&quot;</span>, res.StatusCode)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-Context-http服务器"><a href="#7-3-Context-http服务器" class="headerlink" title="7.3 Context http服务器"></a>7.3 Context http服务器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个监听8000端口的服务器</span></span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;:8000&quot;</span>, http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">    ctx := r.Context()</span><br><span class="line">    <span class="comment">// 输出到STDOUT展示处理已经开始</span></span><br><span class="line">    fmt.Fprint(os.Stdout, <span class="string">&quot;processing request\n&quot;</span>)</span><br><span class="line">    <span class="comment">// 通过select监听多个channel</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">2</span> * time.Second):</span><br><span class="line">        <span class="comment">// 如果两秒后接受到了一个消息后，意味请求已经处理完成</span></span><br><span class="line">        <span class="comment">// 我们写入&quot;request processed&quot;作为响应</span></span><br><span class="line">        w.Write([]<span class="type">byte</span>(<span class="string">&quot;request processed&quot;</span>))</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        <span class="comment">// 如果处理完成前取消了，在STDERR中记录请求被取消的消息</span></span><br><span class="line">        fmt.Fprint(os.Stderr, <span class="string">&quot;request cancelled\n&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-Context-超时控制多个goroutine"><a href="#7-4-Context-超时控制多个goroutine" class="headerlink" title="7.4 Context 超时控制多个goroutine"></a>7.4 Context 超时控制多个goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(ctx context.Context, wg *sync.WaitGroup)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> wg.Done()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">            fmt.Println(<span class="string">&quot;Timeout &quot;</span>, ctx.Err())</span><br><span class="line">            <span class="keyword">return</span> ctx.Err()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx, cancel := context.WithTimeout(context.Background(), <span class="number">100</span>*time.Millisecond)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> worker(ctx, &amp;wg)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">    cancel()</span><br><span class="line"></span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-Context-取消控制多个goroutine"><a href="#7-5-Context-取消控制多个goroutine" class="headerlink" title="7.5 Context 取消控制多个goroutine"></a>7.5 Context 取消控制多个goroutine</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work1</span><span class="params">(ctx context.Context)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 假设这个操作会因为某种原因失败</span></span><br><span class="line">    <span class="comment">// 使用time.Sleep来模拟一个资源密集型操作</span></span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    <span class="keyword">return</span> errors.New(<span class="string">&quot;failed&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">work2</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-time.After(<span class="number">500</span> * time.Millisecond):</span><br><span class="line">        fmt.Println(<span class="string">&quot;done&quot;</span>)</span><br><span class="line">    <span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">        fmt.Println(<span class="string">&quot;halted work2&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ctx := context.Background()</span><br><span class="line">    <span class="comment">// cancel context</span></span><br><span class="line">    ctx, cancel := context.WithCancel(ctx)</span><br><span class="line">    <span class="comment">// 在不同的goroutine中运行work2</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        work2(ctx)</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        work2(ctx)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    err := work1(ctx)</span><br><span class="line">    <span class="comment">// 如果这个操作返回错误，取消所有使用相同Context的操作</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">//发出取消事件</span></span><br><span class="line">        cancel()</span><br><span class="line">    &#125;</span><br><span class="line">    time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-6-Context-控制后台goroutine-生成素数"><a href="#7-6-Context-控制后台goroutine-生成素数" class="headerlink" title="7.6 Context 控制后台goroutine 生成素数"></a>7.6 Context 控制后台goroutine 生成素数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回生成自然数序列的管道: 2, 3, 4, ...</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenerateNatural</span><span class="params">(ctx context.Context)</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">2</span>; ; i++ &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 结束生成自然数</span></span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">case</span> ch &lt;- i:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 管道过滤器: 删除能被素数整除的数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">PrimeFilter</span><span class="params">(ctx context.Context, in &lt;-<span class="keyword">chan</span> <span class="type">int</span>, prime <span class="type">int</span>)</span></span> <span class="keyword">chan</span> <span class="type">int</span> &#123;</span><br><span class="line">    out := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> i := &lt;-in; i%prime != <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-ctx.Done(): <span class="comment">// 结束过滤器</span></span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> out &lt;- i:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 通过 Context 控制后台Goroutine状态</span></span><br><span class="line">    ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"></span><br><span class="line">    ch := GenerateNatural(ctx) <span class="comment">// 自然数序列: 2, 3, 4, ...</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        prime := &lt;-ch <span class="comment">// 新出现的素数</span></span><br><span class="line">        fmt.Printf(<span class="string">&quot;%v: %v\n&quot;</span>, i+<span class="number">1</span>, prime)</span><br><span class="line">        ch = PrimeFilter(ctx, ch, prime) <span class="comment">// 基于新素数构造的过滤器</span></span><br><span class="line">    &#125;</span><br><span class="line">    cancel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-参考"><a href="#8-参考" class="headerlink" title="8 参考"></a>8 参考</h2><ul><li><a href="https://pkg.go.dev/context">https://pkg.go.dev/context</a></li><li><a href="https://faiface.github.io/post/context-should-go-away-go2/">https://faiface.github.io/post/context-should-go-away-go2/</a></li><li><a href="https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/">https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-context/</a></li><li><a href="https://blog.csdn.net/qq_36183935/article/details/81137834">https://blog.csdn.net/qq_36183935/article/details/81137834</a></li><li><a href="https://blog.csdn.net/u011957758/article/details/82948750">https://blog.csdn.net/u011957758/article/details/82948750</a></li><li><a href="https://www.jianshu.com/p/e5df3cd0708bhttps://zhuanlan.zhihu.com/p/68792989">https://www.jianshu.com/p/e5df3cd0708bhttps://zhuanlan.zhihu.com/p/68792989</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] sync.Mutex</title>
      <link href="/2022/07/09/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.Mutex/"/>
      <url>/2022/07/09/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.Mutex/</url>
      
        <content type="html"><![CDATA[<h2 id="1-基本结构"><a href="#1-基本结构" class="headerlink" title="1 基本结构"></a>1 基本结构</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/mutex.go 25行</span></span><br><span class="line"><span class="keyword">type</span> Mutex <span class="keyword">struct</span> &#123;</span><br><span class="line">state <span class="type">int32</span>      <span class="comment">// 当前互斥锁的状态</span></span><br><span class="line">sema  <span class="type">uint32</span>     <span class="comment">// 控制锁状态的信号量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-1-state字段"><a href="#1-1-state字段" class="headerlink" title="1.1 state字段"></a>1.1 state字段</h3><p>![[Pasted image 20230901043018.png]]<br>低三位分别标识</p><ul><li>mutexLocked（是否上锁）</li><li>mutexWoken（是否有协程在抢锁）</li><li>mutexStarving（是否处于饥饿模式）</li><li>高 29 位的值聚合为一个范围为 0~2^29-1 的整数，表示在阻塞队列中等待的协程个数.</li></ul><h3 id="1-2-正常模式和饥饿模式"><a href="#1-2-正常模式和饥饿模式" class="headerlink" title="1.2 正常模式和饥饿模式"></a>1.2 正常模式和饥饿模式</h3><blockquote><p>mutex 是公平锁</p></blockquote><p><code>正常模式</code>：锁的等待者会按照<code>先进先出</code>的顺序获取锁。但是刚被唤起的 Goroutine 与新创建的 Goroutine 竞争时，大概率会获取不到锁，为了减少这种情况的出现，一旦 Goroutine <code>超过 1ms</code> 没有获取到锁，它就会将当前互斥锁切换饥饿模式，防止部分 Goroutine 被<strong>饿死</strong>。<br><code>饥饿模式</code>：互斥锁会直接交给等待队列最前面的 Goroutine。新的 Goroutine 在该状态下不能获取锁、也不会进入自旋状态，它们只会在队列的末尾等待。如果一个 Goroutine 获得了互斥锁并且它在队列的末尾或者它等待的时间<code>少于 1ms</code>，那么当前的互斥锁就会切换回正常模式。</p><h2 id="2-加解锁过程"><a href="#2-加解锁过程" class="headerlink" title="2 加解锁过程"></a>2 加解锁过程</h2><h3 id="2-1-加锁"><a href="#2-1-加锁" class="headerlink" title="2.1 加锁"></a>2.1 加锁</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/mutex.go 72 行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Mutex)</span></span> Lock() &#123;</span><br><span class="line"><span class="comment">// Fast path: grab unlocked mutex.</span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Slow path (outlined so that the fast path can be inlined)</span></span><br><span class="line">m.lockSlow()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-1-Fast-path"><a href="#2-1-1-Fast-path" class="headerlink" title="2.1.1 Fast path"></a>2.1.1 Fast path</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapInt32(&amp;m.state, <span class="number">0</span>, mutexLocked) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>首先进行 <code>CAS</code> 操作，假如当前未上锁且锁内不存在阻塞协程，则直接 CAS 抢锁成功返回</p></blockquote><h4 id="2-1-2-Slow-Path"><a href="#2-1-2-Slow-Path" class="headerlink" title="2.1.2 Slow Path"></a>2.1.2 Slow Path</h4><p>如果互斥锁的状态不是 0 时就会进入 Slow Path。尝试通过自旋（Spinnig）等方式等待锁的释放，该方法的主体是一个非常大 for 循环，这里将它分成几个部分介绍获取锁的过程：</p><h5 id="2-1-2-1-判断当前-Goroutine-能否进入自旋"><a href="#2-1-2-1-判断当前-Goroutine-能否进入自旋" class="headerlink" title="2.1.2.1 判断当前 Goroutine 能否进入自旋"></a>2.1.2.1 判断当前 Goroutine 能否进入自旋</h5><p><strong>自旋是一种多线程同步机制</strong>，当前的进程在进入自旋的过程中会一直保持 CPU 的占用，持续检查某个条件是否为真。<strong>在多核的 CPU 上，自旋可以避免 Goroutine 的切换</strong>，使用恰当会对性能带来很大的增益，但是使用的不恰当就会拖慢整个程序，所以 Goroutine 进入自旋的条件非常苛刻：</p><ul><li>互斥锁只有在普通模式才能进入自旋；</li><li><code>runtime.sync_runtime_canSpin</code>需要返回 true<ul><li>运行在多 CPU 的机器上；</li></ul><ul><li>当前 Goroutine 为了获取该锁进入自旋的次数小于四次；</li><li>当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；</li></ul></li></ul><h5 id="2-1-2-2-通过自旋等待互斥锁的释放"><a href="#2-1-2-2-通过自旋等待互斥锁的释放" class="headerlink" title="2.1.2.2 通过自旋等待互斥锁的释放"></a>2.1.2.2 通过自旋等待互斥锁的释放</h5><p>一旦当前 Goroutine 能够进入自旋就会调用<code>runtime.sync_runtime_doSpin</code>和<code>runtime.procyield</code>执行 30 次的 <code>PAUSE</code> 指令，该指令只会占用 CPU 并消耗 CPU 时间：</p><h5 id="2-1-2-3-计算互斥锁的最新状态"><a href="#2-1-2-3-计算互斥锁的最新状态" class="headerlink" title="2.1.2.3 计算互斥锁的最新状态"></a>2.1.2.3 计算互斥锁的最新状态</h5><p>处理了自旋相关的特殊逻辑之后，互斥锁会根据上下文计算当前互斥锁最新的状态。几个不同的条件分别会更新 <code>state</code> 字段中存储的不同信息 — <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 和 <code>mutexWaiterShift</code>：</p><h5 id="2-1-2-4-更新互斥锁的状态并获取锁"><a href="#2-1-2-4-更新互斥锁的状态并获取锁" class="headerlink" title="2.1.2.4 更新互斥锁的状态并获取锁"></a>2.1.2.4 更新互斥锁的状态并获取锁</h5><p>计算了新的互斥锁状态之后，会使用 CAS 函数更新状态<br>如果没有通过 CAS 获得锁，会调用 <code>runtime.sync_runtime_SemacquireMutex</code> 通过信号量保证资源不会被两个 Goroutine 获取。<br><code>runtime.sync_runtime_SemacquireMutex</code> 会在方法中不断尝试获取锁并陷入休眠等待信号量的释放，一旦当前 Goroutine 可以获取信号量，它就会立刻返回，<code>sync.Mutex.Lock</code>的剩余代码也会继续执行。</p><ul><li>在正常模式下，这段代码会设置唤醒和饥饿标记、重置迭代次数并重新执行获取锁的循环；</li><li>在饥饿模式下，当前 Goroutine 会获得互斥锁，如果等待队列中只存在当前 Goroutine，互斥锁还会从饥饿模式中退出；</li></ul><h3 id="2-2-解锁"><a href="#2-2-解锁" class="headerlink" title="2.2 解锁"></a>2.2 解锁</h3><h4 id="2-2-1-Fast-path"><a href="#2-2-1-Fast-path" class="headerlink" title="2.2.1 Fast path"></a>2.2.1 Fast path</h4><p>该过程会先使用<code>atomic.AddInt32函数快速解锁，这时会发生下面的两种情况：</code></p><ul><li>如果该函数返回的新状态等于 0，当前 Goroutine 就成功解锁了互斥锁；</li><li>如果该函数返回的新状态不等于 0，则进入 Slow path。<h4 id="2-2-2-Slow-path"><a href="#2-2-2-Slow-path" class="headerlink" title="2.2.2 Slow path"></a>2.2.2 Slow path</h4>先校验锁状态的<code>合法性</code> — 如果当前互斥锁已经被解锁过了会直接抛出异常 “sync: unlock of unlocked mutex” 中止当前程序。<br>在正常模式下，上述代码会使用如下所示的处理过程：</li><li>如果互斥锁不存在等待者或者互斥锁的 <code>mutexLocked</code>、<code>mutexStarving</code>、<code>mutexWoken</code> 状态不都为 0，那么当前方法可以直接返回，不需要唤醒其他等待者；</li><li>如果互斥锁存在等待者，会通过<code>runtime_Semrelease</code>唤醒等待者并移交锁的所有权；<br>在饥饿模式下，上述代码会直接调用<code>runtime_Semrelease</code>将当前锁交给下一个正在尝试获取锁的等待者，等待者被唤醒后会得到锁，在这时互斥锁还不会退出饥饿状态；</li></ul><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p>互斥锁的<strong>加锁过程</strong>比较复杂，它涉及自旋、信号量以及调度等概念：</p><ul><li>如果互斥锁处于初始化状态，会通过置位 <code>mutexLocked</code> 加锁；</li><li>如果互斥锁处于 <code>mutexLocked</code> 状态并且在普通模式下工作，会进入自旋，执行 30 次 <code>PAUSE</code> 指令消耗 CPU 时间等待锁的释放；</li><li>如果当前 Goroutine 等待锁的时间超过了 1ms，互斥锁就会切换到饥饿模式；</li><li>互斥锁在正常情况下会通过<code>sync_runtime_SemacquireMutex</code>将尝试获取锁的 Goroutine 切换至休眠状态，等待锁的持有者唤醒；</li><li>如果当前 Goroutine 是互斥锁上的最后一个等待的协程或者等待的时间小于 1ms，那么它会将互斥锁切换回正常模式；</li></ul><p>互斥锁的<strong>解锁过程</strong>与之相比就比较简单：</p><ul><li>当互斥锁已经被解锁时，调用 Mutex.Lock 会直接抛出异常；</li><li>当互斥锁处于饥饿模式时，将锁的所有权交给队列中的下一个等待者，等待者会负责设置 <code>mutexLocked</code> 标志位；</li><li>当互斥锁处于普通模式时，如果没有 Goroutine 等待锁的释放或者已经有被唤醒的 Goroutine 获得了锁，会直接返回；在其他情况下会通过<code>sync.runtime_Semrelease</code> 唤醒对应的 Goroutine；</li></ul><h2 id="4-Sync-RWMutex"><a href="#4-Sync-RWMutex" class="headerlink" title="4 Sync.RWMutex"></a>4 Sync.RWMutex</h2><blockquote><p>从逻辑上，可以把 RWMutex 理解为一把读锁加一把写锁；<br>写锁具有<code>严格的排他性</code>，当其被占用，其他试图取写锁或者读锁的 goroutine 均阻塞；<br>读锁具有<code>有限的共享性</code>，当其被占用，试图取写锁的 goroutine 会阻塞，试图取读锁的 goroutine 可与当前 goroutine 共享读锁；<br>RWMutex 适用于<code>读多写少</code>的场景，最理想化的情况，当所有操作均使用读锁，则可实现无锁化；最悲观的情况，倘若所有操作均使用写锁，则 RWMutex 退化为普通的 Mutex.</p></blockquote><h3 id="4-1-数据结构"><a href="#4-1-数据结构" class="headerlink" title="4.1 数据结构"></a>4.1 数据结构</h3><p>![[Pasted image 20230901163649.png]]<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rwmutexMaxReaders = <span class="number">1</span> &lt;&lt; <span class="number">30</span>   <span class="comment">// 共享读锁的 goroutine 数量上限，值为 2^29；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RWMutex <span class="keyword">struct</span> &#123;</span><br><span class="line">    w           Mutex  <span class="comment">// 内置的一把普通互斥锁 sync.Mutex；</span></span><br><span class="line">    writerSem   <span class="type">uint32</span> <span class="comment">// 关联写锁阻塞队列的信号量；</span></span><br><span class="line">    readerSem   <span class="type">uint32</span> <span class="comment">// 关联读锁阻塞队列的信号量；</span></span><br><span class="line">    readerCount <span class="type">int32</span>  <span class="comment">// 正常情况下等于介入读锁流程的 goroutine 数量；当 goroutine 接入写锁流程时，该值为实际介入读锁流程的 goroutine 数量减 rwmutexMaxReaders.</span></span><br><span class="line">    readerWait  <span class="type">int32</span>  <span class="comment">// 记录在当前 goroutine 获取写锁前，还需要等待多少个 goroutine 释放读锁.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-2-读锁流程"><a href="#4-2-读锁流程" class="headerlink" title="4.2 读锁流程"></a>4.2 读锁流程</h3><h4 id="4-2-1-RLock"><a href="#4-2-1-RLock" class="headerlink" title="4.2.1 RLock"></a>4.2.1 RLock</h4><p>• 基于原子操作，将 RWMutex 的 readCount 变量加一，表示占用或等待读锁的 goroutine 数加一；<br>• 倘若 RWMutex.readCount 的新值仍小于 0，说明有 goroutine 未释放写锁，因此将当前 goroutine 添加到读锁的阻塞队列中并阻塞挂起.</p><h4 id="4-2-2-RUnlock"><a href="#4-2-2-RUnlock" class="headerlink" title="4.2.2 RUnlock"></a>4.2.2 RUnlock</h4><p>• 基于原子操作，将 RWMutex 的 readCount 变量加一，表示占用或等待读锁的 goroutine 数减一；<br>• 倘若 RWMutex.readCount 的新值小于 0，说明有 goroutine 在等待获取写锁，则走入 RWMutex.rUnlockSlow 的流程中.</p><h4 id="4-2-3-rUnlockSlow"><a href="#4-2-3-rUnlockSlow" class="headerlink" title="4.2.3 rUnlockSlow"></a>4.2.3 rUnlockSlow</h4><p>• 对 RWMutex.readerCount 进行校验，倘若发现当前协程此前未抢占过读锁，或者介入读锁流程的 goroutine 数量达到上限，则抛出 fatal；<br>(倘若 r+1 == -rwmutexMaxReaders，说明此时有 goroutine 介入写锁流程，但当前此前未加过读锁，具体原因见 2.3 小节；倘若 r+1=0，则要么此前未加过读锁，要么介入读锁流程的 goroutine 数量达到上限</p><p>• 基于原子操作，对 RWMutex.readerWait 进行减一操作，倘若其新值为 0，说明当前 goroutine 是最后一个介入读锁流程的协程，因此需要唤醒一个等待写锁的阻塞队列的 goroutine.（综合 RWMutex.readerCount 为负值，可以确定存在等待写锁的 goroutine，具体原因见 2.3 小节.）</p><h3 id="4-3-写锁流程"><a href="#4-3-写锁流程" class="headerlink" title="4.3 写锁流程"></a>4.3 写锁流程</h3><h4 id="4-3-1-Lock"><a href="#4-3-1-Lock" class="headerlink" title="4.3.1 Lock"></a>4.3.1 Lock</h4><p>• 对 RWMutex 内置的互斥锁进行加锁操作；<br>• 基于原子操作，对 RWMutex.readerCount 进行减少 -rwmutexMaxReaders 的操作；<br>• 倘若此时存在未释放读锁的 gouroutine，则基于原子操作在 RWMutex.readerWait 的基础上加上介入读锁流程的 goroutine 数量，并将当前 goroutine 添加到写锁的阻塞队列中挂起.</p><h4 id="4-3-2-Unlock"><a href="#4-3-2-Unlock" class="headerlink" title="4.3.2 Unlock"></a>4.3.2 Unlock</h4><p>• 基于原子操作，将 RWMutex.readerCount 的值加上 rwmutexMaxReaders；<br>• 倘若发现 RWMutex.readerCount 的新值大于 rwmutexMaxReaders，则说明要么当前 RWMutex 未上过写锁，要么介入读锁流程的 goroutine 数量已经超限，因此直接抛出 fatal；<br>• 因此唤醒读锁阻塞队列中的所有 goroutine；(可见，竞争读锁的 goroutine 更具备优势)<br>• 解开 RWMutex 内置的互斥锁.</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] sync.WaitGroup</title>
      <link href="/2022/07/09/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.WaitGroup/"/>
      <url>/2022/07/09/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.WaitGroup/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Golang 调度方式：<code>主动让渡</code>和<code>被动调度</code><br>   被动调度: <code>通道 channel</code> 、<code>单机锁 sync.Mutex</code>、<code>并发等待组 sync.WaitGroup</code><br>当 goroutine 之间需要建立明确的<code>层级关系</code>. 倘若父 goroutine 希望持有子 goroutine 的生杀大权，并且保证父 goroutine 消亡时能连带回收其创建的所有子 goroutine ，此时可以使用到 Golang 上下文工具 context，完成父 goroutine 对 子 goroutine 的<code>生命周期控制</code></p><p>多个协程等待一个协程执行完，除了WaitGroup 还有什么方式？  写入channel，for循环读</p><h2 id="1-How-to-use？"><a href="#1-How-to-use？" class="headerlink" title="1 How to use？"></a>1 How to use？</h2><h3 id="1-1-核心方法"><a href="#1-1-核心方法" class="headerlink" title="1.1 核心方法"></a>1.1 核心方法</h3><p>• <code>WaitGroup.Add(n)</code>：完成一次登记操作，使得 WaitGroup 中并发计数器的数值加上 n. 在使用场景中，WaitGroup.Add(n) 背后的含义是，注册并启动了 n 个子 goroutine<br>• <code>WaitGroup.Done()</code>：完成一次上报操作，使得 WaitGroup 中并发计数器的数值减 1. 在使用场景中，通常会在一个子 goroutine 退出前，会执行一次 WaitGroup.Done 方法<br>• <code>WaitGroup.Wait()</code>：完成聚合操作. 通常由主 goroutine 调用该方法，主 goroutine 会因此陷入阻塞，直到所有子 goroutine 都已经执行完成，使得 WaitGroup 并发计数器数值清零时，主 goroutine 才得以继续往下执行</p></blockquote><h3 id="1-2-案例"><a href="#1-2-案例" class="headerlink" title="1.2 案例"></a>1.2 案例</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_waitGroup</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup   <span class="comment">// 声明等待组 wg</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;   <span class="comment">// 循环开启十个子 Goroutine</span></span><br><span class="line">        wg.Add(<span class="number">1</span>)               <span class="comment">// 登记子 Goroutine</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()     <span class="comment">// 保证退出前会调用一次，完成上报</span></span><br><span class="line">            &lt;-time.After(time.Second)</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    wg.Wait()                   <span class="comment">// 阻塞等待，直到等待组全部完成后才往下走</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：子 goroutine 是异步启动的，所以有可能出现 Wait 方法先于 Add 方法执行，此时由于计数器值为 0，Wait 方法会被直接放行，导致产生预期之外的执行流程；因此要保证 add 在 done 之前。</p></blockquote><h3 id="1-3-WaitGroup-channel-完成数据聚合"><a href="#1-3-WaitGroup-channel-完成数据聚合" class="headerlink" title="1.3 WaitGroup + channel 完成数据聚合"></a>1.3 WaitGroup + channel 完成数据聚合</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_waitGroup</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    tasksNum := <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据缓存 channel</span></span><br><span class="line">    dataCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">    <span class="comment">// 数据结果 slice</span></span><br><span class="line">    resp := <span class="built_in">make</span>([]<span class="keyword">interface</span>&#123;&#125;, <span class="number">0</span>, tasksNum)</span><br><span class="line">    <span class="comment">// 控制管道</span></span><br><span class="line">    stopCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 启动读 goroutine</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> data := <span class="keyword">range</span> dataCh &#123;</span><br><span class="line">            resp = <span class="built_in">append</span>(resp, data)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标识数据读取完成</span></span><br><span class="line">        stopCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证获取到所有数据后，通过 channel 传递到读协程手中</span></span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; tasksNum; i++ &#123;</span><br><span class="line">        wg.Add(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ch <span class="keyword">chan</span>&lt;- <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">            <span class="keyword">defer</span> wg.Done()</span><br><span class="line">            ch &lt;- time.Now().UnixNano()</span><br><span class="line">        &#125;(dataCh)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确保所有取数据的协程都完成了工作，才关闭 ch</span></span><br><span class="line">    wg.Wait()</span><br><span class="line">    <span class="built_in">close</span>(dataCh)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保读协程处理完成</span></span><br><span class="line">    &lt;-stopCh</span><br><span class="line"></span><br><span class="line">    t.Logf(<span class="string">&quot;resp: %+v&quot;</span>, resp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-源码走读"><a href="#2-源码走读" class="headerlink" title="2 源码走读"></a>2 源码走读</h2><h3 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h3><p>WaitGroup 位于 golang sync 包下，对应的类声明中包含了几个核心字段：</p><ul><li><code>noCopy</code>：这是防拷贝标识，标记了 WaitGroup 不应该用于值传递</li><li><code>state1</code>：这是 WaitGroup 的核心字段，是一个无符号的64位整数，高32位是 WaitGroup 中并发计数器的数值，即当前 WaitGroup.Add 与 WaitGroup.Done 之间的差值；低 32 位标识了，当前有多少 goroutine 因 WaitGroup.Wait 操作而处于阻塞态，陷入阻塞态的原因是因为计数器的值没有清零，即 state1 字段高 32 位是一个正值</li><li><code>state2</code>：用于阻塞和唤醒 goroutine 的信号量</li></ul><p><code>WaitGroup.Add</code> 方法会给 WaitGroup 的计数器累加上一定的值，背后的含义是标识出当前有多少 goroutine 正在运行，需要由 WaitGroup.Done 操作完成数值的抵扣：</p><ul><li>首先通过 WaitGroup.state 方法，获取到 WaitGroup 的 state1 和 state2 字段，分别将字段对应的地址赋给临时变量 statep 和 semap</li><li>调用 atomic.AddUint64，直接通过指针的方式直接在 WaitGroup.state1 的高 32 位基础上累加上 delta 的值</li><li>获取到 state1 高 32 位的值，赋值给局部变量 v，其含义是并发计数器的数值，即 WaitGroup.Add 和 WaitGroup.Done 之间的差值</li><li>获取到 state1 低 32 位的值，赋值给局部变量 w. 其含义是因执行 WaitGroup.Wait 操作而陷入阻塞态的 goroutine 数量</li><li>倘若 WaitGroup 计数器出现负值，直接 panic（ Done 不应该多于 Add ）</li><li>倘若首次 Add 操作是在有 goroutine 因 Wait 操作而陷入阻塞时才执行，抛出 panic（if w != 0 &amp;&amp; delta &gt; 0 &amp;&amp; v == int32(delta) ）</li><li>倘若执行完 Add 操作后，WaitGroup 的计数器还是正值，则直接返回</li><li>倘若发现本次 Add 操作后， WaitGroup 计数器被清零了，则接下来需要依次把因 Wait 操作而陷入阻塞的 goroutine 唤醒. 在这期间，不允许再并发执行 Add 操作，否则会 panic</li><li>唤醒 goroutine 使用的方法是 runtime_Semrelease 方法，底层会执行 goready 操作，属于 goroutine 的被动调度模式</li></ul><p>执行 WaitGroup.Wait 方法，会判断 WaitGroup 中的并发计数器数值是否为 0，如果不等于0，则当前 goroutine 会陷入阻塞态，直到计数器数值清零之后，才会被唤醒. 具体的执行流程如下：</p><ul><li>执行 WaitGroup.state 方法，获取到 state1 和 state2 字段</li><li>走进 for 循环开启自旋流程</li><li>将 state1 高 32 位所存储的计数器数值赋给局部变量 v</li><li>将 state1 低 32 位所存储的阻塞 goroutine 数量赋给局部变量 w</li><li>倘若计数器数值 v 已经是 0 了，则无需阻塞 goroutine，直接返回即可</li><li>倘若计数器数值 v 大于 0，代表当前 goroutine 需要被阻塞挂起.</li><li>基于 cas，将 state1 低 32 位的数值加 1，标识有一个额外的 goroutine 需要阻塞挂起了</li><li>调用 runtime_Semacquire 方法，内部会通过 go park 操作，将当前 goroutine 阻塞挂起，属于被动调度模式</li><li>当 goroutine 从 runtime_Semacquire 方法走出来时，说明 WaitGroup 计数器已经被清零了.</li><li>在被唤醒的 goroutine 返回前，WaitGroup 不能被并发执行 Add 操作，否则会陷入 panic</li><li>被唤醒的 goroutine 正常返回，Wait 流程结束</li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] sync.Map</title>
      <link href="/2022/07/09/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Map/"/>
      <url>/2022/07/09/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Map/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在 golang 中, map 并不保证并发安全的安全性, 对 map 进行并发读写会导致严重的错误, sync 标准包下的 sync.Map 解决了这一问题.</p></blockquote><span id="more"></span><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h2><h3 id="1-1-sync-Map"><a href="#1-1-sync-Map" class="headerlink" title="1.1 sync.Map"></a>1.1 sync.Map</h3><p><img src="file-20250307231828243.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Map <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu Mutex</span><br><span class="line">    read atomic.Value </span><br><span class="line">    dirty <span class="keyword">map</span>[any]*entry</span><br><span class="line">    misses <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>read：无锁化的只读 map，实际类型为 readOnly</li><li>dirty：加锁处理的读写 map</li><li>misses：记录访问 read 的失效次数，累计达到阈值时，会进行 read map/dirty map 的更新轮换</li><li>mu：一把互斥锁，实现 dirty 和 misses 的并发管理</li><li>sync.Map 的特点是冗余了两份 map：read map 和 dirty map</li></ul><h3 id="1-2-entry-及对应的几种状态"><a href="#1-2-entry-及对应的几种状态" class="headerlink" title="1.2 entry 及对应的几种状态"></a>1.2 entry 及对应的几种状态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type entry struct &#123;</span><br><span class="line">p unsafe.Pointer </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>kv 对中的 value，统一采用 unsafe.Pointer 的形式进行存储，通过 entry.p 的指针进行链接</li><li>entry.p 的指向分为三种情况：<ul><li>存活态：正常指向元素</li><li>软删除态：指向 nil, nil 态表示软删除，read map 和 dirty map 底层的 map 结构仍存在 key-entry 对，但在逻辑上该 key-entry 对已经被删除，因此无法被用户查询到</li><li>硬删除态：指向固定的全局变量 expunged, expunged 态表示硬删除，dirty map 中已不存在该 key-entry 对</li></ul></li></ul><h3 id="1-3-readOnly"><a href="#1-3-readOnly" class="headerlink" title="1.3 readOnly"></a>1.3 readOnly</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> readOnly <span class="keyword">struct</span> &#123;</span><br><span class="line">    m       <span class="keyword">map</span>[any]*entry</span><br><span class="line">    amended <span class="type">bool</span> <span class="comment">// true if the dirty map contains some key not in m.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync.Map 中的只读 map：read 内部包含两个成员属性：</p><ul><li>m：真正意义上的 read map，实现从 key 到 entry 的映射；</li><li>amended：标识 read map 中的 key-entry 对是否存在缺失，需要通过 dirty map 兜底.</li></ul><h2 id="2-读流程"><a href="#2-读流程" class="headerlink" title="2 读流程"></a>2 读流程</h2><h3 id="2-1-sync-Map-Load"><a href="#2-1-sync-Map-Load" class="headerlink" title="2.1 sync.Map.Load()"></a>2.1 sync.Map.Load()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Load(key any) (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        read, _ = m.read.Load().(readOnly)</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e.load()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检查  read map 中是否存在 key-entry 对，若存在，则直接读取 entry 返回</li><li>如果第一轮 read map 查询 miss，且 read map 不全，则需要加锁 double check</li><li>如果第二轮 read map 查询仍 miss（加锁后），且 read map 不全，则查询 dirty map 兜底</li><li>查询操作涉及到与 dirty map 的交互，misses 加一</li><li>解锁，返回查得的结果</li></ul><h3 id="2-2-entry-load"><a href="#2-2-entry-load" class="headerlink" title="2.2 entry.load()"></a>2.2 entry.load()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> load() (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *(*any)(p), <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>sync.Map 中，kv 对的 value 是基于 entry 指针封装的形式；</li><li>从 map 取得 entry 后，最终需要调用 entry.load 方法读取指针指向的内容；</li><li>如果 entry 的指针状态为 nil 或者 expunged，说明 key-entry 对已被删除，则返回 nil；</li><li>如果 entry 未被删除，则读取指针内容，并且转为 any 的形式进行返回.</li></ul><h3 id="2-3-sync-Map-missLocked"><a href="#2-3-sync-Map-missLocked" class="headerlink" title="2.3 sync.Map.missLocked()"></a>2.3 sync.Map.missLocked()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> missLocked() &#123;</span><br><span class="line">    m.misses++</span><br><span class="line">    <span class="keyword">if</span> m.misses &lt; <span class="built_in">len</span>(m.dirty) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    m.read.Store(readOnly&#123;m: m.dirty&#125;)</span><br><span class="line">    m.dirty = <span class="literal">nil</span></span><br><span class="line">    m.misses = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在读流程中，倘若未命中 read map，且由于 read map 内容存在缺失需要和 dirty map 交互时，会走进 missLocked 流程；</li><li>在 missLocked 流程中，首先 misses 计数器累加 1；</li><li>如果 miss 次数小于 dirty map 中存在的 key-entry 对数量，直接返回即可；</li><li>如果 miss 次数大于等于 dirty map 中存在的 key-entry 对数量，则使用 dirty map 覆盖 read map，并将 read map 的 amended flag 置为 false；</li><li>新的 dirty map 置为 nil，misses 计数器清零.</li></ul><h2 id="3-写流程"><a href="#3-写流程" class="headerlink" title="3 写流程"></a>3 写流程</h2><h3 id="3-1-sync-Map-Store"><a href="#3-1-sync-Map-Store" class="headerlink" title="3.1 sync.Map.Store()"></a>3.1 sync.Map.Store()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value any) &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    read, _ = m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">            m.dirty[key] = e</span><br><span class="line">        &#125;</span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !read.amended &#123;</span><br><span class="line">            m.dirtyLocked()</span><br><span class="line">            m.read.Store(readOnly&#123;m: read.m, amended: <span class="literal">true</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        m.dirty[key] = newEntry(value)</span><br><span class="line">    &#125;</span><br><span class="line">    m.mu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> storeLocked(i *any) &#123;</span><br><span class="line">    atomic.StorePointer(&amp;e.p, unsafe.Pointe</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 read map 存在拟写入的 key，且 entry 不为 expunged 状态，说明这次操作属于更新而非插入，直接基于 CAS 操作进行 entry 值的更新，并直接返回（存活态或者软删除，直接覆盖更新）</li><li>如果未命中，则需要加锁 double check</li><li>如果第二轮检查中发现 read map 或者 dirty map 中存在 key-entry 对，则直接将 entry 更新为新值即可（存活态或者软删除，直接覆盖更新）</li><li>如果发现 read map 中该 key-entry 为 expunged 态，需要在 dirty map 先补齐 key-entry 对，再更新 entry 值（从硬删除中恢复，然后覆盖更新）</li><li>如果 read map 和 dirty map 均不存在，则在 dirty map 中插入新 key-entry 对，并且保证 read map 的 amended flag 为 true.（插入）</li><li>如果发现 dirty map 未初始化，需要前置执行 dirtyLocked 流程</li><li>解锁返回</li></ul><h3 id="3-2-entry-tryStore"><a href="#3-2-entry-tryStore" class="headerlink" title="3.2 entry.tryStore()"></a>3.2 entry.tryStore()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value any) &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &amp;&amp; e.tryStore(&amp;value) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryStore(i *any) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">        <span class="keyword">if</span> p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, unsafe.Pointer(i)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在写流程中，如果发现 read map 中已存在对应的 key-entry 对，则会对调用 tryStore 方法尝试进行更新；</li><li>如果 entry 为 expunged 态，说明已被硬删除，dirty 中缺失该项数据，因此 tryStore 执行失败，回归主干流程；</li><li>如果 entry 非 expunged 态，则直接执行 CAS 操作完成值的更新即可.</li></ul><h3 id="3-3-entry-unexpungeLocked"><a href="#3-3-entry-unexpungeLocked" class="headerlink" title="3.3 entry.unexpungeLocked()"></a>3.3 entry.unexpungeLocked()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value any) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    read, _ = m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">        <span class="keyword">if</span> e.unexpungeLocked() &#123;</span><br><span class="line">            m.dirty[key] = e</span><br><span class="line">        &#125;</span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> unexpungeLocked() (wasExpunged <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> atomic.CompareAndSwapPointer(&amp;e.p, expunged, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在写流程加锁 double check 的过程中，如果发现 read map 中存在对应的 key-entry 对，会执行该方法；</li><li>如果 key-entry 为硬删除 expunged 态，该方法会基于 CAS 操作将其更新为软删除 nil 态，然后进一步在 dirty map 中补齐该 key-entry 对，实现从硬删除到软删除的恢复.</li></ul><h3 id="3-4-entry-storeLocked"><a href="#3-4-entry-storeLocked" class="headerlink" title="3.4 entry.storeLocked()"></a>3.4 entry.storeLocked()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Store(key, value any) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    m.mu.Lock()</span><br><span class="line">    read, _ = m.read.Load().(readOnly)</span><br><span class="line">    <span class="keyword">if</span> e, ok := read.m[key]; ok &#123;</span><br><span class="line">       <span class="comment">// ...</span></span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> e, ok := m.dirty[key]; ok &#123;</span><br><span class="line">        e.storeLocked(&amp;value)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> storeLocked(i *any) &#123;</span><br><span class="line">    atomic.StorePointer(&amp;e.p, unsafe.Pointer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>写流程中，如果 read map 或者 dirty map 存在对应 key-entry，最终会通过原子操作，将新值的指针存储到 entry.p 当中.</li></ul><h3 id="3-5-sync-Map-dirtyLocked"><a href="#3-5-sync-Map-dirtyLocked" class="headerlink" title="3.5 sync.Map.dirtyLocked()"></a>3.5 sync.Map.dirtyLocked()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> dirtyLocked() &#123;</span><br><span class="line">    <span class="keyword">if</span> m.dirty != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    m.dirty = <span class="built_in">make</span>(<span class="keyword">map</span>[any]*entry, <span class="built_in">len</span>(read.m))</span><br><span class="line">    <span class="keyword">for</span> k, e := <span class="keyword">range</span> read.m &#123;</span><br><span class="line">        <span class="keyword">if</span> !e.tryExpungeLocked() &#123;</span><br><span class="line">            m.dirty[k] = e</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> tryExpungeLocked() (isExpunged <span class="type">bool</span>) &#123;</span><br><span class="line">    p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    <span class="keyword">for</span> p == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, <span class="literal">nil</span>, expunged) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = atomic.LoadPointer(&amp;e.p)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p == expunged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在写流程中，如果需要将 key-entry 插入到兜底的 dirty map 中，并且此时 dirty map 为空（从未写入过数据或者刚发生过 missLocked），会进入 dirtyLocked 流程；</li><li>此时会遍历一轮 read map ，将未删除的 key-entry 对拷贝到 dirty map 当中；</li><li>在遍历时，还会将 read map 中软删除 nil 态的 entry 更新为硬删除 expunged 态，因为在此流程中，不会将其拷贝到 dirty map.</li></ul><h2 id="4-删流程"><a href="#4-删流程" class="headerlink" title="4 删流程"></a>4 删流程</h2><h3 id="4-1-sync-Map-Delete"><a href="#4-1-sync-Map-Delete" class="headerlink" title="4.1 sync.Map.Delete()"></a>4.1 sync.Map.Delete()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> Delete(key any) &#123;</span><br><span class="line">    m.LoadAndDelete(key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *Map)</span></span> LoadAndDelete(key any) (value any, loaded <span class="type">bool</span>) &#123;</span><br><span class="line">    read, _ := m.read.Load().(readOnly)</span><br><span class="line">    e, ok := read.m[key]</span><br><span class="line">    <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">        m.mu.Lock()</span><br><span class="line">        read, _ = m.read.Load().(readOnly)</span><br><span class="line">        e, ok = read.m[key]</span><br><span class="line">        <span class="keyword">if</span> !ok &amp;&amp; read.amended &#123;</span><br><span class="line">            e, ok = m.dirty[key]</span><br><span class="line">            <span class="built_in">delete</span>(m.dirty, key)</span><br><span class="line">            m.missLocked()</span><br><span class="line">        &#125;</span><br><span class="line">        m.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ok &#123;</span><br><span class="line">        <span class="keyword">return</span> e.<span class="built_in">delete</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 read map 中存在 key，则直接基于 cas 操作将其删除；</li><li>如果 read map 不存在 key，且 read map 有缺失（amended flag 为 true），则加锁 double check；</li><li>如果加锁 double check 时，read map 仍不存在 key 且 read map 有缺失，则从 dirty map 中取元素，并且将 key-entry 对从 dirty map 中物理删除；</li><li>删操作需要和 dirty map 交互，需要 missLocked 流程；</li><li>解锁；</li><li>如果从 read map 或 dirty map 中获取到了 key 对应的 entry，则走入 entry.delete() 方法逻辑删除 entry；</li><li>如果 read map 和 dirty map 中均不存在 key，返回 false 标识删除失败</li></ul><h3 id="4-2-entry-delete"><a href="#4-2-entry-delete" class="headerlink" title="4.2 entry.delete()"></a>4.2 entry.delete()</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *entry)</span></span> <span class="built_in">delete</span>() (value any, ok <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        p := atomic.LoadPointer(&amp;e.p)</span><br><span class="line">        <span class="keyword">if</span> p == <span class="literal">nil</span> || p == expunged &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> atomic.CompareAndSwapPointer(&amp;e.p, p, <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> *(*any)(p), <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果 entry 此前已被删除，则直接返回 false 标识删除失败</li><li>如果 entry 当前仍存在，则通过 CAS 将 entry.p 指向 nil，标识其已进入软删除状态</li></ul><h2 id="5-遍历流程"><a href="#5-遍历流程" class="headerlink" title="5 遍历流程"></a>5 遍历流程</h2><ul><li>在遍历过程中，如果发现 read map 数据不全（amended flag 为 true），会额外加一次锁，并使用 dirty map 覆盖 read map</li><li>遍历 read map（通过上个步骤保证 read map 有全量数据），执行用户传入的回调函数，如果某次回调时返回值为 false，则会终止全流程</li></ul><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h2><h3 id="6-1-entry-的-expunged-态"><a href="#6-1-entry-的-expunged-态" class="headerlink" title="6.1 entry 的 expunged 态"></a>6.1 entry 的 expunged 态</h3><p><strong>为什么需要使用 expunged 态来区分软硬删除？</strong></p><ul><li>无论是软删除(nil)还是硬删除(expunged),都表示在逻辑意义上 key-entry 对已经从 sync.Map 中删除，nil 和 expunged 的区别在于<ul><li>软删除态（nil）：read map 和 dirty map 在物理上仍保有该 key-entry 对，因此如果此时需要对该 entry 执行写操作，可以直接 CAS 操作</li><li>硬删除态（expunged）：dirty map 中已经没有该 key-entry 对，如果执行写操作，必须加锁（dirty map 必须含有全量 key-entry 对数据）</li></ul></li><li>设计 expunged 和 nil 两种状态的原因，就是为了优化在 dirtyLocked 前，针对同一个 key <strong>先删后写</strong>的场景. 通过 expunged 态额外标识出 dirty map 中是否仍具有指向该 entry 的能力，这样能够实现对一部分 nil 态 key-entry 对的解放，能够基于 CAS 完成这部分内容写入操作而无需加锁</li></ul><h3 id="6-2-read-map-和-dirty-map-的数据流转"><a href="#6-2-read-map-和-dirty-map-的数据流转" class="headerlink" title="6.2 read map 和 dirty map 的数据流转"></a>6.2 read map 和 dirty map 的数据流转</h3><p>sync.Map 由两个 map 构成：</p><ul><li>read map：访问时全程无锁；</li><li>dirty map：是兜底的读写 map，访问时需要加锁</li></ul><p>希望能根据对读、删、更新、写操作频次的探测，来实时动态地调整操作方式，希望在读、更新、删频次较高时，更多地采用 CAS 的方式无锁化地完成操作；在写操作频次较高时，则直接了当地采用加锁操作完成.</p><p><strong>两个 map</strong></p><ul><li>总体思想，希望能多用 read map，少用 dirty map，因为操作前者无锁，后者需要加锁</li><li>除了 expunged 态的 entry 之外，read map 的内容为 dirty map 的子集</li></ul><p><strong>dirty map -&gt; read map</strong></p><ul><li>记录读/删流程中，通过 misses 记录访问 read map miss 由 dirty 兜底处理的次数，当 miss 次数达到阈值，则进入 missLocked 流程，进行新老 read/dirty 替换流程；此时将老 dirty 作为新 read，新 dirty map 则暂时为空，直到 dirtyLocked 流程完成对 dirty 的初始化</li></ul><p><strong>read map -&gt; dirty map</strong></p><ul><li>发生 dirtyLocked 的前置条件：I dirty 暂时为空（此前没有写操作或者近期进行过 missLocked 流程）；II 接下来一次写操作访问 read 时 miss，需要由 dirty 兜底</li><li>在 dirtyLocked 流程中，需要对 read 内的元素进行状态更新，因此需要遍历，是一个线性时间复杂度的过程，可能存在性能抖动</li><li>dirtyLocked 遍历中，会将 read 中未被删除的元素（非 nil 非 expunged）拷贝到 dirty 中；会将 read 中所有此前被删的元素统一置为 expunged 态</li></ul><h3 id="6-3-适用场景与注意问题"><a href="#6-3-适用场景与注意问题" class="headerlink" title="6.3 适用场景与注意问题"></a>6.3 适用场景与注意问题</h3><ul><li>sync.Map 适用于读多、更新多、删多、写少的场景；</li><li>如果写操作过多，sync.Map 基本等价于互斥锁 + map；</li><li>sync.Map 可能存在性能抖动问题，主要发生于在读/删流程 miss 只读 map 次数过多时（触发 missLocked 流程），下一次插入操作的过程当中（dirtyLocked 流程）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] sync.pool</title>
      <link href="/2022/07/09/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.pool/"/>
      <url>/2022/07/09/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.pool/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍了Go语言(golang)中的<code>sync.pool</code>包。给出了 sync.pool 的基本用法，以及各大框架中的使用案例。并从源码层面对其底层结构和具体实现原理进行分析。</p><blockquote><p>以下分析基于 Go 1.17.1</p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><h3 id="1-1-大致理念"><a href="#1-1-大致理念" class="headerlink" title="1.1 大致理念"></a>1.1 大致理念</h3><p><code>sync.Pool</code> 是 sync 包下的一个组件，可以作为保存临时取还对象的一个“池子”，可以缓存暂时不用的对象，下次需要时直接使用（无需重新分配）。</p><blockquote><p>因为频繁的内存分配和回收会对性能产生影响，通过复用临时对象就可以避免改问题。</p></blockquote><p>下面是 2018 年的时候，《Go 夜读》上关于 <code>sync.Pool</code> 的分享，关于适用场景：</p><blockquote><p>当多个 goroutine 都需要创建同⼀个对象的时候，如果 goroutine 数过多，导致对象的创建数⽬剧增，进⽽导致 GC 压⼒增大。形成 “并发⼤－占⽤内存⼤－GC 缓慢－处理并发能⼒降低－并发更⼤”这样的恶性循环。 在这个时候，需要有⼀个对象池，每个 goroutine 不再⾃⼰单独创建对象，⽽是从对象池中获取出⼀个对象（如果池中已经有的话）。</p></blockquote><p>因此关键思想就是对象的复用，避免重复创建、销毁，下面我们来看看如何使用。</p><p>所以，sync.pool 的作用一句话描述就是，<strong>复用临时对象，以避免频繁的内存分配和回收，从而减少 GC 压力</strong>。</p><h3 id="1-2-基本使用"><a href="#1-2-基本使用" class="headerlink" title="1.2 基本使用"></a>1.2 基本使用</h3><p>首先，<code>sync.Pool</code> 是协程安全的，这对于使用者来说是极其方便的。使用前，设置好对象的 <code>New</code> 函数，用于在 <code>Pool</code> 里没有缓存的对象时，创建一个。之后，在程序的任何地方、任何时候仅通过 <code>Get()</code>、<code>Put()</code> 方法就可以取、还对象了。</p><p>以下为基本使用 demo：</p><blockquote><p>完整代码见 <a href="#">Github</a><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> main  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">   <span class="string">&quot;sync&quot;</span>  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> Gopher <span class="keyword">struct</span> &#123;  </span><br><span class="line">   Name   <span class="type">string</span>  </span><br><span class="line">   Remark [<span class="number">1024</span>]<span class="type">byte</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Gopher)</span></span> Reset() &#123;  </span><br><span class="line">   s.Name = <span class="string">&quot;&quot;</span>  </span><br><span class="line">   s.Remark = [<span class="number">1024</span>]<span class="type">byte</span>&#123;&#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">var</span> gopherPool = sync.Pool&#123;  </span><br><span class="line">   New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">new</span>(Gopher)  </span><br><span class="line">   &#125;,  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   g := gopherPool.Get().(*Gopher)  </span><br><span class="line">   fmt.Println(<span class="string">&quot;首次从 pool 里获取：&quot;</span>, g.Name)  </span><br><span class="line"> ​  </span><br><span class="line">   g.Name = <span class="string">&quot;first&quot;</span>  </span><br><span class="line">   fmt.Printf(<span class="string">&quot;设置 p.Name = %s\n&quot;</span>, g.Name)  </span><br><span class="line">   gopherPool.Put(g)  </span><br><span class="line"> ​  </span><br><span class="line">   fmt.Println(<span class="string">&quot;Pool 里已有一个对象：&amp;&#123;first&#125;，调用 Get: &quot;</span>, gopherPool.Get().(*Gopher).Name)  </span><br><span class="line">   fmt.Println(<span class="string">&quot;Pool 没有对象了，调用 Get: &quot;</span>, gopherPool.Get().(*Gopher).Name)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>运行结果：<br> 首次从 pool 里获取：<br> 设置 p.Name = first<br> Pool 里已有一个对象：&amp;{first}，调用 Get:  first<br> Pool 没有对象了，调用 Get:<br>首先，需要初始化 <code>Pool</code>，唯一需要的就是设置好 <code>New</code> 函数。当调用 Get 方法时，如果池子里缓存了对象，就直接返回缓存的对象。如果没有存货，则调用 New 函数创建一个新的对象。</p></blockquote><p>另外，我们发现 Get 方法取出来的对象和上次 Put 进去的对象实际上是同一个，Pool 没有做任何“清空”的处理。但我们不应当对此有任何假设，因为在实际的并发使用场景中，无法保证这种顺序，<strong>最好的做法是在 Put 前，将对象清空</strong>。</p><p><strong>Benchmark</strong><br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> defaultGopher, _ = json.Marshal(Gopher&#123;Name: <span class="string">&quot;17x&quot;</span>&#125;)  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">BenchmarkUnmarshal</span><span class="params">(b *testing.B)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">var</span> g *Gopher  </span><br><span class="line">   <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;  </span><br><span class="line">     g = <span class="built_in">new</span>(Gopher)  </span><br><span class="line">     json.Unmarshal(defaultGopher, g)  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">BenchmarkUnmarshalWithPool</span><span class="params">(b *testing.B)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">var</span> g *Gopher  </span><br><span class="line">   <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;  </span><br><span class="line">     g = gopherPool.Get().(*Gopher)  </span><br><span class="line">     json.Unmarshal(defaultGopher, g)  </span><br><span class="line">     g.Reset() <span class="comment">// 重置后在放进去  </span></span><br><span class="line">     gopherPool.Put(g)  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure><br> ​<br>运行结果：</p><p> BenchmarkUnmarshal-6                9518            124806 ns/op            1280 B/op          6 allocs/op<br> BenchmarkUnmarshalWithPool-6       10000            124350 ns/op             128 B/op          5 allocs/op<br> <code>3287449 357 ns/op</code> 表示单位时间内（默认是1s）被测函数运行了 3287449 次，每次运行耗时 357ns，<br> <code>B/op</code> 是每个操作分配的字节数<br> <code>allocs/op</code> 表示每个操作(单次迭代)发生了多少不同的内存分配。</p><p>功能比较简单，其中 json 反序列化占用了大量时间，因此两种方式最终的执行时间几乎没什么变化。但是内存占用差了一个数量级，使用了 <code>sync.Pool</code> 后，内存占用仅为未使用的 128/1280=1/10，对 GC 的影响就很大了。</p><h3 id="1-3-使用案例"><a href="#1-3-使用案例" class="headerlink" title="1.3 使用案例"></a>1.3 使用案例</h3><h4 id="1-3-1-fmt-包"><a href="#1-3-1-fmt-包" class="headerlink" title="1.3.1 fmt 包"></a>1.3.1 fmt 包</h4><p>这部分主要看 <code>fmt.Printf</code> 如何使用：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Printf</span><span class="params">(format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;  </span><br><span class="line">   <span class="keyword">return</span> Fprintf(os.Stdout, format, a...)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>继续看 <code>Fprintf</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Fprintf</span><span class="params">(w io.Writer, format <span class="type">string</span>, a ...<span class="keyword">interface</span>&#123;&#125;)</span></span> (n <span class="type">int</span>, err <span class="type">error</span>) &#123;  </span><br><span class="line">   p := newPrinter()  </span><br><span class="line">   p.doPrintf(format, a)  </span><br><span class="line">   n, err = w.Write(p.buf)  </span><br><span class="line">   p.free()  </span><br><span class="line">   <span class="keyword">return</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br><code>Fprintf</code> 函数的参数是一个 <code>io.Writer</code>，<code>Printf</code> 传的是 <code>os.Stdout</code>，相当于直接输出到标准输出。这里的 <code>newPrinter</code> 用的就是 Pool：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> ppFree = sync.Pool&#123;  </span><br><span class="line">   New: <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123; <span class="keyword">return</span> <span class="built_in">new</span>(pp) &#125;,  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">newPrinter</span><span class="params">()</span></span> *pp &#123;  </span><br><span class="line">   p := ppFree.Get().(*pp)  </span><br><span class="line">   p.panicking = <span class="literal">false</span>  </span><br><span class="line">   p.erroring = <span class="literal">false</span>  </span><br><span class="line">   p.wrapErrs = <span class="literal">false</span>  </span><br><span class="line">   p.fmt.init(&amp;p.buf)  </span><br><span class="line">   <span class="keyword">return</span> p  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>回到 <code>Fprintf</code> 函数，拿到 pp 指针后，会做一些 format 的操作，并且将 p.buf 里面的内容写入 w。最后，调用 free 函数，将 pp 指针归还到 Pool 中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(p *pp)</span></span> free() &#123;  </span><br><span class="line">   <span class="keyword">if</span> <span class="built_in">cap</span>(p.buf) &gt; <span class="number">64</span>&lt;&lt;<span class="number">10</span> &#123;  </span><br><span class="line">     <span class="keyword">return</span>  </span><br><span class="line">   &#125;  </span><br><span class="line"> ​  </span><br><span class="line">   p.buf = p.buf[:<span class="number">0</span>]  </span><br><span class="line">   p.arg = <span class="literal">nil</span>  </span><br><span class="line">   p.value = reflect.Value&#123;&#125;  </span><br><span class="line">   p.wrappedErr = <span class="literal">nil</span>  </span><br><span class="line">   ppFree.Put(p)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><br>归还到 Pool 前还进行了<strong>字段清零</strong>，这样，通过 Get 拿到缓存的对象时，就可以安全地使用了。</p><h4 id="1-3-2-gin-框架"><a href="#1-3-2-gin-框架" class="headerlink" title="1.3.2 gin 框架"></a>1.3.2 gin 框架</h4><p>gin 框架会给每个请求分配一个 Context 用以进行追踪，这就是典型的 sync.pool 使用场景：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">()</span></span> *Engine &#123;  </span><br><span class="line">engine := &amp;Engine&#123;  </span><br><span class="line">  </span><br><span class="line">&#125;  </span><br><span class="line">engine.pool.New = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line"><span class="keyword">return</span> engine.allocateContext()  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> engine  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> allocateContext() *Context &#123;  </span><br><span class="line"><span class="keyword">return</span> &amp;Context&#123;engine: engine&#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(engine *Engine)</span></span> ServeHTTP(w http.ResponseWriter, req *http.Request) &#123;  </span><br><span class="line">c := engine.pool.Get().(*Context)  </span><br><span class="line">c.writermem.reset(w)  </span><br><span class="line">c.Request = req  </span><br><span class="line">c.reset()  </span><br><span class="line">  </span><br><span class="line">engine.handleHTTPRequest(c)  </span><br><span class="line">  </span><br><span class="line">engine.pool.Put(c)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从 pool 中获取 Context 对象，用完后又还回去，注意 还回去之前这里也调用了 reset() 方法进行<strong>字段清空</strong>。</p><h3 id="1-4-正确姿势"><a href="#1-4-正确姿势" class="headerlink" title="1.4 正确姿势"></a>1.4 正确姿势</h3><p>根据以上几个案例，可以看出正确使用姿势就是：</p><ul><li><p>1）设置 New 方法</p></li><li><p>2）使用时直接 Get</p></li><li><p>3）使用完成后先进行<strong>字段清空</strong>,然后在 Put 回去。</p></li></ul><blockquote><p>一定要进行 Reset，不然会出现意想不到的问题。分享一个<a href="https://github.com/lixd/daily-notes/blob/master/Golang/FAQ/mongodb%E9%87%87%E5%9D%91.md">类似的坑</a></p></blockquote><h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h2><blockquote><p>一下分析基于 Go 1.17.1</p></blockquote><h3 id="2-1-Pool-结构体"><a href="#2-1-Pool-结构体" class="headerlink" title="2.1 Pool 结构体"></a>2.1 Pool 结构体</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;  </span><br><span class="line">noCopy noCopy  </span><br><span class="line">local     unsafe.Pointer <span class="comment">// local fixed-size per-P pool, actual type is [P]poolLocal  </span></span><br><span class="line">localSize <span class="type">uintptr</span>        <span class="comment">// size of the local array  </span></span><br><span class="line">victim     unsafe.Pointer <span class="comment">// local from previous cycle  </span></span><br><span class="line">victimSize <span class="type">uintptr</span>        <span class="comment">// size of victims array  </span></span><br><span class="line">New <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="keyword">interface</span>&#123;&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段详解：</p><ul><li><code>noCopy</code>对象，实现了<code>sync.Locker</code>接口，使得内嵌了 noCopy 的对象在进行 go vet 静态检查的时候，可以检查出是否被复制。<ul><li>具体见 <a href="https://github.com/golang/go/issues/8005">Go issues 8005</a></li><li>说明 Pool 对象也是不允许复制的。</li></ul></li><li><code>local</code> 字段存储指向 <code>[P]poolLocal</code> 数组（严格来说，它是一个切片）的指针。<code>localSize</code> 则表示 local 数组的大小。<ul><li>访问时，根据 P 的 id 去访问对应下标的 <code>local[pid]</code></li><li>通过这样的设计，多个 goroutine 使用同一个 Pool 时，减少了竞争，提升了性能。</li><li>有点类似于降低锁粒度，分段锁的思想。</li></ul></li><li><code>victim</code> 和 <code>victimSize</code> 则会在在一轮 GC 到来时，分别“接管” local 和 localSize。<ul><li>victim cache 是一种提高缓存性能的硬件技术;</li><li><code>victim</code> 的机制用于减少 GC 后冷启动导致的性能抖动，让分配对象更平滑;</li></ul></li><li><code>New</code>就是我们指定的新建对象的方法。</li></ul><blockquote><p><a href="https://en.wikipedia.org/wiki/Victim_cache">Victim Cache</a> 是一种提高缓存性能的硬件技术，主要用于提升缓存命令率。<br>所谓受害者缓存（Victim Cache），是一个与直接匹配或低相联缓存并用的、容量很小的全相联缓存。当一个数据块被逐出缓存时，并不直接丢弃，而是暂先进入受害者缓存。如果受害者缓存已满，就替换掉其中一项。当进行缓存标签匹配时，在与索引指向标签匹配的同时，并行查看受害者缓存，如果在受害者缓存发现匹配，就将其此数据块与缓存中的不匹配数据块做交换，同时返回给处理器。</p></blockquote><h4 id="2-1-1-local"><a href="#2-1-1-local" class="headerlink" title="2.1.1 local"></a>2.1.1 local</h4><p>local 具体结构如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolLocal <span class="keyword">struct</span> &#123;  </span><br><span class="line">poolLocalInternal  </span><br><span class="line">    <span class="comment">// 将 poolLocal 补齐至128字节(即两个cache line)的倍数，防止 false sharing,  </span></span><br><span class="line">    <span class="comment">// 伪共享，仅占位用，防止在 cache line 上分配多个 poolLocalInternal  </span></span><br><span class="line">pad [<span class="number">128</span> - unsafe.Sizeof(poolLocalInternal&#123;&#125;)%<span class="number">128</span>]<span class="type">byte</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">type</span> poolLocalInternal <span class="keyword">struct</span> &#123;  </span><br><span class="line">private <span class="keyword">interface</span>&#123;&#125; <span class="comment">// Can be used only by the respective P.  </span></span><br><span class="line">shared  poolChain   <span class="comment">// Local P can pushHead/popHead; any P can popTail.  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>poolLocalInternal</code>对象 中包含一个 <code>private</code> 和 <code>shared</code>。其中 private 只有当前 p 能用，shared 则是其他 p 都可以用。</p><h4 id="2-1-2-cpu-cache-amp-false-sharing"><a href="#2-1-2-cpu-cache-amp-false-sharing" class="headerlink" title="2.1.2 cpu cache &amp; false sharing"></a>2.1.2 cpu cache &amp; false sharing</h4><p><strong>cpu cache</strong><br>现代 cpu 中，cache 都划分成以 cache line (cache block) 为单位，在 x86_64 体系下一般都是 64 字节，cache line 是操作的最小单元。 程序即使只想读内存中的 1 个字节数据，也要同时把附近 63 节字加载到 cache 中，如果读取超个 64 字节，那么就要加载到多个 cache line 中。<br>这样，访问后续 63 字节数据时就可以直接从 cache line 中读取，性能有很大提升。</p><p><strong><a href="https://en.wikipedia.org/wiki/False_sharing">false sharing</a></strong></p><blockquote><p>伪共享的非标准定义为：缓存系统中是以缓存行（cache line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量共享同一个缓存行，就会令整个 cache line 失效，无意中影响彼此的性能，这就是伪共享。</p></blockquote><p>简单来说，如果没有 pad 字段，那么当需要访问 0 号索引的 poolLocal 时，CPU 同时会把 0 号和 1 号索引同时加载到 cpu cache。在只修改 0 号索引的情况下，会让 1 号索引的 poolLocal 失效。这样，当其他线程想要读取 1 号索引时，发生 cache miss，还得重新再加载，对性能有损。增加一个 <code>pad</code>，补齐缓存行，让相关的字段能独立地加载到缓存行就不会出现 <code>false sharding</code> 了。</p><h4 id="2-1-3-poolChain"><a href="#2-1-3-poolChain" class="headerlink" title="2.1.3 poolChain"></a>2.1.3 poolChain</h4><p><code>poolChain</code> 是一个双端队列的实现<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> poolChain <span class="keyword">struct</span> &#123;  </span><br><span class="line">  </span><br><span class="line">   head *poolChainElt  </span><br><span class="line">  </span><br><span class="line">   tail *poolChainElt  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> poolChainElt <span class="keyword">struct</span> &#123;  </span><br><span class="line">poolDequeue  </span><br><span class="line">  </span><br><span class="line">next, prev *poolChainElt  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">type</span> poolDequeue <span class="keyword">struct</span> &#123;  </span><br><span class="line">  </span><br><span class="line">headTail <span class="type">uint64</span>  </span><br><span class="line">  </span><br><span class="line">vals []eface  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><code>poolDequeue</code> 被实现为单生产者、多消费者的固定大小的无锁（atomic 实现） Ring 式队列（底层存储使用数组，使用两个指针标记 head、tail）。生产者可以从 head 插入、head 删除，而消费者仅可从 tail 删除。 <code>headTail</code> 指向队列的头和尾，通过位运算将 head 和 tail 存入 headTail 变量中。</p><p>我们用一幅图来完整地描述 Pool 结构体：</p><p>![[pool-structure.png]]</p><blockquote><p>图源：<a href="https://zhuanlan.zhihu.com/p/133638023">码农桃花源</a></p><h3 id="2-2-大致流程"><a href="#2-2-大致流程" class="headerlink" title="2.2 大致流程"></a>2.2 大致流程</h3></blockquote><p>分析完 Pool 结构体之后，先提前说明一下大致的流程，后续分析时便于理解。</p><p><strong>存储</strong></p><p>为每个 P 开辟了一个 Local 用于数据，降低竞争。</p><p>Local 中包含 private 和 shared。</p><ul><li><p>private ：只有当前 P 能使用</p></li><li><p>shared：所有 P 共享，当 private 没有时优先去当前 P 的 local.shared 中取，如果还没有就去其他 P 中 local.shared 中窃取一个来用。</p></li></ul><p><strong>Get</strong></p><p>优先从当前P 的 local.private 中取，没有则从当前 P 的 local.shared 中取，还没有则去其他 P 中 local.shared 中窃取一个。</p><p><strong>Put</strong></p><p>优先存放到当前 P 的 local.private，local.private 已经有值了就往 shared 中放。</p><h3 id="2-3-Get"><a href="#2-3-Get" class="headerlink" title="2.3 Get"></a>2.3 Get</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Get() <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">l, pid := p.pin()  </span><br><span class="line">x := l.private  </span><br><span class="line">l.private = <span class="literal">nil</span>  </span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;  </span><br><span class="line">x, _ = l.shared.popHead()  </span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;  </span><br><span class="line">x = p.getSlow(pid)  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">runtime_procUnpin()  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &amp;&amp; p.New != <span class="literal">nil</span> &#123;  </span><br><span class="line">x = p.New()  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> x  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程如下：</p><ol><li><p>首先，调用 <code>p.pin()</code> 函数将当前的 goroutine 和 P 绑定，禁止被抢占，返回当前 P 对应的 poolLocal，以及 pid。</p></li><li><p>然后直接取 l.private，赋值给 x，并置 l.private 为 nil。</p></li><li><p>判断 x 是否为空，若为空，则尝试从 l.shared 的头部 pop 一个对象出来，同时赋值给 x。</p></li><li><p>如果 x 仍然为空，则调用 getSlow 尝试从其他 P 的 shared 双端队列尾部“偷”一个对象出来。</p></li><li><p>Pool 的相关操作做完了，调用 <code>runtime_procUnpin()</code> 解除禁止抢占。</p></li><li><p>最后如果还是没有取到缓存的对象，那就直接调用预先设置好的 New 函数，创建一个出来。</p></li></ol><h4 id="2-3-1-pin"><a href="#2-3-1-pin" class="headerlink" title="2.3.1 pin"></a>2.3.1 pin</h4><p>首先，调用 <code>p.pin()</code> 函数将当前的 goroutine 和 P 绑定，禁止被抢占，返回当前 P 对应的 poolLocal，以及 pid。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pin() (*poolLocal, <span class="type">int</span>) &#123;  </span><br><span class="line">   <span class="comment">// pin 具体逻辑由 runtime_procPin 实现  </span></span><br><span class="line">   pid :=  runtime_procPin()  </span><br><span class="line">   <span class="comment">// 原子操作取出 p.localSize 和 p.local  </span></span><br><span class="line">   s := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire  </span></span><br><span class="line">   l := p.local                              <span class="comment">// load-consume  </span></span><br><span class="line">   <span class="comment">// 因为是把 pid 做下标从 pool.local 中取得 p 对应的 local 的，  </span></span><br><span class="line">   <span class="comment">// 所以如果 pid 小于 pool.local size 的时候才有可能取到对应的 local  </span></span><br><span class="line">   <span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;  </span><br><span class="line">      <span class="keyword">return</span> indexLocal(l, pid), pid  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="comment">// 正常情况下会一直满足该条件，  </span></span><br><span class="line">   <span class="comment">// 只有刚开始  pool.local 还没创建或者动态调整了 P 的数量这两种情况  </span></span><br><span class="line">   <span class="comment">// 会进入到下面的逻辑 去创建 pool.local  </span></span><br><span class="line">   <span class="keyword">return</span> p.pinSlow()  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-3-2-pinSlow"><a href="#2-3-2-pinSlow" class="headerlink" title="2.3.2 pinSlow"></a>2.3.2 pinSlow</h4><p>pinSlow 主要是完成 pool.local 的创建。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> pinSlow() (*poolLocal, <span class="type">int</span>) &#123;  </span><br><span class="line">    <span class="comment">// 这里先取消绑定，然后加锁，最后有绑定上  </span></span><br><span class="line">runtime_procUnpin()  </span><br><span class="line">allPoolsMu.Lock()  </span><br><span class="line"><span class="keyword">defer</span> allPoolsMu.Unlock()  </span><br><span class="line">pid := runtime_procPin()  </span><br><span class="line"><span class="comment">// doubleCheck 因为在执行上述命令过程中 pinSlow 可能已经被其他的线程调用，因此这时候需要再次对 pid 进行检查  </span></span><br><span class="line">s := p.localSize  </span><br><span class="line">l := p.local  </span><br><span class="line"><span class="keyword">if</span> <span class="type">uintptr</span>(pid) &lt; s &#123;  </span><br><span class="line"><span class="keyword">return</span> indexLocal(l, pid), pid  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> p.local == <span class="literal">nil</span> &#123;  </span><br><span class="line">allPools = <span class="built_in">append</span>(allPools, p)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 根据当前 P 的数量创建 pool.local并更新pool.localSize  </span></span><br><span class="line">size := runtime.GOMAXPROCS(<span class="number">0</span>)  </span><br><span class="line">local := <span class="built_in">make</span>([]poolLocal, size)  </span><br><span class="line">atomic.StorePointer(&amp;p.local, unsafe.Pointer(&amp;local[<span class="number">0</span>])) <span class="comment">// store-release  </span></span><br><span class="line">runtime_StoreReluintptr(&amp;p.localSize, <span class="type">uintptr</span>(size))     <span class="comment">// store-release  </span></span><br><span class="line">    <span class="comment">// 最后根据 pid 返回当前 P 对应的 local  </span></span><br><span class="line"><span class="keyword">return</span> &amp;local[pid], pid  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### popHead</span><br><span class="line"></span><br><span class="line">然后回到 Get 方法</span><br><span class="line">```go</span><br><span class="line">x := l.private  </span><br><span class="line">l.private = nil  </span><br><span class="line">if x == nil &#123;  </span><br><span class="line">x, _ = l.shared.popHead()  </span><br><span class="line">if x == nil &#123;  </span><br><span class="line">x = p.getSlow(pid)  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">优先从 local.private 中取，如果没有就调用`poolChain.popHead()`去 local.shared 中取一个。</span><br><span class="line">```go</span><br><span class="line">func (c *poolChain) popHead() (interface&#123;&#125;, bool) &#123;  </span><br><span class="line">d := c.head  </span><br><span class="line">for d != nil &#123;  </span><br><span class="line">if val, ok := d.popHead(); ok &#123;  </span><br><span class="line">return val, ok  </span><br><span class="line">&#125;  </span><br><span class="line">d = loadPoolChainElt(&amp;d.prev)  </span><br><span class="line">&#125;  </span><br><span class="line">return nil, false  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`popHead` 函数只会被 producer 调用。首先拿到头节点：c.head，如果头节点不为空的话，尝试调用头节点的 `poolDequeue.popHead` 方法。</span><br><span class="line">```go</span><br><span class="line">func (d *poolDequeue) popHead() (interface&#123;&#125;, bool) &#123;  </span><br><span class="line">var slot *eface  </span><br><span class="line">for &#123;  </span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">head, tail := d.unpack(ptrs)  </span><br><span class="line">        // 收尾相连则说明队列是空的  </span><br><span class="line">if tail == head &#123;  </span><br><span class="line">return nil, false  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// head 位置是队头的前一个位置，所以此处要先退一位。  </span><br><span class="line">        // 在读出 slot 的 value 之前就把 head 值减 1，取消对这个 slot 的控制  </span><br><span class="line">head--  </span><br><span class="line">ptrs2 := d.pack(head, tail)  </span><br><span class="line">        // 通过 CAS 操作更新头部的位置 这样当前头部第一个元素就算是被移除了  </span><br><span class="line">if atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;  </span><br><span class="line">slot = &amp;d.vals[head&amp;uint32(len(d.vals)-1)]  </span><br><span class="line">break  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">    // 类型转换与 nil 判断  </span><br><span class="line">val := *(*interface&#123;&#125;)(unsafe.Pointer(slot))  </span><br><span class="line">if val == dequeueNil(nil) &#123;  </span><br><span class="line">val = nil  </span><br><span class="line">&#125;  </span><br><span class="line">    // 然后把这个 slot 置空，因为现在这个 slot 已经是队列的 head 了，置空便于前一个 head 被回收。  </span><br><span class="line">*slot = eface&#123;&#125;  </span><br><span class="line">return val, true  </span><br><span class="line">&#125;```</span><br></pre></td></tr></table></figure><p>此函数会删掉并且返回 <code>queue</code> 的头节点。但如果 <code>queue</code> 为空的话，返回 false。这里的 <code>queue</code> 存储的实际上就是 Pool 里缓存的对象。</p><p>整个函数的核心是一个无限循环，这是 Go 中常用的无锁化编程形式。</p><p>首先调用 unpack 函数分离出 head 和 tail 指针，如果 head 和 tail 相等，即首尾相等，那么这个队列就是空的，直接就返回 nil，false。</p><p>否则，将 head 指针后移一位，即 head 值减 1，然后调用 pack 打包 head 和 tail 指针。使用 CAS 更新 headTail 的值，并且把 vals 相应索引处的元素赋值给 slot。</p><blockquote><p>因为 <code>vals</code> 长度实际是只能是 2 的 n 次幂，因此 <code>len(d.vals)-1</code> 实际上得到的值的低 n 位是全 1，它再与 head 进行与运算，实际就是取 head 低 n 位的值作为下标。</p></blockquote><p>得到相应 slot 的元素后，经过类型转换并判断是否是 <code>dequeueNil</code>，如果是，说明没取到缓存的对象，返回 nil。</p><p>type dequeueNil *struct{}</p><p>最后，返回 val 之前，将 slot “归零”，移除和上一个 head 的关联，便于回收上一个 Head。</p><p>*slot = eface{}</p><p>结束后回到 <code>poolChain.popHead()</code>，如果调用 <code>poolDequeue.popHead()</code> 拿到了缓存的对象，就直接返回。否则，将 <code>d</code> 重新指向 <code>d.prev</code>，继续尝试获取缓存的对象。</p><h4 id="2-3-3-getSlow"><a href="#2-3-3-getSlow" class="headerlink" title="2.3.3 getSlow"></a>2.3.3 getSlow</h4><p>如果在 shared 里没有获取到缓存对象，则继续调用 <code>Pool.getSlow()</code>，尝试从其他 P 的 poolLocal 偷取：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> getSlow(pid <span class="type">int</span>) <span class="keyword">interface</span>&#123;&#125; &#123;  </span><br><span class="line">size := runtime_LoadAcquintptr(&amp;p.localSize) <span class="comment">// load-acquire  </span></span><br><span class="line">locals := p.local                            <span class="comment">// load-consume  </span></span><br><span class="line">    <span class="comment">// 尝试从其他 p 中窃取一个对象  </span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;  </span><br><span class="line">        <span class="comment">// (pid+i+1)%int(size) 保证每次都可以从 当前pid+1 这个位置开始尝试窃取。  </span></span><br><span class="line">l := indexLocal(locals, (pid+i+<span class="number">1</span>)%<span class="type">int</span>(size))  </span><br><span class="line">        <span class="comment">// 如果能取到就直接返回  </span></span><br><span class="line"><span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> x  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 尝试从其他 P 的 poolLocal 窃取失败后，再尝试从victim cache中取对象  </span></span><br><span class="line">    <span class="comment">// 这样可以使 victim 中的对象更容易被回收。  </span></span><br><span class="line">size = atomic.LoadUintptr(&amp;p.victimSize)  </span><br><span class="line"><span class="keyword">if</span> <span class="type">uintptr</span>(pid) &gt;= size &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">locals = p.victim  </span><br><span class="line">l := indexLocal(locals, pid)  </span><br><span class="line"><span class="keyword">if</span> x := l.private; x != <span class="literal">nil</span> &#123;  </span><br><span class="line">l.private = <span class="literal">nil</span>  </span><br><span class="line"><span class="keyword">return</span> x  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="type">int</span>(size); i++ &#123;  </span><br><span class="line">l := indexLocal(locals, (pid+i)%<span class="type">int</span>(size))  </span><br><span class="line"><span class="keyword">if</span> x, _ := l.shared.popTail(); x != <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> x  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 清空 victim cache。下次就不用再从这里找了  </span></span><br><span class="line">atomic.StoreUintptr(&amp;p.victimSize, <span class="number">0</span>)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line">&#125;<span class="string">``</span><span class="string">`</span></span><br></pre></td></tr></table></figure></p><p>从索引为 pid+1 的 poolLocal 处开始，尝试调用 <code>shared.popTail()</code> 获取缓存对象。如果没有拿到，则从 victim 里找，和 poolLocal 的逻辑类似。</p><p>最后，实在没找到，就把 victimSize 置 0，防止后来的“人”再到 victim 里找。</p><p>在 Get 函数的最后，经过这一番操作还是没找到缓存的对象，就调用 New 函数创建一个新的对象。</p><h4 id="2-3-4-popTail"><a href="#2-3-4-popTail" class="headerlink" title="2.3.4 popTail"></a>2.3.4 popTail</h4><p>最后，还剩一个 popTail 函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> popTail() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;  </span><br><span class="line">    <span class="comment">// tail 指针为空直接返回 这里的 tail 是一个双端队列  </span></span><br><span class="line">d := loadPoolChainElt(&amp;c.tail)  </span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> &#123;  </span><br><span class="line"><span class="comment">// It&#x27;s important that we load the next pointer  </span></span><br><span class="line"><span class="comment">// *before* popping the tail. In general, d may be  </span></span><br><span class="line"><span class="comment">// transiently empty, but if next is non-nil before  </span></span><br><span class="line"><span class="comment">// the pop and the pop fails, then d is permanently  </span></span><br><span class="line"><span class="comment">// empty, which is the only condition under which it&#x27;s  </span></span><br><span class="line"><span class="comment">// safe to drop d from the chain.  </span></span><br><span class="line">        <span class="comment">// 在 for 循环的一开始，就把 d.next 加载到了 d2。因为 d 可能会短暂为空，但如果 d2 在 pop 或者 pop fails 之前就不为空的话，说明 d 就会永久为空了。在这种情况下，可以安全地将 d 这个结点“甩掉”。  </span></span><br><span class="line">d2 := loadPoolChainElt(&amp;d.next)  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> val, ok := d.popTail(); ok &#123;  </span><br><span class="line"><span class="keyword">return</span> val, ok  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> d2 == <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="comment">// This is the only dequeue. It&#x27;s empty right  </span></span><br><span class="line"><span class="comment">// now, but could be pushed to in the future.  </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 同样的通过 CAS 来更新 tail 的值为 d2  </span></span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapPointer((*unsafe.Pointer)(unsafe.Pointer(&amp;c.tail)), unsafe.Pointer(d), unsafe.Pointer(d2)) &#123;  </span><br><span class="line">storePoolChainElt(&amp;d2.prev, <span class="literal">nil</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">        <span class="comment">// 最后将d2赋值给d便于进行下一轮循环。  </span></span><br><span class="line">d = d2  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></p><p>在 for 循环的一开始，就把 d.next 加载到了 d2。因为 d 可能会短暂为空，但如果 d2 在 pop 或者 pop fails 之前就不为空的话，说明 d 就会永久为空了。在这种情况下，可以安全地将 d 这个结点“甩掉”。</p><p>最后，将 c.tail 更新为 d2，可以防止下次 popTail 的时候查看一个空的 dequeue；而将 d2.prev 设置为 nil，可以防止下次 popHead 时查看一个空的 dequeue。</p><p>我们再看一下核心的 <code>poolDequeue.popTail</code>：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popTail() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;  </span><br><span class="line"><span class="keyword">var</span> slot *eface  </span><br><span class="line"><span class="keyword">for</span> &#123;  </span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">head, tail := d.unpack(ptrs)  </span><br><span class="line">        <span class="comment">// 同样的 head=tail 说明队列为空  </span></span><br><span class="line"><span class="keyword">if</span> tail == head &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 同样是 CAS 更新 headTail 以移除 tail 元素  </span></span><br><span class="line">ptrs2 := d.pack(head, tail+<span class="number">1</span>)  </span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;  </span><br><span class="line"><span class="comment">// Success.  </span></span><br><span class="line">slot = &amp;d.vals[tail&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]  </span><br><span class="line"><span class="keyword">break</span>  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 类型转换和 nil 判断  </span></span><br><span class="line">val := *(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot))  </span><br><span class="line"><span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;  </span><br><span class="line">val = <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 最后也是将这个 slot 置空  </span></span><br><span class="line">    <span class="comment">// 先清空 val 再清空 typ 操作顺序和 pushHead 正好相反  </span></span><br><span class="line">slot.val = <span class="literal">nil</span>  </span><br><span class="line">atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">true</span>  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> popTail() (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;  </span><br><span class="line"><span class="keyword">var</span> slot *eface  </span><br><span class="line"><span class="keyword">for</span> &#123;  </span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">head, tail := d.unpack(ptrs)  </span><br><span class="line">        <span class="comment">// 同样的 head=tail 说明队列为空  </span></span><br><span class="line"><span class="keyword">if</span> tail == head &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 同样是 CAS 更新 headTail 以移除 tail 元素  </span></span><br><span class="line">ptrs2 := d.pack(head, tail+<span class="number">1</span>)  </span><br><span class="line"><span class="keyword">if</span> atomic.CompareAndSwapUint64(&amp;d.headTail, ptrs, ptrs2) &#123;  </span><br><span class="line"><span class="comment">// Success.  </span></span><br><span class="line">slot = &amp;d.vals[tail&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]  </span><br><span class="line"><span class="keyword">break</span>  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 类型转换和 nil 判断  </span></span><br><span class="line">val := *(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot))  </span><br><span class="line"><span class="keyword">if</span> val == dequeueNil(<span class="literal">nil</span>) &#123;  </span><br><span class="line">val = <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 最后也是将这个 slot 置空  </span></span><br><span class="line">    <span class="comment">// 先清空 val 再清空 typ 操作顺序和 pushHead 正好相反  </span></span><br><span class="line">slot.val = <span class="literal">nil</span>  </span><br><span class="line">atomic.StorePointer(&amp;slot.typ, <span class="literal">nil</span>)  </span><br><span class="line"><span class="keyword">return</span> val, <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整体逻辑和 popHead 差不多。</p><h4 id="2-3-5-小结"><a href="#2-3-5-小结" class="headerlink" title="2.3.5 小结"></a>2.3.5 小结</h4><p>首先从 当前 p 对应的 local.private 上取，没有就从 local.shared 里取，还没有就去其他 p 的 local.shared 里取，都没有就 new 一个返回。</p><h3 id="2-4-Put"><a href="#2-4-Put" class="headerlink" title="2.4 Put"></a>2.4 Put</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span></span> Put(x <span class="keyword">interface</span>&#123;&#125;) &#123;  </span><br><span class="line"><span class="keyword">if</span> x == <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="keyword">return</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">l, _ := p.pin()  </span><br><span class="line"><span class="keyword">if</span> l.private == <span class="literal">nil</span> &#123;  </span><br><span class="line">l.private = x  </span><br><span class="line">x = <span class="literal">nil</span>  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span> x != <span class="literal">nil</span> &#123;  </span><br><span class="line">l.shared.pushHead(x)  </span><br><span class="line">&#125;  </span><br><span class="line">runtime_procUnpin()  </span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>流程也比较简单：</p><ol><li>先绑定 g 和 P，然后尝试将 x 赋值给 private 字段。</li><li>如果失败，就调用 <code>pushHead</code> 方法尝试将其放入 shared 字段所维护的双端队列中。<h4 id="2-4-1-pushHead"><a href="#2-4-1-pushHead" class="headerlink" title="2.4.1 pushHead"></a>2.4.1 pushHead</h4></li></ol><p>p.pin() 和之前是一样的，就不分析了，主要看一下 pushHead()<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *poolChain)</span></span> pushHead(val <span class="keyword">interface</span>&#123;&#125;) &#123;  </span><br><span class="line">d := c.head  </span><br><span class="line"><span class="keyword">if</span> d == <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="comment">// 第一次写入，队列为空则进行初始化 默认长度为8  </span></span><br><span class="line"><span class="keyword">const</span> initSize = <span class="number">8</span> <span class="comment">// Must be a power of 2  </span></span><br><span class="line">d = <span class="built_in">new</span>(poolChainElt)  </span><br><span class="line">d.vals = <span class="built_in">make</span>([]eface, initSize)  </span><br><span class="line">c.head = d  </span><br><span class="line">storePoolChainElt(&amp;c.tail, d)  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 存储元素 存储成功直接返回  </span></span><br><span class="line"><span class="keyword">if</span> d.pushHead(val) &#123;  </span><br><span class="line"><span class="keyword">return</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// The current dequeue is full. Allocate a new one of twice  </span></span><br><span class="line"><span class="comment">// the size.  </span></span><br><span class="line">    <span class="comment">// 存储失败说明队列满了 进行扩容  </span></span><br><span class="line">newSize := <span class="built_in">len</span>(d.vals) * <span class="number">2</span>  </span><br><span class="line"><span class="keyword">if</span> newSize &gt;= dequeueLimit &#123; <span class="comment">// 限制一下，不能无限扩容  </span></span><br><span class="line">newSize = dequeueLimit  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">// 扩容逻辑也比较简单，就是首尾相连，构成链表  </span></span><br><span class="line">d2 := &amp;poolChainElt&#123;prev: d&#125;  </span><br><span class="line">d2.vals = <span class="built_in">make</span>([]eface, newSize)  </span><br><span class="line">c.head = d2  </span><br><span class="line">storePoolChainElt(&amp;d.next, d2)  </span><br><span class="line">d2.pushHead(val)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>如果 <code>c.head</code> 为空，就要创建一个 poolChainElt，作为首结点，当然也是尾节点。它管理的双端队列的长度，初始为 8，放满之后，再创建一个 poolChainElt 节点时，双端队列的长度就要翻倍。当然，有一个最大长度限制（2^30）：</p><p>const dequeueBits = 32  </p><p>const dequeueLimit = (1 &lt;&lt; dequeueBits) / 4</p><p>调用 <code>poolDequeue.pushHead</code> 尝试将对象放到 poolDeque 里去：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> pushHead(val <span class="keyword">interface</span>&#123;&#125;) <span class="type">bool</span> &#123;  </span><br><span class="line">ptrs := atomic.LoadUint64(&amp;d.headTail)  </span><br><span class="line">head, tail := d.unpack(ptrs)  </span><br><span class="line">    <span class="comment">// 首先判断队列是否已满： 也就是将尾部指针加上 d.vals 的长度，再取低 31 位，看它是否和 head 相等  </span></span><br><span class="line"><span class="keyword">if</span> (tail+<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)))&amp;(<span class="number">1</span>&lt;&lt;dequeueBits<span class="number">-1</span>) == head &#123;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">slot := &amp;d.vals[head&amp;<span class="type">uint32</span>(<span class="built_in">len</span>(d.vals)<span class="number">-1</span>)]  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Check if the head slot has been released by popTail.  </span></span><br><span class="line">typ := atomic.LoadPointer(&amp;slot.typ)  </span><br><span class="line"><span class="keyword">if</span> typ != <span class="literal">nil</span> &#123;  </span><br><span class="line"><span class="comment">// Another goroutine is still cleaning up the tail, so  </span></span><br><span class="line"><span class="comment">// the queue is actually still full.  </span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// slot占位，将val存入vals中  </span></span><br><span class="line"><span class="keyword">if</span> val == <span class="literal">nil</span> &#123;  </span><br><span class="line">val = dequeueNil(<span class="literal">nil</span>)  </span><br><span class="line">&#125;  </span><br><span class="line">*(*<span class="keyword">interface</span>&#123;&#125;)(unsafe.Pointer(slot)) = val  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// head 增加 1  </span></span><br><span class="line">atomic.AddUint64(&amp;d.headTail, <span class="number">1</span>&lt;&lt;dequeueBits)  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>首先判断队列是否已满：</p><pre><code>if (tail+uint32(len(d.vals)))&amp;(1&lt;&lt;dequeueBits-1) == head &#123;      return false  &#125;</code></pre><p>队列没满，通过 head 指针找到即将填充的 slot 位置：取 head 指针的低 31 位。</p><pre><code>slot := &amp;d.vals[head&amp;uint32(len(d.vals)-1)]  // Check if the head slot has been released by popTail.  typ := atomic.LoadPointer(&amp;slot.typ)  if typ != nil &#123;      // Another goroutine is still cleaning up the tail, so      // the queue is actually still full.      return false  &#125;</code></pre><p>这里还判断了当前 slot 是否正在被 popTail 释放，popTail 相关语句如下：</p><pre><code>// 最后也是将这个 slot 置空  // 先清空 val 再清空 typ 操作顺序和 pushHead 正好相反  slot.val = nil  atomic.StorePointer(&amp;slot.typ, nil)</code></pre><p>所以如果 slot.typ==nil 就说明这个 slot 正在被 popTail 释放，说明队列其实还是满的，直接返回 false，走后续的扩容逻辑。</p><p>最后，将 val 赋值到 slot，并将 head 指针值加 1。</p><p>// slot占位，将val存入vals中<br><em>(</em>interface{})(unsafe.Pointer(slot)) = val</p><blockquote><p>这里的实现比较巧妙，slot 是 eface 类型，即空接口，将 slot 转为 interface{} 类型，这样 val 能以 interface{} 赋值给 slot 让 slot.typ 和 slot.val 指向其内存块，于是 slot.typ 和 slot.val 均不为空。</p></blockquote><h4 id="2-4-2-pack-unpack"><a href="#2-4-2-pack-unpack" class="headerlink" title="2.4.2 pack/unpack"></a>2.4.2 pack/unpack</h4><p>最后我们再来看一下 pack 和 unpack 函数，它们实际上是一组绑定、解绑 head 和 tail 指针的两个函数。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> pack(head, tail <span class="type">uint32</span>) <span class="type">uint64</span> &#123;  </span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span>  </span><br><span class="line"><span class="keyword">return</span> (<span class="type">uint64</span>(head) &lt;&lt; dequeueBits) |  </span><br><span class="line"><span class="type">uint64</span>(tail&amp;mask)  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`mask`</span> 的低 <span class="number">31</span> 位为全 <span class="number">1</span>，其他位为 <span class="number">0</span>，它和 tail 相与，就是只看 tail 的低 <span class="number">31</span> 位。而 head 向左移 <span class="number">32</span> 位之后，低 <span class="number">32</span> 位为全 <span class="number">0</span>。最后把两部分“或”起来，head 和 tail 就“绑定”在一起了。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *poolDequeue)</span></span> unpack(ptrs <span class="type">uint64</span>) (head, tail <span class="type">uint32</span>) &#123;  </span><br><span class="line"><span class="keyword">const</span> mask = <span class="number">1</span>&lt;&lt;dequeueBits - <span class="number">1</span>  </span><br><span class="line">head = <span class="type">uint32</span>((ptrs &gt;&gt; dequeueBits) &amp; mask)  </span><br><span class="line">tail = <span class="type">uint32</span>(ptrs &amp; mask)  </span><br><span class="line"><span class="keyword">return</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>unpack 则是相反的逻辑，取出 head 指针的方法就是将 ptrs 右移 32 位，再与 mask 相与，同样只看 head 的低 31 位。而 tail 实际上更简单，直接将 ptrs 与 mask 相与就可以了。</p><h4 id="2-4-3-小结"><a href="#2-4-3-小结" class="headerlink" title="2.4.3 小结"></a>2.4.3 小结</h4><p>Put 和 Get 类似，首先尝试将放到当前 p 的 local.private 上，已经有了就放到 local.shared。</p><h3 id="2-5-GC"><a href="#2-5-GC" class="headerlink" title="2.5 GC"></a>2.5 GC</h3><p>对于 Pool 而言，并不能无限扩展，否则对象占用内存太多了，会引起内存溢出。<br>sync.pool 选择了在 GC 时进行清理。<br>在 pool.go 文件的 init 函数里，注册了 GC 发生时，如何清理 Pool 的函数：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync/pool.go  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;  </span><br><span class="line">runtime_registerPoolCleanup(poolCleanup)  </span><br><span class="line">&#125;</span><br><span class="line">编译器在编译时将其注册到运行时：</span><br><span class="line"><span class="comment">// src/runtime/mgc.go  </span></span><br><span class="line"><span class="comment">// Hooks for other packages  </span></span><br><span class="line"><span class="keyword">var</span> poolcleanup <span class="function"><span class="keyword">func</span><span class="params">()</span></span>  </span><br><span class="line"><span class="comment">// 利用编译器标志将 sync 包中的清理注册到运行时  </span></span><br><span class="line"><span class="comment">//go:linkname sync_runtime_registerPoolCleanup sync.runtime_registerPoolCleanup  </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sync_runtime_registerPoolCleanup</span><span class="params">(f <span class="keyword">func</span>()</span></span>) &#123;  </span><br><span class="line">  poolcleanup = f  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">具体的 poolCleanup() 函数如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poolCleanup</span><span class="params">()</span></span> &#123;  </span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> oldPools &#123;  </span><br><span class="line">p.victim = <span class="literal">nil</span>  </span><br><span class="line">p.victimSize = <span class="number">0</span>  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> _, p := <span class="keyword">range</span> allPools &#123;  </span><br><span class="line">p.victim = p.local  </span><br><span class="line">p.victimSize = p.localSize  </span><br><span class="line">p.local = <span class="literal">nil</span>  </span><br><span class="line">p.localSize = <span class="number">0</span>  </span><br><span class="line">&#125;  </span><br><span class="line">oldPools, allPools = allPools, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整体看起来，比较简洁。主要是将 local 和 victim 作交换，这样也就不致于让 GC 把所有的 Pool 都清空了，有 victim 在“兜底”。</p><ol><li>初始状态下，oldPools 和 allPools 均为 nil。</li><li>第 1 次调用 Get，由于 p.local 为 nil，将会在 pinSlow 中创建 p.local，然后将 p 放入 allPools，此时 allPools 长度为 1，oldPools 为 nil。</li><li>对象使用完毕，第 1 次调用 Put 放回对象。</li><li>第 1 次GC STW 阶段，allPools 中所有 p.local 将值赋值给 victim 并置为 nil。allPools 赋值给 oldPools，最后 allPools 为 nil，oldPools 长度为 1。</li><li>第 2 次调用 Get，由于 p.local 为 nil，此时会从 p.victim 里面尝试取对象。</li><li>对象使用完毕，第 2 次调用 Put 放回对象，但由于 p.local 为 nil，重新创建 p.local，并将对象放回，此时 allPools 长度为 1，oldPools 长度为 1。</li><li>第 2 次 GC STW 阶段，oldPools 中所有 p.victim 置 nil，前一次的 cache 在本次 GC 时被回收，allPools 所有 p.local 将值赋值给 victim 并置为nil，最后 allPools 为 nil，oldPools 长度为 1。<br>简单来说就是清理时，先清理 oldPools 的 local.victim,然后把 allPools 中的 local 赋值给 victim，最后再把 allPools 赋值给 oldPools，把 allPools 置空。<blockquote><p>GC 时只会清理 oldPools，allPools 只会先把数据转移到 victim，然后把 allPools 变成 oldPools，如果从 oldPools 中读取出来的数据进行 Put 也会直接放到 allPools 中，相当于要两次 GC 都没有被访问到并且Put回来才会被移除。</p></blockquote></li></ol><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><ul><li><p>1）关键思想是对象的复用，避免重复创建、销毁。将暂时不用的对象缓存起来，待下次需要的时候直接使用，不用再次经过内存分配，复用对象的内存，减轻 GC 的压力。</p></li><li><p>2）<code>sync.Pool</code> 是协程安全的，使用起来非常方便。设置好 New 函数后，调用 Get 获取，调用 Put 归还对象。</p></li><li><p>3）不要对 Get 得到的对象有任何假设，更好的做法是归还对象时，将对象“清空”。</p></li><li><p>4）Pool 里对象的生命周期受 GC 影响，不适合于做连接池，因为连接池需要自己管理对象的生命周期。</p></li></ul><p>一些设计思想或者相关知识点：</p><ul><li><p>lock free：无锁编程是很多编程语言里逃离不了的话题。<code>sync.Pool</code>的无锁是在<code>poolDequeue</code>和<code>poolChain</code>层面实现的。</p></li><li><p>原子操作代替锁：<code>poolDequeue</code>对一些关键变量采用了CAS操作，比如<code>poolDequeue.headTail</code>，既可完整保证并发又能降低相比锁而言的开销。</p></li><li><p>cacheline false sharing 问题</p></li><li><p>noCopy 禁止复制</p></li><li><p>分段锁，降低锁粒度</p></li><li><p>victim cache</p></li><li><p>常见优化手段：复用</p></li></ul><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><code>https://golang.org/src/sync/pool.go</code></p><p><code>https://en.wikipedia.org/wiki/False_sharing</code></p><p><code>https://en.wikipedia.org/wiki/Victim_cache</code></p><p><code>https://zhuanlan.zhihu.com/p/110140126</code></p><p><code>https://medium.com/swlh/go-the-idea-behind-sync-pool-32da5089df72</code></p><p><code>https://zhuanlan.zhihu.com/p/133638023</code></p><p><code>https://www.jianshu.com/p/dc4b5562aad2</code></p><p><code>https://colobu.com/2019/10/08/how-is-sync-Pool-improved-in-Go-1-13/</code></p><p>[Github]  <a href="https://github.com/lixd/i-go/blob/master/a-tutorials/lib/sync_pool/main.go">https://github.com/lixd/i-go/blob/master/a-tutorials/lib/sync_pool/main.go</a> </p><p>[pool-structure]  <a href="https://github.com/lixd/blog/raw/master/images/golang/lib/sync-pool/pool-structure.png">https://github.com/lixd/blog/raw/master/images/golang/lib/sync-pool/pool-structure.png</a></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] GMP</title>
      <link href="/2022/07/03/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP/"/>
      <url>/2022/07/03/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP/</url>
      
        <content type="html"><![CDATA[<blockquote><p>gmp = goroutine + machine + processor</p></blockquote><span id="more"></span><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><h3 id="1-1-线程"><a href="#1-1-线程" class="headerlink" title="1.1 线程"></a>1.1 线程</h3><p>通常指的是内核级线程，核心点如下：</p><ul><li>是操作系统最小调度单元；</li><li>创建、销毁、调度交由内核完成，cpu 需完成用户态与内核态间的切换；</li><li>可充分利用多核，实现并行.<h3 id="1-2-协程"><a href="#1-2-协程" class="headerlink" title="1.2 协程"></a>1.2 协程</h3></li></ul><p>协程，又称为用户级线程，核心点如下：</p><ul><li>与线程存在映射关系，为 M：1；</li><li>创建、销毁、调度在用户态完成，对内核透明，所以更轻；</li><li>从属同一个内核级线程，无法并行；一个协程阻塞会导致从属同一线程的所有协程无法执行.</li></ul><h3 id="1-3-Goroutine"><a href="#1-3-Goroutine" class="headerlink" title="1.3 Goroutine"></a>1.3 Goroutine</h3><p>Goroutine，经 Golang 优化后的特殊“协程”，特点如下：</p><ul><li>与线程存在映射关系，为 M：N；</li><li>创建、销毁、调度在用户态完成，对内核透明，足够轻便；</li><li>可利用多个线程，实现并行；</li><li>通过调度器的，实现和线程间的动态绑定和灵活调度；</li><li>栈空间大小可动态扩缩.</li></ul><h3 id="1-4-对比"><a href="#1-4-对比" class="headerlink" title="1.4 对比"></a>1.4 对比</h3><div class="table-container"><table><thead><tr><th><strong>模型</strong></th><th><strong>弱依赖内核</strong></th><th><strong>可并行</strong></th><th><strong>可应对阻塞</strong></th><th><strong>栈可动态扩缩</strong></th></tr></thead><tbody><tr><td>线程</td><td>❎</td><td>✅</td><td>✅</td><td>❎</td></tr><tr><td>协程</td><td>✅</td><td>❎</td><td>❎</td><td>❎</td></tr><tr><td>goroutine</td><td>✅</td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table></div><h2 id="2-GMP-模型"><a href="#2-GMP-模型" class="headerlink" title="2 GMP 模型"></a>2 GMP 模型</h2><h3 id="2-1-g"><a href="#2-1-g" class="headerlink" title="2.1 g"></a>2.1 g</h3><ul><li>g 即goroutine，是 golang 中对协程的抽象</li><li>g 有自己的运行栈、状态、以及执行的任务函数（用户通过 go func 指定）</li><li>g 需要绑定到 p 才能执行，在 g 的视角中，p 就是它的 cpu</li></ul><h3 id="2-2-m"><a href="#2-2-m" class="headerlink" title="2.2 m"></a>2.2 m</h3><ul><li>m 即 machine，是 golang 中对线程的抽象</li><li>m 不直接执行 g，而是先和 p 绑定，由其实现代理</li><li>借由 p 的存在，m 无需和 g 绑死，也无需记录 g 的状态信息，因此 g 在全生命周期中可以实现跨 m 执行.</li></ul><h3 id="2-3-p"><a href="#2-3-p" class="headerlink" title="2.3 p"></a>2.3 p</h3><ul><li>p 即 processor，是 golang 中的调度器</li><li>p 是 gmp 的中枢，借由 p 承上启下，实现 g 和 m 之间的动态有机结合</li><li>对 g 而言，p 是其 cpu，g 只有被 p 调度，才得以执行</li><li>对 m 而言，p 是其执行代理，为其提供必要信息的同时（可执行的 g、内存分配情况等），并隐藏了繁杂的调度细节</li><li>p 的数量决定了 g 最大并行数量，可由用户通过 GOMAXPROCS 进行设定（超过 CPU 核数时无意义）</li></ul><h3 id="2-4-GMP"><a href="#2-4-GMP" class="headerlink" title="2.4 GMP"></a>2.4 GMP</h3><ul><li>M 是线程的抽象；G 是 goroutine；P 是承上启下的调度器；</li><li>M调度G前，需要和P绑定；</li><li>全局有多个M和多个P，但同时并行的G的最大数量等于P的数量；</li><li>G的存放队列有三类：P的本地队列；全局队列；和wait队列（图中未展示，为io阻塞就绪态goroutine队列）；</li><li>M调度G时，优先取P本地队列，其次取全局队列，最后取wait队列；这样的好处是，取本地队列时，可以接近于无锁化，减少全局锁竞争；</li><li>为防止不同P的闲忙差异过大，设立work-stealing机制，本地队列为空的P可以尝试从其他P本地队列偷取一半的G补充到自身队列.</li></ul><h2 id="3-核心数据结构"><a href="#3-核心数据结构" class="headerlink" title="3 核心数据结构"></a>3 核心数据结构</h2><blockquote><p>gmp 数据结构定义在 runtime/runtime2.go 文件中</p></blockquote><h3 id="3-1-g"><a href="#3-1-g" class="headerlink" title="3.1 g"></a>3.1 g</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    m         *m      </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sched     gobuf</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    sp   <span class="type">uintptr</span></span><br><span class="line">    pc   <span class="type">uintptr</span></span><br><span class="line">    ret  <span class="type">uintptr</span></span><br><span class="line">    bp   <span class="type">uintptr</span> <span class="comment">// for framepointer-enabled architectures</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>m：在 p 的代理，负责执行当前 g 的 m；</li><li>sched.sp：保存 CPU 的 rsp 寄存器的值，指向函数调用栈栈顶；</li><li>sched.pc：保存 CPU 的 rip 寄存器的值，指向程序下一条执行指令的地址；</li><li>sched.ret：保存系统调用的返回值；</li><li>sched.bp：保存 CPU 的 rbp 寄存器的值，存储函数栈帧的起始位置.</li></ul><p>g的生命周期:未初始化完成 等待被执行  执行  执行系统调用  挂起态  被销毁  栈扩容 被抢占</p><h3 id="3-2-m"><a href="#3-2-m" class="headerlink" title="3.2 m"></a>3.2 m</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    g0      *g     <span class="comment">// goroutine with scheduling stack</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    tls           [tlsSlots]<span class="type">uintptr</span> <span class="comment">// thread-local storage (for x86 extern register)</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>g0：一类特殊的调度协程，不用于执行用户函数，负责执行 g 之间的切换调度. 与 m 的关系为 1:1；</li><li>tls：thread-local storage，线程本地存储，存储内容只对当前线程可见. 线程本地存储的是 m.tls 的地址，m.tls[0] 存储的是当前运行的 g，因此线程可以通过 g 找到当前的 m、p、g0 等信息.<h3 id="3-3-p"><a href="#3-3-p" class="headerlink" title="3.3 p"></a>3.3 p</h3></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    runqhead <span class="type">uint32</span></span><br><span class="line">    runqtail <span class="type">uint32</span></span><br><span class="line">    runq     [<span class="number">256</span>]guintptr</span><br><span class="line">    </span><br><span class="line">    runnext guintptr</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>runq：本地 goroutine 队列，最大长度为 256.</li><li>runqhead：队列头部；</li><li>runqtail：队列尾部；</li><li>runnext：下一个可执行的 goroutine.</li></ul><h3 id="3-4-schedt"><a href="#3-4-schedt" class="headerlink" title="3.4 schedt"></a>3.4 schedt</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lock mutex</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    runq     gQueue</span><br><span class="line">    runqsize <span class="type">int32</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sched 是全局 goroutine 队列的封装：</p><ul><li>lock：一把操作全局队列时使用的锁；</li><li>runq：全局 goroutine 队列；</li><li>runqsize：全局 goroutine 队列的容量.</li></ul><h2 id="4-调度流程"><a href="#4-调度流程" class="headerlink" title="4 调度流程"></a>4 调度流程</h2><h3 id="4-1-g0-和-g-的转换"><a href="#4-1-g0-和-g-的转换" class="headerlink" title="4.1 g0 和 g 的转换"></a>4.1 g0 和 g 的转换</h3><p><strong>goroutine 的类型可分为两类：</strong></p><ul><li>负责调度普通 g 的 g0，执行固定的调度流程，与 m 的关系为一对一</li><li>负责执行用户函数的普通 g<br>m 通过 p 调度执行的 goroutine 永远在普通 g 和 g0 之间进行切换，当 g0 找到可执行的 g 时，会调用 gogo 方法，调度 g 执行用户定义的任务；当 g 需要主动让渡或被动调度时，会触发 mcall 方法，将执行权重新交还给 g0.</li></ul><h3 id="4-2-调度类型"><a href="#4-2-调度类型" class="headerlink" title="4.2 调度类型"></a>4.2 调度类型</h3><blockquote><p>调度器 p 实现从执行一个 g 切换到另一个 g 的过程.</p></blockquote><h4 id="4-2-1-主动调度"><a href="#4-2-1-主动调度" class="headerlink" title="4.2.1 主动调度"></a>4.2.1 主动调度</h4><ul><li>用户主动执行让渡的方式，主要方式是，用户在执行代码中调用了 runtime.Gosched 方法，此时当前 g 会当让出执行权，主动进行队列等待下次被调度执行.</li></ul><h4 id="4-2-2-被动调度"><a href="#4-2-2-被动调度" class="headerlink" title="4.2.2 被动调度"></a>4.2.2 被动调度</h4><ul><li>因当前不满足某种执行条件，g 可能会陷入阻塞态无法被调度，直到关注的条件达成后，g才从阻塞中被唤醒，重新进入可执行队列等待被调度.</li><li><p>常见的被动调度触发方式为因 channel 操作或互斥锁操作陷入阻塞等操作，底层会走进 gopark 方法.</p><h4 id="4-2-3-正常调度"><a href="#4-2-3-正常调度" class="headerlink" title="4.2.3 正常调度"></a>4.2.3 正常调度</h4></li><li><p>g 中的执行任务已完成，g0 会将当前 g 置为死亡状态，发起新一轮调度.</p><h4 id="4-2-4-抢占调度"><a href="#4-2-4-抢占调度" class="headerlink" title="4.2.4 抢占调度"></a>4.2.4 抢占调度</h4></li><li><p>如果 g 执行系统调用超过指定的时长，且全局的 p 资源比较紧缺，此时将 p 和 g 解绑，抢占出来用于其他 g 的调度. 等 g 完成系统调用后，会重新进入可执行队列中等待被调度.</p></li><li>前 3 种调度方式都由 m 下的 g0 完成，唯独抢占调度不同.</li><li>因为发起系统调用时需要打破用户态的边界进入内核态，此时 m 也会因系统调用而陷入僵直，无法主动完成抢占调度的行为.</li><li>因此，在 Golang 进程会有一个全局监控协程 monitor g 的存在，这个 g 会越过 p 直接与一个 m 进行绑定，不断轮询对所有 p 的执行状况进行监控. 倘若发现满足抢占调度的条件，则会从第三方的角度出手干预，主动发起该动作.</li></ul><h3 id="4-3-宏观调度流程"><a href="#4-3-宏观调度流程" class="headerlink" title="4.3 宏观调度流程"></a>4.3 宏观调度流程</h3><ul><li>g0 执行 schedule() 函数，寻找到用于执行的 g</li><li>g0 执行 execute() 方法，更新当前 g、p 的状态信息，并调用 gogo() 方法，将执行权交给 g</li><li>g 因主动让渡( gosche_m() )、被动调度( park_m() )、正常结束( goexit0() )等原因，调用 m_call 函数，执行权重新回到 g0 手中</li><li>g0 执行 schedule() 函数，开启新一轮循环</li></ul><h3 id="4-4-schedule"><a href="#4-4-schedule" class="headerlink" title="4.4 schedule"></a>4.4 schedule</h3><p>调度流程的主干方法是位于 runtime/proc.go 中的 schedule 函数，此时的执行权位于 g0 手中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    gp, inheritTime, tryWakeP := findRunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>寻找到下一个执行的 goroutine</li><li>执行该 goroutine</li></ul><h3 id="4-5-findRunnable"><a href="#4-5-findRunnable" class="headerlink" title="4.5 findRunnable"></a>4.5 findRunnable</h3><p><img src="file-20250303232645826.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRunnable</span><span class="params">()</span></span> (gp *g, inheritTime, tryWakeP <span class="type">bool</span>) &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    _p_ := _g_.m.p.ptr()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> _p_.schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        gp = globrunqget(_p_, <span class="number">1</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> gp, inheritTime := runqget(_p_); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gp, inheritTime, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> list := netpoll(<span class="number">0</span>); !list.empty() &#123; <span class="comment">// non-blocking</span></span><br><span class="line">            gp := list.pop()</span><br><span class="line">            injectglist(&amp;list)</span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    procs := <span class="type">uint32</span>(gomaxprocs)</span><br><span class="line">    <span class="keyword">if</span> _g_.m.spinning || <span class="number">2</span>*atomic.Load(&amp;sched.nmspinning) &lt; procs-atomic.Load(&amp;sched.npidle) &#123;</span><br><span class="line">        <span class="keyword">if</span> !_g_.m.spinning &#123;</span><br><span class="line">            _g_.m.spinning = <span class="literal">true</span></span><br><span class="line">            atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gp, inheritTime, tnow, w, newWork := stealWork(now)</span><br><span class="line">        now = tnow</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// Successfully stole.</span></span><br><span class="line">            <span class="keyword">return</span> gp, inheritTime, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> newWork &#123;</span><br><span class="line">            <span class="comment">// There may be new timer or GC work; restart to</span></span><br><span class="line">            <span class="comment">// discover.</span></span><br><span class="line">            <span class="keyword">goto</span> top</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; (pollUntil == <span class="number">0</span> || w &lt; pollUntil) &#123;</span><br><span class="line">            <span class="comment">// Earlier timer to wait for.</span></span><br><span class="line">            pollUntil = w</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>p 每执行 61 次调度，会从全局队列中获取一个 goroutine 进行执行，并将一个全局队列中的 goroutine 填充到当前 p 的本地队列中<ul><li>取得 p 本地队列队首的索引，同时对本地队列加锁</li><li>倘若 p 的局部队列未满，则成功转移 g，将 p 的对尾索引 runqtail 值加 1 并解锁队列.</li><li>倘若发现本地队列 runq 已经满了，则会返回来将本地队列中一半的 g 放回全局队列中，帮助当前 p 缓解执行压力，这部分内容位于 runqputslow 方法中</li></ul></li><li>尝试从 p 本地队列中获取一个可执行的 goroutine，核心逻辑位于 runqget 方法中<ul><li>倘若当前 p 的 runnext 非空，直接获取即可</li><li>加锁从 p 的本地队列中获取 g, 虽然本地队列是属于 p 独有的，但是由于 work-stealing 机制的存在，其他 p 可能会前来执行窃取动作，因此操作仍需加锁.</li><li>倘若本地队列为空，直接终止并返回</li><li>倘若本地队列存在 g，则取得队首的 g，解锁并返回</li></ul></li><li>倘若本地队列没有可执行的 g，会从全局队列中获取</li><li>倘若本地队列和全局队列都没有 g，则会获取准备就绪的网络协程</li><li>work-stealing: 从其他 p 中偷取 g<ul><li>偷取操作至多会遍历全局的 p 队列 4 次，过程中只要找到可窃取的 p 则会立即返回.</li><li>为保证窃取行为的公平性，遍历的起点是随机的. 窃取动作的核心逻辑位于 runqgrab 方法当中</li><li>每次对一个 p 尝试窃取前，会对其局部队列加锁</li><li>尝试偷取其现有的一半 g，并且返回实际偷取的数量</li></ul></li></ul><h3 id="4-6-execute"><a href="#4-6-execute" class="headerlink" title="4.6 execute"></a>4.6 execute</h3><p>当 g0 为 m 寻找到可执行的 g 之后，接下来就开始执行 g. 这部分内容位于 runtime/proc.go 的 execute 方法中</p><ul><li>更新 g 的状态信息，建立 g 与 m 之间的绑定关系</li><li>更新 p 的总调度次数</li><li>调用 gogo 方法，执行 goroutine 中的任务</li></ul><h3 id="4-7-gosched-m"><a href="#4-7-gosched-m" class="headerlink" title="4.7 gosched_m"></a>4.7 gosched_m</h3><p>g 执行主动让渡时，会调用 mcall 方法将执行权归还给 g0，并由 g0 调用 gosched_m 方法，位于 runtime/proc.go 文件中</p><p><img src="file-20250303234355218.png" alt=""></p><ul><li>将当前 g 的状态由执行中切换为待执行 <code>_Grunnable</code></li><li>调用 dropg() 方法，将当前的 m 和 g 解绑</li><li>将 g 添加到全局队列当中</li><li>开启新一轮的调度</li></ul><h3 id="4-8-park-m-与-ready"><a href="#4-8-park-m-与-ready" class="headerlink" title="4.8 park_m 与 ready"></a>4.8 park_m 与 ready</h3><ul><li>g 需要被动调度时，会调用 mcall 方法切换至 g0，并调用 park_m 方法将 g 置为阻塞态，执行流程位于 runtime/proc.go 的 gopark 方法当中<ul><li>将当前 g 的状态由 running 改为 waiting</li><li>将 g 与 m 解绑</li><li>执行新一轮的调度 schedule</li></ul></li><li>当因被动调度陷入阻塞态的 g 需要被唤醒时，会由其他协程执行 goready 方法将 g 重新置为可执行的状态，方法位于 runtime/proc.go<ul><li>先将 g 的状态从阻塞态改为可执行的状态</li><li>调用 runqput 将当前 g 添加到唤醒者 p 的本地队列中，如果队列满了，会连带 g 一起将一半的元素转移到全局队列</li></ul></li></ul><h3 id="4-9-goexit0"><a href="#4-9-goexit0" class="headerlink" title="4.9 goexit0"></a>4.9 goexit0</h3><ul><li>当 g 执行完成时，会先执行 mcall 方法切换至 g0，然后调用 goexit0 方法<ul><li>将 g 状态置为 dead</li><li>解绑 g 和 m</li><li>开启新一轮的调度</li></ul></li></ul><h3 id="4-10-retake"><a href="#4-10-retake" class="headerlink" title="4.10 retake"></a>4.10 retake</h3><p>抢占调度的执行者不是 g0，而是一个全局的 monitor g，代码位于 runtime/proc.go 的 retake 方法中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retake</span><span class="params">(now <span class="type">int64</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    lock(&amp;allpLock)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(allp); i++ &#123;</span><br><span class="line">        _p_ := allp[i]</span><br><span class="line">        <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// This can happen if procresize has grown</span></span><br><span class="line">            <span class="comment">// allp but not yet created new Ps.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        pd := &amp;_p_.sysmontick</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> s == _Psyscall &#123;            </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">if</span> runqempty(_p_) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; <span class="number">0</span> &amp;&amp; pd.syscallwhen+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &gt; now &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            unlock(&amp;allpLock)</span><br><span class="line">            <span class="keyword">if</span> atomic.Cas(&amp;_p_.status, s, _Pidle) &#123;</span><br><span class="line">                n++</span><br><span class="line">                _p_.syscalltick++</span><br><span class="line">                handoffp(_p_)</span><br><span class="line">            &#125;</span><br><span class="line">            incidlelocked(<span class="number">1</span>)</span><br><span class="line">            lock(&amp;allpLock)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;allpLock)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">uint32</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>加锁后，遍历全局的 p 队列，寻找需要被抢占的目标</li><li>倘若某个 p 同时满足下述条件，则会进行抢占调度<ul><li>执行系统调用超过 10 ms</li><li>p 本地队列有等待执行的 g</li><li>或者当前没有空闲的 p 和 m</li></ul></li><li>抢占调度的步骤是，先将当前 p 的状态更新为 idle，然后步入 handoffp 方法中，判断是否需要为 p 寻找接管的 m（因为其原本绑定的 m 正在执行系统调用）</li><li>当以下条件满足其一时，则需要为 p 获取新的 m<ul><li>当前 p 本地队列还有待执行的 g</li><li>全局繁忙（没有空闲的 p 和 m，全局 g 队列为空）</li><li>需要处理网络 socket 读写请求</li></ul></li><li>获取 m 时，会先尝试获取已有的空闲的 m，若不存在，则会创建一个新的 m</li></ul><h3 id="4-11-reentersyscall-和-exitsyscall"><a href="#4-11-reentersyscall-和-exitsyscall" class="headerlink" title="4.11 reentersyscall 和 exitsyscall"></a>4.11 reentersyscall 和 exitsyscall</h3><p>在 m 需要执行系统调用前，会先执行位于 runtime/proc.go 的 reentersyscall 的方法</p><ul><li>此时执行权同样位于 m 的 g0 手中</li><li>保存当前 g 的执行环境</li><li>将 g 和 p 的状态更新为 syscall</li><li>解除 p 和 当前 m 之间的绑定，因为 m 即将进入系统调用而导致短暂不可用</li><li>将 p 添加到 当前 m 的 oldP 容器当中，后续 m 恢复后，会优先寻找旧的 p 重新建立绑定关系</li></ul><p>当 m 完成了内核态的系统调用之后，此时会步入位于 runtime/proc.go 的 exitsyscall 函数中，尝试寻找 p 重新开始运作</p><ul><li>方法执行之初，此时的执行权是普通 g.倘若此前设置的 oldp 仍然可用，则重新和 oldP 绑定，将当前 g 重新置为 running 状态，然后开始执行后续的用户函数</li><li>old 绑定失败，则调用 mcall 方法切换到 m 的 g0，并执行 exitsyscall0 方法</li><li>将 g 由系统调用状态切换为可运行态，并解绑 g 和 m 的关系</li><li>从全局 p 队列获取可用的 p，如果获取到了，则执行 g</li><li>如若无 p 可用，则将 g 添加到全局队列，当前 m 陷入沉睡. 直到被唤醒后才会继续发起调度.</li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 并发编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] 类型断言</title>
      <link href="/2021/12/13/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/"/>
      <url>/2021/12/13/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/</url>
      
        <content type="html"><![CDATA[<blockquote><p>类型断言的关键是明确接口的动态类型以及对应的类型实现了哪些方法</p></blockquote><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>类型分类：</p><ul><li>抽象类型：空接口、非空接口</li><li>具体类型：int、string、slice、map ….</li></ul><p>断言表达式：</p><ul><li>类型断言作用在接口值之上，可以是空接口或非空接口；</li><li>而断言的目标类型可以是具体类型或非空接口类型。</li></ul><p>这样一共就有4种断言组合。</p><h2 id="2-具体分析"><a href="#2-具体分析" class="headerlink" title="2 具体分析"></a>2 具体分析</h2><h3 id="2-1-空接口-具体类型"><a href="#2-1-空接口-具体类型" class="headerlink" title="2.1 空接口.(具体类型)"></a>2.1 空接口.(具体类型)</h3><p><strong>空接口只有动态类型，所以只要动态类型相同就能断言成功</strong>。<br><img src="file-20250119063246346.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">r,ok := e.(*os.File)</span><br></pre></td></tr></table></figure><p>这里只需要判定 e 的 _type 是否执行 *os.File 的类型元数据即可。</p><blockquote><p> Go 语言里面每种类型的类型元数据都是唯一的，如果类型元数据相同那就是同一种类型。</p></blockquote><p>如果这样赋值就能断言成功, ok 为 true，r 被赋值为 e 的动态值 f。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eface2Specific</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">f, _ := os.Open(<span class="string">&quot;17x.txt&quot;</span>)</span><br><span class="line">e = f</span><br><span class="line">r, ok := e.(*os.File)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反之则不行，ok 为 false，<strong>r 被赋值为 *os.File 类型(断言的目标类型)的零值 nil</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">f, _ := os.Open(<span class="string">&quot;17x.txt&quot;</span>)</span><br><span class="line">e = <span class="string">&quot;17x&quot;</span></span><br><span class="line">r, ok := e.(*os.File)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-非空接口-具体类型"><a href="#2-2-非空接口-具体类型" class="headerlink" title="2.2 非空接口.(具体类型)"></a>2.2 非空接口.(具体类型)</h3><p><strong>这里需要判断非空接口的动态类型是否等于断言目标类型</strong>。</p><p><img src="file-20250119063407429.png" alt=""></p><p>下面的断言，要求 rw 接口类型为 io.ReadWriter，动态类型为*os.File。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rw io.ReadWriter</span><br><span class="line">r, ok := rw.(*os.File)</span><br></pre></td></tr></table></figure><p>只需要判定非空接口的 itab 是否指向 io.ReadWriter 的 itab 结构体即可。</p><p>这样赋值就能断言成功：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> rw io.ReadWriter</span><br><span class="line">f, _ := os.Open(<span class="string">&quot;17x.txt&quot;</span>)</span><br><span class="line">rw = f</span><br><span class="line">r, ok := rw.(*os.File)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样则不行,接口类型对上了，但是 rw 的动态类型是  <em>MyRW，不是断言目标类型 </em>os.File。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> rw io.ReadWriter</span><br><span class="line">rw = &amp;MyRW&#123;&#125;</span><br><span class="line">r, ok := rw.(*os.File)</span><br><span class="line"><span class="keyword">if</span> ok &#123;</span><br><span class="line">fmt.Println(r)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MyRW <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *MyRW)</span></span> Read(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>)  &#123; <span class="keyword">return</span> <span class="number">0</span>, err &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rw *MyRW)</span></span> Write(p []<span class="type">byte</span>) (n <span class="type">int</span>, err <span class="type">error</span>) &#123; <span class="keyword">return</span> <span class="number">0</span>, err &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-空接口-非空接口"><a href="#2-3-空接口-非空接口" class="headerlink" title="2.3 空接口.(非空接口)"></a>2.3 空接口.(非空接口)</h3><p><strong>这里需要判断空接口的动态类型是否实现了非空接口</strong>。<br><img src="file-20250119063351822.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">r, ok := e.(io.ReadWriter)</span><br></pre></td></tr></table></figure><ul><li>1）先去 itab 缓存中找 <strong>&lt;断言目标值接口类型，空接口动态类型&gt;</strong> 这个 Key 对应的 itab 结构体；</li><li>2）如果存在则再次判断 itab.fun[0] 是否等于0<ul><li>等于 0 则断言失败</li><li>不等于 0则断言成功</li></ul></li><li>3）如果不存在则通过 _type 找到方法元数据，校验是否实现了接口类型，且把 itab 添加到哈希表，方便下次断言是比对。<ul><li>如果没有实现该接口类型还要把  itab.fun[0] 置为0</li></ul></li></ul><p><strong>为什么需要判断  itab.fun[0] 是否等于0？</strong></p><p>因为 Go 语言会把断言失败的类型组合也存到哈希表，同时把  itab.fun[0] 置为0，用以标识这里的动态类型并没有实现对应的接口。</p><p><strong>这样下次断言的时候找到 itab 发现  itab.fun[0]=0，就直接返回断言失败</strong>。</p><h3 id="2-4-非空接口-非空接口"><a href="#2-4-非空接口-非空接口" class="headerlink" title="2.4 非空接口.(非空接口)"></a>2.4 非空接口.(非空接口)</h3><p><strong>这里同样是判断非空接口的动态类型是否实现了非空接口</strong>。<br><img src="file-20250119063336492.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">iface2iface</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> w io.Writer</span><br><span class="line">   f, _ := os.Open(<span class="string">&quot;17x.txt&quot;</span>)</span><br><span class="line">   w = f</span><br><span class="line">   r, ok := w.(io.ReadWriter)</span><br><span class="line">   <span class="keyword">if</span> ok &#123;</span><br><span class="line">      fmt.Println(r)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><ul><li>1）空接口.(具体类型)：动态类型等于目标类型的动态类型。</li><li>2）非空接口.(具体类型)：动态类型等于目标类型的动态类型。</li><li>3）空接口.(非空接口)：动态类型是否实现了非空接口的接口类型。</li><li>4）非空接口.(非空接口)：动态类型是否实现了非空接口的接口类型。</li></ul><p>一句话总结：</p><p><strong>断言为具体类型则看动态类型是否相同，断言为非空接口则看是否实现了非空接口的接口类型。</strong></p><p><strong>类型断言的关键是明确接口的动态类型以及对应的类型实现了哪些方法</strong>，明确这些的关键就是<code>类型元数据</code>以及空接口与非空接口的<code>数据结构</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 关键字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] 反射</title>
      <link href="/2021/12/04/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/"/>
      <url>/2021/12/04/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>反射的作用就是将类型元数据暴露给用户使用</p></blockquote><span id="more"></span><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p> runtime 包中的类型元数据、空接口、非空接口等数据类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_type</span><br><span class="line">typeAlg</span><br><span class="line">uncommontype</span><br><span class="line">interfacetype</span><br><span class="line">eface</span><br><span class="line">iface</span><br><span class="line">slicetype</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>但是这些都是未导出的,于是 reflect 包中由定义了一套，这些类型定义在两个包中是保持一致的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rtype</span><br><span class="line">typeAlg</span><br><span class="line">uncommontype</span><br><span class="line">interfaceType</span><br><span class="line">emptyInterface</span><br><span class="line">noneEmptyInterface</span><br><span class="line">sliceType</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>reflect 包提供了 TypeOf 函数用于获取一个变量的类型信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TypeOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Type &#123;</span><br><span class="line">eface := *(*emptyInterface)(unsafe.Pointer(&amp;i))</span><br><span class="line"><span class="keyword">return</span> toType(eface.typ)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反射三大法则：</p><ol><li>从 <code>interface&#123;&#125;</code> 变量可以反射出反射对象；</li><li>从反射对象可以获取 <code>interface&#123;&#125;</code> 变量；</li><li>要修改反射对象，其值必须可设置；</li></ol><h2 id="2-反射获取类型信息"><a href="#2-反射获取类型信息" class="headerlink" title="2 反射获取类型信息"></a>2 反射获取类型信息</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> i17x <span class="keyword">struct</span> &#123;</span><br><span class="line">Name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(i i17x)</span></span> A() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">i := i17x&#123;Name: <span class="string">&quot;17x&quot;</span>&#125;</span><br><span class="line">t := reflect.TypeOf(i)</span><br><span class="line"><span class="built_in">println</span>(t.Name(), t.NumMethod())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们想要获取这个结构体的类型信息，调用 TypeOf 方法。</p><p><strong>然而 TypeOf 方法的参数是一个空接口，需要的是一个地址</strong>。</p><p>但是我们这里传递的是一个值类型，难道函数里面用的是 i 的地址？</p><p>并不是，因为这样就违反了传参值拷贝的语义，实际上这里是在<strong>编译期生成了临时变量作为 a 的拷贝</strong>，然后参数就用的这个临时变量的地址。</p><p>这样即符合传参值拷贝的语义又满足了空接口类型的参数只能是地址的需求。</p><p><strong>所有参数为空接口类型的情况，都要像这样。通过传递拷贝后临时变量的地址来实现传值的语义。</strong></p><p>然后 TypeOf 函数会把传进去的 eface 类型的参数转换成 reflect.emptyInterface 类型。</p><blockquote><p>这两个类型定义是一致的，转换后方便 reflect 包操作内部元素。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">_type *_type</span><br><span class="line">data  unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> emptyInterface <span class="keyword">struct</span> &#123;</span><br><span class="line">typ  *rtype</span><br><span class="line">word unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>emptyInterface 中的字段 typ 实现了 reflect.Type 接口，所以接下来只需要将 eface 包装成reflect.Type 类型的返回值即可。</p><p>所以 TypeOf 最终返回值就是一个 非空接口 iface，具体如下：</p><ul><li>1）接口类型 reflect.Type，动态类型为 *rtype</li><li>2）Data 指向我们传入的参数 i 。</li></ul><h2 id="3-反射修改值"><a href="#3-反射修改值" class="headerlink" title="3 反射修改值"></a>3 反射修改值</h2><p>修改变量值就要用到 reflect.Value 类型了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Value <span class="keyword">struct</span> &#123;</span><br><span class="line">typ *rtype</span><br><span class="line">ptr unsafe.Pointer</span><br><span class="line">flag</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1）typ：类型元数据指针</li><li>2）ptr：数据地址</li><li>3）flag：位标识符，存储反射值的一些描述信息<ul><li>是否为指针</li><li>是否为方法</li><li>是否只读</li><li>……</li></ul></li></ul><p>通常会使用 reflect.ValueOf 函数来获取reflect.Value，这里参数也是空接口，所以需要和 TypeOf 函数一样处理，唯一不同的是 <strong>这个临时变量会被显式逃逸到堆上</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ValueOf</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;)</span></span> Value &#123;</span><br><span class="line"><span class="keyword">if</span> i == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Value&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">escapes(i)</span><br><span class="line"><span class="keyword">return</span> unpackEface(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以最后该函数返回的非空接口中的 data 其实指向的堆上的临时变量。</strong></p><p>例如下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a:=<span class="string">&quot;17x&quot;</span></span><br><span class="line">v := reflect.ValueOf(a)</span><br><span class="line">v.SetString(<span class="string">&quot;i17x&quot;</span>)</span><br><span class="line"><span class="built_in">println</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 v 指向的是堆上的临时变量，所以通过 v 直接修改这样一个用户都不知道的临时变量是行不通的，所以会发生 panic。</p><p><strong>既然有临时变量存在，那怎么才能拿到a的指针？</strong></p><p>为了解决这个问题，就只能在 ValueOf 函数的时候传指针进去，就像这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a:=<span class="string">&quot;17x&quot;</span></span><br><span class="line">v := reflect.ValueOf(a)</span><br><span class="line">v=v.Elem()</span><br><span class="line">v.SetString(<span class="string">&quot;i17x&quot;</span>)</span><br><span class="line"><span class="built_in">println</span>(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样执行传入 a 的地址，虽然还是会创建临时变量，然后逃逸到堆上，最后返回的也是指向的临时变量，但是变量中存放的是a的地址，所以我们可以通过<code>v.Elem()</code> 拿到变量a就可以修改了。</p><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><code>https://www.bilibili.com/video/BV1hv411x7we?p=16</code></p><p><code>https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-reflect/</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] 闭包</title>
      <link href="/2021/12/04/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E9%97%AD%E5%8C%85/"/>
      <url>/2021/12/04/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<blockquote><p>闭包是有状态函数</p></blockquote><span id="more"></span><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="1-function-value"><a href="#1-function-value" class="headerlink" title="1 function value"></a>1 function value</h2><p>Go 语言中的函数是头等公民。可以做为参数传递，可以做函数返回值、也可以绑定到变量。</p><p>Go 语言称这样的参数、返回值或变量为<strong>function value</strong>。</p><p>function value 不直接指向函数指令入口，而是指向一个 <code>runtime.funcval</code>结构体。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/runtime2.go</span></span><br><span class="line"><span class="keyword">type</span> funcval <span class="keyword">struct</span> &#123;</span><br><span class="line">fn <span class="type">uintptr</span></span><br><span class="line"><span class="comment">// variable-size, fn-specific data here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 funcval 只有一个字段 fn，存储的就是函数指令入口地址。</p><h2 id="2-闭包-Closure"><a href="#2-闭包-Closure" class="headerlink" title="2 闭包 Closure"></a>2 闭包 Closure</h2><p><strong>为什么要用 funcval 结构体来包装函数指令入口地址，然后使用二级指针来调用？</strong></p><p>主要是为了处理闭包的情况。</p><p>维基百科上的<a href="[https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">闭包</a>](<a href="https://zh.wikipedia.org/wiki/闭包_(计算机科学)))定义如下：">https://zh.wikipedia.org/wiki/闭包_(计算机科学)))定义如下：</a></p><ul><li>1）必须要有在函数外部定义但在函数内部引用的<code>自由变量</code></li><li>2）脱离了形成闭包的上下文，闭包也能照常使用这些自由变量。</li></ul><p>就向下面这个例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">f1 := create()</span><br><span class="line">f2 := create()</span><br><span class="line">fmt.Println(f1())</span><br><span class="line">fmt.Println(f2())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">i := <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create() 函数执行结束后，通过 f1()，f2() 依然可以正常调用这个闭包函数，并使用定义在 create() 函数内部的局部变量 i，所以这符合闭包的定义。</p><p>通常称这个变量 i 为<strong>捕获变量</strong>。</p><p><strong>闭包函数的指令在编译阶段生成，但是闭包对象要到执行阶段才创建，因为每个闭包对象都要保存自己的捕获变量</strong>。</p><p>闭包函数指令存放在栈中的代码段上。</p><p>闭包对象则会分配到堆上，闭包对象具体组成如下：</p><ul><li>1）funcval 结构体</li><li>2）捕获变量列表</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1 := create()</span><br><span class="line">f2 := create()</span><br></pre></td></tr></table></figure><p>这里创建了两个闭包对象，其中的 funcval 都指向同一个函数指令入口，但是捕获变量则需要各自维护。</p><p>然后把这两个闭包对象的地址赋值给接收者，即这里的 f1,f2。</p><p>通过f1、f2调用闭包函数会找到各自对应的 funcval 结构体，拿到同一个函数入口，但是却使用的是各自的捕获变量列表。</p><p><strong>这就是称闭包为有状态函数的原因。</strong></p><h2 id="3-获取捕获列表"><a href="#3-获取捕获列表" class="headerlink" title="3 获取捕获列表"></a>3 获取捕获列表</h2><p><strong>闭包函数是如何找到对应的捕获列表呢？</strong></p><p>Go语言中通过一个 function value 调用函数时，会把对应的<strong>funcval 结构体地址</strong>存入特定寄存器。例如 amd64 平台使用的是 DX 寄存器。</p><p>这样在闭包函数中就可以通过寄存器取出 funcval 结构体的地址，然后加上相应的<strong>偏移量</strong>来找到每一个被捕获的变量。</p><p>所以<strong>Go 语言中闭包就是有捕获列表的 function value</strong>，而没有捕获列表的 function value 直接忽略这个寄存器的值就好了。</p><h2 id="4-捕获变量"><a href="#4-捕获变量" class="headerlink" title="4 捕获变量"></a>4 捕获变量</h2><p>被闭包捕获的变量，要在外层函数闭包函数中表现一致，好像它们在使用同一个变量。为此 Go 语言编译器针对不同情况做了不同的处理。</p><blockquote><p>变量逃逸、参数堆分配、返回值</p></blockquote><h3 id="4-1-没有修改"><a href="#4-1-没有修改" class="headerlink" title="4.1 没有修改"></a>4.1 没有修改</h3><p>被捕获变量 i 除了赋值之外没有被其他地方修改，所以直接拷贝到捕获列表即可。</p><p>就像下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">incrementer</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line">i := <span class="number">2</span></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-有修改"><a href="#4-2-有修改" class="headerlink" title="4.2 有修改"></a>4.2 有修改</h3><p>除了初始化赋值外还被修改过，则需要进一步细分。</p><p><strong>捕获的是局部变量</strong></p><p>被闭包捕获的局部变量如果除了初始化赋值外还被修改过，就会分配到堆上。</p><p>闭包导致的局部变量堆分配，也是变量逃逸的一种。</p><p>例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fs := create()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(fs); i++ &#123;</span><br><span class="line">fs[i]()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">create</span><span class="params">()</span></span> (fs [<span class="number">2</span>]<span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line">fs[i] = <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>create() 函数中的局部变量 i 除了初始化之外，还被修改过(i++)，同时还被闭包捕获，所以会分配到堆上，然后栈上只存储该变量的地址。</p><p>每次 i++ 自增的是堆上的变量 i，而闭包捕获的都是变量 i 的地址，都指向堆上的变量 i。</p><p>最后 i 会自增到 2 ，所以最终闭包打印出来的i值都为2。</p><p><strong>捕获的是参数</strong></p><p>由于参数设计到函数原型，就不能像局部变量这样处理了。</p><p>参数依然通过调用者栈帧传入，但是编译器会把栈上参数拷贝一份到堆上。然后外层函数和闭包函数都使用堆上分配的这个。</p><p><strong>捕获的是返回值</strong></p><p>如果捕获的是返回值，则处理又不同。</p><p>调用者栈帧上依然会分配返回值空间，不过闭包的外层函数会在堆上也分配一个，外层函数和闭包函数都使用堆上分配的这个。</p><p>但是在外层函数返回前，需要把堆上的返回值拷贝到栈上的返回值空间。</p><h3 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3 小结"></a>4.3 小结</h3><p>处理方式虽然多种多样，但是目标只有一个，那就是<strong>保持捕获变量在外层函数和闭包函数中的一致性</strong>。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h2><ul><li><strong>闭包由 funcval 结构体和捕获变量组成</strong>。<pre><code>* funcval 结构体中的 fn 字段指向闭包函数的函数入口* 捕获变量则是当前闭包对象的参数，每个闭包对象维护各种的参数列表。</code></pre></li><li>除初始化外还被修改过的局部变量被闭包捕获后会<strong>分配到堆上，栈上保存的是指向堆上变量的指针</strong>。<pre><code>* 局部变量堆分配，变量逃逸的一种。* 所以这个时候闭包中的局部变量其实就是一个地址，都指向堆上的同一个变量。* 这也是为什么各种 for 循环最后打印出的 i 都是一个值</code></pre></li></ul><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6 参考"></a>6 参考</h2><p><code>https://zh.wikipedia.org/wiki/闭包_(计算机科学)</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Golang Test 工具指令</title>
      <link href="/2021/10/26/Golang/4%20%E5%85%B6%E4%BB%96/Golang%20Test%20%E5%B7%A5%E5%85%B7%E6%8C%87%E4%BB%A4/"/>
      <url>/2021/10/26/Golang/4%20%E5%85%B6%E4%BB%96/Golang%20Test%20%E5%B7%A5%E5%85%B7%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Golang Test 工具指令</p></blockquote><span id="more"></span><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h2><p>Go test 测试工具包含示例函数测试 (ExampleXXX)、单元测试 (TestXXX)、基准测试 (BenchmarkXXX)。</p><p>命令格式：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Go test [-c] [-i] [build flags] [packages] [flags for test binary]</span><br></pre></td></tr></table></figure><br>参数解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-c : 编译 go test 成为可执行的二进制文件，但是不运行测试。</span><br><span class="line">-i : 安装测试包依赖的 package，但是不运行测试。</span><br><span class="line"></span><br><span class="line">build flags 是编译过程中常用参数，使用命令 `go help build` 查看帮助</span><br><span class="line"></span><br><span class="line">packages 是关于包管理参数，使用命令 `go help packages` 查看帮助</span><br><span class="line"></span><br><span class="line">flags for test binary 是 test 常用参数，使用命令 `go help testflag` 查看帮助, 部分参数如下：</span><br><span class="line">-test. V : 是否输出全部的单元测试用例（不管成功或者失败），默认没有加上，所以只输出失败的单元测试用例。</span><br><span class="line">-test. Run pattern: 指定正则来运行某个/某些测试用例</span><br><span class="line">-test. Bench patten: 只跑那些性能测试用例</span><br><span class="line">-test. Benchmem : 是否在性能测试的时候输出内存情况</span><br><span class="line">-test. Benchtime t : 性能测试运行的时间，默认是 1 s</span><br><span class="line">-test. Cpuprofile cpu. Out : 是否输出 cpu 性能分析文件，为空则不做 cpu 分析</span><br><span class="line">-test. Memprofile mem. Out : 是否输出内存性能分析文件</span><br><span class="line">-test. Blockprofile block. Out : 是否输出内部 goroutine 阻塞的性能分析文件</span><br><span class="line">-test. Memprofilerate n : 内存分析参数，内存分析的抽样率, 默认 512*1024, 可结合 GOGC=off 来关闭内存回收，对每个内存块的分配进行观察。</span><br><span class="line">-test. Blockprofilerate n: 阻塞事件的分析参数，指定抽样频率，控制 goroutine 阻塞时候打点的纳秒数。默认 1。</span><br><span class="line">-test. Parallel n : 性能测试的程序并行 cpu 数，默认等于 GOMAXPROCS。</span><br><span class="line">-test. Timeout t : 如果测试用例运行时间超过 t，则抛出 panic</span><br><span class="line">-test. Cpu 1,2,4 : 程序运行在哪些 CPU 上面</span><br><span class="line">-test. Short : 将那些运行时间较长的测试用例运行时间缩短</span><br><span class="line">-test. Outputdir : 输出目录</span><br><span class="line">-test. Coverprofile : 测试覆盖率参数，指定输出文件</span><br></pre></td></tr></table></figure><p>测试函数示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test 测试函数</span></span><br><span class="line">Func TestXXX (t *testing. T) &#123; … &#125;</span><br><span class="line"><span class="comment">// benchmark 基准函数</span></span><br><span class="line">Func BenchmarkXXX (b *testing. B) &#123; … &#125;</span><br><span class="line"><span class="comment">// examples 示例函数</span></span><br><span class="line">Func ExamplePrintln () &#123;</span><br><span class="line">    Println (“output”)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行测试函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Go test -v -run=<span class="string">&#x27;TestXXX&#x27;</span></span><br><span class="line"></span><br><span class="line">Go test -v xxx_test. Go -run=<span class="string">&#x27;TestXXX&#x27;</span></span><br><span class="line"></span><br><span class="line">Go test -v xxx_test. Go -test. Run TestXXX</span><br><span class="line"></span><br><span class="line">Go test -v xxx_test. Go -bench=.</span><br><span class="line"></span><br><span class="line">Go test -v xxx_test. Go -bench=XXX</span><br><span class="line"></span><br><span class="line">Go test -v xxx_test. Go -bench=BenchmarkXXX</span><br><span class="line"></span><br><span class="line">Go test -v xxx_test. Go -bench=^BenchmarkXXX$ -run=^$</span><br></pre></td></tr></table></figure><p>-v 参数表示是否通过测试都会显示结果，不加-v 表示只显示未通过的测试</p><p>其他参数：-p -cpu=1,2,4 -args= -parallel -timeout -run -short</p><p>执行基准测试:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Go test -bench=.</span><br><span class="line">Go test -c</span><br><span class="line">./xxx. Test -test. Bench=.</span><br><span class="line">Go test -bench=. -benchtime <span class="number">0.1</span> s</span><br><span class="line">./xxx. Test -test. Bench=. -test. Benchtime=<span class="number">1</span> s</span><br><span class="line">Go test -bench=. -count=<span class="number">2</span></span><br><span class="line">./xxx. Test -test. Bench=. -test. Count=<span class="number">2</span></span><br><span class="line"># -benchmem : 打印用于基准测试的内存分配统计数据</span><br><span class="line">Go test -bench=. -benchmem</span><br><span class="line">./xxx. Test -test. Bench -test. Benchmem</span><br></pre></td></tr></table></figure><h2 id="2-参考："><a href="#2-参考：" class="headerlink" title="2 参考："></a>2 参考：</h2><ul><li><a href="https://deepzz.com/post/the-command-flag-of-go-test.html">Go 测试，go test 工具的具体指令 flag</a></li><li><a href="https://sanyuesha.com/2019/08/21/go-test/">Golang 测试</a></li><li><a href="https://studygolang.com/articles/2491">golang test测试使用</a></li><li><a href="http://doc.golang.ltd/">标准库testing</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
          <category> Packages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go-Package </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Golang Connection Reset by Peer 或 EOF 问题</title>
      <link href="/2021/10/26/Golang/4%20%E5%85%B6%E4%BB%96/http.Client%E8%AF%B7%E6%B1%82%E7%A8%8B%E5%BA%8F%E9%81%87%E5%88%B0%20Connection%20Reset%20by%20Peer%20%E6%88%96%20EOF%20%E9%97%AE%E9%A2%98/"/>
      <url>/2021/10/26/Golang/4%20%E5%85%B6%E4%BB%96/http.Client%E8%AF%B7%E6%B1%82%E7%A8%8B%E5%BA%8F%E9%81%87%E5%88%B0%20Connection%20Reset%20by%20Peer%20%E6%88%96%20EOF%20%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Golang http.Client请求程序遇到Connection Reset by peer 或 EOF 问题</p></blockquote><span id="more"></span><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1 问题"></a>1 问题</h2><p>线上服务经常规律性的出现http.Client请求服务器数据和上报数据时报Connection Reset by peer 和 EOF 错误,在测试环境一直没有出现过；</p><h2 id="2-原因"><a href="#2-原因" class="headerlink" title="2 原因"></a>2 原因</h2><p>原因是线上环境是通过代理转发，存在并发连接数限制，当达到限制时服务器会关闭其中一些连接； 同时客户端请求存在连接复用,如果在收到关闭之前复用了连接就会出现Connection Reset by peer; EOF错误发生在请求建立后读取时，此时服务器已经关闭连接，客户端还没有检测到关闭前读取数据；</p><h2 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3 解决方案"></a>3 解决方案</h2><p>在请求时关闭连接复用，每次都使用新的连接；<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">req, err := NewRequest(<span class="string">&quot;POST&quot;</span>, url, body)</span><br><span class="line">req.Close = <span class="literal">true</span></span><br></pre></td></tr></table></figure><br>或者头部设置连接为关闭状态</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">req, err := NewRequest(<span class="string">&quot;POST&quot;</span>, url, body)</span><br><span class="line">req.Header.Add(<span class="string">&quot;Connection&quot;</span>, <span class="string">&quot;close&quot;</span>)</span><br></pre></td></tr></table></figure><p>使用 Transport 取消 HTTP利用连接 DisableKeepAlives 为true时，当前连接只会使用一次</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tr := http.Transport&#123;DisableKeepAlives: <span class="literal">true</span>&#125;</span><br><span class="line">client := http.Client&#123;Transport: &amp;tr&#125;</span><br><span class="line">client.Get(url)</span><br></pre></td></tr></table></figure><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><ul><li><a href="https://www.cnblogs.com/jackluo/p/10452026.html">golang http.client 遇到了 Connection reset by peer 问题</a></li><li><a href="https://blog.csdn.net/weixin_34161032/article/details/86360913">connection reset by peer问题总结及解决方案</a></li><li><a href="https://my.oschina.net/shou1156226/blog/808613">Golang 解决”Connection reset by peer”或”EOF”问题</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Defer</title>
      <link href="/2021/10/26/Golang/0%20%E5%9F%BA%E7%A1%80/%E5%85%B3%E9%94%AE%E5%AD%97/Defer/"/>
      <url>/2021/10/26/Golang/0%20%E5%9F%BA%E7%A1%80/%E5%85%B3%E9%94%AE%E5%AD%97/Defer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Defer 和栈比较相似，<strong>先进后出</strong>，即先注册的 defer 会后执行。</p></blockquote><span id="more"></span><h2 id="1-1-12"><a href="#1-1-12" class="headerlink" title="1 1.12"></a>1 1.12</h2><blockquote><p>本节将的是 Go 1.12 版本的 defer。1.13 和1.14 都有不少优化。</p></blockquote><h3 id="1-1-demo"><a href="#1-1-demo" class="headerlink" title="1.1 demo"></a>1.1 demo</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> B()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// dosomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，编译后伪指令如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r = deferproc(<span class="number">8</span>,B)</span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">goto</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"> ret:</span><br><span class="line">     runtime.deferreturn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>deferproc</code>负责把要执行的函数信息保存起来，也叫 <strong>defer 注册</strong>。</p><p>deferproc()函数会返回0，if 分支和 panic，recover有关，暂时忽略。</p><p>首先调用 deferproc() 进行 defer 注册，然后继续执行后面的逻辑， 直到返回之前通过<code>deferreturn</code>执行注册的 defer 函数。</p><blockquote><p>先注册后调用，所以实现了延迟执行的效果。</p></blockquote><p>defer 信息会注册到一个<strong>链表</strong>，而当前执行的 goroutine 会持有这个链表的头指针。，每个goroutine都要一个结构体g，其中有字段 _defer 就指向defer链表头。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go  395行</span></span><br><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">_defer       *_defer <span class="comment">// innermost defer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>defer 链表中存储的是一个一个的 defer 结构体。<strong>每次注册 defer 时会将当前 defer 链接到链表头，同时 Defer 执行时也是从链表头开始执行</strong>。</p><blockquote><p>所以才会有先进后出的感觉。</p></blockquote><p>defer 结构体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">siz     <span class="type">int32</span> <span class="comment">// 参数和返回值共占多少字节</span></span><br><span class="line">started <span class="type">bool</span> <span class="comment">// 标记defer是否已经执行</span></span><br><span class="line">sp        <span class="type">uintptr</span>  <span class="comment">// 调用者栈指针，通过这个调用者可以判断自己注册的defer是否都执行完了</span></span><br><span class="line">pc        <span class="type">uintptr</span>  <span class="comment">// deferproc 的返回地址</span></span><br><span class="line">fn        *funcval <span class="comment">// 要注册的 funcval</span></span><br><span class="line">_panic    *_panic  <span class="comment">// panic that is running defer</span></span><br><span class="line">link      *_defer <span class="comment">// 链接到前一个注册的 _defer 结构体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-参数与闭包"><a href="#1-2-参数与闭包" class="headerlink" title="1.2 参数与闭包"></a>1.2 参数与闭包</h3><p>需要关注的是 defer 传参和闭包变量捕获机制。</p><p><strong>普通参数</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(a <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(a) <span class="comment">// 1</span></span><br><span class="line">&#125;(a)</span><br><span class="line">a = a + b</span><br><span class="line">fmt.Println(a, b) <span class="comment">// 3,2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 defer function 只使用到了一个 int 类型的参数。</p><p>所以会直接将参数a的<strong>值</strong>拷贝到 defer function 对应的栈空间中。</p><p>等函数执行完成，返回之前就会执行这个 defer function，将 a 的值打印出来。</p><p>由于是拷贝的<strong>值</strong>，所以后续a=a+b 修改变量a的值和和这个  defer function 中的参数 a 已经完全没有关系了，最终打印出a的值还是传入时的1。</p><p><strong>引入普通参数的 defer function 参数值在执行 defer 时就确定了。</strong></p><p><strong>闭包变量</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">a = a + b</span><br><span class="line">fmt.Println(a, b) <span class="comment">// 5 2</span></span><br><span class="line">&#125;(b)</span><br><span class="line">a = a + b</span><br><span class="line">fmt.Println(a, b) <span class="comment">// 3 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述例子中 defer function 除了参数 b 之外还引用到了 外层局部变量 a。</p><p>这里就形成了<strong>闭包</strong>。</p><blockquote><p>闭包也是一个 function value。</p></blockquote><p>同时由于捕获变量a除了初始化赋值之外，还被修改过，所以局部变量a改为<strong>堆分配</strong>，栈上只存储a的地址。</p><p>所以后续a的修改也会影响到defer function，导致最终打印出a的值为5</p><p><strong>引入闭包变量的 defer function 参数值需要到 defer function 执行时才能确定。</strong></p><h3 id="1-3-缺点"><a href="#1-3-缺点" class="headerlink" title="1.3 缺点"></a>1.3 缺点</h3><ul><li>1）defer 在堆上分配</li><li>2）使用链表注册 defer 信息</li></ul><p>以上两点导致了 defer 很慢。</p><p>go 1.13 1.14 版本分别对上述问题进行了不同的优化。</p><h2 id="2-优化"><a href="#2-优化" class="headerlink" title="2 优化"></a>2 优化</h2><h3 id="2-1-1-13"><a href="#2-1-1-13" class="headerlink" title="2.1 1.13"></a>2.1 1.13</h3><p>Go 1.12 中通过 runtime.deferproc() 函数注册 defer，将 _defer结构体分配在<strong>堆</strong>上。</p><p>Go 1.13 中通过编译器优化，生成局部变量，将 defer 信息分配在<strong>栈</strong>上。然后通过 runtime.deferprocStack() 将 _defer 结构体注册到链表中。</p><p>1.13 主要优化点在于减少 defer 信息的堆分配。由于循环中的 defer 调用无法进行编译器优化，因此只能使用 1.12 版本中的处理方法。所以 defer 结构体中增加了一个字段，用于标识是否为堆分配。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 、src/runtime/runtime2.go 861 行</span></span><br><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">heap    <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1.13 版本 defer 官方提供的数据是性能提升 30%。</p><h3 id="2-2-1-14"><a href="#2-2-1-14" class="headerlink" title="2.2 1.14"></a>2.2 1.14</h3><p>对于能够显式优化的部分，进行了优化。</p><p>比如</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> A1(i, <span class="number">2</span>*i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> i &gt; <span class="number">1</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> A2(<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">(a, b <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(a, b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">(m, n <span class="type">string</span>)</span></span> &#123;</span><br><span class="line">fmt.Println(m, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>A1 优化</strong></p><p>函数A中的第一个 defer，<code>defer A1(i, 2*i)</code>编译器会对其进行优化，直接在函数A return 之前，调用A1函数，直接省去了构造 defer 链表项和注册到 链表的过程。</p><p>编译后代码可以看做如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> a,b <span class="type">int</span>=i,<span class="number">2</span>*i</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    A1(a,b)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明了调用A1需要的两个变量，a,b，然后在 return 之前调用了 A1函数。</p><p>降低消耗的同时，也实现了延迟执行的效果。</p><p><strong>A2优化</strong></p><p>第二个 defer <code>defer A2(&quot;hello&quot;, &quot;world&quot;)</code>就不能这样处理了，应该这个defer 需要到执行阶段才能确定是否需要调用。Go 语言用一个标识变量 df 来解决这个问题。</p><p>df 中的每一位都用来标识一个 defer 是否需要被执行。比如之前的 defer A1 需要执行，所以就把第一位置为1，即<code>df|=1</code>。</p><p>执行前判定对应标识位是否为1，同时执行之前还需要将标识位置0，防止重置执行。</p><p>defer A1 调用如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> df <span class="type">byte</span></span><br><span class="line"><span class="keyword">var</span> a,b <span class="type">int</span>=i,<span class="number">2</span>*i</span><br><span class="line"></span><br><span class="line">    df|=<span class="number">1</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> df&amp;<span class="number">1</span>&gt;<span class="number">0</span>&#123;</span><br><span class="line">        df=df&amp;^<span class="number">1</span></span><br><span class="line">        A1(a,b)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的方法处理 defer A2</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">(i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> df <span class="type">byte</span></span><br><span class="line"><span class="keyword">var</span> a,b <span class="type">int</span>=i,<span class="number">2</span>*i</span><br><span class="line"><span class="keyword">var</span> m,n <span class="type">int</span>=<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span></span><br><span class="line">    df|=<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i&gt;<span class="number">1</span>&#123;</span><br><span class="line">        df |=<span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">   <span class="keyword">if</span> df&amp;<span class="number">2</span>&gt;<span class="number">0</span>&#123;</span><br><span class="line">        df=df&amp;^<span class="number">2</span></span><br><span class="line">        A2(m,n)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> df&amp;<span class="number">1</span>&gt;<span class="number">0</span>&#123;</span><br><span class="line">        df=df&amp;^<span class="number">1</span></span><br><span class="line">        A1(a,b)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Go1.14 defer 优化就是通过编译期置入代码，把defer函数的执行逻辑展开在所属函数内，从而免于创建 _defer 结构体，而且不需要注册到 defer 链表。</strong></p><p>Go 语言称这种方式为 open coded defer。</p><p>但是和 1.13 版本一样，这种方式依然不适用于 循环中的 defer，所以1.14中版本还是保留了 1.12 版本的 defer处理方式。</p><p>1.14 版本 defer 性能提升了一个数量级。</p><p><strong>栈扫描</strong></p><p>性能提升也不是没有代价的，像这样展开后的 defer 如果在执行之前，出现了 panic 或者执行了 runtime.Goexit ，此时就会直接跳去执行 defer 链表，所以后面的defer 展开代码就无法执行了。</p><p>于是 Go1.14 又在 defer 中增加了几个字段，同时通过栈扫描的方式，来执行这些原本无法执行的 defer。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 、src/runtime/runtime2.go 861 行</span></span><br><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line">openDefer <span class="type">bool</span></span><br><span class="line"></span><br><span class="line">fd   unsafe.Pointer <span class="comment">// funcdata for the function associated with the frame</span></span><br><span class="line">varp <span class="type">uintptr</span>        <span class="comment">// value of varp for the stack frame</span></span><br><span class="line">framepc <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助这些信息，可以找到未注册到链表的 defer 函数并按照正确的顺序执行。</p><p><strong>这就导致 1.14 版本中 defer 变快的同时，panic 变得更慢了。</strong></p><blockquote><p>官方这样优化肯定是有自己的考量，毕竟 panic 发生的几率比 defer 低。</p></blockquote><h2 id="3-小结"><a href="#3-小结" class="headerlink" title="3 小结"></a>3 小结</h2><p><strong>defer 注册流程</strong></p><ul><li>1）deferproc 进行 defer 注册。</li><li>2）return之前通过 runtime.deferreturn() 调用注册的 defer 函数。</li></ul><p><strong>具体执行逻辑</strong></p><ul><li>1）从当前 goroutine 的字段 defer 中拿到 defer 链表</li><li>2）从链表中拿到第一个要执行的 defer 结构体</li><li>3）根据 defer 结构体的 fn 字段找到对应的 funcval</li><li>4）根据 funcval 找打对应的函数入口地址</li><li>5）执行具体函数</li></ul><p><strong>优化记录</strong></p><ul><li><p>1.1~1.12：堆分配</p><ul><li>编译期将 defer 关键字转换为 deferproc ，并在调用defer关键字的函数返回之前插入 runtime.deferreturn 。</li><li>运行时 runtime.deferproc 会将一个新的<code>runtime._defer</code>结构体追加到当前 Goroutine 的 defer 链表头。</li><li>运行时调用 runtime.deferreturn 会从当前 goroutine 的 defer 链表中取出 <code>runtime._defer</code>结构并依次执行</li></ul></li><li>1.13：栈分配<ul><li>当该关键字在函数体中最多执行一次时，编译期间会将结构体分配到栈上，并调用 runtime.deferprocStack</li></ul></li><li>1.14：开放编码<ul><li>编译期间判断 <code>defer</code> 关键字、<code>return</code> 语句的个数确定是否开启开放编码优化；</li><li>如果 <code>defer</code> 关键字的执行可以在编译期间确定，会在函数返回前直接插入相应的代码，否则会由运行时的  runtime.deferreturn 处理。</li></ul></li></ul><p><strong>问题</strong></p><p><strong>defer 调用时机与执行顺序</strong></p><p>deferproc 注册时是往链表头注册，而调用时也是从链表头开始调用，所以是先进后出的效果。</p><p><strong>参数问题</strong></p><p>注册时就会拷贝 defer 函数的参数(<strong>参数预计算</strong>)，所以如果是参数是值类型，注册时就确定了，如果是指针类型，则后续的修改也会影响到 defer 函数中的参数。</p><blockquote><p>可以简单理解为 defer 参数在调用defer关键字时确定。但是如果传的是指针那被修改也就说得通了。</p></blockquote><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><code>https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 关键字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Map</title>
      <link href="/2021/10/26/Golang/0%20%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Map/"/>
      <url>/2021/10/26/Golang/0%20%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Map/</url>
      
        <content type="html"><![CDATA[<blockquote><p>map 的底层数据结构和实现原理</p></blockquote><span id="more"></span><h2 id="1-基础使用"><a href="#1-基础使用" class="headerlink" title="1 基础使用"></a>1 基础使用</h2><h3 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1.1 概述"></a>1.1 概述</h3><p>核心特征包含下述三点：</p><ul><li>存储基于 key-value 对映射的模式；</li><li>基于 key 维度实现存储数据的去重；</li><li>读、写、删操作控制，时间复杂度 O(1).</li></ul><h3 id="1-2-初始化"><a href="#1-2-初始化" class="headerlink" title="1.2 初始化"></a>1.2 初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">myMap1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>,<span class="number">2</span>)</span><br><span class="line">myMap2 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line"></span><br><span class="line">myMap3 :=<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>&#123;</span><br><span class="line">  <span class="number">1</span>:<span class="number">2</span>,</span><br><span class="line">  <span class="number">3</span>:<span class="number">4</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>map 中，key 的数据类型必须为可比较的类型，chan、map、func不可比较</li></ul><h3 id="1-3-读"><a href="#1-3-读" class="headerlink" title="1.3 读"></a>1.3 读</h3><ul><li>直接读，倘若 key 存在，则获取到对应的 val，倘若 key 不存在或者 map 未初始化，会返回 val 类型的零值作为兜底.</li><li><p>读的同时添加一个 bool 类型的 flag 标识是否读取成功. 倘若 ok == false，说明读取失败， key 不存在，或者 map 未初始化.</p><h3 id="1-4-写"><a href="#1-4-写" class="headerlink" title="1.4 写"></a>1.4 写</h3></li><li><p>如果 map 未初始化，直接执行写操作会导致 panic</p><h3 id="1-5-删除"><a href="#1-5-删除" class="headerlink" title="1.5 删除"></a>1.5 删除</h3></li><li><p>执行 delete 方法时，倘若 key 存在，则会从 map 中将对应的 key-value 对删除；倘若 key 不存在或 map 未初始化，则方法直接结束，不会产生显式提示</p><h3 id="1-6-遍历"><a href="#1-6-遍历" class="headerlink" title="1.6 遍历"></a>1.6 遍历</h3></li></ul><ul><li>基于 k,v 依次承接 map 中的 key-value 对<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k,v := <span class="keyword">range</span> myMap&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>基于 k 依次承接 map 中的 key，不关注 val 的取值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k := <span class="keyword">range</span> myMap&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在执行 map 遍历操作时，获取的 key-value 对并没有一个固定的顺序，因此前后两次遍历顺序可能存在差异</p></li></ul><h3 id="1-7-并发冲突"><a href="#1-7-并发冲突" class="headerlink" title="1.7 并发冲突"></a>1.7 并发冲突</h3><p>map 不是并发安全的数据结构，倘若存在并发读写行为，会抛出 fatal error.<br>具体规则是：</p><ul><li>并发读没有问题；</li><li>并发读写中的“写”是广义上的，包含写入、更新、删除等操作；</li><li>读的时候发现其他 goroutine 在并发写，抛出 fatal error；</li><li>写的时候发现其他 goroutine 在并发写，抛出 fatal error.<blockquote><p>fatal error，是一种比 panic 更严重的错误，无法使用 recover 操作捕获.</p></blockquote></li></ul><h2 id="2-核心原理"><a href="#2-核心原理" class="headerlink" title="2 核心原理"></a>2 核心原理</h2><p>hashmap 就是在算法上基于 hash 实现 key 的映射和寻址；在数据结构上基于桶数组实现 key-value 对的存储.</p><ul><li>通过哈希方法取得 key 的 hash 值</li><li>hash 值对桶数组长度取模，确定其所属的桶；</li><li>在桶中插入 key-value 对.</li><li>相同的 key 必然产生相同的 hash 值，因此能映射到相同的桶中，通过桶内遍历的方式锁定对应的 key-value 对</li></ul><h3 id="2-1-hash"><a href="#2-1-hash" class="headerlink" title="2.1 hash"></a>2.1 hash</h3><blockquote><p>hash 译作散列，是一种将任意长度的输入压缩到某一固定长度的输出摘要的过程，由于这种转换属于压缩映射，输入空间远大于输出空间，因此不同输入可能会映射成相同的输出结果. 此外，hash在压缩过程中会存在部分信息的遗失，因此这种映射关系具有不可逆的特质.</p></blockquote><ul><li>hash 的可重入性：相同的 key，必然产生相同的 hash 值</li><li>hash 的离散性：只要两个 key 不相同，不论其相似度的高低，产生的 hash 值会在整个输出域内均匀地离散化</li><li>hash 的离散性：只要两个 key 不相同，不论其相似度的高低，产生的 hash 值会在整个输出域内均匀地离散化</li><li>hash 冲突：由于输入域（key）无穷大，输出域（hash 值）有限，因此必然存在不同 key 映射到相同 hash 值的情况，称之为 hash 冲突</li></ul><h3 id="2-2-桶数组"><a href="#2-2-桶数组" class="headerlink" title="2.2 桶数组"></a>2.2 桶数组</h3><p>map 中，会通过长度为 2 的整数次幂的桶数组进行 key-value 对的存储：</p><ul><li>每个桶固定可以存放 8 个 key-value 对；</li><li><p>倘若超过 8 个 key-value 对打到桶数组的同一个索引当中，此时会通过创建桶链表的方式来化解这一问题.</p><h3 id="2-3-hash-冲突"><a href="#2-3-hash-冲突" class="headerlink" title="2.3 hash 冲突"></a>2.3 hash 冲突</h3></li><li><p>由于 hash 冲突的存在，不同 key 可能存在相同的 hash 值; hash 值会对桶数组长度取模，因此不同 hash 值可能被打到同一个桶中; 不同的 key-value 可能被映射到 map 的同一个桶当中</p></li><li>拉链法: 将命中同一个桶的元素通过链表的形式进行链接，因此很便于动态扩展.</li><li>开放寻址法: 在插入新条目时，会基于一定的探测策略持续寻找，直到找到一个可用于存放数据的空位为止</li><li>map 的插入写流程, 结合了拉链法和开放寻址法两种思路<ul><li>桶数组中的每个桶，严格意义上是一个单向桶链表，以桶为节点进行串联</li><li>每个桶固定可以存放 8 个 key-value 对</li><li>当 key 命中一个桶时，首先根据开放寻址法，在桶的 8 个位置中寻找空位进行插入</li><li>倘若桶的 8 个位置都已被占满，则基于桶的溢出桶指针，找到下一个桶，重复第（3）步</li><li>倘若遍历到链表尾部，仍未找到空位，则基于拉链法，在桶链表尾部续接新桶，并插入 key-value 对</li></ul></li></ul><h3 id="2-4-扩容优化性能"><a href="#2-4-扩容优化性能" class="headerlink" title="2.4 扩容优化性能"></a>2.4 扩容优化性能</h3><blockquote><p>map 的桶数组长度固定不变，那么随着 key-value 对数量的增长，当一个桶下挂载的 key-value 达到一定的量级，此时操作的时间复杂度会趋于线性, 导致性能不可接受</p></blockquote><p>扩容机制:</p><ul><li>扩容分为增量扩容和等量扩容</li><li>当桶内 key-value 总数/桶数组长度 &gt; 6.5 时发生增量扩容，桶数组长度增长为原值的两倍</li><li>当桶内溢出桶数量大于等于 2^B 时( B 为桶数组长度的指数，B 最大取 15)，发生等量扩容，桶的长度保持为原值</li><li>采用渐进扩容的方式，当桶被实际操作到时，由使用者负责完成数据迁移，避免因为一次性的全量数据迁移引发性能抖动</li></ul><h2 id="3-数据结构"><a href="#3-数据结构" class="headerlink" title="3 数据结构"></a>3 数据结构</h2><h3 id="3-1-hmap"><a href="#3-1-hmap" class="headerlink" title="3.1 hmap"></a>3.1 hmap</h3><p><img src="StarDust/source/_posts/技术/Golang/0%20基础/数据结构/Map/file-20250305235454430.png" alt=""></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hmap <span class="keyword">struct</span> &#123;</span><br><span class="line">    count     <span class="type">int</span> </span><br><span class="line">    flags     <span class="type">uint8</span></span><br><span class="line">    B         <span class="type">uint8</span>  </span><br><span class="line">    noverflow <span class="type">uint16</span> </span><br><span class="line">    hash0     <span class="type">uint32</span> </span><br><span class="line">    buckets    unsafe.Pointer </span><br><span class="line">    oldbuckets unsafe.Pointer </span><br><span class="line">    nevacuate  <span class="type">uintptr</span>       </span><br><span class="line">    extra *mapextra </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>count：map 中的 key-value 总数</li><li>flags：map 状态标识，可以标识出 map 是否被 goroutine 并发读写</li><li>B：桶数组长度的指数，桶数组长度为 2^B</li><li>noverflow：map 中溢出桶的数量</li><li>hash0：hash 随机因子，生成 key 的 hash 值时会使用到</li><li>buckets：桶数组</li><li>oldbuckets：扩容过程中老的桶数组</li><li>nevacuate：扩容时的进度标识，index 小于 nevacuate 的桶都已经由老桶转移到新桶中</li><li>extra：预申请的溢出桶</li></ul><h3 id="3-2-mapextra"><a href="#3-2-mapextra" class="headerlink" title="3.2 mapextra"></a>3.2 mapextra</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> mapextra <span class="keyword">struct</span> &#123;</span><br><span class="line">    overflow    *[]*bmap</span><br><span class="line">    oldoverflow *[]*bmap</span><br><span class="line">  </span><br><span class="line">    nextOverflow *bmap</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 map 初始化时，如果容量过大，会提前申请好一批溢出桶，方便后续使用，这部分溢出桶存放在 hmap.mapextra 当中</p><ul><li>mapextra.overflow：供桶数组 buckets 使用的溢出桶</li><li>mapextra.oldoverFlow: 扩容流程中，供老桶数组 oldBuckets 使用的溢出桶</li><li>mapextra.nextOverflow：下一个可用的溢出桶</li></ul><h3 id="3-3-bmap"><a href="#3-3-bmap" class="headerlink" title="3.3 bmap"></a>3.3 bmap</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bucketCnt = <span class="number">8</span></span><br><span class="line"><span class="keyword">type</span> bmap <span class="keyword">struct</span> &#123;</span><br><span class="line">tophash [bucketCnt]<span class="type">uint8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>bmap 就是 map 中的桶，可以存储 8 组 key-value 对的数据，以及一个指向下一个溢出桶的指针</li><li>每组 key-value 对数据包含 key 高 8 位 hash 值 tophash，key 和 val 三部分</li><li>tophash、key 和 val 的数据长度固定，因此可以通过内存地址偏移的方式寻找到后续的 key 数组、val 数组以及溢出桶指针</li></ul><h2 id="4-构造方法"><a href="#4-构造方法" class="headerlink" title="4 构造方法"></a>4 构造方法</h2><blockquote><p>创建 map 时，会调用 runtime/map.go 文件中的 makemap 方法</p></blockquote><h3 id="4-1-makemap"><a href="#4-1-makemap" class="headerlink" title="4.1 makemap"></a>4.1 makemap</h3><ul><li>hint 为 map 拟分配的容量；在分配前，会提前对拟分配的内存大小进行判断，倘若超限，会将 hint 置为零</li><li>通过 new 方法初始化 hmap</li><li>调用 fastrand，构造 hash 因子：hmap.hash0</li><li>大致上基于 log2(B) &gt;= hint 的思路,计算桶数组的容量 B</li><li>调用 makeBucketArray 方法，初始化桶数组 hmap.buckets</li><li>倘若 map 容量较大，会提前申请一批溢出桶 hmap.extra</li></ul><h3 id="4-2-overLoadFactor"><a href="#4-2-overLoadFactor" class="headerlink" title="4.2 overLoadFactor"></a>4.2 overLoadFactor</h3><p>通过 overLoadFactor 方法，对 map 预分配容量和桶数组长度指数进行判断，决定是否仍需要增长 B 的数值</p><ul><li>map 预分配容量小于等于 8，B 取 0，桶的个数为 1</li><li>保证 map 预分配容量小于等于桶数组长度 * 6.5</li></ul><h3 id="4-3-makeBucketArray"><a href="#4-3-makeBucketArray" class="headerlink" title="4.3 makeBucketArray"></a>4.3 makeBucketArray</h3><ul><li>makeBucketArray 会为 map 的桶数组申请内存，在桶数组的指数 b &gt;= 4时（桶数组的容量 &gt;= 52 ），会需要提前创建溢出桶.</li><li>通过 base 记录桶数组的长度，不包含溢出桶；通过 nbuckets 记录累加上溢出桶后，桶数组的总长度.</li><li>调用 newarray 方法为桶数组申请内存空间，连带着需要初始化的溢出桶</li><li>倘若 base != nbuckets，说明需要创建溢出桶，会基于地址偏移的方式，通过 nextOverflow 指向首个溢出桶的地址</li><li>倘若需要创建溢出桶，会在将最后一个溢出桶的 overflow 指针指向 buckets 数组，以此来标识申请的溢出桶已经用完</li></ul><h2 id="5-读流程"><a href="#5-读流程" class="headerlink" title="5 读流程"></a>5 读流程</h2><blockquote><p>map 读操作最终会走进 runtime/map.go 的 mapaccess 方法中</p><h3 id="5-1-读流程概览"><a href="#5-1-读流程概览" class="headerlink" title="5.1 读流程概览"></a>5.1 读流程概览</h3></blockquote><p>map 读流程主要分为以下几步：</p><ul><li>根据 key 取 hash 值</li><li>根据 hash 值对桶数组取模，确定所在的桶</li><li>沿着桶链表依次遍历各个桶内的 key-value 对</li><li>命中相同的 key，则返回 value；倘若 key 不存在，则返回零值</li></ul><h3 id="5-2-mapaccess-方法"><a href="#5-2-mapaccess-方法" class="headerlink" title="5.2 mapaccess 方法"></a>5.2 mapaccess 方法</h3><ul><li>倘若 map 未初始化，或此时存在 key-value 对数量为 0，直接返回零值</li><li>倘若发现存在其他 goroutine 在写 map，直接抛出并发读写的 fatal error；其中，并发写标记，位于 hmap.flags 的第 3 个 bit 位</li><li>通过 maptype.hasher() 方法计算得到 key 的 hash 值，并对桶数组长度取模，取得对应的桶</li><li>在取桶时，会关注当前 map 是否处于扩容的流程，倘若是的话，需要在老的桶数组 oldBuckets 中取桶，通过 evacuated 方法判断桶数据是已迁到新桶还是仍存留在老桶，倘若仍在老桶，需要取老桶进行遍历<ul><li>在取老桶前，会先判断 map 的扩容流程是否是增量扩容，倘若是的话，说明老桶数组的长度是新桶数组的一半，需要将桶长度值 m 除以 2</li><li>取老桶时，会调用 evacuated 方法判断数据是否已经迁移到新桶. 判断的方式是，取桶中首个 tophash 值，倘若该值为 2,3,4 中的一个，都代表数据已经完成迁移</li></ul></li><li>取 key hash 值的高 8 位值 top. 倘若该值 &lt; 5，会累加 5，以避开 0 ~ 4 的取值. 因为这几个值会用于枚举</li><li>开启两层 for 循环进行遍历流程，外层基于桶链表，依次遍历首个桶和后续的每个溢出桶，内层依次遍历一个桶内的 key-value 对</li></ul><h2 id="6-写流程"><a href="#6-写流程" class="headerlink" title="6 写流程"></a>6 写流程</h2><h3 id="6-1-写流程梳理"><a href="#6-1-写流程梳理" class="headerlink" title="6.1 写流程梳理"></a>6.1 写流程梳理</h3><p>map 写流程主要分为以下几步：</p><ul><li>根据 key 取 hash 值；</li><li>根据 hash 值对桶数组取模，确定所在的桶；</li><li>倘若 map 处于扩容，则迁移命中的桶，帮助推进渐进式扩容；</li><li>沿着桶链表依次遍历各个桶内的 key-value 对；</li><li>倘若命中相同的 key，则对 value 中进行更新；</li><li>倘若 key 不存在，则插入 key-value 对；</li><li>倘若发现 map 达成扩容条件，则会开启扩容模式，并重新返回第（2）步</li></ul><h3 id="6-2-mapassign"><a href="#6-2-mapassign" class="headerlink" title="6.2  mapassign"></a>6.2  mapassign</h3><ul><li>写操作时，倘若 map 未初始化，直接 panic</li><li>倘若其他 goroutine 在进行写或删操作，抛出并发写 fatal error</li><li>通过 maptype.hasher() 方法求得 key 对应的 hash 值</li><li>通过异或位运算，将 map.flags 的第 3 个 bit 位置为 1，添加写标记</li><li>倘若 map 的桶数组 buckets 未空，则对其进行初始化</li><li>找到当前 key 对应的桶索引 bucket</li><li>倘若发现当前 map 正处于扩容过程，则帮助其渐进扩容</li><li>从 map 的桶数组 buckets 出发，结合桶索引和桶容量大小，进行地址偏移，获得对应桶 b</li><li>取得 key 的高 8 位 tophash</li><li>提前声明好的三个指针，用于指向存放 key-value 的空槽</li><li>开启两层 for 循环，外层沿着桶链表依次遍历，内层依次遍历桶内的 key-value 对</li><li>倘若 key 的 tophash 和当前位置 tophash 不同，则会尝试将 inserti、insertk elem 调整指向首个空位，用于后续的插入操作</li><li>倘若找到了相等的 key，则执行更新操作，并且直接跳转到方法的 done 标志位处，进行收尾处理</li><li>倘若没找到相等的 key，会在执行插入操作前，判断 map 是否需要开启扩容模式</li><li>倘若遍历完桶链表，都没有为当前待插入的 key-value 对找到空位，则会创建一个新的溢出桶，挂载在桶链表的尾部，并将 inserti、insertk、elem 指向溢出桶的首个空位</li><li>将 tophash、key、value 插入到取得空位中，并且将 map 的 key-value 对计数器 count 值加 1</li><li>收尾环节，再次校验是否有其他协程并发写，倘若有，则抛 fatal error. 将 hmap.flags 中的写标记抹去，然后退出方法</li></ul><h2 id="7-删流程"><a href="#7-删流程" class="headerlink" title="7 删流程"></a>7 删流程</h2><h3 id="7-1-删流程梳理"><a href="#7-1-删流程梳理" class="headerlink" title="7.1 删流程梳理"></a>7.1 删流程梳理</h3><ul><li>根据 key 取 hash 值</li><li>根据 hash 值对桶数组取模，确定所在的桶</li><li>倘若 map 处于扩容，则迁移命中的桶，帮助推进渐进式扩容</li><li>沿着桶链表依次遍历各个桶内的 key-value 对</li><li>倘若命中相同的 key，删除对应的 key-value 对；并将当前位置的 tophash 置为 emptyOne，表示为空</li><li>倘若当前位置为末位，或者下一个位置的 tophash 为 emptyRest，则沿当前位置向前遍历，将毗邻的 emptyOne 统一更新为 emptyRest</li></ul><h2 id="8-遍历流程"><a href="#8-遍历流程" class="headerlink" title="8 遍历流程"></a>8 遍历流程</h2><p>map 的遍历流程首先会走进 runtime/map.go 的 mapiterinit() 方法当中，初始化用于遍历的迭代器 hiter；接着会调用 runtime/map.go 的 mapiternext() 方法开启遍历流程</p><h3 id="8-1-迭代器数据结构"><a href="#8-1-迭代器数据结构" class="headerlink" title="8.1 迭代器数据结构"></a>8.1 迭代器数据结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hiter <span class="keyword">struct</span> &#123;</span><br><span class="line">    key         unsafe.Pointer </span><br><span class="line">    elem        unsafe.Pointer </span><br><span class="line">    t           *maptype</span><br><span class="line">    h           *hmap</span><br><span class="line">    buckets     unsafe.Pointer </span><br><span class="line">    bptr        *bmap         </span><br><span class="line">    overflow    *[]*bmap      </span><br><span class="line">    oldoverflow *[]*bmap      </span><br><span class="line">    startBucket <span class="type">uintptr</span>       </span><br><span class="line">    offset      <span class="type">uint8</span>         </span><br><span class="line">    wrapped     <span class="type">bool</span>         </span><br><span class="line">    B           <span class="type">uint8</span></span><br><span class="line">    i           <span class="type">uint8</span></span><br><span class="line">    bucket      <span class="type">uintptr</span></span><br><span class="line">    checkBucket <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>key：指向遍历得到 key 的指针</li><li>value：指向遍历得到 value 的指针</li><li>t：map 类型，包含了 key、value 类型大小等信息</li><li>h：map 的指针</li><li>bptr：当前遍历到的桶</li><li>startBucket：遍历起始位置的桶索引</li><li>offset：遍历起始位置的 key-value 对索引</li><li>wrapped：遍历是否穿越桶数组尾端回到头部了</li><li>i：当前遍历到的 key-value 对在桶中的索引</li><li>checkBucket：因为扩容流程的存在，需要额外检查的桶</li></ul><h2 id="9-扩容流程"><a href="#9-扩容流程" class="headerlink" title="9 扩容流程"></a>9 扩容流程</h2><h3 id="9-1-扩容类型"><a href="#9-1-扩容类型" class="headerlink" title="9.1 扩容类型"></a>9.1 扩容类型</h3><p>map 的扩容类型分为两类，一类叫做增量扩容，一类叫做等量扩容</p><ul><li>增量扩容<ul><li>扩容后，桶数组的长度增长为原长度的 2 倍</li><li>降低每个桶中 key-value 对的数量，优化 map 操作的时间复杂度</li></ul></li><li>等量扩容<ul><li>扩容后，桶数组的长度和之前保持一致；但是溢出桶的数量会下降</li><li>提高桶主体结构的数据填充率，减少溢出桶数量，避免发生内存泄漏</li></ul></li></ul><h3 id="9-2-扩容触发"><a href="#9-2-扩容触发" class="headerlink" title="9.2 扩容触发"></a>9.2 扩容触发</h3><ul><li>只有 map 的写流程可能开启扩容模式</li><li>写 map 新插入 key-value 对之前，会发起是否需要扩容的逻辑判断</li><li>根据 hmap 的 oldbuckets 是否空，可以判断 map 此前是否已开启扩容模式</li><li>倘若此前未进入扩容模式，且 map 中 key-value 对的数量超过 8 个，且大于桶数组长度的 6.5 倍，则进入增量扩容</li><li>倘若溢出桶的数量大于 2^B 个（即桶数组的长度；B 大于 15 时取15），则进入等量扩容</li></ul><h3 id="9-3-扩容迁移规则"><a href="#9-3-扩容迁移规则" class="headerlink" title="9.3 扩容迁移规则"></a>9.3 扩容迁移规则</h3><ul><li>在等量扩容中，新桶数组长度与原桶数组相同；</li><li>key-value 对在新桶数组和老桶数组的中的索引号保持一致；</li><li>在增量扩容中，新桶数组长度为原桶数组的两倍；</li><li>把新桶数组中桶号对应于老桶数组的区域称为 x 区域，新扩展的区域称为 y 区域.</li><li>实际上，一个 key 属于哪个桶，取决于其 hash 值对桶数组长度取模得到的结果，因此依赖于其低位的 hash 值结果.；</li><li>在增量扩容流程中，新桶数组的长度会扩展一位，假定 key 原本从属的桶号为 i，则在新桶数组中从属的桶号只可能是 i （x 区域）或者 i + 老桶数组长度（y 区域）；</li><li>当 key 低位 hash 值向左扩展一位的 bit 位为 0，则应该迁往 x 区域的 i 位置；倘若该 bit 位为 1，应该迁往 y 区域对应的 i + 老桶数组长度的位置.</li></ul><h3 id="9-4-渐进式扩容"><a href="#9-4-渐进式扩容" class="headerlink" title="9.4 渐进式扩容"></a>9.4 渐进式扩容</h3><ul><li>map 采用的是渐进扩容的方式，避免因为一次性的全量数据迁移引发性能抖动.</li><li>当每次触发写、删操作时，会为处于扩容流程中的 map 完成两组桶的数据迁移<ul><li>一组桶是当前写、删操作所命中的桶</li><li>另一组桶是，当前未迁移的桶中，索引最小的那个桶</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Function</title>
      <link href="/2021/10/26/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/Function/"/>
      <url>/2021/10/26/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/Function/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Go 语言中 function 是一等公民，可以用作参数、返回值，也可以赋值给变量。</p></blockquote><span id="more"></span><h1 id="function"><a href="#function" class="headerlink" title="function"></a>function</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">a.name = <span class="string">&quot;Hi &quot;</span> + a.name</span><br><span class="line"><span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := A&#123;name: <span class="string">&quot;17x&quot;</span>&#125;</span><br><span class="line">fmt.Println(a.GetName())</span><br><span class="line">fmt.Println(A.GetName(a))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>a.Name()</code>和 <code>A.Name(a)</code> 两种写法效果是一样的，前者只是 Go 语言提供的语法糖。</p><p>具体证明如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">t1 := reflect.TypeOf(A.GetName)</span><br><span class="line">t2 := reflect.TypeOf(NameOfA)</span><br><span class="line">fmt.Println(t1 == t2) <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NameOfA</span><span class="params">(a A)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">a.name = <span class="string">&quot;Hi &quot;</span> + a.name</span><br><span class="line"><span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>t1 t2 分别为A.Name方法 和 NameOfA 函数的类型，t1=t2 说明二者是相同的。</p><p><strong>Go 语言中函数类型只与参数和返回值有关</strong>。所以这两个类型值相等就可以证明，<strong>方法本质上就是普通的函数</strong>，而方法接收者就是隐含的第一个参数。</p><h2 id="2-2-值-指针接收者"><a href="#2-2-值-指针接收者" class="headerlink" title="2 2.值/指针接收者"></a>2 2.值/指针接收者</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line">a.name = <span class="string">&quot;Hi &quot;</span> + a.name</span><br><span class="line"><span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a *A)</span></span> SetName() <span class="type">string</span> &#123;</span><br><span class="line">a.name = <span class="string">&quot;Hi &quot;</span> + a.name</span><br><span class="line"><span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们已经知道了，方法本质上就是普通的函数，而<strong>方法接收者就是隐含的第一个参数</strong>。</p><p>Go 语言中只有值拷贝，不存在引用拷贝的说法。所以 GetName() 第一个参数为 A 类型，SetName 则为 *A 类型。</p><p>虽然都是值拷贝，但是指针接收者拷贝的是地址，所以可以修改外部变量的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   a := A&#123;name: <span class="string">&quot;17x&quot;</span>&#125;</span><br><span class="line">   pa:=&amp;a</span><br><span class="line">   <span class="comment">// 通过值调用指针接收者的方法</span></span><br><span class="line">   fmt.Println(a.SetName())</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   fmt.Println(pa.GetName())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>通过值调用指针接收者的方法，通过指针调用值接收者的方法 都是可以的？这又是什么情况？</strong></p><p>如果没有涉及到接口的话，这也是 Go 语言提供的语法糖。</p><p><strong>编译阶段</strong>就会转换成对应的形式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pa.GetName()--&gt;(*pa).GetName()</span><br><span class="line">a.SetName()--&gt;(&amp;a).SetName()</span><br></pre></td></tr></table></figure><p>由于该语法糖是在<strong>编译期间</strong>发挥作用的，编译期间无法获取地址的字面量，也就不能借助语法糖进行转换了，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法进行转换导致编译失败 </span></span><br><span class="line">A&#123;name: <span class="string">&quot;17x&quot;</span>&#125;.SetName()</span><br></pre></td></tr></table></figure><h2 id="3-赋值给变量"><a href="#3-赋值给变量" class="headerlink" title="3 赋值给变量"></a>3 赋值给变量</h2><p><strong>把 function 赋值给变量是怎么回事？</strong></p><p>Go 语言中把函数作为变量、参数和返回值时都是以 Function Value 的形式存在的，闭包也只是一个有捕获列表的 Function Value 而已。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := A&#123;name: <span class="string">&quot;17x&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 这样赋值后 f1 叫做 方法表达式</span></span><br><span class="line">f1 := A.GetName</span><br><span class="line">    f1(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把 一个类型的方法赋值给变量后，该变量就称之为 <strong>方法表达式</strong>。</p><p>同时方法就是一个带有隐含参数的普通函数，所以以上代码等价于：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetName</span> <span class="params">(a A)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := A&#123;name: <span class="string">&quot;17x&quot;</span>&#125;</span><br><span class="line">f11 := GetName</span><br><span class="line">    f11(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>所以 f1 本质上也是一个 Function Value。</strong></p><p>之前已经证明了 f1 和 f11 是等价的，所以 调用 f1 的时候也要传入一个 A 类型的变量 a 作为第一个参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fourth</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := A&#123;name: <span class="string">&quot;17x&quot;</span>&#125;</span><br><span class="line"><span class="comment">// 这样赋值后 f2 叫做 方法变量</span></span><br><span class="line">f2 := a.GetName</span><br><span class="line">f2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>f2 以这样的方式赋值，被称作 <strong>方法变量</strong>。</p><p>因为<code>a.GetName()</code> 这样调用的时候，会把变量 a 作为 GetName()的第一个参数传入，所以可以想到 <strong>f2 理论上应该是一个 闭包</strong>，即一个由捕获列表的 Function Value。</p><p>但是因为这里 f2 仅作为局部变量，它的生命周期和a的生命周期相同，所以<strong>编译器会做出优化</strong>。转换为类型A的方法调用并传入a作为参数，具体如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A.GetName(a)</span><br></pre></td></tr></table></figure><h2 id="4-做为返回值"><a href="#4-做为返回值" class="headerlink" title="4 做为返回值"></a>4 做为返回值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a A)</span></span> GetName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFunc</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">a := A&#123;name: <span class="string">&quot;17x in GetFunc&quot;</span>&#125;</span><br><span class="line"><span class="keyword">return</span> a.GetName</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a := A&#123;name: <span class="string">&quot;17x in main&quot;</span>&#125;</span><br><span class="line">f2 := a.GetName</span><br><span class="line">fmt.Println(f2()) <span class="comment">// 17x in main</span></span><br><span class="line"></span><br><span class="line">f3 := GetFunc()</span><br><span class="line">fmt.Println(f3()) <span class="comment">// 17x in GetFunc</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>f2 和上个例子相同，会被编译器优化为<code>A.GetName(a)</code> 这样的调用，所以打印出的是 17x in main。</p><p>而 f3 的 GetFunc() 等价于如下函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetFunc</span><span class="params">()</span></span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line">a := A&#123;name: <span class="string">&quot;17x in GetFunc&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> A.GetName(a)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以清晰的看到，<strong>GetFunc() 中的局部变量 a 直接被 A.GetName() 引用而形成了闭包</strong>。</p><blockquote><p>f3 为闭包对象，捕获了GetFunc() 中的局部变量 a 。</p></blockquote><p>所以 f3 打印出的是 17x in GetFunc。</p><h2 id="5-小结"><a href="#5-小结" class="headerlink" title="5 小结"></a>5 小结</h2><p><strong>从本质上讲，方法表达式 Method Expression 和方法变量 Method Value 都是 Function Value。</strong></p><blockquote><p>一个没有捕获列表，一个有捕获列表。当然有时候编译器会做出优化。</p></blockquote><h2 id="6-参考"><a href="#6-参考" class="headerlink" title="6 参考"></a>6 参考</h2><p><code>https://www.bilibili.com/video/BV1hv411x7we?p=8</code></p><p><code>https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-function-call/</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] 接口</title>
      <link href="/2021/10/26/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E6%8E%A5%E5%8F%A3/"/>
      <url>/2021/10/26/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>接口是一组方法的签名</p></blockquote><span id="more"></span><h1 id="Go-接口"><a href="#Go-接口" class="headerlink" title="Go 接口"></a>Go 接口</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>Go 语言中的接口是一组方法的签名，它是 Go 语言的重要组成部分。</p><p>接口的本质是引入一个新的中间层，调用方可以通过接口与具体实现分离，解除上下游的耦合，上层的模块不再需要依赖下层的具体模块，只需要依赖一个约定好的接口。</p><p>除了解耦有依赖关系的上下游，接口还能够帮助我们隐藏底层实现，减少关注点。</p><p>定义接口需要使用 <code>interface</code> 关键字，在接口中我们只能定义方法签名，不能包含成员变量，一个常见的 Go 语言接口是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> <span class="type">error</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">Error() <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个类型需要实现 <code>error</code> 接口，那么它只需要实现 <code>Error() string</code> 方法，下面的 <code>RPCError</code> 结构体就是 <code>error</code> 接口的一个实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> RPCError <span class="keyword">struct</span> &#123;</span><br><span class="line">Code    <span class="type">int64</span></span><br><span class="line">Message <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(e *RPCError)</span></span> Error() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%s, code=%d&quot;</span>, e.Message, e.Code)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 语言中<strong>接口的实现都是隐式的</strong>，我们只需要实现 <code>Error() string</code> 方法就实现了 <code>error</code> 接口。</p><h2 id="2-空接口-eface"><a href="#2-空接口-eface" class="headerlink" title="2 空接口 eface"></a>2 空接口 eface</h2><p>空接口可以接收任意类型的数据，只需要记录这个数据的地址的类型就可以了。具体定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go 205行</span></span><br><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123;</span><br><span class="line">_type *_type</span><br><span class="line">data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>_type</strong>：指向接口的动态类型元数据</li><li><strong>data</strong>：指向接口的动态值</li></ul><blockquote><p>_type 结构体存储的类型信息中的通用部分。</p></blockquote><p>空接口类型变量，在被赋值前 _type 和 data 都为 nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> e <span class="keyword">interface</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>现在给 e 赋值，将 fd 赋值给 e。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd, _ := os.Open(<span class="string">&quot;17x.txt&quot;</span>)</span><br><span class="line">e = fd</span><br></pre></td></tr></table></figure><p>fd 是一个 <code>*os.File</code>类型，根据类型系统章节内容可以知道，<code>*os.File</code> 类型的类型元数据也是由 _type 和 uncommontype 两部分组成。</p><p>赋值给空接口 e 之后，e 的_type就会指向<code>*os.File</code> 类型的类型元数据。</p><p>同时由于 fd 本身就是一个指针，所以 e 的 data 字段就会直接替换为 fd，不用再去取地址了。</p><p>找到类型元数据后再通过偏移量就可以找到<strong>方法元数据数组</strong>了，这里面就有我们常用的 Read 和 Write 这些方法的描述信息。</p><p><img src="file-20250119063022239.png" alt=""></p><h2 id="3-非空接口-iface"><a href="#3-非空接口-iface" class="headerlink" title="3 非空接口 iface"></a>3 非空接口 iface</h2><p>非空接口就是有方法列表的接口类型，由<strong>接口类型</strong>和<strong>动态类型</strong>共同构成。</p><p>一个变量要赋值给非空接口变量，必须要实现该接口要求的所有方法才行。</p><p>具体定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go 200行</span></span><br><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123;</span><br><span class="line">tab  *itab</span><br><span class="line">data unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>data</strong>：指向接口的动态值</li><li><strong>tab</strong>：接口要求的方法列表和接口动态类型信息</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">inter *interfacetype</span><br><span class="line">_type *_type <span class="comment">// 动态类型</span></span><br><span class="line">hash  <span class="type">uint32</span> <span class="comment">// 类型哈希值</span></span><br><span class="line">_     [<span class="number">4</span>]<span class="type">byte</span></span><br><span class="line">fun   [<span class="number">1</span>]<span class="type">uintptr</span> <span class="comment">// 方法地址数组</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>inter</strong>：接口要求的方法列表，接口类型。</li><li><strong>_type</strong>：指向接口的动态类型元数据</li><li><strong>hash</strong>：从动态类型元数据中拷贝出来的类型哈希值，用于快速判断类型是否相等时使用。</li><li><strong>fun</strong>：记录这个动态类型实现的接口要求的方法的地址。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">typ     _type</span><br><span class="line">pkgpath name</span><br><span class="line">mhdr    []imethod <span class="comment">// 方法列表</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个非空接口类型的变量，赋值前 _type 和 data 也为nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rw io.ReadWriter</span><br></pre></td></tr></table></figure><p>然后给这个变量赋值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f, _ := os.Open(<span class="string">&quot;17x.txt&quot;</span>)</span><br><span class="line">rw = f</span><br></pre></td></tr></table></figure><p>具体结构如下：</p><p><img src="file-20250119063034887.png" alt=""></p><h2 id="4-itab-复用"><a href="#4-itab-复用" class="headerlink" title="4 itab 复用"></a>4 itab 复用</h2><p>一旦接口类型 itab.inter确定了，动态类型 itab._type也确定了，那么 itab 的内容就不会改变了，所以<strong>这个 itab 结构体是可以复用的</strong>。</p><p>Go 语言会把用到的 itab 结构体缓存起来，并且以接口类型和动态类型的组合为 key,以 itab 结构体指针为 value，构造一个哈希表，用于存储与查询 itab 缓存信息。</p><p>这里用的哈希表和 map 底层的哈希表不一样，这里是一种更为简单的实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/iface.go 22 行</span></span><br><span class="line"><span class="keyword">type</span> itabTableType <span class="keyword">struct</span> &#123;</span><br><span class="line">size    <span class="type">uintptr</span>             <span class="comment">// length of entries array. Always a power of 2.</span></span><br><span class="line">count   <span class="type">uintptr</span>             <span class="comment">// current number of filled entries.</span></span><br><span class="line">entries [itabInitSize]*itab <span class="comment">// really [size] large</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要一个 itab 时会首先去哈希表中查找，</p><ul><li>如果已经有对应的 itab 指针就直接拿来用；</li><li>若没有则创建一个 itab 结构体，然后添加到这个哈希表中</li></ul><p>Key 值哈希方法如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">itabHashFunc</span><span class="params">(inter *interfacetype, typ *_type)</span></span> <span class="type">uintptr</span> &#123;</span><br><span class="line"><span class="comment">// compiler has provided some good hash codes for us.</span></span><br><span class="line"><span class="keyword">return</span> <span class="type">uintptr</span>(inter.typ.hash ^ typ.hash)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接口类型的类型哈希值与动态类型的类型哈希值进行异或运算。</p><p>这样，如果 Key 值能对应上说明这就是一个类型，所以可以复用 Value 中的 itab 结构体。</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p><code>https://www.bilibili.com/video/BV1hv411x7we?p=13</code></p><p><code>https://draveness.me/golang/docs/part2-foundation/ch04-basic/golang-interface/</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 语言基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Slice</title>
      <link href="/2021/10/22/Golang/0%20%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Slice/"/>
      <url>/2021/10/22/Golang/0%20%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Slice/</url>
      
        <content type="html"><![CDATA[<blockquote><p>切片的实现原理使用</p></blockquote><span id="more"></span><h2 id="1-几个问题"><a href="#1-几个问题" class="headerlink" title="1 几个问题"></a>1 几个问题</h2><h3 id="1-1-问题1"><a href="#1-1-问题1" class="headerlink" title="1.1 问题1"></a>1.1 问题1</h3><ul><li>初始化切片 s 长度和容量均为 10</li><li>在 s 的基础上追加 append 一个元素</li><li>切片s 的内容、长度以及容量分别是什么？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>)  </span><br><span class="line">    s = <span class="built_in">append</span>(s,<span class="number">10</span>)</span><br><span class="line">    t.Logf(<span class="string">&quot;s: %v, len of s: %d, cap of s: %d&quot;</span>,s,<span class="built_in">len</span>(s),<span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s: [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span>], <span class="built_in">len</span> of s: <span class="number">11</span>, <span class="built_in">cap</span> of s: <span class="number">20</span></span><br></pre></td></tr></table></figure><ul><li>基于 make([]int, 10) 的方式初始化切片的话其长度 len 和容量 cap 均为 10，且前10个元素是已经切实被分配过的（虽然会被填充为零值）. 此时进行 append 操作，会在末尾进行元素追加，由于切片的长度和容量是相等的，因此已经没有剩余可用的空间了，于是会进一步引发切片的扩容操作.</li><li>在切片原容量小于 256 的情况下，扩容时会采用原容量的2倍作为新的容量，于是在新切片中，长度增加为 11，而容量则翻倍变成 20.</li></ul><h3 id="1-2-问题2"><a href="#1-2-问题2" class="headerlink" title="1.2 问题2"></a>1.2 问题2</h3><ul><li>初始化切片 s 长度为 0，容量为 10</li><li>在 s 的基础上追加 append 一个元素</li><li>切片s 的内容、长度以及容量分别是什么？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>,<span class="number">10</span>)  </span><br><span class="line">    s = <span class="built_in">append</span>(s,<span class="number">10</span>)</span><br><span class="line">    t.Logf(<span class="string">&quot;s: %v, len of s: %d, cap of s: %d&quot;</span>,s,<span class="built_in">len</span>(s),<span class="built_in">cap</span>(s))</span><br><span class="line"></span><br><span class="line">s: [<span class="number">10</span>], <span class="built_in">len</span> of s: <span class="number">1</span>, <span class="built_in">cap</span> of s: <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>make([]int, 0, 10) 的方式使得切片长度为 0，容量为 10，实际上还有长度为 10 的缓存空间. 于是这一次 append 操作，会直接使用已有的空间，不会引发扩容. 结果中，切片长度从 0 增加为 1，容量则维持为 10 不变.</li></ul><h3 id="1-3-问题3"><a href="#1-3-问题3" class="headerlink" title="1.3 问题3"></a>1.3 问题3</h3><ul><li>初始化切片 s 长度为 10，容量为 11</li><li>在 s 的基础上追加 append 一个元素</li><li>切片s 的内容、长度以及容量分别是什么？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>,<span class="number">11</span>)  </span><br><span class="line">    s = <span class="built_in">append</span>(s,<span class="number">10</span>)</span><br><span class="line">    t.Logf(<span class="string">&quot;s: %v, len of s: %d, cap of s: %d&quot;</span>,s,<span class="built_in">len</span>(s),<span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s: [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10</span>], <span class="built_in">len</span> of s: <span class="number">11</span>, <span class="built_in">cap</span> of s: <span class="number">11</span></span><br></pre></td></tr></table></figure><ul><li>由于容量大于长度，因此仍有足够的空间，这次 append 操作不会引发扩容.</li></ul><h3 id="1-4-问题4"><a href="#1-4-问题4" class="headerlink" title="1.4 问题4"></a>1.4 问题4</h3><ul><li>初始化切片 s 长度为 10，容量为 12</li><li>截取切片 s index = 8 往后的内容赋给 s1</li><li>s1 的内容、长度以及容量分别是什么？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>,<span class="number">12</span>)  </span><br><span class="line">    s1 := s[<span class="number">8</span>:]</span><br><span class="line">    t.Logf(<span class="string">&quot;s1: %v, len of s1: %d, cap of s1: %d&quot;</span>,s1,<span class="built_in">len</span>(s1),<span class="built_in">cap</span>(s1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s1: [<span class="number">0</span> <span class="number">0</span>], <span class="built_in">len</span> of s1: <span class="number">2</span>, <span class="built_in">cap</span> of s1: <span class="number">4</span></span><br></pre></td></tr></table></figure><ul><li>截取操作会以 s[8] 作为内存空间的起点，截取所得新切片 s1 的长度和容量强依赖于原切片 s 的长度和容量，并在此基础上减去头部 8 个未使用到的单位.</li></ul><h3 id="1-5-问题5"><a href="#1-5-问题5" class="headerlink" title="1.5 问题5"></a>1.5 问题5</h3><ul><li>初始化切片 s 长度为 10，容量为 12</li><li>截取切片 s index 为 [8,9) 范围内的元素赋给切片 s1</li><li>s1 的内容、长度以及容量分别是什么？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>,<span class="number">12</span>)  </span><br><span class="line">    s1 := s[<span class="number">8</span>:<span class="number">9</span>]</span><br><span class="line">    t.Logf(<span class="string">&quot;s1: %v, len of s1: %d, cap of s1: %d&quot;</span>,s1,<span class="built_in">len</span>(s1),<span class="built_in">cap</span>(s1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s1: [<span class="number">0</span>], <span class="built_in">len</span> of s1: <span class="number">1</span>, <span class="built_in">cap</span> of s1: <span class="number">4</span></span><br></pre></td></tr></table></figure><ul><li>虽然 s[8:9] 的截取操作限定了 s1 的右边界，但这只是长度意义上的，对于容量，s1 仍然和 s 保持强关联性.</li></ul><h3 id="1-6-问题6"><a href="#1-6-问题6" class="headerlink" title="1.6 问题6"></a>1.6 问题6</h3><ul><li>初始化切片 s 长度为 10，容量为 12</li><li>截取切片 s index = 8 往后的内容赋给 s1</li><li>修改 s1[0] 的值</li><li>这个修改是否会影响到 s？ 此时，s 的内容是什么？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>,<span class="number">12</span>)  </span><br><span class="line">    s1 := s[<span class="number">8</span>:]</span><br><span class="line">    s1[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">    t.Logf(<span class="string">&quot;s: %v&quot;</span>,s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s: [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">-1</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p>s1 是在 s 基础上截取得到的，属于一次引用传递，底层共用同一片内存空间，其中 s[x] 等价于 s1[x+8]. 因此修改了 s1[0] 会直接影响到 s[8] .</p><h3 id="1-7-问题7"><a href="#1-7-问题7" class="headerlink" title="1.7 问题7"></a>1.7 问题7</h3><ul><li>初始化切片 s 长度为 10，容量为 12</li><li>访问 s[10] 是否会越界？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>,<span class="number">12</span>)  </span><br><span class="line">    v := s[<span class="number">10</span>]</span><br><span class="line">    <span class="comment">// 此时数组访问是否会越界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>会发生 panic</li><li>初始化时设定了切片长度为10，容量为 12. 容量是物理意义上的，但长度是逻辑意义上的，判断是否越界以逻辑意义为准，因此 index = 10 已经越界</li></ul><h3 id="1-8-问题8"><a href="#1-8-问题8" class="headerlink" title="1.8 问题8"></a>1.8 问题8</h3><ul><li>初始化切片 s 长度为 10，容量为 12</li><li>截取 s 中 index = 8 后面的内容赋给 s1</li><li>在 s1 的基础上追加 []int{10,11,12} 3 个元素</li><li>访问 s[10] 是否会越界？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>,<span class="number">12</span>)  </span><br><span class="line">    s1 := s[<span class="number">8</span>:]</span><br><span class="line">    s1 = <span class="built_in">append</span>(s1,[]<span class="type">int</span>&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;...)</span><br><span class="line">    v := s[<span class="number">10</span>]</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 求问，此时数组访问是否会越界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>会发生 panic.</li><li>在 s 的基础上截取产生了 s1，此时 s1 和 s 会拥有两个独立的 slice header.</li><li>接下来执行 append 操作时，由于 s 预留的空间不足，s1 会发生扩容</li><li>s1 扩容后，会被迁移到新的空间地址，此时 s1 已经和 s 做到真正意义上的完全独立，意味着修改 s1 不再会影响到 s</li><li>s 继续维持原本的长度值 10 和容量值 12，因此访问 s[10] 会panic</li></ul><h3 id="1-9-问题9"><a href="#1-9-问题9" class="headerlink" title="1.9 问题9"></a>1.9 问题9</h3><ul><li>初始化切片 s 长度为 10，容量为 12</li><li>截取切片 s index = 8 往后的内容赋给 s1</li><li>在方法 changeSlice 中，对 s1[0] 进行修改</li><li>经过上述操作之后，s 的内容是什么？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>,<span class="number">12</span>)  </span><br><span class="line">    s1 := s[<span class="number">8</span>:]</span><br><span class="line">    changeSlice(s1)</span><br><span class="line">    t.Logf(<span class="string">&quot;s: %v&quot;</span>,s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(s1 []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">  s1[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s: [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">-1</span> <span class="number">0</span>]</span><br></pre></td></tr></table></figure><ul><li>切片在传递时属于引用传递，且 s1[0] 和 s[8] 指向同一个元素. 因此在局部方法中，修改了 s1[0] 会直接影响到 s[8] 的内容.</li></ul><h3 id="1-10-问题10"><a href="#1-10-问题10" class="headerlink" title="1.10 问题10"></a>1.10 问题10</h3><ul><li>初始化切片 s 长度为 10，容量为 12</li><li>截取切片 s index = 8 往后的内容赋给 s1</li><li>在方法 changeSlice 中，对 s1 进行 apend 追加操作</li><li>经过上述操作后，s 以及 s1 的内容、长度和容量分别是什么？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">10</span>,<span class="number">12</span>)  </span><br><span class="line">    s1 := s[<span class="number">8</span>:]</span><br><span class="line">    changeSlice(s1)</span><br><span class="line">    t.Logf(<span class="string">&quot;s: %v, len of s: %d, cap of s: %d&quot;</span>,s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">    t.Logf(<span class="string">&quot;s1: %v, len of s1: %d, cap of s1: %d&quot;</span>,s1, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(s1 []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">  s1 = <span class="built_in">append</span>(s1, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">s: [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>], <span class="built_in">len</span> of s: <span class="number">10</span>, <span class="built_in">cap</span> of s: <span class="number">12</span></span><br><span class="line">s1: [<span class="number">0</span> <span class="number">0</span>], <span class="built_in">len</span> of s1: <span class="number">2</span>, <span class="built_in">cap</span> of s1: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>切片是引用传递，但是在方法调用时，传递的会是一个新的 slice header.</li><li>因此在局部方法 changeSlice 中，虽然对 s1 进行了 append 操作，但这这会在局部方法中这个独立的 slice header 中生效，不会影响到原方法 Test_slice 当中的 s 和 s1 的长度和容量</li></ul><h3 id="1-11-问题11"><a href="#1-11-问题11" class="headerlink" title="1.11 问题11"></a>1.11 问题11</h3><ul><li>初始化切片 s，内容为 []int{0,1,2,3,4}</li><li>截取 s 中 index = 2 前面的内容（不含s[2]），并在此基础上追加 index = 3 后面的内容</li><li>经过上述操作后，s 的内容、长度和内容分别是什么？此时访问 s[4] 是否会越界？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">    s = <span class="built_in">append</span>(s[:<span class="number">2</span>],s[<span class="number">3</span>:]...)</span><br><span class="line">    t.Logf(<span class="string">&quot;s: %v, len: %d, cap: %d&quot;</span>, s, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s))</span><br><span class="line">    v := s[<span class="number">4</span>] </span><br><span class="line">    <span class="comment">// 是否会数组访问越界</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s: [<span class="number">0</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span>], <span class="built_in">len</span>: <span class="number">4</span>, <span class="built_in">cap</span>: <span class="number">5</span></span><br></pre></td></tr></table></figure><ul><li>会发生 panic</li><li>执行完上述 append 操作之后，s 的实际长度为 4，容量维持不变为 5. 此时访问 s[4]会发生数组越界的错误</li></ul><h3 id="1-12-问题12"><a href="#1-12-问题12" class="headerlink" title="1.12 问题12"></a>1.12 问题12</h3><ul><li>初始化切片 s 长度和容量均为 512</li><li>在 s 的基础上追加 append 一个元素</li><li>经过上述操作后，切片s 的内容、长度以及容量分别是什么？</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">512</span>)  </span><br><span class="line">    s = <span class="built_in">append</span>(s,<span class="number">1</span>)</span><br><span class="line">    t.Logf(<span class="string">&quot;len of s: %d, cap of s: %d&quot;</span>,<span class="built_in">len</span>(s),<span class="built_in">cap</span>(s))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">len</span>: <span class="number">513</span>, <span class="built_in">cap</span>: <span class="number">848</span></span><br></pre></td></tr></table></figure><ul><li>由于切片 s 原有容量为 512，已经超过了阈值 256，因此对其进行扩容操作会采用的计算共识为 512 <em> (512 + 3\</em>256)/4 = 832</li><li>其次，在真正申请内存空间时，我们会根据切片元素大小乘以容量计算出所需的总空间大小，得出所需的空间为 8byte * 832 = 6656 byte</li><li>再进一步，结合分配内存的 mallocgc 流程，为了更好地进行内存空间对其，golang 允许产生一些有限的内部碎片，对拟申请空间的 object 进行大小补齐，最终 6656 byte 会被补齐到 6784 byte 的这一档次</li><li>再终，在 mallocgc 流程中，我们为扩容后的新切片分配到了 6784 byte 的空间，于是扩容后实际的新容量为 cap = 6784/8 = 848.</li></ul><h2 id="2-使用及原理"><a href="#2-使用及原理" class="headerlink" title="2 使用及原理"></a>2 使用及原理</h2><h3 id="2-1-数据结构"><a href="#2-1-数据结构" class="headerlink" title="2.1 数据结构"></a>2.1 数据结构</h3><p>Go 语言中的 Slice 具体实现如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> slice <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 指向起点的地址</span></span><br><span class="line">    array unsafe.Pointer</span><br><span class="line">    <span class="comment">// 切片长度</span></span><br><span class="line">    <span class="built_in">len</span>   <span class="type">int</span></span><br><span class="line">    <span class="comment">// 切片容量</span></span><br><span class="line">    <span class="built_in">cap</span>   <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>array：指向了内存空间地址的起点. 由于 slice 数据存放在连续的内存空间中，后续可以根据索引 index，在起点的基础上快速进行地址偏移，从而定位到目标元素</li><li>len：切片的长度，指的是逻辑意义上 slice 中实际存放了多少个元素</li><li>cap：切片的容量，指的是物理意义上为 slice 分配了足够用于存放多少个元素的空间. 使用 slice 时，要求 cap 永远大于等于 len</li></ul><p>每个 slice header 中存放的是内存空间的地址（array 字段），后续在传递切片的时候，相当于是对 slice header 进行了一次值拷贝，但内部存放的地址是相同的，因此对于 slice 本身属于<strong>引用传递</strong>操作</p><h3 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h3><ul><li>声明但不初始化<ul><li>只是声明了 slice 的类型，但是并没有执行初始化操作，即 s 这个字面量此时是一个空指针 nil，并没有完成实际的内存分配操作.</li><li>`var s []int</li></ul></li><li>基于 make 进行初始化<ul><li><code>s := make([]int,8)</code>将切片的长度 len 和 容量 cap 同时设置为 8. 需要注意，切片的长度一旦被指定了，就代表对应位置已经被分配了元素，尽管设置的会是对应元素类型下的零值.</li><li><code>s := make([]int,8,16)</code> 在切片中设置了 8 个元素，会设置为对应类型的零值；cap = 16 代表为 slice 分配了用于存放 16 个元素的空间. 需要保证 cap &gt;= len. 在 index 为 [len, cap) 的范围内，虽然内存空间已经分配了，但是逻辑意义上不存在元素，直接访问会 panic 报数组访问越界；但是访问 [0,len) 范围内的元素是能够正常访问到的，只不过会是对应元素类型下的零值.</li></ul></li><li>初始化连带赋值<ul><li><code>s := []int&#123;2,3,4&#125;</code> 将 slice 长度 len 和容量 cap 均设置为 3，同时完成对这 3 个元素赋值.</li></ul></li></ul><h3 id="2-3-引用传递"><a href="#2-3-引用传递" class="headerlink" title="2.3 引用传递"></a>2.3 引用传递</h3><ul><li>引用传递，指的是，将实例的地址信息传递到方法中，这样在方法中会直接通过地址追溯到实例所在位置，因此执行的一些修改操作会直接影响到原实例.</li><li>值传递，指的是对实例进行一轮拷贝，得到一个副本，然后将这个副本传递到方法中. 这样在方法内部发生的修改动作都作用于这个副本之上，而副本本身和实例是相互独立的，因此不会影响到原实例.</li><li>slice 属于引用传递的类型</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">  s := []<span class="type">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">  <span class="comment">// [2,3,4] -&gt; [-1,3,4]</span></span><br><span class="line">  changeSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">changeSlice</span><span class="params">(s []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">  s[<span class="number">0</span>] = <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>将主方法 Test_slice 中声明的切片 s 作为 changeSlice 方法的入参进行传递，同时在 changeSlice 方法中对 s 内的元素进行修改，这样是会直接影响到 Test_slice 中的切片 s 的.</li><li>每个切片实例对应一个 slice header，其中存储了三个字段：<ul><li>切片内存空间的起始地址 array；</li><li>切片长度 len；</li><li>以及切片容量 cap.</li></ul></li><li>在方法间传递切片时，会对 slice header 实例本身进行一次值拷贝，然后将 slice header 的副本传递到局部方法中.</li><li>然而，这个 slice header 副本中的 array 和原 slice 指向同一片内存空间，因此在局部方法中执行修改操作时，还会根据这个地址信息影响到原 slice 所属的内存空间，从而对内容发生影响.</li></ul><h3 id="2-4-内容截取"><a href="#2-4-内容截取" class="headerlink" title="2.4 内容截取"></a>2.4 内容截取</h3><p>可以修改 slice 下标的方式，进行 slice 内容的截取，形如 s[a:b] 的格式，其中 a b 代表切片的索引 index，左闭右开，比如 s[a:b] 对应的范围是 [a,b)，代表的是取切片 slice index = a ~ index = b-1 范围的内容.</p><p>此外，这里的 a 和 b 是可以缺省的：</p><ul><li>如果 a 缺省不填则默认取 0 ，则代表从切片起始位置开始截取. 比如 s[:b] 等价于 s[0:b]</li><li>如果 b 缺省不填，则默认取 len(s)，则代表末尾截取到切片长度 len 的终点，比如 s[a:] 等价于 s[a:len(s)]</li><li>a 和 b 均缺省也是可以的，则代表截取整个切片长度的范围，比如 s[:] 等价于 s[0:len(s)]</li></ul><p>在对切片 slice 执行截取操作时，本质上是一次<strong>引用传递</strong>操作，因为不论如何截取，底层复用的都是同一块内存空间中的数据，只不过，截取动作会创建出一个新的 slice header 实例.</p><h3 id="2-5-元素追加"><a href="#2-5-元素追加" class="headerlink" title="2.5 元素追加"></a>2.5 元素追加</h3><p>通过 append 操作，可以在 slice 末尾，额外新增一个元素. 需要注意，这里的末尾指的是针对 slice 的长度 len 而言. 这个过程中倘若发现 slice 的剩余容量已经不足了，则会对 slice 进行扩容.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span>&#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;  </span><br><span class="line">    s = <span class="built_in">append</span>(s,<span class="number">5</span>)</span><br><span class="line">    <span class="comment">// s: [2,3,4,5]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在创建 slice 时，如果能够预估到其未来所需的容量空间，则应该提前分配好对应容量，避免在运行过程中频繁触发扩容操作，这样会对性能产生不利的影响.</p><h3 id="2-6-切片扩容"><a href="#2-6-切片扩容" class="headerlink" title="2.6 切片扩容"></a>2.6 切片扩容</h3><p>当 slice 当前的长度 len 与容量 cap 相等时，下一次 append 操作就会引发一次切片扩容.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// len:4, cap: 4</span></span><br><span class="line">s := []<span class="type">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="comment">// len:5, cap: 8    </span></span><br><span class="line">s = <span class="built_in">append</span>(s,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><p><strong>扩容流程</strong></p><ul><li>倘若扩容后预期的新容量小于原切片的容量，则 panic</li><li>倘若切片元素大小为 0（元素类型为 struct{}），则直接复用一个全局的 zerobase 实例，直接返回</li><li>倘若预期的新容量超过老容量的两倍，则直接采用预期的新容量</li><li>倘若老容量小于 256，则直接采用老容量的2倍作为新容量</li><li>倘若老容量已经大于等于 256，则在老容量的基础上扩容 1/4 的比例并且累加上 192 的数值，持续这样处理，直到得到的新容量已经大于等于预期的新容量为止</li><li>结合 mallocgc 流程中，对内存分配单元 mspan 的等级制度，推算得到实际需要申请的内存空间大小</li><li>调用 mallocgc，对新切片进行内存初始化</li><li>调用 memmove 方法，将老切片中的内容拷贝到新切片中</li><li>返回扩容后的新切片</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">growslice</span><span class="params">(et *_type, old slice, <span class="built_in">cap</span> <span class="type">int</span>)</span></span> slice &#123;</span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> &lt; old.<span class="built_in">cap</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(errorString(<span class="string">&quot;growslice: cap out of range&quot;</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> et.size == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 倘若元素大小为 0，则无需分配空间直接返回</span></span><br><span class="line">        <span class="keyword">return</span> slice&#123;unsafe.Pointer(&amp;zerobase), old.<span class="built_in">len</span>, <span class="built_in">cap</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算扩容后数组的容量</span></span><br><span class="line">    newcap := old.<span class="built_in">cap</span></span><br><span class="line">    <span class="comment">// 取原容量两倍的容量数值</span></span><br><span class="line">    doublecap := newcap + newcap</span><br><span class="line">    <span class="comment">// 倘若新的容量大于原容量的两倍，直接取新容量作为数组扩容后的容量</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> &gt; doublecap &#123;</span><br><span class="line">        newcap = <span class="built_in">cap</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> threshold = <span class="number">256</span></span><br><span class="line">        <span class="comment">// 倘若原容量小于 256，则扩容后新容量为原容量的两倍</span></span><br><span class="line">        <span class="keyword">if</span> old.<span class="built_in">cap</span> &lt; threshold &#123;</span><br><span class="line">            newcap = doublecap</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在原容量的基础上，对原容量 * 5/4 并且加上 192</span></span><br><span class="line">            <span class="comment">// 循环执行上述操作，直到扩容后的容量已经大于等于预期的新容量为止</span></span><br><span class="line">            <span class="keyword">for</span> <span class="number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="built_in">cap</span> &#123;             </span><br><span class="line">                newcap += (newcap + <span class="number">3</span>*threshold) / <span class="number">4</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 倘若数值越界了，则取预期的新容量 cap 封顶</span></span><br><span class="line">            <span class="keyword">if</span> newcap &lt;= <span class="number">0</span> &#123;</span><br><span class="line">                newcap = <span class="built_in">cap</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> overflow <span class="type">bool</span></span><br><span class="line">    <span class="keyword">var</span> lenmem, newlenmem, capmem <span class="type">uintptr</span></span><br><span class="line">    <span class="comment">// 基于容量，确定新数组容器所需要的内存空间大小 capmem</span></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="comment">// 倘若数组元素的大小为 1，则新容量大小为 1 * newcap.</span></span><br><span class="line">    <span class="comment">// 同时会针对 span class 进行取整</span></span><br><span class="line">    <span class="keyword">case</span> et.size == <span class="number">1</span>:</span><br><span class="line">        lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>)</span><br><span class="line">        newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>)</span><br><span class="line">        capmem = roundupsize(<span class="type">uintptr</span>(newcap))</span><br><span class="line">        overflow = <span class="type">uintptr</span>(newcap) &gt; maxAlloc</span><br><span class="line">        newcap = <span class="type">int</span>(capmem)</span><br><span class="line">    <span class="comment">// 倘若数组元素为指针类型，则根据指针占用空间结合元素个数计算空间大小</span></span><br><span class="line">    <span class="comment">// 并会针对 span class 进行取整</span></span><br><span class="line">    <span class="keyword">case</span> et.size == goarch.PtrSize:</span><br><span class="line">        lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>) * goarch.PtrSize</span><br><span class="line">        newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>) * goarch.PtrSize</span><br><span class="line">        capmem = roundupsize(<span class="type">uintptr</span>(newcap) * goarch.PtrSize)</span><br><span class="line">        overflow = <span class="type">uintptr</span>(newcap) &gt; maxAlloc/goarch.PtrSize</span><br><span class="line">        newcap = <span class="type">int</span>(capmem / goarch.PtrSize)</span><br><span class="line">    <span class="comment">// 倘若元素大小为 2 的指数，则直接通过位运算进行空间大小的计算   </span></span><br><span class="line">    <span class="keyword">case</span> isPowerOfTwo(et.size):</span><br><span class="line">        <span class="keyword">var</span> shift <span class="type">uintptr</span></span><br><span class="line">        <span class="keyword">if</span> goarch.PtrSize == <span class="number">8</span> &#123;</span><br><span class="line">            <span class="comment">// Mask shift for better code generation.</span></span><br><span class="line">            shift = <span class="type">uintptr</span>(sys.Ctz64(<span class="type">uint64</span>(et.size))) &amp; <span class="number">63</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            shift = <span class="type">uintptr</span>(sys.Ctz32(<span class="type">uint32</span>(et.size))) &amp; <span class="number">31</span></span><br><span class="line">        &#125;</span><br><span class="line">        lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>) &lt;&lt; shift</span><br><span class="line">        newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>) &lt;&lt; shift</span><br><span class="line">        capmem = roundupsize(<span class="type">uintptr</span>(newcap) &lt;&lt; shift)</span><br><span class="line">        overflow = <span class="type">uintptr</span>(newcap) &gt; (maxAlloc &gt;&gt; shift)</span><br><span class="line">        newcap = <span class="type">int</span>(capmem &gt;&gt; shift)</span><br><span class="line">    <span class="comment">// 兜底分支：根据元素大小乘以元素个数</span></span><br><span class="line">    <span class="comment">// 再针对 span class 进行取整     </span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        lenmem = <span class="type">uintptr</span>(old.<span class="built_in">len</span>) * et.size</span><br><span class="line">        newlenmem = <span class="type">uintptr</span>(<span class="built_in">cap</span>) * et.size</span><br><span class="line">        capmem, overflow = math.MulUintptr(et.size, <span class="type">uintptr</span>(newcap))</span><br><span class="line">        capmem = roundupsize(capmem)</span><br><span class="line">        newcap = <span class="type">int</span>(capmem / et.size)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行实际的切片初始化操作</span></span><br><span class="line">    <span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line">    <span class="comment">// 非指针类型</span></span><br><span class="line">    <span class="keyword">if</span> et.ptrdata == <span class="number">0</span> &#123;</span><br><span class="line">        p = mallocgc(capmem, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 指针类型</span></span><br><span class="line">        p = mallocgc(capmem, et, <span class="literal">true</span>)</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将切片的内容拷贝到扩容后的位置 p </span></span><br><span class="line">    memmove(p, old.array, lenmem)</span><br><span class="line">    <span class="keyword">return</span> slice&#123;p, old.<span class="built_in">len</span>, newcap&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-元素删除"><a href="#2-7-元素删除" class="headerlink" title="2.7 元素删除"></a>2.7 元素删除</h3><p>从切片中删除元素的实现思路，本质上和切片内容截取的思路是一致的.</p><ul><li>比如删除 slice 中的首个元素，在操作上等同于从切片 index = 1 开始向后进行内容截取</li><li>如果删除 slice 的尾部元素，则操作等价于截取切片内容，并将终点设置在 len(s) - 1 的位置</li><li>如果需要删除 slice 中间的某个元素，操作思路则是采用内容截取加上元素追加的复合操作，可以先截取待删除元素的左侧部分内容，然后在此基础上追加上待删除元素后侧部分的内容</li><li>当需要删除 slice 中的所有元素时，也可以采用切片内容截取的操作方式：s[:0]. 这样操作后，slice header 中的指针 array 仍指向远处，但是逻辑意义上其长度 len 已经等于 0，而容量 cap 则仍保留为原值</li></ul><h3 id="2-8-切片拷贝"><a href="#2-8-切片拷贝" class="headerlink" title="2.8 切片拷贝"></a>2.8 切片拷贝</h3><p>slice 的拷贝可以分为简单拷贝和完整拷贝两种类型</p><p>要实现简单拷贝，只需要对切片的字面量进行赋值传递即可，这样相当于创建出了一个新的 slice header 实例，但是其中的指针 array、容量 cap 和长度 len 仍和老的 slice header 实例相同.</p><p>slice 的完整复制，指的是会创建出一个和 slice 容量大小相等的独立的内存区域，并将原 slice 中的元素一一拷贝到新空间中</p><p>在实现上，slice 的完整复制可以调用系统方法 copy，代码示例如下，通过日志打印的方式可以看到，s 和 s1 的地址是相互独立的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Test_slice</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">    s := []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">    s1 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    <span class="built_in">copy</span>(s1, s)</span><br><span class="line">    t.Logf(<span class="string">&quot;s: %v, s1: %v&quot;</span>, s, s1)</span><br><span class="line">    t.Logf(<span class="string">&quot;address of s: %p, address of s1: %p&quot;</span>, s, s1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-与-String-互转"><a href="#3-与-String-互转" class="headerlink" title="3 与 String 互转"></a>3 与 String 互转</h2><p>Slice 由 Data、Len、Cap 构成，String 由 Data、Len 构成，二者只相差了一个 Cap 属性。</p><p>通过 unsafe 包可以快速进行二者的转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">String2Bytes</span><span class="params">(str <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">sh := (*reflect.SliceHeader)(unsafe.Pointer(&amp;str))</span><br><span class="line"><span class="comment">// slice 比 string 多一个 cap 属性 这里给 cap 单独赋值</span></span><br><span class="line">sh.Cap = sh.Len</span><br><span class="line"><span class="keyword">return</span> *(*[]<span class="type">byte</span>)(unsafe.Pointer(sh))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bytes2String</span><span class="params">(buf []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="type">string</span>)(unsafe.Pointer(&amp;buf))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 语言标准库中 strings.Builder 就使用到了 unsafe.Pointer 来提升效率。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strings/builder.go 47 行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="type">string</span>)(unsafe.Pointer(&amp;b.buf))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 .参考"></a>4 .参考</h2><p><code>https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice/</code></p><p><code>https://blog.golang.org/slices-intro</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Golang Benchyou</title>
      <link href="/2021/10/11/Golang/4%20%E5%85%B6%E4%BB%96/Benchyou%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/10/11/Golang/4%20%E5%85%B6%E4%BB%96/Benchyou%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>benchyou is a benchmark tool for MySQL, real-time monitoring TPS and vmstat/iostat</p></blockquote><span id="more"></span><h2 id="1-Build"><a href="#1-Build" class="headerlink" title="1 Build"></a>1 Build</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/xelabs/benchyou</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> benchyou</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">make build</span></span><br></pre></td></tr></table></figure><h2 id="2-Usage"><a href="#2-Usage" class="headerlink" title="2 Usage"></a>2 Usage</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./bin/benchyou -h</span></span><br></pre></td></tr></table></figure><h2 id="3-Examples"><a href="#3-Examples" class="headerlink" title="3 Examples"></a>3 Examples</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">prepare 64 tables:</span><br><span class="line">./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou  --oltp-tables-count=64 prepare</span><br><span class="line"></span><br><span class="line">cleanup 64 tables:</span><br><span class="line">./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou  --oltp-tables-count=64 cleanup</span><br><span class="line"></span><br><span class="line">random insert(Write/Read Ratio=128:8):</span><br><span class="line"> ./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou --ssh-user=benchyou --ssh-password=benchyou --oltp-tables-count=64 --write-threads=128 --read-threads=8 --max-time=3600 random</span><br><span class="line"></span><br><span class="line">sequential insert(Write/Read Ratio=128:8):</span><br><span class="line"> ./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou --ssh-user=benchyou --ssh-password=benchyou --oltp-tables-count=64 --write-threads=128 --read-threads=8 --max-time=3600 seq</span><br><span class="line"></span><br><span class="line">mix(Write/Read/Update/Delete Ratio=4:4:4:4):</span><br><span class="line"> ./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou --ssh-user=benchyou --ssh-password=benchyou --oltp-tables-count=64 --write-threads=4 --read-threads=4 --update-threads=4 --delete-threads=4 --max-time=3600 random</span><br><span class="line"></span><br><span class="line">insert multiple rows(10 rows per insert):</span><br><span class="line"> ./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou --ssh-user=benchyou --ssh-password=benchyou --oltp-tables-count=64 --write-threads=4 --rows-per-insert=10 --max-time=3600 random</span><br><span class="line"></span><br><span class="line">batch update(10 rows per transaction):</span><br><span class="line"> ./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou --ssh-user=benchyou --ssh-password=benchyou --oltp-tables-count=64 --update-threads=4 --batch-per-commit=10 --max-time=3600 random</span><br><span class="line"></span><br><span class="line">query-range(Write/Read Ratio=128:8):</span><br><span class="line"> ./bin/benchyou  --mysql-host=192.168.0.3 --mysql-user=benchyou --mysql-password=benchyou --ssh-user=benchyou --ssh-password=benchyou --oltp-tables-count=64 --write-threads=128 --read-threads=8 --max-time=3600 --mysql-range-order=DESC range</span><br></pre></td></tr></table></figure><h2 id="4-Github"><a href="#4-Github" class="headerlink" title="4 Github"></a>4 Github</h2><ul><li><a href="https://github.com/xelabs/benchyou">benchyou</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
          <category> Packges </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go-Package </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Golang Time/rate使用</title>
      <link href="/2021/10/11/Golang/4%20%E5%85%B6%E4%BB%96/time%20rate%E4%BD%BF%E7%94%A8/"/>
      <url>/2021/10/11/Golang/4%20%E5%85%B6%E4%BB%96/time%20rate%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Time/rate 是基于 Token Bucket (令牌桶) 算法实现的限流</p></blockquote><span id="more"></span><h2 id="1-限流"><a href="#1-限流" class="headerlink" title="1 限流"></a>1 限流</h2><p>限制某个服务每秒的调用本服务的频率 客户端请求太多，超出服务端的服务能力，导致服务不可用。DoS攻击就是根据此原理， 耗尽被攻击对象的资源，让目标系统无法响应甚至崩溃。解决方案：服务端对客户端限流，保护服务端的资源。 限流通常在网关或网络层面实施。对各类请求设置最高的QPS阈值，当请求高于阈值时直接阻断。</p><p>常用的限流算法有滑动计数，漏斗限流和令牌限流三种：</p><ol><li>滑动计数限流：按时间片（比如1秒）定义滑动窗口，计数器记录当前窗口的请求次数， 达到阈值就限流，窗口滑动后计数器归零。可采用循环队列数据结构实现。</li><li>漏斗限流：维护一个队列，所有请求进队列，按FIFO服务，队满溢出则丢弃请求。</li><li>令牌桶限流：按固定速率往桶中存入令牌，服务前先从桶中取令牌，取到令牌才服务。</li></ol><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用</h2><h3 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get golang.org/x/time/rate</span><br></pre></td></tr></table></figure><h3 id="2-2-构造一个限流器"><a href="#2-2-构造一个限流器" class="headerlink" title="2.2 构造一个限流器"></a>2.2 构造一个限流器</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewLimiter returns a new Limiter that allows events up to rate r and permits</span></span><br><span class="line"><span class="comment">// bursts of at most b tokens.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewLimiter</span><span class="params">(r Limit, b <span class="type">int</span>)</span></span> *Limiter &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Limiter&#123;</span><br><span class="line">        limit: r,</span><br><span class="line">        burst: b,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NewLimiter有两个参数</p><p>第一个r Limit 表示每秒可以放入多少个token到桶中，Limit是float64的别名；</p><p>第二个b int 表示桶容量大小,即同一时刻能取到的最大token数量；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">limiter := NewLimiter(<span class="number">10</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>示例表示每秒放入10个token，桶容量大小为1</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">limit := Every(<span class="number">100</span> * time.Millisecond);</span><br><span class="line">limiter := NewLimiter(limit, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>Every表示放入token速率时间粒度;</p><p>示例表示每100ms放入1个token,即1秒放入10个；</p><h3 id="2-3-Wait-WaitN"><a href="#2-3-Wait-WaitN" class="headerlink" title="2.3 Wait/WaitN"></a>2.3 Wait/WaitN</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Wait(ctx context.Context) (err <span class="type">error</span>)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> WaitN(ctx context.Context, n <span class="type">int</span>) (err <span class="type">error</span>)</span><br></pre></td></tr></table></figure><p>Wait获取Token时如果数组不足(小于N)，将会阻塞一段时间，直至Token满足条件, 如果充足则直接返回</p><p>阻塞时间可以通过context参数设置Deadline或Timeout控制</p><h3 id="2-4-Allow-AllowN"><a href="#2-4-Allow-AllowN" class="headerlink" title="2.4 Allow/AllowN"></a>2.4 Allow/AllowN</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Allow() <span class="type">bool</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> AllowN(now time.Time, n <span class="type">int</span>) <span class="type">bool</span></span><br></pre></td></tr></table></figure><p>Allow获取Token充足返回true，同时Token减少，否则返回false，不会阻塞</p><h3 id="2-5-Reserve-ReserveN"><a href="#2-5-Reserve-ReserveN" class="headerlink" title="2.5 Reserve/ReserveN"></a>2.5 Reserve/ReserveN</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Reserve() *Reservation</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> ReserveN(now time.Time, n <span class="type">int</span>) *Reservation</span><br></pre></td></tr></table></figure><p>返回Reservation对象，有如下对象方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> OK() <span class="type">bool</span> <span class="comment">// 判断是否获取到token</span></span><br><span class="line"><span class="comment">// Delay is shorthand for DelayFrom(time.Now()).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> Delay() time.Duration <span class="comment">// 获取延迟等待时间,此时Cancel不起作用</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> DelayFrom(now time.Time) time.Duration</span><br><span class="line"><span class="comment">// Cancel is shorthand for CancelAt(time.Now()).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> Cancel() <span class="comment">// 取消，将获取的Token重新放入桶中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Reservation)</span></span> CancelAt(now time.Time)</span><br></pre></td></tr></table></figure><h3 id="2-6-调整速率和桶大小"><a href="#2-6-调整速率和桶大小" class="headerlink" title="2.6 调整速率和桶大小"></a>2.6 调整速率和桶大小</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetLimit(newLimit Limit) <span class="comment">//改变放入Token的速率</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetLimitAt(now time.Time, newLimit Limit)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetBurst(newBurst <span class="type">int</span>) <span class="comment">// 改变Token桶大小</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> SetBurstAt(now time.Time, newBurst <span class="type">int</span>)</span><br></pre></td></tr></table></figure><h3 id="2-7-获取速率和桶大小"><a href="#2-7-获取速率和桶大小" class="headerlink" title="2.7 获取速率和桶大小"></a>2.7 获取速率和桶大小</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Limit() Limit <span class="comment">// 获取速率</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(lim *Limiter)</span></span> Burst() <span class="type">int</span> <span class="comment">//获取桶容量</span></span><br></pre></td></tr></table></figure><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h2><ul><li><a href="https://www.cyhone.com/articles/analisys-of-golang-rate/">Golang 标准库限流器 time/rate 实现剖析</a></li><li><a href="https://www.cyhone.com/articles/usage-of-golang-rate/">Golang 标准库限流器 time/rate 使用介绍</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
          <category> Packages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go-Package </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] 工程实践</title>
      <link href="/2021/09/20/Golang/3%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/Golang%20%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
      <url>/2021/09/20/Golang/3%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/Golang%20%E5%B7%A5%E7%A8%8B%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如何写优雅的 Go 语言代码</p></blockquote><span id="more"></span><h2 id="1-最佳实践"><a href="#1-最佳实践" class="headerlink" title="1 最佳实践"></a>1 最佳实践</h2><h3 id="1-1-目录结构"><a href="#1-1-目录结构" class="headerlink" title="1.1 目录结构"></a>1.1 目录结构</h3><p>目录结构基本上就是一个项目的门面，很多时候我们从目录结构中就能够看出开发者对这门语言是否有足够的经验。</p><p>官方并没有给出一个推荐的目录划分方式，但是社区中还是有一些比较常见的约定：例如：<a href="https://github.com/golang-standards/project-layout">golang-standards/project-layout</a> 项目中就定义了一个比较标准的目录结构。</p><h4 id="1-1-1-pkg"><a href="#1-1-1-pkg" class="headerlink" title="1.1.1 /pkg"></a>1.1.1 /pkg</h4><p><code>/pkg</code> 目录是 Go 语言项目中非常常见的目录，我们几乎能够在所有知名的开源项目（非框架）中找到它的身影。</p><p><strong>这个目录中存放的就是项目中可以被外部应用使用的代码库</strong>，其他的项目可以直接通过 <code>import</code> 引入这里的代码，所以当我们将代码放入 <code>pkg</code> 时一定要慎重。</p><h4 id="1-1-2-internal"><a href="#1-1-2-internal" class="headerlink" title="1.1.2 /internal"></a>1.1.2 /internal</h4><p>私有代码推荐放到 <code>/internal</code> 目录中，真正的项目代码应该写在 <code>/internal/app</code> 里，同时这些内部应用依赖的代码库应该在 <code>/internal/pkg</code> 子目录和 <code>/pkg</code> 中。</p><h4 id="1-1-3-src"><a href="#1-1-3-src" class="headerlink" title="1.1.3 /src"></a>1.1.3 /src</h4><p>作为一个 Go 语言的开发者，我们不应该允许项目中存在 <code>/src</code> 目录。</p><blockquote><p>社区中的一些项目确实有 <code>/src</code> 文件夹，但是这些项目的开发者之前大多数都有 Java 的编程经验。</p></blockquote><p>最重要的原因其实是 Go 语言的项目在默认情况下都会被放置到 <code>$GOPATH/src</code> 目录下，这个目录中存储着我们开发和依赖的全部项目代码，如果我们在自己的项目中使用 <code>/src</code> 目录，该项目的 <code>PATH</code> 中就会出现两个 <code>src</code></p><p> $GOPATH/src/github.com/draveness/project/src/code.go</p><h4 id="1-1-4-cmd"><a href="#1-1-4-cmd" class="headerlink" title="1.1.4 /cmd"></a>1.1.4 /cmd</h4><p><code>/cmd</code> 目录中存储的都是当前项目中的可执行文件，该目录下的每一个子目录都应该包含我们希望有的可执行文件。</p><blockquote><p>如果我们的项目是一个 <code>grpc</code> 服务的话，可能在 <code>/cmd/server/main.go</code> 中就包含了启动服务进程的代码，编译后生成的可执行文件就是 <code>server</code>。</p></blockquote><h4 id="1-1-5-api"><a href="#1-1-5-api" class="headerlink" title="1.1.5 /api"></a>1.1.5 /api</h4><p><code>/api</code> 目录中存放的就是当前项目对外提供的各种不同类型的 API 接口定义文件了。</p><blockquote><p>其中可能包含类似 <code>/api/protobuf-spec</code>、<code>/api/thrift-spec</code> 或者 <code>/api/http-spec</code> 的目录</p></blockquote><p> $ tree ./api<br> api<br> └── protobuf-spec<br>     └── oceanbookpb<br>         ├── oceanbook.pb.go<br>         └── oceanbook.proto</p><h4 id="1-1-6-Makefile"><a href="#1-1-6-Makefile" class="headerlink" title="1.1.6 Makefile"></a>1.1.6 Makefile</h4><p>最后要介绍的 <code>Makefile</code> 文件也非常值得被关注，在任何一个项目中都会存在一些需要运行的脚本，这些脚本文件应该被放到 <code>/scripts</code> 目录中并由 <code>Makefile</code> 触发，将这些经常需要运行的命令固化成脚本减少『祖传命令』的出现。</p><h4 id="1-1-7-小结"><a href="#1-1-7-小结" class="headerlink" title="1.1.7 小结"></a>1.1.7 小结</h4><p>总的来说，每一个项目都应该按照固定的组织方式进行实现，这种约定虽然并不是强制的，但是无论是组内、公司内还是整个 Go 语言社区中，只要达成了一致，对于其他工程师快速梳理和理解项目都是很有帮助的。</p><h3 id="1-2-模块拆分"><a href="#1-2-模块拆分" class="headerlink" title="1.2 模块拆分"></a>1.2 模块拆分</h3><p>Go 语言的一些顶层设计最终导致了它在划分模块上与其他的编程语言有着非常明显的不同。</p><h4 id="1-2-1-按层拆分"><a href="#1-2-1-按层拆分" class="headerlink" title="1.2.1 按层拆分"></a>1.2.1 按层拆分</h4><p><code>Java</code>中的<code>SpringMVC</code>深受 <a href="https://draveness.me/mvx">MVC 架构模式</a> 的影响,这是一种 Web 框架的最常见架构方式，将服务中的不同组件分成了 Model、View 和 Controller 三层。</p><p> app<br> ├── controllers<br> │   ├── application_controller.rb<br> │   └── concerns<br> ├── models<br> │   ├── application_record.rb<br> │   └── concerns<br> └── views<br>     └── layouts</p><h4 id="1-2-2-按职责拆分"><a href="#1-2-2-按职责拆分" class="headerlink" title="1.2.2 按职责拆分"></a>1.2.2 按职责拆分</h4><p>Go 语言在拆分模块时就使用了完全不同的思路，虽然 MVC 架构模式是在我们写 Web 服务时无法避开的，但是相比于横向地切分不同的层级，Go 语言的项目往往都按照职责对模块进行拆分：</p><p>对于一个比较常见的博客系统，使用 Go 语言的项目会按照不同的职责将其纵向拆分成 <code>post</code>、<code>user</code>、<code>comment</code> 三个模块，每一个模块都对外提供相应的功能，<code>post</code> 模块中就包含相关的模型和视图定义以及用于处理 API 请求的控制器（或者服务）：</p><p> $ tree pkg<br> pkg<br> ├── comment<br> ├── post<br> │   ├── handler.go<br> │   └── post.go<br> └── user</p><p>如果我们在 Go 语言中使用 <code>model</code>、<code>view</code> 和 <code>controller</code> 来划分层级，你会在其他的模块中看到非常多的 <code>model.Post</code>、<code>model.Comment</code> 和 <code>view.PostView</code>。</p><blockquote><p>这种划分层级的方法在 Go 语言中会显得非常冗余，并且如果对项目依赖包的管理不够谨慎时，很容易发生引用循环</p></blockquote><h4 id="1-2-3-小结"><a href="#1-2-3-小结" class="headerlink" title="1.2.3 小结"></a>1.2.3 小结</h4><p>项目是按照层级还是按照职责对模块进行拆分其实并没有绝对的好与不好，语言和框架层面的设计最终决定了我们应该采用哪种方式对项目和代码进行组织。</p><p><strong>Go 语言项目的最佳实践就是按照职责对模块进行垂直拆分，将代码按照功能的方式分到多个 <code>package</code> 中。</strong></p><blockquote><p>因为 <code>package</code> 作为一个 Go 语言访问控制的最小粒度，所以我们应该遵循顶层的设计使用这种方式构建高内聚的模块。</p></blockquote><h3 id="1-3-显式与隐式"><a href="#1-3-显式与隐式" class="headerlink" title="1.3 显式与隐式"></a>1.3 显式与隐式</h3><p>Go 语言社区对于<strong>显式的初始化、方法调用和错误处理</strong>非常推崇，类似 Spring Boot 和 Rails 的框架其实都广泛地采纳了『约定优于配置』的中心思想，简化了开发者和工程师的工作量。</p><blockquote><p>虽然是社区达成的共识与约定，但是从语言的设计以及工具上的使用我们就能发现显式地调用方法和错误处理是被鼓励的。</p></blockquote><h4 id="1-3-1-init"><a href="#1-3-1-init" class="headerlink" title="1.3.1 init"></a>1.3.1 init</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">var</span> grpcClient *grpc.Client  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;  </span><br><span class="line">     <span class="keyword">var</span> err <span class="type">error</span>  </span><br><span class="line">     grpcClient, err = grpc.Dial(...)  </span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="built_in">panic</span>(err)  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">GetPost</span><span class="params">(postID <span class="type">int64</span>)</span></span> (*Post, <span class="type">error</span>) &#123;  </span><br><span class="line">     post, err := grpcClient.FindPost(context.Background(), &amp;pb.FindPostRequest&#123;PostID: postID&#125;)  </span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nil</span>, err  </span><br><span class="line">     &#125;  </span><br><span class="line">       </span><br><span class="line">     <span class="keyword">return</span> post, <span class="literal">nil</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这种代码虽然能够通过编译并且正常工作，然而这里的 <code>init</code> 函数其实隐式地初始化了 grpc 的连接资源，如果另一个 <code>package</code> 依赖了当前的包，那么引入这个依赖的工程师可能会在遇到错误时非常困惑，因为在 <code>init</code> 函数中做这种资源的初始化是非常耗时并且容易出现问题的。</p><p><strong>一种更加合理的做法显示地调用初始化方法。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// cmd/grpc/main.go  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">     grpcClient, err := grpc.Dial(...)  </span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="built_in">panic</span>(err)  </span><br><span class="line">     &#125;  </span><br><span class="line">       </span><br><span class="line">     postClient := post.NewClient(grpcClient)  </span><br><span class="line">     <span class="comment">// ...  </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这样我们从 <code>main</code> 函数开始就能梳理出程序启动的整个过程。</p><p>比较合理地用法是这样的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;  </span><br><span class="line">     <span class="keyword">if</span> user == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">         log.Fatal(<span class="string">&quot;$USER not set&quot;</span>)  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">if</span> home == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">         home = <span class="string">&quot;/home/&quot;</span> + user  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">if</span> gopath == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">         gopath = home + <span class="string">&quot;/go&quot;</span>  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">// gopath may be overridden by --gopath flag on command line.  </span></span><br><span class="line">     flag.StringVar(&amp;gopath, <span class="string">&quot;gopath&quot;</span>, gopath, <span class="string">&quot;override default GOPATH&quot;</span>)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>我们不应该在 <code>init</code> 中做过重的初始化逻辑，而是做一些简单、轻量的前置条件判断</strong></p><h4 id="1-3-2-error"><a href="#1-3-2-error" class="headerlink" title="1.3.2 error"></a>1.3.2 error</h4><p>当我们在 Go 语言中处理错误相关的逻辑时，最重要的其实就是以下几点：</p><ul><li><ol><li><strong>使用 <code>error</code> 实现错误处理</strong> — 尽管这看起来非常啰嗦；</li></ol></li><li><ol><li><strong>将错误抛给上层处理</strong> — 对于一个方法是否需要返回 <code>error</code> 也需要我们仔细地思考，向上抛出错误时可以通过 <code>errors.Wrap</code> 携带一些额外的信息方便上层进行判断；</li></ol></li><li><ol><li><strong>处理所有可能返回的错误</strong> — 所有可能返回错误的地方最终一定会返回错误，考虑全面才能帮助我们构建更加健壮的项目；</li></ol></li></ul><h3 id="1-4-面向接口"><a href="#1-4-面向接口" class="headerlink" title="1.4 面向接口"></a>1.4 面向接口</h3><p>接口的作用其实就是为不同层级的模块提供了一个定义好的中间层，上游不再需要依赖下游的具体实现，充分地对上下游进行了解耦。</p><p>这种编程方式不仅是在 Go 语言中是被推荐的，在几乎所有的编程语言中，我们都会推荐这种编程的方式。它为我们的程序提供了非常强的<code>灵活性</code>，想要构建一个稳定、健壮的 Go 语言项目，不使用接口是完全无法做到的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> post  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">var</span> client *grpc.ClientConn  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;  </span><br><span class="line">     <span class="keyword">var</span> err <span class="type">error</span>  </span><br><span class="line">     client, err = grpc.Dial(...）  </span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="built_in">panic</span>(err)  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">ListPosts</span><span class="params">()</span></span> ([]*Post, <span class="type">error</span>) &#123;  </span><br><span class="line">     posts, err := client.ListPosts(...)  </span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> []*Post&#123;&#125;, err  </span><br><span class="line">     &#125;  </span><br><span class="line">       </span><br><span class="line">     <span class="keyword">return</span> posts, <span class="literal">nil</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>上述代码其实就不是一个设计良好的代码，它不仅在 <code>init</code> 函数中隐式地初始化了 grpc 连接这种全局变量，而且没有将 <code>ListPosts</code> 通过接口的方式暴露出去，这会让依赖 <code>ListPosts</code> 的上层模块难以测试。</p><p>我们可以使用下面的代码改写原有的逻辑，使得同样地逻辑变得更容易测试和维护：</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> post  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> Service <span class="keyword">interface</span> &#123;  </span><br><span class="line">     ListPosts() ([]*Post, <span class="type">error</span>)  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> service <span class="keyword">struct</span> &#123;  </span><br><span class="line">     conn *grpc.ClientConn  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">NewService</span><span class="params">(conn *grpc.ClientConn)</span></span> Service &#123;  </span><br><span class="line">     <span class="keyword">return</span> &amp;service&#123;  </span><br><span class="line">         conn: conn,  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *service)</span></span> ListPosts() ([]*Post, <span class="type">error</span>) &#123;  </span><br><span class="line">     posts, err := s.conn.ListPosts(...)  </span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> []*Post&#123;&#125;, err  </span><br><span class="line">     &#125;  </span><br><span class="line">       </span><br><span class="line">     <span class="keyword">return</span> posts, <span class="literal">nil</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li><ol><li>通过接口 <code>Service</code> 暴露对外的 <code>ListPosts</code> 方法；</li></ol></li><li><ol><li>使用 <code>NewService</code> 函数初始化 <code>Service</code> 接口的实现并通过私有的结构体 <code>service</code> 持有 grpc 连接；</li></ol></li><li><ol><li><code>ListPosts</code> 不再依赖全局变量，而是依赖接口体 <code>service</code> 持有的连接；</li></ol></li></ul><p>当我们使用这种方式重构代码之后，就可以在 <code>main</code> 函数中显式的初始化 grpc 连接、创建 <code>Service</code> 接口的实现并调用 <code>ListPosts</code> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> main  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">import</span> ...  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;  </span><br><span class="line">     conn, err = grpc.Dial(...）  </span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="built_in">panic</span>(err)  </span><br><span class="line">     &#125;  </span><br><span class="line">       </span><br><span class="line">     svc := post.NewService(conn)  </span><br><span class="line">     posts, err := svc.ListPosts()  </span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="built_in">panic</span>(err)  </span><br><span class="line">     &#125;  </span><br><span class="line">       </span><br><span class="line">     fmt.Println(posts)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这种使用接口组织代码的方式在 Go 语言中非常常见，我们应该在代码中尽可能地使用这种思想和模式对外提供功能：</p><ul><li><ol><li>使用大写的 <code>Service</code> 对外暴露方法；</li></ol></li><li><ol><li>使用小写的 <code>service</code> 实现接口中定义的方法；</li></ol></li><li><ol><li>通过 <code>NewService</code> 函数初始化 <code>Service</code> 接口；</li></ol></li></ul><p>当我们使用上述方法组织代码之后，其实就对不同模块的依赖进行了解耦，也正遵循了软件设计中经常被提到的一句话 — 『依赖接口，不要依赖实现』，也就是<strong>面向接口编程</strong>。</p><h3 id="1-5-小结"><a href="#1-5-小结" class="headerlink" title="1.5 小结"></a>1.5 小结</h3><p>在这一小节中总共介绍了 Go 语言中三个经常会打交道的『元素』— <code>init</code> 函数、<code>error</code> 和接口，我们在这里主要是想通过三个不同的例子为大家传达的一个主要思想就是尽量使用<strong>显式的（explicit）的方式</strong>编写 Go 语言代码。</p><h2 id="2-单元测试"><a href="#2-单元测试" class="headerlink" title="2 单元测试"></a>2 单元测试</h2><p>一个代码质量和工程质量有保证的项目一定有比较合理的单元测试覆盖率，没有单元测试的项目一定是不合格的或者不重要的，单元测试应该是所有项目都必须有的代码，每一个单元测试都表示一个可能发生的情况，<strong>单元测试就是业务逻辑</strong>。</p><h3 id="2-1-可测试性"><a href="#2-1-可测试性" class="headerlink" title="2.1 可测试性"></a>2.1 可测试性</h3><p>如何控制待测试方法中依赖的模块是写单元测试时至关重要的，控制依赖也就是对目标函数的依赖进行 <code>Mock</code> 消灭不确定性，为了减少每一个单元测试的复杂度，我们需要：</p><ul><li>1）尽可能减少目标方法的依赖，让目标方法只依赖必要的模块；</li><li>2）依赖的模块也应该非常容易地进行 <code>Mock</code>；<h4 id="2-1-1-接口"><a href="#2-1-1-接口" class="headerlink" title="2.1.1 接口"></a>2.1.1 接口</h4></li></ul><p>接口的使用能够为我们带来更清晰的抽象，帮助我们思考如何对代码进行设计，也能让我们更方便地对依赖进行 <code>Mock</code>。</p><p>接口常见用法</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Service <span class="keyword">interface</span> &#123; ... &#125;  </span><br><span class="line"> ​  </span><br><span class="line"><span class="keyword">type</span> service <span class="keyword">struct</span> &#123; ... &#125;  </span><br><span class="line"> ​  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewService</span><span class="params">(...)</span></span> (Service, <span class="type">error</span>) &#123;  </span><br><span class="line">   <span class="keyword">return</span> &amp;service&#123;...&#125;, <span class="literal">nil</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>果你不知道应不应该使用接口对外提供服务，这时就应该无脑地使用上述模式对外暴露方法了，这种模式可以在绝大多数的场景下工作。</p><h4 id="函数简单"><a href="#函数简单" class="headerlink" title="函数简单"></a>函数简单</h4><p>另一个建议就是保证每一个函数尽可能简单，这里的简单不止是指功能上的简单、单一，还意味着函数容易理解并且命名能够自解释。</p><h3 id="组织方式"><a href="#组织方式" class="headerlink" title="组织方式"></a>组织方式</h3><p>Go 语言中的单元测试文件和代码都是与源代码放在同一个目录下按照 <code>package</code> 进行组织的，<code>server.go</code> 文件对应的测试代码应该放在同一目录下的 <code>server_test.go</code> 文件中。</p><h4 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h4><p>单元测试的最常见以及默认组织方式就是写在以 <code>_test.go</code> 结尾的文件中，所有的测试方法也都是以 <code>Test</code> 开头并且只接受一个 <code>testing.T</code> 类型的参数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">TestAuthor</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">     author := blog.Author()  </span><br><span class="line">     assert.Equal(t, <span class="string">&quot;draveness&quot;</span>, author)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-Suite"><a href="#2-1-2-Suite" class="headerlink" title="2.1.2 Suite"></a>2.1.2 Suite</h4><p>第二种比较常见的方式是按照簇进行组织，其实就是对 Go 语言默认的测试方式进行简单的封装，我们可以使用 <a href="https://github.com/stretchr/testify">stretchr/testify</a> 中的 <code>suite</code> 包对测试进行组织:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> (  </span><br><span class="line">     <span class="string">&quot;testing&quot;</span>  </span><br><span class="line">     <span class="string">&quot;github.com/stretchr/testify/suite&quot;</span>  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> ExampleTestSuite <span class="keyword">struct</span> &#123;  </span><br><span class="line">     suite.Suite  </span><br><span class="line">     VariableThatShouldStartAtFive <span class="type">int</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(suite *ExampleTestSuite)</span></span> SetupTest() &#123;  </span><br><span class="line">     suite.VariableThatShouldStartAtFive = <span class="number">5</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(suite *ExampleTestSuite)</span></span> TestExample() &#123;  </span><br><span class="line">     suite.Equal(suite.VariableThatShouldStartAtFive, <span class="number">5</span>)  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">TestExampleTestSuite</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">     suite.Run(t, <span class="built_in">new</span>(ExampleTestSuite))  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>suite</code> 包，以结构体的方式对测试簇进行组织，<code>suite</code> 提供的 <code>SetupTest</code>/<code>SetupSuite</code> 和 <code>TearDownTest</code>/<code>TearDownSuite</code> 是执行测试前后以及执行测试簇前后的钩子方法，我们能在其中完成一些共享资源的初始化，减少测试中的初始化代码。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
          <category> 代码规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Panic Recover</title>
      <link href="/2021/09/16/Golang/0%20%E5%9F%BA%E7%A1%80/%E5%85%B3%E9%94%AE%E5%AD%97/Panic%20Recover/"/>
      <url>/2021/09/16/Golang/0%20%E5%9F%BA%E7%A1%80/%E5%85%B3%E9%94%AE%E5%AD%97/Panic%20Recover/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以链表形式存储在 goroutine 结构体中。</p></blockquote><span id="more"></span><h2 id="1-1-概述"><a href="#1-1-概述" class="headerlink" title="1 1.概述"></a>1 1.概述</h2><p>和 defer 一样，<strong>panic 也是以链表形式存储的</strong>,同样是存储在 goroutine 结构体中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/runtime/runtime2.go 395行</span></span><br><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">_panic       *_panic <span class="comment">// innermost panic - offset known to liblink</span></span><br><span class="line">_defer       *_defer <span class="comment">// innermost defer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>panic 链表中链的是一个一个 _panic 结构体。</p><p>和 defer 一样，<strong>发生新的 panic 时也是在 _panic 链表头上插入新的 _panic 结构体</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _panic <span class="keyword">struct</span> &#123;</span><br><span class="line">argp      unsafe.Pointer <span class="comment">// defer 的参数空间地址</span></span><br><span class="line">arg       <span class="keyword">interface</span>&#123;&#125;    <span class="comment">// panic 自己的参数</span></span><br><span class="line">link      *_panic        <span class="comment">// 链接到之前发生的panic</span></span><br><span class="line"></span><br><span class="line">recovered <span class="type">bool</span>           <span class="comment">// 标识panic是否被恢复</span></span><br><span class="line">aborted   <span class="type">bool</span>           <span class="comment">// panic是否被终止</span></span><br><span class="line">    pc        <span class="type">uintptr</span>        </span><br><span class="line">sp        unsafe.Pointer </span><br><span class="line">goexit    <span class="type">bool</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的 pc、sp、goexit 三个字段主要是为了修复 runtime.Goexit 带来的问题引入的。</p><blockquote><p>runtime.Goexit 能够只结束调用该函数的 Goroutine 而不影响其他的 Goroutine，但是该函数会被 <code>defer</code> 中的 <code>panic</code> 和 <code>recover</code> 取消，引入这三个字段就是为了保证该函数的一定会生效。</p></blockquote><p>例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> A1()</span><br><span class="line"><span class="keyword">defer</span> A2()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;panic A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">()</span></span> &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">()</span></span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>具体结构如下图所示：</p><p><img src="file-20250119062723162.png" alt=""></p><h2 id="2-正常流程"><a href="#2-正常流程" class="headerlink" title="2 正常流程"></a>2 正常流程</h2><p>编译器会将关键字 <code>panic</code> 转换成<code>runtime.gopanic</code>函数，该函数执行过程包括以下几个步骤：</p><ul><li>1）创建新的 runtime._panic 并添加到 Goroutine 的 _panic 链表头</li><li>2）在循环中不断从当前 Goroutine 的 <code>_defer</code> 中链表获取<code>runtime._defer</code>,并调用  runtime.reflectcall，运行延迟调用函数。</li><li>3）调用 runtime.fatalpanic 中止整个程序。</li></ul><p>不过 panic 导致的 defer 链表执行和正常 defer 执行有所不同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _defer <span class="keyword">struct</span> &#123;</span><br><span class="line"></span><br><span class="line">started <span class="type">bool</span></span><br><span class="line">_panic    *_panic  <span class="comment">// panic that is running defer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>panic 触发defer执行时，会将 _defer 结构体中的 started 字段标记为 true，同时把 _panic 字段指向自己，表示这个 defer 是由这个 panic 触发的。</p><blockquote><p>这样做主要是为了中止panic，因为defer 函数中有可能还会发生panic。</p></blockquote><p><strong>defer 中的 panic</strong></p><p>如果 defer 函数中也发生了 panic，同样的按照上述逻辑，会创建一个 _panic 结构体，并插入到当前 goroutine 的  _panic 链表头，此时正在执行的 panic 就变成了这个刚发生的 panic。</p><p>这个 panic 执行时也会先去执行 defer 链表，然后发现 defer 链表头指向的 defer 的 started 标记为true，而且 _panic 字段指向的也不是自己，所以就会根据 _panic 指针找到对应的 panic，并将其标记为已终止，即将 aborted 字段设置为 true。</p><p><strong>打印 panic信息</strong></p><p>打印 panic 信息的时候，会从 _panic 链表尾部开始打印，也就是按照 panic 发生的顺序逐个输出。</p><p><strong>例子</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> A1()</span><br><span class="line"><span class="keyword">defer</span> A2()</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;panic A&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A1</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;panic A1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A2</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体结构如下图所示：</p><p><img src="file-20250119062734853.png" alt=""></p><p><strong>小结</strong></p><p>没有 recover 的 panic 执行流程就是这个样子了，关键点如下：</p><ul><li>1）<strong>panic 执行 defer 函数的方式</strong>：先标记后释放， 目的是为了终止之前发生的 panic。</li><li>2）<strong>异常信息输出方式</strong>：从 _panic 链表尾部开始打印，也就是按照 panic 发生的顺序逐个输出</li></ul><h2 id="3-带-recover-的-panic"><a href="#3-带-recover-的-panic" class="headerlink" title="3 带 recover 的 panic"></a>3 带 recover 的 panic</h2><p>recover 只做一件事，就是把当前执行的 panic 置为已恢复，即把 recovered 字段置为 true。</p><h3 id="3-1-执行流程"><a href="#3-1-执行流程" class="headerlink" title="3.1 执行流程"></a>3.1 执行流程</h3><ul><li>1）触发 panic。</li><li>2）panic 开始执行 defer 链表</li><li>3）defer 中有 recover，把当前 panic 恢复了（将当前 panic 的 recovered 字段置为 true）。</li><li>4）每个 defer 函数执行完成后，panic 处理流程都会检查当前 panic 是否被它(即刚刚执行的defer函数)恢复了。</li><li>5）panic 处理流程发现当前 panic 已经被恢复了，于是将其从 panic 链表移除，同时对应的也会把前面执行过的那个 defer 函数移除，不过移除前需要保存 _defer.pc 和 _defer.sp 这两个字段的值。</li><li>6）根据前面保存的 _defer.pc 和 _defer.sp 跳出当前 panic 的处理流程。</li></ul><h3 id="3-2-recover"><a href="#3-2-recover" class="headerlink" title="3.2 recover"></a>3.2 recover</h3><p>编译器会将关键字 <code>recover</code> 转换成 runtime.gorecover,代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gorecover</span><span class="params">(argp <span class="type">uintptr</span>)</span></span> <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">gp := getg()</span><br><span class="line">p := gp._panic</span><br><span class="line"><span class="keyword">if</span> p != <span class="literal">nil</span> &amp;&amp; !p.recovered &amp;&amp; argp == <span class="type">uintptr</span>(p.argp) &#123;</span><br><span class="line">p.recovered = <span class="literal">true</span></span><br><span class="line"><span class="keyword">return</span> p.arg</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-恢复流程"><a href="#3-3-恢复流程" class="headerlink" title="3.3 恢复流程"></a>3.3 恢复流程</h3><p>之前 defer 注册的时候，例子如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> B()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">()</span></span> &#123;</span><br><span class="line"> <span class="comment">// dosomething</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>伪指令大概是这样子的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    r = deferproc(<span class="number">8</span>,B)</span><br><span class="line">    <span class="keyword">if</span> r &gt; <span class="number">0</span>&#123;</span><br><span class="line">        <span class="keyword">goto</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dosomething</span></span><br><span class="line">    runtime.deferreturn()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"> ret:</span><br><span class="line">     runtime.deferreturn()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sp 是当前函数的栈指针，pc 字段就是调用 deferproc函数的返回地址，也就是下面这段逻辑：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> r &gt; <span class="number">0</span>&#123;</span><br><span class="line">    <span class="keyword">goto</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 将寄存器的 r 的值改成了 1，然后进入 if 逻辑，通过 goto 跳转到 ret 位置去执行  runtime.deferreturn()。</p><p>这样就退出了 panic 处理流程。然后由于函数退出前要先执行 defer 链表，所以又进入了 defer 链表的调用流程，直到整个 defer 链表执行完毕，函数正常退出，不会打印任何 panic 信息。</p><p><strong>需要注意的是:只有执行 recover 的函数，正常返回后，才会进入 panic 处理流程，去检查 panic 是否被恢复。</strong></p><h3 id="3-4-recover后再次-panic"><a href="#3-4-recover后再次-panic" class="headerlink" title="3.4 recover后再次 panic"></a>3.4 recover后再次 panic</h3><p>如果 recover 执行后，又触发了 panic，情况就又不一样了：</p><ul><li>1）defer 中执行 recover 将当前 panic 标记为已恢复，然后在这个 defer 函数中又触发了 panic。</li><li>2）将当前这个触发的 panic 添加到 _panic 链表头，由这个 panic 开始再次去执行 defer 链表</li><li>3）发现第一个 defer 已经被执行了(就是刚才调用recover的那个)，但是触发的 panic 不是自己，于是把对应的 panic 标记为已终止，然后把这个已执行的 defer 移除。</li><li>4）继续执行后续的 defer。</li><li>5）最后打印出 panic 信息，不过由于其中有个 panic 是被 recover 过的，所以打印的异常信息中也会将其体现出来。</li></ul><h2 id="4-参考"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考</h2><p><code>`https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 关键字 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] 代码规范</title>
      <link href="/2021/08/19/Golang/3%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/Golang%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2021/08/19/Golang/3%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/Golang%20%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<blockquote><p>主要记录了一些容易犯错的地方，具体规范参考如下:</p></blockquote><span id="more"></span><p><a href="https://github.com/golang/go/wiki/CodeReviewComments">Go Code Review Comments</a><br><a href="https://github.com/uber-go/guide">uber-go</a></p><h2 id="1-原则"><a href="#1-原则" class="headerlink" title="1 原则"></a>1 原则</h2><h3 id="1-1-零值-Mutex-是有效的"><a href="#1-1-零值-Mutex-是有效的" class="headerlink" title="1.1 零值 Mutex 是有效的"></a>1.1 零值 Mutex 是有效的</h3><p>零值 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code> 是有效的。所以指向 mutex 的指针基本是不必要的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> mu := <span class="built_in">new</span>(sync.Mutex)   </span><br><span class="line"> mu.Lock()  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">var</span> mu sync.Mutex   </span><br><span class="line"> mu.Lock()</span><br></pre></td></tr></table></figure><p>如果你使用结构体指针，mutex 可以非指针形式作为结构体的组成字段，或者更好的方式是直接嵌入到结构体中。 如果是私有结构体类型或是要实现 Mutex 接口的类型，我们可以使用嵌入 mutex 的方法：</p><p><strong>为私有类型或需要实现互斥接口的类型嵌入。</strong></p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> smap <span class="keyword">struct</span> &#123;  </span><br><span class="line">   sync.Mutex <span class="comment">// only for unexported types（仅适用于非导出类型）  </span></span><br><span class="line"> ​  </span><br><span class="line">   data <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">newSMap</span><span class="params">()</span></span> *smap &#123;  </span><br><span class="line">   <span class="keyword">return</span> &amp;smap&#123;  </span><br><span class="line">     data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>),  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *smap)</span></span> Get(k <span class="type">string</span>) <span class="type">string</span> &#123;  </span><br><span class="line">   m.Lock()  </span><br><span class="line">   <span class="keyword">defer</span> m.Unlock()  </span><br><span class="line"> ​  </span><br><span class="line">   <span class="keyword">return</span> m.data[k]  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>对于导出的类型，请使用专用字段。</strong></p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SMap <span class="keyword">struct</span> &#123;  </span><br><span class="line">   mu sync.Mutex <span class="comment">// 对于导出类型，请使用私有锁  </span></span><br><span class="line"> ​  </span><br><span class="line">   data <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">NewSMap</span><span class="params">()</span></span> *SMap &#123;  </span><br><span class="line">   <span class="keyword">return</span> &amp;SMap&#123;  </span><br><span class="line">     data: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>),  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(m *SMap)</span></span> Get(k <span class="type">string</span>) <span class="type">string</span> &#123;  </span><br><span class="line">   m.mu.Lock()  </span><br><span class="line">   <span class="keyword">defer</span> m.mu.Unlock()  </span><br><span class="line"> ​  </span><br><span class="line">   <span class="keyword">return</span> m.data[k]  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-在边界处拷贝-Slices-和-Maps"><a href="#1-2-在边界处拷贝-Slices-和-Maps" class="headerlink" title="1.2 在边界处拷贝 Slices 和 Maps"></a>1.2 在边界处拷贝 Slices 和 Maps</h3><p>slices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。</p><h4 id="1-2-1-接收-Slices-和-Maps"><a href="#1-2-1-接收-Slices-和-Maps" class="headerlink" title="1.2.1 接收 Slices 和 Maps"></a>1.2.1 接收 Slices 和 Maps</h4><p>请记住，当 map 或 slice 作为函数参数传入时，如果您存储了对它们的引用，则用户可以对其进行修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span></span> SetTrips(trips []Trip) &#123;  </span><br><span class="line">   <span class="comment">// 直接赋值则和外部指向同一引用 受外部修改影响  </span></span><br><span class="line">   d.trips = trips  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> trips := ...  </span><br><span class="line"> d1.SetTrips(trips)  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 你是要修改 d1.trips 吗？  </span></span><br><span class="line"> trips[<span class="number">0</span>] = ...</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(d *Driver)</span></span> SetTrips(trips []Trip) &#123;  </span><br><span class="line">   <span class="comment">// 这里copy单独复制一份出来 之后则不受外部修改影响  </span></span><br><span class="line">   d.trips = <span class="built_in">make</span>([]Trip, <span class="built_in">len</span>(trips))  </span><br><span class="line">   <span class="built_in">copy</span>(d.trips, trips)  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> trips := ...  </span><br><span class="line"> d1.SetTrips(trips)  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 这里我们修改 trips[0]，但不会影响到 d1.trips  </span></span><br><span class="line"> trips[<span class="number">0</span>] = ...</span><br></pre></td></tr></table></figure><h4 id="1-2-2-返回-slices-或-maps"><a href="#1-2-2-返回-slices-或-maps" class="headerlink" title="1.2.2 返回 slices 或 maps"></a>1.2.2 返回 slices 或 maps</h4><p>同样，请注意用户对暴露内部状态的 map 或 slice 的修改。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Bad  </span></span><br><span class="line"> <span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;  </span><br><span class="line">   mu sync.Mutex  </span><br><span class="line"> ​  </span><br><span class="line">   counters <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// Snapshot 返回当前状态。  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span></span> Snapshot() <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;  </span><br><span class="line">   s.mu.Lock()  </span><br><span class="line">   <span class="keyword">defer</span> s.mu.Unlock()  </span><br><span class="line">   <span class="comment">// 直接返回引用 如果外部修改后会受到影响  </span></span><br><span class="line">   <span class="keyword">return</span> s.counters  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// snapshot 不再受互斥锁保护  </span></span><br><span class="line"> <span class="comment">// 因此对 snapshot 的任何访问都将受到数据竞争的影响  </span></span><br><span class="line"> <span class="comment">// 影响 stats.counters  </span></span><br><span class="line"> snapshot := stats.Snapshot()</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">type</span> Stats <span class="keyword">struct</span> &#123;  </span><br><span class="line">   mu sync.Mutex  </span><br><span class="line"> ​  </span><br><span class="line">   counters <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Stats)</span></span> Snapshot() <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> &#123;  </span><br><span class="line">   s.mu.Lock()  </span><br><span class="line">   <span class="keyword">defer</span> s.mu.Unlock()  </span><br><span class="line">  <span class="comment">//单独make一个新的map返回  </span></span><br><span class="line">   result := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>, <span class="built_in">len</span>(s.counters))  </span><br><span class="line">   <span class="keyword">for</span> k, v := <span class="keyword">range</span> s.counters &#123;  </span><br><span class="line">     result[k] = v  </span><br><span class="line">   &#125;  </span><br><span class="line">   <span class="keyword">return</span> result  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// snapshot 现在是一个拷贝  </span></span><br><span class="line"> snapshot := stats.Snapshot()</span><br></pre></td></tr></table></figure><h3 id="1-3-Channel-的-size-要么是-1，要么是无缓冲的"><a href="#1-3-Channel-的-size-要么是-1，要么是无缓冲的" class="headerlink" title="1.3 Channel 的 size 要么是 1，要么是无缓冲的"></a>1.3 Channel 的 size 要么是 1，要么是无缓冲的</h3><p>channel 通常 size 应为 1 或是无缓冲的。默认情况下，channel 是无缓冲的，其 size 为零。任何其他尺寸都必须经过严格的审查。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bad  </span></span><br><span class="line"> <span class="comment">// 应该足以满足任何情况！  </span></span><br><span class="line"> c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">64</span>)  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="comment">// 大小：1  </span></span><br><span class="line"> c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">1</span>) <span class="comment">// 或者  </span></span><br><span class="line"> <span class="comment">// 无缓冲 channel，大小为 0  </span></span><br><span class="line"> c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br></pre></td></tr></table></figure><h3 id="4-枚举从-1-开始"><a href="#4-枚举从-1-开始" class="headerlink" title="4. 枚举从 1 开始"></a>4. 枚举从 1 开始</h3><p>由于变量的默认值为 0，因此<code>通常</code>应以非零值开头枚举。</p><blockquote><p>在某些情况下，使用零值是有意义的（枚举从零开始），例如，当零值是理想的默认行为时。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">type</span> Operation <span class="type">int</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">const</span> (  </span><br><span class="line">   Add Operation = <span class="literal">iota</span>  </span><br><span class="line">   Subtract  </span><br><span class="line">   Multiply  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// Add=0, Subtract=1, Multiply=2</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">type</span> Operation <span class="type">int</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">const</span> (  </span><br><span class="line">   Add Operation = <span class="literal">iota</span> + <span class="number">1</span>  </span><br><span class="line">   Subtract  </span><br><span class="line">   Multiply  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// Add=1, Subtract=2, Multiply=3</span></span><br></pre></td></tr></table></figure><h3 id="1-4-使用-time-处理时间"><a href="#1-4-使用-time-处理时间" class="headerlink" title="1.4 使用 time 处理时间"></a>1.4 使用 time 处理时间</h3><h4 id="1-4-1-使用-time-Time-表达瞬时时间"><a href="#1-4-1-使用-time-Time-表达瞬时时间" class="headerlink" title="1.4.1 使用 time.Time 表达瞬时时间"></a>1.4.1 使用 <code>time.Time</code> 表达瞬时时间</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">isActive</span><span class="params">(now, start, stop <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> start &lt;= now &amp;&amp; now &lt; stop  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">isActive</span><span class="params">(now, start, stop time.Time)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> (start.Before(now) || start.Equal(now)) &amp;&amp; now.Before(stop)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="1-4-2-使用-time-Duration-表达时间段"><a href="#1-4-2-使用-time-Duration-表达时间段" class="headerlink" title="1.4.2 使用 time.Duration 表达时间段"></a>1.4.2 使用 <code>time.Duration</code> 表达时间段</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">poll</span><span class="params">(delay <span class="type">int</span>)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">for</span> &#123;  </span><br><span class="line">     <span class="comment">// ...  </span></span><br><span class="line">     time.Sleep(time.Duration(delay) * time.Millisecond)  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> poll(<span class="number">10</span>) <span class="comment">// 是几秒钟还是几毫秒?</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">poll</span><span class="params">(delay time.Duration)</span></span> &#123;  </span><br><span class="line">   <span class="keyword">for</span> &#123;  </span><br><span class="line">     <span class="comment">// ...  </span></span><br><span class="line">     time.Sleep(delay)  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> poll(<span class="number">10</span>*time.Second)</span><br></pre></td></tr></table></figure><h4 id="1-4-3-对外部系统使用-time-Time-和-time-Duration"><a href="#1-4-3-对外部系统使用-time-Time-和-time-Duration" class="headerlink" title="1.4.3 对外部系统使用 time.Time 和 time.Duration"></a>1.4.3 对外部系统使用 <code>time.Time</code> 和 <code>time.Duration</code></h4><p>尽可能在与外部系统的交互中使用 <code>time.Duration</code> 和 <code>time.Time</code> 例如 :</p><ul><li><p>Command-line 标志: <a href="https://golang.org/pkg/flag/"><code>flag</code></a> 通过 <a href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code></p></li><li><p>JSON: <a href="https://golang.org/pkg/encoding/json/"><code>encoding/json</code></a> 通过其 <a href="https://golang.org/pkg/time/#Time.UnmarshalJSON"><code>UnmarshalJSON</code> method</a> 方法支持将 <code>time.Time</code> 编码为 <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> 字符串</p></li><li><p>SQL: <a href="https://golang.org/pkg/database/sql/"><code>database/sql</code></a> 支持将 <code>DATETIME</code> 或 <code>TIMESTAMP</code> 列转换为 <code>time.Time</code>，如果底层驱动程序支持则返回</p></li><li><p>YAML: <a href="https://godoc.org/gopkg.in/yaml.v2"><code>gopkg.in/yaml.v2</code></a> 支持将 <code>time.Time</code> 作为 <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> 字符串，并通过 <a href="https://golang.org/pkg/time/#ParseDuration"><code>time.ParseDuration</code></a> 支持 <code>time.Duration</code>。</p></li></ul><p>当不能在这些交互中使用 <code>time.Duration</code> 时，请使用 <code>int</code> 或 <code>float64</code>，<strong>并在字段名称中包含单位</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="comment">// &#123;&quot;interval&quot;: 2&#125;  </span></span><br><span class="line"> <span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;  </span><br><span class="line">   Interval <span class="type">int</span> <span class="string">`json:&quot;interval&quot;`</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="comment">// &#123;&quot;intervalMillis&quot;: 2000&#125;  </span></span><br><span class="line"> <span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;  </span><br><span class="line">   IntervalMillis <span class="type">int</span> <span class="string">`json:&quot;intervalMillis&quot;`</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-Error"><a href="#1-5-Error" class="headerlink" title="1.5 Error"></a>1.5 Error</h3><p>一个（函数/方法）调用失败时，有三种主要的错误传播方式：</p><ul><li><p>如果没有要添加的其他上下文，并且您想要维护原始错误类型，则返回原始错误。</p></li><li><p>添加上下文，使用 <a href="https://godoc.org/github.com/pkg/errors#Wrap"><code>&quot;pkg/errors&quot;.Wrap</code></a> 以便错误消息提供更多上下文 ,<a href="https://godoc.org/github.com/pkg/errors#Cause"><code>&quot;pkg/errors&quot;.Cause</code></a> 可用于提取原始错误。</p></li><li><p>如果调用者不需要检测或处理的特定错误情况，使用 <a href="https://golang.org/pkg/fmt/#Errorf"><code>fmt.Errorf</code></a>。</p></li></ul><p>建议在可能的地方添加上下文，以使您获得诸如“调用服务 foo：连接被拒绝”之类的更有用的错误，而不是诸如“连接被拒绝”之类的模糊错误。</p><p>在将上下文添加到返回的错误时，<strong>请避免使用“failed to”之类的短语</strong>以保持上下文简洁，这些短语会陈述明显的内容，并随着错误在堆栈中的渗透而逐渐堆积：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> s, err := store.New()  </span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">     <span class="keyword">return</span> fmt.Errorf(  </span><br><span class="line">         <span class="string">&quot;failed to create new store: %s&quot;</span>, err)  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//failed to x: failed to y: failed to create new store: the error</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> s, err := store.New()  </span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">     <span class="keyword">return</span> fmt.Errorf(  </span><br><span class="line">         <span class="string">&quot;new store: %s&quot;</span>, err)  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//x: y: new store: the error</span></span><br></pre></td></tr></table></figure><h3 id="1-6-处理类型断言失败"><a href="#1-6-处理类型断言失败" class="headerlink" title="1.6 处理类型断言失败"></a>1.6 处理类型断言失败</h3><p><a href="https://golang.org/ref/spec#Type_assertions">type assertion</a> 的单个返回值形式针对不正确的类型将产生 panic。因此，请始终使用“comma ok”的惯用法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> t := i.(<span class="type">string</span>)  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> t, ok := i.(<span class="type">string</span>)  </span><br><span class="line"> <span class="keyword">if</span> !ok &#123;  </span><br><span class="line">   <span class="comment">// 优雅地处理错误  </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-panic"><a href="#1-7-panic" class="headerlink" title="1.7 panic"></a>1.7 panic</h3><p>在生产环境中运行的代码必须避免出现 panic，程序初始化除外。</p><h3 id="1-8-避免可变全局变量"><a href="#1-8-避免可变全局变量" class="headerlink" title="1.8 避免可变全局变量"></a>1.8 避免可变全局变量</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="comment">// sign.go  </span></span><br><span class="line"> <span class="keyword">var</span> _timeNow = time.Now  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">sign</span><span class="params">(msg <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;  </span><br><span class="line">   <span class="comment">//这里使用了全局变量    </span></span><br><span class="line">   now := _timeNow()  </span><br><span class="line">   <span class="keyword">return</span> signWithTime(msg, now)  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="comment">// sign.go  </span></span><br><span class="line"> <span class="keyword">type</span> signer <span class="keyword">struct</span> &#123;  </span><br><span class="line">   now <span class="function"><span class="keyword">func</span><span class="params">()</span></span> time.Time  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">newSigner</span><span class="params">()</span></span> *signer &#123;  </span><br><span class="line">   <span class="keyword">return</span> &amp;signer&#123;  </span><br><span class="line">     now: time.Now,  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *signer)</span></span> Sign(msg <span class="type">string</span>) <span class="type">string</span> &#123;  </span><br><span class="line">   <span class="comment">// 通过将全局变量作为signer的依赖来传递  </span></span><br><span class="line">   now := s.now()  </span><br><span class="line">   <span class="keyword">return</span> signWithTime(msg, now)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="1-9-避免在公共结构中嵌入类型"><a href="#1-9-避免在公共结构中嵌入类型" class="headerlink" title="1.9 避免在公共结构中嵌入类型"></a>1.9 避免在公共结构中嵌入类型</h3><p>这些嵌入的类型泄漏实现细节、禁止类型演化和模糊的文档。</p><p>假设您使用共享的 <code>AbstractList</code> 实现了多种列表类型，请避免在具体的列表实现中嵌入 <code>AbstractList</code>。 相反，只需手动将方法写入具体的列表，该列表将委托给抽象列表。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">type</span> AbstractList <span class="keyword">struct</span> &#123;&#125;  </span><br><span class="line"> <span class="comment">// 添加将实体添加到列表中。  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span></span> Add(e Entity) &#123;  </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">// 移除从列表中移除实体。  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(l *AbstractList)</span></span> Remove(e Entity) &#123;  </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="comment">// ConcreteList 是一个实体列表。  </span></span><br><span class="line"> <span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;  </span><br><span class="line">    <span class="comment">//直接匿名嵌入不推荐   </span></span><br><span class="line">    <span class="comment">//AbstractList中添加新增方法都会直接影响到ConcreteList  </span></span><br><span class="line">   *AbstractList  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="comment">// ConcreteList 是一个实体列表。  </span></span><br><span class="line"> <span class="keyword">type</span> ConcreteList <span class="keyword">struct</span> &#123;  </span><br><span class="line">   <span class="comment">// 显示嵌入 同时添加了委托方法   </span></span><br><span class="line">   <span class="comment">// 这样AbstractList中添加新增方法都不会影响到ConcreteList  </span></span><br><span class="line">   list *AbstractList  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">// 添加将实体添加到列表中。  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span></span> Add(e Entity) &#123;  </span><br><span class="line">   <span class="keyword">return</span> l.list.Add(e)  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">// 移除从列表中移除实体。  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(l *ConcreteList)</span></span> Remove(e Entity) &#123;  </span><br><span class="line">   <span class="keyword">return</span> l.list.Remove(e)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="2-性能"><a href="#2-性能" class="headerlink" title="2 性能"></a>2 性能</h2><h3 id="2-1-优先使用-strconv-而不是-fmt"><a href="#2-1-优先使用-strconv-而不是-fmt" class="headerlink" title="2.1 优先使用 strconv 而不是 fmt"></a>2.1 优先使用 strconv 而不是 fmt</h3><p>将原语转换为字符串或从字符串转换时，<code>strconv</code>速度比<code>fmt</code>快。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;  </span><br><span class="line">   s := fmt.Sprint(rand.Int())  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">// BenchmarkFmtSprint-4    143 ns/op    2 allocs/op  </span></span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;  </span><br><span class="line">   s := strconv.Itoa(rand.Int())  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//BenchmarkStrconv-4    64.2 ns/op    1 allocs/op</span></span><br></pre></td></tr></table></figure><h3 id="2-2-避免字符串到字节的转换"><a href="#2-2-避免字符串到字节的转换" class="headerlink" title="2.2 避免字符串到字节的转换"></a>2.2 避免字符串到字节的转换</h3><p>不要反复从固定字符串创建字节 slice。相反，请执行一次转换并捕获结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;  </span><br><span class="line">   w.Write([]<span class="type">byte</span>(<span class="string">&quot;Hello world&quot;</span>))  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//BenchmarkBad-4   50000000   22.2 ns/op  </span></span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> data := []<span class="type">byte</span>(<span class="string">&quot;Hello world&quot;</span>)  </span><br><span class="line"> <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;  </span><br><span class="line">   w.Write(data)  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//BenchmarkGood-4  500000000   3.25 ns/op</span></span><br></pre></td></tr></table></figure><h3 id="2-3-尽量初始化时指定-Map-容量"><a href="#2-3-尽量初始化时指定-Map-容量" class="headerlink" title="2.3 尽量初始化时指定 Map 容量"></a>2.3 尽量初始化时指定 Map 容量</h3><p>在尽可能的情况下，在使用 <code>make()</code> 初始化的时候提供容量信息,这减少了在将元素添加到 map 时增长和分配的开销</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">make</span>(<span class="keyword">map</span>[T1]T2, hint)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]os.FileInfo)  </span><br><span class="line"> ​  </span><br><span class="line"> files, _ := ioutil.ReadDir(<span class="string">&quot;./files&quot;</span>)  </span><br><span class="line"> <span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;  </span><br><span class="line">     m[f.Name()] = f  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">// m 是在没有大小提示的情况下创建的； 在运行时可能会有更多分配。  </span></span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> files, _ := ioutil.ReadDir(<span class="string">&quot;./files&quot;</span>)  </span><br><span class="line"> ​  </span><br><span class="line"> m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]os.FileInfo, <span class="built_in">len</span>(files))  </span><br><span class="line"> <span class="keyword">for</span> _, f := <span class="keyword">range</span> files &#123;  </span><br><span class="line">     m[f.Name()] = f  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//m 是有大小提示创建的；在运行时可能会有更少的分配。</span></span><br></pre></td></tr></table></figure><h2 id="3-规范"><a href="#3-规范" class="headerlink" title="3 规范"></a>3 规范</h2><p>最重要的是，<strong>保持一致</strong>。</p><h3 id="3-1-相似的声明放在一组"><a href="#3-1-相似的声明放在一组" class="headerlink" title="3.1 相似的声明放在一组"></a>3.1 相似的声明放在一组</h3><p>导包应该分为两组：</p><ul><li>标准库</li><li>其他库</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">   <span class="string">&quot;os&quot;</span>  </span><br><span class="line">   <span class="string">&quot;go.uber.org/atomic&quot;</span>  </span><br><span class="line">   <span class="string">&quot;golang.org/x/sync/errgroup&quot;</span>  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">import</span> (  </span><br><span class="line">   <span class="string">&quot;fmt&quot;</span>  </span><br><span class="line">   <span class="string">&quot;os&quot;</span>  </span><br><span class="line">     </span><br><span class="line">   <span class="string">&quot;go.uber.org/atomic&quot;</span>  </span><br><span class="line">   <span class="string">&quot;golang.org/x/sync/errgroup&quot;</span>  </span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>常量、变量和类型声明更应该分组。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">const</span> a = <span class="number">1</span>  </span><br><span class="line"> <span class="keyword">const</span> b = <span class="number">2</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">var</span> a = <span class="number">1</span>  </span><br><span class="line"> <span class="keyword">var</span> b = <span class="number">2</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> Area <span class="type">float64</span>  </span><br><span class="line"> <span class="keyword">type</span> Volume <span class="type">float64</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">const</span> (  </span><br><span class="line">   a = <span class="number">1</span>  </span><br><span class="line">   b = <span class="number">2</span>  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">var</span> (  </span><br><span class="line">   a = <span class="number">1</span>  </span><br><span class="line">   b = <span class="number">2</span>  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> (  </span><br><span class="line">   Area <span class="type">float64</span>  </span><br><span class="line">   Volume <span class="type">float64</span>  </span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>仅将相关的声明放在一组。不要将不相关的声明放在一组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">type</span> Operation <span class="type">int</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">const</span> (  </span><br><span class="line">   Add Operation = <span class="literal">iota</span> + <span class="number">1</span>  </span><br><span class="line">   Subtract  </span><br><span class="line">   Multiply  </span><br><span class="line">   ENV_VAR = <span class="string">&quot;MY_ENV&quot;</span> <span class="comment">//这个很明显不是一组的 不应该放一起  </span></span><br><span class="line"> )</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">type</span> Operation <span class="type">int</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">const</span> (  </span><br><span class="line">   Add Operation = <span class="literal">iota</span> + <span class="number">1</span>  </span><br><span class="line">   Subtract  </span><br><span class="line">   Multiply  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">const</span> ENV_VAR = <span class="string">&quot;MY_ENV&quot;</span></span><br></pre></td></tr></table></figure><h3 id="3-2-包名"><a href="#3-2-包名" class="headerlink" title="3.2 包名"></a>3.2 包名</h3><p>当命名包时，请按下面规则选择一个名称：</p><ul><li>全部小写。没有大写或下划线。</li><li>大多数使用命名导入的情况下，不需要重命名。</li><li>简短而简洁。请记住，在每个使用的地方都完整标识了该名称。</li><li>不用复数。例如<code>net/url</code>，而不是<code>net/urls</code>。</li><li><p>不要用“common”，“util”，“shared”或“lib”。这些是不好的，信息量不足的名称。</p><h3 id="3-3-函数分组与顺序"><a href="#3-3-函数分组与顺序" class="headerlink" title="3.3 函数分组与顺序"></a>3.3 函数分组与顺序</h3></li><li><p>函数应按粗略的调用顺序排序。</p></li><li>同一文件中的函数应按接收者分组。</li></ul><p>因此，导出的函数应先出现在文件中，放在<code>struct</code>, <code>const</code>, <code>var</code>定义的后面。<br>在定义类型之后，但在接收者的其余方法之前，可能会出现一个 <code>newXYZ()</code>/<code>NewXYZ()</code><br>由于函数是按接收者分组的，因此普通工具函数应在文件末尾出现。</p><h3 id="3-4-减少嵌套"><a href="#3-4-减少嵌套" class="headerlink" title="3.4 减少嵌套"></a>3.4 减少嵌套</h3><p>代码应通过<strong>尽可能先处理错误情况/特殊情况并尽早返回或继续循环</strong>来减少嵌套。减少嵌套多个级别的代码的代码量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;  </span><br><span class="line">   <span class="keyword">if</span> v.F1 == <span class="number">1</span> &#123;  </span><br><span class="line">     v = process(v)  </span><br><span class="line">     <span class="keyword">if</span> err := v.Call(); err == <span class="literal">nil</span> &#123;  </span><br><span class="line">       v.Send()  </span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">       <span class="keyword">return</span> err  </span><br><span class="line">     &#125;  </span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">     log.Printf(<span class="string">&quot;Invalid v: %v&quot;</span>, v)  </span><br><span class="line">   &#125;  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">for</span> _, v := <span class="keyword">range</span> data &#123;  </span><br><span class="line">   <span class="keyword">if</span> v.F1 != <span class="number">1</span> &#123;  </span><br><span class="line">     log.Printf(<span class="string">&quot;Invalid v: %v&quot;</span>, v)  </span><br><span class="line">     <span class="keyword">continue</span>  </span><br><span class="line">   &#125;  </span><br><span class="line"> ​  </span><br><span class="line">   v = process(v)  </span><br><span class="line">   <span class="keyword">if</span> err := v.Call(); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">     <span class="keyword">return</span> err  </span><br><span class="line">   &#125;  </span><br><span class="line">   v.Send()  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-不必要的-else"><a href="#3-5-不必要的-else" class="headerlink" title="3.5 不必要的 else"></a>3.5 不必要的 else</h3><p>如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">var</span> a <span class="type">int</span>  </span><br><span class="line"> <span class="keyword">if</span> b &#123;  </span><br><span class="line">   a = <span class="number">100</span>  </span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">   a = <span class="number">10</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> a := <span class="number">10</span>  </span><br><span class="line"> <span class="keyword">if</span> b &#123;  </span><br><span class="line">   a = <span class="number">100</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-顶层变量声明"><a href="#3-6-顶层变量声明" class="headerlink" title="3.6 顶层变量声明"></a>3.6 顶层变量声明</h3><p>在顶层，使用标准<code>var</code>关键字。请勿指定类型，除非它与表达式的类型不同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">var</span> _s <span class="type">string</span> = F()  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">var</span> _s = F()  </span><br><span class="line"> <span class="comment">// 由于 F 已经明确了返回一个字符串类型，因此我们没有必要显式指定_s 的类型  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;A&quot;</span> &#125;</span><br></pre></td></tr></table></figure><p>如果表达式的类型与所需的类型不完全匹配，请指定类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">type</span> myError <span class="keyword">struct</span>&#123;&#125;  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(myError)</span></span> Error() <span class="type">string</span> &#123; <span class="keyword">return</span> <span class="string">&quot;error&quot;</span> &#125;  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">F</span><span class="params">()</span></span> myError &#123; <span class="keyword">return</span> myError&#123;&#125; &#125;  </span><br><span class="line"> <span class="keyword">var</span> _e <span class="type">error</span> = F()  </span><br><span class="line"> <span class="comment">// F 返回一个 myError 类型的实例，但是我们要 error 类型</span></span><br></pre></td></tr></table></figure><h3 id="3-7-对于未导出的顶层常量和变量，使用-作为前缀"><a href="#3-7-对于未导出的顶层常量和变量，使用-作为前缀" class="headerlink" title="3.7 对于未导出的顶层常量和变量，使用_作为前缀"></a>3.7 对于未导出的顶层常量和变量，使用<code>_</code>作为前缀</h3><p>在未导出的顶级<code>vars</code>和<code>consts</code>， 前面加上前缀_，以使它们在使用时明确表示它们是全局符号。</p><blockquote><p>例外：未导出的错误值，应以<code>err</code>开头。</p></blockquote><p>基本依据：顶级变量和常量具有包范围作用域。使用通用名称可能很容易在其他文件中意外使用错误的值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="comment">// foo.go  </span></span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">const</span> (  </span><br><span class="line">   defaultPort = <span class="number">8080</span>  </span><br><span class="line">   defaultUser = <span class="string">&quot;user&quot;</span>  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// bar.go  </span></span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Bar</span><span class="params">()</span></span> &#123;  </span><br><span class="line">   defaultPort := <span class="number">9090</span>  </span><br><span class="line">   ...  </span><br><span class="line">   fmt.Println(<span class="string">&quot;Default port&quot;</span>, defaultPort)  </span><br><span class="line"> ​  </span><br><span class="line">   <span class="comment">// We will not see a compile error if the first line of  </span></span><br><span class="line">   <span class="comment">// Bar() is deleted.  </span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="comment">// foo.go  </span></span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">const</span> (  </span><br><span class="line">   _defaultPort = <span class="number">8080</span>  </span><br><span class="line">   _defaultUser = <span class="string">&quot;user&quot;</span>  </span><br><span class="line"> )</span><br></pre></td></tr></table></figure><h3 id="3-8-结构体中的嵌入"><a href="#3-8-结构体中的嵌入" class="headerlink" title="3.8 结构体中的嵌入"></a>3.8 结构体中的嵌入</h3><p>嵌入式类型（例如 mutex）应位于结构体内的字段列表的顶部，并且必须有一个空行将嵌入式字段与常规字段分隔开。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;  </span><br><span class="line">   version <span class="type">int</span>  </span><br><span class="line">   http.Client  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;  </span><br><span class="line">   http.Client  </span><br><span class="line"> ​  </span><br><span class="line">   version <span class="type">int</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-使用字段名初始化结构体"><a href="#3-9-使用字段名初始化结构体" class="headerlink" title="3.9 使用字段名初始化结构体"></a>3.9 使用字段名初始化结构体</h3><p>初始化结构体时，几乎始终应该指定字段名称。现在由 <a href="https://golang.org/cmd/vet/"><code>go vet</code></a> 强制执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> k := User&#123;<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>, <span class="literal">true</span>&#125;  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> k := User&#123;  </span><br><span class="line">     FirstName: <span class="string">&quot;John&quot;</span>,  </span><br><span class="line">     LastName: <span class="string">&quot;Doe&quot;</span>,  </span><br><span class="line">     Admin: <span class="literal">true</span>,  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>例外：如果有 3 个或更少的字段，则可以在测试表中省略字段名称。</p></blockquote><h3 id="3-10-本地变量声明"><a href="#3-10-本地变量声明" class="headerlink" title="3.10 本地变量声明"></a>3.10 本地变量声明</h3><p>如果将变量明确设置为某个值，则应使用短变量声明形式 (<code>:=</code>)。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">var</span> s = <span class="string">&quot;foo&quot;</span>  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> s := <span class="string">&quot;foo&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p>但是，在某些情况下，<code>var</code> 使用关键字时默认值会更清晰。例如，声明空切片。</p></blockquote><h3 id="3-11-nil-是一个有效的-slice"><a href="#3-11-nil-是一个有效的-slice" class="headerlink" title="3.11 nil 是一个有效的 slice"></a>3.11 nil 是一个有效的 slice</h3><p><code>nil</code> 是一个有效的长度为 0 的 slice，这意味着，</p><ul><li>您不应明确返回长度为零的切片。应该返回<code>nil</code> 来代替。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="keyword">if</span> x == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> []<span class="type">int</span>&#123;&#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">if</span> x == <span class="string">&quot;&quot;</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>要检查切片是否为空，请始终使用<code>len(s) == 0</code>。而非 <code>nil</code>。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> s == <span class="literal">nil</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">isEmpty</span><span class="params">(s []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;  </span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">len</span>(s) == <span class="number">0</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>零值切片（用<code>var</code>声明的切片）可立即使用，无需调用<code>make()</code>创建。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="comment">// 这里没必要make  </span></span><br><span class="line"> nums := []<span class="type">int</span>&#123;&#125;  </span><br><span class="line"> <span class="comment">// or, nums := make([]int)  </span></span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">if</span> add1 &#123;  </span><br><span class="line">   nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">if</span> add2 &#123;  </span><br><span class="line">   nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">var</span> nums []<span class="type">int</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">if</span> add1 &#123;  </span><br><span class="line">   nums = <span class="built_in">append</span>(nums, <span class="number">1</span>)  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">if</span> add2 &#123;  </span><br><span class="line">   nums = <span class="built_in">append</span>(nums, <span class="number">2</span>)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-12-缩小变量作用域"><a href="#3-12-缩小变量作用域" class="headerlink" title="3.12 缩小变量作用域"></a>3.12 缩小变量作用域</h3><p>如果有可能，尽量缩小变量作用范围。除非它与 <a href="https://github.com/xxjwxc/uber_go_guide_cn#%E5%87%8F%E5%B0%91%E5%B5%8C%E5%A5%97">减少嵌套</a>的规则冲突。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> err := ioutil.WriteFile(name, data, <span class="number">0644</span>)  </span><br><span class="line"> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;  </span><br><span class="line">  <span class="keyword">return</span> err  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="keyword">if</span> err := ioutil.WriteFile(name, data, <span class="number">0644</span>); err != <span class="literal">nil</span> &#123;  </span><br><span class="line">  <span class="keyword">return</span> err  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-13-避免参数语义不明确-Avoid-Naked-Parameters"><a href="#3-13-避免参数语义不明确-Avoid-Naked-Parameters" class="headerlink" title="3.13 避免参数语义不明确(Avoid Naked Parameters)"></a>3.13 避免参数语义不明确(Avoid Naked Parameters)</h3><p>函数调用中的<code>意义不明确的参数</code>可能会损害可读性。当参数名称的含义不明显时，请为参数添加 C 样式注释 (<code>/* ... */</code>)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="comment">// func printInfo(name string, isLocal, done bool)  </span></span><br><span class="line"> printInfo(<span class="string">&quot;foo&quot;</span>, <span class="literal">true</span>, <span class="literal">true</span>)  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="comment">// func printInfo(name string, isLocal, done bool)  </span></span><br><span class="line"> printInfo(<span class="string">&quot;foo&quot;</span>, <span class="literal">true</span> <span class="comment">/* isLocal */</span>, <span class="literal">true</span> <span class="comment">/* done */</span>)</span><br></pre></td></tr></table></figure><p>对于上面的示例代码，还有一种更好的处理方式是将上面的 <code>bool</code> 类型换成自定义类型。将来，该参数可以支持不仅仅局限于两个状态（true/false）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">type</span> Region <span class="type">int</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">const</span> (  </span><br><span class="line">   UnknownRegion Region = <span class="literal">iota</span>  </span><br><span class="line">   Local  </span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> Status <span class="type">int</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">const</span> (  </span><br><span class="line">   StatusReady Status= <span class="literal">iota</span> + <span class="number">1</span>  </span><br><span class="line">   StatusDone  </span><br><span class="line">   <span class="comment">// Maybe we will have a StatusInProgress in the future.  </span></span><br><span class="line"> )  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">printInfo</span><span class="params">(name <span class="type">string</span>, region Region, status Status)</span></span></span><br></pre></td></tr></table></figure><h3 id="3-14-使用原始字符串字面值，避免转义"><a href="#3-14-使用原始字符串字面值，避免转义" class="headerlink" title="3.14 使用原始字符串字面值，避免转义"></a>3.14 使用原始字符串字面值，避免转义</h3><p>Go 支持使用 <a href="https://golang.org/ref/spec#raw_string_lit">原始字符串字面值</a>，也就是 “ ` “ 来表示原生字符串，在需要转义的场景下，我们应该尽量使用这种方案来替换。</p><p>可以跨越多行并包含引号。使用这些字符串可以避免更难阅读的手工转义的字符串。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> wantError := <span class="string">&quot;unknown name:\&quot;test\&quot;&quot;</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> wantError := <span class="string">`unknown error:&quot;test&quot;`</span></span><br></pre></td></tr></table></figure><h2 id="4-编程模式"><a href="#4-编程模式" class="headerlink" title="4 编程模式"></a>4 编程模式</h2><h3 id="4-1-表驱动测试"><a href="#4-1-表驱动测试" class="headerlink" title="4.1 表驱动测试"></a>4.1 表驱动测试</h3><p>当测试逻辑是重复的时候，通过 <a href="https://blog.golang.org/subtests">subtests</a> 使用 table 驱动的方式编写 case 代码看上去会更简洁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//Bad  </span></span><br><span class="line"> <span class="comment">// func TestSplitHostPort(t *testing.T)  </span></span><br><span class="line"> ​  </span><br><span class="line"> host, port, err := net.SplitHostPort(<span class="string">&quot;192.0.2.0:8000&quot;</span>)  </span><br><span class="line"> require.NoError(t, err)  </span><br><span class="line"> assert.Equal(t, <span class="string">&quot;192.0.2.0&quot;</span>, host)  </span><br><span class="line"> assert.Equal(t, <span class="string">&quot;8000&quot;</span>, port)  </span><br><span class="line"> ​  </span><br><span class="line"> host, port, err = net.SplitHostPort(<span class="string">&quot;192.0.2.0:http&quot;</span>)  </span><br><span class="line"> require.NoError(t, err)  </span><br><span class="line"> assert.Equal(t, <span class="string">&quot;192.0.2.0&quot;</span>, host)  </span><br><span class="line"> assert.Equal(t, <span class="string">&quot;http&quot;</span>, port)  </span><br><span class="line"> ​  </span><br><span class="line"> host, port, err = net.SplitHostPort(<span class="string">&quot;:8000&quot;</span>)  </span><br><span class="line"> require.NoError(t, err)  </span><br><span class="line"> assert.Equal(t, <span class="string">&quot;&quot;</span>, host)  </span><br><span class="line"> assert.Equal(t, <span class="string">&quot;8000&quot;</span>, port)  </span><br><span class="line"> ​  </span><br><span class="line"> host, port, err = net.SplitHostPort(<span class="string">&quot;1:8&quot;</span>)  </span><br><span class="line"> require.NoError(t, err)  </span><br><span class="line"> assert.Equal(t, <span class="string">&quot;1&quot;</span>, host)  </span><br><span class="line"> assert.Equal(t, <span class="string">&quot;8&quot;</span>, port)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="comment">// func TestSplitHostPort(t *testing.T)  </span></span><br><span class="line"> ​  </span><br><span class="line"> tests := []<span class="keyword">struct</span>&#123;  </span><br><span class="line">   give     <span class="type">string</span>  </span><br><span class="line">   wantHost <span class="type">string</span>  </span><br><span class="line">   wantPort <span class="type">string</span>  </span><br><span class="line"> &#125;&#123;  </span><br><span class="line">   &#123;  </span><br><span class="line">     give:     <span class="string">&quot;192.0.2.0:8000&quot;</span>,  </span><br><span class="line">     wantHost: <span class="string">&quot;192.0.2.0&quot;</span>,  </span><br><span class="line">     wantPort: <span class="string">&quot;8000&quot;</span>,  </span><br><span class="line">   &#125;,  </span><br><span class="line">   &#123;  </span><br><span class="line">     give:     <span class="string">&quot;192.0.2.0:http&quot;</span>,  </span><br><span class="line">     wantHost: <span class="string">&quot;192.0.2.0&quot;</span>,  </span><br><span class="line">     wantPort: <span class="string">&quot;http&quot;</span>,  </span><br><span class="line">   &#125;,  </span><br><span class="line">   &#123;  </span><br><span class="line">     give:     <span class="string">&quot;:8000&quot;</span>,  </span><br><span class="line">     wantHost: <span class="string">&quot;&quot;</span>,  </span><br><span class="line">     wantPort: <span class="string">&quot;8000&quot;</span>,  </span><br><span class="line">   &#125;,  </span><br><span class="line">   &#123;  </span><br><span class="line">     give:     <span class="string">&quot;1:8&quot;</span>,  </span><br><span class="line">     wantHost: <span class="string">&quot;1&quot;</span>,  </span><br><span class="line">     wantPort: <span class="string">&quot;8&quot;</span>,  </span><br><span class="line">   &#125;,  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;  </span><br><span class="line">   t.Run(tt.give, <span class="function"><span class="keyword">func</span><span class="params">(t *testing.T)</span></span> &#123;  </span><br><span class="line">     host, port, err := net.SplitHostPort(tt.give)  </span><br><span class="line">     require.NoError(t, err)  </span><br><span class="line">     assert.Equal(t, tt.wantHost, host)  </span><br><span class="line">     assert.Equal(t, tt.wantPort, port)  </span><br><span class="line">   &#125;)  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们遵循这样的约定：将结构体切片称为<code>tests</code>。 每个测试用例称为<code>tt</code>。此外，我们鼓励使用<code>give</code>和<code>want</code>前缀说明每个测试用例的输入和输出值。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> tests := []<span class="keyword">struct</span>&#123;  </span><br><span class="line">   give     <span class="type">string</span>  </span><br><span class="line">   wantHost <span class="type">string</span>  </span><br><span class="line">   wantPort <span class="type">string</span>  </span><br><span class="line"> &#125;&#123;  </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">for</span> _, tt := <span class="keyword">range</span> tests &#123;  </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-功能选项"><a href="#4-2-功能选项" class="headerlink" title="4.2 功能选项"></a>4.2 功能选项</h3><p>功能选项是一种模式，您可以在其中声明一个不透明 Option 类型，该类型在某些内部结构中记录信息。您接受这些选项的可变编号，并根据内部结构上的选项记录的全部信息采取行动。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Bad  </span></span><br><span class="line"> <span class="comment">// package db  </span></span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">   addr <span class="type">string</span>,  </span></span></span><br><span class="line"><span class="params"><span class="function">   cache <span class="type">bool</span>,  </span></span></span><br><span class="line"><span class="params"><span class="function">   logger *zap.Logger  </span></span></span><br><span class="line"><span class="params"><span class="function"> )</span></span> (*Connection, <span class="type">error</span>) &#123;  </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">//使用  </span></span><br><span class="line"> <span class="comment">//必须始终提供缓存和记录器参数，即使用户希望使用默认值。  </span></span><br><span class="line"> ​  </span><br><span class="line"> db.Open(addr, db.DefaultCache, zap.NewNop())  </span><br><span class="line"> db.Open(addr, db.DefaultCache, log)  </span><br><span class="line"> db.Open(addr, <span class="literal">false</span> <span class="comment">/* cache */</span>, zap.NewNop())  </span><br><span class="line"> db.Open(addr, <span class="literal">false</span> <span class="comment">/* cache */</span>, log)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Good  </span></span><br><span class="line"> <span class="comment">// package db  </span></span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;  </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">WithCache</span><span class="params">(c <span class="type">bool</span>)</span></span> Option &#123;  </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">WithLogger</span><span class="params">(log *zap.Logger)</span></span> Option &#123;  </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// Open creates a connection.  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">   addr <span class="type">string</span>,  </span></span></span><br><span class="line"><span class="params"><span class="function">   opts ...Option,  </span></span></span><br><span class="line"><span class="params"><span class="function"> )</span></span> (*Connection, <span class="type">error</span>) &#123;  </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">//使用  </span></span><br><span class="line"> <span class="comment">//只有在需要时才提供选项。  </span></span><br><span class="line"> ​  </span><br><span class="line"> db.Open(addr)  </span><br><span class="line"> db.Open(addr, db.WithLogger(log))  </span><br><span class="line"> db.Open(addr, db.WithCache(<span class="literal">false</span>))  </span><br><span class="line"> db.Open(  </span><br><span class="line">   addr,  </span><br><span class="line">   db.WithCache(<span class="literal">false</span>),  </span><br><span class="line">   db.WithLogger(log),  </span><br><span class="line"> )</span><br></pre></td></tr></table></figure><p>我们建议实现此模式的方法是使用一个 <code>Option</code> 接口，该接口保存一个未导出的方法，在一个未导出的 <code>options</code> 结构上记录选项。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">type</span> options <span class="keyword">struct</span> &#123;  </span><br><span class="line">   cache  <span class="type">bool</span>  </span><br><span class="line">   logger *zap.Logger  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> Option <span class="keyword">interface</span> &#123;  </span><br><span class="line">   apply(*options)  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> cacheOption <span class="type">bool</span>  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(c cacheOption)</span></span> apply(opts *options) &#123;  </span><br><span class="line">   opts.cache = <span class="type">bool</span>(c)  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">WithCache</span><span class="params">(c <span class="type">bool</span>)</span></span> Option &#123;  </span><br><span class="line">   <span class="keyword">return</span> cacheOption(c)  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="keyword">type</span> loggerOption <span class="keyword">struct</span> &#123;  </span><br><span class="line">   Log *zap.Logger  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(l loggerOption)</span></span> apply(opts *options) &#123;  </span><br><span class="line">   opts.logger = l.Log  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">WithLogger</span><span class="params">(log *zap.Logger)</span></span> Option &#123;  </span><br><span class="line">   <span class="keyword">return</span> loggerOption&#123;Log: log&#125;  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// Open creates a connection.  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">Open</span><span class="params">(  </span></span></span><br><span class="line"><span class="params"><span class="function">   addr <span class="type">string</span>,  </span></span></span><br><span class="line"><span class="params"><span class="function">   opts ...Option,  </span></span></span><br><span class="line"><span class="params"><span class="function"> )</span></span> (*Connection, <span class="type">error</span>) &#123;  </span><br><span class="line">   options := options&#123;  </span><br><span class="line">     cache:  defaultCache,  </span><br><span class="line">     logger: zap.NewNop(),  </span><br><span class="line">   &#125;  </span><br><span class="line"> ​  </span><br><span class="line">   <span class="keyword">for</span> _, o := <span class="keyword">range</span> opts &#123;  </span><br><span class="line">     o.apply(&amp;options)  </span><br><span class="line">   &#125;  </span><br><span class="line"> ​  </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
          <category> 代码规范 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Golang Channel实现互斥锁</title>
      <link href="/2021/08/17/Golang/4%20%E5%85%B6%E4%BB%96/Channel%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E9%94%81/"/>
      <url>/2021/08/17/Golang/4%20%E5%85%B6%E4%BB%96/Channel%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5%E9%94%81/</url>
      
        <content type="html"><![CDATA[<blockquote><p>使用长度为1的有缓冲channel实现互斥锁</p></blockquote><span id="more"></span><pre><code class="lang-go">package mainimport (    &quot;sync&quot;)// Lock 锁结构type Lock struct &#123;    c chan struct&#123;&#125;&#125;// NewLock 生成一个锁func NewLock() Lock &#123;    var l Lock    l.c = make(chan struct&#123;&#125;, 1)    l.c &lt;- struct&#123;&#125;&#123;&#125; // 放入一把锁用于获取    return l&#125;// TryLock 尝试加锁,成功返回true,失败返回false，不会阻塞等待func (l Lock) TryLock() bool &#123;    var lockResult bool    select &#123;    case &lt;-l.c:        lockResult = true    default:    &#125;    return lockResult&#125;// 加锁,会阻塞竞争func (l Lock) Lock() &#123;    &lt;-l.c&#125;// 解锁,重复解锁会阻塞func (l Lock) Unlock() &#123;    l.c &lt;- struct&#123;&#125;&#123;&#125;&#125;var counter intfunc main() &#123;    l := NewLock()    var wg sync.WaitGroup    for i := 0; i &lt; 10; i++ &#123;        wg.Add(1)        go func() &#123;            defer wg.Done()            if !l.TryLock() &#123;                println(&quot;lock failed&quot;)                return            &#125;            counter++            println(&quot;try lock counter &quot;, counter)            l.Unlock()        &#125;()    &#125;    for i := 0; i &lt; 10; i++ &#123;        wg.Add(1)        go func() &#123;            defer wg.Done()            l.Lock()            counter++            println(&quot;lock counter &quot;, counter)            l.Unlock()        &#125;()    &#125;    wg.Wait()&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Golang Concatenate Strings</title>
      <link href="/2021/08/17/Golang/4%20%E5%85%B6%E4%BB%96/Concatenate%20Strings/"/>
      <url>/2021/08/17/Golang/4%20%E5%85%B6%E4%BB%96/Concatenate%20Strings/</url>
      
        <content type="html"><![CDATA[<blockquote><p>How to Efficiently Concatenate Strings in Go</p></blockquote><span id="more"></span><h2 id="1-种拼接方式"><a href="#1-种拼接方式" class="headerlink" title="1 种拼接方式"></a>1 种拼接方式</h2><h3 id="1-1-String-Concat"><a href="#1-1-String-Concat" class="headerlink" title="1.1 String Concat"></a>1.1 String Concat</h3><p>Str += “hello-world”</p><h3 id="1-2-String-Sprintf"><a href="#1-2-String-Sprintf" class="headerlink" title="1.2 String Sprintf"></a>1.2 String Sprintf</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Str = fmt.Sprintf (<span class="string">&quot;%s%s&quot;</span>, str, <span class="string">&quot;hello-world&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="1-3-String-Join"><a href="#1-3-String-Join" class="headerlink" title="1.3 String Join"></a>1.3 String Join</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Str = strings.Join ([]<span class="type">string</span>&#123;str, <span class="string">&quot;hello-world&quot;</span>&#125;, <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="1-4-Buffer-Write"><a href="#1-4-Buffer-Write" class="headerlink" title="1.4 Buffer Write"></a>1.4 Buffer Write</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Buf := <span class="built_in">new</span> (bytes. Buffer)</span><br><span class="line">Buf.WriteString (<span class="string">&quot;hello-world&quot;</span>)</span><br><span class="line">Str := buf.String ()</span><br></pre></td></tr></table></figure><h3 id="1-5-Bytes-Append"><a href="#1-5-Bytes-Append" class="headerlink" title="1.5 Bytes Append"></a>1.5 Bytes Append</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Var b []<span class="type">byte</span></span><br><span class="line">S := <span class="string">&quot;hello-world&quot;</span></span><br><span class="line">b = <span class="built_in">append</span> (b, s...)</span><br><span class="line">Str := <span class="type">string</span> (b)</span><br></pre></td></tr></table></figure><h3 id="1-6-String-Copy"><a href="#1-6-String-Copy" class="headerlink" title="1.6 String Copy"></a>1.6 String Copy</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Ts := <span class="string">&quot;hello-world&quot;</span></span><br><span class="line">N := <span class="number">5</span></span><br><span class="line">Tsl := <span class="built_in">len</span> (ts) * n</span><br><span class="line">Bs := <span class="built_in">make</span> ([]<span class="type">byte</span>, tsl)</span><br><span class="line">Bl := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">For bl &lt; tsl &#123;</span><br><span class="line">    Bl += <span class="built_in">copy</span> (bs[bl:], ts)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Str := <span class="type">string</span> (bs)</span><br></pre></td></tr></table></figure><h3 id="1-7-String-Builder"><a href="#1-7-String-Builder" class="headerlink" title="1.7 String Builder"></a>1.7 String Builder</h3><p>From Go 1.10 there is a strings. Builder type</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Var builder strings. Builder</span><br><span class="line">Builder.WriteString (<span class="string">&quot;hello-world&quot;</span>)</span><br><span class="line">Str := builder.String ()</span><br></pre></td></tr></table></figure><h2 id="2-Benchmark"><a href="#2-Benchmark" class="headerlink" title="2 Benchmark"></a>2 Benchmark</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br></pre></td><td class="code"><pre><span class="line">Package main</span><br><span class="line"></span><br><span class="line">Import (</span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Const (</span><br><span class="line">    Sss = <span class="string">&quot;xfoasneobfasieongasbg&quot;</span></span><br><span class="line">    Cnt = <span class="number">10000</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Var (</span><br><span class="line">    Bbb      = []<span class="type">byte</span> (sss)</span><br><span class="line">    Expected = strings.Repeat (sss, cnt)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Func BenchmarkCopyPreAllocate (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Bs := <span class="built_in">make</span> ([]<span class="type">byte</span>, cnt*<span class="built_in">len</span> (sss))</span><br><span class="line">        Bl := <span class="number">0</span></span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Bl += <span class="built_in">copy</span> (bs[bl:], sss)</span><br><span class="line">        &#125;</span><br><span class="line">        Result = <span class="type">string</span> (bs)</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkAppendPreAllocate (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Data := <span class="built_in">make</span> ([]<span class="type">byte</span>, <span class="number">0</span>, cnt*<span class="built_in">len</span> (sss))</span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Data = <span class="built_in">append</span> (data, sss...)</span><br><span class="line">        &#125;</span><br><span class="line">        Result = <span class="type">string</span> (data)</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkBufferPreAllocate (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Buf := bytes.NewBuffer (<span class="built_in">make</span> ([]<span class="type">byte</span>, <span class="number">0</span>, cnt*<span class="built_in">len</span> (sss)))</span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Buf.WriteString (sss)</span><br><span class="line">        &#125;</span><br><span class="line">        Result = buf.String ()</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkCopy (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Data := <span class="built_in">make</span> ([]<span class="type">byte</span>, <span class="number">0</span>, <span class="number">64</span>) <span class="comment">// same size as bootstrap array of bytes. Buffer</span></span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Off := <span class="built_in">len</span> (data)</span><br><span class="line">            If off+<span class="built_in">len</span> (sss) &gt; <span class="built_in">cap</span> (data) &#123;</span><br><span class="line">                Temp := <span class="built_in">make</span> ([]<span class="type">byte</span>, <span class="number">2</span>*<span class="built_in">cap</span> (data)+<span class="built_in">len</span> (sss))</span><br><span class="line">                Copy (temp, data)</span><br><span class="line">                Data = temp</span><br><span class="line">            &#125;</span><br><span class="line">            Data = data[<span class="number">0</span> : off+<span class="built_in">len</span> (sss)]</span><br><span class="line">            Copy (data[off:], sss)</span><br><span class="line">        &#125;</span><br><span class="line">        Result = <span class="type">string</span> (data)</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkCopyX (b *testing. B) &#123;</span><br><span class="line">    bs := <span class="built_in">make</span> ([]<span class="type">byte</span>, b.N)</span><br><span class="line">    Bl := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        bl += <span class="built_in">copy</span>(bs[bl:], <span class="string">&quot;x&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s := strings.Repeat(<span class="string">&quot;x&quot;</span>, b.N); <span class="type">string</span>(bs) != s &#123;</span><br><span class="line">        b.Errorf(<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span>(bs), s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkAppend (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Data := <span class="built_in">make</span> ([]<span class="type">byte</span>, <span class="number">0</span>, <span class="number">64</span>)</span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Data = <span class="built_in">append</span> (data, sss...)</span><br><span class="line">        &#125;</span><br><span class="line">        Result = <span class="type">string</span> (data)</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkBufferWrite (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Var buf bytes. Buffer</span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Buf.Write (bbb)</span><br><span class="line">        &#125;</span><br><span class="line">        Result = buf.String ()</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkBufferWriteString (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Var buf bytes. Buffer</span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Buf.WriteString (sss)</span><br><span class="line">        &#125;</span><br><span class="line">        Result = buf.String ()</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkConcatString (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Var str <span class="type">string</span></span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Str += sss</span><br><span class="line">        &#125;</span><br><span class="line">        Result = str</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkConcat (b *testing. B) &#123;</span><br><span class="line">    Var str <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Str += <span class="string">&quot;x&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s := strings.Repeat(<span class="string">&quot;x&quot;</span>, b.N); str != s &#123;</span><br><span class="line">        b.Errorf(<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, str, s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkBuffer (b *testing. B) &#123;</span><br><span class="line">    Var buffer bytes. Buffer</span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Buffer.WriteString (<span class="string">&quot;x&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s := strings.Repeat(<span class="string">&quot;x&quot;</span>, b.N); buffer.String() != s &#123;</span><br><span class="line">        b.Errorf(<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, buffer.String(), s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Go 1.10</span></span><br><span class="line">Func BenchmarkStringBuilderX (b *testing. B) &#123;</span><br><span class="line">    Var strBuilder strings. Builder</span><br><span class="line"></span><br><span class="line">    b.ResetTimer()</span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        strBuilder.WriteString(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> s := strings.Repeat(<span class="string">&quot;x&quot;</span>, b.N); strBuilder.String() != s &#123;</span><br><span class="line">        b.Errorf(<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, strBuilder.String(), s)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkStringBuilder (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Var builder strings. Builder</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            builder.WriteString(sss)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = builder.String()</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer()</span><br><span class="line">    <span class="keyword">if</span> result != expected &#123;</span><br><span class="line">        b.Errorf(<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span>(result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkStringConcat (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Var str <span class="type">string</span></span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Str += sss</span><br><span class="line">        &#125;</span><br><span class="line">        Result = str</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkStringSprintf (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Var str <span class="type">string</span></span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Str = fmt.Sprintf (<span class="string">&quot;%s%s&quot;</span>, str, sss)</span><br><span class="line">        &#125;</span><br><span class="line">        Result = str</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkStringJoin (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Var str <span class="type">string</span></span><br><span class="line">        For i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            Str = strings.Join ([]<span class="type">string</span>&#123;str, sss&#125;, <span class="string">&quot;&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        Result = str</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer ()</span><br><span class="line">    If result != expected &#123;</span><br><span class="line">        b.Errorf (<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span> (result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkBytesAppend (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Var bbb []<span class="type">byte</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; cnt; i++ &#123;</span><br><span class="line">            bbb = <span class="built_in">append</span>(bbb, sss...)</span><br><span class="line">        &#125;</span><br><span class="line">        result = <span class="type">string</span>(bbb)</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer()</span><br><span class="line">    <span class="keyword">if</span> result != expected &#123;</span><br><span class="line">        b.Errorf(<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span>(result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Func BenchmarkStringCopy (b *testing. B) &#123;</span><br><span class="line">    Var result <span class="type">string</span></span><br><span class="line">    <span class="keyword">for</span> n := <span class="number">0</span>; n &lt; b.N; n++ &#123;</span><br><span class="line">        Tsl := <span class="built_in">len</span> (sss) * cnt</span><br><span class="line">        Bs := <span class="built_in">make</span> ([]<span class="type">byte</span>, tsl)</span><br><span class="line">        Bl := <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> bl &lt; tsl &#123;</span><br><span class="line">            bl += <span class="built_in">copy</span>(bs[bl:], sss)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = <span class="type">string</span>(bs)</span><br><span class="line">    &#125;</span><br><span class="line">    b.StopTimer()</span><br><span class="line">    <span class="keyword">if</span> result != expected &#123;</span><br><span class="line">        b.Errorf(<span class="string">&quot;unexpected result; got=%s, want=%s&quot;</span>, <span class="type">string</span>(result), expected)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test Results:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Go test -v strings_concat_benchmark_test. Go -bench=. -benchmem</span><br><span class="line">Goos: darwin</span><br><span class="line">Goarch: amd 64</span><br><span class="line">BenchmarkCopyPreAllocate-4          8043            125464 ns/op          425984 B/op          2 allocs/op</span><br><span class="line">BenchmarkAppendPreAllocate-4        9818            126881 ns/op          425985 B/op          2 allocs/op</span><br><span class="line">BenchmarkBufferPreAllocate-4        7656            161158 ns/op          425984 B/op          2 allocs/op</span><br><span class="line">BenchmarkCopy-4                     4903            250800 ns/op          929185 B/op         13 allocs/op</span><br><span class="line">BenchmarkCopyX-4                263460769                5.19 ns/op            0 B/op          0 allocs/op</span><br><span class="line">BenchmarkAppend-4                   3820            384086 ns/op         1333122 B/op         24 allocs/op</span><br><span class="line">BenchmarkBufferWrite-4              3626            299617 ns/op          929250 B/op         14 allocs/op</span><br><span class="line">BenchmarkBufferWriteString-4        4428            286061 ns/op          929249 B/op         14 allocs/op</span><br><span class="line">BenchmarkConcatString-4                5         210904237 ns/op        1086401044 B/op    10037 allocs/op</span><br><span class="line">BenchmarkConcat-4                1000000            118204 ns/op          503996 B/op          1 allocs/op</span><br><span class="line">BenchmarkBuffer-4               132420037                8.74 ns/op            2 B/op          0 allocs/op</span><br><span class="line">BenchmarkStringBuilderX-4       418325671                5.97 ns/op            6 B/op          0 allocs/op</span><br><span class="line">BenchmarkStringBuilder-4            3890            310115 ns/op         1120224 B/op         25 allocs/op</span><br><span class="line">BenchmarkStringConcat-4                5         229555747 ns/op        1086401641 B/op    10050 allocs/op</span><br><span class="line">BenchmarkStringSprintf-4               3         451219496 ns/op        2068371440 B/op    35040 allocs/op</span><br><span class="line">BenchmarkStringJoin-4                  4         281371101 ns/op        1086401946 B/op    10058 allocs/op</span><br><span class="line">BenchmarkBytesAppend-4              3406            406706 ns/op         1333218 B/op         26 allocs/op</span><br><span class="line">BenchmarkStringCopy-4               9100            133990 ns/op          425984 B/op          2 allocs/op</span><br><span class="line">PASS</span><br><span class="line">Ok      command-line-arguments  148.510 s</span><br></pre></td></tr></table></figure><h2 id="3-参考"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考</h2><ul><li><a href="https://stackoverflow.com/questions/1760757/how-to-efficiently-concatenate-strings-in-go">How to Efficiently Concatenate Strings in Go</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Golang Quic</title>
      <link href="/2021/08/17/Golang/4%20%E5%85%B6%E4%BB%96/Quic/"/>
      <url>/2021/08/17/Golang/4%20%E5%85%B6%E4%BB%96/Quic/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Quick UDP Internet Connection</p></blockquote><span id="more"></span><h2 id="1-QUIC-概述"><a href="#1-QUIC-概述" class="headerlink" title="1 QUIC 概述"></a>1 QUIC 概述</h2><p>QUIC（Quick UDP Internet Connection，快速 UDP 互联网连接协议）是一种以 UDP 为底层传输协议，支持加密、多路复用，工作在用户空间的的低延迟传输协议。</p><p>Quic 相比现在广泛应用的 http2+tcp+tls 协议有如下优势：</p><ol><li>减少了 TCP 三次握手及 TLS 握手时间。</li><li>改进的拥塞控制。</li><li>避免队头阻塞的多路复用。</li><li>连接迁移。</li><li>前向冗余纠错。</li></ol><h2 id="2-server"><a href="#2-server" class="headerlink" title="2 server"></a>2 server</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/rand&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/rsa&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/tls&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/x509&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/pem&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;math/big&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/lucas-clemente/quic-go&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> saddr = <span class="string">&quot;localhost:9999&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">listener, err := quic.ListenAddr(saddr, generateTLSConfig(), <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sess, err := listener.Accept(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">go</span> dealSession(sess)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dealSession</span><span class="params">(sess quic.Session)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;LocalAddr %s, RemoteAddr %s\n&quot;</span>,</span><br><span class="line">sess.LocalAddr().String(),</span><br><span class="line">sess.RemoteAddr().String())</span><br><span class="line">ctx, cancel := context.WithTimeout(context.Background(), <span class="number">3</span>*time.Second)</span><br><span class="line"><span class="keyword">defer</span> cancel()</span><br><span class="line">stream, err := sess.AcceptStream(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">//panic(err)</span></span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_, err = io.Copy(loggingWriter&#123;stream&#125;, stream)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;err &quot;</span>, err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> loggingWriter <span class="keyword">struct</span>&#123; io.Writer &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w loggingWriter)</span></span> Write(b []<span class="type">byte</span>) (<span class="type">int</span>, <span class="type">error</span>) &#123;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Server: Got &#x27;%s&#x27;\n&quot;</span>, <span class="type">string</span>(b))</span><br><span class="line"><span class="keyword">return</span> w.Writer.Write(b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Setup a bare-bones TLS config for the server</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">generateTLSConfig</span><span class="params">()</span></span> *tls.Config &#123;</span><br><span class="line">key, err := rsa.GenerateKey(rand.Reader, <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">template := x509.Certificate&#123;SerialNumber: big.NewInt(<span class="number">1</span>)&#125;</span><br><span class="line">certDER, err := x509.CreateCertificate(rand.Reader, &amp;template, &amp;template, &amp;key.PublicKey, key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">keyPEM := pem.EncodeToMemory(&amp;pem.Block&#123;Type: <span class="string">&quot;RSA PRIVATE KEY&quot;</span>, Bytes: x509.MarshalPKCS1PrivateKey(key)&#125;)</span><br><span class="line">certPEM := pem.EncodeToMemory(&amp;pem.Block&#123;Type: <span class="string">&quot;CERTIFICATE&quot;</span>, Bytes: certDER&#125;)</span><br><span class="line"></span><br><span class="line">tlsCert, err := tls.X509KeyPair(certPEM, keyPEM)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;tls.Config&#123;</span><br><span class="line">Certificates: []tls.Certificate&#123;tlsCert&#125;,</span><br><span class="line">NextProtos:   []<span class="type">string</span>&#123;<span class="string">&quot;quic-example&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-client"><a href="#3-client" class="headerlink" title="3 client"></a>3 client</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;context&quot;</span></span><br><span class="line"><span class="string">&quot;crypto/tls&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;github.com/lucas-clemente/quic-go&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> addr = <span class="string">&quot;localhost:9999&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">tlsConf := &amp;tls.Config&#123;</span><br><span class="line">InsecureSkipVerify: <span class="literal">true</span>,</span><br><span class="line">NextProtos:         []<span class="type">string</span>&#123;<span class="string">&quot;quic-example&quot;</span>&#125;,</span><br><span class="line">&#125;</span><br><span class="line">session, err := quic.DialAddr(addr, tlsConf, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">stream, err := session.OpenStreamSync(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ticker := time.NewTicker(<span class="number">2000</span> * time.Millisecond)</span><br><span class="line"><span class="keyword">for</span> t := <span class="keyword">range</span> ticker.C &#123;</span><br><span class="line">message := fmt.Sprintf(<span class="string">&quot;Client: Sending &#x27;%d&#x27;&quot;</span>, t.Nanosecond())</span><br><span class="line">_, err = stream.Write([]<span class="type">byte</span>(message))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="built_in">len</span>(message))</span><br><span class="line">_, err = io.ReadFull(stream, buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;Client: Got &#x27;%s&#x27;\n&quot;</span>, buf)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-运行"><a href="#4-运行" class="headerlink" title="4 运行"></a>4 运行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt; go run quic_server.go</span><br><span class="line">LocalAddr 127.0.0.1:9999, RemoteAddr 127.0.0.1:53893</span><br><span class="line">Server: Got &#x27;Client: Sending &#x27;519247000&#x27;&#x27;</span><br><span class="line">Server: Got &#x27;Client: Sending &#x27;522181000&#x27;&#x27;</span><br><span class="line">Server: Got &#x27;Client: Sending &#x27;519381000&#x27;&#x27;</span><br><span class="line"></span><br><span class="line">&gt; go run quic_client.go</span><br><span class="line">Client: Got &#x27;Client: Sending &#x27;519247000&#x27;&#x27;</span><br><span class="line">Client: Got &#x27;Client: Sending &#x27;522181000&#x27;&#x27;</span><br><span class="line">Client: Got &#x27;Client: Sending &#x27;519381000&#x27;&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/32553477">QUIC协议原理分析</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
          <category> Packges </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Packges </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] String</title>
      <link href="/2021/08/15/Golang/0%20%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/String/"/>
      <url>/2021/08/15/Golang/0%20%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/String/</url>
      
        <content type="html"><![CDATA[<blockquote><p>字符串的实现和注意事项</p></blockquote><span id="more"></span><p>以下分析基于 Go1.14 版本。</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h2><p>String 具体实现如下<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// reflect/value.go 1954行  </span></span><br><span class="line"> <span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;  </span><br><span class="line">   Data <span class="type">uintptr</span>  </span><br><span class="line">   Len  <span class="type">int</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><ul><li>Data：指向 真正存储字符串内容的地址</li><li>Len：字符串的长度（字节）<br>通过起始地址换个字符串长度就可以准确定位整个字符串了。</li></ul><blockquote><p>Go 语言没有用 C 语言中的<code>\0</code>标志表示字符串结束，而是为 String 增加了 Len 字段。</p></blockquote><h2 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2 注意事项"></a>2 注意事项</h2><h3 id="2-1-不可变"><a href="#2-1-不可变" class="headerlink" title="2.1 不可变"></a>2.1 不可变</h3><p><strong>Go 语言中认为字符串是不可变的，所以分配在只读内存段。</strong></p><p>虽然可以通过如下方式读取，但是不可修改</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">&quot;hello指月&quot;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%c \n&quot;</span>, str[<span class="number">1</span>]) <span class="comment">// e</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要修改可以直接给变量赋新值，这样 string 中的 str 字段就会指向新的地址。</p><p>不过也可以通过强转为 byte slice 的方式进行修改。同样会重新分配一段内存，并拷贝原来的内容。</p><blockquote><p>使用 unsafe 包中的方法可以让 slice 依旧使用原来的这段内存，避免内存拷贝。不过这样转换类型后也无法修改这段只读内存的内容。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">str := <span class="string">&quot;hello指月&quot;</span></span><br><span class="line">bs:=[]<span class="type">byte</span>(str)</span><br><span class="line">bs[<span class="number">1</span>]=<span class="string">&#x27;z&#x27;</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;%c \n&quot;</span>, bs[<span class="number">1</span>]) <span class="comment">// z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-共享内存"><a href="#2-2-共享内存" class="headerlink" title="2.2 共享内存"></a>2.2 共享内存</h3><p>不同字符串可以共享同一个字符串内容，如果其中一个字符串修改了底层字符串内容，这样的影响是不可预测的。</p><p><img src="StarDust/source/_posts/技术/Golang/0%20基础/数据结构/String/file-20250119031144315.png" alt=""></p><p>比如图中的 s1（hello指月） 和 s2（指月）就共享了底层的字符串内容。</p><p>如果其中一个修改后都会导致，其他字符串类容被修改。</p><blockquote><p>所以字符串才被设定为不可修改，分配在只读内存段上。</p></blockquote><h2 id="3-与-bytes-互转"><a href="#3-与-bytes-互转" class="headerlink" title="3 与 bytes 互转"></a>3 与 bytes 互转</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">String2Bytes</span><span class="params">(str <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">sh := (*reflect.SliceHeader)(unsafe.Pointer(&amp;str))</span><br><span class="line"><span class="comment">// slice 比 string 多一个 cap 属性 这里给 cap 单独赋值</span></span><br><span class="line">sh.Cap = sh.Len</span><br><span class="line"><span class="keyword">return</span> *(*[]<span class="type">byte</span>)(unsafe.Pointer(sh))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Bytes2String</span><span class="params">(buf []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="type">string</span>)(unsafe.Pointer(&amp;buf))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Go 语言标准库中 strings.Builder 就使用到了 unsafe.Pointer 来提升效率。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// strings/builder.go 47 行</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Builder)</span></span> String() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="type">string</span>)(unsafe.Pointer(&amp;b.buf))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>性能测试</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Benchmark_NormalBytes2String<span class="number">-6</span>          <span class="number">33555104</span>                <span class="number">36.7</span> ns/op            <span class="number">64</span> B/op          <span class="number">1</span> allocs/op</span><br><span class="line">Benchmark_UnsafeByte2String<span class="number">-6</span>           <span class="number">1000000000</span>               <span class="number">0.268</span> ns/op           <span class="number">0</span> B/op          <span class="number">0</span> allocs/op</span><br><span class="line">Benchmark_NormalString2Bytes<span class="number">-6</span>          <span class="number">1000000000</span>               <span class="number">0.271</span> ns/op           <span class="number">0</span> B/op          <span class="number">0</span> allocs/op</span><br><span class="line">Benchmark_UnsafeString2Bytes<span class="number">-6</span>          <span class="number">1000000000</span>               <span class="number">0.268</span> ns/op           <span class="number">0</span> B/op          <span class="number">0</span> allocs/op</span><br></pre></td></tr></table></figure><p>Byte2String 的时候 unsafe 包会有明显的优势，String2Bytes的时候二者基本一致。</p><p>[]byte(string)的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/string.go 155行</span></span><br><span class="line"><span class="comment">// The constant is known to the compiler.</span></span><br><span class="line"><span class="comment">// There is no fundamental theory behind this number.</span></span><br><span class="line"><span class="keyword">const</span> tmpStringBufSize = <span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> tmpBuf [tmpStringBufSize]<span class="type">byte</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringtoslicebyte</span><span class="params">(buf *tmpBuf, s <span class="type">string</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b []<span class="type">byte</span></span><br><span class="line">    <span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(s) &lt;= <span class="built_in">len</span>(buf) &#123;</span><br><span class="line">        *buf = tmpBuf&#123;&#125;</span><br><span class="line">        b = buf[:<span class="built_in">len</span>(s)]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        b = rawbyteslice(<span class="built_in">len</span>(s))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">copy</span>(b, s)</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rawbyteslice allocates a new byte slice. The byte slice is not zeroed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rawbyteslice</span><span class="params">(size <span class="type">int</span>)</span></span> (b []<span class="type">byte</span>) &#123;</span><br><span class="line">    <span class="built_in">cap</span> := roundupsize(<span class="type">uintptr</span>(size))</span><br><span class="line">    p := mallocgc(<span class="built_in">cap</span>, <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">cap</span> != <span class="type">uintptr</span>(size) &#123;</span><br><span class="line">        memclrNoHeapPointers(add(p, <span class="type">uintptr</span>(size)), <span class="built_in">cap</span>-<span class="type">uintptr</span>(size))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *(*slice)(unsafe.Pointer(&amp;b)) = slice&#123;p, size, <span class="type">int</span>(<span class="built_in">cap</span>)&#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>长度超过 32 的时候就需要通过 mallocgc() 分配一块新内存，然后使用 copy() 复制数据了。</p><p>string([]byte)的实现</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/string.go 75行</span></span><br><span class="line"><span class="comment">// Buf is a fixed-size buffer for the result,</span></span><br><span class="line"><span class="comment">// it is not nil if the result does not escape.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">slicebytetostring</span><span class="params">(buf *tmpBuf, b []<span class="type">byte</span>)</span></span> (str <span class="type">string</span>) &#123;</span><br><span class="line">    l := <span class="built_in">len</span>(b)</span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// Turns out to be a relatively common case.</span></span><br><span class="line">        <span class="comment">// Consider that you want to parse out data between parens in &quot;foo()bar&quot;,</span></span><br><span class="line">        <span class="comment">// you find the indices and convert the subslice to string.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 如果开启了竞态检测 -race</span></span><br><span class="line">    <span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">        racereadrangepc(unsafe.Pointer(&amp;b[<span class="number">0</span>]),</span><br><span class="line">            <span class="type">uintptr</span>(l),</span><br><span class="line">            getcallerpc(),</span><br><span class="line">            funcPC(slicebytetostring))</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 如果开启了memory sanitizer -msan</span></span><br><span class="line">    <span class="keyword">if</span> msanenabled &#123;</span><br><span class="line">        msanread(unsafe.Pointer(&amp;b[<span class="number">0</span>]), <span class="type">uintptr</span>(l))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">1</span> &#123;</span><br><span class="line">        stringStructOf(&amp;str).str = unsafe.Pointer(&amp;staticbytes[b[<span class="number">0</span>]])</span><br><span class="line">        stringStructOf(&amp;str).<span class="built_in">len</span> = <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> p unsafe.Pointer</span><br><span class="line">    <span class="keyword">if</span> buf != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(b) &lt;= <span class="built_in">len</span>(buf) &#123;</span><br><span class="line">        p = unsafe.Pointer(buf)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        p = mallocgc(<span class="type">uintptr</span>(<span class="built_in">len</span>(b)), <span class="literal">nil</span>, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    stringStructOf(&amp;str).str = p</span><br><span class="line">    stringStructOf(&amp;str).<span class="built_in">len</span> = <span class="built_in">len</span>(b)</span><br><span class="line">  <span class="comment">// 拷贝字节数组至字符串</span></span><br><span class="line">    memmove(p, (*(*slice)(unsafe.Pointer(&amp;b))).array, <span class="type">uintptr</span>(<span class="built_in">len</span>(b)))</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例stringStruct对象</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stringStructOf</span><span class="params">(sp *<span class="type">string</span>)</span></span> *stringStruct &#123;</span><br><span class="line">    <span class="keyword">return</span> (*stringStruct)(unsafe.Pointer(sp))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样的，当数组长度超过32时，同样需要调用 mallocgc() 分配一块新内存。最后通过 memmove() 完成拷贝。</p><p><strong>小结</strong></p><p>Go 语言也是在安全和性能之间选择了安全，不过这点性能损失也非常小。</p><p>当不确定会不会出现安全问题的时候就用标准的转换方式。</p><p>在对性能有极高要求，且没有安全隐患（即确定数据是只读的，后续不会有修改操作），就可以使用 unsafe 包。</p><h2 id="4-字符串拼接"><a href="#4-字符串拼接" class="headerlink" title="4 字符串拼接"></a>4 字符串拼接</h2><p>字符串拼接有多种方式：</p><ul><li>1）直接相加</li><li>2）fmt.Sprintf()</li><li>3）strings.Builder</li><li>4）bytes.Buffer</li></ul><p>测试结果如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 2次</span></span><br><span class="line">BenchmarkSprintf-6               5544774               214 ns/op              32 B/op          3 allocs/op</span><br><span class="line">BenchmarkStringBuilder-6        40105342                30.9 ns/op             8 B/op          1 allocs/op</span><br><span class="line">BenchmarkBytesBuf-6             24064540                51.1 ns/op            64 B/op          1 allocs/op</span><br><span class="line">BenchmarkStringAdd-6            30062755                40.6 ns/op             2 B/op          1 allocs/op</span><br><span class="line"><span class="comment"># 100次</span></span><br><span class="line">BenchmarkSprintf-6                 66108             16317 ns/op           12178 B/op        297 allocs/op</span><br><span class="line">BenchmarkStringBuilder-6         1471501               828 ns/op             504 B/op          6 allocs/op</span><br><span class="line">BenchmarkBytesBuf-6              1000000              1122 ns/op             688 B/op          4 allocs/op</span><br><span class="line">BenchmarkStringAdd-6              240511              5032 ns/op            9776 B/op         99 allocs/op</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1000次</span></span><br><span class="line">BenchmarkSprintf-6                  3081            367700 ns/op         1518878 B/op       2998 allocs/op</span><br><span class="line">BenchmarkStringBuilder-6           44805             26449 ns/op           13376 B/op        912 allocs/op</span><br><span class="line">BenchmarkBytesBuf-6                41952             28877 ns/op           15344 B/op        908 allocs/op</span><br><span class="line">BenchmarkStringAdd-6                4620            237020 ns/op         1496941 B/op       1899 allocs/op</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> Sprintf 和直接相加 因为每次都生成一个新字符串，所以有大量的内存分配，而 strings.Builder 和 bytes.Buffer 都有缓存,省去了内存分配的开销，所以效率比较高。</p><p>结论：<strong>字符串少推荐直接相加，多则使用 strings.Builder。</strong></p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p><code>https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-string/</code></p><p><code>https://www.bilibili.com/video/BV1hv411x7we?p=1</code></p><p><code>https://www.mdeditor.tw/pl/pDSl</code></p>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Golang WorkerPool</title>
      <link href="/2021/08/11/Golang/4%20%E5%85%B6%E4%BB%96/WorkerPool/"/>
      <url>/2021/08/11/Golang/4%20%E5%85%B6%E4%BB%96/WorkerPool/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Golang实现一个工作池处理并发任务</p></blockquote><span id="more"></span><pre><code class="lang-go">package mainimport (    &quot;log&quot;    &quot;time&quot;)// Worker 工作者type Worker struct &#123;    dataCh chan interface&#123;&#125; // worker channel    stopCh chan struct&#123;&#125;    // stop channel&#125;// NewWorker 新建一个工作者func NewWorker(lenght int) *Worker &#123;    return &amp;Worker&#123;        dataCh: make(chan interface&#123;&#125;, lenght),        stopCh: make(chan struct&#123;&#125;),    &#125;&#125;// Run 运行一个工作任务func (w *Worker) Run() &#123;    for &#123;        select &#123;        case msg := &lt;-w.dataCh:            w.handler(msg)        case &lt;-w.stopCh:            return        &#125;    &#125;&#125;func (w *Worker) stop() &#123;    select &#123;    case &lt;-w.stopCh:        return    default:    &#125;    close(w.stopCh)&#125;func (w *Worker) handler(message interface&#123;&#125;) &#123;    switch msg := message.(type) &#123;    case stopEvent: // 停止工作任务        log.Println(&quot;worker exit&quot;)        w.stop()    default:        //TODO 处理工作任务        log.Printf(&quot;unkown msg %#v&quot;, msg)    &#125;&#125;type stopEvent int// Dispatcher 工作调度器type Dispatcher struct &#123;    maxWorkers   int                   // 最大worker数量    workerLength int                   // worker缓冲长度    queue        chan interface&#123;&#125;      // 任务调度队列    workerPool   chan chan interface&#123;&#125; // worker channel pool    stopCh       chan struct&#123;&#125;         // stop channel&#125;// NewDispatcher 创建一个调度器func NewDispatcher(maxQueue, maxWorkers, workerLength int) *Dispatcher &#123;    pool := make(chan chan interface&#123;&#125;, maxWorkers) // 创建最大数量    return &amp;Dispatcher&#123;        workerPool:   pool,        maxWorkers:   maxWorkers,        workerLength: workerLength,        stopCh:       make(chan struct&#123;&#125;),        queue:        make(chan interface&#123;&#125;, maxQueue),    &#125;&#125;func (d *Dispatcher) spawnWorker() &#123;    worker := NewWorker(d.workerLength)    go worker.Run()    d.workerPool &lt;- worker.dataCh&#125;// Run 运行调度器func (d *Dispatcher) Run() &#123;    for i := 0; i &lt; d.maxWorkers; i++ &#123;        d.spawnWorker()    &#125;    go d.dispatch()&#125;func (d *Dispatcher) stop() &#123;    select &#123;    case &lt;-d.stopCh:        return    default:    &#125;    close(d.stopCh)&#125;// 任务分派器func (d *Dispatcher) dispatch() &#123;    for &#123;        select &#123;        case msg := &lt;-d.queue:            d.handler(msg)        case &lt;-d.stopCh:            return        &#125;    &#125;&#125;func (d *Dispatcher) handler(msg interface&#123;&#125;) &#123;    switch msg.(type) &#123;    case stopEvent: // 停止分派任务        d.stop()        log.Println(&quot;dispatcher closed&quot;)        return    &#125;    for workerCh := range d.workerPool &#123;        if (len(workerCh) + 1) == cap(workerCh) &#123;            workerCh &lt;- stopEvent(1)            continue        &#125;        workerCh &lt;- msg        d.workerPool &lt;- workerCh        break    &#125;    if len(d.workerPool) &lt; d.maxWorkers &#123;        d.spawnWorker()    &#125;&#125;func main() &#123;    defaultDispatch := NewDispatcher(4, 5, 100)    defaultDispatch.Run()    for i := 0; i &lt; 100; i++ &#123;        select &#123;        case &lt;-defaultDispatch.stopCh:            return        default:        &#125;        defaultDispatch.queue &lt;- i    &#125;    time.Sleep(5 * time.Second)    //defaultDispatch.queue &lt;- stopEvent(1)&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Golang ldflags</title>
      <link href="/2021/08/09/Golang/4%20%E5%85%B6%E4%BB%96/ldflags/"/>
      <url>/2021/08/09/Golang/4%20%E5%85%B6%E4%BB%96/ldflags/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Golang 在编译时使用ldflags动态设置包中变量的值</p></blockquote><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-X importpath.name=value Set the value of the string variable in importpath named name to value. Note that before Go 1.5 this option took two separate arguments. Now it takes one argument split on the first = sign.</span><br></pre></td></tr></table></figure><p>ldflags用于链接过程，详细见文章<a href="https://tonybai.com/2017/06/27/an-intro-about-go-portability/">也谈Go的可移植性</a><br><a href="http://blog.champbay.com/2019/11/25/%e9%9d%99%e6%80%81%e9%93%be%e6%8e%a5%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e9%9d%99%e6%80%81%e5%ba%93%e5%85%b1%e4%ba%ab%e5%ba%93%e8%bf%99%e4%ba%9b%e6%a6%82%e5%bf%b5%e7%9a%84%e8%af%a6%e8%a7%a3/">静态链接,动态链接,静态库,共享库这些概念的详解</a></p><h2 id="1-参数作用"><a href="#1-参数作用" class="headerlink" title="1 参数作用"></a>1 参数作用</h2><p><code>golang在编译、测试、安装时使用-ldflags -X动态设置包中变量的值 go install/build/test 时可以通过命令行参数设置package中的变量， 其格式为-X importpath.name=val, 其中importpath是变量所在包的的路径， name是包中定义的变量， val 是需要在编译时设置的变量的值(string)， name表示的变量只能是variable，不能是constant, 且不能通过函数调用的方式初始化， 其类型只能是string，不可是int, bool等. 如果val中存在空格,需要用引号括起来,如下date和go version输出结果有空格： go build -ldflags &quot;-X &#39;main.BUILD_TIME=`date`&#39; -X &#39;main.GO_VERSION=`go version`&#39;&quot;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">docker version</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Client: Docker Engine - Community</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Version: 19.03.3</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">API version: 1.40</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Go version: go1.12.10</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Git commit: a872fc2</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Built: Tue Oct 8 00:55:12 2019</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">OS/Arch: darwin/amd64</span> </span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">Experimental: <span class="literal">false</span></span></span><br></pre></td></tr></table></figure><h2 id="2-编译时使用"><a href="#2-编译时使用" class="headerlink" title="2 编译时使用"></a>2 编译时使用</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">version    <span class="type">string</span></span><br><span class="line">build_time <span class="type">string</span></span><br><span class="line">go_version <span class="type">string</span></span><br><span class="line">git_commit <span class="type">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;version:&quot;</span>, version)</span><br><span class="line">fmt.Println(<span class="string">&quot;go version:&quot;</span>, go_version)</span><br><span class="line">fmt.Println(<span class="string">&quot;build time:&quot;</span>, build_time)</span><br><span class="line">fmt.Println(<span class="string">&quot;git log:&quot;</span>, git_commit)</span><br><span class="line">&#125;<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">执行输出：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>shell</span><br><span class="line">&gt; <span class="keyword">go</span> build -ldflags <span class="string">&quot;-X &#x27;main.build_time=$(date)&#x27; -X &#x27;main.git_commit=$(git log --pretty=format:&quot;</span>%h<span class="string">&quot; -1)&#x27; -X main.version=1.0.0 -X &#x27;main.go_version=`go version`&#x27;&quot;</span> main.<span class="keyword">go</span></span><br><span class="line">&gt; ./main</span><br><span class="line">version: <span class="number">1.0</span><span class="number">.0</span></span><br><span class="line"><span class="keyword">go</span> version: <span class="keyword">go</span> version go1<span class="number">.14</span> darwin/amd64</span><br><span class="line">build time: <span class="number">2021</span>年 <span class="number">8</span>月 <span class="number">9</span>日 星期日 <span class="number">19</span>时<span class="number">09</span>分<span class="number">50</span>秒 CST</span><br><span class="line">git log: <span class="number">175</span>a5eb<span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## 测试时使用</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">创建包和文件</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>shell</span><br><span class="line">&gt; mkdir $GOPATH/src/gotest </span><br><span class="line">&gt; touch $GOPATH/src/gotest/go_test.<span class="keyword">go</span></span><br></pre></td></tr></table></figure><pre><code class="lang-go">package gotestimport &quot;testing&quot;var time stringvar version stringfunc TestBuild(t *testing.T) &#123;  t.Log(time)  t.Log(version)&#125;</code></pre><p>执行输出：</p><pre><code class="lang-shell">&gt; cd $GOPATH/src/&gt; GO111MODULE=off go test -ldflags=&quot;-X &#39;gotest.time=`date`&#39; -X gotest.version=1.0.1&quot; gotest -v=== RUN   TestBuild    TestBuild: go_test.go:9: 2021年 8月 9日 星期日 18时57分49秒 CST    TestBuild: go_test.go:10: 1.0.1--- PASS: TestBuild (0.00s)PASSok      gotest  0.009s</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/ahmczsy/p/11512151.html">ldflags使用技巧</a></li><li><a href="https://tonybai.com/2017/06/27/an-intro-about-go-portability/">也谈Go的可移植性</a></li><li><a href="http://blog.champbay.com/2019/11/25/%e9%9d%99%e6%80%81%e9%93%be%e6%8e%a5%e5%8a%a8%e6%80%81%e9%93%be%e6%8e%a5%e9%9d%99%e6%80%81%e5%ba%93%e5%85%b1%e4%ba%ab%e5%ba%93%e8%bf%99%e4%ba%9b%e6%a6%82%e5%bf%b5%e7%9a%84%e8%af%a6%e8%a7%a3/">静态链接,动态链接,静态库,共享库这些概念的详解</a></li><li><a href="https://book.douban.com/subject/4141733/">Linux C编程一站式学习</a></li><li><a href="http://docs.linuxtone.org/ebooks/C&amp;CPP/c/">Linux C编程一站式学习 ebook</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
          <category> Packages </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Go-Package </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Go] Golang 内存对齐</title>
      <link href="/2021/07/22/Golang/4%20%E5%85%B6%E4%BB%96/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
      <url>/2021/07/22/Golang/4%20%E5%85%B6%E4%BB%96/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>内存对齐主要就是为了迎合内存设计, 可以提升内存访问效率</p></blockquote><span id="more"></span><h2 id="1-内存概述"><a href="#1-内存概述" class="headerlink" title="1 内存概述"></a>1 内存概述</h2><h3 id="1-1-内存设计"><a href="#1-1-内存设计" class="headerlink" title="1.1 内存设计"></a>1.1 内存设计</h3><p>内存条上的 8 个黑色小方块称之为 <strong>chip</strong>，整个合起来叫做 <strong>rank</strong>。</p><p>chip 中又分为多个 <strong>bank</strong>，bank 这里就可以通过行列方式来进行访问了。</p><h3 id="1-2-内存访问"><a href="#1-2-内存访问" class="headerlink" title="1.2 内存访问"></a>1.2 内存访问</h3><p>内存访问一般采取<strong>并行</strong>方式，比如 8 Byte 的数据并不会都存在第一个 chip,而是分散到各个 chip 中存储。比如 chip1 存储 Byte1，chip2 存储 Byte2,依次类推。读取的时候分别从 8 个 chip 中读取出 1Byte，拼接起来就是完整的 8 Byte。</p><blockquote><p>可以简单的理解为这样使得内存访问效率提升了 8 倍。</p></blockquote><p><strong>可以看到内存的真实存放情况并不是我们想象的那样是逻辑连续的。</strong></p><h2 id="2-内存字节对齐"><a href="#2-内存字节对齐" class="headerlink" title="2 内存字节对齐"></a>2 内存字节对齐</h2><p>这里说的内存对齐指的是存入内存之前的数据。即分散之前的，或者说是读取出来拼接好后的那一部分数据需要对齐。</p><p>否则就不能迅速的从各个 chip 将对应的数据读取出来，需要分多次读取，这样效率势必会降低不少。</p><h3 id="2-1-例子"><a href="#2-1-例子" class="headerlink" title="2.1 例子"></a>2.1 例子</h3><p>假设有一个 8Byte 的数据，进行内存对齐后地址分别为 0~7。</p><p>然后分别存到 8 个 chip 中，假设是存在 （1,1）这个位置的。</p><p>读取时只需要分别读取8个chip 的（1,1）位置数据然后组合起来就是完成的数据了。</p><p>如果没有内存对齐，比如分配的地址是(1~8)。</p><p>这样分别存到 8 个chip之后就不会是相同的地址了。</p><p>现在 0 这个位置虽然没有数据，但是chip 中还是要给它流出位置来，万一后面会写入数据呢。</p><p>所以现在8个chip的（1，1）这个位置中，chip1的（1,1）是空的，后续7个chip分别存储了（1~7）的数据，剩下的位置8这个数据，会存在下一个坐标，比如(1,2),然后后续的9~15又是空的。chip1的（1,2）存放了数据8，但是其他chip的(1,2)位置暂时还是空的。</p><p>所以最后要读取（1~8）的所有数据就需要分别读取出8个chip上的位置（1,1）和（1，2）然后剔除掉不要的数据最后拼接起来才是完整的数据。</p><blockquote><p>之所以有的 CPU 可能实现随机内存访问，就是因为实现了这个数据过滤拼接的功能，但是这样在内存读取效率会大打折扣。</p></blockquote><h2 id="3-Go-语言内存对齐"><a href="#3-Go-语言内存对齐" class="headerlink" title="3 Go 语言内存对齐"></a>3 Go 语言内存对齐</h2><p>具体对齐方式和平台有关。</p><p><strong>32 位平台指针宽度和寄存器宽度都是4字节，64位平台则都是8字节。</strong></p><p>在Go语言中<strong>寄存器宽度</strong>也称之为<strong>机器字长</strong>或者<strong>最大对齐边界</strong>。</p><h3 id="3-1-对齐规则"><a href="#3-1-对齐规则" class="headerlink" title="3.1 对齐规则"></a>3.1 对齐规则</h3><p>在分析之前，我们先看下内存对齐的规则：</p><h4 id="3-1-1-规则一"><a href="#3-1-1-规则一" class="headerlink" title="3.1.1 规则一"></a>3.1.1 <strong>规则一</strong></h4><p>对于具体类型来说，<strong>对齐值=min(平台最大对齐边界，类型大小Sizeof长度)</strong>。<strong>也就是在平台最大对齐边界和类型的内存占用大小之间，取最小值为该类型的对齐值</strong>。我的电脑默认是8，所以最大值不会超过8.</p><p>为什么不统一按照平台最大对齐边界或者类型大小来对齐？</p><p>主要是为了节约内存。直接按平台最大对齐边界对齐的话，如果数据类型长度小于最大对齐边界的时候就会造成内存浪费，比如 int8占1byte也按照8byte对齐就会浪费7byte空间，按照类型大小长度对齐也有同样的问题，所以才取二者中的最小值。</p><h4 id="3-1-2-规则二"><a href="#3-1-2-规则二" class="headerlink" title="3.1.2 规则二"></a>3.1.2 <strong>规则二</strong></h4><p>struct 在每个字段都内存对齐之后，其本身也要进行对齐，<strong>对齐值为各个成员对齐值中的最大值</strong>。</p><p>结构体对齐是为了保证<strong>结构体数组</strong>中的各个元素能正常访问，由于数组内存是连续的，如果结构体不对齐势必会导致，数组的第二个及其后面的元素无法正常访问。</p><p>在这里再次提醒，对齐值也叫对齐系数、对齐倍数，对齐模数。这就是说，<strong>每个字段在内存中的偏移量是对齐值的倍数即可</strong>。</p><h3 id="3-2-类型长度"><a href="#3-2-类型长度" class="headerlink" title="3.2 类型长度"></a>3.2 类型长度</h3><p>windows 64位系统 编译器默认对齐值=8</p><div class="table-container"><table><thead><tr><th>类型</th><th>大小</th><th>对齐系数</th><th>备注</th></tr></thead><tbody><tr><td>bool</td><td>1</td><td>1</td><td></td></tr><tr><td>byte</td><td>1</td><td>1</td><td></td></tr><tr><td>int8</td><td>1</td><td>1</td><td></td></tr><tr><td>int16</td><td>2</td><td>2</td><td></td></tr><tr><td>int32</td><td>4</td><td>4</td><td></td></tr><tr><td>int64</td><td>8</td><td>8</td><td></td></tr><tr><td>float32</td><td>4</td><td>4</td><td></td></tr><tr><td>float64</td><td>8</td><td>8</td><td></td></tr><tr><td>map</td><td>8</td><td>8</td><td></td></tr><tr><td>string</td><td>16</td><td>8</td><td>对齐系数不会超过编译器默认对齐值</td></tr><tr><td>array ([1]string{“xxx”})</td><td>16</td><td>8</td><td></td></tr><tr><td>slice ([]string{“xxx”})</td><td>24</td><td>8</td></tr></tbody></table></div><h3 id="3-3-例子"><a href="#3-3-例子" class="headerlink" title="3.3 例子"></a>3.3 例子</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Part1 <span class="keyword">struct</span> &#123;</span><br><span class="line">A <span class="type">bool</span>              <span class="comment">// 长度1 偏移0 填充0 总大小1</span></span><br><span class="line">B <span class="type">byte</span>              <span class="comment">// 长度1 偏移1 填充0 总大小2</span></span><br><span class="line">C <span class="type">int8</span>              <span class="comment">// 长度1 偏移2 填充0 总大小3</span></span><br><span class="line">D <span class="type">int16</span>             <span class="comment">// 长度2 偏移3 填充1 总大小6</span></span><br><span class="line">E <span class="type">int32</span>             <span class="comment">// 长度4 偏移5 填充2 总大小12</span></span><br><span class="line">F <span class="type">int64</span>             <span class="comment">// 长度8 偏移11 填充4 总大小22</span></span><br><span class="line">G <span class="type">float32</span>           <span class="comment">// 长度4 偏移21 填充2 总大小28</span></span><br><span class="line">H <span class="type">float64</span>           <span class="comment">// 长度8 偏移27 填充4 总大小40</span></span><br><span class="line">I <span class="type">string</span>            <span class="comment">// 长度16 偏移39 填充0 总大小56</span></span><br><span class="line">J <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span> <span class="comment">// 长度8 偏移55 填充0 总大小64</span></span><br><span class="line">K []<span class="type">string</span>          <span class="comment">// 长度24 偏移63 填充0 总大小88</span></span><br><span class="line">L [<span class="number">1</span>]<span class="type">string</span>         <span class="comment">// 长度16 偏移87 填充0 总大小104</span></span><br><span class="line"><span class="comment">//104 刚好是8的倍数 不需要填充</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-小结"><a href="#4-小结" class="headerlink" title="4 小结"></a>4 小结</h2><p>内存对齐主要就是为了迎合内存设计。</p><p>而内存之所以这么设计是为了提升内存访问效率。</p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考</h2><p><code>https://go101.org/article/memory-layout.html</code></p><p><code>https://www.bilibili.com/video/BV1hv411x7we</code></p><p><code>https://xie.infoq.cn/article/594a7f54c639accb53796cfc7</code></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
          <category> Golang </category>
          
          <category> Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> Golang-Basic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Algorithm] Dynamic Programming</title>
      <link href="/2021/06/12/Algorithm/Dynamic%20Programming/"/>
      <url>/2021/06/12/Algorithm/Dynamic%20Programming/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h3 id="0-1-1、思考状态"><a href="#0-1-1、思考状态" class="headerlink" title="0.1 1、思考状态"></a>0.1 1、思考状态</h3><ul><li>状态的定义：题目问什么，把什么设置成状态</li><li>思考状态怎么转移，如果不好转移，尝试修改定义</li><li>状态转移方程：大问题的最优解怎么从小问题的最优解得到</li></ul><h3 id="0-2-2、思考状态转移方程"><a href="#0-2-2、思考状态转移方程" class="headerlink" title="0.2 2、思考状态转移方程"></a>0.2 2、思考状态转移方程</h3><ul><li>推导技巧：分类讨论。即：对状态空间进行分类</li><li>「动态规划」方法依然是「空间换时间」思想的体现，常见的解决问题的过程很像在「填表」</li></ul><h3 id="0-3-3、思考初始化"><a href="#0-3-3、思考初始化" class="headerlink" title="0.3 3、思考初始化"></a>0.3 3、思考初始化</h3><ul><li>角度 1：直接从状态的语义出发；</li><li>角度 2：如果状态的语义不好思考，就考虑「状态转移方程」的边界需要什么样初始化的条件；</li><li>角度 3：从「状态转移方程」方程的下标看是否需要多设置一行、一列表示「哨兵」（sentinel），这样可以避免一些特殊情况的讨论。</li></ul><h3 id="0-4-4、思考输出"><a href="#0-4-4、思考输出" class="headerlink" title="0.4 4、思考输出"></a>0.4 4、思考输出</h3><p>有些时候是最后一个状态，有些时候可能会综合之前所有计算过的状态。</p><h3 id="0-5-5、思考优化空间（也可以叫做表格复用）"><a href="#0-5-5、思考优化空间（也可以叫做表格复用）" class="headerlink" title="0.5 5、思考优化空间（也可以叫做表格复用）"></a>0.5 5、思考优化空间（也可以叫做表格复用）</h3><ul><li>「优化空间」会使得代码难于理解，且是的「状态」丢失原来的语义，初学的时候可以不一步到位。先把代码写正确是更重要；</li><li>「优化空间」在有一种情况下是很有必要的，那就是状态空间非常庞大的时候（处理海量数据），此时空间不够用，就必须「优化空间」；</li><li>非常经典的「优化空间」的典型问题是「0-1 背包」问题和「完全背包」问题。</li></ul><h2 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1 斐波那契数列"></a>1 斐波那契数列</h2><h3 id="1-1-70-爬楼梯"><a href="#1-1-70-爬楼梯" class="headerlink" title="1.1 70.爬楼梯"></a>1.1 70.爬楼梯</h3><p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p>注意：给定 n 是一个正整数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：第i个楼梯可以从i-1或者i-2处再走一步到达；那么dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class="line"><span class="comment">//又因为只和前两步有关，可以用两个变量存储之前的状态，降低时间复杂度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre1</span> <span class="operator">=</span> <span class="number">1</span>,pre2 = <span class="number">2</span>;  <span class="comment">//初始状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt; n;i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> pre1 + pre2;<span class="comment">//当前为前两级的和</span></span><br><span class="line">            pre1 = pre2;<span class="comment">//都前进一步</span></span><br><span class="line">            pre2 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-198-强盗打劫"><a href="#1-2-198-强盗打劫" class="headerlink" title="1.2 198.强盗打劫"></a>1.2 198.强盗打劫</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。</span></span><br><span class="line"><span class="comment">//状态转移方程：dp[i] = Math.max(dp[i-2] + nums[i],dp[i-1]) </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre1</span> <span class="operator">=</span> <span class="number">0</span>,pre2 = <span class="number">0</span>, cur = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length ; i++)&#123;</span><br><span class="line">            cur = Math.max(nums[i] + pre1 , pre2);</span><br><span class="line">            pre1 = pre2;</span><br><span class="line">            pre2 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-213-强盗在环型街道打劫"><a href="#1-3-213-强盗在环型街道打劫" class="headerlink" title="1.3 213.强盗在环型街道打劫"></a>1.3 213.强盗在环型街道打劫</h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：在打家劫舍的基础上限定了范围，也就是打劫的第一家和最后一家不能相邻[0,n-2] [1,n-1]</span></span><br><span class="line"><span class="comment">//状态转移方程dp[i] = Math.max(dp[i-2] + nums[i],dp[i-1]) </span></span><br><span class="line"><span class="comment">//通过新建打劫方法对范围进行限定和比较</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//抢劫的第一家和最后一家不能相邻[1,n-1] [0,n-2]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> Math.max(robHelper(nums,<span class="number">1</span>,n-<span class="number">1</span>),robHelper(nums,<span class="number">0</span>,n-<span class="number">2</span>)); <span class="comment">//两种不同的打劫方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">robHelper</span><span class="params">(<span class="type">int</span>[] nums,<span class="type">int</span> start,<span class="type">int</span> end)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre1</span> <span class="operator">=</span> <span class="number">0</span>,pre2=<span class="number">0</span>,cur=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start;i&lt;=end;i++)&#123;</span><br><span class="line">            cur = Math.max(pre1 + nums[i] , pre2);</span><br><span class="line">            pre1 = pre2;</span><br><span class="line">            pre2 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-信件错排"><a href="#1-4-信件错排" class="headerlink" title="1.4 信件错排"></a>1.4 信件错排</h3><p>题目描述：有 N 个 信 和 信封，它们被打乱，求错误装信方式的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：定义一个数组 dp 存储错误方式数量，dp[i] 表示前 i 个信和信封的错误方式数量。假设第 i 个信装到第 j 个信封里面，而第 j 个信装到第 k 个信封里面。根据 i 和 k 是否相等，有两种情况：</span></span><br><span class="line"><span class="comment">// i==k，交换 i 和 j 的信后，它们的信和信封在正确的位置，但是其余 i-2 封信有 dp[i-2] 种错误装信的方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-2] 种错误装信方式。</span></span><br><span class="line"><span class="comment">// i != k，交换 i 和 j 的信后，第 i 个信和信封在正确的位置，其余 i-1 封信有 dp[i-1] 种错误装信方式。由于 j 有 i-1 种取值，因此共有 (i-1)*dp[i-1] 种错误装信方式。</span></span><br><span class="line">dp[i] = (i-<span class="number">1</span>)*dp[i-<span class="number">2</span>] + (i-<span class="number">1</span>)*dp[i-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="1-5-母牛生产"><a href="#1-5-母牛生产" class="headerlink" title="1.5 母牛生产"></a>1.5 母牛生产</h3><p>题目描述：假设农场中成熟的母牛每年都会生 1 头小母牛，并且永远不会死。第一年有 1 只小母牛，从第二年开始，母牛开始生小母牛。每只小母牛 3 年之后成熟又可以生小母牛。给定整数 N，求 N 年后牛的数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">3</span>]</span><br></pre></td></tr></table></figure><h2 id="2-矩阵路径"><a href="#2-矩阵路径" class="headerlink" title="2 矩阵路径"></a>2 矩阵路径</h2><h3 id="2-1-64-矩阵的最小路径和"><a href="#2-1-64-矩阵的最小路径和" class="headerlink" title="2.1 64.矩阵的最小路径和"></a>2.1 64.矩阵的最小路径和</h3><p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前的状态只能从左或者上到达</span></span><br><span class="line"><span class="comment">//状态转移方程dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]</span></span><br><span class="line"><span class="comment">//考虑边界，在最左时不可能从左来，在最上时，不可能从上来</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; grid.length ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>) grid[i][j] = grid[i][j] + grid[i][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) grid[i][j] = grid[i][j] + grid[i-<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] = grid[i][j] + Math.min(grid[i-<span class="number">1</span>][j],grid[i][j-<span class="number">1</span>]);</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[grid.length - <span class="number">1</span>][grid[<span class="number">0</span>].length - <span class="number">1</span>] ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-62-矩阵的总路径数"><a href="#2-2-62-矩阵的总路径数" class="headerlink" title="2.2 62.矩阵的总路径数"></a>2.2 62.矩阵的总路径数</h3><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。问总共有多少条不同的路径？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i][j] = dp[i-1][j] + dp[i][j-1]</span></span><br><span class="line"><span class="comment">//左边界和上边界都是1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-0-1背包"><a href="#3-0-1背包" class="headerlink" title="3 0-1背包"></a>3 0-1背包</h2><p>有一个容量为 N 的背包，要用这个背包装下物品的价值最大，这些物品有两个属性：体积 w 和价值 v。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个二维数组 dp 存储最大价值，其中 dp[i][j] 表示前 i 件物品体积不超过 j 的情况下能达到的最大价值。设第 i 件物品体积为 w，价值为 v，根据第 i 件物品是否添加到背包中，可以分两种情况讨论：</span></span><br><span class="line"><span class="comment">//第 i 件物品没添加到背包，总体积不超过 j 的前 i 件物品的最大价值就是总体积不超过 j 的前 i-1 件物品的最大价值，dp[i][j] = dp[i-1][j]。</span></span><br><span class="line"><span class="comment">//第 i 件物品添加到背包中，dp[i][j] = dp[i-1][j-w] + v。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//状态转移方程：dp[i][j] = max(dp[i-1][j], dp[i-1][j-w]+v)</span></span><br><span class="line"><span class="comment">// W 为背包总体积</span></span><br><span class="line"><span class="comment">// N 为物品数量</span></span><br><span class="line"><span class="comment">// weights 数组存储 N 个物品的重量</span></span><br><span class="line"><span class="comment">// values 数组存储 N 个物品的价值</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span> N, <span class="type">int</span>[] weights, <span class="type">int</span>[] values)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[N + <span class="number">1</span>][W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> weights[i - <span class="number">1</span>], v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= W; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w) &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - w] + v);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[N][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-空间优化"><a href="#3-1-空间优化" class="headerlink" title="3.1 空间优化"></a>3.1 空间优化</h3><p>观察状态转移方程可以知道，前 i 件物品的状态仅与前 i-1 件物品的状态有关，因此可以将 dp 定义为一维数组</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i] = max(dp[j],dp[j-w]+v)</span></span><br><span class="line"><span class="comment">//因为 dp[j-w] 表示 dp[i-1][j-w]，因此不能先求 dp[i][j-w]，防止将 dp[i-1][j-w] 覆盖。也就是说要先计算 dp[i][j] 再计算 dp[i][j-w]，在程序实现时需要按倒序来循环求解。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">knapsack</span><span class="params">(<span class="type">int</span> W, <span class="type">int</span> N, <span class="type">int</span>[] weights, <span class="type">int</span>[] values)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[W + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> weights[i - <span class="number">1</span>], v = values[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> W; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - w] + v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-完全背包"><a href="#4-完全背包" class="headerlink" title="4 完全背包"></a>4 完全背包</h2><h3 id="4-1-322-找零钱的最少硬币数"><a href="#4-1-322-找零钱的最少硬币数" class="headerlink" title="4.1 322.找零钱的最少硬币数"></a>4.1 322.找零钱的最少硬币数</h3><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//状态转移方程：dp[amount] = Math.min(&#123;dp[amount - coin]|(for(int coin : coins))&#125;)</span></span><br><span class="line"><span class="comment">//也就是根据当前硬币的面值可以抵达的状态中的最小值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(amount == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> coin : coins)&#123;<span class="comment">//对硬币面值进行遍历</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> coin; i &lt; amount + <span class="number">1</span>; i++)&#123;</span><br><span class="line">                <span class="comment">//如果一个硬币就可以，置为一</span></span><br><span class="line">                <span class="keyword">if</span>(i == coin) dp[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果减一个硬币就可以，在该状态基础上加一</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dp[i] == <span class="number">0</span> &amp;&amp; dp[i-coin] != <span class="number">0</span>) dp[i] = dp[i-coin] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//在遍历硬币的时候，如果发现更优解，重置结果</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(dp[i] != <span class="number">0</span> &amp;&amp; dp[i-coin] != <span class="number">0</span>) dp[i] = Math.min(dp[i], dp[i-coin]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] == <span class="number">0</span> ? -<span class="number">1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-518-找零钱的硬币数组合"><a href="#4-2-518-找零钱的硬币数组合" class="headerlink" title="4.2 518.找零钱的硬币数组合"></a>4.2 518.找零钱的硬币数组合</h3><p>给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> coin : coins)&#123;   <span class="comment">//遍历硬币面值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> coin; i &lt; amount + <span class="number">1</span>; i++)&#123;</span><br><span class="line">                dp[i] += dp[i-coin];  <span class="comment">//终态是不同状态到达该状态的累加</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-数组区间"><a href="#5-数组区间" class="headerlink" title="5 数组区间"></a>5 数组区间</h2><h3 id="5-1-303-数组区间和"><a href="#5-1-303-数组区间和" class="headerlink" title="5.1 303.数组区间和"></a>5.1 303.数组区间和</h3><p>给定一个整数数组 nums，求出数组从索引 i 到 j (i ≤ j) 范围内元素的总和，包含 i, j 两点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从i到j的区间和可以转化成前缀和之差</span></span><br><span class="line"><span class="comment">//构建一个数组，保存从0到下标处的数组和</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] sums;  <span class="comment">//和数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        sums = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> ; i &lt;= nums.length;i++)&#123;</span><br><span class="line">            sums[i] = sums[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sums[j+<span class="number">1</span>] - sums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-413-等差数列划分"><a href="#5-2-413-等差数列划分" class="headerlink" title="5.2 413.等差数列划分"></a>5.2 413.等差数列划分</h3><p>数组 A 包含 N 个数，且索引从0开始。数组 A 的一个子数组划分为数组 (P, Q)，P 与 Q 是整数且满足 0&lt;=P&lt;Q&lt;N 。</p><p>如果满足以下条件，则称子数组(P, Q)为等差数组：</p><p>元素 A[P], A[p + 1], …, A[Q - 1], A[Q] 是等差的。并且 P + 1 &lt; Q 。</p><p>函数要返回数组 A 中所有为等差数组的子数组个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：dp[i]表示以A[i]结尾的等差递增子区间的个数</span></span><br><span class="line"><span class="comment">//当 A[i] - A[i-1] == A[i-1] - A[i-2]，那么 [A[i-2], A[i-1], A[i]] 构成一个等差递增子区间。而且在以 A[i-1] 为结尾的递增子区间的后面再加上一个 A[i]，一样可以构成新的递增子区间。</span></span><br><span class="line"><span class="comment">//也就是在 A[i] - A[i-1] == A[i-1] - A[i-2] 时，dp[i] = dp[i-1] + 1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfArithmeticSlices</span><span class="params">(<span class="type">int</span>[] A)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> A.length;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(A[i] - A[i-<span class="number">1</span>] == A[i-<span class="number">1</span>] - A[i-<span class="number">2</span>])&#123;<span class="comment">//从头到尾遍历数组</span></span><br><span class="line">                dp[i] = dp[i-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">total</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> cnt : dp)&#123;</span><br><span class="line">            total += cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="6-分割整数"><a href="#6-分割整数" class="headerlink" title="6 分割整数"></a>6 分割整数</h2><h3 id="6-1-分割整数的最大乘积"><a href="#6-1-分割整数的最大乘积" class="headerlink" title="6.1 分割整数的最大乘积"></a>6.1 分割整数的最大乘积</h3><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//状态转移方程： dp[i] = Math.max(dp[i], Math.max(j*dp[i-j], j*(i-j)))</span></span><br><span class="line"><span class="comment">//和自己比，和不同切的方式比，留下最大值</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">integerBreak</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(j*dp[i-j], j*(i-j)));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-最长上升子序列"><a href="#7-最长上升子序列" class="headerlink" title="7 最长上升子序列"></a>7 最长上升子序列</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//思路：动态规划 dp[i]存储当前的最大上升子序列，遍历前序dp，如果大于则dp[j]+1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLIS</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;<span class="comment">//遍历整数数组</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)&#123;<span class="comment">//计算当前最大上升子序列</span></span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;<span class="comment">//如果当前值比前面遍历到的大，最大上升子序列加一</span></span><br><span class="line">                    max = Math.max(max, dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = max;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> ret : dp)&#123;</span><br><span class="line">            result = Math.max(ret, result);   <span class="comment">//找出dp数组中的最大</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-1-剑指-Offer-46-把数字翻译成字符串"><a href="#7-1-剑指-Offer-46-把数字翻译成字符串" class="headerlink" title="7.1 剑指 Offer 46. 把数字翻译成字符串"></a>7.1 <a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof/">剑指 Offer 46. 把数字翻译成字符串</a></h3><p>给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(num);</span><br><span class="line">        <span class="comment">//dp[i-2] = b; dp[i-1] = a; dp[i] = c </span></span><br><span class="line">        <span class="comment">//对于一个字符串，如果最后两位可以被翻译，那么</span></span><br><span class="line">        <span class="comment">//dp[i] = dp[i-1] + dp[i-2]</span></span><br><span class="line">        <span class="comment">//否则dp[i] = dp[i-1]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从左往右递推</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> s.substring(i - <span class="number">2</span>, i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> tmp.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; tmp.compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> ? a + b : a;</span><br><span class="line">            b = a;</span><br><span class="line">            a = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-字符串相关"><a href="#8-字符串相关" class="headerlink" title="8 字符串相关"></a>8 字符串相关</h2><h3 id="8-1-72-编辑距离"><a href="#8-1-72-编辑距离" class="headerlink" title="8.1 72. 编辑距离"></a>8.1 <a href="https://leetcode-cn.com/problems/edit-distance/">72. 编辑距离</a></h3><p>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</p><p>你可以对一个单词进行如下三种操作：</p><p>插入一个字符<br>删除一个字符<br>替换一个字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dp[i][j]: word1中前i个单词变换到word2中前j个单词需要的最短操作次数</span></span><br><span class="line"><span class="comment">//考虑某一个单词是空的</span></span><br><span class="line"><span class="comment">//状态转移：</span></span><br><span class="line"><span class="comment">//增：dp[i][j] = dp[i][j-1] + 1</span></span><br><span class="line"><span class="comment">//删：dp[i][j] = dp[i-1][j] + 1</span></span><br><span class="line"><span class="comment">//改：dp[i][j] = dp[i-1][j-1] + 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> word1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> word2.length();</span><br><span class="line">        <span class="comment">// 多开一行一列是为了保存边界条件，即字符长度为 0 的情况，这一点在字符串的动态规划问题中比较常见</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 初始化：当 word2 长度为 0 时，将 word1 的全部删除即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当 word1 长度为 0 时，插入所有 word2 的字符即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 由于 word1.charAt(i) 操作会去检查下标是否越界，因此在 Java 里，将字符串转换成字符数组是常见额操作</span></span><br><span class="line">        <span class="type">char</span>[] word1Array = word1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] word2Array = word2.toCharArray();</span><br><span class="line">        <span class="comment">// 递推开始，注意：填写 dp 数组的时候，由于初始化多设置了一行一列，横纵坐标有个偏移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= len1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= len2; j++) &#123;</span><br><span class="line">                <span class="comment">// 这是最佳情况</span></span><br><span class="line">                <span class="comment">// 多开了一行，所以是 i-1 和 j-1</span></span><br><span class="line">                <span class="keyword">if</span> (word1Array[i - <span class="number">1</span>] == word2Array[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 否则在以下三种情况中选出步骤最少的，这是「动态规划」的「最优子结构」</span></span><br><span class="line">                <span class="comment">// 1、在下标 i 处插入一个字符</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">insert</span> <span class="operator">=</span> dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 2、替换一个字符</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">replace</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 3、删除一个字符</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">delete</span> <span class="operator">=</span> dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                dp[i][j] = Math.min(Math.min(insert, replace), delete);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="8-2-5-最长回文子串"><a href="#8-2-5-最长回文子串" class="headerlink" title="8.2 5. 最长回文子串"></a>8.2 <a href="https://leetcode-cn.com/problems/longest-palindromic-substring/">5. 最长回文子串</a></h3><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义状态 dp[i][j] 表示从 i 到 j 的字串是不是回文的</span></span><br><span class="line"><span class="comment">//状态转移方程 ：dp[i][j] = ( s[j] == s[j] ) &amp;&amp; dp[i+1][j-1]</span></span><br><span class="line"><span class="comment">//或者 j - i &lt; 3 的情况下 s[j] == s[j]</span></span><br><span class="line"><span class="comment">//初始化dp[i][i] = true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录最大长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录开始</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//表示从i到j是不是回文串</span></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="type">char</span>[] charArray = s.toCharArray();</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; len; i++)&#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; j; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(charArray[i] != charArray[j])&#123;</span><br><span class="line">                    dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(j - i &lt; <span class="number">3</span>)&#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        dp[i][j] = dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen)&#123;</span><br><span class="line">                maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start,start+maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Algorithm] Queue&amp;Stack</title>
      <link href="/2021/06/12/Algorithm/Queue&amp;Stack/"/>
      <url>/2021/06/12/Algorithm/Queue&amp;Stack/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="0-1-20-有效的括号"><a href="#0-1-20-有效的括号" class="headerlink" title="0.1 20. 有效的括号"></a>0.1 <a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h3><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串 s ，判断字符串是否有效。</p><p>用栈实现。如果是左括号直接压入栈，如果遇到右括号则弹出一个，如果不匹配直接输出false，如果匹配则继续。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>( c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">char</span> <span class="variable">cPop</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">b1</span> <span class="operator">=</span> c == <span class="string">&#x27;)&#x27;</span> &amp;&amp; cPop != <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">b2</span> <span class="operator">=</span> c == <span class="string">&#x27;]&#x27;</span> &amp;&amp; cPop != <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">b3</span> <span class="operator">=</span> c == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; cPop != <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span>(b1 || b2 || b3)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-2-42-接雨水"><a href="#0-2-42-接雨水" class="headerlink" title="0.2 42. 接雨水"></a>0.2 <a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h3><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对于某个位置 i，可以接的雨水是左侧最高和右侧最高的较小 减去当前高度</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (height.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 数组充当备忘录</span></span><br><span class="line">        <span class="type">int</span>[] l_max = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] r_max = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 初始化 base case</span></span><br><span class="line">        l_max[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        r_max[n - <span class="number">1</span>] = height[n - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 从左向右计算 l_max 包括 i 位置在内</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            l_max[i] = Math.max(height[i], l_max[i - <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 从右向左计算 r_max</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            r_max[i] = Math.max(height[i], r_max[i + <span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// 计算答案</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">            res += Math.min(l_max[i], r_max[i]) - height[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l_max</span> <span class="operator">=</span> <span class="number">0</span>, r_max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        l_max = Math.max(l_max, height[left]);</span><br><span class="line">        r_max = Math.max(r_max, height[right]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// res += min(l_max, r_max) - height[i]</span></span><br><span class="line">        <span class="keyword">if</span> (l_max &lt; r_max) &#123;</span><br><span class="line">            res += l_max - height[left];</span><br><span class="line">            left++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res += r_max - height[right];</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-3-11-盛最多水的容器"><a href="#0-3-11-盛最多水的容器" class="headerlink" title="0.3 11. 盛最多水的容器"></a>0.3 <a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h3><p>给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</p><p>找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p><p>返回容器可以储存的最大水量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = height.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// [left, right] 之间的矩形面积</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cur_area</span> <span class="operator">=</span> Math.min(height[left], height[right]) * (right - left);</span><br><span class="line">            res = Math.max(res, cur_area);</span><br><span class="line">            <span class="comment">// 双指针技巧，移动较低的一边</span></span><br><span class="line">            <span class="keyword">if</span> (height[left] &lt; height[right]) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-4-232-用栈实现队列"><a href="#0-4-232-用栈实现队列" class="headerlink" title="0.4 232. 用栈实现队列"></a>0.4 <a href="https://leetcode.cn/problems/implement-queue-using-stacks/">232. 用栈实现队列</a></h3><p>请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：</p><p>栈的顺序为后进先出，而队列的顺序为先进先出。使用两个栈实现队列，一个元素需要经过两个栈才能出队列，在经过第一个栈时元素顺序被反转，经过第二个栈时再次被反转，此时就是先进先出顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; in;</span><br><span class="line">    Stack&lt;Integer&gt; out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        in = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        out = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        in.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        in2out();</span><br><span class="line">        <span class="keyword">return</span> out.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        in2out();</span><br><span class="line">        <span class="keyword">return</span> out.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">in2out</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(out.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(!in.isEmpty())&#123;</span><br><span class="line">                out.push(in.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> in.isEmpty() &amp;&amp; out.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-5-225-用队列实现栈"><a href="#0-5-225-用队列实现栈" class="headerlink" title="0.5 225. 用队列实现栈"></a>0.5 <a href="https://leetcode.cn/problems/implement-stack-using-queues/">225. 用队列实现栈</a></h3><p>请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。</p><p>在将一个元素 x 插入队列时，为了维护原来的后进先出顺序，需要让 x 插入队列首部。而队列的默认插入顺序是队列尾部，因此在将 x 插入队列尾部之后，需要让除了 x 之外的所有元素出队列，再入队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyStack</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        queue.add(x);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            queue.add(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-6-1047-删除字符串中的所有相邻重复项"><a href="#0-6-1047-删除字符串中的所有相邻重复项" class="headerlink" title="0.6 1047. 删除字符串中的所有相邻重复项"></a>0.6 <a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/">1047. 删除字符串中的所有相邻重复项</a></h3><p>给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。在 S 上反复执行重复项删除操作，直到无法继续删除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        Deque&lt;Character&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : cs) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!d.isEmpty() &amp;&amp; d.peekLast().equals(c)) &#123;</span><br><span class="line">                d.pollLast();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                d.addLast(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (!d.isEmpty()) sb.append(d.pollLast());</span><br><span class="line">        sb.reverse();</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-7-316-去除重复字母"><a href="#0-7-316-去除重复字母" class="headerlink" title="0.7 316. 去除重复字母"></a>0.7 <a href="https://leetcode.cn/problems/remove-duplicate-letters/">316. 去除重复字母</a></h3><p>给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 返回结果的字典序最小（要求不能打乱其他字符的相对位置）。</p><p>要利用 stack 结构和一个 inStack 布尔数组来满足上述三个条件，具体思路如下：</p><p>通过 inStack 这个布尔数组做到栈 stk 中不存在重复元素，满足要求一。</p><p>我们顺序遍历字符串 s，通过「栈」这种顺序结构的 push/pop 操作记录结果字符串，保证了字符出现的顺序和 s 中出现的顺序一致，满足要求二。</p><p>我们用类似单调栈的思路，配合计数器 count 不断 pop 掉不符合最小字典序的字符，保证了最终得到的结果字典序最小，满足要求三。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicateLetters</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Stack&lt;Character&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 维护一个计数器记录字符串中字符的数量</span></span><br><span class="line">        <span class="comment">// 因为输入为 ASCII 字符，大小 256 够用了</span></span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            count[s.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] inStack = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">// 每遍历过一个字符，都将对应的计数减一</span></span><br><span class="line">            count[c]--;</span><br><span class="line">            <span class="keyword">if</span> (inStack[c]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 如果当前栈顶的比 c 大，并且还有重复的，那就 pop 出来</span></span><br><span class="line">            <span class="keyword">while</span> (!stk.isEmpty() &amp;&amp; stk.peek() &gt; c) &#123;</span><br><span class="line">                <span class="comment">// 若之后不存在栈顶元素了，则停止 pop</span></span><br><span class="line">                <span class="keyword">if</span> (count[stk.peek()] == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 若之后还有，则可以 pop</span></span><br><span class="line">                inStack[stk.pop()] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(c);</span><br><span class="line">            inStack[c] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty()) &#123;</span><br><span class="line">            sb.append(stk.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-8-155-最小栈"><a href="#0-8-155-最小栈" class="headerlink" title="0.8 155. 最小栈"></a>0.8 <a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></h3><p>设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。</p><p>两个栈：保持两个栈的大小相等。压栈时，一个压数据，另一个压目前入栈的最小值；而出栈时，一起弹出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    Stack&lt;Integer&gt; dataStack;</span><br><span class="line">    Stack&lt;Integer&gt; minStack;</span><br><span class="line">    <span class="type">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        dataStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        min = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        dataStack.push(x);</span><br><span class="line">        min = Math.min(min,x);</span><br><span class="line">        minStack.push(min);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        dataStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">        <span class="keyword">if</span>(minStack.isEmpty()) min = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">else</span> min = minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dataStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-9-496-下一个更大元素-I-单调栈"><a href="#0-9-496-下一个更大元素-I-单调栈" class="headerlink" title="0.9 496. 下一个更大元素 I 单调栈"></a>0.9 <a href="https://leetcode.cn/problems/next-greater-element-i/">496. 下一个更大元素 I</a> 单调栈</h3><p>nums1 中数字 x 的 下一个更大元素 是指 x 在 nums2 中对应位置 右侧 的 第一个 比 x 大的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把 nums2 中每个元素的下一个更大元素算出来存到一个映射里</span></span><br><span class="line"><span class="comment">// 然后再让 nums1 中的元素去查表即可。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums1, <span class="type">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// 记录 nums2 中每个元素的下一个更大元素</span></span><br><span class="line">        <span class="type">int</span>[] greater = nextGreaterElement(nums2);</span><br><span class="line">        <span class="comment">// 转化成映射：元素 x -&gt; x 的下一个最大元素</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; greaterMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums2.length; i++) &#123;</span><br><span class="line">            greaterMap.put(nums2[i], greater[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums1 是 nums2 的子集，所以根据 greaterMap 可以得到结果</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums1.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums1.length; i++) &#123;</span><br><span class="line">            res[i] = greaterMap.get(nums1[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算 nums 中每个元素的下一个更大元素</span></span><br><span class="line">    <span class="type">int</span>[] nextGreaterElement(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// 存放答案的数组</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 倒着往栈里放</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 判定个子高矮</span></span><br><span class="line">            <span class="keyword">while</span> (!s.isEmpty() &amp;&amp; s.peek() &lt;= nums[i]) &#123;</span><br><span class="line">                <span class="comment">// 矮个起开，反正也被挡着了。。。</span></span><br><span class="line">                s.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// nums[i] 身后的下一个更大元素</span></span><br><span class="line">            res[i] = s.isEmpty() ? -<span class="number">1</span> : s.peek();</span><br><span class="line">            s.push(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-10-503-下一个更大元素-II-单调栈"><a href="#0-10-503-下一个更大元素-II-单调栈" class="headerlink" title="0.10 503. 下一个更大元素 II  单调栈"></a>0.10 <a href="https://leetcode.cn/problems/next-greater-element-ii/">503. 下一个更大元素 II</a>  单调栈</h3><p>给定一个循环数组 nums （ nums[nums.length - 1] 的下一个元素是 nums[0] ），返回 nums 中每个元素的 下一个更大元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里需要迭代两遍，而且输出的是更大的数而不是距离。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] nextGreaterElements(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">2</span>*n; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[i%n] &gt; nums[stack.peek()])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                result[pre] = nums[i%n];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n)&#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result[pre] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-11-739-每日温度-单调栈"><a href="#0-11-739-每日温度-单调栈" class="headerlink" title="0.11 739. 每日温度  单调栈"></a>0.11 <a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a>  单调栈</h3><p>给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用单调栈维护一个递减序列, 从后往前进行遍历</span></span><br><span class="line"><span class="comment">// 若当前元素小于栈顶，那么栈顶就是下一个更高温度，</span></span><br><span class="line"><span class="comment">// 再将当前温度入栈,继续寻找下一个</span></span><br><span class="line"><span class="comment">// 若栈空后仍无法找到比当前元素高的温度则为0.</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="comment">// 这里放元素索引，而不是元素</span></span><br><span class="line">    Stack&lt;Integer&gt; s = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;(); </span><br><span class="line">    <span class="comment">// 倒着入栈</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 如果不是递减就出栈</span></span><br><span class="line">        <span class="keyword">while</span> (!s.isEmpty() &amp;&amp; temperatures[s.peek()] &lt;= temperatures[i]) &#123;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到索引间距</span></span><br><span class="line">        res[i] = s.isEmpty() ? <span class="number">0</span> : (s.peek() - i); </span><br><span class="line">        <span class="comment">// 将索引入栈，而不是元素</span></span><br><span class="line">        s.push(i); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-12-402-移掉-K-位数字"><a href="#0-12-402-移掉-K-位数字" class="headerlink" title="0.12 402. 移掉 K 位数字"></a>0.12 <a href="https://leetcode.cn/problems/remove-k-digits/">402. 移掉 K 位数字</a></h3><p>给你一个以字符串表示的非负整数 num 和一个整数 k ，移除这个数中的 k 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 选择使用单调栈，使得剩下的数字是单调递增的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeKdigits</span><span class="params">(String num, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        Deque&lt;Character&gt; stk = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : num.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stk.isEmpty() &amp;&amp; c &lt; stk.getLast() &amp;&amp; k &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                stk.pollLast();</span><br><span class="line">                k--;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.addLast(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> stk.stream().map(Object::toString).collect(Collectors.joining());</span><br><span class="line">        res = res.substring(<span class="number">0</span>, res.length() - k).replaceAll(<span class="string">&quot;^0+&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res.isEmpty() ? <span class="string">&quot;0&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-13-71-简化路径"><a href="#0-13-71-简化路径" class="headerlink" title="0.13 71. 简化路径"></a>0.13 <a href="https://leetcode.cn/problems/simplify-path/">71. 简化路径</a></h3><p>给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 ‘/‘ 开头），请你将其转化为更加简洁的规范路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">simplifyPath</span><span class="params">(String path)</span> &#123;</span><br><span class="line">        String[] parts = path.split(<span class="string">&quot;/&quot;</span>);</span><br><span class="line">        Stack&lt;String&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 借助栈计算最终的文件夹路径</span></span><br><span class="line">        <span class="keyword">for</span> (String part : parts) &#123;</span><br><span class="line">            <span class="keyword">if</span> (part.isEmpty() || part.equals(<span class="string">&quot;.&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (part.equals(<span class="string">&quot;..&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stk.isEmpty()) stk.pop();</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            stk.push(part);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 栈中存储的文件夹组成路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stk.isEmpty()) &#123;</span><br><span class="line">            res = <span class="string">&quot;/&quot;</span> + stk.pop() + res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.isEmpty() ? <span class="string">&quot;/&quot;</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-14-394-字符串解码"><a href="#0-14-394-字符串解码" class="headerlink" title="0.14 394. 字符串解码"></a>0.14 <a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h3><p>给定一个经过编码的字符串，返回它解码后的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">构建辅助栈 stack， 遍历字符串 s 中每个字符 c；</span><br><span class="line">当 c 为数字时，将数字字符转化为数字 multi，用于后续倍数计算；</span><br><span class="line">当 c 为字母时，在 res 尾部添加 c；</span><br><span class="line">当 c 为 [ 时，将当前 multi 和 res 入栈，并分别置空置 <span class="number">00</span>：</span><br><span class="line">记录此 [ 前的临时结果 res 至栈，用于发现对应 ] 后的拼接操作；</span><br><span class="line">记录此 [ 前的倍数 multi 至栈，用于发现对应 ] 后，获取 multi × [...] 字符串。</span><br><span class="line">进入到新 [ 后，res 和 multi 重新记录。</span><br><span class="line">当 c 为 ] 时，stack 出栈，拼接字符串 res = last_res + cur_multi * res，其中:</span><br><span class="line">last_res是上个 [ 到当前 [ 的字符串，例如 <span class="string">&quot;3[a2[c]]&quot;</span> 中的 a；</span><br><span class="line">cur_multi是当前 [ 到 ] 内字符串的重复倍数，例如 <span class="string">&quot;3[a2[c]]&quot;</span> 中的 <span class="number">2</span>。</span><br><span class="line">返回字符串 res。</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">multi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; stack_multi = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        LinkedList&lt;String&gt; stack_res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Character c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">                stack_multi.addLast(multi);</span><br><span class="line">                stack_res.addLast(res.toString());</span><br><span class="line">                multi = <span class="number">0</span>;</span><br><span class="line">                res = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">                <span class="type">StringBuilder</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                <span class="type">int</span> <span class="variable">cur_multi</span> <span class="operator">=</span> stack_multi.removeLast();</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cur_multi; i++) tmp.append(res);</span><br><span class="line">                res = <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(stack_res.removeLast() + tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span>) multi = multi * <span class="number">10</span> + Integer.parseInt(c + <span class="string">&quot;&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> res.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-15-84-柱状图中最大的矩形"><a href="#0-15-84-柱状图中最大的矩形" class="headerlink" title="0.15 84. 柱状图中最大的矩形"></a>0.15 <a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h3><p>给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。</p><p>求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><ul><li>遇到了当前柱形的高度比它上一个柱形的高度严格小的时候，一定可以确定它之前的某些柱形的最大宽度，并且确定的柱形宽度的顺序是从右边向左边。</li><li>这个现象告诉我们，在遍历的时候需要记录的信息就是遍历到的柱形的下标，它一左一右的两个柱形的下标的差就是这个面积最大的矩形对应的最大宽度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="comment">// 特殊情况判断</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> heights[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] newHeights = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 在两端加上高度为 0 的两根柱子，避免出现栈到最后不为空</span></span><br><span class="line">        newHeights[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        System.arraycopy(heights, <span class="number">0</span>, newHeights, <span class="number">1</span>, len);</span><br><span class="line">        newHeights[len + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        len += <span class="number">2</span>;</span><br><span class="line">        heights = newHeights;</span><br><span class="line"></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;(len);</span><br><span class="line">        <span class="comment">// 先放入哨兵，在循环里就不用做非空判断</span></span><br><span class="line">        stack.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前的高度比之前的小，可以之前的高度对应的面积</span></span><br><span class="line">            <span class="keyword">while</span> (heights[i] &lt; heights[stack.peekLast()]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">curHeight</span> <span class="operator">=</span> heights[stack.pollLast()];</span><br><span class="line">                <span class="type">int</span> <span class="variable">curWidth</span> <span class="operator">=</span> i - stack.peekLast() - <span class="number">1</span>;</span><br><span class="line">                res = Math.max(res, curHeight * curWidth);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果高度继续增加，继续存对应的下标</span></span><br><span class="line">            stack.addLast(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// int[] heights = &#123;2, 1, 5, 6, 2, 3&#125;;</span></span><br><span class="line">        <span class="type">int</span>[] heights = &#123;<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">Solution</span> <span class="variable">solution</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> solution.largestRectangleArea(heights);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-16-85-最大矩形-hard"><a href="#0-16-85-最大矩形-hard" class="headerlink" title="0.16 85. 最大矩形 hard"></a>0.16 <a href="https://leetcode.cn/problems/maximal-rectangle/">85. 最大矩形</a> hard</h3><p>给定一个仅包含 0 和 1 、大小为 rows x cols 的二维二进制矩阵，找出只包含 1 的最大矩形，并返回其面积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历每行的高度,用上一题方法(栈)求出最大矩形!</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="literal">null</span> || matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// row 行 col 列</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] height = <span class="keyword">new</span> <span class="title class_">int</span>[col + <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; col + <span class="number">2</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= <span class="number">1</span> &amp;&amp; j &lt;= col) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (matrix[i][j-<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) height[j] += <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> height[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; height[stack.peek()] &gt; height[j]) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                    res = Math.max(res, (j - stack.peek() - <span class="number">1</span>) * height[cur]);</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-17-224-基本计算器"><a href="#0-17-224-基本计算器" class="headerlink" title="0.17 224. 基本计算器"></a>0.17 <a href="https://leetcode.cn/problems/basic-calculator/">224. 基本计算器</a></h3><p>s 由数字、 + 、 -、(  、 )、和 ‘   ‘ 组成</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 存放所有的数字</span></span><br><span class="line">        Deque&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 为了防止第一个数为负数，先往 nums 加个 0</span></span><br><span class="line">        nums.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 将所有的空格去掉</span></span><br><span class="line">        s = s.replaceAll(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="comment">// 存放所有的操作，包括 +/-</span></span><br><span class="line">        Deque&lt;Character&gt; ops = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="comment">// 主逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> cs[i];</span><br><span class="line">            <span class="comment">// 如果是左括号，放入 ops</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ops.addLast(c);</span><br><span class="line">        <span class="comment">// 如果是右括号，计算一轮，直到碰到左括号</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 计算到最近一个左括号为止</span></span><br><span class="line">                <span class="keyword">while</span> (!ops.isEmpty()) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">op</span> <span class="operator">=</span> ops.peekLast();</span><br><span class="line">                    <span class="keyword">if</span> (op != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        calc(nums, ops);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 左括号出栈</span></span><br><span class="line">                        ops.pollLast();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是数字，连续取出，入栈</span></span><br><span class="line">                <span class="keyword">if</span> (isNum(c)) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">                    <span class="comment">// 将从 i 位置开始后面的连续数字整体取出，加入 nums</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; n &amp;&amp; isNum(cs[j])) u = u * <span class="number">10</span> + (<span class="type">int</span>)(cs[j++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    nums.addLast(u);</span><br><span class="line">                    i = j - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果是操作符 入栈</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (cs[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> || cs[i - <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> || cs[i - <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">                        nums.addLast(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 有一个新操作要入栈时，先把栈内可以算的都算了</span></span><br><span class="line">                    <span class="keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="string">&#x27;(&#x27;</span>) calc(nums, ops);</span><br><span class="line">                    ops.addLast(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!ops.isEmpty()) calc(nums, ops);</span><br><span class="line">        <span class="keyword">return</span> nums.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算方法</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">calc</span><span class="params">(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ops.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> nums.pollLast(), a = nums.pollLast();</span><br><span class="line">        <span class="type">char</span> <span class="variable">op</span> <span class="operator">=</span> ops.pollLast();</span><br><span class="line">        nums.addLast(op == <span class="string">&#x27;+&#x27;</span> ? a + b : a - b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断数字</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNum</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Character.isDigit(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-18-227-基本计算器-II"><a href="#0-18-227-基本计算器-II" class="headerlink" title="0.18 227. 基本计算器 II"></a>0.18 <a href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II</a></h3><p>给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。</p><p>整数除法仅保留整数部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">对于「任何表达式」而言，我们都使用两个栈 nums 和 ops：</span><br><span class="line">nums ： 存放所有的数字</span><br><span class="line">ops ：存放所有的数字以外的操作</span><br><span class="line">然后从前往后做，对遍历到的字符做分情况讨论：</span><br><span class="line">空格 : 跳过</span><br><span class="line">( : 直接加入 ops 中，等待与之匹配的 )</span><br><span class="line">) : 使用现有的 nums 和 ops 进行计算，直到遇到左边最近的一个左括号为止，计算结果放到 nums</span><br><span class="line">数字 : 从当前位置开始继续往后取，将整一个连续数字整体取出，加入 nums</span><br><span class="line">+ - * / ^ % : 需要将操作放入 ops 中。在放入之前先把栈内可以算的都算掉（只有「栈内运算符」比「当前运算符」优先级高/同等，才进行运算），使用现有的 nums 和 ops 进行计算，</span><br><span class="line"></span><br><span class="line">    比如当前栈内是➕号，但是后面出现了比如 * ，那就不能先算 <span class="number">1</span>+<span class="number">2</span>*<span class="number">3</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 map 维护一个运算符优先级</span></span><br><span class="line">    <span class="comment">// 这里的优先级划分按照「数学」进行划分即可</span></span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;()&#123;&#123;</span><br><span class="line">        put(<span class="string">&#x27;-&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">&#x27;+&#x27;</span>, <span class="number">1</span>);</span><br><span class="line">        put(<span class="string">&#x27;*&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        put(<span class="string">&#x27;/&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        put(<span class="string">&#x27;%&#x27;</span>, <span class="number">2</span>);</span><br><span class="line">        put(<span class="string">&#x27;^&#x27;</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 将所有的空格去掉</span></span><br><span class="line">        s = s.replaceAll(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="type">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 存放所有的数字</span></span><br><span class="line">        Deque&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 为了防止第一个数为负数，先往 nums 加个 0</span></span><br><span class="line">        nums.addLast(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 存放所有「非数字以外」的操作</span></span><br><span class="line">        Deque&lt;Character&gt; ops = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> cs[i];</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                ops.addLast(c);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 计算到最近一个左括号为止</span></span><br><span class="line">                <span class="keyword">while</span> (!ops.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (ops.peekLast() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        calc(nums, ops);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        ops.pollLast();</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isNumber(c)) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">                    <span class="comment">// 将从 i 位置开始后面的连续数字整体取出，加入 nums</span></span><br><span class="line">                    <span class="keyword">while</span> (j &lt; n &amp;&amp; isNumber(cs[j])) u = u * <span class="number">10</span> + (cs[j++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                    nums.addLast(u);</span><br><span class="line">                    i = j - <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; (cs[i - <span class="number">1</span>] == <span class="string">&#x27;(&#x27;</span> || cs[i - <span class="number">1</span>] == <span class="string">&#x27;+&#x27;</span> || cs[i - <span class="number">1</span>] == <span class="string">&#x27;-&#x27;</span>)) &#123;</span><br><span class="line">                        nums.addLast(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 有一个新操作要入栈时，先把栈内可以算的都算了 </span></span><br><span class="line">                    <span class="comment">// 只有满足「栈内运算符」比「当前运算符」优先级高/同等，才进行运算</span></span><br><span class="line">                    <span class="keyword">while</span> (!ops.isEmpty() &amp;&amp; ops.peekLast() != <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                        <span class="type">char</span> <span class="variable">prev</span> <span class="operator">=</span> ops.peekLast();</span><br><span class="line">                        <span class="comment">// 判断优先级</span></span><br><span class="line">                        <span class="keyword">if</span> (map.get(prev) &gt;= map.get(c)) &#123;</span><br><span class="line">                            calc(nums, ops);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ops.addLast(c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将剩余的计算完</span></span><br><span class="line">        <span class="keyword">while</span> (!ops.isEmpty()) calc(nums, ops);</span><br><span class="line">        <span class="keyword">return</span> nums.peekLast();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算逻辑</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">calc</span><span class="params">(Deque&lt;Integer&gt; nums, Deque&lt;Character&gt; ops)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.isEmpty() || nums.size() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (ops.isEmpty()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> nums.pollLast(), a = nums.pollLast();</span><br><span class="line">        <span class="type">char</span> <span class="variable">op</span> <span class="operator">=</span> ops.pollLast();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;+&#x27;</span>) ans = a + b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;-&#x27;</span>) ans = a - b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;*&#x27;</span>) ans = a * b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;/&#x27;</span>)  ans = a / b;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;^&#x27;</span>) ans = (<span class="type">int</span>)Math.pow(a, b);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;%&#x27;</span>) ans = a % b;</span><br><span class="line">        nums.addLast(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(<span class="type">char</span> c)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Character.isDigit(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-19-150-逆波兰表达式求值"><a href="#0-19-150-逆波兰表达式求值" class="headerlink" title="0.19 150. 逆波兰表达式求值"></a>0.19 <a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值</a></h3><p>根据 逆波兰表示法，求表达式的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String token : tokens) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;+-*/&quot;</span>.contains(token)) &#123;</span><br><span class="line">                <span class="comment">// 是个运算符，从栈顶拿出两个数字进行运算，运算结果入栈</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> stk.pop(), b = stk.pop();</span><br><span class="line">                <span class="keyword">switch</span> (token) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                        stk.push(a + b);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                        stk.push(a * b);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">// 对于减法和除法，顺序别搞反了，第二个数是被除（减）数</span></span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                        stk.push(b - a);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                        stk.push(b / a);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 是个数字，直接入栈即可</span></span><br><span class="line">                stk.push(Integer.parseInt(token));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后栈中剩下一个数字，即是计算结果</span></span><br><span class="line">        <span class="keyword">return</span> stk.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-20-面试题59-II-队列的最大值"><a href="#0-20-面试题59-II-队列的最大值" class="headerlink" title="0.20 面试题59 - II. 队列的最大值"></a>0.20 <a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/">面试题59 - II. 队列的最大值</a></h3><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建一个递减列表来保存队列 所有递减的元素 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    Deque&lt;Integer&gt; deque;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max_value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deque.isEmpty() ? -<span class="number">1</span> : deque.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        queue.offer(value);</span><br><span class="line">        <span class="comment">// 如果入队的比当前最小的大，不停弹出，知道有序</span></span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; value)</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        deque.offerLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop_front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(queue.peek().equals(deque.peekFirst()))</span><br><span class="line">            deque.pollFirst();</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-21-946-验证栈序列"><a href="#0-21-946-验证栈序列" class="headerlink" title="0.21 946. 验证栈序列"></a>0.21 <a href="https://leetcode.cn/problems/validate-stack-sequences/">946. 验证栈序列</a></h3><p>给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。</p><ul><li>根据题意，利用元素各不相同，我们使用一个栈来处理 pushed 数组，每次将 pushed[i] 放入栈中，然后比较当前栈顶元素是否与待弹出元素相同（使用变量 j 来代指当前待弹出元素下标），若相等则弹栈并进行 j 自增，当所有的元素处理完后，栈为空说明栈序列合法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">        Deque&lt;Integer&gt; d = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; pushed.length; i++) &#123;</span><br><span class="line">            d.addLast(pushed[i]);</span><br><span class="line">            <span class="keyword">while</span> (!d.isEmpty() &amp;&amp; d.peekLast() == popped[j] &amp;&amp; ++j &gt;= <span class="number">0</span>) d.pollLast(); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> d.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Algorithm] Binary Search</title>
      <link href="/2021/06/12/Algorithm/Binary%20Search/"/>
      <url>/2021/06/12/Algorithm/Binary%20Search/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><p>二分查找就是不断缩小搜索区间的过程，要注意到区间内的元素不能遗漏</p><h2 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1 时间复杂度"></a>1 时间复杂度</h2><p>二分查找也称为折半查找，每次都能将查找区间减半，这种折半特性的算法时间复杂度为 O(logN)。</p><h2 id="2-二分查找框架"><a href="#2-二分查找框架" class="headerlink" title="2 二分查找框架"></a>2 二分查找框架</h2><p>注意循环不变量</p><h4 id="2-1-1-第一种："><a href="#2-1-1-第一种：" class="headerlink" title="2.1.1 第一种："></a>2.1.1 第一种：</h4><p>如果定义在一个左闭右闭的区间里，也就是[left,right];<br>循环结束条件： left &gt; right</p><p>[left, middle - 1]    [middle + 1, right]</p><p>right = mid - 1</p><p>left = mid + 1</p><h4 id="2-1-2-第二种：在一个在左闭右开的区间里，也就是-left-right"><a href="#2-1-2-第二种：在一个在左闭右开的区间里，也就是-left-right" class="headerlink" title="2.1.2 第二种：在一个在左闭右开的区间里，也就是[left, right)"></a>2.1.2 第二种：在一个在左闭右开的区间里，也就是[left, right)</h4><p>循环结束条件： left &lt; right</p><p>[left, middle)    [middle+1, right)</p><p>right  = mid</p><p>left = mid + 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;  <span class="comment">//防止直接相加出现溢出的情况</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-寻找一个数"><a href="#3-寻找一个数" class="headerlink" title="3 寻找一个数"></a>3 寻找一个数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; </span><br><span class="line">    <span class="comment">//循环跳出时，left = right + 1，搜索区间为[right+1,right],也就是说right取到了，right+1没有取到</span></span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;   <span class="comment">//因为right是可以取到的，所以要有=号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>; <span class="comment">//因为mid是判断过的，所以可以跳过</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target)</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-寻找左侧边界的二分搜索"><a href="#4-寻找左侧边界的二分搜索" class="headerlink" title="4 寻找左侧边界的二分搜索"></a>4 寻找左侧边界的二分搜索</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length; <span class="comment">// 右侧是取不到的，[left,right)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123; <span class="comment">// 中止时left==right，但是不是闭区间，可以跳出</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;  </span><br><span class="line">            right = mid;<span class="comment">//找到target后，缩小上界，不断向左收缩</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;  <span class="comment">//[left,mid) [mid+1,right)</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid; <span class="comment">// 注意</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果找不到目标值</span></span><br><span class="line"><span class="comment">// target 比所有数都大</span></span><br><span class="line"><span class="keyword">if</span> (left == nums.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : -<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="5-寻找右侧边界的二分搜索"><a href="#5-寻找右侧边界的二分搜索" class="headerlink" title="5 寻找右侧边界的二分搜索"></a>5 寻找右侧边界的二分搜索</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length;  <span class="comment">//[left,right)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;<span class="comment">//[left,mid) [mid+1,right),因为mid已经判断过，所以跳过</span></span><br><span class="line">            left = mid + <span class="number">1</span>;   <span class="comment">//如果找到，缩小下界，同时向右收缩</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;<span class="comment">//[left,mid) [mid+1,right)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left - <span class="number">1</span>; <span class="comment">//因为更新的是left = mid + 1，所以 mid = left - 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-逻辑统一"><a href="#6-逻辑统一" class="headerlink" title="6 逻辑统一"></a>6 逻辑统一</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基本二分</span></span><br><span class="line">因为我们初始化 right = nums.length - <span class="number">1</span></span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right]</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">同时也决定了 left = mid+<span class="number">1</span> 和 right = mid-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">因为我们只需找到一个 target 的索引即可</span><br><span class="line">所以当 nums[mid] == target 时可以立即返回</span><br><span class="line">    </span><br><span class="line"><span class="comment">//左侧边界</span></span><br><span class="line">因为我们初始化 right = nums.length</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + <span class="number">1</span> 和 right = mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最左侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧右侧边界以锁定左侧边界</span><br><span class="line"></span><br><span class="line"><span class="comment">//右侧边界</span></span><br><span class="line">因为我们初始化 right = nums.length</span><br><span class="line">所以决定了我们的「搜索区间」是 [left, right)</span><br><span class="line">所以决定了 <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">同时也决定了 left = mid + <span class="number">1</span> 和 right = mid</span><br><span class="line"></span><br><span class="line">因为我们需找到 target 的最右侧索引</span><br><span class="line">所以当 nums[mid] == target 时不要立即返回</span><br><span class="line">而要收紧左侧边界以锁定右侧边界</span><br><span class="line"></span><br><span class="line">又因为收紧左侧边界时必须 left = mid + <span class="number">1</span></span><br><span class="line">所以最后无论返回 left 还是 right，必须减一                 </span><br></pre></td></tr></table></figure><h3 id="6-1-合并为闭区间"><a href="#6-1-合并为闭区间" class="headerlink" title="6.1 合并为闭区间"></a>6.1 合并为闭区间</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">binary_search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接返回</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定左侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后要检查 left 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定右侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后要检查 right 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-例题"><a href="#7-例题" class="headerlink" title="7 例题"></a>7 例题</h2><h3 id="7-1-69-x-的平方根"><a href="#7-1-69-x-的平方根" class="headerlink" title="7.1 69. x 的平方根"></a>7.1 <a href="https://leetcode-cn.com/problems/sqrtx/">69. x 的平方根</a></h3><p>实现 <code>int sqrt(int x)</code> 函数。</p><p>计算并返回 <em>x</em> 的平方根，其中 <em>x</em> 是非负整数。</p><p>由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在left &lt;= right的情况下，结束时 left = right + 1</span></span><br><span class="line"><span class="comment">//需要的是小的那个</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>, right = x;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sqrt</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(sqrt == x/sqrt)&#123;</span><br><span class="line">                <span class="keyword">return</span> sqrt;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sqrt &gt; x/sqrt)&#123;</span><br><span class="line">                right = sqrt - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sqrt &lt; x/sqrt)&#123;</span><br><span class="line">                left = sqrt + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-2-744-寻找比目标字母大的最小字母"><a href="#7-2-744-寻找比目标字母大的最小字母" class="headerlink" title="7.2 744. 寻找比目标字母大的最小字母"></a>7.2 <a href="https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/">744. 寻找比目标字母大的最小字母</a></h3><p>给你一个排序后的字符列表 <code>letters</code> ，列表中只包含小写英文字母。另给出一个目标字母 <code>target</code>，请你寻找在这一有序列表里比目标字母大的最小字母。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">nextGreatestLetter</span><span class="params">(<span class="type">char</span>[] letters, <span class="type">char</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> letters.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span> ,high = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[mid] &lt;= target)&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(low &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">return</span> letters[<span class="number">0</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> letters[low];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-540-有序数组中的单一元素"><a href="#7-3-540-有序数组中的单一元素" class="headerlink" title="7.3 540. 有序数组中的单一元素"></a>7.3 <a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array/">540. 有序数组中的单一元素</a></h3><p>给定一个只包含整数的有序数组，每个元素都会出现两次，唯有一个数只会出现一次，找出这个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果前面不包含单个的，那么偶数位置的数肯定是和后面一个相等</span></span><br><span class="line"><span class="comment">//如果相等，说明在后面 left = mid + 2</span></span><br><span class="line"><span class="comment">//如果不相等，说明在前面，right = mid</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNonDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//保证m是偶数</span></span><br><span class="line">            <span class="keyword">if</span>(mid % <span class="number">2</span> == <span class="number">1</span>)&#123;</span><br><span class="line">                mid--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == nums[mid + <span class="number">1</span>])&#123;</span><br><span class="line">                left = mid + <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[right];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-4-278-第一个错误的版本"><a href="#7-4-278-第一个错误的版本" class="headerlink" title="7.4 278. 第一个错误的版本"></a>7.4 <a href="https://leetcode-cn.com/problems/first-bad-version/">278. 第一个错误的版本</a></h3><p>你是产品经理，目前正在带领一个团队开发新的产品。不幸的是，你的产品的最新版本没有通过质量检测。由于每个版本都是基于之前的版本开发的，所以错误的版本之后的所有版本都是错的。</p><p>假设你有 n 个版本 [1, 2, …, n]，你想找出导致之后所有版本出错的第一个错误的版本。</p><p>你可以通过调用 bool isBadVersion(version) 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。你应该尽量减少对调用 API 的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> <span class="keyword">extends</span> <span class="title class_">VersionControl</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstBadVersion</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">1</span>,right = n;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid) == <span class="literal">false</span>)&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-5-153-寻找旋转排序数组中的最小值"><a href="#7-5-153-寻找旋转排序数组中的最小值" class="headerlink" title="7.5 153. 寻找旋转排序数组中的最小值"></a>7.5 <a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h3><p>假设按照升序排序的数组在预先未知的某个点上进行了旋转。例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] 。</p><p>请找出其中最小的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMin</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;<span class="comment">//左闭右闭区间，如果用右开区间则不方便判断右值 </span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;<span class="comment">//循环不变式，如果left == right，则循环结束 </span></span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;<span class="comment">//地板除，mid更靠近left</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[right]) &#123;<span class="comment">//中值 &gt; 右值，最小值在右半边，收缩左边界</span></span><br><span class="line">                left = mid + <span class="number">1</span>;<span class="comment">//因为中值 &gt; 右值，中值肯定不是最小值，左边界可以跨过mid </span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; nums[right]) &#123;<span class="comment">//明确中值 &lt; 右值，最小值在左半边，收缩右边界 */ </span></span><br><span class="line">                right = mid;<span class="comment">//因为中值 &lt; 右值，中值也可能是最小值，右边界只能取到mid处 */ </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left];<span class="comment">//循环结束，left == right，最小值输出nums[left]或nums[right]均可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-6-34-在排序数组中查找元素的第一个和最后一个位置"><a href="#7-6-34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="7.6 34. 在排序数组中查找元素的第一个和最后一个位置"></a>7.6 <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h3><p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//寻找target的最左侧边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> binarySearch(nums,target);</span><br><span class="line">        <span class="comment">//寻找target+1的最左侧边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> binarySearch(nums,target+<span class="number">1</span>) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(start == nums.length || nums[start] != target)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start,Math.max(start,end)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//寻找左侧边界</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">binarySearch</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>,right = nums.length;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target)&#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Algorithm] LinkedList</title>
      <link href="/2021/06/12/Algorithm/LinkedList/"/>
      <url>/2021/06/12/Algorithm/LinkedList/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="1-链表"><a href="#1-链表" class="headerlink" title="1 链表"></a>1 链表</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Definition for singly-linked list.</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SinglyListNode</span> &#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    SinglyListNode next;</span><br><span class="line">    SinglyListNode(<span class="type">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-206-反转链表"><a href="#1-2-206-反转链表" class="headerlink" title="1.2 206. 反转链表 *"></a>1.2 <a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a> *</h3><p>题目：反转一个单链表</p><p>1.双指针迭代</p><p>从前向后反转</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// cur 是当前需要翻转的节点</span></span><br><span class="line">        <span class="comment">// pre 是 cur 的前一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head, pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 记录 cur 的下一个节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后 cur 是 null, pre 是新链表的 head</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.递归</p><p>从后往前反转</p><p>终止条件是当前节点或者下一个节点==null<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"><span class="comment">//递归终止条件是当前为空，或者下一个节点为空</span></span><br><span class="line"><span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// cur 从头到尾是不变的 都是指向最后递归结束时的</span></span><br><span class="line"><span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reverseList(head.next);</span><br><span class="line">head.next.next = head;</span><br><span class="line"><span class="comment">//防止链表循环，需要将head.next设置为空</span></span><br><span class="line">head.next = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">//每层递归函数都返回cur，也就是最后一个节点</span></span><br><span class="line"><span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reverseList(<span class="number">5</span>) 中 head=<span class="number">5</span>，head.next=<span class="literal">null</span>，返回head=<span class="number">5</span></span><br><span class="line">reverseList(<span class="number">4</span>) cur = <span class="number">5</span>，head=<span class="number">4</span>，head.next=<span class="number">5</span></span><br><span class="line">reverseList(<span class="number">3</span>)</span><br><span class="line">reverseList(<span class="number">2</span>)</span><br><span class="line">reverseList(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><h3 id="1-3-92-反转链表-II"><a href="#1-3-92-反转链表-II" class="headerlink" title="1.3 92. 反转链表 II  *"></a>1.3 <a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a>  *</h3><p>题目：反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line">时间复杂度：O(n)</span><br><span class="line">空间复杂度：O(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录第 N+1 个节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">mark</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归到变成翻转前n 个节点</span></span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> reverseN(head, right);</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = reverseBetween(head.next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归翻转从 root 开始,长度为 n 的链表</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">reverseN</span><span class="params">(ListNode root, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// basecase,只有一个节点,也就是第 n 个,返回它本身</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// mark 记录第 n 加一个,避免断链</span></span><br><span class="line">            mark = root.next;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reverseN(root.next, n - <span class="number">1</span>);</span><br><span class="line">        root.next.next = root;</span><br><span class="line">        <span class="comment">// root 是翻转后的最后一个,连上后面</span></span><br><span class="line">        root.next = mark;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 迭代实现,头插法</span></span><br><span class="line">时间复杂度：O(n)</span><br><span class="line">空间复杂度：O(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseBetween</span><span class="params">(ListNode head, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 需要翻转的节点数</span></span><br><span class="line">        right = right - left;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="comment">// 移动到 left 左侧</span></span><br><span class="line">        <span class="keyword">while</span> (left-- &gt; <span class="number">1</span>) cur = cur.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> cur.next, b = a.next;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将中间的链表翻转,此时 cur 在前一段最后,a 在第一段最后,b 在最后一段开始</span></span><br><span class="line">        <span class="keyword">while</span> (right-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> b.next;</span><br><span class="line">            b.next = a;</span><br><span class="line">            a = b;</span><br><span class="line">            b = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将第二段开头连上第三段开头</span></span><br><span class="line">        cur.next.next = b;</span><br><span class="line">        <span class="comment">// 第一段末尾连上第二段末尾</span></span><br><span class="line">        cur.next = a;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-25-K-个一组翻转链表-important"><a href="#1-4-25-K-个一组翻转链表-important" class="headerlink" title="1.4 25. K 个一组翻转链表 important"></a>1.4 <a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a> important</h3><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//哑节点辅助反转</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummyNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummyNode.next = head;</span><br><span class="line">        <span class="comment">//将从pre的下一个节点开始反转</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummyNode;</span><br><span class="line">        <span class="comment">//当前已经反转完成的位置</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//需要进行反转的节点</span></span><br><span class="line">        ListNode next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//需要翻转len/k组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len/k; i++)&#123;</span><br><span class="line">            <span class="comment">//每组需要将k-1个节点头插法到pre后面</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; k-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                next = cur.next;</span><br><span class="line">                cur.next = next.next;</span><br><span class="line">                next.next = pre.next;</span><br><span class="line">                pre.next = next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//一组反转完成后，重置pre和cur位置</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 区间 [a, b) 包含 k 个待反转元素</span></span><br><span class="line">        ListNode a, b;</span><br><span class="line">        a = b = head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">// 不足 k 个，不需要反转，base case</span></span><br><span class="line">            <span class="keyword">if</span> (b == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">            b = b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 反转前 k 个元素</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverse(a, b);</span><br><span class="line">        <span class="comment">// 递归反转后续链表并连接起来</span></span><br><span class="line">        a.next = reverseKGroup(b, k);</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 反转区间 [a, b) 的元素，注意是左闭右开 */</span></span><br><span class="line">    ListNode <span class="title function_">reverse</span><span class="params">(ListNode a, ListNode b)</span> &#123;</span><br><span class="line">        ListNode pre, cur, nxt;</span><br><span class="line">        pre = <span class="literal">null</span>;</span><br><span class="line">        cur = a;</span><br><span class="line">        nxt = a;</span><br><span class="line">        <span class="comment">// while 终止的条件改一下就行了</span></span><br><span class="line">        <span class="keyword">while</span> (cur != b) &#123;</span><br><span class="line">            nxt = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nxt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回反转后的头结点</span></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-83-删除排序链表中的重复元素"><a href="#1-5-83-删除排序链表中的重复元素" class="headerlink" title="1.5 83. 删除排序链表中的重复元素"></a>1.5 <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/">83. 删除排序链表中的重复元素</a></h3><p>题目：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。</p><p>思路：从头到尾遍历，将结点的值与后面 的结点值比较，如果重复就跳过下一个结点指向之后的结点。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">current</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">null</span> &amp;&amp; current.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current.next.val == current.val) &#123;</span><br><span class="line">            current.next = current.next.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-82-删除排序链表中的重复元素-II"><a href="#1-6-82-删除排序链表中的重复元素-II" class="headerlink" title="1.6 82. 删除排序链表中的重复元素 II"></a>1.6 <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/">82. 删除排序链表中的重复元素 II</a></h3><p>题目：给定一个排序链表，删除所有重复的元素，只保留没有重复出现的结点。</p><p>思路：<br>1.头节点也可能要删除，增加一个哑结点<br>2.双指针a，b；a指向dummy，b指向head，如果a.next！=b.next 那么ab都往前，如果相等则只移动b到不等为止，然后a.next=b.next;b=b.next</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteDuplicates</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        dummy.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">b</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span>(b!=<span class="literal">null</span> &amp;&amp; b.next!=<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//初始化的时a指向的是哑结点，所以比较逻辑应该是a的下一个节点和b的下一个节点</span></span><br><span class="line">            <span class="keyword">if</span>(a.next.val!=b.next.val) &#123;</span><br><span class="line">                a = a.next;</span><br><span class="line">                b = b.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果a、b指向的节点值相等，就不断移动b，直到a、b指向的值不相等 </span></span><br><span class="line">                <span class="keyword">while</span>(b!=<span class="literal">null</span> &amp;&amp; b.next!=<span class="literal">null</span> &amp;&amp; a.next.val==b.next.val) &#123;</span><br><span class="line">                    b = b.next;</span><br><span class="line">                &#125;</span><br><span class="line">                a.next = b.next;</span><br><span class="line">                b = b.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-从尾到头打印链表"><a href="#1-7-从尾到头打印链表" class="headerlink" title="1.7 从尾到头打印链表"></a>1.7 从尾到头打印链表</h3><p>题目：输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。</p><p>思路：<br>1.递归</p><p>每层递归将值加入结果数组</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        recur(head);</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[temp.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; res.length;i++)</span><br><span class="line">            res[i] = temp.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recur(head.next);</span><br><span class="line">    temp.add(head.val);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.辅助栈</p><p>遍历链表，将结点值入栈，遍历完成后将栈中元素存入数组，实现倒序输出</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">        <span class="type">Deque</span> <span class="variable">stack</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="literal">null</span>)&#123;</span><br><span class="line">           stack.add(head.val);</span><br><span class="line">           head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[stack.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; res.length ;i++)&#123;</span><br><span class="line">            res[i] = stack.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-链表中的倒数第K个节点"><a href="#1-8-链表中的倒数第K个节点" class="headerlink" title="1.8 链表中的倒数第K个节点 *"></a>1.8 链表中的倒数第K个节点 *</h3><p>题目：输入一个链表，输出该链表中倒数第k个结点。</p><p>思路：双指针法，一个先走k步，另一个也开始走，直到</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;    </span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">a</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">b</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; k ;i++)&#123;</span><br><span class="line">        b = b.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(b != <span class="literal">null</span>)&#123;</span><br><span class="line">        a = a.next;</span><br><span class="line">        b = b.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-9-19-删除链表的倒数第-N-个结点"><a href="#1-9-19-删除链表的倒数第-N-个结点" class="headerlink" title="1.9 19. 删除链表的倒数第 N 个结点"></a>1.9 <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目:给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.</span><br><span class="line"></span><br><span class="line">当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 采用两个间隔为n的指针，同时向前移动。当快指针的下一个节点为最后一个节点时，要删除的节点就是慢指针的下一个节点。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 只有一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head, slow = head;</span><br><span class="line">        <span class="comment">// fast 先走 n 步,然后一起到最后,slow 指向删除的前一个位置</span></span><br><span class="line">        <span class="keyword">while</span>(n-- &gt; <span class="number">0</span>) fast = fast.next;</span><br><span class="line">      <span class="comment">// 边界:如果有 n 个节点,删倒数第 n 个,也就是头结点</span></span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">null</span>) <span class="keyword">return</span> head.next;</span><br><span class="line">      <span class="comment">// 直到 fast 指向末尾,slow 指向待删除的前一个</span></span><br><span class="line">        <span class="keyword">while</span>(fast.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">        &#125;</span><br><span class="line">        slow.next = slow.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-10-复杂链表的复制"><a href="#1-10-复杂链表的复制" class="headerlink" title="1.10 复杂链表的复制"></a>1.10 复杂链表的复制</h3><p>题目：请实现 copyRandomList 函数，复制一个复杂链表。在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p><p>思路：先在原链路中复制，然后建立random连接，最后拆分</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; <span class="comment">//HashMap实现</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="type">HashMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(); <span class="comment">//创建HashMap集合</span></span><br><span class="line">        Node cur=head;</span><br><span class="line">        <span class="comment">//复制结点值</span></span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//存储put:</span></span><br><span class="line">            map.put(cur,<span class="keyword">new</span> <span class="title class_">Node</span>(cur.val)); <span class="comment">//顺序遍历，存储老结点和新结点(先存储新创建的结点值)</span></span><br><span class="line">            cur=cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//复制结点指向</span></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//得到get:.value2,3</span></span><br><span class="line">            map.get(cur).next = map.get(cur.next); <span class="comment">//新结点next指向同旧结点的next指向</span></span><br><span class="line">            map.get(cur).random = map.get(cur.random); <span class="comment">//新结点random指向同旧结点的random指向</span></span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;   </span><br><span class="line"><span class="comment">//返回复制的链表</span></span><br><span class="line">    <span class="keyword">return</span> map.get(head);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-11-两个链表的第一个公共节点"><a href="#1-11-两个链表的第一个公共节点" class="headerlink" title="1.11 两个链表的第一个公共节点"></a>1.11 两个链表的第一个公共节点</h3><p>题目：输入两个链表，找出它们的第一个公共节点。</p><p>思路：两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。</p><p>这样，当它们相遇时，所指向的结点就是第一个公共结点。</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nodeA</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">nodeB</span> <span class="operator">=</span> headB;</span><br><span class="line">        <span class="keyword">while</span>(nodeA!=nodeB)&#123;</span><br><span class="line">            nodeA = nodeA==<span class="literal">null</span>?headB:nodeA.next;</span><br><span class="line">            nodeB = nodeB==<span class="literal">null</span>?headA:nodeB.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodeA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-12-环型链表"><a href="#1-12-环型链表" class="headerlink" title="1.12 环型链表"></a>1.12 环型链表</h3><p>题目：给定一个链表，判断链表中是否有环。</p><p>思路：快慢指针</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">low</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">while</span>( fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(low.equals(fast) )&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            low = low.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="1-13-链表中环的入口结点"><a href="#1-13-链表中环的入口结点" class="headerlink" title="1.13 链表中环的入口结点"></a>1.13 <a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&amp;tqId=11208&amp;tPage=3&amp;rp=1&amp;ru=%2Fta%2Fcoding-interviews&amp;qru=%2Fta%2Fcoding-interviews%2Fquestion-ranking">链表中环的入口结点</a></h3><p><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/submissions/">https://leetcode-cn.com/problems/linked-list-cycle-ii/submissions/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快慢指针</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> &#123;</span><br><span class="line">    <span class="comment">// 设计双指针， 1. 边界都要判断下一个结点也是否为空</span></span><br><span class="line">    <span class="keyword">if</span> (pHead == <span class="literal">null</span> || pHead.next == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> pHead, fast = pHead;</span><br><span class="line">    <span class="comment">// 2. 快以二倍速前进，慢正常操作</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125; <span class="keyword">while</span> (slow != fast); <span class="comment">// 3. 相遇点</span></span><br><span class="line">    <span class="comment">// 4. fast从头继续和slow正常走</span></span><br><span class="line">    fast = pHead;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123; </span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 返回slow，毕竟二者走在一块</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-14-2-两数相加"><a href="#1-14-2-两数相加" class="headerlink" title="1.14 2. 两数相加  *"></a>1.14 <a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a>  *</h3><p>题目:给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</p><p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p><p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p>思路:用一个虚拟头结点 逐位相加,考虑进位</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逐位相加,考虑进位</span></span><br><span class="line"><span class="comment">// 复杂度 时间:O(max(m,n));  空间:O(max(m,n))</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> l1 != <span class="literal">null</span> ? l1.val : <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> l2 != <span class="literal">null</span> ? l2.val : <span class="number">0</span>;</span><br><span class="line">            carry = a + b + carry;</span><br><span class="line">            temp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry % <span class="number">10</span>);</span><br><span class="line">            carry /= <span class="number">10</span>;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            <span class="keyword">if</span>(l1 != <span class="literal">null</span>) l1 = l1.next;</span><br><span class="line">            <span class="keyword">if</span>(l2 != <span class="literal">null</span>) l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry != <span class="number">0</span>) temp.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-15-445-两数相加-II"><a href="#1-15-445-两数相加-II" class="headerlink" title="1.15 445. 两数相加 II"></a>1.15 <a href="https://leetcode-cn.com/problems/add-two-numbers-ii/">445. 两数相加 II</a></h3><p>题目：给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</p><p>你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p>思路：两辅助栈</p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack1.push(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack2.push(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;  <span class="comment">//标记是否进位</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>( !stack1.isEmpty() || !stack2.isEmpty() || carry!=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> carry;</span><br><span class="line">            sum += stack1.isEmpty() ? <span class="number">0</span> : stack1.pop();</span><br><span class="line">            sum += stack2.isEmpty() ? <span class="number">0</span> : stack2.pop();</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum%<span class="number">10</span>);</span><br><span class="line">            node.next = head1.next;<span class="comment">//头插法</span></span><br><span class="line">            head1.next = node;</span><br><span class="line">            carry = sum/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-16-328-奇偶链表"><a href="#1-16-328-奇偶链表" class="headerlink" title="1.16 328. 奇偶链表"></a>1.16 <a href="https://leetcode-cn.com/problems/odd-even-linked-list/">328. 奇偶链表</a></h3><p>题目：给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>思路：三个指针，两个排序，一个标记偶数链表的头</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">oddEvenList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">odd</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">even</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">evenHead</span> <span class="operator">=</span> even;</span><br><span class="line">        <span class="keyword">while</span>(even!= <span class="literal">null</span> &amp;&amp; even.next!= <span class="literal">null</span>)&#123;<span class="comment">//偶数在后面，如果偶数有，那么奇数也有</span></span><br><span class="line">            odd.next = odd.next.next;</span><br><span class="line">            odd = odd.next;</span><br><span class="line">            even.next = even.next.next;</span><br><span class="line">            even = even.next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd.next = evenHead;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-17-725-分隔链表"><a href="#1-17-725-分隔链表" class="headerlink" title="1.17 725. 分隔链表"></a>1.17 <a href="https://leetcode-cn.com/problems/split-linked-list-in-parts/">725. 分隔链表</a></h3><p>给定一个头结点为 root 的链表, 编写一个函数以将链表分隔为 k 个连续的部分。</p><p>每部分的长度应该尽可能的相等: 任意两部分的长度差距不能超过 1，也就是说可能有些部分为 null。</p><p>这k个部分应该按照在链表中出现的顺序进行输出，并且排在前面的部分的长度应该大于或等于后面的长度。</p><p>返回一个符合上述规则的链表的列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//链表长度</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">            N++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每个部分的基础长度和余数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> N/k;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> N%k;</span><br><span class="line">        cur = root;</span><br><span class="line">        ListNode[] res = <span class="keyword">new</span> <span class="title class_">ListNode</span>[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; cur != <span class="literal">null</span> &amp;&amp; i &lt; k ; i++)&#123;</span><br><span class="line">            <span class="comment">//表头加入</span></span><br><span class="line">            res[i] = cur;</span><br><span class="line">            <span class="comment">//当前的大小取决于基础大小和是否还有余数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">curSize</span> <span class="operator">=</span> size + (mod-- &gt; <span class="number">0</span> ? <span class="number">1</span>:<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//需要得到Cursize规模的链表，需要走Cursize - 1步</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; curSize - <span class="number">1</span>; j++)&#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//记录下下一个节点，断开链表</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            cur.next = <span class="literal">null</span>;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-18-21-合并两个有序链表"><a href="#1-18-21-合并两个有序链表" class="headerlink" title="1.18 21. 合并两个有序链表 *"></a>1.18 <a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a> *</h3><p>题目：将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><p>递归解法：</p><p>终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束</p><p>返回值：每一层调用都返回排序好的链表头</p><p>本级递归内容：如果 l1 的 val 值更小，则将 l1.next 与排序好的链表头相接，l2 同理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归  时间 O(n+m)  空间 O(n+m)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(l2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 迭代  时间 O(n+m)  空间 O(1)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt;= l2.val)&#123;</span><br><span class="line">                pre.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = pre.next;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        pre.next = l1 == <span class="literal">null</span> ? l2 : l1;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-19-23-合并K个升序链表"><a href="#1-19-23-合并K个升序链表" class="headerlink" title="1.19 23. 合并K个升序链表 *"></a>1.19 <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a> *</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最小堆</span></span><br><span class="line"><span class="comment">// 时间: O(kn×logk)  k 个链表,kn 个点</span></span><br><span class="line"><span class="comment">// 空间: O(k)</span></span><br><span class="line"><span class="comment">// 堆排序,使用大顶堆可以得到升序的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="comment">// 哨兵节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(-<span class="number">1</span>), tail = dummy;</span><br><span class="line">        <span class="comment">//优先队列，每次出堆的都是最小的  小顶堆,输出根节点</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; q = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a.val - b.val);</span><br><span class="line">        <span class="comment">// 入队</span></span><br><span class="line">        <span class="keyword">for</span>(ListNode node : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>) q.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">            tail.next = q.poll();</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            <span class="keyword">if</span>(tail.next != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.add(tail.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分治实现</span></span><br><span class="line"><span class="comment">// 时间 O(kn×logk)</span></span><br><span class="line"><span class="comment">// 空间 O(logk)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lists == <span class="literal">null</span> || lists.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> merge(lists, <span class="number">0</span>, lists.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//分治实现两两合并</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode[] lists, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span> lists[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l1</span> <span class="operator">=</span> merge(lists, left, mid);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">l2</span> <span class="operator">=</span> merge(lists, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(l1, l2);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">//合并两个有序</span></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">null</span>) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">null</span>) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">            l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2.next = mergeTwoLists(l1,l2.next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-20-234-回文链表-important"><a href="#1-20-234-回文链表-important" class="headerlink" title="1.20 234. 回文链表 important"></a>1.20 <a href="https://leetcode-cn.com/problems/palindrome-linked-list/">234. 回文链表</a> important</h3><p>请判断一个链表是否为回文链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//只有一个或者两个</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head,fast = head.next;</span><br><span class="line">        <span class="comment">//找出中点</span></span><br><span class="line">        <span class="keyword">while</span>(fast!= <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//考虑只有两个元素的情况</span></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="literal">null</span>) slow = slow.next;</span><br><span class="line">        cut(head,slow);</span><br><span class="line">        <span class="keyword">return</span> isequal(head,reverse(slow));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//断开链表，断在slow前</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">cut</span><span class="params">(ListNode head,ListNode slow)</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head.next != slow)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转链表</span></span><br><span class="line">    <span class="keyword">private</span>  ListNode <span class="title function_">reverse</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> reverse(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否相等</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isequal</span><span class="params">(ListNode l1,ListNode l2)</span>&#123;</span><br><span class="line">        <span class="comment">//忽略奇数个节点情况</span></span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val != l2.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">                l2 = l2.next;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-21-86-分隔链表-important"><a href="#1-21-86-分隔链表-important" class="headerlink" title="1.21 86. 分隔链表  important"></a>1.21 <a href="https://leetcode-cn.com/problems/partition-list/">86. 分隔链表</a>  important</h3><p>给你一个链表的头节点 head 和一个特定值 x ，请你对链表进行分隔，使得所有 小于 x 的节点都出现在 大于或等于 x 的节点之前。</p><p>你应当 保留 两个分区中每个节点的初始相对位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node1</span> <span class="operator">=</span> dummy1, node2 = dummy2;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (head.val &lt; x)&#123;</span><br><span class="line">                node1.next = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                node1 = node1.next;</span><br><span class="line">                <span class="comment">//断开与主链表的联系</span></span><br><span class="line">                node1.next = <span class="literal">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                node2.next = head;</span><br><span class="line">                head = head.next;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">                node2.next = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node1.next = dummy2.next;</span><br><span class="line">        <span class="keyword">return</span> dummy1.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-22-剑指46-圆圈中最后剩下的数"><a href="#1-22-剑指46-圆圈中最后剩下的数" class="headerlink" title="1.22 剑指46.圆圈中最后剩下的数"></a>1.22 剑指46.圆圈中最后剩下的数</h3><p>每年六一儿童节,牛客都会准备一些小礼物去看望孤儿院的小朋友,今年亦是如此。HF作为牛客的资深元老,自然也准备了一些小游戏。其中,有个游戏是这样的:首先,让小朋友们围成一个大圈。然后,他随机指定一个数m,让编号为0的小朋友开始报数。每次喊到m-1的那个小朋友要出列唱首歌,然后可以在礼品箱中任意的挑选礼物,并且不再回到圈中,从他的下一个小朋友开始,继续0…m-1报数….这样下去….直到剩下最后一个小朋友,可以不用表演,并且拿到牛客名贵的“名侦探柯南”典藏版(名额有限哦!!^_^)。请你试着想下,哪个小朋友会得到这份礼品呢？(注：小朋友的编号是从0到n-1) </p><p>如果没有小朋友，请返回-1 </p><p>思路：</p><p>使用List模拟，使用一个指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">LastRemaining_Solution</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span> || m == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        LinkedList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) list.add(i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(list.size()&gt;<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">                cur++;</span><br><span class="line">                <span class="keyword">if</span>(cur == list.size()) cur = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            list.remove(cur);</span><br><span class="line">            <span class="comment">//删除节点时，cur会指向下一个节点，因此需要减1。</span></span><br><span class="line">            cur--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-23-853-链表的中间结点-important"><a href="#1-23-853-链表的中间结点-important" class="headerlink" title="1.23 853.链表的中间结点  important"></a>1.23 853.链表的中间结点  important</h3><p><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list/">https://leetcode-cn.com/problems/middle-of-the-linked-list/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双指针（快慢）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">middleNode</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head, q = head;</span><br><span class="line">        <span class="keyword">while</span> (q != <span class="literal">null</span> &amp;&amp; q.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            q = q.next.next;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-24-24-两两交换链表中的节点"><a href="#1-24-24-两两交换链表中的节点" class="headerlink" title="1.24 24. 两两交换链表中的节点 *"></a>1.24 <a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a> *</h3><p>给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        pre.next = head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">temp</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="comment">// temp -&gt; start -&gt; end</span></span><br><span class="line">        <span class="comment">// temp 是要交换的两个的前一个</span></span><br><span class="line">        <span class="keyword">while</span>(temp.next != <span class="literal">null</span> &amp;&amp; temp.next.next != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">start</span> <span class="operator">=</span> temp.next;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> temp.next.next;</span><br><span class="line">            temp.next = end;</span><br><span class="line">            start.next = end.next;</span><br><span class="line">            end.next = start;</span><br><span class="line">            <span class="comment">// 交换完成,此时 start 后面是需要交换的</span></span><br><span class="line">            temp = start;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 递归解法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">swapPairs</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">// 当前无节点或者只有一个节点，无法进行交换</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// head -&gt; next -&gt; (next.next)</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        head.next = swapPairs(next.next);</span><br><span class="line">        next.next = head;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-25-奇数位升序偶数位降序的链表-important"><a href="#1-25-奇数位升序偶数位降序的链表-important" class="headerlink" title="1.25 奇数位升序偶数位降序的链表  important"></a>1.25 奇数位升序偶数位降序的链表  important</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">oddEvenLinkedList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="comment">// 将偶数链表拆分出来</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">evenHead</span> <span class="operator">=</span> getEvenList(head);</span><br><span class="line">    <span class="comment">// 逆序偶数链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">reEvenHead</span> <span class="operator">=</span> reverseList(evenHead);</span><br><span class="line">    <span class="comment">// 归并奇偶链表</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">mHead</span> <span class="operator">=</span> mergeList(head, reEvenHead);</span><br><span class="line">    <span class="keyword">return</span> mHead;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">getEvenList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">evenHead</span> <span class="operator">=</span> head.next;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; cur.next != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取next</span></span><br><span class="line">        next = cur.next;</span><br><span class="line">        <span class="comment">// cur奇数，-&gt; next.next (奇数)</span></span><br><span class="line">        cur.next = next.next;</span><br><span class="line">        <span class="comment">// 移动</span></span><br><span class="line">        cur = cur.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始偶数</span></span><br><span class="line">        next.next = cur.next;</span><br><span class="line">        <span class="comment">// 移动</span></span><br><span class="line">        next = next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> evenHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title function_">mergeList</span><span class="params">(ListNode l1, ListNode l2)</span>&#123;</span><br><span class="line">    <span class="comment">// 我用递归</span></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">null</span>) </span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        l1.next = mergeList(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l2.next = mergeList(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Algorithm] Sort</title>
      <link href="/2021/06/12/Algorithm/Sort/"/>
      <url>/2021/06/12/Algorithm/Sort/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="排序算法的比较"><a href="#排序算法的比较" class="headerlink" title="排序算法的比较"></a>排序算法的比较</h2><div class="table-container"><table><thead><tr><th><strong>算法</strong></th><th><strong>稳定性</strong></th><th><strong>时间复杂度</strong></th><th><strong>空间复杂度</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>选择排序</td><td>×</td><td>N2</td><td>1</td><td></td></tr><tr><td>冒泡排序</td><td>√</td><td>N2</td><td>1</td><td></td></tr><tr><td>插入排序</td><td>√</td><td>N ~ N2</td><td>1</td><td>时间复杂度和初始顺序有关</td></tr><tr><td>希尔排序</td><td>×</td><td>N的若干倍乘于递增序列的长度</td><td>1</td><td>改进版插入排序</td></tr><tr><td>快速排序</td><td>×</td><td>NlogN</td><td>logN</td><td></td></tr><tr><td>三向切分快速排序</td><td>×</td><td>N ~ NlogN</td><td>logN</td><td>适用于有大量重复主键</td></tr><tr><td>归并排序</td><td>√</td><td>NlogN</td><td>N</td><td></td></tr><tr><td>堆排序</td><td>×</td><td>NlogN</td><td>1</td><td>无法利用局部性原理</td></tr></tbody></table></div><p>快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 ~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。</p><p>使用三向切分快速排序，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序通过一个切分元素将数组分为两个子数组，左子数组小于等于切分元素，右子数组大于等于切分元素，将这两个子数组排序也就将整个数组排序了。</p><p>取 a[l] 作为切分元素，从数组的左端向右扫描直到找到第一个大于等于它的元素，再从数组的右端向左扫描找到第一个小于它的元素，交换这两个元素。不断进行这个过程，就可以保证左指针 i 的左侧元素都不大于切分元素，右指针 j 的右侧元素都不小于切分元素。当两个指针相遇时，将切分元素 a[l] 和 a[j] 交换位置。</p><p>为了防止数组最开始就是有序的，在进行快速排序时需要随机打乱数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 快速排序主函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">quicksort</span><span class="params">(arr []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(arr) &lt; <span class="number">2</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    left, right := <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span></span><br><span class="line">    <span class="comment">// 选择枢纽元素</span></span><br><span class="line">    pivot := arr[<span class="built_in">len</span>(arr)/<span class="number">2</span>]</span><br><span class="line">    <span class="comment">// 分区过程</span></span><br><span class="line">    <span class="keyword">for</span> left &lt;= right &#123;</span><br><span class="line">        <span class="keyword">for</span> arr[left] &lt; pivot &#123;</span><br><span class="line">            left++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> arr[right] &gt; pivot &#123;</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> left &lt;= right &#123;</span><br><span class="line">            arr[left], arr[right] = arr[right], arr[left]</span><br><span class="line">            left++</span><br><span class="line">            right--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归排序左右两部分</span></span><br><span class="line">    <span class="keyword">if</span> right &gt; <span class="number">0</span> &#123;</span><br><span class="line">        quicksort(arr[:right+<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> left &lt; <span class="built_in">len</span>(arr) &#123;</span><br><span class="line">        quicksort(arr[left:])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    data := []<span class="type">int</span>&#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Unsorted array:&quot;</span>, data)</span><br><span class="line">    quicksort(data)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Sorted array:&quot;</span>, data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> <span class="keyword">extends</span> <span class="title class_">Sort</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(Integer[] nums, <span class="type">int</span> l, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = h+<span class="number">1</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">v</span> <span class="operator">=</span> nums[l];</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line">     <span class="comment">//从左侧向右扫描找到第一个大于等于基准的，再从数组的右端向左扫描找到第一个小于它的元素，交换这两个元素。</span></span><br><span class="line">            <span class="keyword">while</span> (less(nums[++i],v) &amp;&amp; i != h);</span><br><span class="line">            <span class="keyword">while</span> (less(v,nums[--j]) &amp;&amp; j != l);</span><br><span class="line">            <span class="comment">//当两个指针相遇，结束循环</span></span><br><span class="line">            <span class="keyword">if</span>(j &lt; i) <span class="keyword">break</span>;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums,l,j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">shuffle</span><span class="params">(Integer[] nums)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(nums);</span><br><span class="line">        Collections.shuffle(list);</span><br><span class="line">        list.toArray(nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">        shuffle(nums);</span><br><span class="line">        sort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums, <span class="type">int</span> l, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= h) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> partition(nums, l, h);</span><br><span class="line">        sort(nums, l, j);</span><br><span class="line">        sort(nums, j+<span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(Integer v, Integer w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v &lt; w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Integer[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于切分的快速选择算法（TopK）"><a href="#基于切分的快速选择算法（TopK）" class="headerlink" title="基于切分的快速选择算法（TopK）"></a>基于切分的快速选择算法（TopK）</h3><p>快速排序的partition()方法，会返回一个索引j，j前面的都小于a[j],后面的都大于，也即是返回第j大的元素</p><p>可以据此找出第k大元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> partition(nums,low,high);</span><br><span class="line">        <span class="keyword">if</span>(j == k) <span class="keyword">return</span> nums[k];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; k)&#123;</span><br><span class="line">            high = j - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">low = j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三向切分"><a href="#三向切分" class="headerlink" title="三向切分"></a>三向切分</h3><p>对于有大量重复元素的数组，可以将数组切分为三部分，分别对应小于、等于和大于切分元素。</p><p>三向切分快速排序对于有大量重复元素的随机数组可以在线性时间内完成排序。</p><p>Java 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeWayQuickSort</span> <span class="keyword">extends</span> <span class="title class_">QuickSort</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums, <span class="type">int</span> l, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=h) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lt</span> <span class="operator">=</span> l, i = l+<span class="number">1</span>, gt = h;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">v</span> <span class="operator">=</span> nums[l];</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=gt)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cmp</span> <span class="operator">=</span> nums[i] - v;</span><br><span class="line">            <span class="keyword">if</span>(cmp &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums, lt++, i++);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cmp &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                swap(nums, i, gt--);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums, l, lt-<span class="number">1</span>);</span><br><span class="line">        sort(nums, gt+<span class="number">1</span>, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h3><p>在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</p><p>对子数组进行划分，如果划分得到的 q 正好就是我们需要的下标，就直接返回 a[q]；否则，如果 q 比目标下标小，就递归右子区间，否则递归左子区间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> len - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 转换一下，第 k 大元素的索引是 len - k</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> len - k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (index == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[index];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; target) &#123;</span><br><span class="line">                left = index + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = index - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[left];</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left + <span class="number">1</span>; i &lt;= right; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; pivot) &#123;</span><br><span class="line">                j++;</span><br><span class="line">                swap(nums, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, j, left);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index1, <span class="type">int</span> index2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[index1];</span><br><span class="line">        nums[index1] = nums[index2];</span><br><span class="line">        nums[index2] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择最小的元素，然后和第一个交换，然后从剩下的元素选最小的和第二个交换，直到将整个数组排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Selection</span> <span class="keyword">extends</span> <span class="title class_">Sort</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+<span class="number">1</span>; j &lt; n; j++)&#123;<span class="comment">//从剩下的元素中选出最小的元素</span></span><br><span class="line">                <span class="keyword">if</span>(less(nums[j], nums[min]))&#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i, min);<span class="comment">//和最小的交换位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(Integer[] a, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">temp</span> <span class="operator">=</span> a[i];</span><br><span class="line">        a[i] = a[j];</span><br><span class="line">        a[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(Integer v, Integer w)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v &lt; w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆中某个节点的值总是大于等于其子节点的值，并且堆是一颗完全二叉树。</p><p>位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。</p><p>大根堆： 根节点大于叶子节点  根节点是最大的   根据大根堆可以得到几个最小的</p><p>小根堆： 根节点是最小的，输出根节点就是输出最小的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Heap</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T[] heap;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Heap</span><span class="params">(<span class="type">int</span> maxN)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.heap = (T[]) <span class="keyword">new</span> <span class="title class_">Comparable</span>[maxN + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> N;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> heap[i].compareTo(heap[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> heap[i];</span><br><span class="line">        heap[i] = heap[j];</span><br><span class="line">        heap[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上浮和下沉"><a href="#上浮和下沉" class="headerlink" title="上浮和下沉"></a>上浮和下沉</h3><p>在堆中，当一个节点比父节点大，那么需要交换这个两个节点。交换后还可能比它新的父节点大，因此需要不断地进行比较和交换操作，把这种操作称为上浮。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swim</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span> &amp;&amp; less(k / <span class="number">2</span>, k)) &#123;</span><br><span class="line">        swap(k / <span class="number">2</span>, k);</span><br><span class="line">        k = k / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个节点比子节点来得小，也需要不断地向下进行比较和交换操作，把这种操作称为下沉。一个节点如果有两个子节点，应当与两个子节点中最大那个节点进行交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * k;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; N &amp;&amp; less(j, j + <span class="number">1</span>))</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">if</span> (!less(k, j))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        swap(k, j);</span><br><span class="line">        k = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>将新元素放到数组末尾，然后上浮到合适的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(Comparable v)</span> &#123;</span><br><span class="line">    heap[++N] = v;</span><br><span class="line">    swim(N);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除最大元素"><a href="#删除最大元素" class="headerlink" title="删除最大元素"></a>删除最大元素</h3><p>从数组顶端删除最大的元素，并将数组的最后一个元素放到顶端，并让这个元素下沉到合适的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">delMax</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">T</span> <span class="variable">max</span> <span class="operator">=</span> heap[<span class="number">1</span>];</span><br><span class="line">    swap(<span class="number">1</span>, N--);</span><br><span class="line">    heap[N + <span class="number">1</span>] = <span class="literal">null</span>;</span><br><span class="line">    sink(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h3><p>把最大元素和当前堆中数组的最后一个元素交换位置，并且不删除它，那么就可以得到一个从尾到头的递减序列，从正向来看就是一个递增序列，这就是堆排序。</p><p>从右至左进行下沉操作，如果一个节点的两个节点都已经是堆有序，那么进行下沉操作可以使得这个节点为根节点的堆有序。</p><p>交换堆顶元素与最后一个元素</p><p>交换之后需要进行下沉操作维持堆的有序状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span>&lt;T <span class="keyword">extends</span> <span class="title class_">Comparable</span>&lt;T&gt;&gt; <span class="keyword">extends</span> <span class="title class_">Sort</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组第 0 个位置不能有元素</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(T[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> N / <span class="number">2</span>; k &gt;= <span class="number">1</span>; k--)</span><br><span class="line">            sink(nums, k, N);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            swap(nums, <span class="number">1</span>, N--);</span><br><span class="line">            sink(nums, <span class="number">1</span>, N);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sink</span><span class="params">(T[] nums, <span class="type">int</span> k, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * k &lt;= N) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span> * k;</span><br><span class="line">            <span class="keyword">if</span> (j &lt; N &amp;&amp; less(nums, j, j + <span class="number">1</span>))</span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">if</span> (!less(nums, k, j))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            swap(nums, k, j);</span><br><span class="line">            k = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">less</span><span class="params">(T[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i].compareTo(nums[j]) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>从左到右不断交换相邻逆序的元素，在一轮的循环之后，可以让未排序的最大元素上浮到右侧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bubble</span> <span class="keyword">extends</span> <span class="title class_">Sort</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>; i &gt; <span class="number">0</span> &amp;&amp; flag; i--)&#123;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(less(nums[j+<span class="number">1</span>],nums[j]))&#123;</span><br><span class="line">                    swap(nums,j,j+<span class="number">1</span>);</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>每次都将当前元素插入到左侧已经排序的数组中，使得插入之后左侧数组依然有序。</p><p>插入排序每次只能交换相邻元素，令逆序数量减少 1，因此插入排序需要交换的次数为逆序数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Insertion</span> <span class="keyword">extends</span> <span class="title class_">Sort</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span> &amp;&amp; less(nums[j],nums[j-<span class="number">1</span>]); j--)&#123;</span><br><span class="line">                swap(nums,j,j-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>插入排序的优化</p><p>通过交换不相邻的元素，每次可以将逆序数量减少大于 1。</p><p>使用插入排序对间隔 h 的序列进行排序。通过不断减小 h，最后令 h=1，就可以使得整个数组是有序的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Shell</span> <span class="keyword">extends</span> <span class="title class_">Sort</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (h &lt; n/<span class="number">3</span>)&#123;</span><br><span class="line">            h = <span class="number">3</span>*h + <span class="number">1</span>;<span class="comment">//1,4,9,13</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (h &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &gt; <span class="number">0</span> &amp;&amp; less(nums[j],nums[j-h]); j -= h)&#123;</span><br><span class="line">                    swap(nums,j,j-h);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            h = h/<span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并算法"><a href="#归并算法" class="headerlink" title="归并算法"></a>归并算法</h2><p>将数组分成两部分，分别进行排序，然后归并起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeSort</span> <span class="keyword">extends</span> <span class="title class_">Sort</span> &#123;</span><br><span class="line">    <span class="comment">//合并时，需要辅助数组，空间复杂度为 O(N)</span></span><br><span class="line">    <span class="keyword">private</span> Integer[] aux;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并方法：将数组中两个已经排序的部分归并成一个。</span></span><br><span class="line">    <span class="comment">//l需要合并的数组左端，m中点，h需要合并的数组右端</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(Integer[] nums, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= h; k++)&#123;</span><br><span class="line">            aux[k] = nums[k];<span class="comment">//将数据复制到辅助数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= h; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; m)&#123;</span><br><span class="line">                nums[k] = aux[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; h)&#123;</span><br><span class="line">                nums[k] = aux[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aux[i]&lt;=aux[j])&#123;</span><br><span class="line">                nums[k] = aux[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k] = aux[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将一个大数组分成两个小数组去求解。</span></span><br><span class="line">    <span class="comment">//因为每次都将问题对半分成两个子问题，这种对半分的算法复杂度一般为 O(NlogN)。</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums)</span> &#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="title class_">Integer</span>[nums.length];</span><br><span class="line">        sort(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Integer[] nums, <span class="type">int</span> l, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(h&lt;=l)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> l + (h - l)/<span class="number">2</span>;</span><br><span class="line">        sort(nums, l, mid);</span><br><span class="line">        sort(nums, mid+<span class="number">1</span>, h);</span><br><span class="line">        merge(nums, l, mid, h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剑指35-数组的逆序对"><a href="#剑指35-数组的逆序对" class="headerlink" title="剑指35.数组的逆序对"></a>剑指35.数组的逆序对</h3><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P%1000000007</p><p>在两个子序列left、right合并过程中，当left中当前元素A大于right中当前元素B时，因为left序列已经有序，所以A后面所有元素都可以与B组成逆序对。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] aux;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">InversePairs</span><span class="params">(<span class="type">int</span> [] array)</span> &#123;</span><br><span class="line">        aux = <span class="keyword">new</span> <span class="title class_">int</span>[array.length];</span><br><span class="line">        mergeSort(array, <span class="number">0</span>, array.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, j = m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= h; k++)&#123;</span><br><span class="line">            aux[k] = array[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> l; k &lt;= h; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; m)&#123;</span><br><span class="line">                array[k] = aux[j++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt; h)&#123;</span><br><span class="line">                array[k] = aux[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(aux[i] &lt;= aux[j])&#123;</span><br><span class="line">                array[k] = aux[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                array[k] = aux[j++];</span><br><span class="line">                count = (count + m + <span class="number">1</span> - i)%<span class="number">1000000007</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> l, <span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=h) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + (h-l)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(array,l,m);</span><br><span class="line">        mergeSort(array,m+<span class="number">1</span>,h);</span><br><span class="line">        merge(array,l,m,h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Algorithm] String</title>
      <link href="/2021/06/12/Algorithm/String/"/>
      <url>/2021/06/12/Algorithm/String/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h3 id="0-1-字符串常用方法"><a href="#0-1-字符串常用方法" class="headerlink" title="0.1 字符串常用方法"></a>0.1 字符串常用方法</h3><ul><li>不必考虑到线程同步问题，我们应该优先使用StringBuilder类；如果要保证线程安全，自然是StringBuffer。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String的方法</span></span><br><span class="line"><span class="type">char</span>  <span class="title function_">charAt</span><span class="params">(<span class="type">int</span> index)</span> <span class="comment">//返回指定索引处的值</span></span><br><span class="line">String  <span class="title function_">concat</span><span class="params">(String str)</span>  <span class="comment">//将指定的字符串连接到该字符串的末尾</span></span><br><span class="line"><span class="type">boolean</span>   <span class="title function_">contentEquals</span><span class="params">(StringBuffer sb)</span>  <span class="comment">//将此字符串与指定的StringBuffer进行比较</span></span><br><span class="line"><span class="type">int</span>   <span class="title function_">indexOf</span><span class="params">(<span class="type">int</span> ch)</span>  <span class="comment">//返回指定字符第一次出现的字符串内的索引</span></span><br><span class="line"><span class="type">int</span>   <span class="title function_">indexOf</span><span class="params">(String str)</span>  <span class="comment">//返回指定子字符串第一次出现的字符串内的索引</span></span><br><span class="line"><span class="type">boolean</span>  <span class="title function_">isEmpty</span><span class="params">()</span> </span><br><span class="line"><span class="type">int</span>  <span class="title function_">length</span><span class="params">()</span></span><br><span class="line">String   <span class="title function_">valueOf</span><span class="params">(<span class="type">int</span> i)</span>  <span class="comment">//将 int 变量 i 转换成字符串(使用于其他数据类型)</span></span><br><span class="line">String[]  split(String regex)  <span class="comment">//按regex将String切分成数组</span></span><br><span class="line"><span class="type">char</span>[]   toCharArray()  <span class="comment">//将此字符串转换为新的字符数组</span></span><br><span class="line">String   <span class="title function_">trim</span><span class="params">()</span>  <span class="comment">//删除前后的空格</span></span><br><span class="line">String    <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex, <span class="type">int</span> endIndex)</span>  <span class="comment">//获得子串，是左闭右开区间</span></span><br><span class="line">  </span><br><span class="line">StringBuffer  方法</span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="number">50</span>);  <span class="comment">// 容量为50</span></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">sb.append(<span class="string">&quot; World&quot;</span>);  <span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line">sb.insert(<span class="number">5</span>, <span class="string">&quot; Java&quot;</span>);  <span class="comment">// &quot;Hello Java World&quot;</span></span><br><span class="line">sb.replace(<span class="number">6</span>, <span class="number">10</span>, <span class="string">&quot;Beautiful&quot;</span>);  <span class="comment">// &quot;Hello Beautiful World&quot;</span></span><br><span class="line">sb.delete(<span class="number">6</span>, <span class="number">15</span>);  <span class="comment">// &quot;Hello World&quot;</span></span><br><span class="line">sb.deleteCharAt(<span class="number">5</span>);  <span class="comment">// &quot;HelloWorld&quot;</span></span><br><span class="line">sb.reverse();  <span class="comment">// &quot;dlroWolleH&quot;</span></span><br><span class="line">sb.setCharAt(<span class="number">0</span>, <span class="string">&#x27;h&#x27;</span>);  <span class="comment">// &quot;helloWorld&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> sb.substring(<span class="number">5</span>);  <span class="comment">// &quot;World&quot;</span></span><br><span class="line"><span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> sb.substring(<span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> sb.length();  <span class="comment">// 10</span></span><br><span class="line">res.toString()   <span class="comment">//转换成string</span></span><br></pre></td></tr></table></figure><h3 id="0-2-剑指-Offer-58-I-翻转单词顺序"><a href="#0-2-剑指-Offer-58-I-翻转单词顺序" class="headerlink" title="0.2 剑指 Offer 58 - I. 翻转单词顺序"></a>0.2 <a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof/">剑指 Offer 58 - I. 翻转单词顺序</a></h3><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//split()将字符串按空格分割，倒序遍历，将单词拼接到StringBuilder，去空格后返回</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        String[] strs = s.trim().split(<span class="string">&quot; &quot;</span>); <span class="comment">// 删除首尾空格，分割字符串</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> strs.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 倒序遍历单词列表</span></span><br><span class="line">            <span class="keyword">if</span>(strs[i].equals(<span class="string">&quot;&quot;</span>)) <span class="keyword">continue</span>; <span class="comment">// 遇到空单词则跳过</span></span><br><span class="line">            res.append(strs[i] + <span class="string">&quot; &quot;</span>); <span class="comment">// 将单词拼接至 StringBuilder</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim(); <span class="comment">// 转化为字符串，删除尾部空格，并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//倒序，逐个确定每个单词的边界</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        s = s.trim(); <span class="comment">// 删除首尾空格</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.length() - <span class="number">1</span>, i = j;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) != <span class="string">&#x27; &#x27;</span>) i--; <span class="comment">// 搜索首个空格</span></span><br><span class="line">            res.append(s.substring(i + <span class="number">1</span>, j + <span class="number">1</span>) + <span class="string">&quot; &quot;</span>); <span class="comment">// 添加单词</span></span><br><span class="line">            <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27; &#x27;</span>) i--; <span class="comment">// 跳过单词间空格</span></span><br><span class="line">            j = i; <span class="comment">// j 指向下个单词的尾字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim(); <span class="comment">// 转化为字符串并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-3-409-最长回文串"><a href="#0-3-409-最长回文串" class="headerlink" title="0.3 409. 最长回文串"></a>0.3 <a href="https://leetcode-cn.com/problems/longest-palindrome/">409. 最长回文串</a></h3><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计每个字符的个数</span></span><br><span class="line"><span class="comment">//每对字符都可以组成回文串，因为中间的可以是单个，如果还有剩余的单个，可以加一个上去</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; s.length() ; i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            map.put(c, map.getOrDefault(c,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c: map.keySet())&#123;</span><br><span class="line">            res += (map.get(c) / <span class="number">2</span>) * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res &lt; s.length())&#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用数组统计</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            cnt[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i : cnt)&#123;</span><br><span class="line">            result += (i/<span class="number">2</span>)*<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(result &lt; s.length())&#123;</span><br><span class="line">            result++;<span class="comment">//这种情况有单独的字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-4-205-同构字符串"><a href="#0-4-205-同构字符串" class="headerlink" title="0.4 205. 同构字符串"></a>0.4 <a href="https://leetcode-cn.com/problems/isomorphic-strings/">205. 同构字符串</a></h3><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p><p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p><p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录一个字符上次出现的位置，如果两个字符串中上次出现的位置一样，那么就是同构</span></span><br><span class="line"><span class="comment">//如 egg add g上次出现在2，d也上次出现在2，那么它们就是同构的</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isIsomorphic</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] indexOft = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="type">int</span>[] indexOfs = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">cs</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="type">char</span> <span class="variable">ct</span> <span class="operator">=</span> t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(indexOfs[cs] != indexOft[ct])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//防止一开始放进去的是0，无法区分</span></span><br><span class="line">            indexOfs[cs] = i + <span class="number">1</span>;</span><br><span class="line">            indexOft[ct] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-5-647-回文子串"><a href="#0-5-647-回文子串" class="headerlink" title="0.5 647. 回文子串"></a>0.5 <a href="https://leetcode-cn.com/problems/palindromic-substrings/">647. 回文子串</a></h3><p>给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// 中心扩展法</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//可以从一个字符向两侧扩展，也可以从两个相邻字符开始扩展，这样可以覆盖所有可能的子串</span></span><br><span class="line">        <span class="comment">//这样的单个字符有n个，两个有n-1个，所以合计有2n-1个中心点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">center</span> <span class="operator">=</span> <span class="number">0</span>; center &lt; <span class="number">2</span> * s.length() - <span class="number">1</span>; center++) &#123;</span><br><span class="line">            <span class="comment">// left和right指针和中心点的关系是？</span></span><br><span class="line">            <span class="comment">// 首先是left，有一个很明显的2倍关系的存在，其次是right，可能和left指向同一个（偶数时），也可能往后移动一个（奇数）</span></span><br><span class="line">            <span class="comment">// 大致的关系出来了，可以选择带两个特殊例子进去看看是否满足。</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> center / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> left + center % <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//在字符串范围内向两侧拓展</span></span><br><span class="line">            <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                left--;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-6-696-计数二进制子串"><a href="#0-6-696-计数二进制子串" class="headerlink" title="0.6 696. 计数二进制子串"></a>0.6 <a href="https://leetcode-cn.com/problems/count-binary-substrings/">696. 计数二进制子串</a></h3><p>给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计相同连续数字的个数，取其中的较小</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countBinarySubstrings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//统计当前数字连续的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">curCnt</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//记录上一个数字连续的个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//如果和前一个一样，当前连续个数++</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == s.charAt(i-<span class="number">1</span>))&#123;</span><br><span class="line">                curCnt++;</span><br><span class="line">            <span class="comment">//否则，记录下，作为前一个连续数字个数，然后重置当前</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                preCnt = curCnt;</span><br><span class="line">                curCnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//前一个数连续的个数大于当前，那么就多一种子串</span></span><br><span class="line">            <span class="keyword">if</span>(preCnt &gt;= curCnt)&#123;</span><br><span class="line">                result++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-7-剑指-Offer-19-正则表达式匹配"><a href="#0-7-剑指-Offer-19-正则表达式匹配" class="headerlink" title="0.7 剑指 Offer 19. 正则表达式匹配"></a>0.7 <a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">剑指 Offer 19. 正则表达式匹配</a></h3><p>请实现一个函数用来匹配包含’. ‘和’/<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（含0次）。在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但与”aa.a”和”ab*a”均不匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//&#x27;.&#x27;可以表示任意一个字符</span></span><br><span class="line"><span class="comment">//&#x27;*&#x27;表示前面的字符可以出现任意次</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">有三种情况：</span></span><br><span class="line"><span class="comment">1.B的最后一个是正常字符，那么比较AB最后一个，相等则往前一位</span></span><br><span class="line"><span class="comment">2.B的最后是&#x27;.&#x27;，可以直接往前一位</span></span><br><span class="line"><span class="comment">3.B的最后是&#x27;*&#x27;，代表B的倒数第二个可以重复一次，或者多次</span></span><br><span class="line"><span class="comment">如果A的最后匹配失败，那么B往前两位</span></span><br><span class="line"><span class="comment">如果匹配成功，那么A匹配完往前，B继续</span></span><br><span class="line"><span class="comment">f[i][j] 代表 A 的前 i 个和 B 的前 j 个能否匹配</span></span><br><span class="line"><span class="comment">对于前面两个情况，可以合并成一种情况 f[i][j] = f[i-1][j-1]</span></span><br><span class="line"><span class="comment">对于第三种情况，对于 c*c∗ 分为看和不看两种情况</span></span><br><span class="line"><span class="comment">不看：直接砍掉正则串的后面两个， f[i][j] = f[i][j-2]</span></span><br><span class="line"><span class="comment">看：正则串不动，主串前移一个，f[i][j] = f[i-1][j] </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> p.length();</span><br><span class="line">        <span class="type">boolean</span>[][] f = <span class="keyword">new</span> <span class="title class_">boolean</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n ; i++ )&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt;= m; j++)&#123;</span><br><span class="line">                <span class="comment">//如果j=0，那么只有i也是0的情况匹配成功</span></span><br><span class="line">                <span class="keyword">if</span>(j == <span class="number">0</span>) f[i][j] = i == <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//如果p最后一位不是&#x27;*&#x27;</span></span><br><span class="line">                    <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>) != <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                        <span class="comment">//如果相等，或者p的最后是&#x27;.&#x27;，那么都向前</span></span><br><span class="line">                        <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">1</span>) || p.charAt(j-<span class="number">1</span>) == <span class="string">&#x27;.&#x27;</span>))&#123;</span><br><span class="line">                            f[i][j] = f[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//碰到&#x27;*&#x27;</span></span><br><span class="line">                        <span class="comment">//不看，能否匹配取决于B串砍两位后能否匹配成功</span></span><br><span class="line">                        <span class="keyword">if</span>(j &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                            <span class="comment">//只要有一个成立就都成立</span></span><br><span class="line">                            f[i][j] |= f[i][j-<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line"><span class="comment">//看，正则串不动，主串前移</span></span><br><span class="line">                        <span class="keyword">if</span>(i &gt;= <span class="number">1</span> &amp;&amp; j &gt;= <span class="number">2</span> &amp;&amp; (s.charAt(i-<span class="number">1</span>) == p.charAt(j-<span class="number">2</span>) || p.charAt(j-<span class="number">2</span>) == <span class="string">&#x27;.&#x27;</span>))&#123;</span><br><span class="line">                            f[i][j] |= f[i-<span class="number">1</span>][j];</span><br><span class="line">                        &#125;</span><br><span class="line"> </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-8-剑指-Offer-48-最长不含重复字符的子字符串"><a href="#0-8-剑指-Offer-48-最长不含重复字符的子字符串" class="headerlink" title="0.8 剑指 Offer 48. 最长不含重复字符的子字符串"></a>0.8 <a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/">剑指 Offer 48. 最长不含重复字符的子字符串</a></h3><p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//滑动窗口实现</span></span><br><span class="line"><span class="comment">//维护一个left，表示窗口的最左侧</span></span><br><span class="line"><span class="comment">//维护一个HashMap，记录窗口内的元素和位置</span></span><br><span class="line"><span class="comment">//当加入了一个当前窗口内已有的值，直接通过HashMap获取位置，重置left</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i ++)&#123;</span><br><span class="line">            <span class="comment">//如果这个元素出现过</span></span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                <span class="comment">//如果在窗口内，left跳转到它的下一个</span></span><br><span class="line">                left = Math.max(left,map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//放入当前</span></span><br><span class="line">            map.put(s.charAt(i),i);</span><br><span class="line">            <span class="comment">//计算当前窗口值是否最大</span></span><br><span class="line">            max = Math.max(max,i-left+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-9-剑指-Offer-67-把字符串转换成整数"><a href="#0-9-剑指-Offer-67-把字符串转换成整数" class="headerlink" title="0.9 剑指 Offer 67. 把字符串转换成整数"></a>0.9 <a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/">剑指 Offer 67. 把字符串转换成整数</a></h3><p>写一个函数 StrToInt，实现把字符串转换成整数这个功能。不能使用 atoi 或者其他类似的库函数。</p><p>首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。</p><p>当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p><p>该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。</p><p>注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。</p><p>在任何情况下，若函数不能进行有效的转换时，请返回 0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strToInt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="comment">//去除两端空格</span></span><br><span class="line">        str = str.trim();</span><br><span class="line">        <span class="comment">//判空</span></span><br><span class="line">        <span class="keyword">if</span>(str.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>  <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//标记是否为负</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//记录当前所指字符位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span>) flag = -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//有符号，前进一位</span></span><br><span class="line">        <span class="keyword">if</span> (str.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span> || str.charAt(<span class="number">0</span>) == <span class="string">&#x27;+&#x27;</span>) i++;</span><br><span class="line">        <span class="comment">//如果是数字，循环继续 </span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; str.length() &amp;&amp; isNum(str.charAt(i)))&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> str.charAt(i) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="comment">//判断在加上之后是否会越界</span></span><br><span class="line">            <span class="keyword">if</span> ((res &gt; Integer.MAX_VALUE/<span class="number">10</span>) || (res == Integer.MAX_VALUE/<span class="number">10</span> &amp;&amp; r &gt; <span class="number">7</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> flag &gt; <span class="number">0</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">            res = res *<span class="number">10</span> + r;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag&gt;<span class="number">0</span>? res:-res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是不是数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isNum</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c - <span class="string">&#x27;0&#x27;</span> &gt;=<span class="number">0</span> &amp;&amp; c - <span class="string">&#x27;9&#x27;</span> &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-10-剑指-Offer-44-数字序列中某一位的数字"><a href="#0-10-剑指-Offer-44-数字序列中某一位的数字" class="headerlink" title="0.10 剑指 Offer 44. 数字序列中某一位的数字"></a>0.10 <a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/">剑指 Offer 44. 数字序列中某一位的数字</a></h3><p>数字以0123456789101112131415…的格式序列化到一个字符序列中。在这个序列中，第5位（从下标0开始计数）是5，第13位是1，第19位是4，等等。</p><p>请写一个函数，求任意第n位对应的数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//特殊情况</span></span><br><span class="line">       <span class="keyword">if</span>(n&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(n&gt;=<span class="number">0</span> &amp;&amp; n&lt;=<span class="number">9</span>) <span class="keyword">return</span> n; </span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//防止越界</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> n;</span><br><span class="line">   <span class="type">long</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">           <span class="comment">//当前数字的长度</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">           <span class="comment">//当前数字的个数</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">   <span class="type">char</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">           <span class="comment">//当前占的位数，循环到包含第n位数字</span></span><br><span class="line">   <span class="keyword">while</span>((temp+base*num) &lt; m) &#123;</span><br><span class="line">               <span class="comment">//长度</span></span><br><span class="line">   temp += base*num;</span><br><span class="line">               <span class="comment">//数字长度加一</span></span><br><span class="line">   base += <span class="number">1</span>;</span><br><span class="line">               <span class="comment">//长度为base的数字个数</span></span><br><span class="line">   num *= <span class="number">10</span>;</span><br><span class="line">   &#125;</span><br><span class="line">           <span class="comment">//a用来确定所在数字的大小</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> (m-temp)/base;</span><br><span class="line">           <span class="comment">//b用来确定在这个数字的第几位</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> (m-temp)%base;</span><br><span class="line">           </span><br><span class="line">   <span class="keyword">if</span>(b!=<span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//计算出这个数</span></span><br><span class="line">   <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">long</span>) (Math.pow(<span class="number">10</span>, base-<span class="number">1</span>) + a);</span><br><span class="line">               <span class="comment">//找到答案</span></span><br><span class="line">   res = String.valueOf(c).charAt((<span class="type">int</span>)b-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//b=0，说明是在前一个数的最后一位上</span></span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">long</span>) (Math.pow(<span class="number">10</span>, base-<span class="number">1</span>) + a - <span class="number">1</span>);</span><br><span class="line">   res = String.valueOf(c).charAt((<span class="type">int</span>)base-<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> Integer.parseInt(String.valueOf(res));</span><br><span class="line">   &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-11-无重复的最长子串"><a href="#0-11-无重复的最长子串" class="headerlink" title="0.11 无重复的最长子串"></a>0.11 无重复的最长子串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双指针，如果已经包含就不断前移</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        Set&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>,i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; n &amp;&amp; j &lt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(s.charAt(j)))&#123;</span><br><span class="line">                set.add(s.charAt(j));</span><br><span class="line">                j++;</span><br><span class="line">                res = Math.max(res,j-i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                set.remove(s.charAt(i));</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复</span></span><br><span class="line"><span class="comment">//我们定义不重复子串的开始位置为 start，结束位置为 end</span></span><br><span class="line"><span class="comment">//随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符</span></span><br><span class="line"><span class="comment">//无论是否更新 start，都会更新其 map 数据结构和结果 ans。</span></span><br><span class="line"><span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span> ,left = <span class="number">0</span>; right &lt; n ;right++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(s.charAt(right)))&#123;</span><br><span class="line">                left = Math.max(map.get(s.charAt(right)),left);  </span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res,right-left+<span class="number">1</span>);</span><br><span class="line">            map.put(s.charAt(right),right+<span class="number">1</span>);  <span class="comment">//加一是为了返回重复字符的后一位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-12-最小覆盖子串"><a href="#0-12-最小覆盖子串" class="headerlink" title="0.12 最小覆盖子串"></a>0.12 最小覆盖子串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="literal">null</span> || s == <span class="string">&quot;&quot;</span> || t == <span class="literal">null</span> || t == <span class="string">&quot;&quot;</span> || s.length() &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用来统计t中每个字符出现次数  char型可以转换成0-128的int，对应字符的ASCII码,也就是用字符对应的int值作为下标</span></span><br><span class="line">        <span class="type">int</span>[] needs = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];    <span class="comment">//标记字符串t中字符</span></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span>[] window = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">128</span>];  <span class="comment">//标记滑动窗口中的字符</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;<span class="comment">//加入数组中</span></span><br><span class="line">            needs[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//当前有多少个字符匹配成功</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来记录最短需要多少个字符。</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minLength</span> <span class="operator">=</span> s.length() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">ch</span> <span class="operator">=</span> s.charAt(right);</span><br><span class="line">            window[ch]++;</span><br><span class="line">            <span class="keyword">if</span> (needs[ch] &gt; <span class="number">0</span> &amp;&amp; needs[ch] &gt;= window[ch]) &#123;<span class="comment">//如果字符匹配成功，count++</span></span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (count == t.length()) &#123;<span class="comment">//当匹配整个字符串都匹配成功，记录下当前的最短覆盖子串，然后从左侧缩小窗口，如果最左是有效的字符，右移右侧的指针直到再次匹配成功</span></span><br><span class="line">                ch = s.charAt(left);</span><br><span class="line">                <span class="keyword">if</span> (needs[ch] &gt; <span class="number">0</span> &amp;&amp; needs[ch] &gt;= window[ch]) &#123;<span class="comment">//如果最左的元素属于有效字符，减少count</span></span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (right - left + <span class="number">1</span> &lt; minLength) &#123;<span class="comment">//如果当前窗口的大小小于最短，更新minlength</span></span><br><span class="line">                    minLength = right - left + <span class="number">1</span>;</span><br><span class="line">                    res = s.substring(left, right + <span class="number">1</span>);<span class="comment">//截取当前最短的子串作为答案</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                window[ch]--;<span class="comment">//将最左元素从窗口中去除</span></span><br><span class="line">                left++;<span class="comment">//左指针右移</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            right++;<span class="comment">//右指针右移</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="0-13-剑指-Offer-57-II-和为s的连续正数序列"><a href="#0-13-剑指-Offer-57-II-和为s的连续正数序列" class="headerlink" title="0.13 剑指 Offer 57 - II. 和为s的连续正数序列"></a>0.13 <a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/">剑指 Offer 57 - II. 和为s的连续正数序列</a></h3><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] findContinuousSequence(<span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">//左右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(i &lt;= target / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="comment">//如果和小于目标，右边界右移</span></span><br><span class="line">            <span class="keyword">if</span>(sum &lt; target)&#123;</span><br><span class="line">                sum += j;</span><br><span class="line">                j++;</span><br><span class="line">            <span class="comment">//如果和大于目标，左边界右移</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target)&#123;</span><br><span class="line">                sum -= i;</span><br><span class="line">                i++;</span><br><span class="line">            <span class="comment">//否则，将答案加入</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[j-i];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> i ; k &lt; j; k++)&#123;</span><br><span class="line">                    a[k - i] = k;</span><br><span class="line">                &#125;</span><br><span class="line">                res.add(a);</span><br><span class="line">                <span class="comment">//以i为起点已经没有答案了，左边界右移</span></span><br><span class="line">                sum -= i;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[res.size()][] );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-14-剑指-Offer-59-I-滑动窗口的最大值"><a href="#0-14-剑指-Offer-59-I-滑动窗口的最大值" class="headerlink" title="0.14 剑指 Offer 59 - I. 滑动窗口的最大值"></a>0.14 <a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/">剑指 Offer 59 - I. 滑动窗口的最大值</a></h3><p>给定一个数组 <code>nums</code> 和滑动窗口的大小 <code>k</code>，请找出所有滑动窗口里的最大值。</p><p>思路：怎么样在每次窗口滑动后在O(1)的时间获得最大值——-单调队列，队列头就是最大的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//维护一个单调递减的双端队列</span></span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>,i = <span class="number">1</span>-k ; j &lt; nums.length ; i++,j++)&#123;</span><br><span class="line">            <span class="comment">//如果窗口已经成型，并且滑动时移除的是最大值</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; deque.peekFirst() == nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//移除队列中所有小于新加入的值</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j])&#123;</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//加入队列</span></span><br><span class="line">            deque.add(nums[j]);</span><br><span class="line">            <span class="comment">//记录最大值</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                res[i] = deque.peekFirst();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Algorithm] Search</title>
      <link href="/2021/06/12/Algorithm/Search/"/>
      <url>/2021/06/12/Algorithm/Search/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><h2 id="1-BFS"><a href="#1-BFS" class="headerlink" title="1 BFS"></a>1 BFS</h2><p>广度优先搜索一层一层的进行遍历，每次遍历以上层遍历的结果作为起点，遍历一个距离能达到的节点，注意去除重复遍历的情况</p><h3 id="1-1-279-完全平方数"><a href="#1-1-279-完全平方数" class="headerlink" title="1.1 279. 完全平方数"></a>1.1 <a href="https://leetcode-cn.com/problems/perfect-squares/">279. 完全平方数</a></h3><p>给定正整数 <em>n</em>，找到若干个完全平方数（比如 <code>1, 4, 9, 16, ...</code>）使得它们的和等于 <em>n</em>。你需要让组成和的完全平方数的个数最少。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSquares</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    HashSet&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    queue.add(n);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">        level++; <span class="comment">// 开始生成下一层</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">//依次减 1, 4, 9... 生成下一层的节点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j * j &lt;= cur; j++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> cur - j * j;</span><br><span class="line">                <span class="keyword">if</span> (next == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> level;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!visited.contains(next)) &#123;</span><br><span class="line">                    queue.offer(next);</span><br><span class="line">                    visited.add(next);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-127-单词接龙"><a href="#1-2-127-单词接龙" class="headerlink" title="1.2 127. 单词接龙"></a>1.2 <a href="https://leetcode-cn.com/problems/word-ladder/">127. 单词接龙</a></h3><p>给定两个单词（beginWord 和 endWord）和一个字典，找到从 beginWord 到 endWord 的最短转换序列的长度。转换需遵循如下规则：</p><p>每次转换只能改变一个字母。<br>转换过程中的中间单词必须是字典中的单词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">        <span class="comment">// 第 1 步：先将 wordList 放到哈希表里，便于判断某个单词是否在 wordList 里</span></span><br><span class="line">        Set&lt;String&gt; wordSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordList);</span><br><span class="line">        <span class="keyword">if</span> (wordSet.size() == <span class="number">0</span> || !wordSet.contains(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        wordSet.remove(beginWord);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第 2 步：图的广度优先遍历，必须使用队列和表示是否访问过的 visited 哈希表</span></span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(beginWord);</span><br><span class="line">        Set&lt;String&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        visited.add(beginWord);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第 3 步：开始广度优先遍历，包含起点，因此初始化的时候步数为 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">currentSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; currentSize; i++) &#123;</span><br><span class="line">                <span class="comment">// 依次遍历当前队列中的单词</span></span><br><span class="line">                <span class="type">String</span> <span class="variable">currentWord</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="comment">// 如果 currentWord 能够修改 1 个字符与 endWord 相同，则返回 step + 1</span></span><br><span class="line">                <span class="keyword">if</span> (changeWordEveryOneLetter(currentWord, endWord, queue, visited, wordSet)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> step + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 尝试对 currentWord 修改每一个字符，看看是不是能与 endWord 匹配</span></span><br><span class="line"><span class="comment">     * @param currentWord</span></span><br><span class="line"><span class="comment">     * @param endWord</span></span><br><span class="line"><span class="comment">     * @param queue</span></span><br><span class="line"><span class="comment">     * @param visited</span></span><br><span class="line"><span class="comment">     * @param wordSet</span></span><br><span class="line"><span class="comment">     * @return</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">changeWordEveryOneLetter</span><span class="params">(String currentWord, String endWord,</span></span><br><span class="line"><span class="params">                                             Queue&lt;String&gt; queue, Set&lt;String&gt; visited, Set&lt;String&gt; wordSet)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] charArray = currentWord.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; endWord.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 先保存，然后恢复</span></span><br><span class="line">            <span class="type">char</span> <span class="variable">originChar</span> <span class="operator">=</span> charArray[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">k</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; k &lt;= <span class="string">&#x27;z&#x27;</span>; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k == originChar) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                charArray[i] = k;</span><br><span class="line">                <span class="type">String</span> <span class="variable">nextWord</span> <span class="operator">=</span> String.valueOf(charArray);</span><br><span class="line">                <span class="keyword">if</span> (wordSet.contains(nextWord)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nextWord.equals(endWord)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!visited.contains(nextWord)) &#123;</span><br><span class="line">                        queue.add(nextWord);</span><br><span class="line">                        <span class="comment">// 注意：添加到队列以后，必须马上标记为已经访问</span></span><br><span class="line">                        visited.add(nextWord);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 恢复</span></span><br><span class="line">            charArray[i] = originChar;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-542-01-矩阵"><a href="#1-3-542-01-矩阵" class="headerlink" title="1.3 542. 01 矩阵"></a>1.3 <a href="https://leetcode-cn.com/problems/01-matrix/">542. 01 矩阵</a></h3><p>给定一个由 0 和 1 组成的矩阵，找出每个元素到最近的 0 的距离。</p><p>两个相邻元素间的距离为 1 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] updateMatrix(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">        Deque&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt; matrix[<span class="number">0</span>].length;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i,j&#125;);<span class="comment">//源点入队</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    matrix[i][j] = -<span class="number">1</span>;  <span class="comment">//标记未访问到的1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dir = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;; <span class="comment">//用来循环访问源点的上下左右</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] point = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> point[<span class="number">0</span>],y = point[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span>[] d:dir)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> x+d[<span class="number">0</span>],y1 = y +d[<span class="number">1</span>];<span class="comment">//源点的四周的点</span></span><br><span class="line">                <span class="keyword">if</span>(x1 &gt;= <span class="number">0</span> &amp;&amp; x1 &lt; matrix.length &amp;&amp; y1 &gt;=<span class="number">0</span> &amp;&amp; y1 &lt; matrix[<span class="number">0</span>].length &amp;&amp; matrix[x1][y1] == -<span class="number">1</span>)&#123;  <span class="comment">//这个1在矩阵内且未被访问过</span></span><br><span class="line">                    matrix[x1][y1] = matrix[x][y] + <span class="number">1</span>; <span class="comment">//距离加一</span></span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x1,y1&#125;); <span class="comment">//将源点四周的点入队</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matrix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-DFS"><a href="#2-DFS" class="headerlink" title="2 DFS"></a>2 DFS</h2><p>从一个节点出发，使用DFS对一个图进行遍历，能到达的都是从初始节点可达的，DFS用来解决可达性问题</p><p>注意：</p><p>用栈保存当前节点信息</p><h3 id="2-1-200-岛屿数量"><a href="#2-1-200-岛屿数量" class="headerlink" title="2.1 200. 岛屿数量"></a>2.1 <a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h3><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><p>处。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dir = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="comment">//空矩阵</span></span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="literal">null</span> || grid.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">islands</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; n ;j++)&#123;</span><br><span class="line">                <span class="comment">//有一个1，进行dfs，将与它相连的全部沉没</span></span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                    dfs(grid,i,j);</span><br><span class="line">                    islands++;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> islands;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid,<span class="type">int</span> r,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="comment">//终止条件：在范围外或者是0；</span></span><br><span class="line">        <span class="keyword">if</span>(r&gt;=m||r&lt;<span class="number">0</span>||c&gt;=n||c&lt;<span class="number">0</span>||grid[r][c]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//沉没当前</span></span><br><span class="line">        grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">//沉没四周</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] d :dir)&#123;</span><br><span class="line">            dfs(grid,r+d[<span class="number">0</span>],c+d[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-695-岛屿的最大面积"><a href="#2-2-695-岛屿的最大面积" class="headerlink" title="2.2 695. 岛屿的最大面积"></a>2.2 <a href="https://leetcode-cn.com/problems/max-area-of-island/">695. 岛屿的最大面积</a></h3><p>给定一个包含了一些 0 和 1 的非空二维数组 grid 。</p><p>一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。</p><p>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dir = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxAreaOfIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(grid == <span class="literal">null</span> ||grid.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxArea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m ;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; n ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    maxArea = Math.max(maxArea,dfs(grid,i,j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid,<span class="type">int</span> r,<span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;<span class="number">0</span> || r&gt;=grid.length || c&lt; <span class="number">0</span> || c&gt;=grid[<span class="number">0</span>].length || grid[r][c]==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[r][c] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] d : dir)&#123;</span><br><span class="line">            max += dfs(grid,r+d[<span class="number">0</span>],c+d[<span class="number">1</span>]);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-547-朋友圈"><a href="#2-3-547-朋友圈" class="headerlink" title="2.3 547. 朋友圈"></a>2.3 <a href="https://leetcode-cn.com/problems/friend-circles/">547. 朋友圈</a></h3><p>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p><p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求无向图的连通分量</span></span><br><span class="line"><span class="comment">//如果ij两人是朋友，那么ij之间有边相连</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCircleNum</span><span class="params">(<span class="type">int</span>[][] M)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[M.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                dfs(M, i, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] M, <span class="type">int</span> i, <span class="type">boolean</span>[] visited)</span> &#123;</span><br><span class="line">        visited[i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; M.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[j] &amp;&amp; M[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                dfs(M, j, visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-130-被围绕的区域"><a href="#2-4-130-被围绕的区域" class="headerlink" title="2.4 130. 被围绕的区域"></a>2.4 <a href="https://leetcode-cn.com/problems/surrounded-regions/">130. 被围绕的区域</a></h3><p>给定一个二维的矩阵，包含 <code>&#39;X&#39;</code> 和 <code>&#39;O&#39;</code>（<strong>字母 O</strong>）。</p><p>找到所有被 <code>&#39;X&#39;</code> 围绕的区域，并将这些区域里所有的 <code>&#39;O&#39;</code> 用 <code>&#39;X&#39;</code> 填充。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先填充最外侧，因为最外侧的O肯定不能被围绕，将它置为T，然后DFS它附近的O，标记</span></span><br><span class="line"><span class="comment">//全部标记完成后，遍历将O置为X，T置为O</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m,n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] dir = &#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(board == <span class="literal">null</span> || board.length == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        m = board.length;</span><br><span class="line">        n = board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            dfs(board,i,<span class="number">0</span>);</span><br><span class="line">            dfs(board,i,n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            dfs(board,<span class="number">0</span>,i);</span><br><span class="line">            dfs(board,m-<span class="number">1</span>,i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; m ; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span> ; j &lt; n ;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;T&#x27;</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board , <span class="type">int</span> r, <span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r &lt; <span class="number">0</span> || r &gt;= m || c &lt; <span class="number">0</span> || c &gt;= n || board[r][c] != <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[r][c] = <span class="string">&#x27;T&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span>[] d : dir)&#123;</span><br><span class="line">            dfs(board , r+d[<span class="number">0</span>] , c+d[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-417-太平洋大西洋水流问题"><a href="#2-5-417-太平洋大西洋水流问题" class="headerlink" title="2.5 417. 太平洋大西洋水流问题"></a>2.5 <a href="https://leetcode-cn.com/problems/pacific-atlantic-water-flow/">417. 太平洋大西洋水流问题</a></h3><p>给定一个 m x n 的非负整数矩阵来表示一片大陆上各个单元格的高度。“太平洋”处于大陆的左边界和上边界，而“大西洋”处于大陆的右边界和下边界。</p><p>规定水流只能按照上、下、左、右四个方向流动，且只能从高到低或者在同等高度上流动。</p><p>请找出那些水流既可以流动到“太平洋”，又能流动到“大西洋”的陆地单元的坐标。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反过来，从大西洋和太平洋向里面爬，两个区域的交点就是所需要的坐标</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">pacificAtlantic</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] dires = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> m, n;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[][] matrix;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pacificAtlantic</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        m = matrix.length;</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">this</span>.matrix = matrix;</span><br><span class="line">        <span class="type">boolean</span>[][] canReachP = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="type">boolean</span>[][] canReachA = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dfs(<span class="number">0</span>, i, canReachP);</span><br><span class="line">            dfs(m - <span class="number">1</span>, i, canReachA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dfs(i, <span class="number">0</span>, canReachP);</span><br><span class="line">            dfs(i, n - <span class="number">1</span>, canReachA);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(canReachA[i][j] &amp;&amp; canReachP[i][j])&#123;</span><br><span class="line">                    List&lt;Integer&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">                    temp.add(i);</span><br><span class="line">                    temp.add(j);</span><br><span class="line">                    res.add(temp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//换一种思路，从边界往里面走，只能走到比自己更高或者等高的地方。边界能走到的地方，就是能流入对应海洋的地方。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">boolean</span>[][] canReach)</span> &#123;</span><br><span class="line">        canReach[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">newX</span> <span class="operator">=</span> x + dires[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">newY</span> <span class="operator">=</span> y + dires[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (isIn(newX, newY) &amp;&amp; matrix[x][y] &lt;= matrix[newX][newY] &amp;&amp; !canReach[newX][newY]) &#123;</span><br><span class="line">                dfs(newX, newY, canReach);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isIn</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; m &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-Backtracking"><a href="#3-Backtracking" class="headerlink" title="3 Backtracking"></a>3 Backtracking</h2><h3 id="3-1-1-DFS与回溯的区别"><a href="#3-1-1-DFS与回溯的区别" class="headerlink" title="3.1 1.DFS与回溯的区别"></a>3.1 1.DFS与回溯的区别</h3><p>回溯属于DFS，普通的DFS用来求解可达性问题，而回溯建立在DFS基础上，在搜索过程中，达到结束条件后，恢复状态，回溯上一层，再次搜索。区别就在于有没有状态的重置。</p><p>回溯问题都可以抽象成树形结构，都是在集合中递归查找子集</p><p><strong>集合的大小决定数的宽度，递归的深度决定树的深度</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模板</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">backtracking</span><span class="params">(参数)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-2-回溯算法的使用场景"><a href="#3-2-2-回溯算法的使用场景" class="headerlink" title="3.2 2.回溯算法的使用场景"></a>3.2 2.回溯算法的使用场景</h3><p>当问题需要找出所有的解时，比如求解排列组合问题。</p><p>满足结束条件或者发现不是正确的路径的时候，<strong>撤销选择</strong>，回退到上一个状态，继续尝试。</p><h3 id="3-3-3-使用的步骤"><a href="#3-3-3-使用的步骤" class="headerlink" title="3.3 3.使用的步骤"></a>3.3 3.使用的步骤</h3><ul><li>画出递归树，找到状态变量（回溯函数的参数）</li><li>确定结束条件</li><li>找出选择列表，与函数参数相关</li><li>判断是否需要剪枝</li><li>做出选择，递归调用，进入下一层</li><li>撤销选择</li></ul><h3 id="3-4-4-回溯的类型"><a href="#3-4-4-回溯的类型" class="headerlink" title="3.4 4.回溯的类型"></a>3.4 4.回溯的类型</h3><div class="table-container"><table><thead><tr><th>类型</th><th>概念</th></tr></thead><tbody><tr><td>组合问题</td><td>N个数里面按一定规则找出k个数的集合</td></tr><tr><td>排列</td><td>N个数按一定规则全排列，求出所有的排列方式</td></tr><tr><td>切割问题</td><td>一个字符串按一定规则有多少种切割方式</td></tr><tr><td>子集问题</td><td>N个数的集合里有多少种符合条件的子集</td></tr><tr><td>棋盘问题</td><td>N皇后，数独等</td></tr></tbody></table></div><p>组合不强调元素顺序，排列强调元素顺序</p><p>“排列”类型问题和“子集、组合”问题不同在于：“排列”问题使用used数组来标识选择列表，而“子集、组合”问题则使用start参数。另外还需注意两种问题的判重剪枝！</p><h4 id="3-4-1-组合问题"><a href="#3-4-1-组合问题" class="headerlink" title="3.4.1 组合问题"></a>3.4.1 组合问题</h4><p>如果是一个集合求组合，需要 start 来控制 for 循环的起始位置</p><p>如果是多个集合取组合，他们互不影响，就不用 start</p><h5 id="3-4-1-1-去重："><a href="#3-4-1-1-去重：" class="headerlink" title="3.4.1.1 去重："></a>3.4.1.1 去重：</h5><p>当 candidate[i] == candidate[i-1] 时，有两种情况</p><p>两个维度：同一个递归层的重复和递归枝的重复，可以根据 used[i-1] 进行判断</p><p>如果是同一层上的重复，used[i-1]  == false 不可以进行重复的选取</p><p>如果是同一枝上的重复，used[i-1]  == true 可以进行重复的选取</p><h4 id="3-4-2-切割问题"><a href="#3-4-2-切割问题" class="headerlink" title="3.4.2 切割问题"></a>3.4.2 切割问题</h4><ul><li>如何模拟那些切割线</li><li>切割问题中递归如何终止</li><li>在递归循环中如何截取子串</li><li>如何判断回文</li></ul><h4 id="3-4-3-子集问题"><a href="#3-4-3-子集问题" class="headerlink" title="3.4.3 子集问题"></a>3.4.3 子集问题</h4><p>子集问题是收集所有节点的结果，组合是收集叶子节点的结果</p><h5 id="3-4-3-1-递增子序列的去重不能先排序"><a href="#3-4-3-1-递增子序列的去重不能先排序" class="headerlink" title="3.4.3.1 递增子序列的去重不能先排序"></a>3.4.3.1 递增子序列的去重不能先排序</h5><h5 id="3-4-3-2-子集类的剪枝："><a href="#3-4-3-2-子集类的剪枝：" class="headerlink" title="3.4.3.2 子集类的剪枝："></a>3.4.3.2 子集类的剪枝：</h5><p>判断是否需要剪枝，先排序</p><p>去除从重复的集合，也就是去除当前的选择列表中，与上一个重复的数，所引出的分支</p><h4 id="3-4-4-排列问题"><a href="#3-4-4-排列问题" class="headerlink" title="3.4.4 排列问题"></a>3.4.4 排列问题</h4><p>排列的有序的，因此不需要 start，每次都是从0开始</p><p>需要一个 used 数组对已经使用的进行记录</p><h5 id="3-4-4-1-排列的去重：使用-used-i-1-false-，即树层去重，效率更高"><a href="#3-4-4-1-排列的去重：使用-used-i-1-false-，即树层去重，效率更高" class="headerlink" title="3.4.4.1 排列的去重：使用(used[i - 1] == false)，即树层去重，效率更高"></a>3.4.4.1 排列的去重：<strong>使用(used[i - 1] == false)，即树层去重，效率更高</strong></h5><p>因为对于树层，如果重复元素相邻，那么如果前面的是false，肯定就已经是用过了</p><h4 id="3-4-5-去重问题"><a href="#3-4-5-去重问题" class="headerlink" title="3.4.5 去重问题"></a>3.4.5 去重问题</h4><p>用set和数组都可以，数组效率更高</p><h4 id="3-4-6-棋盘问题"><a href="#3-4-6-棋盘问题" class="headerlink" title="3.4.6 棋盘问题"></a>3.4.6 棋盘问题</h4><h5 id="3-4-6-1-N皇后："><a href="#3-4-6-1-N皇后：" class="headerlink" title="3.4.6.1 N皇后："></a>3.4.6.1 N皇后：</h5><p>二维矩阵中矩阵的高就是这颗树的高度，矩阵的宽就是树形结构中每一个节点的宽度。</p><p><strong>棋盘的宽度就是for循环的长度，递归的深度就是棋盘的高度</strong></p><h5 id="3-4-6-2-数独："><a href="#3-4-6-2-数独：" class="headerlink" title="3.4.6.2 数独："></a>3.4.6.2 数独：</h5><p>相较于N皇后，每一列每一行都只要放一个数字，只需要一层 for 循环遍历一行，递归来遍历列，然后一行一列确定皇后的唯一位置。</p><p><strong>棋盘的每一个位置都要放一个数字，并检查数字是否合法，解数独的树形结构要比N皇后更宽更深</strong></p><h3 id="3-5-17-电话号码的字母组合"><a href="#3-5-17-电话号码的字母组合" class="headerlink" title="3.5 17. 电话号码的字母组合"></a>3.5 <a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h3><p>给定一个仅包含数字 <code>2-9</code> 的字符串，返回所有它能表示的字母组合。</p><p>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//记录数字对应字符串的映射</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] Keys = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">letterCombinations</span><span class="params">(String digits)</span> &#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(digits == <span class="literal">null</span> || digits.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        BackTracking(<span class="keyword">new</span> <span class="title class_">StringBuilder</span>(), res, digits);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">BackTracking</span><span class="params">(StringBuilder prefix, List&lt;String&gt; res, <span class="keyword">final</span> String digits)</span>&#123;</span><br><span class="line">        <span class="comment">//递归中止条件</span></span><br><span class="line">        <span class="keyword">if</span>(prefix.length() == digits.length())&#123;</span><br><span class="line">            <span class="comment">//作为答案加入</span></span><br><span class="line">            res.add(prefix.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前应当映射的数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> digits.charAt(prefix.length()) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">//数字对应的字符串</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">letters</span> <span class="operator">=</span> Keys[cur];</span><br><span class="line">        <span class="comment">//遍历其中的字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c : letters.toCharArray())&#123;</span><br><span class="line">            <span class="comment">//添加字符</span></span><br><span class="line">            prefix.append(c);</span><br><span class="line">            <span class="comment">//以添加后的为基础递归</span></span><br><span class="line">            BackTracking(prefix,res,digits);</span><br><span class="line">            <span class="comment">//递归结束，回溯，移除当前的字符</span></span><br><span class="line">            prefix.deleteCharAt(prefix.length() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-93-复原IP地址"><a href="#3-6-93-复原IP地址" class="headerlink" title="3.6 93. 复原IP地址"></a>3.6 <a href="https://leetcode-cn.com/problems/restore-ip-addresses/">93. 复原IP地址</a></h3><p>给定一个只包含数字的字符串，复原它并返回所有可能的 IP 地址格式。</p><p>有效的 IP 地址 正好由四个整数（每个整数位于 0 到 255 之间组成，且不能含有前导 0），整数之间用 ‘.’ 分隔。</p><p>例如：”0.1.2.201” 和 “192.168.1.1” 是 有效的 IP 地址，但是 “0.011.255.245”、”192.168.1.312” 和 “192.168@1.1” 是 无效的 IP 地址。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">restoreIpAddresses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//记录答案</span></span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//记录当前ip地址</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">curAddress</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        backTracking(<span class="number">0</span>,curAddress,res,s);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> k, StringBuilder curAddress, List&lt;String&gt; res, String s)</span>&#123;</span><br><span class="line">        <span class="comment">//递归中止条件，ip地址有四个数或者字符串为空</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">4</span> || s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//如果是有效的ip地址，加入答案中</span></span><br><span class="line">            <span class="keyword">if</span>(k == <span class="number">4</span> &amp;&amp; s.length() == <span class="number">0</span>)&#123;</span><br><span class="line">                res.add(curAddress.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//针对1，2，3位的ip地址逐个判断</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() &amp;&amp; i &lt;= <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//如果首位是零并且不是一位数，那么是无效的</span></span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//从字符串中取出相应长度的数字</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">part</span> <span class="operator">=</span> s.substring(<span class="number">0</span>,i+<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//判断是否有效</span></span><br><span class="line">            <span class="keyword">if</span>(Integer.valueOf(part) &lt;= <span class="number">255</span>)&#123;</span><br><span class="line">                <span class="comment">//累加方式</span></span><br><span class="line">                <span class="keyword">if</span>(curAddress.length() != <span class="number">0</span>)&#123;</span><br><span class="line">                    part = <span class="string">&#x27;.&#x27;</span> + part;</span><br><span class="line">                &#125;</span><br><span class="line">                curAddress.append(part);</span><br><span class="line">                <span class="comment">//进行下一步的递归</span></span><br><span class="line">                backTracking(k+<span class="number">1</span>,curAddress,res,s.substring(i+<span class="number">1</span>));</span><br><span class="line">                <span class="comment">//取消上一层的状态</span></span><br><span class="line">                curAddress.delete(curAddress.length() - part.length(), curAddress.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-257-二叉树的所有路径"><a href="#3-7-257-二叉树的所有路径" class="headerlink" title="3.7 257. 二叉树的所有路径"></a>3.7 <a href="https://leetcode-cn.com/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h3><p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        helper(root,<span class="string">&quot;&quot;</span>,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//前序遍历，根-&gt;左-&gt;右</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(TreeNode root,String path,List&lt;String&gt; list)</span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)   <span class="keyword">return</span>;</span><br><span class="line">        path += Integer.toString(root.val);</span><br><span class="line">        <span class="comment">//如果到底了，复制path，加入答案</span></span><br><span class="line">        <span class="keyword">if</span>((root.left == <span class="literal">null</span>) &amp;&amp; (root.right == <span class="literal">null</span>))&#123; </span><br><span class="line">            list.add(path.toString());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            helper(root.left,path,list);</span><br><span class="line">            helper(root.right,path,list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-46-全排列"><a href="#3-8-46-全排列" class="headerlink" title="3.8 46. 全排列"></a>3.8 <a href="https://leetcode-cn.com/problems/permutations/">46. 全排列</a></h3><p>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//全排列</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//当前排列</span></span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//标记是否已经访问过</span></span><br><span class="line">        <span class="type">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        backTracking (cur, res, hasVisited, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">boolean</span>[] hasVisited, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="comment">//加入结果</span></span><br><span class="line">        <span class="keyword">if</span>(cur.size() == nums.length)&#123;</span><br><span class="line">            <span class="comment">//要新建，不然后面会被修改</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cur));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历可能的组合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hasVisited.length; i++)&#123;</span><br><span class="line">            <span class="comment">//如果已经访问过的，通过</span></span><br><span class="line">           <span class="keyword">if</span>(hasVisited[i])&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//加入答案，将访问标记置为true</span></span><br><span class="line">           hasVisited[i] = <span class="literal">true</span>;</span><br><span class="line">           cur.add(nums[i]); </span><br><span class="line">           <span class="comment">//回溯剩下的部分</span></span><br><span class="line">           backTracking(cur,res,hasVisited,nums);</span><br><span class="line">           <span class="comment">//移除之前回溯的状态</span></span><br><span class="line">           cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">           hasVisited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-47-全排列-II"><a href="#3-9-47-全排列-II" class="headerlink" title="3.9 47. 全排列 II"></a>3.9 <a href="https://leetcode-cn.com/problems/permutations-ii/">47. 全排列 II</a></h3><p>给定一个可包含重复数字的序列 <code>nums</code> ，<strong>按任意顺序</strong> 返回所有不重复的全排列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先进行排序，在遍历的时候判断这个元素是否等于上一个元素，如果等于，并且前一个元素还没有访问，那么跳过这个元素，或者是访问了跳过当前元素，需要跳过一个</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permuteUnique</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//全排列</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//当前排列</span></span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//标记是否已经访问过</span></span><br><span class="line">        <span class="type">boolean</span>[] hasVisited = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">        <span class="comment">//回溯</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        backTracking(cur, res, hasVisited, nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">boolean</span>[] hasVisited, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="comment">//加入结果</span></span><br><span class="line">        <span class="keyword">if</span>(cur.size() == nums.length)&#123;</span><br><span class="line">            <span class="comment">//要新建，不然后面会被修改</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cur));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历可能的组合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hasVisited.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>] &amp;&amp; !hasVisited[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果已经访问过的，通过</span></span><br><span class="line">           <span class="keyword">if</span>(hasVisited[i])&#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//加入答案，将访问标记置为true</span></span><br><span class="line">           hasVisited[i] = <span class="literal">true</span>;</span><br><span class="line">           cur.add(nums[i]); </span><br><span class="line">           <span class="comment">//回溯剩下的部分</span></span><br><span class="line">           backTracking(cur,res,hasVisited,nums);</span><br><span class="line">           <span class="comment">//移除之前回溯的状态</span></span><br><span class="line">           cur.remove(cur.size()-<span class="number">1</span>);</span><br><span class="line">           hasVisited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-10-77-组合"><a href="#3-10-77-组合" class="headerlink" title="3.10 77. 组合"></a>3.10 <a href="https://leetcode-cn.com/problems/combinations/">77. 组合</a></h3><p>给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backTracking(cur, res, <span class="number">1</span>, k, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res, <span class="type">int</span> start, <span class="type">int</span> k, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">//如果有k个数了</span></span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从起点开始遍历，因为有k个数那么作为起点，肯定不会大于n-k+1，可以用来剪枝</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt;= n-k+<span class="number">1</span>; i++)&#123;</span><br><span class="line">            cur.add(i);</span><br><span class="line">            <span class="comment">//下次递归起点加一</span></span><br><span class="line">            backTracking(cur, res, i+<span class="number">1</span>, k-<span class="number">1</span>, n);</span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-11-78-子集"><a href="#3-11-78-子集" class="headerlink" title="3.11 78. 子集"></a>3.11 <a href="https://leetcode-cn.com/problems/subsets/">78. 子集</a></h3><p>给定一组<strong>不含重复元素</strong>的整数数组 <em>nums</em>，返回该数组所有可能的子集（幂集）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//对应不同长度的子集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; size &lt;= nums.length; size++)&#123;</span><br><span class="line">            backTracking(<span class="number">0</span>,size,nums,cur,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//start：状态变量，用来标识当前的选择列表的起始位置，控制选择列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> size, <span class="type">int</span>[] nums, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.size() == size)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            cur.add(nums[i]);</span><br><span class="line">            backTracking(i+<span class="number">1</span>,size,nums,cur,res);</span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-12-90-子集-II"><a href="#3-12-90-子集-II" class="headerlink" title="3.12 90. 子集 II"></a>3.12 <a href="https://leetcode-cn.com/problems/subsets-ii/">90. 子集 II</a></h3><p>给定一个可能包含重复元素的整数数组 <strong><em>nums</em></strong>，返回该数组所有可能的子集（幂集）。</p><p><strong>说明：</strong>解集不能包含重复的子集。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; cur = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//对应不同长度的子集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>; size &lt;= nums.length; size++)&#123;</span><br><span class="line">            backTracking(<span class="number">0</span>,size,nums,cur,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//start：状态变量，用来标识当前的选择列表的起始位置，控制选择列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> size, <span class="type">int</span>[] nums, List&lt;Integer&gt; cur, List&lt;List&lt;Integer&gt;&gt; res)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.size() == size)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(cur));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从start到末尾，就是当前的选择列表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="comment">//去除当前选择列表中，与上一个数重复的数</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;start &amp;&amp; nums[i] == nums[i-<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur.add(nums[i]);</span><br><span class="line">            backTracking(i+<span class="number">1</span>,size,nums,cur,res);</span><br><span class="line">            cur.remove(cur.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-13-491-递增子序列"><a href="#3-13-491-递增子序列" class="headerlink" title="3.13 491. 递增子序列"></a>3.13 <a href="https://leetcode-cn.com/problems/increasing-subsequences/">491. 递增子序列</a></h3><p>给定一个整型数组, 你的任务是找到所有该数组的递增子序列，递增子序列的长度至少是2。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意与子集的区别</span></span><br><span class="line"><span class="comment">//这里只要本层重复使用元素，递增子序列就会重复：如&#123;4，7，6，7&#125;，如果重复使用，会有两个&#123;4，7&#125;</span></span><br><span class="line"><span class="comment">//子集问题是看排序后相邻的相同元素是否重复使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findSubsequences</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//答案</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//路径</span></span><br><span class="line">        List&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        backTracking(res, path, <span class="number">0</span>,  nums);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; res, List&lt;Integer&gt; path, <span class="type">int</span> start,<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(path.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//只负责记录本层是否重复使用了，新的一层会清空</span></span><br><span class="line">        <span class="type">boolean</span>[] used = <span class="keyword">new</span> <span class="title class_">boolean</span>[<span class="number">201</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> start; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((path.size() &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt; path.get(path.size() - <span class="number">1</span>)) || used[nums[i]+<span class="number">100</span>] == <span class="literal">true</span>   )&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            used[nums[i] + <span class="number">100</span>] = <span class="literal">true</span>;</span><br><span class="line">            path.add(nums[i]);</span><br><span class="line">            backTracking(res,path,i+<span class="number">1</span>,nums);</span><br><span class="line">            path.remove(path.size() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-14-51-N-皇后"><a href="#3-14-51-N-皇后" class="headerlink" title="3.14 51. N 皇后"></a>3.14 <a href="https://leetcode-cn.com/problems/n-queens/">51. N 皇后</a></h3><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p>二维矩阵中矩阵的高就是这颗树的高度，矩阵的宽就是树型结构中每一个节点的宽度。</p><p><strong>递归深度就是row控制棋盘的行，每一层里for循环的col控制棋盘的列，一行一列，确定了放置皇后的位置。</strong></p><p><strong>只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径：board 中小于 row 的那些行都已经成功放置了皇后</span></span><br><span class="line"><span class="comment">// 选择列表：第 row 行的所有列都是放置皇后的选择</span></span><br><span class="line"><span class="comment">// 结束条件：row 超过 board 的最后一行</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">solveNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[][] board = <span class="keyword">new</span> <span class="title class_">char</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c:board)&#123;</span><br><span class="line">            Arrays.fill(c,<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        backTracking(board,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">backTracking</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> row)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row == board.length)&#123;</span><br><span class="line">            res.add(arrayToList(board));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> <span class="number">0</span>; col &lt; board.length; col++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isValid(board,row,col))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            board[row][col] = <span class="string">&#x27;Q&#x27;</span>;</span><br><span class="line">            backTracking(board,row+<span class="number">1</span>);</span><br><span class="line">            board[row][col] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; <span class="title function_">arrayToList</span><span class="params">(<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">        List&lt;String&gt; temp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span>[] c : board)&#123;</span><br><span class="line">            <span class="type">StringBuffer</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">char</span> i : c)&#123;</span><br><span class="line">                sb.append(i);</span><br><span class="line">            &#125;</span><br><span class="line">            temp.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//因为在每次递归的 for 循环中只会在同一行选一个，所有不用去重</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> row, <span class="type">int</span> col)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="comment">//因为下面的还没有放置，只需要检查上面即可</span></span><br><span class="line">        <span class="comment">// 检查列是否有皇后互相冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][col] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查右上方是否有皇后互相冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col + <span class="number">1</span>;</span><br><span class="line">             i &gt;= <span class="number">0</span> &amp;&amp; j &lt; n; i--, j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查左上方是否有皇后互相冲突</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> row - <span class="number">1</span>, j = col - <span class="number">1</span>;</span><br><span class="line">             i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>; i--, j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;Q&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-15-时间复杂度"><a href="#3-15-时间复杂度" class="headerlink" title="3.15 时间复杂度"></a>3.15 时间复杂度</h3><p>子集问题分析：</p><ul><li>时间复杂度：O(n <em> 2^n)，因为每一个元素的状态无外乎取与不取，所以时间复杂度为O(2^n)，构造每一组子集都需要填进数组，又有需要O(n)，最终时间复杂度：O(n </em> 2^n)</li><li>空间复杂度：O(n)，递归深度为n，所以系统栈所用空间为O(n)，每一层递归所用的空间都是常数级别，注意代码里的result和path都是全局变量，就算是放在参数里，传的也是引用，并不会新申请内存空间，最终空间复杂度为O(n)</li></ul><p>排列问题分析：</p><ul><li>时间复杂度：O(n!)，这个可以从排列的树形图中很明显发现，每一层节点为n，第二层每一个分支都延伸了n-1个分支，再往下又是n-2个分支，所以一直到叶子节点一共就是 n <em> n-1 </em> n-2 * ….. 1 = n!。</li><li>空间复杂度：O(n)，和子集问题同理。</li></ul><p>组合问题分析：</p><ul><li>时间复杂度：O(n * 2^n)，组合问题其实就是一种子集的问题，所以组合问题最坏的情况，也不会超过子集问题的时间复杂度。</li><li>空间复杂度：O(n)，和子集问题同理。</li></ul><p>N皇后问题分析：</p><ul><li>时间复杂度：O(n!) ，其实如果看树形图的话，直觉上是O(n^n)，但皇后之间不能见面所以在搜索的过程中是有剪枝的，最差也就是O（n!），n!表示n <em> (n-1) </em> …. * 1。</li><li>空间复杂度：O(n)，和子集问题同理。</li></ul><p>解数独问题分析：</p><ul><li>时间复杂度：O(9^m) , m是’.’的数目。</li><li>空间复杂度：O(n^2)，递归的深度是n^2</li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Algorithm] Tree</title>
      <link href="/2021/06/12/Algorithm/Tree/"/>
      <url>/2021/06/12/Algorithm/Tree/</url>
      
        <content type="html"><![CDATA[<span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置  进入节点的时候 </span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    <span class="comment">// 中序位置左子树遍历完成</span></span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">// 后序位置  离开节点的时候</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历一遍二叉树得出答案  </span></span><br><span class="line"><span class="comment">// 通过分解问题计算出答案 定义递归函数完成</span></span><br><span class="line"><span class="comment">// 只有后序位置才能通过返回值获取子树的信息。</span></span><br><span class="line"><span class="comment">// 二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，</span></span><br><span class="line"><span class="comment">// 去达到自己的目的，你只需要单独思考每一个节点应该做什么</span></span><br></pre></td></tr></table></figure><p>[toc]</p><h2 id="1-遍历"><a href="#1-遍历" class="headerlink" title="1 遍历"></a>1 遍历</h2><h3 id="1-1-前序遍历"><a href="#1-1-前序遍历" class="headerlink" title="1.1 前序遍历"></a>1.1 前序遍历</h3><p>思路：根节点-&gt;左子树-&gt;右子树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            preorderTraversal(root.left);</span><br><span class="line">            preorderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归，用栈实现，先访问父节点，先压右再压左</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="comment">// 倒过来，因为栈后面压入先出</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-中序遍历"><a href="#1-2-中序遍历" class="headerlink" title="1.2 中序遍历"></a>1.2 中序遍历</h3><p>思路：左子树-&gt;根节点-&gt;右子树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            inorderTraversal(root.left);</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            inorderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归 先压左节点，然后从最后一个左节点开始访问，如果有右节点则访问</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//中序遍历结束的条件是栈空，并且树中全部节点都已经被压入栈</span></span><br><span class="line">        <span class="keyword">while</span>(stack.size() &gt; <span class="number">0</span> || root != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//从root开始，将root的左节点全部压入</span></span><br><span class="line">            <span class="comment">//这里是为了剔除右节点为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;<span class="comment">//压入后，从最左开始访问</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                res.add(node.val);</span><br><span class="line">                root = node.right;<span class="comment">//如果有右节点，那么将在下一个循环中被压入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-后序遍历"><a href="#1-3-后序遍历" class="headerlink" title="1.3 后序遍历"></a>1.3 后序遍历</h3><p>思路：左子树-&gt;右子树-&gt;根节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归的比较简单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归，可以将前序修改成根右左，倒序就是后序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val); <span class="comment">//根节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) stack.push(node.left);<span class="comment">//先压左再压右</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);<span class="comment">//倒序结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-987-二叉树的垂序遍历"><a href="#1-4-987-二叉树的垂序遍历" class="headerlink" title="1.4 987. 二叉树的垂序遍历"></a>1.4 <a href="https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/">987. 二叉树的垂序遍历</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录每个节点和对应的坐标 (row, col)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Triple</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> row, col;</span><br><span class="line">        <span class="keyword">public</span> TreeNode node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Triple</span><span class="params">(TreeNode node, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.node = node;</span><br><span class="line">            <span class="built_in">this</span>.row = row;</span><br><span class="line">            <span class="built_in">this</span>.col = col;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">verticalTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历二叉树，并且为所有节点生成对应的坐标</span></span><br><span class="line">        traverse(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 根据题意，根据坐标值对所有节点进行排序：</span></span><br><span class="line">        <span class="comment">// 按照 col 从小到大排序，col 相同的话按 row 从小到大排序，</span></span><br><span class="line">        <span class="comment">// 如果 col 和 row 都相同，按照 node.val 从小到大排序。</span></span><br><span class="line">        Collections.sort(nodes, (Triple a, Triple b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.col == b.col &amp;&amp; a.row == b.row) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.node.val - b.node.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a.col == b.col) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.row - b.row;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a.col - b.col;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 将排好序的节点组装成题目要求的返回格式</span></span><br><span class="line">        LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 记录上一列编号，初始化一个特殊值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preCol</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">            <span class="type">Triple</span> <span class="variable">cur</span> <span class="operator">=</span> nodes.get(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.col != preCol) &#123;</span><br><span class="line">                <span class="comment">// 开始记录新的一列</span></span><br><span class="line">                res.addLast(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">                preCol = cur.col;</span><br><span class="line">            &#125;</span><br><span class="line">            res.getLast().add(cur.node.val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Triple&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 二叉树遍历函数，记录所有节点对应的坐标</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录坐标</span></span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">Triple</span>(root, row, col));</span><br><span class="line">        <span class="comment">// 二叉树遍历框架</span></span><br><span class="line">        traverse(root.left, row + <span class="number">1</span>, col - <span class="number">1</span>);</span><br><span class="line">        traverse(root.right, row + <span class="number">1</span>, col + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-236-二叉树的最近公共祖先"><a href="#1-5-236-二叉树的最近公共祖先" class="headerlink" title="1.5 236. 二叉树的最近公共祖先"></a>1.5 <a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果root是最近的公共祖先，那么有三种情况：</span></span><br><span class="line"><span class="comment">//p和q在root的左右子树中；p=root，q在p的子树中；q=root，p在q的子树中</span></span><br><span class="line"><span class="comment">//递归对二叉树进行后序遍历：（左右中）遇到p或q返回</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">//中止条件：越过了叶子节点或者找到了p或q</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">//如果都为空，都没有，返回</span></span><br><span class="line">        <span class="comment">//都不空，返回root</span></span><br><span class="line">        <span class="comment">//有一个空，另一个就是最近公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-993-二叉树的堂兄弟节点"><a href="#1-6-993-二叉树的堂兄弟节点" class="headerlink" title="1.6 993. 二叉树的堂兄弟节点"></a>1.6 <a href="https://leetcode.cn/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a></h3><p>如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">parentX</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">parentY</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">depthX</span> <span class="operator">=</span> <span class="number">0</span>, depthY = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCousins</span><span class="params">(TreeNode root, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        traverse(root, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (depthX == depthY &amp;&amp; parentX != parentY) &#123;</span><br><span class="line">            <span class="comment">// 判断 x，y 是否是表兄弟节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> depth, TreeNode parent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == x) &#123;</span><br><span class="line">            <span class="comment">// 找到 x，记录它的深度和父节点</span></span><br><span class="line">            parentX = parent;</span><br><span class="line">            depthX = depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == y) &#123;</span><br><span class="line">            <span class="comment">// 找到 y，记录它的深度和父节点</span></span><br><span class="line">            parentY = parent;</span><br><span class="line">            depthY = depth;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root.left, depth + <span class="number">1</span>, root);</span><br><span class="line">        traverse(root.right, depth + <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-二叉树的下一个节点"><a href="#1-7-二叉树的下一个节点" class="headerlink" title="1.7 二叉树的下一个节点"></a>1.7 二叉树的下一个节点</h3><p>给定二叉树其中的一个结点，请找出其中序遍历顺序的下一个结点并且返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;TreeLinkNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeLinkNode <span class="title function_">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeLinkNode</span> <span class="variable">root</span> <span class="operator">=</span> pNode;</span><br><span class="line">        <span class="comment">// 找到父节点</span></span><br><span class="line">        <span class="keyword">while</span>(root.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            root = root.next;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size()-<span class="number">1</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list.get(i) == pNode) <span class="keyword">return</span> list.get(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeLinkNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        list.add(root);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有右子树，则找右子树的最左节点</span></span><br><span class="line"><span class="comment">//没右子树</span></span><br><span class="line"><span class="comment">//若x是父节点的左孩子。则x的父节点就是x的下一个节点。</span></span><br><span class="line"><span class="comment">//若x是父节点的右孩子。则沿着父节点向上，直到找到一个节点的父节点的左孩子是该节点，</span></span><br><span class="line"><span class="comment">//则该节点的父节点就是x的下一个节点</span></span><br></pre></td></tr></table></figure><h3 id="1-8-剑指-Offer-07-重建二叉树"><a href="#1-8-剑指-Offer-07-重建二叉树" class="headerlink" title="1.8 剑指 Offer 07. 重建二叉树"></a>1.8 <a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h3><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序第一个是根节点，而在中序的该值的左边是左子树，右边是右子树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder[<span class="number">0</span>] == inorder[i])&#123;</span><br><span class="line">                root.left = buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(inorder,<span class="number">0</span>,i));</span><br><span class="line">                root.right = buildTree(Arrays.copyOfRange(preorder,i+<span class="number">1</span>,preorder.length),Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Arrays.copyOfRange(T[ ] original,int from,int to)将一个原始的数组original，从下标from开始复制，复制到上标to，生成一个新的数组。注意这里包括下标from，不包括上标to。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] preorder;</span><br><span class="line">    <span class="comment">//可以用来查找根节点在中序中的对应位置</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++)</span><br><span class="line">            dic.put(inorder[i], i);</span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//root是根节点在前序中的位置，left，right是中序遍历中的边界</span></span><br><span class="line">    TreeNode <span class="title function_">recur</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;                          <span class="comment">// 递归终止</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[root]);          <span class="comment">// 建立根节点</span></span><br><span class="line">        <span class="comment">//找到左右子树的划分点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dic.get(preorder[root]);                       <span class="comment">// 划分根节点、左子树、右子树</span></span><br><span class="line">        <span class="comment">//左子树的根节点，左边界不变</span></span><br><span class="line">        node.left = recur(root + <span class="number">1</span>, left, i - <span class="number">1</span>);              <span class="comment">// 开启左子树递归</span></span><br><span class="line">        <span class="comment">//右子树的根节点就是根节点加上左子树长度加一</span></span><br><span class="line">        node.right = recur(root + i - left + <span class="number">1</span>, i + <span class="number">1</span>, right); <span class="comment">// 开启右子树递归</span></span><br><span class="line">        <span class="keyword">return</span> node;                                           <span class="comment">// 回溯返回根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-9-106-从中序与后序遍历序列构造二叉树"><a href="#1-9-106-从中序与后序遍历序列构造二叉树" class="headerlink" title="1.9 106. 从中序与后序遍历序列构造二叉树"></a>1.9 <a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h3><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储 inorder 中值到索引的映射</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; valToIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            valToIndex.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>,</span><br><span class="line">                    postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       定义：</span></span><br><span class="line"><span class="comment">       中序遍历数组为 inorder[inStart..inEnd]，</span></span><br><span class="line"><span class="comment">       后序遍历数组为 postorder[postStart..postEnd]，</span></span><br><span class="line"><span class="comment">       构造这个二叉树并返回该二叉树的根节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd,</span></span><br><span class="line"><span class="params">                <span class="type">int</span>[] postorder, <span class="type">int</span> postStart, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// root 节点对应的值就是后序遍历数组的最后一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> postorder[postEnd];</span><br><span class="line">        <span class="comment">// rootVal 在中序遍历数组中的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> valToIndex.get(rootVal);</span><br><span class="line">        <span class="comment">// 左子树的节点个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - inStart;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">// 递归构造左右子树</span></span><br><span class="line">        root.left = build(inorder, inStart, index - <span class="number">1</span>,</span><br><span class="line">                         postorder, postStart, postStart + leftSize - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        root.right = build(inorder, index + <span class="number">1</span>, inEnd,</span><br><span class="line">                          postorder, postStart + leftSize, postEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-10-257-二叉树的所有路径"><a href="#1-10-257-二叉树的所有路径" class="headerlink" title="1.10 257. 二叉树的所有路径"></a>1.10 <a href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h3><p>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        helper(root,<span class="string">&quot;&quot;</span>,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(TreeNode root,String path,List&lt;String&gt; list)</span>&#123;  <span class="comment">//前序遍历，根-&gt;左-&gt;右</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)   <span class="keyword">return</span>;</span><br><span class="line">        path += Integer.toString(root.val);</span><br><span class="line">        <span class="keyword">if</span>((root.left == <span class="literal">null</span>) &amp;&amp; (root.right == <span class="literal">null</span>))&#123;  <span class="comment">//如果到底了，复制path，加入答案</span></span><br><span class="line">            list.add(path.toString());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            helper(root.left,path,list);</span><br><span class="line">            helper(root.right,path,list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-11-297-二叉树的序列化与反序列化"><a href="#1-11-297-二叉树的序列化与反序列化" class="headerlink" title="1.11 297. 二叉树的序列化与反序列化"></a>1.11 <a href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">SEP</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">NULL</span> <span class="operator">=</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主函数，将二叉树序列化为字符串 */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        serialize(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 辅助函数，将二叉树存入 StringBuilder */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            sb.append(NULL).append(SEP);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/******前序遍历位置******/</span></span><br><span class="line">        sb.append(root.val).append(SEP);</span><br><span class="line">        serialize(root.left, sb);</span><br><span class="line">        serialize(root.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主函数，将字符串反序列化为二叉树结构 */</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="comment">// 将字符串转化成列表</span></span><br><span class="line">        LinkedList&lt;String&gt; nodes = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : data.split(SEP)) &#123;</span><br><span class="line">            nodes.addLast(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(nodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 辅助函数，通过 nodes 列表构造二叉树 */</span></span><br><span class="line">    TreeNode <span class="title function_">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/******前序遍历位置******/</span></span><br><span class="line">        <span class="comment">// 列表最左侧就是根节点</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> nodes.removeFirst();</span><br><span class="line">        <span class="keyword">if</span> (first.equals(NULL)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(first));</span><br><span class="line">        <span class="comment">// 会把左子树的元素全部移除</span></span><br><span class="line">        root.left = deserialize(nodes);</span><br><span class="line">        root.right = deserialize(nodes);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-12-124-二叉树中的最大路径和"><a href="#1-12-124-二叉树中的最大路径和" class="headerlink" title="1.12 124. 二叉树中的最大路径和"></a>1.12 <a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h3><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在后序遍历的时候顺便计算题目要求的最大路径和。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算单边路径和时顺便计算最大路径和</span></span><br><span class="line">        oneSideMax(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：计算从根节点 root 为起点的最大单边路径和</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">oneSideMax</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMaxSum</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, oneSideMax(root.left));</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMaxSum</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, oneSideMax(root.right));</span><br><span class="line">        <span class="comment">// 后序遍历位置，顺便更新最大路径和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pathMaxSum</span> <span class="operator">=</span> root.val + leftMaxSum + rightMaxSum;</span><br><span class="line">        res = Math.max(res, pathMaxSum);</span><br><span class="line">        <span class="comment">// 实现函数定义，左右子树的最大单边路径和加上根节点的值</span></span><br><span class="line">        <span class="comment">// 就是从根节点 root 为起点的最大单边路径和</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftMaxSum, rightMaxSum) + root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-13-114-二叉树展开为链表"><a href="#1-13-114-二叉树展开为链表" class="headerlink" title="1.13 114. 二叉树展开为链表"></a>1.13 <a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h3><p>给你二叉树的根结点 root ，请你将它展开为一个单链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：将以 root 为根的树拉平为链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 先递归拉平左右子树</span></span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/****后序遍历位置****/</span></span><br><span class="line">        <span class="comment">// 1、左右子树已经被拉平成一条链表</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、将左子树作为右子树</span></span><br><span class="line">        root.left = <span class="literal">null</span>;</span><br><span class="line">        root.right = left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、将原先的右子树接到当前右子树的末端</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (p.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        p.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-14-623-在二叉树中增加一行"><a href="#1-14-623-在二叉树中增加一行" class="headerlink" title="1.14 623. 在二叉树中增加一行"></a>1.14 <a href="https://leetcode.cn/problems/add-one-row-to-tree/">623. 在二叉树中增加一行</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> targetVal, targetDepth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">addOneRow</span><span class="params">(TreeNode root, <span class="type">int</span> val, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        targetVal = val;</span><br><span class="line">        targetDepth = depth;</span><br><span class="line">        <span class="comment">// 插入到第一行的话特殊对待一下</span></span><br><span class="line">        <span class="keyword">if</span> (targetDepth == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">newRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(targetVal);</span><br><span class="line">            newRoot.left = root;</span><br><span class="line">            <span class="keyword">return</span> newRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历二叉树，走到对应行进行插入</span></span><br><span class="line">        traverse(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">curDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        curDepth++;</span><br><span class="line">        <span class="keyword">if</span> (curDepth == targetDepth - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 进行插入</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">newLeft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(targetVal);</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">newRight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(targetVal);</span><br><span class="line">            newLeft.left = root.left;</span><br><span class="line">            newRight.right = root.right;</span><br><span class="line">            root.left = newLeft;</span><br><span class="line">            root.right = newRight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        curDepth--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-15-654-最大二叉树"><a href="#1-15-654-最大二叉树" class="headerlink" title="1.15 654. 最大二叉树"></a>1.15 <a href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/* 主函数 */</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义：将 nums[lo..hi] 构造成符合条件的树，返回根节点 */</span></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (lo &gt; hi) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到数组中的最大值和对应的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>, maxVal = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxVal &lt; nums[i]) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxVal);</span><br><span class="line">        <span class="comment">// 递归调用构造左右子树</span></span><br><span class="line">        root.left = build(nums, lo, index - <span class="number">1</span>);</span><br><span class="line">        root.right = build(nums, index + <span class="number">1</span>, hi);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-16-814-二叉树剪枝"><a href="#1-16-814-二叉树剪枝" class="headerlink" title="1.16 814. 二叉树剪枝"></a>1.16 <a href="https://leetcode.cn/problems/binary-tree-pruning/">814. 二叉树剪枝</a></h3><p>给你二叉树的根结点 root ，此外树的每个结点的值要么是 0 ，要么是 1 。</p><p>返回移除了所有不包含 1 的子树的原二叉树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：输入一棵二叉树，返回的二叉树叶子节点都是 1</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">pruneTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二叉树递归框架</span></span><br><span class="line">        root.left = pruneTree(root.left);</span><br><span class="line">        root.right = pruneTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历位置，判断自己是否是值为 0 的叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == <span class="number">0</span> &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回值会被父节点接收，相当于把自己删掉了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不是，正常返回</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-层序遍历"><a href="#2-层序遍历" class="headerlink" title="2 层序遍历"></a>2 层序遍历</h2><h3 id="2-1-102-二叉树的层序遍历"><a href="#2-1-102-二叉树的层序遍历" class="headerlink" title="2.1 102. 二叉树的层序遍历"></a>2.1 <a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="comment">// 记录当前层的节点，并将下一层的入队</span></span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                level.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>)</span><br><span class="line">                    q.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>)</span><br><span class="line">                    q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-103-二叉树的锯齿形层序遍历"><a href="#2-2-103-二叉树的锯齿形层序遍历" class="headerlink" title="2.2 103. 二叉树的锯齿形层序遍历"></a>2.2 <a href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h3><p>即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt;  queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            queue.offer(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置标记，记录顺序</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;   </span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    level.add(node.val);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 倒过来添加到队列里面</span></span><br><span class="line">                    level.add(<span class="number">0</span>,node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">            flag = !flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-662-二叉树最大宽度"><a href="#2-3-662-二叉树最大宽度" class="headerlink" title="2.3 662. 二叉树最大宽度"></a>2.3 <a href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a></h3><p>给你一棵二叉树的根节点 root ，返回树的 <strong>最大宽度</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据完全二叉树的概念，i位置节点的左子节点位置为2i，右子节点位置为2i+1；</span></span><br><span class="line"><span class="comment">//通过一个list记录节点对应的完全二叉树中的位置</span></span><br><span class="line"><span class="comment">//按层BFS二叉树，记录下list中每一层的前后位置之差，返回最大</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//节点队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();   </span><br><span class="line">        <span class="comment">//节点位置队列</span></span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        res.add(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">cur</span> <span class="operator">=</span> res.removeFirst();</span><br><span class="line">                <span class="comment">// 相应的位置也加入辅助队列</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                    res.add(cur*<span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                    res.add(cur * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最大宽度</span></span><br><span class="line">            <span class="keyword">if</span>(res.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                ans = Math.max(ans,res.getLast() - res.getFirst() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-958-二叉树的完全性检验"><a href="#2-4-958-二叉树的完全性检验" class="headerlink" title="2.4 958. 二叉树的完全性检验"></a>2.4 <a href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">958. 二叉树的完全性检验</a></h3><p>给定一个二叉树的 root ，确定它是否是一个 <em>完全二叉树</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历，判断是否出现过null</span></span><br><span class="line"><span class="comment">//通过一个 flag 进行记录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompleteTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;<span class="comment">//判断是否出现过null</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size ; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;<span class="comment">//如果当前节点不是null</span></span><br><span class="line">                    <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//如果之前出现就直接返回</span></span><br><span class="line">                    queue.add(node.left);<span class="comment">//不管有没有子节点，都加入</span></span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-5-222-完全二叉树的节点个数"><a href="#2-5-222-完全二叉树的节点个数" class="headerlink" title="2.5 222. 完全二叉树的节点个数"></a>2.5 <a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h3><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> countLevel(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> countLevel(root.right);</span><br><span class="line">        <span class="comment">// 层数一样，左边满，不一样，右边满</span></span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="comment">// 位运算 2^left</span></span><br><span class="line">            <span class="keyword">return</span> countNodes(root.right) + (<span class="number">1</span>&lt;&lt;left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> countNodes(root.left) + (<span class="number">1</span>&lt;&lt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countLevel</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            level++;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-199-二叉树的右视图"><a href="#2-6-199-二叉树的右视图" class="headerlink" title="2.6 199. 二叉树的右视图"></a>2.6 <a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h3><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* BFS 层序遍历解法 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// BFS 层序遍历，计算右侧视图</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="comment">// while 循环控制从上向下一层层遍历</span></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="comment">// 每一层头部就是最右侧的元素</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">last</span> <span class="operator">=</span> q.peek();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="comment">// 控制每一层从右向左遍历</span></span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每一层的最后一个节点就是二叉树的右侧视图</span></span><br><span class="line">            res.add(last.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DFS 递归遍历解法 */</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录递归的层数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView_DFS</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二叉树遍历函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历位置</span></span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">if</span> (res.size() &lt; depth) &#123;</span><br><span class="line">            <span class="comment">// 这一层还没有记录值</span></span><br><span class="line">            <span class="comment">// 说明 root 就是右侧视图的第一个节点</span></span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意，这里反过来，先遍历右子树再遍历左子树</span></span><br><span class="line">        <span class="comment">// 这样首先遍历的一定是右侧节点</span></span><br><span class="line">        traverse(root.right);</span><br><span class="line">        traverse(root.left);</span><br><span class="line">        <span class="comment">// 后序遍历位置</span></span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-递归"><a href="#3-递归" class="headerlink" title="3 递归"></a>3 递归</h2><h3 id="3-1-112-路径总和"><a href="#3-1-112-路径总和" class="headerlink" title="3.1 112. 路径总和"></a>3.1 <a href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h3><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//为空节点，false</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; root.val == sum)&#123; <span class="comment">//当路径总和等于目标且为叶子节点时，true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left,sum - root.val) || hasPathSum(root.right,sum - root.val);</span><br><span class="line">    &#125;  <span class="comment">//从当前节点的左右继续往下递归，目标值减去当前节点值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-113-路径总和-II"><a href="#3-2-113-路径总和-II" class="headerlink" title="3.2 113. 路径总和 II"></a>3.2 <a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h3><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java 文档中 Stack 类建议使用 Deque 代替 Stack，注意：只使用栈的相关接口</span></span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dfs(root, sum, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pathSum</span><span class="params">(TreeNode node, <span class="type">int</span> sum, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归终止条件 1：遇到空结点不再递归调用</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 沿途结点必须选择，这个时候要做两件事：1、sum 减去这个结点的值；2、添加到 path 里</span></span><br><span class="line">        sum -= node.val;</span><br><span class="line">        path.addLast(node.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归终止条件 2：遇到叶子结点，sum 恰好为 0，说明从根结点到叶子结点的路径是一个符合要求的解</span></span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span> &amp;&amp; node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// path 全局只有一份，必须做拷贝</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="comment">// 注意：这里 return 之前必须重置</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pathSum(node.left, sum, path, res);</span><br><span class="line">        pathSum(node.right, sum, path, res);</span><br><span class="line">        <span class="comment">// 递归完成以后，必须重置变量</span></span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    dfs(root, sum, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> sum, List&lt;Integer&gt; list,</span></span><br><span class="line"><span class="params">                List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">    <span class="comment">//如果节点为空直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//因为list是引用传递，为了防止递归的时候分支污染，我们要在每个路径</span></span><br><span class="line">    <span class="comment">//中都要新建一个subList</span></span><br><span class="line">    List&lt;Integer&gt; subList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">    <span class="comment">//把当前节点值加入到subList中</span></span><br><span class="line">    subList.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(root.val));</span><br><span class="line">    <span class="comment">//如果到达叶子节点，就不能往下走了，直接return</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果到达叶子节点，并且sum等于叶子节点的值，说明我们找到了一组，</span></span><br><span class="line">        <span class="comment">//要把它放到result中</span></span><br><span class="line">        <span class="keyword">if</span> (sum == root.val)</span><br><span class="line">            result.add(subList);</span><br><span class="line">        <span class="comment">//到叶子节点之后直接返回，因为在往下就走不动了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没到达叶子节点，就继续从他的左右两个子节点往下找，注意到</span></span><br><span class="line">    <span class="comment">//下一步的时候，sum值要减去当前节点的值</span></span><br><span class="line">    dfs(root.left, sum - root.val, subList, result);</span><br><span class="line">    dfs(root.right, sum - root.val, subList, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-437-路径总和-III"><a href="#3-3-437-路径总和-III" class="headerlink" title="3.3 437. 路径总和 III"></a>3.3 <a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h3><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 <strong>路径</strong> 的数目。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//因为未必是要从根节点开始，因此需要对所有节点进行递归判断</span></span><br><span class="line">        <span class="keyword">return</span> pathSumFromRoot(root,sum) + pathSum(root.left,sum) + pathSum(root.right,sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">pathSumFromRoot</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span>&#123; <span class="comment">//递归判断从当前节点是否有满足条件的路径</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum == root.val) ret++;</span><br><span class="line">        ret += pathSumFromRoot(root.left, sum - root.val) + pathSumFromRoot(root.right, sum - root.val);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-572-另一棵树的子树"><a href="#3-4-572-另一棵树的子树" class="headerlink" title="3.4 572. 另一棵树的子树"></a>3.4 <a href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></h3><p>给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//因为未必是要从根节点开始，因此需要对所有节点进行递归判断</span></span><br><span class="line">        <span class="keyword">return</span> isSubtree(s.left,t) || isSubtree(s.right,t) || isSubtreeFromRoot(s,t);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSubtreeFromRoot</span><span class="params">(TreeNode s, TreeNode t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> &amp;&amp; t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> || t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.val != t.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSubtreeFromRoot(s.left,t.left) &amp;&amp; isSubtreeFromRoot(s.right,t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-5-111-二叉树的最小深度"><a href="#3-5-111-二叉树的最小深度" class="headerlink" title="3.5 111. 二叉树的最小深度"></a>3.5 <a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h3><p>给定一个二叉树，找出其最小深度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> minDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> minDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> || right == <span class="number">0</span>) <span class="keyword">return</span> left+right+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.min(left , right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-101-对称二叉树"><a href="#3-6-101-对称二叉树" class="headerlink" title="3.6 101. 对称二叉树"></a>3.6 <a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMirror</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> &amp;&amp; t2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> || t2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">            (t1.val == t2.val)</span><br><span class="line">            &amp;&amp; isMirror(t1.right, t2.left)</span><br><span class="line">            &amp;&amp; isMirror(t1.left, t2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-404-左叶子之和"><a href="#3-7-404-左叶子之和" class="headerlink" title="3.7 404. 左叶子之和"></a>3.7 <a href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h3><p>给定二叉树的根节点 root ，返回所有左叶子之和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是不是左叶子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(isLeaf(root.left))&#123;</span><br><span class="line">            left = root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">(TreeNode root)</span>&#123; <span class="comment">//判断是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-8-687-最长同值路径"><a href="#3-8-687-最长同值路径" class="headerlink" title="3.8 687. 最长同值路径"></a>3.8 <a href="https://leetcode.cn/problems/longest-univalue-path/">687. 最长同值路径</a></h3><p>给定一个二叉树的 root ，返回 <em>最长的路径的长度</em> ，这个路径中的 <em>每个节点具有相同值</em> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestUnivaluePath</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在后序遍历的位置更新 res</span></span><br><span class="line">        maxLen(root, root.val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：计算以 root 为根的这棵二叉树中，从 root 开始值为 parentVal 的最长树枝长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">maxLen</span><span class="params">(TreeNode root, <span class="type">int</span> parentVal)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用函数定义，计算左右子树值为 root.val 的最长树枝长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLen</span> <span class="operator">=</span> maxLen(root.left, root.val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLen</span> <span class="operator">=</span> maxLen(root.right, root.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历位置顺便更新全局变量</span></span><br><span class="line">        <span class="comment">// 同值路径就是左右同值树枝长度之和</span></span><br><span class="line">        res = Math.max(res, leftLen + rightLen);</span><br><span class="line">        <span class="comment">// 如果 root 本身和上级值不同，那么整棵子树都不可能有同值树枝</span></span><br><span class="line">        <span class="keyword">if</span> (root.val != parentVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现函数的定义：</span></span><br><span class="line">        <span class="comment">// 以 root 为根的二叉树从 root 开始值为 parentVal 的最长树枝长度</span></span><br><span class="line">        <span class="comment">// 等于左右子树的最长树枝长度的最大值加上 root 节点本身</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span> + Math.max(leftLen, rightLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-9-337-打家劫舍-III"><a href="#3-9-337-打家劫舍-III" class="headerlink" title="3.9 337. 打家劫舍 III"></a>3.9 <a href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h3><p>给定二叉树的 root 。返回 <strong><em>在不触动警报的情况下\</em></strong> <em>，小偷能够盗取的最高金额</em> 。</p><p>如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//设置备忘录，记录打劫该点的最大收益</span></span><br><span class="line">    Map&lt;TreeNode, Integer&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 移除子问题</span></span><br><span class="line">        <span class="keyword">if</span>(memo.containsKey(root)) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo.get(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">doRob</span> <span class="operator">=</span> root.val</span><br><span class="line">                + (root.left == <span class="literal">null</span> ?</span><br><span class="line">                <span class="number">0</span> : rob(root.left.left) + rob(root.left.right))</span><br><span class="line">                + (root.right == <span class="literal">null</span> ?</span><br><span class="line">                <span class="number">0</span> : rob(root.right.left) + rob(root.right.right));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">notRob</span> <span class="operator">=</span> rob(root.left) + rob(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(doRob, notRob);</span><br><span class="line">        memo.put(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-10-671-二叉树中第二小的节点"><a href="#3-10-671-二叉树中第二小的节点" class="headerlink" title="3.10 671. 二叉树中第二小的节点"></a>3.10 <a href="https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/">671. 二叉树中第二小的节点</a></h3><p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归中止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">//如果为空节点，返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">//如果没有子节点，返回-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> root.left.val;  <span class="comment">//左节点的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> root.right.val;  <span class="comment">//右节点的值</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == left) left = findSecondMinimumValue(root.left);  <span class="comment">//如果左节点和根节点的值相同，第二小的从左子树上寻找</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == right) right = findSecondMinimumValue(root.right);  <span class="comment">//如果和右节点还是相同，则找出右子树的第二小</span></span><br><span class="line">        </span><br><span class="line">       <span class="comment">//返回情况</span></span><br><span class="line">        <span class="keyword">if</span>(left != -<span class="number">1</span> &amp;&amp; right != -<span class="number">1</span>) <span class="keyword">return</span> Math.min(left,right);  <span class="comment">//如果左右都不是-1，返回其中的最小</span></span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>) <span class="keyword">return</span> right;  <span class="comment">//如果左边没有，那就返回右边</span></span><br><span class="line">        <span class="keyword">return</span> left;<span class="comment">//否则返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-11-110-平衡二叉树"><a href="#3-11-110-平衡二叉树" class="headerlink" title="3.11 110. 平衡二叉树"></a>3.11 <a href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxDepth(root);</span><br><span class="line">        <span class="keyword">return</span> isBalanced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录二叉树是否平衡</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isBalanced</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入一个节点，返回以该节点为根的二叉树的最大深度</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMaxDepth</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMaxDepth</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历位置</span></span><br><span class="line">        <span class="comment">// 如果左右最大深度大于 1，就不是平衡二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (Math.abs(rightMaxDepth - leftMaxDepth) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            isBalanced = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftMaxDepth, rightMaxDepth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-12-104-二叉树的最大深度"><a href="#3-12-104-二叉树的最大深度" class="headerlink" title="3.12 104. 二叉树的最大深度"></a>3.12 <a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 前序遍历位置</span></span><br><span class="line">        depth++;</span><br><span class="line">        res = Math.max(res, depth);</span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line">        <span class="comment">// 后序遍历位置</span></span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：输入一个节点，返回以该节点为根的二叉树的最大深度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="comment">// 根据左右子树的最大深度推出原二叉树的最大深度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftMax, rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-13-129-求根节点到叶节点数字之和"><a href="#3-13-129-求根节点到叶节点数字之和" class="headerlink" title="3.13 129. 求根节点到叶节点数字之和"></a>3.13 <a href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历一遍二叉树就能出结果</span></span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二叉树遍历函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历位置，记录节点值</span></span><br><span class="line">        path.append(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 到达叶子节点，累加路径和</span></span><br><span class="line">            res += Integer.parseInt(path.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二叉树递归框架，遍历左右子树</span></span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后续遍历位置，撤销节点值</span></span><br><span class="line">        path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-14-543-二叉树的直径"><a href="#3-14-543-二叉树的直径" class="headerlink" title="3.14 543. 二叉树的直径"></a>3.14 <a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDiameter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxDepth(root);</span><br><span class="line">        <span class="keyword">return</span> maxDiameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="comment">// 后序遍历位置顺便计算最大直径</span></span><br><span class="line">        maxDiameter = Math.max(maxDiameter, leftMax + rightMax);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftMax, rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-15-226-翻转二叉树"><a href="#3-15-226-翻转二叉树" class="headerlink" title="3.15 226. 翻转二叉树"></a>3.15 <a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 「遍历」的思路</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历二叉树，交换每个节点的子节点</span></span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二叉树遍历函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**** 前序位置 ****/</span></span><br><span class="line">        <span class="comment">// 每一个节点需要做的事就是交换它的左右子节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历框架，去遍历左右子树的节点</span></span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 「分解问题」的思路</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：将以 root 为根的这棵二叉树翻转，返回翻转后的二叉树的根节点</span></span><br><span class="line">    TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用函数定义，先翻转左右子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后交换左右子节点</span></span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和定义逻辑自恰：以 root 为根的这棵二叉树已经被翻转，返回 root</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-16-863-二叉树中所有距离为-K-的结点"><a href="#3-16-863-二叉树中所有距离为-K-的结点" class="headerlink" title="3.16 863. 二叉树中所有距离为 K 的结点"></a>3.16 <a href="https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/">863. 二叉树中所有距离为 K 的结点</a></h3><p>给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 k 。</p><p>返回到目标结点 target 距离为 k 的所有结点的值的列表。 答案可以以 任何顺序 返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录父节点：node.val -&gt; parentNode</span></span><br><span class="line">    <span class="comment">// 题目说了树中所有节点值都是唯一的，所以可以用 node.val 代表 TreeNode</span></span><br><span class="line">    HashMap&lt;Integer, TreeNode&gt; parent = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历所有节点，记录每个节点的父节点</span></span><br><span class="line">        traverse(root, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始从 target 节点施放 BFS 算法，找到距离为 k 的节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        q.offer(target);</span><br><span class="line">        visited.add(target.val);</span><br><span class="line">        <span class="comment">// 记录离 target 的距离</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dist</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span> (dist == k) &#123;</span><br><span class="line">                    <span class="comment">// 找到距离起点 target 距离为 k 的节点</span></span><br><span class="line">                    res.add(cur.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 向父节点、左右子节点扩散</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">parentNode</span> <span class="operator">=</span> parent.get(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (parentNode != <span class="literal">null</span> &amp;&amp; !visited.contains(parentNode.val)) &#123;</span><br><span class="line">                    visited.add(parentNode.val);</span><br><span class="line">                    q.offer(parentNode);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span> &amp;&amp; !visited.contains(cur.left.val)) &#123;</span><br><span class="line">                    visited.add(cur.left.val);</span><br><span class="line">                    q.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span> &amp;&amp; !visited.contains(cur.right.val)) &#123;</span><br><span class="line">                    visited.add(cur.right.val);</span><br><span class="line">                    q.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向外扩展一圈</span></span><br><span class="line">            dist++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, TreeNode parentNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parent.put(root.val, parentNode);</span><br><span class="line">        <span class="comment">// 二叉树递归框架</span></span><br><span class="line">        traverse(root.left, root);</span><br><span class="line">        traverse(root.right, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-17-617-合并二叉树"><a href="#3-17-617-合并二叉树" class="headerlink" title="3.17 617. 合并二叉树"></a>3.17 <a href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果一棵树有，另一棵树没有，接上去</span></span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两棵树都有的节点，叠加节点值</span></span><br><span class="line">        root1.val += root2.val;</span><br><span class="line">        <span class="comment">// 递归合并左右子树</span></span><br><span class="line">        root1.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">        root1.right = mergeTrees(root1.right, root2.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-二叉搜索树"><a href="#4-二叉搜索树" class="headerlink" title="4 二叉搜索树"></a>4 二叉搜索树</h2><p>对于 BST 的每一个节点 node，左子树节点的值都比 node 的值要小，右子树节点的值都比 node 的值大。</p><h3 id="4-1-98-验证二叉搜索树"><a href="#4-1-98-验证二叉搜索树" class="headerlink" title="4.1 98. 验证二叉搜索树"></a>4.1 <a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 限定以 root 为根的子树节点必须满足 max.val &gt; root.val &gt; min.val */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST</span></span><br><span class="line">        <span class="keyword">if</span> (min != <span class="literal">null</span> &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (max != <span class="literal">null</span> &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 限定左子树的最大值是 root.val，右子树的最小值是 root.val</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left, min, root)</span><br><span class="line">            &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-230-二叉搜索树中第K小的元素"><a href="#4-2-230-二叉搜索树中第K小的元素" class="headerlink" title="4.2 230. 二叉搜索树中第K小的元素"></a>4.2 <a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h3><p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 利用 BST 的中序遍历特性</span></span><br><span class="line">    traverse(root, k);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 记录当前元素的排名</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rank</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traverse(root.left, k);</span><br><span class="line">    <span class="comment">/* 中序遍历代码位置 */</span></span><br><span class="line">    rank++;</span><br><span class="line">    <span class="keyword">if</span> (k == rank) &#123;</span><br><span class="line">        <span class="comment">// 找到第 k 小的元素</span></span><br><span class="line">        res = root.val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traverse(root.right, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-450-删除二叉搜索树中的节点"><a href="#4-3-450-删除二叉搜索树中的节点" class="headerlink" title="4.3 450. 删除二叉搜索树中的节点"></a>4.3 <a href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h3><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种情况：</span></span><br><span class="line"><span class="comment">//无左子：其右子顶替其位置，删除了该节点；</span></span><br><span class="line"><span class="comment">//无右子：其左子顶替其位置，删除了该节点；</span></span><br><span class="line"><span class="comment">//左右子节点都有：左子树转移到其右子树的最左节点的左子树上</span></span><br><span class="line"><span class="comment">//然后右子树顶替其位置，由此删除了该节点。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">            <span class="comment">// 这两个 if 把情况 1 和 2 都正确处理了</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="comment">// 处理情况 3</span></span><br><span class="line">            <span class="comment">// 获得右子树最小的节点</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">minNode</span> <span class="operator">=</span> getMin(root.right);</span><br><span class="line">            <span class="comment">// 删除右子树最小的节点</span></span><br><span class="line">            root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">            <span class="comment">// 用右子树最小的节点替换 root 节点</span></span><br><span class="line">            minNode.left = root.left;</span><br><span class="line">            minNode.right = root.right;</span><br><span class="line">            root = minNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode <span class="title function_">getMin</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="comment">// BST 最左边的就是最小的</span></span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="literal">null</span>) node = node.left;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-96-不同的二叉搜索树"><a href="#4-4-96-不同的二叉搜索树" class="headerlink" title="4.4 96. 不同的二叉搜索树"></a>4.4 <a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h3><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录</span></span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 备忘录的值初始化为 0</span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> count(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt; hi) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 查备忘录</span></span><br><span class="line">        <span class="keyword">if</span> (memo[lo][hi] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[lo][hi];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo; mid &lt;= hi; mid++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> count(lo, mid - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> count(mid + <span class="number">1</span>, hi);</span><br><span class="line">            res += left * right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将结果存入备忘录</span></span><br><span class="line">        memo[lo][hi] = res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-108-将有序数组转换为二叉搜索树"><a href="#4-5-108-将有序数组转换为二叉搜索树" class="headerlink" title="4.5 108. 将有序数组转换为二叉搜索树"></a>4.5 <a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h3><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将闭区间 [left, right] 中的元素转化成 BST，返回根节点</span></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="comment">// 区间为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造根节点</span></span><br><span class="line">        <span class="comment">// BST 节点左小右大，中间的元素就是根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        <span class="comment">// 递归构建左子树</span></span><br><span class="line">        root.left = build(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归构造右子树</span></span><br><span class="line">        root.right = build(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-449-序列化和反序列化二叉搜索树"><a href="#4-6-449-序列化和反序列化二叉搜索树" class="headerlink" title="4.6 449. 序列化和反序列化二叉搜索树"></a>4.6 <a href="https://leetcode.cn/problems/serialize-and-deserialize-bst/">449. 序列化和反序列化二叉搜索树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="comment">// 分隔符，区分每个节点的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SEP</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        serialize(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历位置进行序列化</span></span><br><span class="line">        sb.append(root.val).append(SEP);</span><br><span class="line">        serialize(root.left, sb);</span><br><span class="line">        serialize(root.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 转化成前序遍历结果</span></span><br><span class="line">        LinkedList&lt;Integer&gt; inorder = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : data.split(SEP)) &#123;</span><br><span class="line">            inorder.offer(Integer.parseInt(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(inorder, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：将 nodes 中值在闭区间 [min, max] 的节点构造成一棵 BST</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">deserialize</span><span class="params">(LinkedList&lt;Integer&gt; nodes, <span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 前序遍历位置进行反序列化</span></span><br><span class="line">        <span class="comment">// 前序遍历结果第一个节点是根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> nodes.getFirst();</span><br><span class="line">        <span class="keyword">if</span> (rootVal &gt; max || rootVal &lt; min) &#123;</span><br><span class="line">            <span class="comment">// 超过闭区间 [min, max]，则返回空指针</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nodes.removeFirst();</span><br><span class="line">        <span class="comment">// 生成 root 节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">// 构建左右子树</span></span><br><span class="line">        <span class="comment">// BST 左子树都比根节点小，右子树都比根节点大</span></span><br><span class="line">        root.left = deserialize(nodes, min, rootVal);</span><br><span class="line">        root.right = deserialize(nodes, rootVal, max);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-669-修剪二叉搜索树"><a href="#4-7-669-修剪二叉搜索树" class="headerlink" title="4.7 669. 修剪二叉搜索树"></a>4.7 <a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h3><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据二叉搜索树的性质</span></span><br><span class="line"><span class="comment">// 一个节点小于 low，则左子树都要减掉</span></span><br><span class="line"><span class="comment">// 同样的处理大于情况</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：删除 BST 中小于 low 和大于 high 的所有节点，返回结果 BST</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; low) &#123;</span><br><span class="line">            <span class="comment">// 直接返回 root.right</span></span><br><span class="line">            <span class="comment">// 等于删除 root 以及 root 的左子树</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; high) &#123;</span><br><span class="line">            <span class="comment">// 直接返回 root.left</span></span><br><span class="line">            <span class="comment">// 等于删除 root 以及 root 的右子树</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 闭区间 [lo, hi] 内，不处理当前节点，递归子树</span></span><br><span class="line">        root.left = trimBST(root.left, low, high);</span><br><span class="line">        root.right = trimBST(root.right, low, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-173-二叉搜索树迭代器"><a href="#4-8-173-二叉搜索树迭代器" class="headerlink" title="4.8 173. 二叉搜索树迭代器"></a>4.8 <a href="https://leetcode.cn/problems/binary-search-tree-iterator/">173. 二叉搜索树迭代器</a></h3><p>实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟递归栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;TreeNode&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一路到底，把根节点和它的所有左节点放到栈中；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushLeftBranch</span><span class="params">(TreeNode p)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            stk.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        pushLeftBranch(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 弹出栈顶节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> stk.pop();</span><br><span class="line">        pushLeftBranch(p.right);</span><br><span class="line">        <span class="keyword">return</span> p.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !stk.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-9-1305-两棵二叉搜索树中的所有元素"><a href="#4-9-1305-两棵二叉搜索树中的所有元素" class="headerlink" title="4.9 1305. 两棵二叉搜索树中的所有元素"></a>4.9 <a href="https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/">1305. 两棵二叉搜索树中的所有元素</a></h3><p>给你 root1 和 root2 这两棵二叉搜索树。请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getAllElements</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">// BST 有序迭代器</span></span><br><span class="line">        <span class="type">BSTIterator</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSTIterator</span>(root1);</span><br><span class="line">        <span class="type">BSTIterator</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSTIterator</span>(root2);</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 类似合并有序链表的算法逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (t1.hasNext() &amp;&amp; t2.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t1.peek() &gt; t2.peek()) &#123;</span><br><span class="line">                res.add(t2.next());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(t1.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有一棵 BST 还剩元素，添加到最后</span></span><br><span class="line">        <span class="keyword">while</span> (t1.hasNext()) &#123;</span><br><span class="line">            res.add(t1.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (t2.hasNext()) &#123;</span><br><span class="line">            res.add(t2.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BST 有序迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 左侧树枝一撸到底</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushLeftBranch</span><span class="params">(TreeNode p)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            stk.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        pushLeftBranch(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stk.peek().val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> stk.pop();</span><br><span class="line">        pushLeftBranch(p.right);</span><br><span class="line">        <span class="keyword">return</span> p.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !stk.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-10-1038-从二叉搜索树到更大和树"><a href="#4-10-1038-从二叉搜索树到更大和树" class="headerlink" title="4.10 1038. 从二叉搜索树到更大和树"></a>4.10 <a href="https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/">1038. 从二叉搜索树到更大和树</a></h3><p>给定一个二叉搜索树 root (BST)，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">bstToGst</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录累加和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root.right);</span><br><span class="line">        <span class="comment">// 维护累加和</span></span><br><span class="line">        sum += root.val;</span><br><span class="line">        <span class="comment">// 将 BST 转化成累加树</span></span><br><span class="line">        root.val = sum;</span><br><span class="line">        traverse(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-11-1373-二叉搜索子树的最大键值和"><a href="#4-11-1373-二叉搜索子树的最大键值和" class="headerlink" title="4.11 1373. 二叉搜索子树的最大键值和"></a>4.11 <a href="https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/">1373. 二叉搜索子树的最大键值和</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、左右子树是否是 BST。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、左子树的最大值和右子树的最小值。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、左右子树的节点值之和。</span><br><span class="line"></span><br><span class="line">想要获得子树的信息，就要用到前文 手把手刷二叉树总结篇 说过的后序位置的妙用了。</span><br><span class="line"></span><br><span class="line">我们定义一个 traverse 函数，traverse(root) 返回一个大小为 <span class="number">4</span> 的 <span class="type">int</span> 数组，我们暂且称它为 res，其中：</span><br><span class="line"></span><br><span class="line">res[<span class="number">0</span>] 记录以 root 为根的二叉树是否是 BST，若为 <span class="number">1</span> 则说明是 BST，若为 <span class="number">0</span> 则说明不是 BST；</span><br><span class="line"></span><br><span class="line">res[<span class="number">1</span>] 记录以 root 为根的二叉树所有节点中的最小值；</span><br><span class="line"></span><br><span class="line">res[<span class="number">2</span>] 记录以 root 为根的二叉树所有节点中的最大值；</span><br><span class="line"></span><br><span class="line">res[<span class="number">3</span>] 记录以 root 为根的二叉树所有节点值之和。</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 全局变量，记录 BST 最大节点之和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主函数 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] traverse(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;</span><br><span class="line">                    <span class="number">1</span>, Integer.MAX_VALUE, Integer.MIN_VALUE, <span class="number">0</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归计算左右子树</span></span><br><span class="line">        <span class="type">int</span>[] left = traverse(root.left);</span><br><span class="line">        <span class="type">int</span>[] right = traverse(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*******后序遍历位置*******/</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">// 这个 if 在判断以 root 为根的二叉树是不是 BST</span></span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; right[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp;</span><br><span class="line">                root.val &gt; left[<span class="number">2</span>] &amp;&amp; root.val &lt; right[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">// 以 root 为根的二叉树是 BST</span></span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 计算以 root 为根的这棵 BST 的最小值</span></span><br><span class="line">            res[<span class="number">1</span>] = Math.min(left[<span class="number">1</span>], root.val);</span><br><span class="line">            <span class="comment">// 计算以 root 为根的这棵 BST 的最大值</span></span><br><span class="line">            res[<span class="number">2</span>] = Math.max(right[<span class="number">2</span>], root.val);</span><br><span class="line">            <span class="comment">// 计算以 root 为根的这棵 BST 所有节点之和</span></span><br><span class="line">            res[<span class="number">3</span>] = left[<span class="number">3</span>] + right[<span class="number">3</span>] + root.val;</span><br><span class="line">            <span class="comment">// 更新全局变量</span></span><br><span class="line">            maxSum = Math.max(maxSum, res[<span class="number">3</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 以 root 为根的二叉树不是 BST</span></span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 其他的值都没必要计算了，因为用不到</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**************************/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-12-面试题-04-06-后继者"><a href="#4-12-面试题-04-06-后继者" class="headerlink" title="4.12 面试题 04.06. 后继者"></a>4.12 <a href="https://leetcode.cn/problems/successor-lcci/">面试题 04.06. 后继者</a></h3><p>找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。</p><ul><li>若有 root.val &lt;= p.val : 根据 BST 特性可知当前节点 root 及其左子树子节点均满足「值小于等于 p.val」，因此不可能是 p 点的后继，我们直接到 root 的右子树搜索 p 的后继（递归处理）；</li><li>若有 root.val &gt; p.val : 当第一次搜索到满足此条件的节点时，在以 root 为根节点的子树中「位于最左下方」的值为 p 的后继，但也有可能 root 没有左子树，因此 p 的后继要么在 root 的左子树中（若有），要么是 root 本身，此时我们可以直接到 root 的左子树搜索，若搜索结果为空返回 root，否则返回搜索结果。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= p.val) <span class="keyword">return</span> inorderSuccessor(root.right, p);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">ans</span> <span class="operator">=</span> inorderSuccessor(root.left, p);</span><br><span class="line">        <span class="keyword">return</span> ans == <span class="literal">null</span> ? root : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-13-109-有序链表转换二叉搜索树"><a href="#4-13-109-有序链表转换二叉搜索树" class="headerlink" title="4.13 109. 有序链表转换二叉搜索树"></a>4.13 <a href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></h3><p>给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用快慢指针寻找中间值（需要找到中间节点的前一个节点）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedListToBST</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//有下面两种边界问题</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(head.val);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">preMid</span> <span class="operator">=</span> helper(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> preMid.next;</span><br><span class="line">        preMid.next = <span class="literal">null</span>;<span class="comment">//从这里断开链表</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(mid.val);</span><br><span class="line">        root.left = sortedListToBST(head);</span><br><span class="line">        root.right = sortedListToBST(mid.next);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//寻找preMid</span></span><br><span class="line">    ListNode <span class="title function_">helper</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next.next;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-14-剑指26-二叉搜索树与双向链表"><a href="#4-14-剑指26-二叉搜索树与双向链表" class="headerlink" title="4.14 剑指26.二叉搜索树与双向链表"></a>4.14 剑指26.二叉搜索树与双向链表</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p><p>思路：</p><p>线索化二叉树。类似于中序遍历构建。</p><p>由于正向构建时，指针会移动到尾部，因此反向构建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Convert</span><span class="params">(TreeNode pRootOfTree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">            pRootOfTree.right = pre;</span><br><span class="line">            pre.left = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pRootOfTree;</span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-15-653-给定一个二叉搜索树和一个目标结果，如果-BST-中存在两个元素且它们的和等于给定的目标结果，则返回-true。"><a href="#4-15-653-给定一个二叉搜索树和一个目标结果，如果-BST-中存在两个元素且它们的和等于给定的目标结果，则返回-true。" class="headerlink" title="4.15 653.给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。"></a>4.15 653.给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findTarget</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; inOrder = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inOrder(root, inOrder);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = inOrder.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> inOrder.get(left) + inOrder.get(right);</span><br><span class="line">            <span class="keyword">if</span>(sum == k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; k) right--;</span><br><span class="line">            <span class="keyword">else</span> left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; inOrder)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left, inOrder);</span><br><span class="line">        inOrder.add(root.val);</span><br><span class="line">        inOrder(root.right, inOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-16-501-给定一个有相同值的二叉搜索树（BST），找出-BST-中的所有众数（出现频率最高的元素）。"><a href="#4-16-501-给定一个有相同值的二叉搜索树（BST），找出-BST-中的所有众数（出现频率最高的元素）。" class="headerlink" title="4.16 501.给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。"></a>4.16 501.给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</h3><p>如果众数超过1个，不需考虑输出顺序。</p><p>你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p><p>思路：</p><p>毫无疑问，同样使用中序遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">//存储最小值</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">preNode</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//存储前一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="keyword">if</span>(preNode != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//后一个节点肯定大于前一个节点</span></span><br><span class="line">            min = Math.min(cur - preNode.val, min);</span><br><span class="line">        preNode = root;</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 常用操作</title>
      <link href="/2021/06/12/Basic/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
      <url>/2021/06/12/Basic/git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="一、git-工作流程"><a href="#一、git-工作流程" class="headerlink" title="一、git 工作流程"></a>一、git 工作流程</h1><p>git 有四个区域:</p><ul><li>3个本地区域<ul><li>工作区(Workspace): 存放项目代码的地方。</li><li>暂存区(Stage): 存放临时的改动, 事实上它只是一个文件, 保存即将提交的文件列表信息。</li><li>资源库(Repository): 安全存放数据的位置, 这里面有提交到所有版本的数据。其中 HEAD 指向最新放入仓库的版本。</li></ul></li><li>1个远程区域<ul><li>远程库(Remote): 托管代码的服务器。</li></ul></li></ul><p><img src="../../img/git/git区域.png" alt="git区域"></p><h1 id="二、git-初始化"><a href="#二、git-初始化" class="headerlink" title="二、git 初始化"></a>二、git 初始化</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> git-study &amp;&amp; <span class="built_in">cd</span> git-study</span><br><span class="line">$ git init</span><br><span class="line">$ <span class="built_in">ls</span> -la</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x   3 kino  staff   96 11 23 17:18 .</span><br><span class="line">drwxr-xr-x  16 kino  staff  512 11 23 17:18 ..</span><br><span class="line">drwxr-xr-x   9 kino  staff  288 11 23 17:18 .git</span><br></pre></td></tr></table></figure><p>创建成功之后, 会出现一个 <code>.git</code> 的隐藏文件夹, 这个就是这个项目的 git 仓库, 以后所有的 git 操作历史提交记录信息全都在此, 只要这个文件夹还存在, 就可以记住我们所有的 git 操作。</p><h1 id="三、git-配置相关常用命令"><a href="#三、git-配置相关常用命令" class="headerlink" title="三、git 配置相关常用命令"></a>三、git 配置相关常用命令</h1><h2 id="1-git-config"><a href="#1-git-config" class="headerlink" title="1 git config"></a>1 git config</h2><p>查看 git 配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">credential.helper=osxkeychain</span><br><span class="line">user.name=kino</span><br><span class="line">user.email=kino@gmail.com</span><br><span class="line">core.autocrlf=input</span><br><span class="line">core.quotepath=<span class="literal">false</span></span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=<span class="literal">true</span></span><br><span class="line">core.bare=<span class="literal">false</span></span><br><span class="line">core.logallrefupdates=<span class="literal">true</span></span><br><span class="line">core.ignorecase=<span class="literal">true</span></span><br><span class="line">core.precomposeunicode=<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>修改 git 配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config -e            <span class="comment"># 针对当前仓库</span></span><br><span class="line">$ git config -e --global   <span class="comment"># 针对系统上的所有仓库</span></span><br></pre></td></tr></table></figure><br>设置提交代码时的用户信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;yourUserName&quot;</span>     <span class="comment"># 去掉 --global 就只对当前仓库生效</span></span><br><span class="line">$ git config --gloabl user.email <span class="string">&quot;yourEmail&quot;</span>       <span class="comment"># 去掉 --global 就只对当前仓库生效</span></span><br></pre></td></tr></table></figure></p><h1 id="四、git-日常操作"><a href="#四、git-日常操作" class="headerlink" title="四、git 日常操作"></a>四、git 日常操作</h1><p><a href="#411-git-add"><code>git add</code>: 将文件添加到暂存区</a></p><p><a href="#412-git-status"><code>git status</code>: 查看在你上次提交之后是否有对文件进行再次修改</a></p><p><a href="#413-git-diff"><code>git diff</code>: 比较文件在暂存区和工作区的差异</a></p><p><a href="#414-git-status"><code>git ls-files</code>: 查看暂存区的文件</a></p><p><a href="#415-git-status"><code>git cat-file -p</code>: 查看暂存区文件中的内容</a></p><p><a href="#416-git-status"><code>git commit</code>: 提交暂存区文件到本地仓库</a></p><p><a href="#417-git-rm"><code>git rm</code>: 删除文件</a></p><h2 id="1-提交代码"><a href="#1-提交代码" class="headerlink" title="1 提交代码"></a>1 提交代码</h2><h3 id="1-1-git-add"><a href="#1-1-git-add" class="headerlink" title="1.1 git add"></a>1.1 git add</h3><p>语法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 该命令可以将文件添加到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加指定目录到暂存区</span></span><br><span class="line">$ git add [<span class="built_in">dir</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 添加当前目录下所有文件进入暂存区</span></span><br><span class="line">$ git add .</span><br></pre></td></tr></table></figure><br>示例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> 1.txt 2.txt 3.txt 4.txt</span><br><span class="line">$ ll </span><br><span class="line">total 8</span><br><span class="line">-rw-r--r--  1 kino  staff   0  7  5 18:30 1.txt</span><br><span class="line">-rw-r--r--  1 kino  staff   0  7  5 18:30 2.txt</span><br><span class="line">-rw-r--r--  1 kino  staff   0  7  5 18:31 3.txt</span><br><span class="line">-rw-r--r--  1 kino  staff   0  7  5 18:31 4.txt</span><br><span class="line">-rw-r--r--  1 kino  staff  13  7  5 18:30 README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 1.txt 和 2.txt 进入暂存区</span></span><br><span class="line">$ git add 1.txt 2.txt</span><br></pre></td></tr></table></figure></p><h3 id="1-2-git-status"><a href="#1-2-git-status" class="headerlink" title="1.2 git status"></a>1.2 git status</h3><p>查看在你上次提交之后是否有对文件进行再次修改。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$ git status </span><br><span class="line">On branch main</span><br><span class="line">Your branch is up to <span class="built_in">date</span> with <span class="string">&#x27;origin/main&#x27;</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">new file:   1.txt</span><br><span class="line">new file:   2.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">3.txt</span><br><span class="line">4.txt</span><br><span class="line"></span><br><span class="line">$ git status -s </span><br><span class="line">A  1.txt</span><br><span class="line">A  2.txt</span><br><span class="line">?? 3.txt</span><br><span class="line">?? 4.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;提交&quot;</span></span><br><span class="line">[main 26c1139] 提交</span><br><span class="line"> 2 files changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 1.txt</span><br><span class="line"> create mode 100644 2.txt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> 11111 &gt;&gt; 1.txt</span><br><span class="line">$ <span class="built_in">echo</span> 33333 &gt;&gt; 3.txt</span><br><span class="line">$ git add 3.txt</span><br><span class="line"></span><br><span class="line">$ git status -s </span><br><span class="line"> M 1.txt</span><br><span class="line">AM 3.txt</span><br><span class="line">?? 4.txt</span><br></pre></td></tr></table></figure></p><ul><li>A 表示新提交</li><li>M 表示提交过，并且本地又修改了</li><li>AM 表示有改动</li></ul><h3 id="1-3-git-diff"><a href="#1-3-git-diff" class="headerlink" title="1.3 git diff"></a>1.3 git diff</h3><p>比较文件的不同, 即比较文件在暂存区和工作区的差异</p><p>git diff 显示已经写入暂存区和已经被修改但尚未写入暂存区文件的区别</p><p>应用场景:</p><ol><li>尚未缓存的改动: git diff</li><li>查看已经缓存的改动: git diff —cached</li><li>查看缓存成功和未缓存的所有改动: git diff HEAD</li><li>显示摘要而非整个diff: git diff —stat</li></ol><p>删除原来的项目重新clone<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> -rf git-study</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> git-study</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> 1111 &gt;&gt; README.md</span><br><span class="line">$ git add . &amp;&amp; git commit -m <span class="string">&quot;readme&quot;</span> </span><br><span class="line">$ <span class="built_in">echo</span> 2222 &gt;&gt; README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看暂未添加至缓存区的改动</span></span><br><span class="line">$ git diff</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 5f2f16b..4f142ee 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> 1111</span><br><span class="line">+2222</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示简略信息</span></span><br><span class="line">$ git diff --<span class="built_in">stat</span></span><br><span class="line"> README.md | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已经添加至缓存区的改动</span></span><br><span class="line">$ git add README.md</span><br><span class="line">$ git diff --cached</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 5f2f16b..4f142ee 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> 1111</span><br><span class="line">+2222</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看不在缓存区 &amp; 在缓存区的改动</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 5f2f16b..4f142ee 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> 1111</span><br><span class="line">+2222</span><br></pre></td></tr></table></figure></p><h3 id="1-4-git-ls-files"><a href="#1-4-git-ls-files" class="headerlink" title="1.4 git ls-files"></a>1.4 git ls-files</h3><p>查看暂存区的文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-files</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure><br>可选参数:</p><ul><li>-c: 默认</li><li>-d: 显示删除的文件</li><li>-m: 显示被修改过的文件</li><li>-o: 显示没有被 git 跟踪过的文件</li><li>-s: 显示 mode 以及对应的 Blog对象, 进而可以获取暂存区中对应文件的内容</li></ul><h3 id="1-5-git-cat-file-p"><a href="#1-5-git-cat-file-p" class="headerlink" title="1.5 git cat-file -p"></a>1.5 git cat-file -p</h3><p>查看暂存区文件中的内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-files -s</span><br><span class="line">100644 5cf7833392d65968a05971b9923f36a1ec46d7f7 0       README.md</span><br><span class="line"></span><br><span class="line">$ git cat-file -p  5cf7</span><br><span class="line">1111</span><br><span class="line">2222</span><br></pre></td></tr></table></figure></p><h3 id="1-6-git-commit"><a href="#1-6-git-commit" class="headerlink" title="1.6 git commit"></a>1.6 git commit</h3><p>提交暂存区文件到本地仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m [message]</span><br></pre></td></tr></table></figure><br>提交暂存区的指定文件到本地仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br></pre></td></tr></table></figure></p><h3 id="1-7-git-rebase"><a href="#1-7-git-rebase" class="headerlink" title="1.7 git rebase"></a>1.7 git rebase</h3><ul><li>变基提交,用来重写提交历史</li><li>基于 master 的 a 新建的分支,后面 master 又有了 c 提交,rebase 后分支的更新就是基于 c 了<h3 id="1-8-git-stash"><a href="#1-8-git-stash" class="headerlink" title="1.8 git stash"></a>1.8 git stash</h3></li><li>保存当前工作进度，会把暂存区和工作区的改动保存到一个未完结变更的堆栈中；执行完这个命令后，在运行 <code>git status</code> 命令，就会发现当前是一个干净的工作区，没有任何改动<h3 id="1-9-git-rm"><a href="#1-9-git-rm" class="headerlink" title="1.9 git rm"></a>1.9 git rm</h3><code>git rm</code> 用于删除文件</li></ul><p>1、将文件从暂存区和工作区中删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">rm</span> 1.txt 2.txt</span><br></pre></td></tr></table></figure><br>2、将文件从暂存区和工作区中强制删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以加上 -f, 表示强制删除之前修改过而且 add 到暂存区的文件</span></span><br><span class="line">$ git <span class="built_in">rm</span> -f 1.txt 2.txt</span><br></pre></td></tr></table></figure><br>3、将文件从暂存区删除，在工作区保留<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached 1.txt 2.txt</span><br></pre></td></tr></table></figure></p><h2 id="2-分支操作"><a href="#2-分支操作" class="headerlink" title="2 分支操作"></a>2 分支操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看分支</span></span><br><span class="line">$ git branch -a </span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于当前分支创建一个新分支</span></span><br><span class="line">$ git checkout -b feature/hotfix-001</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于指定分支创建一个新的分支</span></span><br><span class="line">$ git checkout -b feature/hotfix-002 master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换分支</span></span><br><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d feature/hotfix-001</span><br></pre></td></tr></table></figure><h2 id="3-更新操作"><a href="#3-更新操作" class="headerlink" title="3 更新操作"></a>3 更新操作</h2><p>@TODO</p><h2 id="4-合并冲突"><a href="#4-合并冲突" class="headerlink" title="4 合并冲突"></a>4 合并冲突</h2><p>简单制造一个冲突<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 再迁出一个分支(模拟其他人的修改操作)</span></span><br><span class="line">$ git checkout -b feature/hotfix-001 feature/hotfix-002</span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line">$ <span class="built_in">echo</span> 3333 &gt;&gt; README.md</span><br><span class="line">$ git add README.md</span><br><span class="line">$ git commit -m <span class="string">&quot;hotfix-001: add newline&quot;</span></span><br><span class="line"><span class="comment"># 合并到master</span></span><br><span class="line">$ git checkout master </span><br><span class="line">$ git merge feature/hotfix-001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git checkout feature/hotfix-002</span><br><span class="line">$ vim README.md</span><br><span class="line"><span class="comment"># 在第三行添加</span></span><br><span class="line">3344</span><br><span class="line">$ git add README.md</span><br><span class="line">$ git commit -m <span class="string">&quot;hotfix-002: add newline&quot;</span></span><br><span class="line"></span><br><span class="line">$ git checkout master</span><br><span class="line"><span class="comment"># 再合并代码就会出现冲突提示</span></span><br><span class="line"><span class="comment"># 这个时候不可以进行任何分支切换和commit操作，需要按照提示将冲突解决。</span></span><br><span class="line">$ git merge feature/hotfix-002</span><br><span class="line">Auto-merging README.md</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> README.md</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><br>查看冲突文件内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vim README.md</span><br><span class="line">1111</span><br><span class="line">2222</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string">3333</span></span><br><span class="line"><span class="string">=======</span></span><br><span class="line"><span class="string">3344</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/hotfix-002</span></span><br></pre></td></tr></table></figure></p><ul><li>从 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> 开始, 到 <code>=======</code> 都是主分支已经存在的内容。</li><li>从 <code>=======</code> 开始, 到 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/hotfix-002</code> 都是 merge 过来的分支的内容。</li></ul><p>解决冲突，视情况保留(删除)记录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ vim README.md</span><br><span class="line">1111</span><br><span class="line">2222</span><br><span class="line">3333</span><br><span class="line">3344</span><br><span class="line"></span><br><span class="line"><span class="comment"># 冲突解决完成之后, 再次提交代码</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看变更记录</span></span><br><span class="line">commit 8715c66d8ca756077040ce6d783c6caf470d115e (HEAD -&gt; master)</span><br><span class="line">Merge: b89c0c5 ba903ae</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Wed Nov 23 18:29:17 2022 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">&#x27;feature/hotfix-002&#x27;</span></span><br><span class="line"></span><br><span class="line">commit ba903aebecb447d6f485108f0321b15f6c009886 (feature/hotfix-002)</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Wed Nov 23 18:19:54 2022 +0800</span><br><span class="line"></span><br><span class="line">    hotfix-002: add newline</span><br><span class="line"></span><br><span class="line">commit b89c0c592ba11894acb2cd93564c5e43934065fb (feature/hotfix-001)</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Wed Nov 23 18:16:23 2022 +0800</span><br><span class="line"></span><br><span class="line">    hotfix-001: add newline</span><br></pre></td></tr></table></figure></p><h2 id="5-暂存代码保护现场"><a href="#5-暂存代码保护现场" class="headerlink" title="5 暂存代码保护现场"></a>5 暂存代码保护现场</h2><p>项目经理提了一个新的需求, 开发就需要从 master 分支迁出一个新的分支进行功能开发(例如迁出新分支为dev), 如果在开发过程工, 生产上有紧急 bug 需要修复, 就可以用到 <code>git stash</code> 了。</p><p><code>git stash</code> 可以将现在的 <strong>工作区</strong>全部的修改、新增、删除等操作，全部保存起来。</p><p><code>git stash</code> 的常用命令:</p><ol><li><code>git stash save &#39;save message&#39;</code>: 执行存储时, 添加备注, 方便查找, 当然只执行 <code>git stash</code> 也是可以的, 但查找时不方便。</li><li><code>git stash list</code>: 查看 stash 了哪些存储。</li><li><code>git stash show</code>: 显示做了哪些改动, 默认 show 第一个存储, 如果要显示其他的存储, 后面加 <code>stash@&#123;$num&#125;</code>, 比如第二个: <code>git stash show stash@&#123;1&#125;</code></li><li><code>git stast show -p</code>: 显示第一个存储的改动, 如果想显示其他存储, 则: <code>git stash show stash@&#123;$num&#125; -p</code>, 比如第二个: <code>git stash show stash@&#123;1&#125; -p</code></li><li><code>git stash apply</code>: 应用某个存储, 但不会把存储从存储列表中删除, 默认使用第一个存储, 即 <code>stash@&#123;0&#125;</code>, 如果要是用其他, 则: <code>git stash apply stash@&#123;$num&#125;</code>, 比如第二个: <code>git stash apply stash@&#123;1&#125;</code></li><li><code>git stash pop</code>: 恢复之前缓存的工作目录, 将缓存列表中对应的 stash 删除, 并将对应修改应用到当前的工作目录下, 默认为第一个 stash, 即 <code>stash@&#123;0&#125;</code>, 如果要应用并删除其他 stash, 则: <code>git stash pop stash@&#123;$num&#125;</code>, 比如应用并删除第二个: <code>git stash pop stash@&#123;1&#125;</code></li><li><code>git stash drop stash@&#123;num&#125;</code>: 丢弃 <code>stash@&#123;num&#125;</code> 存储, 从列表中删除这个存储</li><li><code>git stash clear</code>: 删除所有缓存的 stash</li></ol><p>开始模拟现场<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git 初始化</span></span><br><span class="line">$ <span class="built_in">cd</span> .. &amp;&amp; <span class="built_in">rm</span> -rf git-study &amp;&amp; <span class="built_in">mkdir</span> git-study &amp;&amp; <span class="built_in">cd</span> git-study &amp;&amp; git init</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;file1 init&#x27;</span> &gt; file1.txt</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;file2 init&#x27;</span> &gt; file2.txt</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&#x27;change: add file1 &amp; file2&#x27;</span></span><br><span class="line">[master (root-commit) 525c358] change: add file1 &amp; file2</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 file1.txt</span><br><span class="line"> create mode 100644 file2.txt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 然后从 master 分支创建两个新的 feature 分支</span></span><br><span class="line">$ git branch feature1</span><br><span class="line">$ git branch feature2</span><br><span class="line"></span><br><span class="line"><span class="comment"># checkout feature1, 修改 file1.txt, 并在 feature1 上创建两次提交</span></span><br><span class="line">$ git checkout feature1</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;add file1.txt code 1&#x27;</span> &gt;&gt; file1.txt</span><br><span class="line">$ git add file1.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;change file1 no.1&#x27;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;add file2.txt code 2&#x27;</span> &gt;&gt; file1.txt</span><br><span class="line">$ git add file1.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;change file1 no.2&#x27;</span></span><br><span class="line"><span class="comment"># 目前 feature1 上的改动内容</span></span><br><span class="line">$ <span class="built_in">cat</span> file1.txt</span><br><span class="line">file1 init</span><br><span class="line">add file1.txt code 1</span><br><span class="line">add file2.txt code 2</span><br><span class="line">$ <span class="built_in">cat</span> file2.txt</span><br><span class="line">file2 init</span><br><span class="line"></span><br><span class="line"><span class="comment"># checkout feature2, 修改 file2.tx</span></span><br><span class="line">$ git checkout feature2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;add file2.txt code 1&#x27;</span> &gt;&gt; file2.txt</span><br><span class="line">$ git add file2.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;change file2 no.1&#x27;</span></span><br><span class="line"><span class="comment"># 目前 feature2 上的改动内容</span></span><br><span class="line">$ <span class="built_in">cat</span> file1.txt</span><br><span class="line">file1 init</span><br><span class="line">$ <span class="built_in">cat</span> file2.txt</span><br><span class="line">file2 init</span><br><span class="line">add file2.txt code 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设不小心将 feature2 合并到了 feature1, 并在 feature1 继续进行了代码开发并提交</span></span><br><span class="line">$ git checkout feature1</span><br><span class="line">$ git merge feature2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;add file1.txt no.3 &amp; code end&#x27;</span> &gt;&gt; file1.txt</span><br><span class="line">$ git add file1.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;change file1 no.3&#x27;</span></span><br><span class="line"><span class="comment"># 此时 feature1 上所有文件的内容</span></span><br><span class="line">$ <span class="built_in">cat</span> file1.txt</span><br><span class="line">file1 init</span><br><span class="line">add file1.txt code 1</span><br><span class="line">add file2.txt code 2</span><br><span class="line">add file1.txt no.3 &amp; code end</span><br><span class="line">$ <span class="built_in">cat</span> file2.txt</span><br><span class="line">file2 init</span><br><span class="line">add file2.txt code 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时我们发现了不小心 merge 进来的 feature2, 而且在这基础上我们还有新的 commit, 如果我们想将 merge 剔除, 可以做如下操作</span></span><br><span class="line"><span class="comment"># 先查看需要还原 commit 的版本号</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">8a1454f (HEAD -&gt; feature1) change file1 no.3</span><br><span class="line">422a454 Merge branch <span class="string">&#x27;feature2&#x27;</span> into feature1</span><br><span class="line">4978e2c (feature2) change file2 no.1</span><br><span class="line">ee4a50e change file1 no.2</span><br><span class="line">dc397c1 change file1 no.1</span><br><span class="line">525c358 (master) change: add file1 &amp; file2</span><br><span class="line"><span class="comment"># 其中, 422a454 就是误合并的 commitid</span></span><br><span class="line"><span class="comment"># 目前我们需要做的就是撤销已提交的 commit, 回滚到 feature2 误合并到 feature1 分支的 commit 版本。</span></span><br><span class="line">$ git reset --mixed 422a454</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">Mfile1.txt</span><br><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">422a454 (HEAD -&gt; feature1) Merge branch <span class="string">&#x27;feature2&#x27;</span> into feature1</span><br><span class="line">4978e2c (feature2) change file2 no.1</span><br><span class="line">ee4a50e change file1 no.2</span><br><span class="line">dc397c1 change file1 no.1</span><br><span class="line">525c358 (master) change: add file1 &amp; file2</span><br><span class="line">$ git diff file1.txt</span><br><span class="line">diff --git a/file1.txt b/file1.txt</span><br><span class="line">index 4a1ca46..6954af7 100644</span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ b/file1.txt</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> file1 init</span><br><span class="line"> add file1.txt code 1</span><br><span class="line"> add file2.txt code 2</span><br><span class="line">+add file1.txt no.3 &amp; code end   <span class="comment">## 可以看见, feature1 最后一次提交已经是未暂存状态了</span></span><br><span class="line"><span class="comment"># 此时, 我们就可以使用 git stash, 将撤销的代码存储起来, </span></span><br><span class="line">$ git stash save <span class="string">&#x27;save file1.txt reset code&#x27;</span></span><br><span class="line">Saved working directory and index state On feature1: save file1.txt reset code</span><br><span class="line"><span class="comment"># 查看 stash 列表</span></span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: On feature1: save file1.txt reset code</span><br><span class="line"><span class="comment"># 查看 status, 可以看见在工作空间已经没有了</span></span><br><span class="line">$ git status </span><br><span class="line">On branch feature1</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后再撤销 merge 相关的信息</span></span><br><span class="line">$ git reset --hard HEAD~</span><br><span class="line"><span class="comment"># 再查看此时本地的文件内容</span></span><br><span class="line">$ <span class="built_in">cat</span> file1.txt</span><br><span class="line">file1 init</span><br><span class="line">add file1.txt code 1</span><br><span class="line">add file2.txt code 2</span><br><span class="line">$ <span class="built_in">cat</span> file2.txt</span><br><span class="line">file2 init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来恢复 feature1 上被撤销的代码</span></span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: On feature1: save file1.txt reset code</span><br><span class="line">$ git stash apply stash&#123;0&#125;</span><br><span class="line">On branch feature1</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">modified:   file1.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line"><span class="comment"># 此时代码就恢复回来了</span></span><br><span class="line">$ <span class="built_in">cat</span> file1.txt</span><br><span class="line">file1 init</span><br><span class="line">add file1.txt code 1</span><br><span class="line">add file2.txt code 2</span><br><span class="line">add file1.txt no.3 &amp; code end</span><br></pre></td></tr></table></figure><br>说明: git stash会贮存及不会贮存的文件范围</p><ul><li>会贮存: <ul><li>添加到暂存区的修改（staged changes）</li><li>git跟踪的但并未添加到暂存区的修改（unstaged changes）</li></ul></li><li>不会贮存:<ul><li>在工作目录中新的文件（untracked files）</li><li>被忽略的文件（ignored files）</li></ul></li></ul><p>当然, 如果仅仅需要 删除某个 commit, 其实有更好的方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设, 当前已经到了 git commit -m &#x27;change file1 no.3&#x27;, 当前 log </span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 3e6be928866581f1779bb0f0e84d29d068d698e8 (HEAD -&gt; feature1)</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 24 23:30:31 2022 +0800</span><br><span class="line"></span><br><span class="line">    change file1 no.3</span><br><span class="line"></span><br><span class="line">commit ef733ffec4e80ed851f353f2d8b2dba46b831bb6</span><br><span class="line">Merge: 5e96765 7d9cebd</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 24 23:30:29 2022 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">&#x27;feature2&#x27;</span> into feature1</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以直接 git revert 指定的 commit, 例如 上面 merge 的 commit id 是 ef733ffec4e80ed851f353f2d8b2dba46b831bb6</span></span><br><span class="line">$ git revert -i ef733ffec4e80ed851f353f2d8b2dba46b831bb6 -m 1</span><br><span class="line"><span class="comment"># 注意, 已经要加上 -m 1, 否则会报如下错:</span></span><br><span class="line"><span class="comment">#   error: commit ef733ffec4e80ed851f353f2d8b2dba46b831bb6 is a merge but no -m option was given.</span></span><br><span class="line"><span class="comment">#   fatal: revert failed</span></span><br><span class="line"><span class="comment"># 在这里解释下 -m 1 的含义:</span></span><br><span class="line"><span class="comment">#   从上面的 git log 可以看见 &quot;Merge: 5e96765 7d9cebd&quot; 的信息, 这代表着, 本次 merge 是使用当前分支的 5e96765(commit) 和 feature2 分支的 7d9cebd(commit) 合并而来, 我们可以做一下验证:</span></span><br><span class="line"><span class="comment">#     # 首先 cat-file 5e96765</span></span><br><span class="line"><span class="comment">#     $ git cat-file -p 5e96765</span></span><br><span class="line"><span class="comment">#     tree fa6ff2fd55be9834b45f0be9d347b1670594ed17</span></span><br><span class="line"><span class="comment">#     parent d27c172b6e876938eb39094801ca5e436a30b3c3</span></span><br><span class="line"><span class="comment">#     author kino &lt;kino@gmail.com&gt; 1669303829 +0800</span></span><br><span class="line"><span class="comment">#     committer kino &lt;kino@gmail.com&gt; 1669303829 +0800</span></span><br><span class="line"><span class="comment">#     change file1 no.2</span></span><br><span class="line"><span class="comment">#    # 然后取 tree 的 id 继续查看, 可以看到, 这个 tree 记录该 commit 的两个文件</span></span><br><span class="line"><span class="comment">#    $ git cat-file -p fa6ff2fd55be9834b45f0be9d347b1670594ed17</span></span><br><span class="line"><span class="comment">#    100644 blob 4a1ca461271ec4e0041822373470703dca5d0626file1.txt</span></span><br><span class="line"><span class="comment">#    100644 blob 18ffc0add953f06f00be32437b9f79e09af27d32file2.txt</span></span><br><span class="line"><span class="comment">#    # 然后取 file2.txt 的 id 继续查看, 可以看到, 这个 tree 记录 该 file2.txt 的内容为: file2 init</span></span><br><span class="line"><span class="comment">#    $ git cat-file -p 18ffc0add953f06f00be32437b9f79e09af27d32</span></span><br><span class="line"><span class="comment">#    file2 init</span></span><br><span class="line"><span class="comment">#    # 然后我们再 cat-file 7d9cebd</span></span><br><span class="line"><span class="comment">#    tree 1b5c42acd113046ec223223affe7b3ef579a293b</span></span><br><span class="line"><span class="comment">#    parent 9acd7882175075c0f3e2f44dfa0d91f3d0a673d1</span></span><br><span class="line"><span class="comment">#    author kino &lt;kino@gmail.com&gt; 1669303829 +0800</span></span><br><span class="line"><span class="comment">#    committer kino &lt;kino@gmail.com&gt; 1669303829 +0800</span></span><br><span class="line"><span class="comment">#    change file2 no.1</span></span><br><span class="line"><span class="comment">#    # 然后取 tree 的 id 继续查看, 可以看到, 这个 tree 记录该 commit 的两个文件</span></span><br><span class="line"><span class="comment">#    git cat-file -p 1b5c42acd113046ec223223affe7b3ef579a293b</span></span><br><span class="line"><span class="comment">#    100644 blob 0c481f7fe4602d041634c353e31846bf1b638c37file1.txt</span></span><br><span class="line"><span class="comment">#    100644 blob c6b0b29e598db81ef8e54ec955df78cfac4ae316file2.txt</span></span><br><span class="line"><span class="comment">#    # 然后取 file2.txt 的 id 继续查看, 可以看到, 这个 tree 记录 该 file2.txt 的内容</span></span><br><span class="line"><span class="comment">#    git cat-file -p c6b0b29e598db81ef8e54ec955df78cfac4ae316</span></span><br><span class="line"><span class="comment">#    file2 init</span></span><br><span class="line"><span class="comment">#    add file2.txt code 1</span></span><br><span class="line"><span class="comment"># 由此我们可以得出结论, 5e96765 就是 feature1 在 Merge 之前的状态, 而 7d9cebd 就是 feature2 在 Merge 之前的状态。</span></span><br><span class="line"><span class="comment"># 因为 一个 Merge 记录了两个分支的 commit 信息, 所以, 在 revert merge 的时候,需要明确的支出, 要revert 到哪个commit, 因为我们是想取消 feature2 里面的内容, 所以就是 -m 1 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ok, 回到正题, git revert 之后, 我们再查看 log</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">b4dde93 (HEAD -&gt; feature1) Revert <span class="string">&quot;Merge branch &#x27;feature2&#x27; into feature1&quot;</span></span><br><span class="line">3e6be92 change file1 no.3</span><br><span class="line">ef733ff Merge branch <span class="string">&#x27;feature2&#x27;</span> into feature1</span><br><span class="line">5e96765 change file1 no.2</span><br><span class="line">7d9cebd (feature2) change file2 no.1</span><br><span class="line">d27c172 change file1 no.1</span><br><span class="line">9acd788 (master) change: add file1 &amp; file2</span><br><span class="line"><span class="comment"># 然后查看 file2.txt</span></span><br><span class="line">$ <span class="built_in">cat</span> file2.txt</span><br><span class="line">file2 init</span><br></pre></td></tr></table></figure></p><h1 id="五、git-高级操作"><a href="#五、git-高级操作" class="headerlink" title="五、git 高级操作"></a>五、git 高级操作</h1><h2 id="1-git-撤销操作"><a href="#1-git-撤销操作" class="headerlink" title="1 git 撤销操作"></a>1 git 撤销操作</h2><p><strong>disk</strong></p><div class="table-container"><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>查看修改</td><td><code>git diff</code></td></tr><tr><td>查看状态</td><td><code>git status</code> -&gt; <code>Changes not staged for comit</code></td></tr><tr><td>撤销文件修改</td><td><code>git checkout &lt;change_file&gt;  or git restore &lt;change_file&gt;</code></td></tr><tr><td>提交暂存区</td><td>git add <change_file></td></tr></tbody></table></div><p><strong>暂存区</strong></p><div class="table-container"><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>查看状态</td><td><code>git status</code> -&gt; <code>Changes to be committed(绿色)</code></td></tr><tr><td>从暂存区移除，但保留硬盘上的修改</td><td><code>git reset &lt;change_file&gt;</code> or <code>git restore --staged &lt;change_file&gt;</code></td></tr><tr><td>从暂存区移除，不保留硬盘上的修改</td><td><code>git checkout HEAD &lt;change_file&gt;</code></td></tr><tr><td>提交本地git</td><td><code>git commit</code></td></tr></tbody></table></div><p><strong>local</strong></p><div class="table-container"><table><thead><tr><th>command</th><th>description</th></tr></thead><tbody><tr><td>撤销commit(保留磁盘上的修改和暂存区记录)</td><td><code>git reset --soft HEAD~1</code></td></tr><tr><td>撤销commit(清除暂存区记录, 只保留磁盘上的修改)</td><td><code>git reset HEAD~1</code> == <code>git reset --mixed HEAS~1</code></td></tr><tr><td>撤销commit(清除暂存区记录, 清除磁盘上的修改)</td><td><code>git reset --hard HEAD~1</code></td></tr><tr><td>生成新的<code>commitId</code>,将上一个<code>commit+</code>的内容变成<code>commit-</code></td><td><code>git revert HEAD</code></td></tr><tr><td>提交远端git</td><td><code>git push</code></td></tr></tbody></table></div><p><code>git reset</code> &amp; <code>git revert</code>:</p><ol><li><code>git reset</code>: 只能回到之前某一个commit的状态。</li><li><code>git revert</code>:撤销中间任意一个commit。<code>git revert 70a0;(git revert HEAD~1)</code></li></ol><p>如果操作项目的分支是公共分支，只能通过 <code>git revert</code> 生成一个新的 commitId，从这个结果上撤销我们之前的修改。</p><ol><li><code>git revert HEAD</code></li><li><code>git push</code></li></ol><p>如果操作项目的分支是个人分支，可以通过<code>git reset</code>撤销我们之前的修改</p><ol><li><code>git reset --hard HEAD~1</code></li><li><code>git push -f</code></li></ol><h2 id="2-git-找回丢失文件-commit了"><a href="#2-git-找回丢失文件-commit了" class="headerlink" title="2 git 找回丢失文件(commit了)"></a>2 git 找回丢失文件(commit了)</h2><p>恢复因为执行 <code>git reset --hard COMMITID</code> 丢失的文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新创建一个项目</span></span><br><span class="line">$ <span class="built_in">cd</span> .. &amp;&amp; <span class="built_in">rm</span> -rf git-study &amp;&amp; <span class="built_in">mkdir</span> git-study &amp;&amp; <span class="built_in">cd</span> git-study &amp;&amp; git init</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;master message 1&#x27;</span> &gt;&gt; master_1.txt</span><br><span class="line">$ git add master_1.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;first commit&#x27;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;master message 2&#x27;</span> &gt;&gt; master_2.txt</span><br><span class="line">$ git add master_2.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;No.2 commit&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这两次commit的基础上, reset 到第一次(first commit)上</span></span><br><span class="line">$ git <span class="built_in">log</span>   <span class="comment"># 获取第一次commitid</span></span><br><span class="line">$ git reset --hard 4a9bcb880db85a1ca77807dea9b3adce29dc4fda</span><br><span class="line"><span class="comment"># 再次查看 log 信息, 此时可以看见只有一次commit了, 第二次 commit(No.2 commit) 已经丢失</span></span><br><span class="line">$ git <span class="built_in">log</span> -n 2</span><br></pre></td></tr></table></figure><br>git 提供了 <code>git reflog</code> 用来记录你的每一次改变目录树的命令，使用好他就可以很方便的恢复你的提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4a9bcb8 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 4a9bcb880db85a1ca77807dea9b3adce29dc4fda</span><br><span class="line">80258ce HEAD@&#123;1&#125;: commit: No.2 commit</span><br><span class="line">4a9bcb8 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): first commit</span><br></pre></td></tr></table></figure><br>可以看到最上面一条记录是将 HEAD 重新指向第一次的commit了, 同时也有显示第二次 commit 的 commitid, 有了这个 commitid, 就可以回滚了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 80258ce</span><br><span class="line">HEAD is now at 80258ce No.2 commit</span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 80258ce0146f373d15a1991d61af4061687782bc (HEAD -&gt; master)</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 24 02:26:10 2022 +0800</span><br><span class="line"></span><br><span class="line">    No.2 commit</span><br><span class="line"></span><br><span class="line">commit 4a9bcb880db85a1ca77807dea9b3adce29dc4fda</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 24 02:25:06 2022 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure><br>可以看到, commit 已被找回.</p><p>但是通常情况下, 可能会出现在 <code>git reset</code> 之后, 还有新的 commit, 如果直接 <code>reset</code> 恢复的 commit, 肯定会造成新的 commit 又丢失, 所以如果我们只是想恢复这个一个 commit, 可以使用 <code>git cherry-pick commitid</code> 来单独将这个 commitid 恢复到当前分支或者用 <code>git merge</code> 来做合并<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git cherry-pick 04b0396</span><br><span class="line">[master fbf401a] No.2 commit</span><br><span class="line"> Date: Thu Nov 24 02:38:14 2022 +0800</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 master_2.txt</span><br><span class="line"> </span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit fbf401a96bd9831c18ed02e9ee852cef8111ccb1 (HEAD -&gt; master)</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 24 02:38:14 2022 +0800</span><br><span class="line"></span><br><span class="line">    No.2 commit</span><br><span class="line"></span><br><span class="line">commit 1b5bfdb36ad01fb86d94b76654347f5de5475f37</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 24 02:38:05 2022 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure></p><h2 id="3-git-找回丢失文件-未commit-但添加暂存区了"><a href="#3-git-找回丢失文件-未commit-但添加暂存区了" class="headerlink" title="3 git 找回丢失文件(未commit,但添加暂存区了)"></a>3 git 找回丢失文件(未commit,但添加暂存区了)</h2><p>如果只 <code>git add</code> 了没有 <code>git commit</code>(如果连 <code>git add</code>都没有, 那只能找磁盘数据恢复的方式了), 这就不是仅仅一个 <code>git reflog</code> 就能找回的了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> .. &amp;&amp; <span class="built_in">rm</span> -rf git-study &amp;&amp; <span class="built_in">mkdir</span> git-study &amp;&amp; <span class="built_in">cd</span> git-study &amp;&amp; git init</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;master message 1&#x27;</span> &gt;&gt; master_1.txt</span><br><span class="line">$ git add master_1.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;first commit&#x27;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;master message 2&#x27;</span> &gt;&gt; master_2.txt</span><br><span class="line">$ git add master_2.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;No.2 commit&#x27;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;master message 3&#x27;</span> &gt;&gt; master_3.txt</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 log</span></span><br><span class="line">$ git <span class="built_in">log</span> -n 2</span><br><span class="line"><span class="comment"># 取最新的一次 commit id</span></span><br><span class="line">$ git reset --hard ee614a48f753479a111723ae7ad926e0750ffa6c</span><br><span class="line"><span class="comment"># 查看 status</span></span><br><span class="line">$ git status </span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"><span class="comment"># 查看本地文件</span></span><br><span class="line">total 16</span><br><span class="line">-rw-r--r--  1 kino  staff    17B 11 24 02:43 master_1.txt</span><br><span class="line">-rw-r--r--  1 kino  staff    17B 11 24 02:43 master_2.txt</span><br><span class="line"><span class="comment"># 可以看见文件已经丢了</span></span><br></pre></td></tr></table></figure><br>git 提供了 <code>git fsck --lost-found</code> 命令, 他会通过一些神奇的方式把历史操作过的文件以某种算法算出来加到.git/lost-found文件夹里，输出的记录就像下面这个样子。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ git fsck --lost-found</span><br><span class="line">Checking object directories: 100% (256/256), <span class="keyword">done</span>.</span><br><span class="line">dangling blob adbd4c8bf64367fb685336a67f02c5716dc47d73</span><br></pre></td></tr></table></figure><br>这里返回的第一行带有 <code>blob</code> 的信息，我们可以用 <code>git show</code>来查看里面的内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git show adbd4c8bf64367fb685336a67f02c5716dc47d73</span><br><span class="line">master message 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比如可以将内容追加到新文件中 </span></span><br><span class="line">$ git show adbd4c8bf64367fb685336a67f02c5716dc47d73 &gt; master_3.txt</span><br></pre></td></tr></table></figure></p><p>小记: 如果你的提交记录多的话, <code>git fsck --lost-found</code> 可以看见很多内容, 如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ git fsck --lost-found</span><br><span class="line">Checking object directories: 100% (256/256), <span class="keyword">done</span>.</span><br><span class="line">Checking objects: 100% (35559/35559), <span class="keyword">done</span>.</span><br><span class="line">dangling blob 601e8abff177a0b2f8a31944654c0cdf0dd1f197</span><br><span class="line">dangling tree 6c247c35ae51aa86736f745802bb59b97b6598ee</span><br><span class="line">dangling blob 7a379e6f07391f3bca1fbcc076fcde8f719ffb69</span><br><span class="line">dangling blob c66fa02bf74853789b63615a80998b3fbd3d8823</span><br><span class="line">dangling blob 4996ec43a907f8f6312c3bf137e2f76c7f4c9c9c</span><br><span class="line">dangling commit 69a110054ca792e6b1060d20ec24ddc9710ada4d</span><br><span class="line">dangling blob 87ed1263b56d0a98cd163440f872f135a34b61da</span><br><span class="line">dangling blob aff0bc224d142929e3f82b8855dd1e97d8b3635b</span><br><span class="line">dangling blob eef114f8614a15a11ccfbb7cf5e34302072176e1</span><br><span class="line">dangling blob b50db5dad43e13fde45141039f684be48e293739</span><br><span class="line">dangling blob 820f0136b61394e482fd18e28a7ba81fbb31f688</span><br><span class="line">dangling blob 2d26cd809139b86218d3460c85baed90d018f007</span><br><span class="line">dangling blob 603ca9d770947939d8da7ff3aef3775bb27c427e</span><br><span class="line">dangling blob e54821ed942c6582d01f60b6715e16301cdcfc4d</span><br><span class="line">dangling blob e06be73bb272c7837ab38226c1c1bb13f845574e</span><br><span class="line">dangling blob 399aede4e687465bf7c895251bef685b0de089b6</span><br><span class="line">dangling blob 5ea2239d63a9a119a54a52fde6ebf208a940832a</span><br><span class="line">dangling blob 35ab95c7faf42b7dbbf4e0992527c719ffd4acbd</span><br><span class="line">dangling blob 9bb609de693b78eb1dc0e3dca7a9d684effd3f4a</span><br><span class="line">dangling blob aac499592477199b2630791aecde2db8a608dfa9</span><br><span class="line">dangling commit 10c581dcdf08ea1bed594a359e09698afd4f794e</span><br><span class="line">dangling blob 06eb7790a9f71bf796749940102030c6e9503022</span><br></pre></td></tr></table></figure><br>可以看到这里有<code>blob</code>、<code>commit</code>、<code>tree</code>类型的数据，其实还有<code>tag</code>等类型的, 这里需要了解下 git 的底层存储</p><ul><li><code>commit</code> 数据结构在每次提交之后都会生成一个, 当我们进行 <code>commit</code> 之后, 首先会创建一个 <code>commit</code> 组件, 之后创建一个 <code>tree</code> 组件, 把所有的文件信息都存在里面, 每个 <code>blob</code> 都代表一个文件, 都可以在 <code>tree</code> 里面找到。</li><li><code>blob</code> 组件并不会对文件信息进行存储, 而是只对文件的内容进行记录, 文件信息存储在 <code>tree</code> 里.</li></ul><h2 id="4-终极大招"><a href="#4-终极大招" class="headerlink" title="4 终极大招"></a>4 终极大招</h2><p>如果 5.3 并没有找到你想要的内容, 那只能再去看看最近修改的文件了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects -<span class="built_in">type</span> f | xargs <span class="built_in">ls</span> -lt | sed 3q</span><br><span class="line">-r--r--r--  1 kino  staff   33 11 24 02:43 .git/objects/ad/bd4c8bf64367fb685336a67f02c5716dc47d73</span><br><span class="line">-r--r--r--  1 kino  staff   33 11 24 02:43 .git/objects/cc/6e4eeea4f70e784fade7a18bdba6c28f7642e8</span><br><span class="line">-r--r--r--  1 kino  staff   33 11 24 02:43 .git/objects/24/b6cb352efeff7a2b24b99e8ff814ab1fc2a2fd</span><br></pre></td></tr></table></figure><br>使用 <code>git cat-file -t commitid</code> 可以看见是什么类型的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t adbd4c8bf64367fb685336a67f02c5716dc47d73</span><br><span class="line">blob</span><br><span class="line"></span><br><span class="line">$ git cat-file -t cc6e4eeea4f70e784fade7a18bdba6c28f7642e8</span><br><span class="line">blob</span><br><span class="line"></span><br><span class="line">$ git cat-file -t 24b6cb352efeff7a2b24b99e8ff814ab1fc2a2fd</span><br><span class="line">blob</span><br></pre></td></tr></table></figure><br>再使用 <code>git cat-file -p commitid</code> 查看内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p adbd4c8bf64367fb685336a67f02c5716dc47d73</span><br><span class="line">master message 3</span><br><span class="line"></span><br><span class="line">$ git cat-file -p cc6e4eeea4f70e784fade7a18bdba6c28f7642e8</span><br><span class="line">master message 2</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 24b6cb352efeff7a2b24b99e8ff814ab1fc2a2fd</span><br><span class="line">master message 1</span><br></pre></td></tr></table></figure></p><h2 id="5-git-迁移-保留-commit"><a href="#5-git-迁移-保留-commit" class="headerlink" title="5 git 迁移(保留 commit)"></a>5 git 迁移(保留 commit)</h2><h3 id="5-1-clone-原来的项目"><a href="#5-1-clone-原来的项目" class="headerlink" title="5.1 clone 原来的项目"></a>5.1 clone 原来的项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --bare git://github.com/username/project.git</span><br></pre></td></tr></table></figure><h3 id="5-2-推送到新的gitlab"><a href="#5-2-推送到新的gitlab" class="headerlink" title="5.2 推送到新的gitlab"></a>5.2 推送到新的gitlab</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> project</span><br><span class="line">$ git push --mirror git@example.com/username/newproject.git</span><br></pre></td></tr></table></figure><p>会提示没有权限, 在gitlab中把项目的权限保护关掉就好了</p><h3 id="5-3-本地代码更换gitlab地址"><a href="#5-3-本地代码更换gitlab地址" class="headerlink" title="5.3 本地代码更换gitlab地址"></a>5.3 本地代码更换gitlab地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote set-url origin git@example.com/username/newproject.git</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Basic </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>links</title>
      <link href="/links/index.html"/>
      <url>/links/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
