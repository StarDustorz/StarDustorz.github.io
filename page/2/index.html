<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->


<!-- Website keywords -->




<!-- Website rss -->

<link rel="alternate" href="/atom.xml" title="Draco's Blog" type="application/atom+xml">


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://stardustorz.github.io/page/2/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":false};
</script>
  
  <title>Draco&#39;s Blog</title>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Draco&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        Home              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        Archives              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        Tags              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        Categories              </li>
    </a>
    
    <a href="/links/">
      <li class="mobile-menu-item">
        
        
        Links              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        About              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">Draco's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              Home  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              Archives  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              Tags  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              Categories  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/links/">  
              
              
              Links  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              About  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <section id="posts" class="posts">
  
  
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/07/18/DevOps/Docker/"></a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-07-18
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2024/07/01/DevOps/K8S/"></a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2024-07-01
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <ul>
<li>k8s<ul>
<li>docker<ul>
<li>实现原理<ul>
<li>namespace</li>
<li>cgroup</li>
<li>chroot</li>
</ul>
</li>
<li>镜像<ul>
<li>分层结构<ul>
<li>rootfs</li>
</ul>
</li>
<li>Dockerfile<ul>
<li>FROM</li>
<li>COPY</li>
<li>RUN</li>
<li>CMD</li>
</ul>
</li>
<li>镜像仓库</li>
</ul>
</li>
<li>命令<ul>
<li>ps</li>
<li>images</li>
<li>build</li>
<li>run</li>
<li>pull/push</li>
<li>save/load</li>
</ul>
</li>
</ul>
</li>
<li>架构<ul>
<li>master<ul>
<li>apiserver</li>
<li>etcd</li>
<li>scheduler</li>
<li>controller-manager</li>
</ul>
</li>
<li>node<ul>
<li>kubelet</li>
<li>kube-proxy</li>
<li>container-runtime</li>
</ul>
</li>
</ul>
</li>
<li>kubelet<ul>
<li>get</li>
<li>run</li>
<li>exec</li>
<li>apply</li>
<li>describe</li>
<li>explain</li>
</ul>
</li>
<li>api对象<ul>
<li>yaml语言</li>
<li>Pod</li>
<li>Job/CronJob</li>
<li>ConfigMap/Secret</li>
<li>Deployment<ul>
<li>kubectl scale</li>
<li>replicas</li>
<li>selector</li>
</ul>
</li>
<li>DaemonSet<ul>
<li>守护进程</li>
</ul>
</li>
<li>StatefulSet<ul>
<li>有状态应用</li>
</ul>
</li>
<li>Service<ul>
<li>负载均衡</li>
<li>iptables</li>
<li>kubectl expose</li>
</ul>
</li>
<li>Ingress<ul>
<li>Ingress-Controller</li>
</ul>
</li>
</ul>
</li>
<li>持久化存储<ul>
<li>PVC</li>
<li>NFS</li>
</ul>
</li>
<li>网络插件<ul>
<li>flannel</li>
<li>calico</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>构建镜像</p>
<ul>
<li>docker build -f article-api.dockerfile -t article-api:v1.0.0 .<br>查看镜像</li>
<li>docker images | grep ‘article-api’<br>生成Deployment</li>
<li>goctl kube deploy -name article-api -namespace beyond -image article-api:v1.0.0 -port 80 -o article-api.yaml<br>打包、拷贝、解压镜像</li>
<li>docker save -o article-api.tar article-api:v1.0.0</li>
<li>scp ./article-api.tar zsg@192.168.56.3:/home/zsg/images</li>
<li>docker load —input article-api.tar</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2023/11/02/DevOps/%E7%9F%A5%E5%B7%B1%E4%B8%8A%E4%BA%91/"></a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2023-11-02
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <p>STKE 提供的 HPA 能力能够很好的满足知几对扩缩容的需求，知几同时使用了定时 HPA 和动态 HAP 满足不同的场景：</p>
<ul>
<li>针对突发流量， 知几采用 CPU request 和内存 request 作为触发扩容的条件。</li>
<li>节假日和周五、六晚未成年人游戏上线，知几采用周定时 HPA 提前扩容。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/gBXSicjuwMvE0DQ8sSf45n8FicIXxprYlNGMicaf7MMKK4leVEHNQxhsJ6OxWLdWxZKauYkGfq5icgnPjwibQGqehrQ/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p>这样很大程度上减少了开发、运维同学面对运营活动和突发流量时的心智负担，提高了服务稳定性。特别是定时 HPA，可以很方便的满足知几在未成年人保护方面对扩缩容的要求，系统可以在特定时间段完成系统容量的扩容和缩容，在保证系统平稳应对流量的同时也不会造成对资源的浪费。迁移上云后，知几通过这种方式保证了周末时段和线上多场运营活动的平稳进行。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/gBXSicjuwMvE0DQ8sSf45n8FicIXxprYlNIMxLkne6debgic5fyjau3WsZibMU3kSvEibLa6VpCib2sez4bUCicP37XVw/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<h3 id="1-可观测性"><a href="#1-可观测性" class="headerlink" title="1 可观测性"></a>1 可观测性</h3><p>系统的可观测性能够让开发同学根据系统输出快速监控、定位问题。可观测性可以从 Metrics、Log、Trace 三个方面来看。</p>
<ul>
<li><strong>Metrics</strong>，知几服务大部分对接的是 Monitor 系统，通过自定义 metircs 上报实现模调信息、服务状态、业务等指标的监控，知几封装了 Monitor 的标准库实现指标模板的标准化和上报。Monitor 上报需要通过 http 请求获取上报的 ip 再将数据通过 tcp 形式发送到 Monitor 侧，这种形式的上报对业务并不友好，Monitor 当前也已不再接入新的业务，目前知几正逐步将 Metrics 迁移到智研监控系统，trpc 提供插件接入智研监控能力。</li>
<li><strong>Log</strong>，早期知几上云时采用的 filebeat 采集日志，现在 stke 提供了统一的日志数据解决方案 CLS，可以方便的进行日志采集、存储、检索，运维成本较低，体验较好。</li>
<li><strong>Trace</strong>，知几接入天机阁来对请求做 traceing，记录系统的请求链路等上下文信息。通过 traceId 对请求进行标记染色很大程度上提升了问题定位的效率。在此基础上，知几同时也在尝试 dapr[2] 这类新的分布式应用开发组件，dapr 提供的可观测性的无感知接入，相比天机阁等侵入式的接入方式，成本更低。</li>
</ul>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/gBXSicjuwMvE0DQ8sSf45n8FicIXxprYlNpjxQQNVZy5e36lgIIU4qCsfOkmV6U3wFJ7vB5iaciaHEZUhSU4IibVraA/640?wx_fmt=png&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<h3 id="2-业务稳定是第一位"><a href="#2-业务稳定是第一位" class="headerlink" title="2 业务稳定是第一位"></a>2 业务稳定是第一位</h3><p>在云原生提分实践过程中，发现很多模块的瓶颈并不是 CPU，而是流量或者内存，但是目前云原生的计算方式只计算 CPU，所以制定 HPA 扩缩容策略时需要综合各维度去考虑。</p>
<h3 id="3-降低-request-值"><a href="#3-降低-request-值" class="headerlink" title="3 降低 request 值"></a>3 降低 request 值</h3><p>对于某些流量型的模块如 http、preupload和 prxoy，可以把 workoad 的 request 的值适当降低，这样可以让 CPU 利用率的提升有立竿见影的效果，需要结合压力测试来确认 request 降低后 CPU 不会成为瓶颈。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg5NjA1MjkxNw==&amp;mid=2247521650&amp;idx=1&amp;sn=6a13f20045cb4aae49ae7ad82256c25c&amp;chksm=c0042ea8f773a7beaa3daeff95afc8eecd03187d650d70c483e96fa1ee03c03e002c5f10d97e&amp;scene=178&amp;cur_album_id=1487567830194667526#rd">https://mp.weixin.qq.com/s?__biz=Mzg5NjA1MjkxNw==&amp;mid=2247521650&amp;idx=1&amp;sn=6a13f20045cb4aae49ae7ad82256c25c&amp;chksm=c0042ea8f773a7beaa3daeff95afc8eecd03187d650d70c483e96fa1ee03c03e002c5f10d97e&amp;scene=178&amp;cur_album_id=1487567830194667526#rd</a></p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2023/10/31/DevOps/%E4%BA%91%E8%AE%A1%E7%AE%97%E6%A6%82%E8%BF%B0/"></a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2023-10-31
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="云原生概论"><a href="#云原生概论" class="headerlink" title="云原生概论"></a>云原生概论</h2><h3 id="1-云原生的定义"><a href="#1-云原生的定义" class="headerlink" title="1. 云原生的定义"></a>1. 云原生的定义</h3><ul>
<li>模块化</li>
<li>可观测性</li>
<li>可测试性</li>
<li>可处理性</li>
<li>可替换性<blockquote>
<p>云原生技术有利于各组织在公有云、私有云和混合云等新型动态环境中，构建和运行可弹性扩展的应用。云原生的代表技术包括容器、服务网格、微服务、不可变基础设施和声明式 API。</p>
</blockquote>
</li>
</ul>
<h3 id="2-云原生的目标"><a href="#2-云原生的目标" class="headerlink" title="2. 云原生的目标"></a>2. 云原生的目标</h3><ul>
<li>可用（Available）：通过各种机制来实现应用的高可用，以保证服务提供的连续性。</li>
<li>规模（Scale）：要求云原生服务能够适应不同的规模（包括但不限于用户规模/部署规模/请求量），并能够在部署时动态分配资源，以便在不同的规模之间快速和平滑的伸缩。典型场景如：<ul>
<li>初创公司或新产品线快速成长，用户规模和应用部署规模在短时间内十倍百倍增长。</li>
<li>促销、季节性、节假日带来的访问量波动。</li>
<li>高峰时间段的突发流量等。</li>
</ul>
</li>
<li>敏捷（Agility）：快速响应市场需求。</li>
<li>成本（Cost）：充分有效的利用资源。<h3 id="3-云原生代表技术"><a href="#3-云原生代表技术" class="headerlink" title="3. 云原生代表技术"></a>3. 云原生代表技术</h3><h4 id="3-1-容器技术"><a href="#3-1-容器技术" class="headerlink" title="3.1. 容器技术"></a>3.1. 容器技术</h4><h4 id="3-2-微服务"><a href="#3-2-微服务" class="headerlink" title="3.2. 微服务"></a>3.2. 微服务</h4><h4 id="3-3-服务网格"><a href="#3-3-服务网格" class="headerlink" title="3.3. 服务网格"></a>3.3. 服务网格</h4><h4 id="3-4-不可变基础设施"><a href="#3-4-不可变基础设施" class="headerlink" title="3.4. 不可变基础设施"></a>3.4. 不可变基础设施</h4><h4 id="3-5-声明式设计"><a href="#3-5-声明式设计" class="headerlink" title="3.5. 声明式设计"></a>3.5. 声明式设计</h4><h4 id="3-6-DevOps"><a href="#3-6-DevOps" class="headerlink" title="3.6. DevOps"></a>3.6. DevOps</h4></li>
</ul>
<h2 id="容器技术概论和实践"><a href="#容器技术概论和实践" class="headerlink" title="容器技术概论和实践"></a>容器技术概论和实践</h2><h3 id="1-容器技术的优点"><a href="#1-容器技术的优点" class="headerlink" title="1. 容器技术的优点"></a>1. 容器技术的优点</h3><p>容器本质上是受到资源限制，彼此间相互隔离的若干个 Linux 进程集合。容器技术借助 cgroups、namespace，以及 Linux 内核等技术从而应用可以在沙箱环境中独立运行，从而避免之间的冲突和影响</p>
<ul>
<li><strong>轻量</strong>： 容器共享计算机操作系统内核，无需为每个应用程序提供完整的操作系统实例，容器体积更小，依赖更少。与虚拟机相比，这意味着可以快速运行，更好地支持横向扩展的云原生应用程序。</li>
<li><strong>可移植且平台独立</strong>： 容器包含所有的依赖关系，这意味着软件一次编写即可运行，交付时无需再配置各类环境。由于跨平台部署的可移植性/一致性以及体积优势，容器非常适用于如 DevOps、Serverless 以及微服务这类的现代开发和应用模式。</li>
<li><strong>利用率高</strong>：容器结合容器编排系统如 Kubernetes 可以更精细地部署和扩展应用组件，实现资源利用以及业务稳定、可靠运行之间的平衡。<h3 id="2-容器技术的核心原理"><a href="#2-容器技术的核心原理" class="headerlink" title="2. 容器技术的核心原理"></a>2. 容器技术的核心原理</h3><h4 id="2-1-Namespace-资源隔离"><a href="#2-1-Namespace-资源隔离" class="headerlink" title="2.1. Namespace 资源隔离"></a>2.1. Namespace 资源隔离</h4>Linux Namespace 提供了一种内核级别隔离系统资源的方法，通过将系统的全局资源放在不同的 Namespace 中来实现资源隔离的目的。<h4 id="2-2-Cgroups-资源限制"><a href="#2-2-Cgroups-资源限制" class="headerlink" title="2.2. Cgroups 资源限制"></a>2.2. Cgroups 资源限制</h4>Cgroups 全称是 Control Groups，是 Linux 内核提供的一种可以限制单个或者多个进程多所使用物理资源的机制，可以对 CPU、内存、I/O、网络等资源实现精准的控制。</li>
<li>资源限制：对进程组使用的资源总额进行限制。</li>
<li>优先级分配：通过分配 CPU 时间片与硬盘 I/O，控制进程运行优先级。</li>
<li>资源统计： 统计进程、系统实际资源使用量。</li>
<li>进程控制：对进程组执行挂起、恢复等操作。<h4 id="2-3-UnionFs-联合文件系统"><a href="#2-3-UnionFs-联合文件系统" class="headerlink" title="2.3. UnionFs 联合文件系统"></a>2.3. UnionFs 联合文件系统</h4>联合文件系统（Union File System， UnionFs）它可以不同物理位置的目录合并、挂载到同一个目录中，而实际上目录的物理位置是分开的。UnionFs 把文件系统的每一次修改作为一个个层进行叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2023/10/09/Algorithm/%E8%B7%B3%E8%A1%A8/"></a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2023-10-09
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">![图片](file:///Users/caotianlong/Documents/%E5%88%B7%E9%A2%98/%E7%83%AD%E9%97%A8%E5%AE%9E%E7%8E%B0/img/640-20230911011754301.png?lastModify=1694370430)</span><br><span class="line"></span><br><span class="line">## 1 核心性质</span><br><span class="line"></span><br><span class="line">- 跳表由多层索引结构组成</span><br><span class="line">- 每次节点个数接近于相邻下层节点数的一半</span><br><span class="line">- 对于一个 m 层存在的节点，在 1~m-1层中这个节点也一定存在</span><br><span class="line">- 为保证连贯性，跳表额外补充了本身不存储数据的头节点和尾节点，作为起点和终点</span><br><span class="line">- 头节点和尾节点的高度是动态扩缩的，其高度取决于当前跳表内数据节点的最大高度</span><br><span class="line">- 跳表的”跳“字体现在，在高层检索时，每跳过一个节点，实际上都过滤跳过了底层的大量数据，从而实现检索加速</span><br><span class="line">## 2 数据结构定义</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line"> // 跳表的数据结构 Skiplist  </span><br><span class="line"> type Skiplist struct &#123;  </span><br><span class="line">     head *node  </span><br><span class="line"> &#125;  </span><br><span class="line"> // 节点定义  </span><br><span class="line"> type node struct &#123;  </span><br><span class="line">     // 长度为当前节点的高度  </span><br><span class="line">     nexts    []*node  </span><br><span class="line">     key, val int  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-读流程"><a href="#3-读流程" class="headerlink" title="3 读流程"></a>3 读流程</h2><ul>
<li>以 head 节点作为起点</li>
<li>从当前跳表存在的最大高度出发</li>
<li>倘若右侧节点 key 值小于 target，则持续向右遍历</li>
<li>倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回</li>
<li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li>
<li>重复（3）-（5）步</li>
<li>倘若已经抵达第1层仍然找到不到 target，则返回 key 不存在的信息</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 根据 key 读取 val，第二个 bool flag 反映 key 在 skiplist 中是否存在  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Get(key <span class="type">int</span>) (<span class="type">int</span>, <span class="type">bool</span>) &#123;  </span><br><span class="line">     <span class="comment">// 根据 key 尝试检索对应的 node，如果 node 存在，则返回对应的 val  </span></span><br><span class="line">     <span class="keyword">if</span> _node := s.search(key); _node != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> _node.val, <span class="literal">true</span>  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">false</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 从跳表中检索 key 对应的 node  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> search(key <span class="type">int</span>) *node &#123;  </span><br><span class="line">     <span class="comment">// 每次检索从头部出发  </span></span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="comment">// 每次检索从最大高度出发，直到来到首层  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="comment">// 在每一层中持续向右遍历，直到下一个节点不存在或者 key 值大于等于 key  </span></span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; key &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 如果 key 值相等，则找到了目标直接返回  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key == key &#123;  </span><br><span class="line">             <span class="keyword">return</span> move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 当前层没找到目标，则层数减 1，继续向下  </span></span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">// 遍历完所有层数，都没有找到目标，返回 nil  </span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-写流程"><a href="#4-写流程" class="headerlink" title="4 写流程"></a>4 写流程</h2><ul>
<li>首先基于读流程检索出 key 对应的节点是否存在，倘若存在，则对值进行更新并直接返回</li>
<li>随机出新插入节点的高度；倘若新插入节点的高度大于当前跳表的最大高度，则需要对起点和终点的高度进行扩容</li>
<li>以 head 节点作为起点，从当前跳表存在的最大高度出发</li>
<li>倘若右侧节点 key 值小于 target，则持续向右遍历</li>
<li>倘若右侧节点为终点（nil）或者 key 值大于 target，则在该空隙插入新节点，并降低高度进入下一层</li>
<li>重复（4）-（5）步</li>
<li>倘若已经进入第 1 层，插入新节点后即可返回<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> (<span class="string">&quot;math/rand&quot;</span>)  </span><br><span class="line"> roll 骰子，决定一个待插入的新节点在 skiplist 中最高层对应的 index  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> roll() <span class="type">int</span> &#123;  </span><br><span class="line">     <span class="keyword">var</span> level <span class="type">int</span>  </span><br><span class="line">     <span class="comment">// 每次投出 1，则层数加 1  </span></span><br><span class="line">     <span class="keyword">for</span> rand.Int() &gt; <span class="number">0</span> &#123;  </span><br><span class="line">         level++  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> level  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 将 key-val 对加入 skiplist  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Put(key, val <span class="type">int</span>) &#123;  </span><br><span class="line">     <span class="comment">// 假如 kv对已存在，则直接对值进行更新并返回  </span></span><br><span class="line">     <span class="keyword">if</span> _node := s.search(key); _node != <span class="literal">nil</span> &#123;  </span><br><span class="line">         _node.val = val  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// roll 出新节点的高度  </span></span><br><span class="line">     level := s.roll()  </span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 新节点高度超出跳表最大高度，则需要对高度进行补齐  </span></span><br><span class="line">     <span class="keyword">for</span> <span class="built_in">len</span>(s.head.nexts)<span class="number">-1</span> &lt; level &#123;  </span><br><span class="line">         s.head.nexts = <span class="built_in">append</span>(s.head.nexts, <span class="literal">nil</span>)  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 创建出新的节点  </span></span><br><span class="line">     newNode := node&#123;  </span><br><span class="line">         key:   key,  </span><br><span class="line">         val:   val,  </span><br><span class="line">         nexts: <span class="built_in">make</span>([]*node, level+<span class="number">1</span>),  </span><br><span class="line">     &#125;  </span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 从头节点的最高层出发  </span></span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="keyword">for</span> level := level; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="comment">// 向右遍历，直到右侧节点不存在或者 key 值大于 key  </span></span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; key &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 调整指针关系，完成新节点的插入  </span></span><br><span class="line">         newNode.nexts[level] = move.nexts[level]  </span><br><span class="line">         move.nexts[level] = &amp;newNode  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="删流程"><a href="#删流程" class="headerlink" title="删流程"></a>删流程</h2><ul>
<li>以 head 节点作为起点，从当前跳表存在的最大高度出发</li>
<li>倘若右侧节点 key 值小于 target，则持续向右遍历</li>
<li>倘若右侧节点为终点（nil）或者 key 值大于 target，则在该空隙插入新节点，并降低高度进入下一层</li>
<li>倘若右侧节点 key 值等于 target，则代表找到目标</li>
<li>找到目标值后，沿当前节点层层向下，依次将每层中的目标节点删除</li>
<li>倘若已经进入第 1 层仍然没有找到节点，说明节点不存在，删除失败</li>
<li><p>倘若删除成功，需要尝试对跳表的整体高度进行缩容，即需要对高度递减，直到确定最大高度对应的层数上至少存在一个有效的数据节点为止</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 key 从跳表中删除对应的节点  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Del(key <span class="type">int</span>) &#123;  </span><br><span class="line">     <span class="comment">// 如果 kv 对不存在，则无需删除直接返回  </span></span><br><span class="line">     <span class="keyword">if</span> _node := s.search(key); _node == <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 从头节点的最高层出发      </span></span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="comment">// 向右遍历，直到右侧节点不存在或者 key 值大于等于 key  </span></span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; key &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">           </span><br><span class="line">         <span class="comment">// 右侧节点不存在或者 key 值大于 target，则直接跳过  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] == <span class="literal">nil</span> || move.nexts[level].key &gt; key&#123;  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">         &#125;      </span><br><span class="line">         <span class="comment">// 走到此处意味着右侧节点的 key 值必然等于 key，则调整指针引用  </span></span><br><span class="line">         move.nexts[level] = move.nexts[level].nexts[level]  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 对跳表的最大高度进行更新  </span></span><br><span class="line">     <span class="keyword">var</span> dif <span class="type">int</span>  </span><br><span class="line">     <span class="comment">// 倘若某一层已经不存在数据节点，高度需要递减  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt; <span class="number">0</span> &amp;&amp; s.head.nexts[level] == <span class="literal">nil</span>; level-- &#123;  </span><br><span class="line">         dif++  </span><br><span class="line">     &#125;  </span><br><span class="line">     s.head.nexts = s.head.nexts[:<span class="built_in">len</span>(s.head.nexts)-dif]  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-RANGE-流程"><a href="#5-RANGE-流程" class="headerlink" title="5 RANGE 流程"></a>5 RANGE 流程</h2></li>
<li>以 head 节点作为起点</li>
<li>从当前跳表存在的最大高度出发</li>
<li>倘若右侧节点 key 值小于 target，则持续向右遍历</li>
<li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li>
<li>倘若右侧节点 key 值等于 target，则代表找到目标，直接沿该节点向下来到第1层</li>
<li><p>重复（3）-（5）步，直到来到第1层，接下来从首个大于等于 target 的节点出发，向右依次遍历，直到取满 range 区间的数据后返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到 skiplist 当中 ≥ start，且 ≤ end 的 kv 对  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Range(start, end <span class="type">int</span>) [][<span class="number">2</span>]<span class="type">int</span> &#123;  </span><br><span class="line">     <span class="comment">// 首先通过 ceiling 方法，找到 skiplist 中 key 值大于等于 start 且最接近于 start 的节点 ceilNode  </span></span><br><span class="line">     ceilNode := s.ceiling(start)  </span><br><span class="line">     <span class="comment">// 如果不存在，直接返回  </span></span><br><span class="line">     <span class="keyword">if</span> ceilNode == <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> [][<span class="number">2</span>]<span class="type">int</span>&#123;&#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 从 ceilNode 首层出发向右遍历，把所有位于 [start,end] 区间内的节点统统返回  </span></span><br><span class="line">     <span class="keyword">var</span> res [][<span class="number">2</span>]<span class="type">int</span>  </span><br><span class="line">     <span class="keyword">for</span> move := ceilNode; move != <span class="literal">nil</span> &amp;&amp; move.key &lt;= end; move = move.nexts[<span class="number">0</span>] &#123;  </span><br><span class="line">         res = <span class="built_in">append</span>(res, [<span class="number">2</span>]<span class="type">int</span>&#123;move.key, move.val&#125;)  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> res  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 找到 key 值大于等于 target 且 key 值最接近于 target 的节点  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> ceiling(target <span class="type">int</span>) *node &#123;  </span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="comment">// 自上而下，找到 key 值小于 target 且最接近 target 的 kv 对  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; target &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 如果 key 值等于 targe 的 kv 对存在，则直接返回  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key == target &#123;  </span><br><span class="line">             <span class="keyword">return</span> move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">// 此时 move 已经对应于在首层 key 值小于 key 且最接近于 key 的节点，其右侧第一个节点即为所寻找的目标节点  </span></span><br><span class="line">     <span class="keyword">return</span> move.nexts[<span class="number">0</span>]  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="CEILING-流程"><a href="#CEILING-流程" class="headerlink" title="CEILING 流程"></a>CEILING 流程</h2><ul>
<li>以 head 节点作为起点</li>
<li>从当前跳表存在的最大高度出发</li>
<li>倘若右侧节点 key 值小于 target，则持续向右遍历</li>
<li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li>
<li>倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回</li>
<li>重复（3）-（5）步，直到找到 key 值等于 target 的节点或者来到第1层，接下来获取到首个大于等于 target 的节点并返回</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 找到 skiplist 中，key 值大于等于 target 且最接近于 target 的 key-value 对  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Ceiling(target <span class="type">int</span>) ([<span class="number">2</span>]<span class="type">int</span>, <span class="type">bool</span>) &#123;  </span><br><span class="line">     <span class="keyword">if</span> ceilNode := s.ceiling(target); ceilNode != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;ceilNode.key, ceilNode.val&#125;, <span class="literal">true</span>  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;&#125;, <span class="literal">false</span>  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>
<p> ​</p>
<h2 id="6-FLOOR-流程"><a href="#6-FLOOR-流程" class="headerlink" title="6 FLOOR 流程"></a>6 FLOOR 流程</h2><ul>
<li>以 head 节点作为起点</li>
<li>从当前跳表存在的最大高度出发</li>
<li>倘若右侧节点 key 值小于 target，则持续向右遍历</li>
<li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li>
<li>倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回</li>
<li><p>重复（3）-（5）步，直到找到 key 值等于 target 的节点或者来到第1层，接下来获取到首个小于等于 target 的节点并返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到 skiplist 中，key 值小于等于 target 且最接近于 target 的 key-value 对  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Floor(target <span class="type">int</span>) ([<span class="number">2</span>]<span class="type">int</span>, <span class="type">bool</span>) &#123;  </span><br><span class="line">     <span class="comment">// 引用 floor 方法，取 floorNode 值进行返回  </span></span><br><span class="line">     <span class="keyword">if</span> floorNode := s.floor(target); floorNode != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;floorNode.key, floorNode.val&#125;, <span class="literal">true</span>  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;&#125;, <span class="literal">false</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 找到 key 值小于等于 target 且 key 值最接近于 target 的节点  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> floor(target <span class="type">int</span>) *node &#123;  </span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="comment">// 自上而下，找到 key 值小于 target 且最接近 target 的 kv 对  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; target &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 如果 key 值等于 targe 的 kv对存在，则直接返回  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key == target &#123;  </span><br><span class="line">             <span class="keyword">return</span> move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// move 是首层中 key 值小于 target 且最接近 target 的节点，直接返回 move 即可  </span></span><br><span class="line">     <span class="keyword">return</span> move  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>
<p>​<br>​</p>
</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2023/10/09/Basic/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"></a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2023-10-09
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1-硬件结构"><a href="#1-硬件结构" class="headerlink" title="1 硬件结构"></a>1 硬件结构</h2><ul>
<li>什么是中断？<ul>
<li>中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。</li>
</ul>
</li>
<li>什么是软中断？<ul>
<li>为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」</li>
<li><strong>上半部直接处理硬件请求，也就是硬中断</strong>，主要是负责耗时短的工作，特点是快速执行；</li>
<li><strong>下半部是由内核触发，也就说软中断</strong>，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；</li>
</ul>
</li>
</ul>
<h2 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2 内存管理"></a>2 内存管理</h2><h3 id="2-1-虚拟内存"><a href="#2-1-虚拟内存" class="headerlink" title="2.1 虚拟内存"></a>2.1 虚拟内存</h3><ul>
<li><em>虚拟地址</em>： 隔离不同进程，给每个进程独立的虚拟地址，并通过内存管理单元 MMU 映射到物理地址。</li>
<li><em>虚拟内存</em>：让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。  因为申请了不代表会用满，局部性原理<h3 id="2-2-内存分段"><a href="#2-2-内存分段" class="headerlink" title="2.2 内存分段"></a>2.2 内存分段</h3></li>
<li>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。<strong>不同的段是有不同的属性的，所以就用分段（<em>Segmentation</em>）的形式把这些段分离出来。</strong></li>
<li>分段机制下的虚拟地址由两部分组成，<strong>段选择因子</strong>和<strong>段内偏移量</strong>。<ul>
<li><strong>段选择子</strong>就保存在段寄存器里面。段选择子里面最重要的是<strong>段号</strong>，用作段表的索引。<strong>段表</strong>里面保存的是这个<strong>段的基地址、段的界限和特权等级</strong>等。</li>
<li>虚拟地址中的<strong>段内偏移量</strong>应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</li>
</ul>
</li>
<li>缺点：<strong>内存碎片</strong>，内存交换效率低<h3 id="2-3-内存分页"><a href="#2-3-内存分页" class="headerlink" title="2.3 内存分页"></a>2.3 内存分页</h3></li>
<li><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）。在 Linux 下，每一页的大小为 <code>4KB</code>。</li>
<li><strong>内存管理单元</strong> （<em>MMU</em>）将虚拟内存地址转换成物理地址</li>
<li>分页机制下，虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，<strong>页表</strong>包含物理页每页所在<strong>物理内存的基地址</strong>，这个基地址与页内偏移的组合就形成了物理内存地址</li>
<li><em>多级页表</em>：将页表（一级页表）分为 <code>1024</code> 个页表（二级页表），每个表（二级页表）中包含 <code>1024</code> 个「页表项」，形成<strong>二级分页</strong>。</li>
<li><em>快表 TLB</em>： 页表缓存、转址旁路缓存、快表; 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。<h3 id="2-4-段页式"><a href="#2-4-段页式" class="headerlink" title="2.4 段页式"></a>2.4 段页式</h3></li>
<li>先将程序划分为多个有逻辑意义的段，再把每个段划分为多个页</li>
<li>地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成</li>
<li>每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号<h3 id="2-5-Linux-内存布局"><a href="#2-5-Linux-内存布局" class="headerlink" title="2.5 Linux 内存布局"></a>2.5 Linux 内存布局</h3></li>
<li><strong>Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理</strong>。于是 Linux 就把所有段的基地址设为 <code>0</code>，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。</li>
<li>Linux 系统中虚拟空间分布可分为<strong>用户态</strong>和<strong>内核态</strong>两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。<h2 id="3-进程管理"><a href="#3-进程管理" class="headerlink" title="3 进程管理"></a>3 进程管理</h2><h3 id="3-1-进程基础知识"><a href="#3-1-进程基础知识" class="headerlink" title="3.1 进程基础知识"></a>3.1 进程基础知识</h3><blockquote>
<p><strong>进程是若干个活动的执行流以及各类相关资源的总称</strong>，这些资源包括内核结构、地址空间（内存），寄存器等<br>运行可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个<strong>运行中的程序，就被称为「进程」（Process）</strong></p>
<h4 id="3-1-1-进程的状态"><a href="#3-1-1-进程的状态" class="headerlink" title="3.1.1 进程的状态"></a>3.1.1 进程的状态</h4></blockquote>
</li>
<li>运行状态（<em>Running</em>）：该时刻进程占用 CPU；</li>
<li>就绪状态（<em>Ready</em>）：可运行，由于其他进程处于运行状态而暂时停止运行；</li>
<li>阻塞状态（<em>Blocked</em>）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；</li>
<li>创建状态（<em>new</em>）：进程正在被创建时的状态；</li>
<li>结束状态（<em>Exit</em>）：进程正在从系统中消失时的状态；<h4 id="3-1-2-进程的控制结构"><a href="#3-1-2-进程的控制结构" class="headerlink" title="3.1.2 进程的控制结构"></a>3.1.2 进程的控制结构</h4></li>
<li>用<strong>进程控制块</strong>（<em>process control block，PCB</em>）数据结构来描述进程</li>
<li><em>PCB 是进程存在的唯一标识</em><ul>
<li><code>进程描述信息</code>：<ul>
<li>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；</li>
<li>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；</li>
</ul>
</li>
<li><code>进程控制和管理信息</code>：<ul>
<li>进程当前状态，如 new、ready、running、waiting 或 blocked 等；</li>
<li>进程优先级：进程抢占 CPU 时的优先级；</li>
</ul>
</li>
<li><code>资源分配清单</code>：<ul>
<li>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。</li>
</ul>
</li>
<li><code>CPU 相关信息</code>：<ul>
<li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。<h4 id="3-1-3-进程的上下文切换"><a href="#3-1-3-进程的上下文切换" class="headerlink" title="3.1.3 进程的上下文切换"></a>3.1.3 进程的上下文切换</h4></li>
</ul>
</li>
</ul>
</li>
<li><strong>一个进程切换到另一个进程运行，称为进程的上下文切换</strong>。</li>
<li><em>CPU 上下文切换</em>：把保存前一个任务的 CPU 上下文（CPU 寄存器和程序计数器），加载新任务的上下文到这些寄存器和程序计数器，再跳转到程序计数器所指的新位置，运行新任务</li>
<li><em>进程的上下文切换</em> :不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</li>
</ul>
<h3 id="3-2-进程通信"><a href="#3-2-进程通信" class="headerlink" title="3.2 进程通信"></a>3.2 进程通信</h3><ul>
<li>每个进程的用户地址空间都是独立的，进程之间要通信必须通过内核。</li>
<li><em>管道</em>：对于匿名管道，它的通信范围是存在父子关系的进程，通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</li>
<li><em>消息队列</em>：保存在内核中的消息链表</li>
<li><em>共享内存</em>：拿出一块虚拟地址空间来，映射到相同的物理内存中</li>
<li><em>信号量</em>：主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</li>
<li><em>Socket</em>：跨网络与不同主机上的进程之间通信，针对 TCP、UDP、本机间的模型</li>
<li><em>死锁</em><ul>
<li>条件：互斥，占用和等待，不可抢占，循环等待</li>
<li>忽略；检测和恢复，预防，避免</li>
</ul>
</li>
</ul>
<h3 id="3-3-线程"><a href="#3-3-线程" class="headerlink" title="3.3 线程"></a>3.3 线程</h3><ul>
<li><em>线程是进程当中的一条执行流程。</em> 同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套<code>独立的寄存器和栈</code>，这样可以确保线程的控制流是相对独立的。</li>
<li><em>线程与进程的比较</em><ul>
<li>进程是<code>资源（包括内存、打开的文件等）分配</code>的单位，线程是<code>CPU 调度</code>的单位</li>
<li>进程拥有一个完整的<code>资源平台</code>，而线程只独享必不可少的资源，如<code>寄存器和栈</code></li>
<li>线程能减少并发执行的<code>时间和空间开销</code><ul>
<li>线程的创建时间比进程快，不涉及资源管理</li>
<li>线程的终止时间比进程快，释放的资源少</li>
<li>同一个进程内的线程切换比进程切换快，不需要切换页表</li>
<li>共享内存和文件资源，数据交互效率更高</li>
</ul>
</li>
</ul>
</li>
<li><em>线程的上下文切换</em>：两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的<code>私有数据</code>、寄存器等不共享的数据</li>
<li><em>线程的实现</em>：<ul>
<li><strong>用户线程（<em>User Thread</em>）</strong>：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；</li>
<li><strong>内核线程（<em>Kernel Thread</em>）</strong>：在内核中实现的线程，是由内核管理的线程；</li>
<li><strong>轻量级进程（<em>LightWeight Process</em>）</strong>：在内核中来支持用户线程；</li>
</ul>
</li>
<li><em>线程控制块TCB</em> ：线程状态信息（PC、栈指针、寄存器）</li>
<li><em>线程通信</em>：共享变量等，主要关注竞争共享资源的问题<h3 id="3-4-协程"><a href="#3-4-协程" class="headerlink" title="3.4 协程"></a>3.4 协程</h3></li>
<li>不是进程也不是线程，而是一个特殊的函数。协程是属于线程的。协程程序是在线程里面跑的，因此协程又称微线程和纤程等<ul>
<li>比线程更轻量级，协程完全由程序控制（也就是在用户态执行）</li>
<li>没有线程切换的开销</li>
<li>和多线程比，线程数量越多，协程的性能优势就越明显</li>
</ul>
</li>
</ul>
<h2 id="4-调度算法"><a href="#4-调度算法" class="headerlink" title="4 调度算法"></a>4 调度算法</h2><h3 id="4-1-进程调度算法"><a href="#4-1-进程调度算法" class="headerlink" title="4.1 进程调度算法"></a>4.1 进程调度算法</h3><ul>
<li><em>先来先服务调度算法</em>：每次从就绪队列选择最先进入队列的进程</li>
<li><em>最短作业优先调度算法</em>：优先选择运行时间最短的进程来运行</li>
<li><em>高响应比优先调度算法</em>：把「响应比优先级」最高的进程投入运行  服务时间+等待时间/服务时间</li>
<li><em>时间片轮转调度算法</em>：每个进程被分配一个时间段</li>
<li><em>最高优先级调度算法</em>：从就绪队列中选择最高优先级的进程进行运行</li>
<li><em>多级反馈队列调度算法</em>：设置多个优先级队列，优先级越高时间片越短，在当前队列没执行完就去下一级队尾<h3 id="4-2-内存页面置换算法"><a href="#4-2-内存页面置换算法" class="headerlink" title="4.2 内存页面置换算法"></a>4.2 内存页面置换算法</h3></li>
<li>当 CPU 访问的页面不在物理内存时，便会产生一个<code>缺页中断</code>，请求操作系统将所缺页调入到物理内存</li>
<li><em>最佳页面置换算法</em>：理想状态</li>
<li><em>先进先出置换算法</em>：置换掉在内存驻留时间很长的页面</li>
<li><em>时钟页面置换算法</em>：指到谁就替换</li>
<li><em>最不常用算法</em>：选择「访问次数」最少的那个页面，并将其淘汰<h3 id="4-3-磁盘调度算法"><a href="#4-3-磁盘调度算法" class="headerlink" title="4.3 磁盘调度算法"></a>4.3 磁盘调度算法</h3></li>
<li>_先来先服务算法</li>
<li>_最短寻道时间优先算法</li>
<li>_扫描算法</li>
<li>_循环扫描算法</li>
<li>_LOOK 与 C-LOOK 算法</li>
</ul>
<h2 id="5-网络系统"><a href="#5-网络系统" class="headerlink" title="5 网络系统"></a>5 网络系统</h2><h3 id="5-1-零拷贝"><a href="#5-1-零拷贝" class="headerlink" title="5.1 零拷贝"></a>5.1 零拷贝</h3><ul>
<li><strong>直接内存访问（<em>Direct Memory Access</em>）</strong> 技术</li>
<li>由 DMA 控制器负责进行 I/O 设备和内存的数据传输工作，CPU 不参与</li>
<li>过程：<ul>
<li>操作系统将 I/O 请求发送 DMA</li>
<li>DMA 将 I/O 请求发送给磁盘</li>
<li>磁盘把数据读取到缓冲区中，读满后，向 DMA 发起中断信号，告知缓冲区已满</li>
<li>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中</li>
<li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU</li>
<li>CPU 将数据从内核拷贝到用户空间，系统调用返回</li>
</ul>
</li>
<li>实现零拷贝？<ul>
<li>减少「上下文切换」和「数据拷贝」的次数</li>
<li>mmap + write：把内核缓冲区里的数据「<strong>映射</strong>」到用户空间</li>
<li>sendfile：替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销<h3 id="5-2-I-O-多路复用"><a href="#5-2-I-O-多路复用" class="headerlink" title="5.2 I/O 多路复用"></a>5.2 I/O 多路复用</h3></li>
</ul>
</li>
<li>多个请求复用了一个进程，这就是多路复用，<strong>程可以通过一个系统调用函数从内核中获取多个事件</strong><h4 id="5-2-1-Select"><a href="#5-2-1-Select" class="headerlink" title="5.2.1 Select"></a>5.2.1 Select</h4></li>
<li>将已连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后调用 select 函数<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合<strong>拷贝</strong>回用户态里，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket，然后再对其处理。</li>
<li>需要进行 <strong>2 次「遍历」文件描述符集合</strong></li>
<li>使用固定长度的 BitsMap，表示文件描述符集合，最多监听 1024 个</li>
</ul>
<h4 id="5-2-2-poll"><a href="#5-2-2-poll" class="headerlink" title="5.2.2 poll"></a>5.2.2 poll</h4><ul>
<li>poll 用链表形式来组织存储所关注的文件描述符，突破了 select 的文件描述符个数限制</li>
<li>和 select 并没有太大的本质区别，都是线性结构，也都需要遍历</li>
</ul>
<h4 id="5-2-3-epoll"><a href="#5-2-3-epoll" class="headerlink" title="5.2.3 epoll"></a>5.2.3 epoll</h4><ul>
<li>epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里</li>
<li>epoll 使用<code>事件驱动</code>的机制，内核里维护了一个<code>链表</code>来记录就绪事件，当某个 socket 有事件发生时，通过<code>回调函数</code>内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</li>
<li><em>事件触发模式</em><ul>
<li><strong>边缘触发</strong>：当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；   <strong>一般和非阻塞 I/O 搭配使用</strong></li>
<li><strong>水平触发</strong>：当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong>，目的是告诉我们有数据需要读取；</li>
</ul>
</li>
</ul>
<h3 id="5-3-高性能网络模式"><a href="#5-3-高性能网络模式" class="headerlink" title="5.3 高性能网络模式"></a>5.3 高性能网络模式</h3><p><strong>I/O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程</strong></p>
<h4 id="5-3-1-Reactor-模式"><a href="#5-3-1-Reactor-模式" class="headerlink" title="5.3.1 Reactor 模式"></a>5.3.1 Reactor 模式</h4><ul>
<li><strong>Reactor（监听和分发事件）、Acceptor（获取连接）、Handler（处理业务）</strong></li>
<li>单 Reactor 单进程 / 线程，不用考虑进程间通信以及数据同步的问题，因此实现起来比较简单，这种方案的缺陷在于无法充分利用多核 CPU，而且处理业务逻辑的时间不能太长，否则会延迟响应，所以不适用于计算机密集型的场景，适用于业务处理快速的场景，比如 Redis（6.0之前 ） 采用的是单 Reactor 单进程的方案。</li>
<li>单 Reactor 多线程，通过多线程的方式解决了方案一的缺陷，但它离高并发还差一点距离，差在只有一个 Reactor 对象来承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方。</li>
<li>Reactor 多进程 / 线程，通过多个 Reactor 来解决了方案二的缺陷，主 Reactor 只负责监听事件，响应事件的工作交给了从 Reactor<h4 id="5-3-2-Proactor-异步网络模式"><a href="#5-3-2-Proactor-异步网络模式" class="headerlink" title="5.3.2 Proactor 异步网络模式"></a>5.3.2 Proactor 异步网络模式</h4></li>
<li>阻塞 I/O：食堂等  ； 非阻塞 I/O： 过一段时间再去食堂； 异步 I/O： 阿姨送过来</li>
<li><strong>Proactor 是异步网络模式， 感知的是已完成的读写事件</strong>。<strong>「来了事件操作系统来处理，处理完再通知应用进程」</strong>。</li>
</ul>
<h2 id="6-Linux命令"><a href="#6-Linux命令" class="headerlink" title="6 Linux命令"></a>6 Linux命令</h2><h3 id="6-1-查看网络性能指标"><a href="#6-1-查看网络性能指标" class="headerlink" title="6.1 查看网络性能指标"></a>6.1 查看网络性能指标</h3><ul>
<li>网络的配置和状态   使用 <code>ifconfig</code> 或者 <code>ip</code> 命令来查看</li>
<li>socket 信息如何查看   使用 <code>netstat</code> 或者 <code>ss</code></li>
<li>网络吞吐率和 PPS 如何查看     使用 <code>sar</code> 命令</li>
<li>连通性和延时如何查看  ping</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2023/10/09/Basic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"></a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2023-10-09
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="1-网络模型与协议"><a href="#1-网络模型与协议" class="headerlink" title="1 网络模型与协议"></a>1 网络模型与协议</h2><h3 id="1-1-网络模型分层解析"><a href="#1-1-网络模型分层解析" class="headerlink" title="1.1 网络模型分层解析"></a>1.1 网络模型分层解析</h3><ul>
<li><code>OSI七层模型</code>：应用（DNS，HTTP，SMTP，FTP）， 表示 ，会话，传输（TCP、UDP），网络（IP ICMP），数据链路，物理</li>
<li><code>TCP/IP</code>：<ul>
<li><code>应用层</code>：工作在用户态，往下都在内核态；主要协议有：HTTP、FTP、Telnet、DNS、SMTP等</li>
<li><code>传输层</code>：为用层提供网络支持；主要协议有 TCP&amp;UDP，加上 TCP 头部</li>
<li><code>网络层</code>：实现实际的传输功能；主要协议有 IP 协议，加上 IP 头部</li>
<li><code>网络接口层</code>：链路级别， IP 头部的前面加上 MAC 头部，并封装成数据帧（Data frame）发送到网络上<h3 id="1-2-常见协议报文格式"><a href="#1-2-常见协议报文格式" class="headerlink" title="1.2 常见协议报文格式"></a>1.2 常见协议报文格式</h3></li>
</ul>
</li>
<li><code>TCP首部格式</code>（源/目标端口号; 序列号(随机数,避免乱序); 确认号(避免丢包); 首部长度; 关键字; 窗口; 校验和）</li>
<li><code>UDP</code>（端口号 长度 校验和） 包 最大为64k</li>
<li><code>IP报文</code>（版本 首部长度 服务类型 总长度 生存时间 校验和 ip地址</li>
<li><code>TCP</code>：TCP<code>最大报文段长度</code>（MSS，536字节），超过就分块（TCP Segment） IP：加上IP头成为IP报文，如果超过<code>MTU</code>（1500字节）就分片</li>
</ul>
<h2 id="2-HTTP-amp-HTTPS"><a href="#2-HTTP-amp-HTTPS" class="headerlink" title="2 HTTP &amp; HTTPS"></a>2 HTTP &amp; HTTPS</h2><h3 id="2-1-HTTP"><a href="#2-1-HTTP" class="headerlink" title="2.1 HTTP"></a>2.1 HTTP</h3><h4 id="2-1-1-HTTP-基本概念"><a href="#2-1-1-HTTP-基本概念" class="headerlink" title="2.1.1 HTTP 基本概念"></a>2.1.1 HTTP 基本概念</h4><h5 id="2-1-1-1-HTTP-是什么？"><a href="#2-1-1-1-HTTP-是什么？" class="headerlink" title="2.1.1.1 HTTP 是什么？"></a>2.1.1.1 HTTP 是什么？</h5><p>超文本传输协议</p>
<h5 id="2-1-1-2-HTTP-常见状态码"><a href="#2-1-1-2-HTTP-常见状态码" class="headerlink" title="2.1.1.2 HTTP 常见状态码"></a>2.1.1.2 HTTP 常见状态码</h5><ul>
<li>1xx：<strong>指示信息</strong>—表示请求已接收，继续处理；</li>
<li>2xx：<strong>成功</strong>—表示请求已被成功接收、理解、接受；200—OK 204—请求收到，但返回信息为空 206—服务器已经完成了部分用户的GET请求</li>
<li>3xx：<strong>重定向</strong>—信息不完整需要进一步补充；300 请求资源在多处可得到。301—永久重定向，隐式重定向。302 临时重定向，显示重定向。 304—请求的资源没有改变，可以使用缓存。</li>
<li>4xx：<strong>客户端错误</strong>—请求有语法错误或请求无法实现； 401—-未授权 403—禁止访问。 404 –找不到。409：对当前资源状态，请求不能完成</li>
<li>5xx：<strong>服务器端错误</strong>—服务器未能实现合法的请求；500内部服务器错误，501未实现，502网关错误，503服务不可用，504 网关超时<h5 id="2-1-1-3-HTTP-常见字段"><a href="#2-1-1-3-HTTP-常见字段" class="headerlink" title="2.1.1.3 HTTP 常见字段"></a>2.1.1.3 HTTP 常见字段</h5></li>
<li><em>Host</em> 字段：指定服务器域名</li>
<li><em>Content-Length 字段</em>：表明本次回应的数据长度</li>
<li><em>Connection 字段</em>：要求服务器使用「HTTP 长连接」机制，Keep-Alive</li>
<li><em>Content-Type 字段</em>：本次数据格式</li>
<li><em>Content-Encoding 字段</em>：数据的压缩方法<h4 id="2-1-2-GET-和-POST-有什么区别"><a href="#2-1-2-GET-和-POST-有什么区别" class="headerlink" title="2.1.2 GET 和 POST 有什么区别"></a>2.1.2 GET 和 POST 有什么区别</h4></li>
<li><code>RFC 规范</code>：GET 的语义是从服务器 <em>获取指定的资源</em>；POST 的语义是根据请求负荷（报文body）对 <em>指定的资源做出处理</em></li>
<li>GET 方法是安全、幂等、可被缓存的</li>
<li>POST 不安全，不幂等，（大部分实现）不可缓存<h4 id="2-1-3-HTTP缓存技术"><a href="#2-1-3-HTTP缓存技术" class="headerlink" title="2.1.3 HTTP缓存技术"></a>2.1.3 HTTP缓存技术</h4></li>
<li><code>强制缓存</code>：Cache-Control 和 Expires 控制资源在客户端的缓存有效期</li>
<li><code>协商缓存</code>：<em>Last-Modified</em> 资源没修改，响应 HTTP 304 走缓存 ; <em>ETag</em>,判断资源有没有变化<h4 id="2-1-4-HTTP特性"><a href="#2-1-4-HTTP特性" class="headerlink" title="2.1.4 HTTP特性"></a>2.1.4 HTTP特性</h4></li>
<li>优点：简单，灵活容易拓展，跨平台</li>
<li>缺点：明文传输，无状态，不安全</li>
<li>性能：<em>长连接</em>；<em>管道网络传输</em>：当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「<strong>队头阻塞</strong>」<h3 id="2-2-HTTPS"><a href="#2-2-HTTPS" class="headerlink" title="2.2 HTTPS"></a>2.2 HTTPS</h3><h4 id="2-2-1-HTTPS-的区别"><a href="#2-2-1-HTTPS-的区别" class="headerlink" title="2.2.1 HTTPS 的区别"></a>2.2.1 HTTPS 的区别</h4></li>
<li><code>加密传输</code>：在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议<ul>
<li>混合加密：<strong>对称加密</strong>和<strong>非对称加密</strong>结合，非对称加密交换会话秘钥</li>
<li><em>摘要算法 + 数字签名</em>：计算内容的指纹</li>
</ul>
</li>
<li><code>连接建立</code>：需进行 SSL/TLS 的握手过程<ul>
<li>基于 RSA 的 TLS 握手过程<ul>
<li><em>ClientHello</em>：客户端发起加密通信请求，发送（一个随机数，TLS 版本，加密算法）给服务器</li>
<li><em>SeverHello</em>：服务端回应，发送随机数和数字证书</li>
<li><em>客户端回应</em>：取出公钥加密报文，再发送随机数过去，握手介绍，生成摘要</li>
<li><em>服务器的最后回应</em>： 计算出本次通话的会话秘钥，变更加密通信算法</li>
</ul>
</li>
</ul>
</li>
<li><code>默认端口</code>：HTTP 默认端口号是 <code>80</code>，HTTPS 默认端口号是 <code>443</code></li>
<li><code>可信身份</code>：向 CA（证书权威机构）申请数字证书<ul>
<li>把公钥注册到 CA，客户端拿到<code>数字证书</code>（公钥+数字签名）后用 CA 的公钥验证<h4 id="2-2-2-HTTPS-怎么保证数据完整性"><a href="#2-2-2-HTTPS-怎么保证数据完整性" class="headerlink" title="2.2.2 HTTPS 怎么保证数据完整性"></a>2.2.2 HTTPS 怎么保证数据完整性</h4></li>
</ul>
</li>
<li>TLS 在实现上分为<strong>握手协议</strong>和<strong>记录协议</strong>两层：</li>
<li>TLS 握手协议负责协商加密算法和生成对称密钥</li>
<li>TLS 记录协议负责保护应用程序数据并验证其完整性和来源<ul>
<li>消息被分割成多个较短的片段,然后分别对每个片段进行压缩</li>
<li><strong>加上消息认证码（MAC 值，这个是通过哈希算法生成的），这是为了保证完整性，并进行数据的认证</strong>。通过附加消息认证码的 MAC 值，可以识别出篡改。与此同时，为了防止重放攻击，在计算消息认证码时，还加上了片段的编码。</li>
<li>经过压缩的片段再加上消息认证码会一起通过对称密码进行加密。</li>
<li>经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。</li>
</ul>
</li>
</ul>
<h4 id="2-2-3-HTTPS-一定安全吗"><a href="#2-2-3-HTTPS-一定安全吗" class="headerlink" title="2.2.3 HTTPS 一定安全吗"></a>2.2.3 HTTPS 一定安全吗</h4><ul>
<li>中间人攻击：客户端接受了中间人服务器的证书，然后中间人分别和客户端服务器 TLS 握手并转发。</li>
<li>HTTPS 协议本身到目前为止还是没有任何漏洞的，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。</li>
<li>抓包：使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。<h3 id="2-3-HTTP-1-1-amp-2-0-amp-3-0-演变"><a href="#2-3-HTTP-1-1-amp-2-0-amp-3-0-演变" class="headerlink" title="2.3 HTTP 1.1&amp;2.0 &amp; 3.0 演变"></a>2.3 HTTP 1.1&amp;2.0 &amp; 3.0 演变</h3><h4 id="2-3-1-HTTP-1-1-相比-HTTP-1-0"><a href="#2-3-1-HTTP-1-1-相比-HTTP-1-0" class="headerlink" title="2.3.1 HTTP/1.1 相比 HTTP/1.0"></a>2.3.1 HTTP/1.1 相比 HTTP/1.0</h4></li>
<li>优点：<ul>
<li>使用<code>长连接</code>的方式改善了 HTTP/1.0 短连接造成的性能开销。</li>
<li>支持管道（pipeline）网络传输</li>
</ul>
</li>
<li>缺点：<ul>
<li>请求 / 响应头部（Header）没压缩，造成浪费</li>
<li>队头阻塞</li>
<li>没有请求优先级控制</li>
<li>服务器只能被动响应<h4 id="2-3-2-HTTP-2-优化"><a href="#2-3-2-HTTP-2-优化" class="headerlink" title="2.3.2 HTTP/2 优化"></a>2.3.2 HTTP/2 优化</h4></li>
</ul>
</li>
<li><em>头部压缩</em>：消除重复的部分,HPACK算法维护头信息表和字段的映射</li>
<li><em>二进制格式</em>：头信息和数据体都是二进制，并且统称为帧（frame）</li>
<li><em>并发传输</em>：引入了 Stream，针对不同的 HTTP 请求用独一无二的 Stream ID 来区分，可以并行交错地发送请求和响应</li>
<li><em>服务器推送</em>：<strong>双方都可以建立 Stream</strong>，服务器可以主动向客户端发送消息</li>
<li>问题：基于 TCP 传输数据，需要按序到达缓冲区才能从内核取数据，一旦丢包就会阻塞所有请求这就是 HTTP/2 <code>队头阻塞</code>问题。<h4 id="2-3-3-HTTP-3-优化"><a href="#2-3-3-HTTP-3-优化" class="headerlink" title="2.3.3 HTTP/3 优化"></a>2.3.3 HTTP/3 优化</h4></li>
<li><strong>把 HTTP 下层的 TCP 协议改成了 UDP</strong></li>
<li>基于 UDP 的 <strong>QUIC 协议</strong>实现可靠传输：就是把 TCP 的校验放到应用层实现</li>
</ul>
<h3 id="2-4-HTTP-amp-RPC"><a href="#2-4-HTTP-amp-RPC" class="headerlink" title="2.4 HTTP &amp; RPC"></a>2.4 HTTP &amp; RPC</h3><ul>
<li>TCP 的特点 <strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong><ul>
<li>没有消息边界，于是会加上信息头，以及包长度</li>
<li>需要协议约定消息体格式</li>
</ul>
</li>
<li>服务发现：HTTP 只要知道网址就可以 DNS 解析出 IP 地址和 80 端口；RPC 需要之间服务</li>
<li>传输的内容：RPC 定制化程度高，序列化协议多，性能稍好</li>
<li><code>gRPC</code> 底层都直接用的 <code>HTTP/2</code></li>
<li>HTTP/2 是 2015 年出来的，有惯性<h2 id="3-TCP-amp-UDP"><a href="#3-TCP-amp-UDP" class="headerlink" title="3 TCP &amp; UDP"></a>3 TCP &amp; UDP</h2><h3 id="3-1-简介与区别"><a href="#3-1-简介与区别" class="headerlink" title="3.1 简介与区别"></a>3.1 简介与区别</h3></li>
<li>TCP 头部<ul>
<li>![[Pasted image 20230904012336.png]]</li>
<li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li>
<li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li>
</ul>
</li>
<li><code>为什么需要 TCP</code>？ IP 层不可靠，需要传输层确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></li>
<li><code>什么是 TCP</code>：<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</li>
<li><p>什么是 TCP 连接？用于保证可靠性和流量控制维护的某些状态信息，这些信息的组合，包括 <code>Socket、序列号和窗口大小</code>称为连接。</p>
<ul>
<li>连接数量限制：文件描述符限制，内存限制，单机最大 TCP 连接数，约为 <code>2</code> 的 <code>48</code> 次方</li>
</ul>
</li>
<li><p><code>UDP 和 TCP 有什么区别呢？分别的应用场景是？</code></p>
<ul>
<li><em>连接</em>：UDP 不需要连接，即刻传输数据</li>
<li><em>服务对象</em>：TCP 是一对一的两点服务；UDP 支持一对一、一对多、多对多的交互通信</li>
<li><em>可靠性</em>：UDP 尽最大努力交付，不保证可靠交付数据</li>
<li><em>拥塞控制、流量控制</em>：网络拥堵也不影响 UDP 发送速率</li>
<li><em>传输方式</em>：TCP 是流式传输，没有边界；UDP 是一个包一个包的发送</li>
<li><em>分片不同</em>：TCP 大于 MSS(536字节) 在传输层分片；UDP 大于 MTU(1500字节)在 IP 层分片</li>
<li><em>使用场景</em>：TCP 用于文件传输，HTTP 等；UDP 用于视频，广播，<code>DNS</code> 等</li>
</ul>
</li>
<li><code>有一方突然断电或者崩溃</code><ul>
<li>两端的 TCP 连接一直没有数据交互，达到了触发 TCP 保活机制的条件，那么内核里的 TCP 协议栈就会发送探测报文。</li>
<li>服务端是<strong>无法感知到的</strong>，在加上服务端没有开启 TCP keepalive，又没有数据交互的情况下，<strong>服务端的 TCP 连接将会一直处于 ESTABLISHED 连接状态</strong>，直到服务端重启进程。</li>
<li>所以，我们可以得知一个点，在没有使用 TCP 保活机制且双方不传输数据的情况下，一方的 TCP 连接处在 ESTABLISHED 状态，并不代表另一方的连接还一定正常。</li>
<li><strong>在 kill 掉进程后，服务端会发送 FIN 报文，与客户端进行四次挥手</strong>。所以，即使没有开启 TCP keepalive，且双方也没有数据交互的情况下，如果其中一方的进程发生了崩溃，这个过程操作系统是可以感知的到的，于是就会发送 FIN 报文给对方，然后与对方进行 TCP 四次挥手。</li>
<li>如果对端程序是正常工作的。当 TCP 保活的探测报文发送给对端, 对端会正常响应，这样 <strong>TCP 保活时间会被重置</strong>，等待下一个 TCP 保活时间的到来。</li>
<li>如果对端主机崩溃，或对端由于其他原因导致报文不可达。当 TCP 保活的探测报文发送给对端后，石沉大海，没有响应，连续几次，达到保活探测次数后，<strong>TCP 会报告该 TCP 连接已经死亡</strong>。</li>
<li><code>在客户端主机宕机后</code>，服务端向客户端发送的报文会得不到任何的响应，在一定时长后，服务端就会触发<strong>超时重传</strong>机制，重传未得到响应的报文。<ul>
<li>服务端重传报文的过程中，客户端主机重启完成后，客户端的内核就会接收重传的报文，然后根据报文的信息传递给对应的进程：</li>
<li>如果客户端主机上<strong>没有</strong>进程监听该 TCP 报文的目标端口号，那么客户端内核就会<em>*回复 RST 报文，重置该 TCP 连接</em>；</li>
<li>如果客户端主机上<strong>有</strong>进程监听该 TCP 报文的目标端口号，由于客户端主机重启后，之前的 TCP 连接的数据结构已经丢失了，客户端内核里协议栈会发现找不到该 TCP 连接的 socket 结构体，于是就会<strong>回复 RST 报文，重置该 TCP 连接</strong>。</li>
<li>所以，只要有一方重启完成后，收到之前 TCP 连接的报文，都会回复 RST 报文，以断开连接。<h3 id="3-2-TCP"><a href="#3-2-TCP" class="headerlink" title="3.2 TCP"></a>3.2 TCP</h3><h4 id="3-2-1-如何保证可靠？"><a href="#3-2-1-如何保证可靠？" class="headerlink" title="3.2.1 如何保证可靠？"></a>3.2.1 如何保证可靠？</h4><h4 id="3-2-2-三次握手"><a href="#3-2-2-三次握手" class="headerlink" title="3.2.2 三次握手"></a>3.2.2 三次握手</h4></li>
</ul>
</li>
</ul>
</li>
<li><em>目的</em>:<ul>
<li><code>防止旧的重复连接初始化造成混乱</code>：网络阻塞重发建立连接请求</li>
<li><code>同步双方的初始序列号</code></li>
<li><code>避免资源浪费</code>：避免建立冗余链接</li>
</ul>
</li>
<li><em>过程</em>：控制位: ACK(确认应答); RST(强制断开); SYN(建立连接); FIN(断开连接)<ul>
<li>建立连接时，客户端随机初始化序列号（<strong>client-isn</strong>），<strong>SYN 标志为1</strong>，表示 SYN 报文，发送到服务器，并进入<strong>SYN-SENT状态</strong>，等待服务器确认；</li>
<li>服务器收到SYN报文，也随机初始化自己的序列号（server-isn），填入序号，然后在<strong>确认应答号字段</strong>填入 <strong>client-isn+1</strong>，然后将<strong>SYN和ACK置为1</strong>，发送给客户端。此时服务器进入<strong>SYN_RECV状态</strong>；</li>
<li>客户端收到服务器报文后，向服务器回应最后一个应答报文，ACK=1，确认应答号填入server-isn+1，发送给服务端，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。<strong>此次可以携带数据</strong></li>
<li><code>netstat -napt</code> 查看连接状态</li>
</ul>
</li>
<li><em>握手丢失</em>：<ul>
<li>第一次：客户端超时重传</li>
<li>第二次：服务端超时重传</li>
<li>第三次：服务端超时重传</li>
</ul>
</li>
<li><em>SYN 攻击</em>：<ul>
<li>Linux 内核会维护两个队列:半连接队列，全连接队列</li>
<li>SYN 攻击就是打满半连接队列</li>
<li>解决：<ul>
<li>调大 netdev_max_backlog，保存数据包的队列</li>
<li>增大 TCP 半连接队列</li>
<li>开启 tcp_syncookies，绕开 SYN 半连接建立连接</li>
<li>减少 SYN+ACK 重传次数，加快处于 SYN_REVC 状态的 TCP 连接断开<h4 id="3-2-3-四次挥手"><a href="#3-2-3-四次挥手" class="headerlink" title="3.2.3 四次挥手"></a>3.2.3 四次挥手</h4></li>
</ul>
</li>
</ul>
</li>
<li><em>目的</em>：客户端发送了FIN连接释放报文后，服务器加入close-wait状态，是为了<code>让服务器发送还未传送完毕的数据</code>，传送完毕之后，服务器会发送FIN连接释放报文;</li>
<li><em>过程</em>：<ul>
<li>客户端发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li>
<li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSE_WAIT</code> 状态。</li>
<li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li>
<li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li>
<li>服务端收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li>
</ul>
</li>
<li><em>TIME_WAIT状态</em>： <ul>
<li>防止历史连接中的数据，被后面相同四元组的连接错误的接收；</li>
<li>保证「被动关闭连接」的一方，能被正确的关闭；确保最后的 ACK 到达。</li>
<li>MSL：<strong>报文最大生存时间</strong>，2MSL是允许报文丢失一次</li>
<li>过多会占用系统资源和端口资源；复用<strong>TIME_WAIT</strong>的 socket；超过 18000 直接重置；让客户端去断开，承受<strong>TIME_WAIT</strong></li>
<li>出现大量TIME_WAIT状态？ 没有用长连接；长连接超时；<h4 id="3-2-4-重传机制"><a href="#3-2-4-重传机制" class="headerlink" title="3.2.4 重传机制"></a>3.2.4 重传机制</h4></li>
</ul>
</li>
<li>TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决</li>
<li><em>超时重传</em>：<ul>
<li>触发场景：数据包丢失，确认应答丢失</li>
<li>超时时间：RTO 略大于 RTT <code>包往返时间</code></li>
<li>每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送</li>
</ul>
</li>
<li><em>快速重传</em>：<code>三次重复的 ACK</code> 触发，但是不知道要重传一个还是所有</li>
<li><em>SACK 方法</em>：<code>选择性确认</code>，将已收到的数据的信息发送给「发送方」</li>
<li><em>D-ACK</em>：Duplicate 使用了 SACK 来告诉「发送方」有哪些数据被<code>重复接收</code>了，可以知道是数据包丢了还是 ACK 包丢了<h4 id="3-2-5-滑动窗口"><a href="#3-2-5-滑动窗口" class="headerlink" title="3.2.5 滑动窗口"></a>3.2.5 滑动窗口</h4></li>
<li><em>窗口</em>：一个缓存空间，是无需等待确认应答，而可以继续发送数据的<code>最大值</code></li>
<li>TCP 报文中的 Windows 字段控制</li>
<li>四部分：发送已确认，发送未确认，未发生但是在处理范围内，未发送范围外<h4 id="3-2-6-流量控制"><a href="#3-2-6-流量控制" class="headerlink" title="3.2.6 流量控制"></a>3.2.6 流量控制</h4></li>
<li>让「发送方」根据「接收方」的<code>实际接收能力</code>控制发送的数据量，让接受方处理的过来</li>
<li><em>窗口关闭</em>：可能导致死锁。收到零窗口通知，就启动<code>持续计时器</code>，如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文。</li>
<li><em>糊涂窗口综合症</em>：接收方太忙，来不及处理，窗口越来越小<ul>
<li>接收方不通告小窗口：小于 MSS 或者 缓存空间/2 ，通告窗口为 0</li>
<li>发送方避免发送小数据：Nagle 算法，除非窗口够大且数据够多并且收到 ack，否则囤积数据<h4 id="3-2-7-拥塞控制"><a href="#3-2-7-拥塞控制" class="headerlink" title="3.2.7 拥塞控制"></a>3.2.7 拥塞控制</h4></li>
</ul>
</li>
<li>避免「发送方」的数据填满整个网络。发送方维护一个叫<code>拥塞窗口</code>（cwnd）的状态变量</li>
<li><em>慢开始与拥塞避免</em>：发送的最初执行<code>慢开始</code>，令cwnd=1，发送方只能发送一个报文段，当收到确认后，将cwnd<code>加倍</code>，设置一个<code>慢开始门限</code> ssthresh，当cwnd&gt;=ssthresh时进入<code>拥塞避免</code>，按照<code>线性</code>增长方式增加，线性增长达到<code>网络拥塞</code>时，则令ssthresh=cwnd/2，然后重新执行慢开始。</li>
<li><em>快重传与快恢复</em>：每次接收到报文段都对最后一个已收到的的有序报文段进行<code>确认</code>。在发送方，如果收到<code>三个重复确认</code>，那么可以知道下一个报文段丢失，此时执行快重传，<code>立即重传下一个报文段</code>。在这种情况下，只是丢失个别报文段，而不是网络拥塞，因此执行<code>快恢复</code>，令ssthresh = cwnd/2，cwnd = ssthresh 。直接进入<code>拥塞避免</code>。<h4 id="3-2-8-拾遗"><a href="#3-2-8-拾遗" class="headerlink" title="3.2.8 拾遗"></a>3.2.8 拾遗</h4></li>
<li>查看 TCP 连接信息的命令？ <code>netstat -napt</code></li>
</ul>
<h2 id="4-IP协议"><a href="#4-IP协议" class="headerlink" title="4 IP协议"></a>4 IP协议</h2><h3 id="4-1-基本认识"><a href="#4-1-基本认识" class="headerlink" title="4.1 基本认识"></a>4.1 基本认识</h3><ul>
<li>处于第三层，也就是<strong>网络层</strong>：实现主机与主机之间的通信</li>
<li>DNS：解析 IP 地址</li>
<li>ARP：获取下一跳的 MAC 地址，通过广播 ARP 请求与 ARP 响应实现</li>
<li>ICMP：<strong>互联网控制报文协议</strong>，确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等<h3 id="4-2-Ping"><a href="#4-2-Ping" class="headerlink" title="4.2 Ping"></a>4.2 Ping</h3></li>
<li><em>工作原理</em>：基于 ICMP 协议工作<ul>
<li><strong>发送ICMP请求</strong>：Ping工具向目标主机发送一个ICMP请求数据包（通常是一个特殊的Echo请求），请求目标主机进行响应。</li>
<li><strong>目标主机响应</strong>：目标主机接收到ICMP请求后，会发送一个ICMP响应数据包（Echo响应）回给Ping工具。</li>
<li><strong>测量延迟</strong>：Ping工具在发送ICMP请求和接收ICMP响应之间测量时间，从而计算出往返时间（Round-Trip Time，RTT）。RTT表示数据从Ping工具发送到目标主机并返回所需的时间，用于衡量网络的延迟。</li>
<li><strong>报告结果</strong>：Ping工具会显示目标主机的IP地址、RTT和其他统计信息，以便用户可以了解网络连接的质量和性能。</li>
</ul>
</li>
<li>ping 127.0.0.1<ul>
<li><strong>127 开头的都属于回环地址</strong>：目标 IP 是回环地址是会选择本地网卡</li>
</ul>
</li>
<li>ping 0.0.0.0<ul>
<li>会失败，因为这是无效的目标地址</li>
</ul>
</li>
</ul>
<h2 id="5-DNS协议"><a href="#5-DNS协议" class="headerlink" title="5 DNS协议"></a>5 DNS协议</h2><ol>
<li>DNS 解析过程，端口号？<ol>
<li>客户端发出 DNS 请求到<code>本地 DNS 服务器</code></li>
<li><code>本地 DNS 服务器</code>如果没有对应的缓存，就去访问<code>根域名服务器</code></li>
<li>根域名返回网址对应的<code>顶级域名服务器</code>地址</li>
<li><code>本地 DNS 服务器</code>请求<code>顶级域名服务器</code>，获得<code>权威 DNS 服务器</code>的地址</li>
<li><code>本地 DNS 服务器</code>请求<code>权威 DNS 服务器</code>，获取 IP 地址</li>
<li>返回给客户端，客户端和目标建立连接</li>
</ol>
</li>
<li>DNS 使用什么传输层协议？<ol>
<li>多数情况下使用 UDP</li>
<li>响应的大小超过UDP数据包的<code>最大限制</code>和<code>进行区域传输</code>（Zone Transfer）时 使用 TCP</li>
</ol>
</li>
</ol>
<h2 id="6-拾遗"><a href="#6-拾遗" class="headerlink" title="6 拾遗"></a>6 拾遗</h2><h3 id="6-1-键入网址到网页显示，期间发生了什么？"><a href="#6-1-键入网址到网页显示，期间发生了什么？" class="headerlink" title="6.1 键入网址到网页显示，期间发生了什么？"></a>6.1 键入网址到网页显示，期间发生了什么？</h3><ol>
<li><code>解析 URL</code>：确定了 Web 服务器和文件名，生成 HTTP 请求</li>
<li><code>查询服务器域名对应的 IP 地址</code>：按照浏览器缓存，操作系统缓存和 hosts 的顺序查询，如果没有就去请求本地 DNS 服务器，进入 <code>DNS 解析流程</code></li>
<li>应用程序（浏览器）通过调用 Socket 库，来委托<code>协议栈</code>工作<ol>
<li>TCP 可靠传输   <code>三次握手</code></li>
<li>IP 远程定位，将数据封装成<strong>网络包</strong>发送给通信对象</li>
<li>MAC 两点传输，在 IP 头部的前面加上 <strong>MAC 头部</strong>，包含接收方和发送方的 MAC 地址等信息。</li>
</ol>
</li>
<li>出口<code>网卡</code>：在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong></li>
<li>交换机：<strong>根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>  <code>MAC 层</code></li>
<li>路由器：根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作</li>
<li>拆包，获取数据内容，交给浏览器渲染页面，然后<code>四次挥手</code>断开连接</li>
</ol>
<h3 id="6-2-TCP-报文头部"><a href="#6-2-TCP-报文头部" class="headerlink" title="6.2 TCP 报文头部"></a>6.2 TCP 报文头部</h3><p>![[Pasted image 20230903203817.png]]</p>
<ul>
<li>首先，<strong>源端口号</strong>和<strong>目标端口</strong>号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</li>
<li>接下来有包的<strong>序</strong>号，这个是为了解决包乱序的问题。</li>
<li>还有应该有的是<strong>确认号</strong>，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决丢包的问题。</li>
<li>接下来还有一些<strong>状态位</strong>。例如 <code>SYN</code> 是发起一个连接，<code>ACK</code> 是回复，<code>RST</code> 是重新连接，<code>FIN</code> 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</li>
<li>还有一个重要的就是<strong>窗口大小</strong>。TCP 要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。</li>
<li>除了做流量控制以外，TCP还会做<strong>拥塞控制</strong>，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。</li>
</ul>
<h3 id="6-3-网络报文图"><a href="#6-3-网络报文图" class="headerlink" title="6.3 网络报文图"></a>6.3 网络报文图</h3><p>![[Pasted image 20230903204154.png]]</p>
<h3 id="6-4-网络攻击"><a href="#6-4-网络攻击" class="headerlink" title="6.4 网络攻击"></a>6.4 网络攻击</h3><h4 id="6-4-1-CSRF攻击"><a href="#6-4-1-CSRF攻击" class="headerlink" title="6.4.1 CSRF攻击"></a>6.4.1 CSRF攻击</h4><ul>
<li>CSRF（Cross-Site Request Forgery，跨站请求伪造）攻击，利用了用户已经在某个网站上进行了<code>身份验证</code>的情况下，对用户在另一个网站上的操作进行<code>伪造请求</code>，以执行未经授权的操作。</li>
<li>防范：<ul>
<li><strong>使用HTTP-only Cookie</strong></li>
<li><strong>使用验证码</strong>：敏感操作输入验证码</li>
<li>限制敏感操作</li>
<li><strong>使用CSRF令牌</strong>：为了确保请求是合法的，服务器可以生成一个唯一的CSRF令牌，并将其嵌入到表单或请求中</li>
<li><strong>定期审查和更新安全策略</strong></li>
<li><strong>同源策略</strong>CORS：浏览器的同源策略要求网页只能从同一来源加载资源。通过使用同源策略，浏览器可以限制对不同网站的跨站请求，从而减少CSRF攻击的可能性。</li>
</ul>
</li>
</ul>
<h4 id="6-4-2-XSS攻击"><a href="#6-4-2-XSS攻击" class="headerlink" title="6.4.2 XSS攻击"></a>6.4.2 XSS攻击</h4><ul>
<li>XSS（Cross-Site Scripting，跨站脚本攻击），将恶意脚本注入到网页中，以便在受害者的浏览器上执行恶意代码。XSS攻击可能导致盗取用户的敏感信息、劫持用户会话、操纵网页内容等恶意行为。</li>
<li>防范：<ul>
<li><strong>输入验证和过滤</strong>：在应用程序接受用户输入时，对输入数据进行验证和过滤。确保只接受预期的输入，并拒绝包含恶意脚本的输入。这可以通过编码规范、白名单过滤和黑名单过滤来实现。</li>
<li><strong>转义输出</strong>：在将用户输入插入到HTML、JavaScript或其他上下文中时，确保对用户输入进行适当的转义。这可以防止浏览器将用户输入解释为可执行的脚本。</li>
<li><strong>CORS策略</strong>：使用CORS（Cross-Origin Resource Sharing，跨源资源共享）策略来限制其他域名的网页访问您的网页，从而减少恶意脚本的机会。</li>
<li><strong>HTTP头设置</strong>：设置HTTP头中的安全标头，如Content Security Policy（CSP）和X-XSS-Protection，以帮助阻止XSS攻击。</li>
</ul>
</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2023/10/09/System-Design/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%BD%92%E7%BA%B3/"></a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2023-10-09
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="实现令牌桶"><a href="#实现令牌桶" class="headerlink" title="实现令牌桶"></a>实现令牌桶</h2><p>“HMSET” 是 Redis 的哈希表命令，用于设置哈希表中的多个字段及其对应的值。<br>通过将获取锁封装到lua脚本中，提交给redis进行eval和evalsha操作来完成lua脚本的执行，由于lua脚本在redis中天然的原子性，我们的需求能够比较好的满足，问题是将业务逻辑封装在lua中，对于开发人员自身的能力和调试存在一定的问题。<br>限流器在每次请求令牌和放入令牌操作中，存在一个协同的问题，即获取令牌操作要尽可能保证原子性，否则无法保证限流器是否能正常工作。在RateLimiter的实现中使用了mutex作为互斥锁来保证操作的原子性，那么在redis中就需要一个类似于事务的机制来保证获取令牌中多重操作的原子性。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">-- 返回码 1:操作成功 0:未配置 -1: 获取失败 -2:修改错误，建议重新初始化 -500:不支持的操作</span><br><span class="line">-- redis hashmap 中存放的内容:</span><br><span class="line">-- last_mill_second 上次放入令牌或者初始化的时间</span><br><span class="line">-- stored_permits 目前令牌桶中的令牌数量</span><br><span class="line">-- max_permits 令牌桶容量</span><br><span class="line">-- interval 放令牌间隔</span><br><span class="line">-- app 一个标志位，表示对于当前key有没有限流存在</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> SUCCESS = 1</span><br><span class="line"><span class="built_in">local</span> NO_LIMIT = 0</span><br><span class="line"><span class="built_in">local</span> ACQUIRE_FAIL = -1</span><br><span class="line"><span class="built_in">local</span> MODIFY_ERROR = -2</span><br><span class="line"><span class="built_in">local</span> UNSUPPORT_METHOD = -500</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> ratelimit_info = redis.pcall(<span class="string">&quot;HMGET&quot;</span>,KEYS[1], <span class="string">&quot;last_mill_second&quot;</span>, <span class="string">&quot;stored_permits&quot;</span>, <span class="string">&quot;max_permits&quot;</span>, <span class="string">&quot;interval&quot;</span>, <span class="string">&quot;app&quot;</span>)</span><br><span class="line"><span class="built_in">local</span> last_mill_second = ratelimit_info[1]</span><br><span class="line"><span class="built_in">local</span> stored_permits = tonumber(ratelimit_info[2])</span><br><span class="line"><span class="built_in">local</span> max_permits = tonumber(ratelimit_info[3])</span><br><span class="line"><span class="built_in">local</span> interval = tonumber(ratelimit_info[4])</span><br><span class="line"><span class="built_in">local</span> app = ratelimit_info[5]</span><br><span class="line"></span><br><span class="line"><span class="built_in">local</span> method = ARGV[1]</span><br><span class="line"></span><br><span class="line">--获取当前毫秒</span><br><span class="line">--考虑主从策略和脚本回放机制，这个time由客户端获取传入</span><br><span class="line">--<span class="built_in">local</span> curr_time_arr = redis.call(<span class="string">&#x27;TIME&#x27;</span>)</span><br><span class="line">--<span class="built_in">local</span> curr_timestamp = curr_time_arr[1] * 1000 + curr_time_arr[2]/1000</span><br><span class="line"><span class="built_in">local</span> curr_timestamp = tonumber(ARGV[2])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 当前方法为初始化</span><br><span class="line"><span class="keyword">if</span> method == <span class="string">&#x27;init&#x27;</span> <span class="keyword">then</span></span><br><span class="line">    --如果app不为null说明已经初始化过，不要重复初始化</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>(app) ~=<span class="string">&#x27;boolean&#x27;</span> and app ~=nil) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> SUCCESS</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    redis.pcall(<span class="string">&quot;HMSET&quot;</span>, KEYS[1],</span><br><span class="line">        <span class="string">&quot;last_mill_second&quot;</span>, curr_timestamp,</span><br><span class="line">        <span class="string">&quot;stored_permits&quot;</span>, ARGV[3],</span><br><span class="line">        <span class="string">&quot;max_permits&quot;</span>, ARGV[4],</span><br><span class="line">        <span class="string">&quot;interval&quot;</span>, ARGV[5],</span><br><span class="line">        <span class="string">&quot;app&quot;</span>, ARGV[6])</span><br><span class="line">    --始终返回成功</span><br><span class="line">    <span class="built_in">return</span> SUCCESS</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 当前方法为修改配置</span><br><span class="line"><span class="keyword">if</span> method == <span class="string">&quot;modify&quot;</span> <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>(app) ==<span class="string">&#x27;boolean&#x27;</span> or app ==nil) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> MODIFY_ERROR</span><br><span class="line">    end</span><br><span class="line">    --只能修改max_permits和interval</span><br><span class="line">    redis.pcall(<span class="string">&quot;HMSET&quot;</span>, KEYS[1],</span><br><span class="line">        <span class="string">&quot;max_permits&quot;</span>, ARGV[3],</span><br><span class="line">        <span class="string">&quot;interval&quot;</span>, ARGV[4])</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> SUCCESS</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 当前方法为删除</span><br><span class="line"><span class="keyword">if</span> method == <span class="string">&quot;delete&quot;</span> <span class="keyword">then</span></span><br><span class="line">    --已经清除完毕</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>(app) ==<span class="string">&#x27;boolean&#x27;</span> or app ==nil) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> SUCCESS</span><br><span class="line">    end</span><br><span class="line">    redis.pcall(<span class="string">&quot;DEL&quot;</span>, KEYS[1])</span><br><span class="line">    <span class="built_in">return</span> SUCCESS</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- 尝试获取permits</span><br><span class="line"><span class="keyword">if</span> method == <span class="string">&quot;acquire&quot;</span> <span class="keyword">then</span></span><br><span class="line">    -- 如果app为null说明没有对这个进行任何配置，返回0代表不限流</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">type</span>(app) ==<span class="string">&#x27;boolean&#x27;</span> or app ==nil) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">return</span> NO_LIMIT</span><br><span class="line">    end</span><br><span class="line">    --需要获取令牌数量</span><br><span class="line">    <span class="built_in">local</span> acquire_permits = tonumber(ARGV[3])</span><br><span class="line">    --计算上一次放令牌到现在的时间间隔中，一共应该放入多少令牌</span><br><span class="line">    <span class="built_in">local</span> reserve_permits = math.max(0, math.floor((curr_timestamp - last_mill_second) / interval))</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">local</span> new_permits = math.min(max_permits, stored_permits + reserve_permits)</span><br><span class="line">    <span class="built_in">local</span> result = ACQUIRE_FAIL</span><br><span class="line">    --如果桶中令牌数量够则放行</span><br><span class="line">    <span class="keyword">if</span> new_permits &gt;= acquire_permits <span class="keyword">then</span></span><br><span class="line">        result = SUCCESS</span><br><span class="line">        new_permits = new_permits - acquire_permits</span><br><span class="line">    end</span><br><span class="line">    --更新当前桶中的令牌数量 </span><br><span class="line">    redis.pcall(<span class="string">&quot;HSET&quot;</span>, KEYS[1], <span class="string">&quot;stored_permits&quot;</span>, new_permits)</span><br><span class="line">    --如果这次有放入令牌，则更新时间</span><br><span class="line">    <span class="keyword">if</span> reserve_permits &gt; 0 <span class="keyword">then</span></span><br><span class="line">        redis.pcall(<span class="string">&quot;HSET&quot;</span>, KEYS[1], <span class="string">&quot;last_mill_second&quot;</span>, curr_timestamp)</span><br><span class="line">    end</span><br><span class="line">    <span class="built_in">return</span> result</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="built_in">return</span> UNSUPPORT_METHOD</span><br></pre></td></tr></table></figure>
<h2 id="实现-set"><a href="#实现-set" class="headerlink" title="实现 set"></a>实现 set</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Set 是一个使用 map 实现的集合</span></span><br><span class="line"><span class="keyword">type</span> Set <span class="keyword">struct</span> &#123;</span><br><span class="line">    m <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NewSet 创建一个新的空集合</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewSet</span><span class="params">()</span></span> *Set &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;Set&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;)&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add 向集合中添加一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Add(value <span class="type">string</span>) &#123;</span><br><span class="line">    s.m[value] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove 从集合中删除一个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Remove(value <span class="type">string</span>) &#123;</span><br><span class="line">    <span class="built_in">delete</span>(s.m, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Contains 检查集合中是否包含某个元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Contains(value <span class="type">string</span>) <span class="type">bool</span> &#123;</span><br><span class="line">    _, ok := s.m[value]</span><br><span class="line">    <span class="keyword">return</span> ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Len 返回集合的长度</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(s.m)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear 清空集合</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Clear() &#123;</span><br><span class="line">    s.m = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Values 返回集合中的所有元素</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Set)</span></span> Values() []<span class="type">string</span> &#123;</span><br><span class="line">    values := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>, <span class="built_in">len</span>(s.m))</span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> s.m &#123;</span><br><span class="line">        values = <span class="built_in">append</span>(values, k)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> values</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    set := NewSet()</span><br><span class="line">    set.Add(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    set.Add(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">    set.Add(<span class="string">&quot;c&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;Set contains &#x27;a&#x27;:&quot;</span>, set.Contains(<span class="string">&quot;a&quot;</span>)) <span class="comment">// true</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;Set contains &#x27;d&#x27;:&quot;</span>, set.Contains(<span class="string">&quot;d&quot;</span>)) <span class="comment">// false</span></span><br><span class="line">    </span><br><span class="line">    set.Remove(<span class="string">&quot;a&quot;</span>)</span><br><span class="line">    fmt.Println(<span class="string">&quot;Set contains &#x27;a&#x27;:&quot;</span>, set.Contains(<span class="string">&quot;a&quot;</span>)) <span class="comment">// false</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;Set length:&quot;</span>, set.Len()) <span class="comment">// 2</span></span><br><span class="line">    </span><br><span class="line">    fmt.Println(<span class="string">&quot;Set values:&quot;</span>, set.Values()) <span class="comment">// [b c]</span></span><br><span class="line">    </span><br><span class="line">    set.Clear()</span><br><span class="line">    fmt.Println(<span class="string">&quot;Set length after clear:&quot;</span>, set.Len()) <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="实现协程交替打印"><a href="#实现协程交替打印" class="headerlink" title="实现协程交替打印"></a>实现协程交替打印</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> countNum = <span class="number">100</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//3个函数分别打印cat、dog、fish，要求每个函数都要起一个goroutine，按照cat、dog、fish顺序打印在屏幕上10次</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"> </span><br><span class="line">    dogCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(dogCh)</span><br><span class="line">    catCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(catCh)</span><br><span class="line">    fishCh := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(fishCh)</span><br><span class="line"> </span><br><span class="line">    wg.Add(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">go</span> catPrint(&amp;wg, &amp;catCh, &amp;dogCh)</span><br><span class="line">    <span class="keyword">go</span> dogPrint(&amp;wg, &amp;dogCh, &amp;fishCh)</span><br><span class="line">    <span class="keyword">go</span> fishPrint(&amp;wg, &amp;fishCh, &amp;catCh)</span><br><span class="line"> </span><br><span class="line">    catCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    wg.Wait()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">catPrint</span><span class="params">(wg *sync.WaitGroup, catCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, dogCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> count &gt;= countNum &#123;</span><br><span class="line">            wg.Done()</span><br><span class="line">            <span class="comment">//fmt.Println(&quot;cat quit&quot;)</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        &lt;-*catCh</span><br><span class="line">        fmt.Println(<span class="string">&quot;cat&quot;</span>, count+<span class="number">1</span>)</span><br><span class="line">        count++</span><br><span class="line">        *dogCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dogPrint</span><span class="params">(wg *sync.WaitGroup, dogCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, fishCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> count &gt;= countNum &#123;</span><br><span class="line">            wg.Done()</span><br><span class="line">            <span class="comment">//fmt.Println(&quot;dog quit&quot;)</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        &lt;-*dogCh</span><br><span class="line">        fmt.Println(<span class="string">&quot;dog&quot;</span>)</span><br><span class="line">        count++</span><br><span class="line">        *fishCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fishPrint</span><span class="params">(wg *sync.WaitGroup, dogCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, catCh *<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    count := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> count &gt;= countNum &#123;</span><br><span class="line">            wg.Done()</span><br><span class="line">            <span class="comment">//fmt.Println(&quot;fish quit&quot;)</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        &lt;-*dogCh</span><br><span class="line">        fmt.Println(<span class="string">&quot;fish&quot;</span>)</span><br><span class="line">        count++</span><br><span class="line">        *catCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2023/10/09/DevOps/HPA/"></a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2023-10-09
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="0-1-扩容场景"><a href="#0-1-扩容场景" class="headerlink" title="0.1 扩容场景"></a>0.1 扩容场景</h3><ol>
<li>对于有流量突发的关键业务，在需要的时候应该快速扩容 (即便可能不需要，以防万一)，但缩容要慢 (防止另一个流量高峰)。</li>
<li>处理关键数据的应用，数据量飙升时它们应该尽快扩容以减少数据处理时间，数据量降低时应尽快缩小规模以降低成本，数据量的短暂抖动导致不必要的频繁扩缩是可以接受的。</li>
<li>处理常规数据/网络流量的业务，不是很重要，它们可能会以一般的方式扩大和缩小规模，以减少抖动。<h3 id="0-2-扩缩容策略"><a href="#0-2-扩缩容策略" class="headerlink" title="0.2 扩缩容策略"></a>0.2 扩缩容策略</h3></li>
</ol>
<ul>
<li>HPA Spec 下新增了一个 <code>behavior</code> 字段，下面有 <code>scaleUp</code> 和 <code>scaleDown</code> 两个字段分别控制扩容和缩容的行为</li>
<li><code>scaleUp</code> 和 <code>scaleDown</code> 都可以配置1个或多个策略，最终扩缩时用哪个策略，取决于 <code>selectPolicy</code>。</li>
<li><code>selectPolicy</code> 默认是 <code>Max</code>，即扩缩时，评估多个策略算出来的结果，最终选取扩缩 Pod 数量最多的那个策略的结果。</li>
<li><code>stabilizationWindowSeconds</code> 是稳定窗口时长，即需要指标高于或低于阈值，并持续这个窗口的时长才会真正执行扩缩，以防止抖动导致频繁扩缩容。扩容时，稳定窗口默认为0，即立即扩容；缩容时，稳定窗口默认为5分钟。</li>
<li><p><code>policies</code> 中定义扩容或缩容策略，<code>type</code> 的值可以是 <code>Pods</code> 或 <code>Percent</code>，表示每 <code>periodSeconds</code> 时间范围内，允许扩缩容的最大副本数或比例。</p>
</li>
<li><p>快速扩容，缓慢缩容，避免下一个流量高峰</p>
</li>
<li>缓慢扩容</li>
<li>禁止自动缩容</li>
<li>延长缩容时间窗口</li>
<li>延长扩容时间窗口<h3 id="0-3-指标值的计算方式"><a href="#0-3-指标值的计算方式" class="headerlink" title="0.3 指标值的计算方式"></a>0.3 指标值的计算方式</h3>每个 <strong>Pod 的指标是其中所有容器指标之和</strong>，如果计算百分比，就再除以 Pod 的 requests.<br>HPA 默认使用 Pod 的当前指标进行计算，以 CPU 使用率为例，其计算公式为：<br>`「Pod 的 CPU 使用率」= 100% * 「所有 Container 的 CPU 用量之和」/「所有 Container 的 CPU requests 之和」<h3 id="0-4-HPA-的扩缩容算法"><a href="#0-4-HPA-的扩缩容算法" class="headerlink" title="0.4 HPA 的扩缩容算法"></a>0.4 HPA 的扩缩容算法</h3></li>
</ul>
<ol>
<li>HPA 的「目标指标」可以使用两种形式：绝对度量指标和资源利用率。<ul>
<li>绝对度量指标：比如 CPU，就是指 CPU 的使用量</li>
<li>资源利用率（资源使用量/资源请求 * 100%）：在 Pod 设置了资源请求时，可以使用资源利用率进行 Pod 伸缩</li>
</ul>
</li>
<li>HPA 的「当前指标」是一段时间内所有 Pods 的平均值，不是峰值</li>
<li>只要「当前指标」超过了目标指标，就一定会发生扩容。</li>
<li><code>当前指标 / 目标指标</code>要小到一定的程度，才会触发缩容。<ol>
<li>比如双副本的情况下，上述比值要小于等于 1/2，才会缩容到单副本。</li>
<li>三副本的情况下，上述比值的临界点是 2/3。</li>
<li>五副本时临界值是 4/5，100副本时临界值是 99/100，依此类推。</li>
<li>如果 <code>当前指标 / 目标指标</code> 从 1 降到 0.5，副本的数量将会减半。（虽然说副本数越多，发生这么大变化的可能性就越小。）</li>
</ol>
</li>
<li><code>当前副本数 / 目标指标</code>的值越大，「当前指标」的波动对「期望副本数」的影响就越大。<br><strong>为了防止扩缩容过于敏感，HPA 有几个相关参数：</strong></li>
<li>Hardcoded 参数<ol>
<li>HPA Loop 延时：默认 15 秒，每 15 秒钟进行一次 HPA 扫描。</li>
<li>缩容冷却时间：默认 5 分钟。</li>
</ol>
</li>
<li>对于 K8s 1.18+，HPA 通过 <code>spec.behavior</code> 提供了多种控制扩缩容行为的参数<h3 id="0-5-HPA-的期望值设成多少合适？如何兼顾资源利用率与服务稳定性？"><a href="#0-5-HPA-的期望值设成多少合适？如何兼顾资源利用率与服务稳定性？" class="headerlink" title="0.5 HPA 的期望值设成多少合适？如何兼顾资源利用率与服务稳定性？"></a>0.5 HPA 的期望值设成多少合适？如何兼顾资源利用率与服务稳定性？</h3></li>
</ol>
<ul>
<li>核心服务<ul>
<li>requests/limits 值: 建议设成相等的，保证<a target="_blank" rel="noopener" href="https://kubernetes.io/docs/tasks/configure-pod-container/quality-service-pod/">服务质量等级</a>为 Guaranteed<ul>
<li>需要注意 CPU 跟 Memory 的 limits 限制策略是不同的，CPU 是真正地限制了上限，而 Memory 是用超了就干掉容器（OOMKilled）</li>
<li>k8s 一直使用 cgroups v1 (<code>cpu_shares</code>/<code>memory.limit_in_bytes</code>)来限制 cpu/memory，但是对于 <code>Guaranteed</code> 的 Pods 而言，内存并不能完全预留，资源竞争总是有可能发生的。1.22 有 alpha 特性改用 cgroups v2，可以关注下。</li>
</ul>
</li>
<li>HPA: 一般来说，期望值设为 60% 到 70% 可能是比较合适的，最小副本数建议设为 2 - 5. （仅供参考）</li>
<li>PodDisruptionBudget: 建议按服务的健壮性与 HPA 期望值，来设置 PDB，后面会详细介绍，这里就先略过了</li>
</ul>
</li>
<li>非核心服务<ul>
<li>requests/limits 值: 建议 requests 设为 limits 的 0.6 - 0.9 倍（仅供参考），对应的服务质量等级为 Burstable<ul>
<li>也就是超卖了资源，这样做主要的考量点是，很多非核心服务负载都很低，根本跑不到 limits 这么高，降低 requests 可以提高集群资源利用率，也不会损害服务稳定性。</li>
</ul>
</li>
<li>HPA: 因为 requests 降低了，而 HPA 是以 requests 为 100% 计算使用率的，我们可以提高 HPA 的期望值（如果使用百分比为期望值的话），比如 80% ~ 90%，最小副本数建议设为 1 - 3. （仅供参考）</li>
<li>PodDisruptionBudget: 非核心服务嘛，保证最少副本数为 1 就行了。</li>
</ul>
</li>
</ul>
<h3 id="0-6-HPA-扩缩容过于敏感，导致-Pod-数量震荡"><a href="#0-6-HPA-扩缩容过于敏感，导致-Pod-数量震荡" class="headerlink" title="0.6 HPA 扩缩容过于敏感，导致 Pod 数量震荡"></a>0.6 HPA 扩缩容过于敏感，导致 Pod 数量震荡</h3><p>通常来讲，K8s 上绝大部分负载都应该选择使用 CPU 进行扩缩容。因为 CPU 通常能很好的反映服务的负载情况<br>但是有些服务会存在其他影响 CPU 使用率的因素，导致使用 CPU 扩缩容变得不那么可靠，比如：</p>
<ul>
<li>有些 Java 服务堆内存设得很大，GC pause 也设得比较长，因此内存 GC 会造成 CPU 间歇性飙升，CPU 监控会有大量的尖峰。</li>
<li>有些服务有定时任务，定时任务一运行 CPU 就涨，但是这跟服务的 QPS 是无关的</li>
<li>有些服务可能一运行 CPU 就会立即处于一个高位状态，它可能希望使用别的业务侧指标来进行扩容，而不是 CPU.<br>因为上述问题存在，使用 CPU 扩缩容，就可能会造成服务频繁的扩容然后缩容，或者无限扩容。 而有些服务（如我们的「推荐服务」），对「扩容」和「缩容」都是比较敏感的，每次扩缩都会造成服务可用率抖动。<br>对这类服务而言，HPA 有这几种调整策略：</li>
<li>选择使用 <strong>QPS</strong> 等相对比较平滑，没有 GC 这类干扰的指标来进行扩缩容，这需要借助 KEDA 等社区组件。</li>
<li>对 kubernetes 1.18+，可以直接使用 HPA 的 <code>behavior.scaleDown</code> 和 <code>behavior.scaleUp</code> 两个参数，控制每次扩缩容的最多 pod 数量或者比例。</li>
</ul>
<h3 id="0-7-配置实例"><a href="#0-7-配置实例" class="headerlink" title="0.7 配置实例"></a>0.7 配置实例</h3><p>![[Pasted image 20230918234033.png]]</p>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2023/10/09/System-Design/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"></a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2023-10-09
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    
    
    
  </div>

  

  

</article>
  
    
  <nav class="pagination">  
      
      <a class="prev" href="/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text">Prev</span>  
      </a>  
      
      
      <a class="next" href="/page/3/">  
        <span class="next-text">Next</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  
</section>
        </div>
      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2019 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">draco</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
  







<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>



<script type="text/javascript" src="/lib/slideout/slideout.js"></script>



<script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>