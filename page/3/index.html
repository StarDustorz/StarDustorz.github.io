<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->


<!-- Website keywords -->




<!-- Website rss -->

<link rel="alternate" href="/atom.xml" title="Draco's Blog" type="application/atom+xml">


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://stardustorz.github.io/page/3/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":false};
</script>
  
  <title>Draco&#39;s Blog</title>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Draco&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        Home              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        Archives              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        Tags              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        Categories              </li>
    </a>
    
    <a href="/links/">
      <li class="mobile-menu-item">
        
        
        Links              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        About              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">Draco's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              Home  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              Archives  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              Tags  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              Categories  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/links/">  
              
              
              Links  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              About  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <section id="posts" class="posts">
  
  
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/07/25/Algorithm/Tree/">[Algorithm] Tree</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-07-25
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <span id="more"></span>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前序位置  进入节点的时候 </span></span><br><span class="line">    traverse(root.left);</span><br><span class="line">    <span class="comment">// 中序位置	左子树遍历完成</span></span><br><span class="line">    traverse(root.right);</span><br><span class="line">    <span class="comment">// 后序位置  离开节点的时候</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历一遍二叉树得出答案  </span></span><br><span class="line"><span class="comment">// 通过分解问题计算出答案 定义递归函数完成</span></span><br><span class="line"><span class="comment">// 只有后序位置才能通过返回值获取子树的信息。</span></span><br><span class="line"><span class="comment">// 二叉树的所有问题，就是让你在前中后序位置注入巧妙的代码逻辑，</span></span><br><span class="line"><span class="comment">// 去达到自己的目的，你只需要单独思考每一个节点应该做什么</span></span><br></pre></td></tr></table></figure>
<h2 id="1-遍历"><a href="#1-遍历" class="headerlink" title="1 遍历"></a>1 遍历</h2><h3 id="1-1-前序遍历"><a href="#1-1-前序遍历" class="headerlink" title="1.1 前序遍历"></a>1.1 前序遍历</h3><p>思路：根节点-&gt;左子树-&gt;右子树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            preorderTraversal(root.left);</span><br><span class="line">            preorderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归，用栈实现，先访问父节点，先压右再压左</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            res.add(node.val);</span><br><span class="line">            <span class="comment">// 倒过来，因为栈后面压入先出</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) stack.push(node.right);</span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) stack.push(node.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-中序遍历"><a href="#1-2-中序遍历" class="headerlink" title="1.2 中序遍历"></a>1.2 中序遍历</h3><p>思路：左子树-&gt;根节点-&gt;右子树</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            inorderTraversal(root.left);</span><br><span class="line">            res.add(root.val);</span><br><span class="line">            inorderTraversal(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非递归 先压左节点，然后从最后一个左节点开始访问，如果有右节点则访问</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//中序遍历结束的条件是栈空，并且树中全部节点都已经被压入栈</span></span><br><span class="line">        <span class="keyword">while</span>(stack.size() &gt; <span class="number">0</span> || root != <span class="literal">null</span>)&#123;	</span><br><span class="line">            <span class="comment">//从root开始，将root的左节点全部压入</span></span><br><span class="line">            <span class="comment">//这里是为了剔除右节点为空的情况</span></span><br><span class="line">            <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;			</span><br><span class="line">                stack.push(root);</span><br><span class="line">                root = root.left;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;						<span class="comment">//压入后，从最左开始访问</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                res.add(node.val);</span><br><span class="line">                root = node.right;		<span class="comment">//如果有右节点，那么将在下一个循环中被压入栈</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-3-后序遍历"><a href="#1-3-后序遍历" class="headerlink" title="1.3 后序遍历"></a>1.3 后序遍历</h3><p>思路：左子树-&gt;右子树-&gt;根节点</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归的比较简单</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//非递归，可以将前序修改成根右左，倒序就是后序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        stack.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result.add(node.val); 		<span class="comment">//根节点</span></span><br><span class="line">            <span class="keyword">if</span>(node.left != <span class="literal">null</span>) stack.push(node.left);	<span class="comment">//先压左再压右</span></span><br><span class="line">            <span class="keyword">if</span>(node.right != <span class="literal">null</span>) stack.push(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.reverse(result);	<span class="comment">//倒序结果</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-987-二叉树的垂序遍历"><a href="#1-4-987-二叉树的垂序遍历" class="headerlink" title="1.4 987. 二叉树的垂序遍历"></a>1.4 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/vertical-order-traversal-of-a-binary-tree/">987. 二叉树的垂序遍历</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录每个节点和对应的坐标 (row, col)</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Triple</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> row, col;</span><br><span class="line">        <span class="keyword">public</span> TreeNode node;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Triple</span><span class="params">(TreeNode node, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.node = node;</span><br><span class="line">            <span class="built_in">this</span>.row = row;</span><br><span class="line">            <span class="built_in">this</span>.col = col;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">verticalTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历二叉树，并且为所有节点生成对应的坐标</span></span><br><span class="line">        traverse(root, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 根据题意，根据坐标值对所有节点进行排序：</span></span><br><span class="line">        <span class="comment">// 按照 col 从小到大排序，col 相同的话按 row 从小到大排序，</span></span><br><span class="line">        <span class="comment">// 如果 col 和 row 都相同，按照 node.val 从小到大排序。</span></span><br><span class="line">        Collections.sort(nodes, (Triple a, Triple b) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a.col == b.col &amp;&amp; a.row == b.row) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.node.val - b.node.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a.col == b.col) &#123;</span><br><span class="line">                <span class="keyword">return</span> a.row - b.row;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> a.col - b.col;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 将排好序的节点组装成题目要求的返回格式</span></span><br><span class="line">        LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 记录上一列编号，初始化一个特殊值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">preCol</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nodes.size(); i++) &#123;</span><br><span class="line">            <span class="type">Triple</span> <span class="variable">cur</span> <span class="operator">=</span> nodes.get(i);</span><br><span class="line">            <span class="keyword">if</span> (cur.col != preCol) &#123;</span><br><span class="line">                <span class="comment">// 开始记录新的一列</span></span><br><span class="line">                res.addLast(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;());</span><br><span class="line">                preCol = cur.col;</span><br><span class="line">            &#125;</span><br><span class="line">            res.getLast().add(cur.node.val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Triple&gt; nodes = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 二叉树遍历函数，记录所有节点对应的坐标</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> row, <span class="type">int</span> col)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录坐标</span></span><br><span class="line">        nodes.add(<span class="keyword">new</span> <span class="title class_">Triple</span>(root, row, col));</span><br><span class="line">        <span class="comment">// 二叉树遍历框架</span></span><br><span class="line">        traverse(root.left, row + <span class="number">1</span>, col - <span class="number">1</span>);</span><br><span class="line">        traverse(root.right, row + <span class="number">1</span>, col + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-5-236-二叉树的最近公共祖先"><a href="#1-5-236-二叉树的最近公共祖先" class="headerlink" title="1.5 236. 二叉树的最近公共祖先"></a>1.5 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果root是最近的公共祖先，那么有三种情况：</span></span><br><span class="line"><span class="comment">//p和q在root的左右子树中；p=root，q在p的子树中；q=root，p在q的子树中</span></span><br><span class="line"><span class="comment">//递归对二叉树进行后序遍历：（左右中）遇到p或q返回</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="comment">//中止条件：越过了叶子节点或者找到了p或q</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="comment">//如果都为空，都没有，返回</span></span><br><span class="line">        <span class="comment">//都不空，返回root</span></span><br><span class="line">        <span class="comment">//有一个空，另一个就是最近公共祖先</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span>) <span class="keyword">return</span> right;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">null</span>) <span class="keyword">return</span> left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-993-二叉树的堂兄弟节点"><a href="#1-6-993-二叉树的堂兄弟节点" class="headerlink" title="1.6 993. 二叉树的堂兄弟节点"></a>1.6 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/cousins-in-binary-tree/">993. 二叉树的堂兄弟节点</a></h3><p>如果二叉树的两个节点深度相同，但 父节点不同 ，则它们是一对堂兄弟节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">parentX</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">parentY</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">depthX</span> <span class="operator">=</span> <span class="number">0</span>, depthY = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCousins</span><span class="params">(TreeNode root, <span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.x = x;</span><br><span class="line">        <span class="built_in">this</span>.y = y;</span><br><span class="line">        traverse(root, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (depthX == depthY &amp;&amp; parentX != parentY) &#123;</span><br><span class="line">            <span class="comment">// 判断 x，y 是否是表兄弟节点</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> depth, TreeNode parent)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == x) &#123;</span><br><span class="line">            <span class="comment">// 找到 x，记录它的深度和父节点</span></span><br><span class="line">            parentX = parent;</span><br><span class="line">            depthX = depth;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == y) &#123;</span><br><span class="line">            <span class="comment">// 找到 y，记录它的深度和父节点</span></span><br><span class="line">            parentY = parent;</span><br><span class="line">            depthY = depth;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root.left, depth + <span class="number">1</span>, root);</span><br><span class="line">        traverse(root.right, depth + <span class="number">1</span>, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-7-二叉树的下一个节点"><a href="#1-7-二叉树的下一个节点" class="headerlink" title="1.7 二叉树的下一个节点"></a>1.7 二叉树的下一个节点</h3><p>给定二叉树其中的一个结点，请找出其中序遍历顺序的下一个结点并且返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;TreeLinkNode&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeLinkNode <span class="title function_">GetNext</span><span class="params">(TreeLinkNode pNode)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(pNode == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeLinkNode</span> <span class="variable">root</span> <span class="operator">=</span> pNode;</span><br><span class="line">        <span class="comment">// 找到父节点</span></span><br><span class="line">        <span class="keyword">while</span>(root.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            root = root.next;</span><br><span class="line">        &#125;</span><br><span class="line">        inorder(root);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; list.size()-<span class="number">1</span>; i ++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(list.get(i) == pNode) <span class="keyword">return</span> list.get(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeLinkNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inorder(root.left);</span><br><span class="line">        list.add(root);</span><br><span class="line">        inorder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有右子树，则找右子树的最左节点</span></span><br><span class="line"><span class="comment">//没右子树</span></span><br><span class="line"><span class="comment">//若x是父节点的左孩子。则x的父节点就是x的下一个节点。</span></span><br><span class="line"><span class="comment">//若x是父节点的右孩子。则沿着父节点向上，直到找到一个节点的父节点的左孩子是该节点，</span></span><br><span class="line"><span class="comment">//则该节点的父节点就是x的下一个节点</span></span><br></pre></td></tr></table></figure>
<h3 id="1-8-剑指-Offer-07-重建二叉树"><a href="#1-8-剑指-Offer-07-重建二叉树" class="headerlink" title="1.8 剑指 Offer 07. 重建二叉树"></a>1.8 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">剑指 Offer 07. 重建二叉树</a></h3><p>输入某二叉树的前序遍历和中序遍历的结果，请构建该二叉树并返回其根节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序第一个是根节点，而在中序的该值的左边是左子树，右边是右子树</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.length == <span class="number">0</span> || inorder.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(preorder[<span class="number">0</span>] == inorder[i])&#123;</span><br><span class="line">                root.left = buildTree(Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>),Arrays.copyOfRange(inorder,<span class="number">0</span>,i));</span><br><span class="line">                root.right = buildTree(Arrays.copyOfRange(preorder,i+<span class="number">1</span>,preorder.length),Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Arrays.copyOfRange(T[ ] original,int from,int to)将一个原始的数组original，从下标from开始复制，复制到上标to，生成一个新的数组。注意这里包括下标from，不包括上标to。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] preorder;</span><br><span class="line">    <span class="comment">//可以用来查找根节点在中序中的对应位置</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++)</span><br><span class="line">            dic.put(inorder[i], i);</span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//root是根节点在前序中的位置，left，right是中序遍历中的边界</span></span><br><span class="line">    TreeNode <span class="title function_">recur</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;                          <span class="comment">// 递归终止</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[root]);          <span class="comment">// 建立根节点</span></span><br><span class="line">        <span class="comment">//找到左右子树的划分点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dic.get(preorder[root]);                       <span class="comment">// 划分根节点、左子树、右子树</span></span><br><span class="line">        <span class="comment">//左子树的根节点，左边界不变</span></span><br><span class="line">        node.left = recur(root + <span class="number">1</span>, left, i - <span class="number">1</span>);              <span class="comment">// 开启左子树递归</span></span><br><span class="line">        <span class="comment">//右子树的根节点就是根节点加上左子树长度加一</span></span><br><span class="line">        node.right = recur(root + i - left + <span class="number">1</span>, i + <span class="number">1</span>, right); <span class="comment">// 开启右子树递归</span></span><br><span class="line">        <span class="keyword">return</span> node;                                           <span class="comment">// 回溯返回根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-9-106-从中序与后序遍历序列构造二叉树"><a href="#1-9-106-从中序与后序遍历序列构造二叉树" class="headerlink" title="1.9 106. 从中序与后序遍历序列构造二叉树"></a>1.9 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">106. 从中序与后序遍历序列构造二叉树</a></h3><p>给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 存储 inorder 中值到索引的映射</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; valToIndex = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            valToIndex.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(inorder, <span class="number">0</span>, inorder.length - <span class="number">1</span>,</span><br><span class="line">                    postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">       定义：</span></span><br><span class="line"><span class="comment">       中序遍历数组为 inorder[inStart..inEnd]，</span></span><br><span class="line"><span class="comment">       后序遍历数组为 postorder[postStart..postEnd]，</span></span><br><span class="line"><span class="comment">       构造这个二叉树并返回该二叉树的根节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> inStart, <span class="type">int</span> inEnd,</span></span><br><span class="line"><span class="params">                <span class="type">int</span>[] postorder, <span class="type">int</span> postStart, <span class="type">int</span> postEnd)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (inStart &gt; inEnd) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// root 节点对应的值就是后序遍历数组的最后一个元素</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> postorder[postEnd];</span><br><span class="line">        <span class="comment">// rootVal 在中序遍历数组中的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> valToIndex.get(rootVal);</span><br><span class="line">        <span class="comment">// 左子树的节点个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> index - inStart;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">// 递归构造左右子树</span></span><br><span class="line">        root.left = build(inorder, inStart, index - <span class="number">1</span>,</span><br><span class="line">                         postorder, postStart, postStart + leftSize - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        root.right = build(inorder, index + <span class="number">1</span>, inEnd,</span><br><span class="line">                          postorder, postStart + leftSize, postEnd - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-10-257-二叉树的所有路径"><a href="#1-10-257-二叉树的所有路径" class="headerlink" title="1.10 257. 二叉树的所有路径"></a>1.10 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-paths/">257. 二叉树的所有路径</a></h3><p>给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">binaryTreePaths</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        helper(root,<span class="string">&quot;&quot;</span>,list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">helper</span><span class="params">(TreeNode root,String path,List&lt;String&gt; list)</span>&#123;  <span class="comment">//前序遍历，根-&gt;左-&gt;右</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)   <span class="keyword">return</span>;</span><br><span class="line">        path += Integer.toString(root.val);</span><br><span class="line">        <span class="keyword">if</span>((root.left == <span class="literal">null</span>) &amp;&amp; (root.right == <span class="literal">null</span>))&#123;  <span class="comment">//如果到底了，复制path，加入答案</span></span><br><span class="line">            list.add(path.toString());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            path += <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">            helper(root.left,path,list);</span><br><span class="line">            helper(root.right,path,list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-11-297-二叉树的序列化与反序列化"><a href="#1-11-297-二叉树的序列化与反序列化" class="headerlink" title="1.11 297. 二叉树的序列化与反序列化"></a>1.11 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/">297. 二叉树的序列化与反序列化</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">SEP</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">NULL</span> <span class="operator">=</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主函数，将二叉树序列化为字符串 */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        serialize(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 辅助函数，将二叉树存入 StringBuilder */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            sb.append(NULL).append(SEP);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/******前序遍历位置******/</span></span><br><span class="line">        sb.append(root.val).append(SEP);</span><br><span class="line">        serialize(root.left, sb);</span><br><span class="line">        serialize(root.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主函数，将字符串反序列化为二叉树结构 */</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="comment">// 将字符串转化成列表</span></span><br><span class="line">        LinkedList&lt;String&gt; nodes = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : data.split(SEP)) &#123;</span><br><span class="line">            nodes.addLast(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(nodes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 辅助函数，通过 nodes 列表构造二叉树 */</span></span><br><span class="line">    TreeNode <span class="title function_">deserialize</span><span class="params">(LinkedList&lt;String&gt; nodes)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">/******前序遍历位置******/</span></span><br><span class="line">        <span class="comment">// 列表最左侧就是根节点</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">first</span> <span class="operator">=</span> nodes.removeFirst();</span><br><span class="line">        <span class="keyword">if</span> (first.equals(NULL)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(first));</span><br><span class="line">        <span class="comment">// 会把左子树的元素全部移除</span></span><br><span class="line">        root.left = deserialize(nodes);</span><br><span class="line">        root.right = deserialize(nodes);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-12-124-二叉树中的最大路径和"><a href="#1-12-124-二叉树中的最大路径和" class="headerlink" title="1.12 124. 二叉树中的最大路径和"></a>1.12 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h3><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在后序遍历的时候顺便计算题目要求的最大路径和。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxPathSum</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算单边路径和时顺便计算最大路径和</span></span><br><span class="line">        oneSideMax(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：计算从根节点 root 为起点的最大单边路径和</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">oneSideMax</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMaxSum</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, oneSideMax(root.left));</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMaxSum</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, oneSideMax(root.right));</span><br><span class="line">        <span class="comment">// 后序遍历位置，顺便更新最大路径和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pathMaxSum</span> <span class="operator">=</span> root.val + leftMaxSum + rightMaxSum;</span><br><span class="line">        res = Math.max(res, pathMaxSum);</span><br><span class="line">        <span class="comment">// 实现函数定义，左右子树的最大单边路径和加上根节点的值</span></span><br><span class="line">        <span class="comment">// 就是从根节点 root 为起点的最大单边路径和</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftMaxSum, rightMaxSum) + root.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-13-114-二叉树展开为链表"><a href="#1-13-114-二叉树展开为链表" class="headerlink" title="1.13 114. 二叉树展开为链表"></a>1.13 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h3><p>给你二叉树的根结点 root ，请你将它展开为一个单链表</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：将以 root 为根的树拉平为链表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 先递归拉平左右子树</span></span><br><span class="line">        flatten(root.left);</span><br><span class="line">        flatten(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/****后序遍历位置****/</span></span><br><span class="line">        <span class="comment">// 1、左右子树已经被拉平成一条链表</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2、将左子树作为右子树</span></span><br><span class="line">        root.left = <span class="literal">null</span>;</span><br><span class="line">        root.right = left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3、将原先的右子树接到当前右子树的末端</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">while</span> (p.right != <span class="literal">null</span>) &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        p.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-14-623-在二叉树中增加一行"><a href="#1-14-623-在二叉树中增加一行" class="headerlink" title="1.14 623. 在二叉树中增加一行"></a>1.14 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/add-one-row-to-tree/">623. 在二叉树中增加一行</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> targetVal, targetDepth;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">addOneRow</span><span class="params">(TreeNode root, <span class="type">int</span> val, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">        targetVal = val;</span><br><span class="line">        targetDepth = depth;</span><br><span class="line">        <span class="comment">// 插入到第一行的话特殊对待一下</span></span><br><span class="line">        <span class="keyword">if</span> (targetDepth == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">newRoot</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(targetVal);</span><br><span class="line">            newRoot.left = root;</span><br><span class="line">            <span class="keyword">return</span> newRoot;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历二叉树，走到对应行进行插入</span></span><br><span class="line">        traverse(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">curDepth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历</span></span><br><span class="line">        curDepth++;</span><br><span class="line">        <span class="keyword">if</span> (curDepth == targetDepth - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 进行插入</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">newLeft</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(targetVal);</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">newRight</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(targetVal);</span><br><span class="line">            newLeft.left = root.left;</span><br><span class="line">            newRight.right = root.right;</span><br><span class="line">            root.left = newLeft;</span><br><span class="line">            root.right = newRight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历</span></span><br><span class="line">        curDepth--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-15-654-最大二叉树"><a href="#1-15-654-最大二叉树" class="headerlink" title="1.15 654. 最大二叉树"></a>1.15 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-binary-tree/">654. 最大二叉树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">/* 主函数 */</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义：将 nums[lo..hi] 构造成符合条件的树，返回根节点 */</span></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (lo &gt; hi) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到数组中的最大值和对应的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> -<span class="number">1</span>, maxVal = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo; i &lt;= hi; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxVal &lt; nums[i]) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                maxVal = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxVal);</span><br><span class="line">        <span class="comment">// 递归调用构造左右子树</span></span><br><span class="line">        root.left = build(nums, lo, index - <span class="number">1</span>);</span><br><span class="line">        root.right = build(nums, index + <span class="number">1</span>, hi);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-16-814-二叉树剪枝"><a href="#1-16-814-二叉树剪枝" class="headerlink" title="1.16 814. 二叉树剪枝"></a>1.16 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-pruning/">814. 二叉树剪枝</a></h3><p>给你二叉树的根结点 root ，此外树的每个结点的值要么是 0 ，要么是 1 。</p>
<p>返回移除了所有不包含 1 的子树的原二叉树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：输入一棵二叉树，返回的二叉树叶子节点都是 1</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">pruneTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二叉树递归框架</span></span><br><span class="line">        root.left = pruneTree(root.left);</span><br><span class="line">        root.right = pruneTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历位置，判断自己是否是值为 0 的叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.val == <span class="number">0</span> &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回值会被父节点接收，相当于把自己删掉了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不是，正常返回</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-层序遍历"><a href="#2-层序遍历" class="headerlink" title="2 层序遍历"></a>2 层序遍历</h2><h3 id="2-1-102-二叉树的层序遍历"><a href="#2-1-102-二叉树的层序遍历" class="headerlink" title="2.1 102. 二叉树的层序遍历"></a>2.1 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="comment">// 记录当前层的节点，并将下一层的入队</span></span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                level.add(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>)</span><br><span class="line">                    q.offer(cur.left);</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>)</span><br><span class="line">                    q.offer(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-103-二叉树的锯齿形层序遍历"><a href="#2-2-103-二叉树的锯齿形层序遍历" class="headerlink" title="2.2 103. 二叉树的锯齿形层序遍历"></a>2.2 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/">103. 二叉树的锯齿形层序遍历</a></h3><p>即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt;  queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            queue.offer(root);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置标记，记录顺序</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;   </span><br><span class="line">            List&lt;Integer&gt; level = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i &lt; n ; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    level.add(node.val);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 倒过来添加到队列里面</span></span><br><span class="line">                    level.add(<span class="number">0</span>,node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>) queue.offer(node.left);</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>) queue.offer(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(level);</span><br><span class="line">            flag = !flag;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-662-二叉树最大宽度"><a href="#2-3-662-二叉树最大宽度" class="headerlink" title="2.3 662. 二叉树最大宽度"></a>2.3 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-width-of-binary-tree/">662. 二叉树最大宽度</a></h3><p>给你一棵二叉树的根节点 root ，返回树的 <strong>最大宽度</strong> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据完全二叉树的概念，i位置节点的左子节点位置为2i，右子节点位置为2i+1；</span></span><br><span class="line"><span class="comment">//通过一个list记录节点对应的完全二叉树中的位置</span></span><br><span class="line"><span class="comment">//按层BFS二叉树，记录下list中每一层的前后位置之差，返回最大</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//节点队列</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();		   </span><br><span class="line">        <span class="comment">//节点位置队列</span></span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        res.add(<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; size;i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="type">Integer</span> <span class="variable">cur</span> <span class="operator">=</span> res.removeFirst();</span><br><span class="line">                <span class="comment">// 相应的位置也加入辅助队列</span></span><br><span class="line">                <span class="keyword">if</span>(node.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.left);</span><br><span class="line">                    res.add(cur*<span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(node.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    queue.offer(node.right);</span><br><span class="line">                    res.add(cur * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更新最大宽度</span></span><br><span class="line">            <span class="keyword">if</span>(res.size() &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">                ans = Math.max(ans,res.getLast() - res.getFirst() + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-958-二叉树的完全性检验"><a href="#2-4-958-二叉树的完全性检验" class="headerlink" title="2.4 958. 二叉树的完全性检验"></a>2.4 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/check-completeness-of-a-binary-tree/">958. 二叉树的完全性检验</a></h3><p>给定一个二叉树的 root ，确定它是否是一个 <em>完全二叉树</em> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历，判断是否出现过null</span></span><br><span class="line"><span class="comment">//通过一个 flag 进行记录</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompleteTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;		<span class="comment">//判断是否出现过null</span></span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size ; i++)&#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(node != <span class="literal">null</span>)&#123;	<span class="comment">//如果当前节点不是null</span></span><br><span class="line">                    <span class="keyword">if</span>(flag) <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//如果之前出现就直接返回</span></span><br><span class="line">                    queue.add(node.left);	<span class="comment">//不管有没有子节点，都加入</span></span><br><span class="line">                    queue.add(node.right);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;				</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-222-完全二叉树的节点个数"><a href="#2-5-222-完全二叉树的节点个数" class="headerlink" title="2.5 222. 完全二叉树的节点个数"></a>2.5 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数</a></h3><p>给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> countLevel(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> countLevel(root.right);</span><br><span class="line">        <span class="comment">// 层数一样，左边满，不一样，右边满</span></span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            <span class="comment">// 位运算 2^left</span></span><br><span class="line">            <span class="keyword">return</span> countNodes(root.right) + (<span class="number">1</span>&lt;&lt;left);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> countNodes(root.left) + (<span class="number">1</span>&lt;&lt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countLevel</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>)&#123;</span><br><span class="line">            level++;</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-199-二叉树的右视图"><a href="#2-6-199-二叉树的右视图" class="headerlink" title="2.6 199. 二叉树的右视图"></a>2.6 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h3><p>给定一个二叉树的 根节点 root，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* BFS 层序遍历解法 */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// BFS 层序遍历，计算右侧视图</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.offer(root);</span><br><span class="line">        <span class="comment">// while 循环控制从上向下一层层遍历</span></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="comment">// 每一层头部就是最右侧的元素</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">last</span> <span class="operator">=</span> q.peek();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="comment">// 控制每一层从右向左遍历</span></span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    q.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 每一层的最后一个节点就是二叉树的右侧视图</span></span><br><span class="line">            res.add(last.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* DFS 递归遍历解法 */</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录递归的层数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">rightSideView_DFS</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二叉树遍历函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历位置</span></span><br><span class="line">        depth++;</span><br><span class="line">        <span class="keyword">if</span> (res.size() &lt; depth) &#123;</span><br><span class="line">            <span class="comment">// 这一层还没有记录值</span></span><br><span class="line">            <span class="comment">// 说明 root 就是右侧视图的第一个节点</span></span><br><span class="line">            res.add(root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注意，这里反过来，先遍历右子树再遍历左子树</span></span><br><span class="line">        <span class="comment">// 这样首先遍历的一定是右侧节点</span></span><br><span class="line">        traverse(root.right);</span><br><span class="line">        traverse(root.left);</span><br><span class="line">        <span class="comment">// 后序遍历位置</span></span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-递归"><a href="#3-递归" class="headerlink" title="3 递归"></a>3 递归</h2><h3 id="3-1-112-路径总和"><a href="#3-1-112-路径总和" class="headerlink" title="3.1 112. 路径总和"></a>3.1 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum/">112. 路径总和</a></h3><p>给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;	<span class="comment">//为空节点，false</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span> &amp;&amp; root.val == sum)&#123; <span class="comment">//当路径总和等于目标且为叶子节点时，true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left,sum - root.val) || hasPathSum(root.right,sum - root.val);</span><br><span class="line">    &#125;  <span class="comment">//从当前节点的左右继续往下递归，目标值减去当前节点值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-113-路径总和-II"><a href="#3-2-113-路径总和-II" class="headerlink" title="3.2 113. 路径总和 II"></a>3.2 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></h3><p>给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Java 文档中 Stack 类建议使用 Deque 代替 Stack，注意：只使用栈的相关接口</span></span><br><span class="line">        Deque&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        dfs(root, sum, path, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pathSum</span><span class="params">(TreeNode node, <span class="type">int</span> sum, Deque&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; res)</span> &#123;</span><br><span class="line">        <span class="comment">// 递归终止条件 1：遇到空结点不再递归调用</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 沿途结点必须选择，这个时候要做两件事：1、sum 减去这个结点的值；2、添加到 path 里</span></span><br><span class="line">        sum -= node.val;</span><br><span class="line">        path.addLast(node.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归终止条件 2：遇到叶子结点，sum 恰好为 0，说明从根结点到叶子结点的路径是一个符合要求的解</span></span><br><span class="line">        <span class="keyword">if</span> (sum == <span class="number">0</span> &amp;&amp; node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// path 全局只有一份，必须做拷贝</span></span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">            <span class="comment">// 注意：这里 return 之前必须重置</span></span><br><span class="line">            path.removeLast();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pathSum(node.left, sum, path, res);</span><br><span class="line">        pathSum(node.right, sum, path, res);</span><br><span class="line">        <span class="comment">// 递归完成以后，必须重置变量</span></span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    dfs(root, sum, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(), result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> sum, List&lt;Integer&gt; list,</span></span><br><span class="line"><span class="params">                List&lt;List&lt;Integer&gt;&gt; result)</span> &#123;</span><br><span class="line">    <span class="comment">//如果节点为空直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//因为list是引用传递，为了防止递归的时候分支污染，我们要在每个路径</span></span><br><span class="line">    <span class="comment">//中都要新建一个subList</span></span><br><span class="line">    List&lt;Integer&gt; subList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list);</span><br><span class="line">    <span class="comment">//把当前节点值加入到subList中</span></span><br><span class="line">    subList.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(root.val));</span><br><span class="line">    <span class="comment">//如果到达叶子节点，就不能往下走了，直接return</span></span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果到达叶子节点，并且sum等于叶子节点的值，说明我们找到了一组，</span></span><br><span class="line">        <span class="comment">//要把它放到result中</span></span><br><span class="line">        <span class="keyword">if</span> (sum == root.val)</span><br><span class="line">            result.add(subList);</span><br><span class="line">        <span class="comment">//到叶子节点之后直接返回，因为在往下就走不动了</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果没到达叶子节点，就继续从他的左右两个子节点往下找，注意到</span></span><br><span class="line">    <span class="comment">//下一步的时候，sum值要减去当前节点的值</span></span><br><span class="line">    dfs(root.left, sum - root.val, subList, result);</span><br><span class="line">    dfs(root.right, sum - root.val, subList, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-437-路径总和-III"><a href="#3-3-437-路径总和-III" class="headerlink" title="3.3 437. 路径总和 III"></a>3.3 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h3><p>给定一个二叉树的根节点 root ，和一个整数 targetSum ，求该二叉树里节点值之和等于 targetSum 的 <strong>路径</strong> 的数目。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//因为未必是要从根节点开始，因此需要对所有节点进行递归判断</span></span><br><span class="line">        <span class="keyword">return</span> pathSumFromRoot(root,sum) + pathSum(root.left,sum) + pathSum(root.right,sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">pathSumFromRoot</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span>&#123; <span class="comment">//递归判断从当前节点是否有满足条件的路径</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum == root.val) ret++;</span><br><span class="line">        ret += pathSumFromRoot(root.left, sum - root.val) + pathSumFromRoot(root.right, sum - root.val);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-572-另一棵树的子树"><a href="#3-4-572-另一棵树的子树" class="headerlink" title="3.4 572. 另一棵树的子树"></a>3.4 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/subtree-of-another-tree/">572. 另一棵树的子树</a></h3><p>给你两棵二叉树 root 和 subRoot 。检验 root 中是否包含和 subRoot 具有相同结构和节点值的子树。如果存在，返回 true ；否则，返回 false 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//因为未必是要从根节点开始，因此需要对所有节点进行递归判断</span></span><br><span class="line">        <span class="keyword">return</span> isSubtree(s.left,t) || isSubtree(s.right,t) || isSubtreeFromRoot(s,t);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSubtreeFromRoot</span><span class="params">(TreeNode s, TreeNode t)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> &amp;&amp; t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> || t == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.val != t.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSubtreeFromRoot(s.left,t.left) &amp;&amp; isSubtreeFromRoot(s.right,t.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-111-二叉树的最小深度"><a href="#3-5-111-二叉树的最小深度" class="headerlink" title="3.5 111. 二叉树的最小深度"></a>3.5 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度</a></h3><p>给定一个二叉树，找出其最小深度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> minDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> minDepth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="number">0</span> || right == <span class="number">0</span>) <span class="keyword">return</span> left+right+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.min(left , right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-101-对称二叉树"><a href="#3-6-101-对称二叉树" class="headerlink" title="3.6 101. 对称二叉树"></a>3.6 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root, root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMirror</span><span class="params">(TreeNode t1, TreeNode t2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> &amp;&amp; t2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="literal">null</span> || t2 == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> </span><br><span class="line">            (t1.val == t2.val)</span><br><span class="line">            &amp;&amp; isMirror(t1.right, t2.left)</span><br><span class="line">            &amp;&amp; isMirror(t1.left, t2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-7-404-左叶子之和"><a href="#3-7-404-左叶子之和" class="headerlink" title="3.7 404. 左叶子之和"></a>3.7 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-of-left-leaves/">404. 左叶子之和</a></h3><p>给定二叉树的根节点 root ，返回所有左叶子之和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是不是左叶子</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(isLeaf(root.left))&#123;</span><br><span class="line">            left = root.left.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left + sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isLeaf</span><span class="params">(TreeNode root)</span>&#123; <span class="comment">//判断是否是叶子节点</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-8-687-最长同值路径"><a href="#3-8-687-最长同值路径" class="headerlink" title="3.8 687. 最长同值路径"></a>3.8 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/longest-univalue-path/">687. 最长同值路径</a></h3><p>给定一个二叉树的 root ，返回 <em>最长的路径的长度</em> ，这个路径中的 <em>每个节点具有相同值</em> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestUnivaluePath</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 在后序遍历的位置更新 res</span></span><br><span class="line">        maxLen(root, root.val);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：计算以 root 为根的这棵二叉树中，从 root 开始值为 parentVal 的最长树枝长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">maxLen</span><span class="params">(TreeNode root, <span class="type">int</span> parentVal)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用函数定义，计算左右子树值为 root.val 的最长树枝长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftLen</span> <span class="operator">=</span> maxLen(root.left, root.val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightLen</span> <span class="operator">=</span> maxLen(root.right, root.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历位置顺便更新全局变量</span></span><br><span class="line">        <span class="comment">// 同值路径就是左右同值树枝长度之和</span></span><br><span class="line">        res = Math.max(res, leftLen + rightLen);</span><br><span class="line">        <span class="comment">// 如果 root 本身和上级值不同，那么整棵子树都不可能有同值树枝</span></span><br><span class="line">        <span class="keyword">if</span> (root.val != parentVal) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 实现函数的定义：</span></span><br><span class="line">        <span class="comment">// 以 root 为根的二叉树从 root 开始值为 parentVal 的最长树枝长度</span></span><br><span class="line">        <span class="comment">// 等于左右子树的最长树枝长度的最大值加上 root 节点本身</span></span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span> + Math.max(leftLen, rightLen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-9-337-打家劫舍-III"><a href="#3-9-337-打家劫舍-III" class="headerlink" title="3.9 337. 打家劫舍 III"></a>3.9 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/house-robber-iii/">337. 打家劫舍 III</a></h3><p>给定二叉树的 root 。返回 <strong><em>在不触动警报的情况下\</em></strong> <em>，小偷能够盗取的最高金额</em> 。</p>
<p>如果 两个直接相连的房子在同一天晚上被打劫 ，房屋将自动报警。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//设置备忘录，记录打劫该点的最大收益</span></span><br><span class="line">    Map&lt;TreeNode, Integer&gt; memo = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 移除子问题</span></span><br><span class="line">        <span class="keyword">if</span>(memo.containsKey(root)) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo.get(root);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">doRob</span> <span class="operator">=</span> root.val</span><br><span class="line">                + (root.left == <span class="literal">null</span> ?</span><br><span class="line">                <span class="number">0</span> : rob(root.left.left) + rob(root.left.right))</span><br><span class="line">                + (root.right == <span class="literal">null</span> ?</span><br><span class="line">                <span class="number">0</span> : rob(root.right.left) + rob(root.right.right));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">notRob</span> <span class="operator">=</span> rob(root.left) + rob(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(doRob, notRob);</span><br><span class="line">        memo.put(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-10-671-二叉树中第二小的节点"><a href="#3-10-671-二叉树中第二小的节点" class="headerlink" title="3.10 671. 二叉树中第二小的节点"></a>3.10 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/second-minimum-node-in-a-binary-tree/">671. 二叉树中第二小的节点</a></h3><p>给定一个非空特殊的二叉树，每个节点都是正数，并且每个节点的子节点数量只能为 2 或 0。如果一个节点有两个子节点的话，那么这个节点的值不大于它的子节点的值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findSecondMinimumValue</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归中止条件</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">//如果为空节点，返回-1</span></span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) <span class="keyword">return</span> -<span class="number">1</span>;  <span class="comment">//如果没有子节点，返回-1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归操作</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> root.left.val;  <span class="comment">//左节点的值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> root.right.val;  <span class="comment">//右节点的值</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == left) left = findSecondMinimumValue(root.left);  <span class="comment">//如果左节点和根节点的值相同，第二小的从左子树上寻找</span></span><br><span class="line">        <span class="keyword">if</span>(root.val == right) right = findSecondMinimumValue(root.right);  <span class="comment">//如果和右节点还是相同，则找出右子树的第二小</span></span><br><span class="line">        </span><br><span class="line">       	<span class="comment">//返回情况</span></span><br><span class="line">        <span class="keyword">if</span>(left != -<span class="number">1</span> &amp;&amp; right != -<span class="number">1</span>) <span class="keyword">return</span> Math.min(left,right);  <span class="comment">//如果左右都不是-1，返回其中的最小</span></span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>) <span class="keyword">return</span> right;  <span class="comment">//如果左边没有，那就返回右边</span></span><br><span class="line">        <span class="keyword">return</span> left;	<span class="comment">//否则返回-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-11-110-平衡二叉树"><a href="#3-11-110-平衡二叉树" class="headerlink" title="3.11 110. 平衡二叉树"></a>3.11 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/balanced-binary-tree/">110. 平衡二叉树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxDepth(root);</span><br><span class="line">        <span class="keyword">return</span> isBalanced;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录二叉树是否平衡</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isBalanced</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入一个节点，返回以该节点为根的二叉树的最大深度</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMaxDepth</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMaxDepth</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后序遍历位置</span></span><br><span class="line">        <span class="comment">// 如果左右最大深度大于 1，就不是平衡二叉树</span></span><br><span class="line">        <span class="keyword">if</span> (Math.abs(rightMaxDepth - leftMaxDepth) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            isBalanced = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftMaxDepth, rightMaxDepth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-12-104-二叉树的最大深度"><a href="#3-12-104-二叉树的最大深度" class="headerlink" title="3.12 104. 二叉树的最大深度"></a>3.12 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h3><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">// 前序遍历位置</span></span><br><span class="line">        depth++;</span><br><span class="line">        res = Math.max(res, depth);</span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line">        <span class="comment">// 后序遍历位置</span></span><br><span class="line">        depth--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：输入一个节点，返回以该节点为根的二叉树的最大深度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="comment">// 根据左右子树的最大深度推出原二叉树的最大深度</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftMax, rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-13-129-求根节点到叶节点数字之和"><a href="#3-13-129-求根节点到叶节点数字之和" class="headerlink" title="3.13 129. 求根节点到叶节点数字之和"></a>3.13 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sum-root-to-leaf-numbers/">129. 求根节点到叶节点数字之和</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">path</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历一遍二叉树就能出结果</span></span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二叉树遍历函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历位置，记录节点值</span></span><br><span class="line">        path.append(root.val);</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 到达叶子节点，累加路径和</span></span><br><span class="line">            res += Integer.parseInt(path.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 二叉树递归框架，遍历左右子树</span></span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 后续遍历位置，撤销节点值</span></span><br><span class="line">        path.deleteCharAt(path.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-14-543-二叉树的直径"><a href="#3-14-543-二叉树的直径" class="headerlink" title="3.14 543. 二叉树的直径"></a>3.14 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxDiameter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        maxDepth(root);</span><br><span class="line">        <span class="keyword">return</span> maxDiameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftMax</span> <span class="operator">=</span> maxDepth(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightMax</span> <span class="operator">=</span> maxDepth(root.right);</span><br><span class="line">        <span class="comment">// 后序遍历位置顺便计算最大直径</span></span><br><span class="line">        maxDiameter = Math.max(maxDiameter, leftMax + rightMax);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(leftMax, rightMax);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-15-226-翻转二叉树"><a href="#3-15-226-翻转二叉树" class="headerlink" title="3.15 226. 翻转二叉树"></a>3.15 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 「遍历」的思路</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历二叉树，交换每个节点的子节点</span></span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二叉树遍历函数</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**** 前序位置 ****/</span></span><br><span class="line">        <span class="comment">// 每一个节点需要做的事就是交换它的左右子节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历框架，去遍历左右子树的节点</span></span><br><span class="line">        traverse(root.left);</span><br><span class="line">        traverse(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 「分解问题」的思路</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：将以 root 为根的这棵二叉树翻转，返回翻转后的二叉树的根节点</span></span><br><span class="line">    TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 利用函数定义，先翻转左右子树</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> invertTree(root.left);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> invertTree(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 然后交换左右子节点</span></span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 和定义逻辑自恰：以 root 为根的这棵二叉树已经被翻转，返回 root</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-16-863-二叉树中所有距离为-K-的结点"><a href="#3-16-863-二叉树中所有距离为-K-的结点" class="headerlink" title="3.16 863. 二叉树中所有距离为 K 的结点"></a>3.16 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/all-nodes-distance-k-in-binary-tree/">863. 二叉树中所有距离为 K 的结点</a></h3><p>给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 k 。</p>
<p>返回到目标结点 target 距离为 k 的所有结点的值的列表。 答案可以以 任何顺序 返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 记录父节点：node.val -&gt; parentNode</span></span><br><span class="line">    <span class="comment">// 题目说了树中所有节点值都是唯一的，所以可以用 node.val 代表 TreeNode</span></span><br><span class="line">    HashMap&lt;Integer, TreeNode&gt; parent = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">distanceK</span><span class="params">(TreeNode root, TreeNode target, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">// 遍历所有节点，记录每个节点的父节点</span></span><br><span class="line">        traverse(root, <span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始从 target 节点施放 BFS 算法，找到距离为 k 的节点</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        q.offer(target);</span><br><span class="line">        visited.add(target.val);</span><br><span class="line">        <span class="comment">// 记录离 target 的距离</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">dist</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sz</span> <span class="operator">=</span> q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> q.poll();</span><br><span class="line">                <span class="keyword">if</span> (dist == k) &#123;</span><br><span class="line">                    <span class="comment">// 找到距离起点 target 距离为 k 的节点</span></span><br><span class="line">                    res.add(cur.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 向父节点、左右子节点扩散</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">parentNode</span> <span class="operator">=</span> parent.get(cur.val);</span><br><span class="line">                <span class="keyword">if</span> (parentNode != <span class="literal">null</span> &amp;&amp; !visited.contains(parentNode.val)) &#123;</span><br><span class="line">                    visited.add(parentNode.val);</span><br><span class="line">                    q.offer(parentNode);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.left != <span class="literal">null</span> &amp;&amp; !visited.contains(cur.left.val)) &#123;</span><br><span class="line">                    visited.add(cur.left.val);</span><br><span class="line">                    q.offer(cur.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur.right != <span class="literal">null</span> &amp;&amp; !visited.contains(cur.right.val)) &#123;</span><br><span class="line">                    visited.add(cur.right.val);</span><br><span class="line">                    q.offer(cur.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向外扩展一圈</span></span><br><span class="line">            dist++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, TreeNode parentNode)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        parent.put(root.val, parentNode);</span><br><span class="line">        <span class="comment">// 二叉树递归框架</span></span><br><span class="line">        traverse(root.left, root);</span><br><span class="line">        traverse(root.right, root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-17-617-合并二叉树"><a href="#3-17-617-合并二叉树" class="headerlink" title="3.17 617. 合并二叉树"></a>3.17 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/merge-two-binary-trees/">617. 合并二叉树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">// 如果一棵树有，另一棵树没有，接上去</span></span><br><span class="line">        <span class="keyword">if</span> (root1 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root2 == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 两棵树都有的节点，叠加节点值</span></span><br><span class="line">        root1.val += root2.val;</span><br><span class="line">        <span class="comment">// 递归合并左右子树</span></span><br><span class="line">        root1.left = mergeTrees(root1.left, root2.left);</span><br><span class="line">        root1.right = mergeTrees(root1.right, root2.right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-二叉搜索树"><a href="#4-二叉搜索树" class="headerlink" title="4 二叉搜索树"></a>4 二叉搜索树</h2><p>对于 BST 的每一个节点 node，左子树节点的值都比 node 的值要小，右子树节点的值都比 node 的值大。</p>
<h3 id="4-1-98-验证二叉搜索树"><a href="#4-1-98-验证二叉搜索树" class="headerlink" title="4.1 98. 验证二叉搜索树"></a>4.1 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root, <span class="literal">null</span>, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 限定以 root 为根的子树节点必须满足 max.val &gt; root.val &gt; min.val */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode root, TreeNode min, TreeNode max)</span> &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST</span></span><br><span class="line">        <span class="keyword">if</span> (min != <span class="literal">null</span> &amp;&amp; root.val &lt;= min.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (max != <span class="literal">null</span> &amp;&amp; root.val &gt;= max.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 限定左子树的最大值是 root.val，右子树的最小值是 root.val</span></span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left, min, root)</span><br><span class="line">            &amp;&amp; isValidBST(root.right, root, max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-230-二叉搜索树中第K小的元素"><a href="#4-2-230-二叉搜索树中第K小的元素" class="headerlink" title="4.2 230. 二叉搜索树中第K小的元素"></a>4.2 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h3><p>给定一个二叉搜索树的根节点 root ，和一个整数 k ，请你设计一个算法查找其中第 k 个最小元素（从 1 开始计数）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kthSmallest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 利用 BST 的中序遍历特性</span></span><br><span class="line">    traverse(root, k);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 记录结果</span></span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 记录当前元素的排名</span></span><br><span class="line"><span class="type">int</span> <span class="variable">rank</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traverse(root.left, k);</span><br><span class="line">    <span class="comment">/* 中序遍历代码位置 */</span></span><br><span class="line">    rank++;</span><br><span class="line">    <span class="keyword">if</span> (k == rank) &#123;</span><br><span class="line">        <span class="comment">// 找到第 k 小的元素</span></span><br><span class="line">        res = root.val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    traverse(root.right, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-450-删除二叉搜索树中的节点"><a href="#4-3-450-删除二叉搜索树中的节点" class="headerlink" title="4.3 450. 删除二叉搜索树中的节点"></a>4.3 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/delete-node-in-a-bst/">450. 删除二叉搜索树中的节点</a></h3><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种情况：</span></span><br><span class="line"><span class="comment">//无左子：其右子顶替其位置，删除了该节点；</span></span><br><span class="line"><span class="comment">//无右子：其左子顶替其位置，删除了该节点；</span></span><br><span class="line"><span class="comment">//左右子节点都有：左子树转移到其右子树的最左节点的左子树上</span></span><br><span class="line"><span class="comment">//然后右子树顶替其位置，由此删除了该节点。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deleteNode</span><span class="params">(TreeNode root, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val == key) &#123;</span><br><span class="line">            <span class="comment">// 这两个 if 把情况 1 和 2 都正确处理了</span></span><br><span class="line">            <span class="keyword">if</span> (root.left == <span class="literal">null</span>) <span class="keyword">return</span> root.right;</span><br><span class="line">            <span class="keyword">if</span> (root.right == <span class="literal">null</span>) <span class="keyword">return</span> root.left;</span><br><span class="line">            <span class="comment">// 处理情况 3</span></span><br><span class="line">            <span class="comment">// 获得右子树最小的节点</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">minNode</span> <span class="operator">=</span> getMin(root.right);</span><br><span class="line">            <span class="comment">// 删除右子树最小的节点</span></span><br><span class="line">            root.right = deleteNode(root.right, minNode.val);</span><br><span class="line">            <span class="comment">// 用右子树最小的节点替换 root 节点</span></span><br><span class="line">            minNode.left = root.left;</span><br><span class="line">            minNode.right = root.right;</span><br><span class="line">            root = minNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &gt; key) &#123;</span><br><span class="line">            root.left = deleteNode(root.left, key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root.val &lt; key) &#123;</span><br><span class="line">            root.right = deleteNode(root.right, key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TreeNode <span class="title function_">getMin</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">        <span class="comment">// BST 最左边的就是最小的</span></span><br><span class="line">        <span class="keyword">while</span> (node.left != <span class="literal">null</span>) node = node.left;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-96-不同的二叉搜索树"><a href="#4-4-96-不同的二叉搜索树" class="headerlink" title="4.4 96. 不同的二叉搜索树"></a>4.4 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h3><p>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 备忘录</span></span><br><span class="line">    <span class="type">int</span>[][] memo;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">// 备忘录的值初始化为 0</span></span><br><span class="line">        memo = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> count(<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lo &gt; hi) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 查备忘录</span></span><br><span class="line">        <span class="keyword">if</span> (memo[lo][hi] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> memo[lo][hi];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> lo; mid &lt;= hi; mid++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> count(lo, mid - <span class="number">1</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> count(mid + <span class="number">1</span>, hi);</span><br><span class="line">            res += left * right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将结果存入备忘录</span></span><br><span class="line">        memo[lo][hi] = res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-5-108-将有序数组转换为二叉搜索树"><a href="#4-5-108-将有序数组转换为二叉搜索树" class="headerlink" title="4.5 108. 将有序数组转换为二叉搜索树"></a>4.5 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h3><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> build(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将闭区间 [left, right] 中的元素转化成 BST，返回根节点</span></span><br><span class="line">    TreeNode <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="comment">// 区间为空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造根节点</span></span><br><span class="line">        <span class="comment">// BST 节点左小右大，中间的元素就是根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[mid]);</span><br><span class="line">        <span class="comment">// 递归构建左子树</span></span><br><span class="line">        root.left = build(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 递归构造右子树</span></span><br><span class="line">        root.right = build(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-6-449-序列化和反序列化二叉搜索树"><a href="#4-6-449-序列化和反序列化二叉搜索树" class="headerlink" title="4.6 449. 序列化和反序列化二叉搜索树"></a>4.6 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/serialize-and-deserialize-bst/">449. 序列化和反序列化二叉搜索树</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line">    <span class="comment">// 分隔符，区分每个节点的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">SEP</span> <span class="operator">=</span> <span class="string">&quot;,&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        serialize(root, sb);</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">serialize</span><span class="params">(TreeNode root, StringBuilder sb)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 前序遍历位置进行序列化</span></span><br><span class="line">        sb.append(root.val).append(SEP);</span><br><span class="line">        serialize(root.left, sb);</span><br><span class="line">        serialize(root.right, sb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (data.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 转化成前序遍历结果</span></span><br><span class="line">        LinkedList&lt;Integer&gt; inorder = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String s : data.split(SEP)) &#123;</span><br><span class="line">            inorder.offer(Integer.parseInt(s));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> deserialize(inorder, Integer.MIN_VALUE, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义：将 nodes 中值在闭区间 [min, max] 的节点构造成一棵 BST</span></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">deserialize</span><span class="params">(LinkedList&lt;Integer&gt; nodes, <span class="type">int</span> min, <span class="type">int</span> max)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes.isEmpty()) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 前序遍历位置进行反序列化</span></span><br><span class="line">        <span class="comment">// 前序遍历结果第一个节点是根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rootVal</span> <span class="operator">=</span> nodes.getFirst();</span><br><span class="line">        <span class="keyword">if</span> (rootVal &gt; max || rootVal &lt; min) &#123;</span><br><span class="line">            <span class="comment">// 超过闭区间 [min, max]，则返回空指针</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nodes.removeFirst();</span><br><span class="line">        <span class="comment">// 生成 root 节点</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(rootVal);</span><br><span class="line">        <span class="comment">// 构建左右子树</span></span><br><span class="line">        <span class="comment">// BST 左子树都比根节点小，右子树都比根节点大</span></span><br><span class="line">        root.left = deserialize(nodes, min, rootVal);</span><br><span class="line">        root.right = deserialize(nodes, rootVal, max);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-7-669-修剪二叉搜索树"><a href="#4-7-669-修剪二叉搜索树" class="headerlink" title="4.7 669. 修剪二叉搜索树"></a>4.7 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/trim-a-binary-search-tree/">669. 修剪二叉搜索树</a></h3><p>给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据二叉搜索树的性质</span></span><br><span class="line"><span class="comment">// 一个节点小于 low，则左子树都要减掉</span></span><br><span class="line"><span class="comment">// 同样的处理大于情况</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 定义：删除 BST 中小于 low 和大于 high 的所有节点，返回结果 BST</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">trimBST</span><span class="params">(TreeNode root, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.val &lt; low) &#123;</span><br><span class="line">            <span class="comment">// 直接返回 root.right</span></span><br><span class="line">            <span class="comment">// 等于删除 root 以及 root 的左子树</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root.right, low, high);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val &gt; high) &#123;</span><br><span class="line">            <span class="comment">// 直接返回 root.left</span></span><br><span class="line">            <span class="comment">// 等于删除 root 以及 root 的右子树</span></span><br><span class="line">            <span class="keyword">return</span> trimBST(root.left, low, high);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 闭区间 [lo, hi] 内，不处理当前节点，递归子树</span></span><br><span class="line">        root.left = trimBST(root.left, low, high);</span><br><span class="line">        root.right = trimBST(root.right, low, high);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-8-173-二叉搜索树迭代器"><a href="#4-8-173-二叉搜索树迭代器" class="headerlink" title="4.8 173. 二叉搜索树迭代器"></a>4.8 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search-tree-iterator/">173. 二叉搜索树迭代器</a></h3><p>实现一个二叉搜索树迭代器类BSTIterator ，表示一个按中序遍历二叉搜索树（BST）的迭代器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    <span class="comment">// 模拟递归栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;TreeNode&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一路到底，把根节点和它的所有左节点放到栈中；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushLeftBranch</span><span class="params">(TreeNode p)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            stk.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        pushLeftBranch(root);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 弹出栈顶节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> stk.pop();</span><br><span class="line">        pushLeftBranch(p.right);</span><br><span class="line">        <span class="keyword">return</span> p.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !stk.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-9-1305-两棵二叉搜索树中的所有元素"><a href="#4-9-1305-两棵二叉搜索树中的所有元素" class="headerlink" title="4.9 1305. 两棵二叉搜索树中的所有元素"></a>4.9 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/all-elements-in-two-binary-search-trees/">1305. 两棵二叉搜索树中的所有元素</a></h3><p>给你 root1 和 root2 这两棵二叉搜索树。请你返回一个列表，其中包含 两棵树 中的所有整数并按 升序 排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">getAllElements</span><span class="params">(TreeNode root1, TreeNode root2)</span> &#123;</span><br><span class="line">        <span class="comment">// BST 有序迭代器</span></span><br><span class="line">        <span class="type">BSTIterator</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSTIterator</span>(root1);</span><br><span class="line">        <span class="type">BSTIterator</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BSTIterator</span>(root2);</span><br><span class="line">        LinkedList&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 类似合并有序链表的算法逻辑</span></span><br><span class="line">        <span class="keyword">while</span> (t1.hasNext() &amp;&amp; t2.hasNext()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t1.peek() &gt; t2.peek()) &#123;</span><br><span class="line">                res.add(t2.next());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res.add(t1.next());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果有一棵 BST 还剩元素，添加到最后</span></span><br><span class="line">        <span class="keyword">while</span> (t1.hasNext()) &#123;</span><br><span class="line">            res.add(t1.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (t2.hasNext()) &#123;</span><br><span class="line">            res.add(t2.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// BST 有序迭代器</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BSTIterator</span> &#123;</span><br><span class="line">    Stack&lt;TreeNode&gt; stk = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 左侧树枝一撸到底</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pushLeftBranch</span><span class="params">(TreeNode p)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            stk.push(p);</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BSTIterator</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        pushLeftBranch(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stk.peek().val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> stk.pop();</span><br><span class="line">        pushLeftBranch(p.right);</span><br><span class="line">        <span class="keyword">return</span> p.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasNext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !stk.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-10-1038-从二叉搜索树到更大和树"><a href="#4-10-1038-从二叉搜索树到更大和树" class="headerlink" title="4.10 1038. 从二叉搜索树到更大和树"></a>4.10 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/">1038. 从二叉搜索树到更大和树</a></h3><p>给定一个二叉搜索树 root (BST)，请将它的每个节点的值替换成树中大于或者等于该节点值的所有节点值之和。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">bstToGst</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录累加和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">traverse</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root.right);</span><br><span class="line">        <span class="comment">// 维护累加和</span></span><br><span class="line">        sum += root.val;</span><br><span class="line">        <span class="comment">// 将 BST 转化成累加树</span></span><br><span class="line">        root.val = sum;</span><br><span class="line">        traverse(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-11-1373-二叉搜索子树的最大键值和"><a href="#4-11-1373-二叉搜索子树的最大键值和" class="headerlink" title="4.11 1373. 二叉搜索子树的最大键值和"></a>4.11 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/">1373. 二叉搜索子树的最大键值和</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、左右子树是否是 BST。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、左子树的最大值和右子树的最小值。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>、左右子树的节点值之和。</span><br><span class="line"></span><br><span class="line">想要获得子树的信息，就要用到前文 手把手刷二叉树总结篇 说过的后序位置的妙用了。</span><br><span class="line"></span><br><span class="line">我们定义一个 traverse 函数，traverse(root) 返回一个大小为 <span class="number">4</span> 的 <span class="type">int</span> 数组，我们暂且称它为 res，其中：</span><br><span class="line"></span><br><span class="line">res[<span class="number">0</span>] 记录以 root 为根的二叉树是否是 BST，若为 <span class="number">1</span> 则说明是 BST，若为 <span class="number">0</span> 则说明不是 BST；</span><br><span class="line"></span><br><span class="line">res[<span class="number">1</span>] 记录以 root 为根的二叉树所有节点中的最小值；</span><br><span class="line"></span><br><span class="line">res[<span class="number">2</span>] 记录以 root 为根的二叉树所有节点中的最大值；</span><br><span class="line"></span><br><span class="line">res[<span class="number">3</span>] 记录以 root 为根的二叉树所有节点值之和。</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">// 全局变量，记录 BST 最大节点之和</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 主函数 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> maxSum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] traverse(TreeNode root) &#123;</span><br><span class="line">        <span class="comment">// base case</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;</span><br><span class="line">                    <span class="number">1</span>, Integer.MAX_VALUE, Integer.MIN_VALUE, <span class="number">0</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归计算左右子树</span></span><br><span class="line">        <span class="type">int</span>[] left = traverse(root.left);</span><br><span class="line">        <span class="type">int</span>[] right = traverse(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*******后序遍历位置*******/</span></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="comment">// 这个 if 在判断以 root 为根的二叉树是不是 BST</span></span><br><span class="line">        <span class="keyword">if</span> (left[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; right[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp;</span><br><span class="line">                root.val &gt; left[<span class="number">2</span>] &amp;&amp; root.val &lt; right[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="comment">// 以 root 为根的二叉树是 BST</span></span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 计算以 root 为根的这棵 BST 的最小值</span></span><br><span class="line">            res[<span class="number">1</span>] = Math.min(left[<span class="number">1</span>], root.val);</span><br><span class="line">            <span class="comment">// 计算以 root 为根的这棵 BST 的最大值</span></span><br><span class="line">            res[<span class="number">2</span>] = Math.max(right[<span class="number">2</span>], root.val);</span><br><span class="line">            <span class="comment">// 计算以 root 为根的这棵 BST 所有节点之和</span></span><br><span class="line">            res[<span class="number">3</span>] = left[<span class="number">3</span>] + right[<span class="number">3</span>] + root.val;</span><br><span class="line">            <span class="comment">// 更新全局变量</span></span><br><span class="line">            maxSum = Math.max(maxSum, res[<span class="number">3</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 以 root 为根的二叉树不是 BST</span></span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 其他的值都没必要计算了，因为用不到</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**************************/</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-12-面试题-04-06-后继者"><a href="#4-12-面试题-04-06-后继者" class="headerlink" title="4.12 面试题 04.06. 后继者"></a>4.12 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/successor-lcci/">面试题 04.06. 后继者</a></h3><p>找出二叉搜索树中指定节点的“下一个”节点（也即中序后继）。</p>
<ul>
<li>若有 root.val &lt;= p.val : 根据 BST 特性可知当前节点 root 及其左子树子节点均满足「值小于等于 p.val」，因此不可能是 p 点的后继，我们直接到 root 的右子树搜索 p 的后继（递归处理）；</li>
<li>若有 root.val &gt; p.val : 当第一次搜索到满足此条件的节点时，在以 root 为根节点的子树中「位于最左下方」的值为 p 的后继，但也有可能 root 没有左子树，因此 p 的后继要么在 root 的左子树中（若有），要么是 root 本身，此时我们可以直接到 root 的左子树搜索，若搜索结果为空返回 root，否则返回搜索结果。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">inorderSuccessor</span><span class="params">(TreeNode root, TreeNode p)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.val &lt;= p.val) <span class="keyword">return</span> inorderSuccessor(root.right, p);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">ans</span> <span class="operator">=</span> inorderSuccessor(root.left, p);</span><br><span class="line">        <span class="keyword">return</span> ans == <span class="literal">null</span> ? root : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-13-109-有序链表转换二叉搜索树"><a href="#4-13-109-有序链表转换二叉搜索树" class="headerlink" title="4.13 109. 有序链表转换二叉搜索树"></a>4.13 <a target="_blank" rel="noopener" href="https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/">109. 有序链表转换二叉搜索树</a></h3><p>给定一个单链表的头节点  head ，其中的元素 按升序排序 ，将其转换为高度平衡的二叉搜索树。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用快慢指针寻找中间值（需要找到中间节点的前一个节点）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">sortedListToBST</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//有下面两种边界问题</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(head.next == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(head.val);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">preMid</span> <span class="operator">=</span> helper(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> preMid.next;</span><br><span class="line">        preMid.next = <span class="literal">null</span>;<span class="comment">//从这里断开链表</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(mid.val);</span><br><span class="line">        root.left = sortedListToBST(head);</span><br><span class="line">        root.right = sortedListToBST(mid.next);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="comment">//寻找preMid</span></span><br><span class="line">    ListNode <span class="title function_">helper</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next.next;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-14-剑指26-二叉搜索树与双向链表"><a href="#4-14-剑指26-二叉搜索树与双向链表" class="headerlink" title="4.14 剑指26.二叉搜索树与双向链表"></a>4.14 剑指26.二叉搜索树与双向链表</h3><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<p>思路：</p>
<p>线索化二叉树。类似于中序遍历构建。</p>
<p>由于正向构建时，指针会移动到尾部，因此反向构建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">Convert</span><span class="params">(TreeNode pRootOfTree)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        Convert(pRootOfTree.right);</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">null</span>)&#123;</span><br><span class="line">            pRootOfTree.right = pre;</span><br><span class="line">            pre.left = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pRootOfTree;</span><br><span class="line">        Convert(pRootOfTree.left);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-15-653-给定一个二叉搜索树和一个目标结果，如果-BST-中存在两个元素且它们的和等于给定的目标结果，则返回-true。"><a href="#4-15-653-给定一个二叉搜索树和一个目标结果，如果-BST-中存在两个元素且它们的和等于给定的目标结果，则返回-true。" class="headerlink" title="4.15 653.给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。"></a>4.15 653.给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findTarget</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; inOrder = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        inOrder(root, inOrder);</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = inOrder.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> inOrder.get(left) + inOrder.get(right);</span><br><span class="line">            <span class="keyword">if</span>(sum == k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; k) right--;</span><br><span class="line">            <span class="keyword">else</span> left ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root, List&lt;Integer&gt; inOrder)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left, inOrder);</span><br><span class="line">        inOrder.add(root.val);</span><br><span class="line">        inOrder(root.right, inOrder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-16-501-给定一个有相同值的二叉搜索树（BST），找出-BST-中的所有众数（出现频率最高的元素）。"><a href="#4-16-501-给定一个有相同值的二叉搜索树（BST），找出-BST-中的所有众数（出现频率最高的元素）。" class="headerlink" title="4.16 501.给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。"></a>4.16 501.给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。</h3><p>如果众数超过1个，不需考虑输出顺序。</p>
<p>你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）</p>
<p>思路：</p>
<p>毫无疑问，同样使用中序遍历。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;<span class="comment">//存储最小值</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">preNode</span> <span class="operator">=</span> <span class="literal">null</span>;<span class="comment">//存储前一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMinimumDifference</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        inOrder(root);</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inOrder</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        inOrder(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> root.val;</span><br><span class="line">        <span class="keyword">if</span>(preNode != <span class="literal">null</span>)</span><br><span class="line">            <span class="comment">//后一个节点肯定大于前一个节点</span></span><br><span class="line">            min = Math.min(cur - preNode.val, min);</span><br><span class="line">        preNode = root;</span><br><span class="line">        inOrder(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/07/25/Basic/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">[Basic] Linux 常用命令</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-07-25
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <span id="more"></span>
<h2 id="1-一、文件和目录"><a href="#1-一、文件和目录" class="headerlink" title="1 一、文件和目录"></a>1 一、文件和目录</h2><blockquote>
<p>查看路径</p>
</blockquote>
<h3 id="1-1-pwd"><a href="#1-1-pwd" class="headerlink" title="1.1 pwd"></a>1.1 <strong>pwd</strong></h3><p><strong>显示当前目录的路径</strong></p>
<h3 id="1-2-which"><a href="#1-2-which" class="headerlink" title="1.2 which"></a>1.2 <strong>which</strong></h3><p>查看命令的可执行文件所在路径， Linux 下，每一条命令其实都对应一个可执行程序，在终端中输入命令，按回车的时候，就是执行了对应的那个程序， which 命令本身对应的程序也存在于 Linux 中。</p>
<p>总的来说一个命令就是一个可执行程序。</p>
<blockquote>
<p><em>浏览和切换目录</em></p>
</blockquote>
<h3 id="1-3-ls"><a href="#1-3-ls" class="headerlink" title="1.3 ls"></a>1.3 <strong>ls</strong></h3><p><strong>列出文件和目录，它是 Linux 最常用的命令之一。</strong></p>
<p>【常用参数】</p>
<ul>
<li>-a 显示所有文件和目录包括隐藏的</li>
<li>-l 显示详细列表</li>
<li>-h 适合人类阅读的</li>
<li>-t 按文件最近一次修改时间排序</li>
<li>-i 显示文件的 inode （ inode 是文件内容的标识）</li>
</ul>
<h3 id="1-4-cd"><a href="#1-4-cd" class="headerlink" title="1.4 cd"></a>1.4 <strong>cd</strong></h3><p><strong>cd 是英语 change directory 的缩写，表示切换目录。</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cd / --&gt; 跳转到根目录</span><br><span class="line">cd ~ --&gt; 跳转到家目录</span><br><span class="line">cd .. --&gt; 跳转到上级目录</span><br><span class="line">cd ./home --&gt; 跳转到当前目录的home目录下</span><br><span class="line">cd /home/lion --&gt; 跳转到根目录下的home目录下的lion目录</span><br><span class="line">cd --&gt; 不添加任何参数，也是回到家目录</span><br></pre></td></tr></table></figure>
<p>[注意] 输入cd /ho + 单次 tab 键会自动补全路径 + 两次 tab 键会列出所有可能的目录列表。</p>
<h3 id="1-5-du"><a href="#1-5-du" class="headerlink" title="1.5 du"></a>1.5 <strong>du</strong></h3><p><strong>列举目录大小信息。</strong></p>
<p>【常用参数】</p>
<ul>
<li>-h 适合人类阅读的；</li>
<li>-a 同时列举出目录下文件的大小信息；</li>
<li>-s 只显示总计大小，不显示具体信息。</li>
</ul>
<h3 id="1-6-浏览和创建文件"><a href="#1-6-浏览和创建文件" class="headerlink" title="1.6 浏览和创建文件"></a>1.6 浏览和创建文件</h3><h3 id="1-7-cat"><a href="#1-7-cat" class="headerlink" title="1.7 cat"></a>1.7 <strong>cat</strong></h3><p><strong>一次性显示文件所有内容，更适合查看小的文件。</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat cloud-init.log</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>【常用参数】</p>
<ul>
<li>-n 显示行号。  </li>
</ul>
<h3 id="1-8-less"><a href="#1-8-less" class="headerlink" title="1.8 less"></a>1.8 <strong>less</strong></h3><p><strong>分页显示文件内容，更适合查看大的文件。</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">less cloud-init.log</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>【快捷操作】</p>
<ul>
<li>空格键：前进一页（一个屏幕）；</li>
<li>b 键：后退一页；</li>
<li>回车键：前进一行；</li>
<li>y 键：后退一行；</li>
<li>上下键：回退或前进一行；</li>
<li>d 键：前进半页；</li>
<li>u 键：后退半页；</li>
<li>q 键：停止读取文件，中止 less 命令；</li>
<li>= 键：显示当前页面的内容是文件中的第几行到第几行以及一些其它关于本页内容的详细信息；</li>
<li>h 键：显示帮助文档；</li>
<li>/ 键：进入搜索模式后，按 n 键跳到一个符合项目，按 N 键跳到上一个符合项目，同时也可以输入<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">正则表达式</a>匹配。</li>
</ul>
<h3 id="1-9-head"><a href="#1-9-head" class="headerlink" title="1.9 head"></a>1.9 <strong>head</strong></h3><p><strong>显示文件的开头几行（默认是10行）</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head cloud-init.log</span><br></pre></td></tr></table></figure>
<p>【参数】</p>
<ul>
<li>-n 指定行数 head cloud-init.log -n 2  </li>
</ul>
<h3 id="1-10-tail"><a href="#1-10-tail" class="headerlink" title="1.10 tail"></a>1.10 <strong>tail</strong></h3><p><strong>显示文件的结尾几行（默认是10行）</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail cloud-init.log复制代码</span><br></pre></td></tr></table></figure>
<p>【参数】</p>
<ul>
<li>-n 指定行数 tail cloud-init.log -n 2</li>
<li>-f 会每过1秒检查下文件是否有更新内容，也可以用 -s 参数指定间隔时间 tail -f -s 4 xxx.log</li>
</ul>
<h3 id="1-11-touch"><a href="#1-11-touch" class="headerlink" title="1.11 touch"></a>1.11 <strong>touch</strong></h3><p><strong>创建一个文件</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch new_file复制代码</span><br></pre></td></tr></table></figure>
<h3 id="1-12-mkdir"><a href="#1-12-mkdir" class="headerlink" title="1.12 mkdir"></a>1.12 <strong>mkdir</strong></h3><p><strong>创建一个目录</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir new_folder复制代码</span><br></pre></td></tr></table></figure>
<p>【常用参数】</p>
<ul>
<li>-p 递归的创建目录结构 mkdir -p one/two/three  </li>
</ul>
<blockquote>
<p>文件的复制和移动</p>
</blockquote>
<h3 id="1-13-cp"><a href="#1-13-cp" class="headerlink" title="1.13 cp"></a>1.13 <strong>cp</strong></h3><p><strong>拷贝文件和目录</strong></p>
<p>cp file file_copy —&gt; file 是目标文件，file_copy 是拷贝出来的文件cp file one —&gt; 把 file 文件拷贝到 one 目录下，并且文件名依然为 file</p>
<p>cp file one/file_copy —&gt; 把 file 文件拷贝到 one 目录下，文件名为file_copy</p>
<p>cp *.txt folder —&gt; 把当前目录下所有 txt 文件拷贝到 folder 目录下</p>
<p>【常用参数】</p>
<ul>
<li>-r 递归的拷贝，常用来拷贝一整个目录  </li>
</ul>
<h3 id="1-14-mv"><a href="#1-14-mv" class="headerlink" title="1.14 mv"></a>1.14 <strong>mv</strong></h3><p><strong>移动（重命名）文件或目录，与cp命令用法相似。</strong></p>
<p>mv file one —&gt; 将 file 文件移动到 one 目录下</p>
<p>mv new_folder one —&gt; 将 new_folder 文件夹移动到one目录下mv *.txt folder —&gt; 把当前目录下所有 txt 文件移动到 folder 目录下mv file new_file —&gt; file 文件重命名为 new_file</p>
<blockquote>
<p>文件的删除和链接</p>
</blockquote>
<h3 id="1-15-rm"><a href="#1-15-rm" class="headerlink" title="1.15 rm"></a>1.15 <strong>rm</strong></h3><p><strong>删除文件和目录，由于 Linux 下没有回收站，一旦删除非常难恢复，因此需要谨慎操作</strong></p>
<p>rm new_file —&gt; 删除 new_file 文件</p>
<p>rm f1 f2 f3 —&gt; 同时删除 f1 f2 f3 3个文件</p>
<p>【常用参数】</p>
<ul>
<li>-i 向用户确认是否删除；</li>
<li>-f 文件强制删除；</li>
<li>-r 递归删除文件夹，著名的删除操作 rm -rf 。  </li>
</ul>
<h3 id="1-16-ln"><a href="#1-16-ln" class="headerlink" title="1.16 ln"></a>1.16 <strong>ln</strong></h3><p><strong>英文 Link 的缩写，表示创建链接。</strong></p>
<p>学习创建链接之前，首先要理解链接是什么，我们先来看看 Linux 的文件是如何存储的：</p>
<p>Linux 文件的存储方式分为3个部分，文件名、文件内容以及权限，其中文件名的列表是存储在硬盘的其它地方和文件内容是分开存放的，每个文件名通过 inode 标识绑定到文件内容。</p>
<p>Linux 下有两种链接类型：硬链接和软链接。</p>
<h3 id="1-17-硬链接"><a href="#1-17-硬链接" class="headerlink" title="1.17 硬链接"></a>1.17 硬链接</h3><p>使链接的两个文件共享同样文件内容，就是同样的 inode ，一旦文件1和文件2之间有了硬链接，那么修改任何一个文件，修改的都是同一块内容，它的缺点是，只能创建指向文件的硬链接，不能创建指向目录的（其实也可以，但比较复杂）而软链接都可以，<strong>因此软链接使用更加广泛</strong>。</p>
<p>这个部分暂时不展开。  </p>
<h2 id="2-二、用户与权限"><a href="#2-二、用户与权限" class="headerlink" title="2 二、用户与权限"></a>2 二、用户与权限</h2><blockquote>
<p>用户</p>
</blockquote>
<p>Linux 是一个多用户的操作系统。在 Linux 中，理论上来说，我们可以创建无数个用户，但是这些用户是被划分到不同的群组里面的，有一个用户，名叫 root ，是一个很特殊的用户，它是超级用户，拥有最高权限。</p>
<h3 id="2-1-sudo"><a href="#2-1-sudo" class="headerlink" title="2.1 sudo"></a>2.1 <strong>sudo</strong></h3><p><strong>以 root 身份运行命令</strong></p>
<h3 id="2-2-useradd-passwd"><a href="#2-2-useradd-passwd" class="headerlink" title="2.2 useradd + passwd"></a>2.2 <strong>useradd + passwd</strong></h3><ul>
<li>useradd 添加新用户</li>
<li>passwd 修改用户密码</li>
</ul>
<p>这两个命令需要 root 用户权限</p>
<h3 id="2-3-userdel"><a href="#2-3-userdel" class="headerlink" title="2.3 userdel"></a>2.3 <strong>userdel</strong></h3><p><strong>删除用户，需要 root 用户权限</strong></p>
<h3 id="2-4-su"><a href="#2-4-su" class="headerlink" title="2.4 su"></a>2.4 <strong>su</strong></h3><p><strong>切换用户</strong>，需要 root 用户权限</p>
<blockquote>
<p>群组的管理</p>
</blockquote>
<p>Linux 中每个用户都属于一个特定的群组，如果你不设置用户的群组，默认会创建一个和它的用户名一样的群组，并且把用户划归到这个群组。</p>
<h3 id="2-5-groupadd"><a href="#2-5-groupadd" class="headerlink" title="2.5 groupadd"></a>2.5 <strong>groupadd</strong></h3><p><strong>创建群组，</strong>用法和 useradd 类似</p>
<h3 id="2-6-groupdel"><a href="#2-6-groupdel" class="headerlink" title="2.6 groupdel"></a>2.6 <strong>groupdel</strong></h3><p><strong>删除一个已存在的群组</strong></p>
<h3 id="2-7-groups"><a href="#2-7-groups" class="headerlink" title="2.7 groups"></a>2.7 <strong>groups</strong></h3><p><strong>查看用户所在群组</strong></p>
<h3 id="2-8-usermod"><a href="#2-8-usermod" class="headerlink" title="2.8 usermod"></a>2.8 <strong>usermod</strong></h3><p><strong>用于修改用户的账户。</strong></p>
<p>【常用参数】</p>
<ul>
<li>-l 对用户重命名。需要注意的是 /home 中的用户家目录的名字不会改变，需要手动修改。</li>
<li>-g 修改用户所在的群组，例如 usermod -g friends lion修改 lion 用户的群组为 friends 。</li>
<li>-G 一次性让用户添加多个群组，例如 usermod -G friends,foo,bar lion 。</li>
<li>-a -G 会让你离开原先的群组，如果你不想这样做的话，就得再添加 -a 参数，意味着append 追加的意思。  </li>
</ul>
<h3 id="2-9-chgrp"><a href="#2-9-chgrp" class="headerlink" title="2.9 chgrp"></a>2.9 <strong>chgrp</strong></h3><p><strong>用于修改文件的群组。</strong></p>
<h3 id="2-10-chown"><a href="#2-10-chown" class="headerlink" title="2.10 chown"></a>2.10 <strong>chown</strong></h3><p><strong>改变文件的所有者</strong>，需要 root 身份才能运行。</p>
<p>【常用参数】</p>
<ul>
<li>-R 递归设置子目录和子文件， chown -R lion:lion /home/frank 把 frank 文件夹的用户和群组都改为 lion 。</li>
</ul>
<blockquote>
<p>文件权限管理</p>
</blockquote>
<h3 id="2-11-chmod"><a href="#2-11-chmod" class="headerlink" title="2.11 chmod"></a>2.11 <strong>chmod</strong></h3><p><strong>修改访问权限。</strong></p>
<p>【常用参数】</p>
<ul>
<li>-R 可以递归地修改文件访问权限，例如 chmod -R 777 /home/lion</li>
</ul>
<p>其中 drwxr-xr-x 表示文件或目录的权限。让我们一起来解读它具体代表什么？</p>
<ul>
<li>d ：表示目录，就是说这是一个目录，普通文件是 - ，链接是 l 。</li>
<li>r ：read 表示文件可读。</li>
<li>w ：write 表示文件可写，一般有写的权限，就有删除的权限。</li>
<li>x ：execute 表示文件可执行。</li>
<li><ul>
<li>：表示没有相应权限。</li>
</ul>
</li>
</ul>
<p>现在再来理解这句权限 drwxr-xr-x 的意思：</p>
<ul>
<li>它是一个文件夹；</li>
<li>它的所有者具有：读、写、执行权限；</li>
<li>它的群组用户具有：读、执行的权限，没有写的权限；</li>
<li>它的其它用户具有：读、执行的权限，没有写的权限。  </li>
</ul>
<p>现在理解了权限，我们使用 chmod 来尝试修改权限。chmod 它不需要是 root 用户才能运行的，只要你是此文件所有者，就可以用 chmod 来修改文件的访问权限。</p>
<p><img src="https://pic1.zhimg.com/80/v2-419fd37f2018837b1ffd75925e24901e_1440w.webp?source=1940ef5c" alt=""></p>
<p>chmod 640 hello.c</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>6 = 4 + 2 + 0 表示所有者具有 rw 权限</p>
<p>4 = 4 + 0 + 0 表示群组用户具有 r 权限</p>
<p>0 = 0 + 0 + 0 表示其它用户没有权限</p>
<p>对应文字权限为：-rw-r——-</p>
<h3 id="0-1-用字母来分配权限"><a href="#0-1-用字母来分配权限" class="headerlink" title="0.1 用字母来分配权限"></a>0.1 用字母来分配权限</h3><ul>
<li>u ：user 的缩写，用户的意思，表示所有者。</li>
<li>g ：group 的缩写，群组的意思，表示群组用户。</li>
<li>o ：other 的缩写，其它的意思，表示其它用户。</li>
<li>a ：all 的缩写，所有的意思，表示所有用户。</li>
<li><ul>
<li>：加号，表示添加权限。</li>
</ul>
</li>
<li><ul>
<li>：减号，表示去除权限。</li>
</ul>
</li>
<li>= ：等于号，表示分配权限。</li>
</ul>
<p>chmod u+rx file —&gt; 文件file的所有者增加读和运行的权限</p>
<p>chmod g+r file —&gt; 文件file的群组用户增加读的权限</p>
<p>chmod o-r file—&gt; 文件file的其它用户移除读的权限</p>
<p>chmod g+r file —&gt; 文件file的群组用户增加读的权限，其它用户移除读的权限</p>
<p>chmod go-r file —&gt; 文件file的群组和其他用户移除读的权限</p>
<p>chmod +x file —&gt; 文件file的所有用户增加运行的权限</p>
<p>chmod u=rwx,g=r,o=- file —&gt; 文件file的所有者分配读写和执行的权限，群组其它用户分配读的权限，其他用户没有任何权限</p>
<h2 id="1-三、查找文件"><a href="#1-三、查找文件" class="headerlink" title="1 三、查找文件"></a>1 三、查找文件</h2><h3 id="1-1-locate"><a href="#1-1-locate" class="headerlink" title="1.1 locate"></a>1.1 <strong>locate</strong></h3><p><strong>搜索包含关键字的所有文件和目录。后接需要查找的文件名，也可以用正则表达式。</strong></p>
<h3 id="1-2-安装-locate"><a href="#1-2-安装-locate" class="headerlink" title="1.2 安装 locate"></a>1.2 安装 locate</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install mlocate --&gt; 安装包updatedb --&gt; 更新数据库复制代码locate file.txtlocate fil*.txt</span><br></pre></td></tr></table></figure>
<p>[注意] locate 命令会去<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E5%BA%93&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">文件数据库</a>中查找命令，而不是全磁盘查找，因此刚创建的文件并不会更新到数据库中，所以无法被查找到，可以执行 updatedb 命令去更新数据库。</p>
<blockquote>
<p>find</p>
</blockquote>
<p>用于查找文件，它会去遍历你的实际硬盘进行查找，而且它允许我们对每个找到的文件进行后续操作，功能非常强大。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &lt;何处&gt; &lt;何物&gt; &lt;做什么&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>何处：指定在哪个目录查找，此目录的所有子目录也会被查找。</li>
<li>何物：查找什么，可以根据文件的名字来查找，也可以根据其大小来查找，还可以根据其最近访问时间来查找。</li>
<li>做什么：找到文件后，可以进行后续处理，如果不指定这个参数， find 命令只会显示找到的文件。  </li>
</ul>
<h3 id="1-3-根据文件名查找"><a href="#1-3-根据文件名查找" class="headerlink" title="1.3 根据文件名查找"></a>1.3 <strong>根据文件名查找</strong></h3><p>find -name “file.txt” —&gt; 当前目录以及子目录下通过名称查找文件</p>
<p>find . -name “syslog” —&gt; 当前目录以及子目录下通过名称查找文件</p>
<p>find / -name “syslog” —&gt; 整个硬盘下查找syslog</p>
<p>find /var/log -name “syslog” —&gt; 在指定的目录/var/log下查找syslog文件find /var/log -name “syslog*” —&gt; 查找syslog1、syslog2 … 等文件，通配符表示所有</p>
<p>find /var/log -name “<em>syslog</em>“ —&gt; 查找包含syslog的文件</p>
<p>[注意] find 命令只会查找完全符合 “何物” 字符串的文件，而 locate 会查找所有包含关键字的文件。</p>
<h3 id="1-4-根据文件大小查找"><a href="#1-4-根据文件大小查找" class="headerlink" title="1.4 根据文件大小查找"></a>1.4 <strong>根据文件大小查找</strong></h3><p>find /var -size +10M —&gt; /var 目录下查找文件大小超过 10M 的文件</p>
<p>find /var -size -50k —&gt; /var 目录下查找文件大小小于 50k 的文件</p>
<p>find /var -size +1G —&gt; /var 目录下查找文件大小查过 1G 的文件</p>
<p>find /var -size 1M —&gt; /var 目录下查找文件大小等于 1M 的文件</p>
<h3 id="1-5-根据文件最近访问时间查找"><a href="#1-5-根据文件最近访问时间查找" class="headerlink" title="1.5 根据文件最近访问时间查找"></a>1.5 <strong>根据文件最近访问时间查找</strong></h3><p>find -name “*.txt” -atime -7</p>
<p>—&gt; 近 7天内访问过的.txt结尾的文件</p>
<h3 id="1-6-仅查找目录或文件-根据类型查找"><a href="#1-6-仅查找目录或文件-根据类型查找" class="headerlink" title="1.6 仅查找目录或文件,根据类型查找"></a>1.6 <strong>仅查找目录或文件,根据类型查找</strong></h3><p>find . -name “file” -type f</p>
<p>—&gt; 只查找当前目录下的file文件</p>
<p>find . -name “file” -type d</p>
<p>—&gt; 只查找当前目录下的file目录</p>
<blockquote>
<p>软件仓库</p>
</blockquote>
<p>Linux 下软件是以包的形式存在，一个软件包其实就是软件的所有文件的压缩包，是二进制的形式，包含了安装软件的所有指令。Red Hat 家族的软件包后缀名一般为 .rpm ，Debian 家族的软件包后缀是 .deb 。</p>
<p>Linux 的包都存在一个仓库，叫做软件仓库，它可以使用 yum 来管理软件包， yum 是 CentOS 中默认的包管理工具，适用于 Red Hat 一族。可以理解成 Node.js 的 npm 。</p>
<blockquote>
<p>yum 常用命令</p>
</blockquote>
<ul>
<li>yum update | yum upgrade 更新软件包</li>
<li>yum search xxx 搜索相应的软件包</li>
<li>yum install xxx 安装软件包</li>
<li>yum remove xxx 删除软件包</li>
</ul>
<h2 id="2-四、文本操作"><a href="#2-四、文本操作" class="headerlink" title="2 四、文本操作"></a>2 四、文本操作</h2><blockquote>
<p>grep</p>
</blockquote>
<p><strong>全局搜索一个正则表达式，并且打印到屏幕。简单来说就是，在文件中查找关键字，并显示关键字所在行。</strong></p>
<h3 id="2-1-基础语法"><a href="#2-1-基础语法" class="headerlink" title="2.1 基础语法"></a>2.1 基础语法</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep text file # text代表要搜索的文本，file代表供搜索的文件</span><br></pre></td></tr></table></figure>
<h3 id="2-2-常用参数"><a href="#2-2-常用参数" class="headerlink" title="2.2 常用参数"></a>2.2 常用参数</h3><ul>
<li>-i 忽略大小写， grep -i path /etc/profile</li>
<li>-n 显示行号，grep -n path /etc/profile</li>
<li>-v 只显示搜索文本不在的那些行，grep -v path /etc/profile</li>
<li>-r 递归查找， grep -r hello /etc ，Linux 中还有一个 rgrep 命令，作用相当于 grep -r</li>
</ul>
<h3 id="2-3-sort"><a href="#2-3-sort" class="headerlink" title="2.3 sort"></a>2.3 sort</h3><p><strong>对文件的行进行排序。</strong></p>
<h3 id="2-4-基础语法"><a href="#2-4-基础语法" class="headerlink" title="2.4 基础语法"></a>2.4 基础语法</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort name.txt # 对name.txt文件进行排序</span><br></pre></td></tr></table></figure>
<h3 id="2-5-实例用法"><a href="#2-5-实例用法" class="headerlink" title="2.5 实例用法"></a>2.5 实例用法</h3><p>为了演示方便，我们首先创建一个文件 name.txt ，放入以下内容：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChristopherShawnTedRockNoahZacharyBella</span><br></pre></td></tr></table></figure>
<p>执行 sort name.txt 命令，会对文本内容进行排序。</p>
<h3 id="2-6-常用参数"><a href="#2-6-常用参数" class="headerlink" title="2.6 常用参数"></a>2.6 常用参数</h3><ul>
<li>-o 将排序后的文件写入新文件， sort -o name_sorted.txt name.txt ；</li>
<li>-r 倒序排序， sort -r name.txt ；</li>
<li>-R 随机排序， sort -R name.txt ；</li>
<li>-n 对数字进行排序，默认是把数字识别成字符串的，因此 138 会排在 25 前面，如果添加了 -n 数字排序的话，则 25 会在 138 前面。</li>
</ul>
<h3 id="2-7-wc"><a href="#2-7-wc" class="headerlink" title="2.7 wc"></a>2.7 wc</h3><p><strong>word count 的缩写，用于文件的统计。它可以统计单词数目、行数、字符数，字节数等。</strong></p>
<h3 id="2-8-基础语法"><a href="#2-8-基础语法" class="headerlink" title="2.8 基础语法"></a>2.8 基础语法</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc name.txt # 统计name.txt</span><br></pre></td></tr></table></figure>
<h3 id="2-9-实例用法"><a href="#2-9-实例用法" class="headerlink" title="2.9 实例用法"></a>2.9 实例用法</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@lion ~]# wc name.txt 13 13 91 name.txt</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个13，表示行数；</li>
<li>第二个13，表示单词数；</li>
<li>第三个91，表示字节数。</li>
</ul>
<h3 id="2-10-常用参数"><a href="#2-10-常用参数" class="headerlink" title="2.10 常用参数"></a>2.10 常用参数</h3><ul>
<li>-l 只统计行数， wc -l name.txt ；</li>
<li>-w 只统计单词数， wc -w name.txt ；</li>
<li>-c 只统计字节数， wc -c name.txt ；</li>
<li>-m 只统计字符数， wc -m name.txt 。  </li>
</ul>
<h3 id="2-11-uniq"><a href="#2-11-uniq" class="headerlink" title="2.11 uniq"></a>2.11 uniq</h3><p><strong>删除文件中的重复内容。</strong></p>
<h3 id="2-12-基础语法"><a href="#2-12-基础语法" class="headerlink" title="2.12 基础语法"></a>2.12 基础语法</h3><p>uniq name.txt # 去除name.txt重复的行数，并打印到屏幕上</p>
<p>【注意】它只能去除连续重复的行数。</p>
<h3 id="2-13-常用参数"><a href="#2-13-常用参数" class="headerlink" title="2.13 常用参数"></a>2.13 常用参数</h3><ul>
<li>-c 统计重复行数， uniq -c name.txt ；</li>
<li>-d 只显示重复的行数， uniq -d name.txt 。  </li>
</ul>
<h3 id="2-14-cut"><a href="#2-14-cut" class="headerlink" title="2.14 cut"></a>2.14 <strong>cut</strong></h3><p><strong>剪切文件的一部分内容。</strong></p>
<h3 id="2-15-基础语法"><a href="#2-15-基础语法" class="headerlink" title="2.15 基础语法"></a>2.15 基础语法</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut -c 2-4 name.txt # 剪切每一行第二到第四个字符</span><br></pre></td></tr></table></figure>
<h3 id="2-16-常用参数"><a href="#2-16-常用参数" class="headerlink" title="2.16 常用参数"></a>2.16 常用参数</h3><ul>
<li>-d 用于指定用什么分隔符（比如逗号、分号、双引号等等） cut -d , name.txt ；</li>
<li>-f 表示剪切下用分隔符分割的哪一块或哪几块区域， cut -d , -f 1 name.txt 。  </li>
</ul>
<h2 id="3-五、重定向-管道-流"><a href="#3-五、重定向-管道-流" class="headerlink" title="3 五、重定向 管道 流"></a>3 五、重定向 管道 流</h2><p>在 Linux 中一个命令的去向可以有3个地方：终端、文件、作为另外一个命令的入参。</p>
<p>命令一般都是通过键盘输入，然后输出到终端、文件等地方，它的标准用语是 stdin 、 stdout 以及 stderr 。</p>
<ul>
<li>标准输入 stdin ，终端接收键盘输入的命令，会产生两种输出；</li>
<li>标准输出 stdout ，终端输出的信息（不包含错误信息）；</li>
<li>标准错误输出 stderr ，终端输出的错误信息。</li>
</ul>
<h3 id="3-1-重定向"><a href="#3-1-重定向" class="headerlink" title="3.1 重定向"></a>3.1 重定向</h3><p>把本来要显示在终端的命令结果，输送到别的地方（到文件中或者作为其他命令的输入）。</p>
<h3 id="3-2-输出重定向-gt"><a href="#3-2-输出重定向-gt" class="headerlink" title="3.2 输出重定向 &gt;"></a>3.2 <strong>输出重定向 &gt;</strong></h3><blockquote>
<p>表示重定向到新的文件， cut -d , -f 1 notes.csv &gt; name.csv ，它表示通过逗号剪切notes.csv 文件（剪切完有3个部分）获取第一个部分，重定向到 name.csv 文件。</p>
</blockquote>
<p>我们来看一个具体示例，学习它的使用，假设我们有一个文件 notes.csv ，文件内容如下：</p>
<p>Mark1,951/100,很不错1Mark2,952/100,很不错2Mark3,</p>
<p>953/100,很不错3Mark4,954/100,很不错4Mark5,955/100,很不错5Mark6,956/100,很不错6</p>
<p>执行命令：cut -d , -f 1 notes.csv &gt; name.csv 最后输出如下内容：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mark1Mark2Mark3Mark4Mark5Mark6</span><br></pre></td></tr></table></figure>
<p>【注意】使用 &gt; 要注意，如果输出的文件不存在它会新建一个，如果输出的文件已经存在，则会覆盖。因此执行这个操作要非常小心，以免覆盖其它重要文件。</p>
<h3 id="3-3-输出重定向-gt-gt"><a href="#3-3-输出重定向-gt-gt" class="headerlink" title="3.3 输出重定向 &gt;&gt;"></a>3.3 <strong>输出重定向 &gt;&gt;</strong></h3><p>表示重定向到文件末尾，因此它不会像 &gt; 命令这么危险，它是追加到文件的末尾（当然如果文件不存在，也会被创建）。</p>
<p>再次执行 cut -d , -f 1 notes.csv &gt;&gt; name.csv ，则会把名字追加到 name.csv 里面。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mark1Mark2Mark3Mark4Mark5Mark6Mark1Mark2Mark3Mark4Mark5Mark6</span><br></pre></td></tr></table></figure>
<p>我们平时读的 log 日志文件其实都是用这个命令输出的。</p>
<h3 id="3-4-输出重定向-2-gt"><a href="#3-4-输出重定向-2-gt" class="headerlink" title="3.4 输出重定向 2&gt;"></a>3.4 <strong>输出重定向 2&gt;</strong></h3><p>标准错误输出</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat not_exist_file.csv &gt; res.txt 2&gt; errors.log</span><br></pre></td></tr></table></figure>
<ul>
<li>当我们 cat 一个文件时，会把文件内容打印到屏幕上，这个是标准输出；</li>
<li>当使用了 &gt; res.txt 时，则不会打印到屏幕，会把标准输出写入文件 res.txt 文件中；</li>
<li>2&gt; errors.log 当发生错误时会写入 errors.log 文件中。  </li>
</ul>
<h3 id="3-5-输出重定向-2-gt-gt"><a href="#3-5-输出重定向-2-gt-gt" class="headerlink" title="3.5 输出重定向 2&gt;&gt;"></a>3.5 <strong>输出重定向 2&gt;&gt;</strong></h3><p>标准错误输出（追加到文件末尾）同 &gt;&gt; 相似。</p>
<h3 id="3-6-输入重定向-lt"><a href="#3-6-输入重定向-lt" class="headerlink" title="3.6 输入重定向 &lt;"></a>3.6 <strong>输入重定向 &lt;</strong></h3><p>&lt; 符号用于指定命令的输入。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &lt; name.csv # 指定命令的输入为 name.csv</span><br></pre></td></tr></table></figure>
<p>虽然它的运行结果与 cat name.csv 一样，但是它们的原理却完全不同。</p>
<ul>
<li>cat name.csv 表示 cat 命令接收的输入是 notes.csv 文件名，那么要先打开这个文件，然后打印出文件内容。</li>
<li>cat &lt; name.csv 表示 cat 命令接收的输入直接是 notes.csv 这个文件的内容， cat命令只负责将其内容打印，打开文件并将文件内容传递给 cat 命令的工作则交给终端完成。  </li>
</ul>
<h3 id="3-7-输入重定向-lt-lt"><a href="#3-7-输入重定向-lt-lt" class="headerlink" title="3.7 输入重定向 &lt;&lt;"></a>3.7 <strong>输入重定向 &lt;&lt;</strong></h3><p>将键盘的输入重定向为某个命令的输入。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort -n &lt;&lt; END # 输入这个命令之后，按下回车，终端就进入键盘输入模式，其中END为结束命令（这个可以自定义）wc -m &lt;&lt; END # 统计输入的单词复</span><br></pre></td></tr></table></figure>
<h3 id="3-8-管道"><a href="#3-8-管道" class="headerlink" title="3.8 管道 |"></a>3.8 管道 |</h3><p>把两个命令连起来使用，一个命令的输出作为另外一个命令的输入，英文是 pipeline ，可以想象一个个水管连接起来，管道算是重定向流的一种。</p>
<p>举几个实际用法案例：</p>
<p>cut -d , -f 1 name.csv | sort &gt; sorted_name.txt</p>
<h1 id="第一步获取到的-name-列表，通过管道符再进行排序，最后输出到sorted-name-txt"><a href="#第一步获取到的-name-列表，通过管道符再进行排序，最后输出到sorted-name-txt" class="headerlink" title="第一步获取到的 name 列表，通过管道符再进行排序，最后输出到sorted_name.txt"></a>第一步获取到的 name 列表，通过管道符再进行排序，最后输出到sorted_name.txt</h1><p>du | sort -nr | head</p>
<h1 id="du-表示列举目录大小信息-sort-进行排序-n-表示按数字排序，-r-表示倒序-head-前10行文件"><a href="#du-表示列举目录大小信息-sort-进行排序-n-表示按数字排序，-r-表示倒序-head-前10行文件" class="headerlink" title="du 表示列举目录大小信息# sort 进行排序,-n 表示按数字排序，-r 表示倒序# head 前10行文件"></a>du 表示列举目录大小信息# sort 进行排序,-n 表示按数字排序，-r 表示倒序# head 前10行文件</h1><p>grep log -Ir /var/log | cut -d : -f 1 | sort | uniq</p>
<h1 id="grep-log-Ir-var-log-表示在log文件夹下搜索-var-log-文本，-r-表示递归，-I-用于排除二进制文件-cut-d-f-1-表示通过冒号进行剪切，获取剪切的第一部分-sort-进行排序-uniq-进行去重复制代码"><a href="#grep-log-Ir-var-log-表示在log文件夹下搜索-var-log-文本，-r-表示递归，-I-用于排除二进制文件-cut-d-f-1-表示通过冒号进行剪切，获取剪切的第一部分-sort-进行排序-uniq-进行去重复制代码" class="headerlink" title="grep log -Ir /var/log 表示在log文件夹下搜索 /var/log 文本，-r 表示递归，-I 用于排除二进制文件# cut -d : -f 1 表示通过冒号进行剪切，获取剪切的第一部分# sort 进行排序# uniq 进行去重复制代码"></a>grep log -Ir /var/log 表示在log文件夹下搜索 /var/log 文本，-r 表示递归，-I 用于排除二进制文件# cut -d : -f 1 表示通过冒号进行剪切，获取剪切的第一部分# sort 进行排序# uniq 进行去重复制代码</h1><h2 id="1-六、查看进程"><a href="#1-六、查看进程" class="headerlink" title="1 六、查看进程"></a>1 六、查看进程</h2><p>在 Windows 中通过 Ctrl + Alt + Delete 快捷键查看软件进程。</p>
<h3 id="1-1-w"><a href="#1-1-w" class="headerlink" title="1.1 w"></a>1.1 <strong>w</strong></h3><p><strong>帮助我们快速了解系统中目前有哪些用户登录着，以及他们在干什么。</strong></p>
<h3 id="1-2-ps"><a href="#1-2-ps" class="headerlink" title="1.2 ps"></a>1.2 <strong>ps</strong></h3><p><strong>用于显示当前系统中的进程， ps 命令显示的进程列表不会随时间而更新，是静态的，是运行 ps 命令那个时刻的状态或者说是一个进程快照。</strong></p>
<h3 id="1-3-常用参数"><a href="#1-3-常用参数" class="headerlink" title="1.3 常用参数"></a>1.3 常用参数</h3><ul>
<li>-ef 列出所有进程;</li>
<li>-efH 以乔木状列举出所有进程;</li>
<li>-u 列出此用户运行的进程;</li>
<li>-aux 通过 CPU 和内存使用来过滤进程 ps -aux | less ;</li>
<li>-aux —sort -pcpu 按 CPU 使用降序排列， -aux —sort -pmem 表示按内存使用降序排列;</li>
<li>-axjf 以树形结构显示进程， ps -axjf 它和 pstree 效果类似。  </li>
</ul>
<h3 id="1-4-top"><a href="#1-4-top" class="headerlink" title="1.4 top"></a>1.4 top</h3><p><strong>获取进程的动态列表。</strong></p>
<h3 id="1-5-kill"><a href="#1-5-kill" class="headerlink" title="1.5 kill"></a>1.5 <strong>kill</strong></h3><p><strong>结束一个进程， kill + PID 。</strong></p>
<h2 id="2-七、管理进程"><a href="#2-七、管理进程" class="headerlink" title="2 七、管理进程"></a>2 七、管理进程</h2><h3 id="2-1-进程状态"><a href="#2-1-进程状态" class="headerlink" title="2.1 进程状态"></a>2.1 进程状态</h3><p>主要是切换进程的状态。我们先了解下 Linux 下进程的五种状态：</p>
<ol>
<li>状态码 R ：表示正在运行的状态；</li>
<li>状态码 S ：表示中断（休眠中，受阻，当某个条件形成后或接受到信号时，则脱离该状态）；</li>
<li>状态码 D ：表示不可中断（进程不响应系统异步信号，即使用kill命令也不能使其中断）；</li>
<li>状态码 Z ：表示僵死（进程已终止，但进程描述符依然存在，直到父进程调用 wait4()<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">系统函数</a>后将进程释放）；</li>
<li>状态码 T ：表示停止（进程收到 SIGSTOP 、 SIGSTP 、 SIGTIN 、 SIGTOU 等停止信号后停止运行）。  </li>
</ol>
<h3 id="2-2-前台进程-amp-后台进程"><a href="#2-2-前台进程-amp-后台进程" class="headerlink" title="2.2 前台进程 &amp; 后台进程"></a>2.2 前台进程 &amp; 后台进程</h3><p>默认情况下，用户创建的进程都是前台进程，前台进程从键盘读取数据，并把处理结果输出到显示器。例如运行 top 命令，这就是一个一直运行的前台进程。</p>
<p>后台进程的优点是不必等待程序运行结束，就可以输入其它命令。在需要执行的命令后面添加&amp; 符号，就表示启动一个后台进程。</p>
<h3 id="2-3-amp"><a href="#2-3-amp" class="headerlink" title="2.3 &amp;"></a>2.3 &amp;</h3><p>启动后台进程，它的缺点是后台进程与终端相关联，一旦关闭终端，进程就自动结束了。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp name.csv name-copy.csv &amp;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-nohup"><a href="#2-4-nohup" class="headerlink" title="2.4 nohup"></a>2.4 nohup</h3><p>使进程不受挂断（关闭终端等动作）的影响。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup cp name.csv name-copy.csv</span><br></pre></td></tr></table></figure>
<p>nohup 命令也可以和 &amp; 结合使用。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup cp name.csv name-copy.csv &amp;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-bg"><a href="#2-5-bg" class="headerlink" title="2.5 bg"></a>2.5 bg</h3><p>使一个”后台暂停运行”的进程，状态改为”后台运行”。</p>
<h3 id="2-6-jobs"><a href="#2-6-jobs" class="headerlink" title="2.6 jobs"></a>2.6 jobs</h3><p>显示当前终端后台进程状态。</p>
<h3 id="2-7-fg"><a href="#2-7-fg" class="headerlink" title="2.7 fg"></a>2.7 fg</h3><p>fg 使进程转为前台运行，用法和 bg 命令类似。</p>
<p>我们用一张图来表示前后台进程切换：</p>
<p><img src="https://pic1.zhimg.com/80/v2-fda7a2872cecb93215a9b88f9ae71a29_1440w.webp?source=1940ef5c" alt=""></p>
<p>我们可以使程序在后台运行，成为后台进程，这样在当前终端中我们就可以做其他事情了，而不必等待此进程运行结束。</p>
<h2 id="3-八、文件压缩解压"><a href="#3-八、文件压缩解压" class="headerlink" title="3 八、文件压缩解压"></a>3 八、文件压缩解压</h2><ul>
<li>打包：是将多个文件变成一个总的文件，它的学名叫存档、归档。</li>
<li>压缩：是将一个大文件（通常指归档）压缩变成一个小文件。  </li>
</ul>
<p>我们常常使用 tar 将多个文件归档为一个总的文件，称为 archive 。然后用 gzip 或 bzip2 命令将 archive 压缩为更小的文件。</p>
<h3 id="3-1-tar"><a href="#3-1-tar" class="headerlink" title="3.1 tar"></a>3.1 <strong>tar</strong></h3><p><strong>创建一个 tar 归档。</strong></p>
<h3 id="3-2-基础用法"><a href="#3-2-基础用法" class="headerlink" title="3.2 基础用法"></a>3.2 基础用法</h3><p>tar -cvf sort.tar sort/</p>
<h1 id="将sort文件夹归档为sort-tar"><a href="#将sort文件夹归档为sort-tar" class="headerlink" title="将sort文件夹归档为sort.tar"></a>将sort文件夹归档为sort.tar</h1><p>tar -cvf archive.tar file1 file2 file3</p>
<h1 id="将-file1-file2-file3-归档为archive-tar复制代码"><a href="#将-file1-file2-file3-归档为archive-tar复制代码" class="headerlink" title="将 file1 file2 file3 归档为archive.tar复制代码"></a>将 file1 file2 file3 归档为archive.tar复制代码</h1><h3 id="0-1-常用参数"><a href="#0-1-常用参数" class="headerlink" title="0.1 常用参数"></a>0.1 常用参数</h3><ul>
<li>-cvf 表示 create（创建）+ verbose（细节）+ file（文件），创建归档文件并显示操作细节；</li>
<li>-tf 显示归档里的内容，并不解开归档；</li>
<li>-rvf 追加文件到归档， tar -rvf archive.tar file.txt ；</li>
<li>-xvf 解开归档， tar -xvf archive.tar 。</li>
</ul>
<h3 id="0-2-gzip-gunzip"><a href="#0-2-gzip-gunzip" class="headerlink" title="0.2 gzip / gunzip"></a>0.2 gzip / gunzip</h3><p>“压缩/解压”归档，默认用 gzip 命令，压缩后的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80%E5%90%8D&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">文件后缀名</a>为 .tar.gz 。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip archive.tar # 压缩gunzip archive.tar.gz # 解压</span><br></pre></td></tr></table></figure>
<h3 id="0-3-tar-归档-压缩"><a href="#0-3-tar-归档-压缩" class="headerlink" title="0.3 tar 归档+压缩"></a>0.3 tar 归档+压缩</h3><p>可以用 tar 命令同时完成归档和压缩的操作，就是给 tar 命令多加一个选项参数，使之完成归档操作后，还是调用 gzip 或 bzip2 命令来完成压缩操作。</p>
<p>tar -zcvf archive.tar.gz archive/ # 将archive文件夹归档并压缩</p>
<p>tar -zxvf archive.tar.gz # 将archive.tar.gz归档压缩文件解压</p>
<h3 id="0-4-zcat、zless、zmore"><a href="#0-4-zcat、zless、zmore" class="headerlink" title="0.4 zcat、zless、zmore"></a>0.4 zcat、zless、zmore</h3><p>之前讲过使用 cat less more 可以查看文件内容，但是压缩文件的内容是不能使用这些命令进行查看的，而要使用 zcat、zless、zmore 进行查看。</p>
<p>zcat archive.tar.gz</p>
<h3 id="0-5-zip-unzip"><a href="#0-5-zip-unzip" class="headerlink" title="0.5 zip/unzip"></a>0.5 zip/unzip</h3><p>“压缩/解压” zip 文件（ zip 压缩文件一般来自 windows 操作系统）。</p>
<h3 id="0-6-命令安装"><a href="#0-6-命令安装" class="headerlink" title="0.6 命令安装"></a>0.6 命令安装</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Red Hat 一族中的安装方式yum install zip yum install unzip 复制代码</span><br></pre></td></tr></table></figure>
<h3 id="0-7-基础用法"><a href="#0-7-基础用法" class="headerlink" title="0.7 基础用法"></a>0.7 基础用法</h3><p>unzip archive.zip</p>
<h1 id="解压-zip-文件"><a href="#解压-zip-文件" class="headerlink" title="解压 .zip 文件"></a>解压 .zip 文件</h1><p>unzip -l archive.zip</p>
<h1 id="不解开-zip-文件，只看其中内容"><a href="#不解开-zip-文件，只看其中内容" class="headerlink" title="不解开 .zip 文件，只看其中内容"></a>不解开 .zip 文件，只看其中内容</h1><p>zip -r sort.zip sort/</p>
<h1 id="将sort文件夹压缩为-sort-zip，其中-r表示递归"><a href="#将sort文件夹压缩为-sort-zip，其中-r表示递归" class="headerlink" title="将sort文件夹压缩为 sort.zip，其中-r表示递归"></a>将sort文件夹压缩为 sort.zip，其中-r表示递归</h1><h3 id="0-1-编译安装"><a href="#0-1-编译安装" class="headerlink" title="0.1 编译安装"></a>0.1 编译安装</h3><p>简单来说，编译就是将程序的源代码转换成可执行文件的过程。大多数 Linux 的程序都是开放源码的，可以编译成适合我们的电脑和操纵系统属性的可执行文件。</p>
<p>基本步骤如下：</p>
<ol>
<li>下载源代码</li>
<li>解压压缩包</li>
<li>配置</li>
<li>编译</li>
<li>安装  </li>
</ol>
<h3 id="0-2-实际案例"><a href="#0-2-实际案例" class="headerlink" title="0.2 实际案例"></a>0.2 实际案例</h3><h3 id="0-3-1、下载"><a href="#0-3-1、下载" class="headerlink" title="0.3 1、下载"></a>0.3 1、下载</h3><p>我们来编译安装 htop 软件，首先在它的官网下载源码：<strong><a href="https://link.zhihu.com/?target=http%3A//bintray.com/htop/source">http://bintray.com/htop/source</a>…</strong>[1]</p>
<p>下载好的源码在本机电脑上使用如下命令同步到服务器上：</p>
<p>scp 文件名 用户名@服务器ip:目标路径</p>
<p>scp ~/Desktop/htop-3.0.0.tar.gz root@121.42.11.34:.</p>
<p>也可以使用 wegt 进行下载：</p>
<p>wegt+下载地址</p>
<p>wegt <a href="https://link.zhihu.com/?target=https%3A//bintray.com/htop/source/download_file%3Ffile_path%3Dhtop-3.0.0.tar.gz">https://bintray.com/htop/source/download_file?file_path=htop-3.0.0.tar.gz</a></p>
<h3 id="0-4-2、解压文件"><a href="#0-4-2、解压文件" class="headerlink" title="0.4 2、解压文件"></a>0.4 2、解压文件</h3><p>tar -zxvf htop-3.0.0.tar.gz</p>
<h1 id="解压cd-htop-3-0-0-进入目录"><a href="#解压cd-htop-3-0-0-进入目录" class="headerlink" title="解压cd htop-3.0.0 # 进入目录"></a>解压cd htop-3.0.0 # 进入目录</h1><h3 id="0-1-3、配置"><a href="#0-1-3、配置" class="headerlink" title="0.1 3、配置"></a>0.1 3、配置</h3><p>执行 ./configure ，它会分析你的电脑去确认编译所需的工具是否都已经安装了。</p>
<h3 id="0-2-4、编译"><a href="#0-2-4、编译" class="headerlink" title="0.2 4、编译"></a>0.2 4、编译</h3><p>执行 make 命令</p>
<h3 id="0-3-5、安装"><a href="#0-3-5、安装" class="headerlink" title="0.3 5、安装"></a>0.3 5、安装</h3><p>执行 make install 命令，安装完成后执行 ls /usr/local/bin/ 查看是否有 htop 命令。如果有就可以执行 htop 命令查看系统进程了。</p>
<h2 id="1-九、网络"><a href="#1-九、网络" class="headerlink" title="1 九、网络"></a>1 九、网络</h2><h3 id="1-1-ifconfig"><a href="#1-1-ifconfig" class="headerlink" title="1.1 ifconfig"></a>1.1 <strong>ifconfig</strong></h3><p><strong>查看 ip 网络相关信息，如果命令不存在的话， 执行命令 yum install net-tools 安装。</strong></p>
<p>参数解析：</p>
<ul>
<li><p>eth0 对应有线连接（对应你的有线网卡），就是用网线来连接的上网。eth 是 Ethernet 的缩写，表示”<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BB%A5%E5%A4%AA%E7%BD%91&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">以太网</a>“。有些电脑可能同时有好几条网线连着，例如服务器，那么除了eht0 ，你还会看到 eth1 、 eth2 等。  </p>
</li>
<li><p>lo 表示本地回环（ Local Loopback 的缩写，对应一个<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">虚拟网卡</a>）可以看到它的 ip 地址是 127.0.0.1 。每台电脑都应该有这个接口，因为它对应着”连向自己的链接”。这也是被称之为”本地回环”的原因。所有经由这个接口发送的东西都会回到你自己的电脑。看起来好像并没有什么用，但有时为了某些缘故，我们需要连接自己。例如用来测试一个网络程序，但又不想让局域网或外网的用户查看，只能在此台主机上运行和查看所有的网络接口。例如在我们启动一个前端工程时，在浏览器输入 127.0.0.1:3000 启动项目就能查看到自己的 web 网站，并且它只有你能看到。  </p>
</li>
<li><p>wlan0 表示无线局域网</p>
</li>
</ul>
<h3 id="1-2-host"><a href="#1-2-host" class="headerlink" title="1.2 host"></a>1.2 <strong>host</strong></h3><p><strong>ip 地址和主机名的互相转换。</strong></p>
<h3 id="1-3-ssh-连接远程服务器"><a href="#1-3-ssh-连接远程服务器" class="headerlink" title="1.3 ssh 连接远程服务器"></a>1.3 <strong>ssh 连接远程服务器</strong></h3><p><strong>通过<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">非对称加密</a>以及对称加密的方式（同 HTTPS 安全连接原理相似）连接到远端服务器。</strong></p>
<h3 id="1-4-h"><a href="#1-4-h" class="headerlink" title="1.4 *h"></a>1.4 <em>*</em>h</h3><p>config 文件可以<em>*</em>h ，方便批量管理多个 ssh 连接。</p>
<p>配置文件分为以下几种：</p>
<ul>
<li>全局 ssh 服务端的配置：/etc/ssh/sshd_config ；</li>
<li>全局 ssh 客户端的配置：/etc/ssh/ssh_config（很少修改）；</li>
<li>当前用户 ssh 客户端的<em>*</em>h/config 。</li>
</ul>
<p><img src="https://pica.zhimg.com/80/v2-6822a5b5868d9e08fb6d9fbae94b6661_1440w.webp?source=1940ef5c" alt=""></p>
<p>配置当前用户的 config ：</p>
<h1 id="创建config"><a href="#创建config" class="headerlink" title="创建config"></a>创建config</h1><p>vim ~/.ssh/config</p>
<h1 id="填写一下内容"><a href="#填写一下内容" class="headerlink" title="填写一下内容"></a>填写一下内容</h1><p>Host lion # 别名 HostName 172.x.x.x # ip 地址 Port 22 # 端口 User root # 用户</p>
<p>这样配置完成后，下次登录时，可以这样登录 ssh lion 会自动识别为 root 用户。</p>
<p>[注意] 这段配置不是在服务器上，而是你自己的机器上，它仅仅是设置了一个别名。</p>
<h3 id="0-1-wget"><a href="#0-1-wget" class="headerlink" title="0.1 wget"></a>0.1 wget</h3><p>可以使我们直接从终端控制台下载文件，只需要给出文件的HTTP或FTP地址。</p>
<h2 id="1-十-备份"><a href="#1-十-备份" class="headerlink" title="1 十 备份"></a>1 十 备份</h2><h3 id="1-1-scp"><a href="#1-1-scp" class="headerlink" title="1.1 scp"></a>1.1 scp</h3><p><strong>它是 Secure Copy 的缩写，表示安全拷贝。scp 可以使我们通过网络，把文件从一台电脑拷贝到另一台电脑。</strong></p>
<p>scp 是基于 ssh 的原理来运作的， ssh 会在两台通过网络连接的电脑之间创建一条安全通信的管道， scp 就利用这条管道安全地拷贝文件。</p>
<p>scp source_file destination_file</p>
<h1 id="source-file-表示源文件，destination-file-表示目标文件"><a href="#source-file-表示源文件，destination-file-表示目标文件" class="headerlink" title="source_file 表示源文件，destination_file 表示目标文件"></a>source_file 表示源文件，destination_file 表示目标文件</h1><p>其中 source_file 和 destination_file 都可以这样表示：user@ip:file_name ， user 是登录名， ip 是域名或 ip 地址。file_name 是文件路径。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp root@192.168.1.5:/root/file.txt file.txt # 表示把远程电脑上的 file.txt 文件拷贝到本机</span><br><span class="line">scp file.txt root@192.168.1.5:/root # 表示把我的电脑中当前文件夹下的 file.txt 文件拷贝到远程电脑</span><br></pre></td></tr></table></figure>
<h3 id="0-1-rsync"><a href="#0-1-rsync" class="headerlink" title="0.1 rsync"></a>0.1 rsync</h3><p>rsync 命令主要用于远程同步文件。它可以同步两个目录，不管它们是否处于同一台电脑。它应该是最常用于”<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">增量备份</a>“的命令了。它就是智能版的 scp 命令。</p>
<h3 id="0-2-软件安装"><a href="#0-2-软件安装" class="headerlink" title="0.2 软件安装"></a>0.2 软件安装</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install rsync复制代码</span><br></pre></td></tr></table></figure>
<h3 id="0-3-基础用法"><a href="#0-3-基础用法" class="headerlink" title="0.3 基础用法"></a>0.3 基础用法</h3><p>rsync -arv Images/ backups/</p>
<h1 id="将Images-目录下的所有文件备份到-backups-目录下"><a href="#将Images-目录下的所有文件备份到-backups-目录下" class="headerlink" title="将Images 目录下的所有文件备份到 backups 目录下"></a>将Images 目录下的所有文件备份到 backups 目录下</h1><p>rsync -arv Images/ root@192.x.x.x:backups/</p>
<h1 id="同步到服务器的backups目录下"><a href="#同步到服务器的backups目录下" class="headerlink" title="同步到服务器的backups目录下"></a>同步到服务器的backups目录下</h1><h3 id="0-1-常用参数-1"><a href="#0-1-常用参数-1" class="headerlink" title="0.1 常用参数"></a>0.1 常用参数</h3><ul>
<li>-a 保留文件的所有信息，包括权限，修改日期等；</li>
<li>-r 递归调用，表示子目录的所有文件也都包括；</li>
<li>-v 冗余模式，输出详细操作信息。</li>
</ul>
<p>默认地， rsync 在同步时并不会删除目标目录的文件，例如你在源目录中删除一个文件，但是用 rsync 同步时，它并不会删除同步目录中的相同文件。如果向删除也可以这么做：rsync -arv —delete Images/ backups/ 。</p>
<h2 id="1-十一-系统"><a href="#1-十一-系统" class="headerlink" title="1 十一 系统"></a>1 十一 系统</h2><h3 id="1-1-halt"><a href="#1-1-halt" class="headerlink" title="1.1 halt"></a>1.1 halt</h3><p>关闭系统，需要 root 身份。</p>
<h3 id="1-2-reboot"><a href="#1-2-reboot" class="headerlink" title="1.2 reboot"></a>1.2 reboot</h3><p>重启系统，需要 root 身份。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>
<h3 id="1-3-poweroff"><a href="#1-3-poweroff" class="headerlink" title="1.3 poweroff"></a>1.3 poweroff</h3><p>直接运行即可关机，不需要 root 身份。</p>
<h2 id="2-十二-Vim-编辑器"><a href="#2-十二-Vim-编辑器" class="headerlink" title="2 十二 Vim 编辑器"></a>2 十二 Vim 编辑器</h2><h2 id="3-Vim-是什么？"><a href="#3-Vim-是什么？" class="headerlink" title="3 Vim 是什么？"></a>3 Vim 是什么？</h2><p>Vim 是从 vi 发展出来的一个<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2717297135%7D">文本编辑器</a>。其代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。和 Emacs 并列成为类 Unix 系统用户最喜欢的编辑器。</p>
<h2 id="4-Vim-常用模式"><a href="#4-Vim-常用模式" class="headerlink" title="4 Vim 常用模式"></a>4 Vim 常用模式</h2><ul>
<li>交互模式</li>
<li>插入模式</li>
<li>命令模式</li>
<li>可视模式  </li>
</ul>
<h3 id="4-1-交互模式"><a href="#4-1-交互模式" class="headerlink" title="4.1 交互模式"></a>4.1 交互模式</h3><p>也成为正常模式，这是 Vim 的默认模式，每次运行 Vim 程序的时候，就会进入这个模式。</p>
<p>例如执行 vim name.txt 则会进入交互模式。</p>
<p>交互模式特征：</p>
<ul>
<li>在这个模式下，你不能输入文本；</li>
<li>它可以让我们在文本间移动，删除一行文本，复制黏贴文本，跳转到指定行，撤销操作，等等  </li>
</ul>
<h3 id="4-2-插入模式"><a href="#4-2-插入模式" class="headerlink" title="4.2 插入模式"></a>4.2 插入模式</h3><p>这个模式是我们熟悉的文本编辑器的模式，就是可以输入任何你想输入的内容。进入这个模式有几种方法，最常用的方法是按字母键 i （ i、I、a、A、o、O 都可以进入插入模式，只是所处的位置不同），退出这种模式，只需要按下 Esc 键。</p>
<ul>
<li>i, I 进入输入模式 Insert mode ：i 为”从目前光标所在处输入”， I 为”在目前所在行的第一个非空格符处开始输入”；</li>
<li>a, A 进入输入模式 Insert mode ：a 为”从目前光标所在的下一个字符处开始输入”，A 为”从光标所在行的最后一个字符处开始输入”；</li>
<li>o, O 进入输入模式 Insert mode ：o 为”在目前光标所在的下一行处输入新的一行”；O 为在目前光标所在处的上一行输入新的一行。</li>
</ul>
<h3 id="4-3"><a href="#4-3" class="headerlink" title="4.3"></a>4.3</h3><h3 id="4-4-命令模式"><a href="#4-4-命令模式" class="headerlink" title="4.4 命令模式"></a>4.4 命令模式</h3><p>命令模式也称为底线命令模式，这个模式下可以运行一些命令例如”退出”，”保存”，等动作。</p>
<p>也可以用这个模式来激活一些 Vim 配置，例如语法高亮，显示行号，等。甚至还可以发送一些命令给终端命令行，例如 ls、cp 。</p>
<p>为了进入命令模式，首先要进入交互模式，再按下冒号键。</p>
<p>用一张图表示三种模式如何切换：</p>
<p><img src="https://picx.zhimg.com/80/v2-ba2da86f7f9e710f75d2b52449458f07_1440w.webp?source=1940ef5c" alt=""></p>
<p>基本操作</p>
<h3 id="4-5-打开-Vim"><a href="#4-5-打开-Vim" class="headerlink" title="4.5 打开 Vim"></a>4.5 打开 Vim</h3><p>在终端命令行中输入 vim 回车后 Vim 就会被运行起来，也可以用 Vim 来打开一个文件，只需要在 vim 后面再加文件名。如 vim file.name ，如果文件不存在，那么会被创建。  </p>
<h3 id="4-6-插入"><a href="#4-6-插入" class="headerlink" title="4.6 插入"></a>4.6 插入</h3><p>进入文件之后，此时处于交互模式，可以通过输入 i 进入插入模式  </p>
<h3 id="4-7-移动"><a href="#4-7-移动" class="headerlink" title="4.7 移动"></a>4.7 移动</h3><p>在 Vim 的交互模式下，我们可以在文本中移动光标。</p>
<ul>
<li>h 向左移动一个字符</li>
<li>j 向下移动一个字符</li>
<li>k 向上移动一个字符</li>
<li>i 向右移动一个字符</li>
</ul>
<p>当然也可以使用四个方向键进行移动，效果是一样的。  </p>
<h3 id="4-8-跳至行首和行末"><a href="#4-8-跳至行首和行末" class="headerlink" title="4.8 跳至行首和行末"></a>4.8 跳至行首和行末</h3><ul>
<li>行首：在交互模式下，为了将光标定位到一行的开始位置，只需要按下数字键 0 即可，键盘上的 Home 键也有相同效果。</li>
<li>行末：在交互模式下，为了将光标定位到一行的末尾，只需要按下美元符号键 $ 即可，键盘上的 End 键也有相同效果。</li>
</ul>
<h3 id="4-9-按单词移动"><a href="#4-9-按单词移动" class="headerlink" title="4.9 按单词移动"></a>4.9 按单词移动</h3><p>在交互模式下，按字母键 w 可以一个单词一个单词的移动。</p>
<h3 id="4-10-退出文件"><a href="#4-10-退出文件" class="headerlink" title="4.10 退出文件"></a>4.10 退出文件</h3><p>在交互模式下，按下冒号键 : 进入命令模式，再按下 q 键，就可以退出了。</p>
<p>如果在退出之前又修改了文件，就直接想用 :q 退出 Vim ，那么 Vim 会显示一个红字标明错误信息。此时我们有两个选择：</p>
<ol>
<li>保存并退出 :wq 或 :x ；</li>
<li>不保存且退出 :q! 。</li>
</ol>
<h2 id="5-标准操作"><a href="#5-标准操作" class="headerlink" title="5 标准操作"></a>5 标准操作</h2><h3 id="5-1-删除字符"><a href="#5-1-删除字符" class="headerlink" title="5.1 删除字符"></a>5.1 删除字符</h3><p>在交互模式下，将光标定位到一个你想要删除的字符上，按下字母键 x 你会发现这个字符被删除了。</p>
<p>也可以一次性删除多个字符，只需要在按 x 键之前输入数字即可。  </p>
<h3 id="5-2-删除（剪切）单词，行"><a href="#5-2-删除（剪切）单词，行" class="headerlink" title="5.2 删除（剪切）单词，行"></a>5.2 删除（剪切）单词，行</h3><ul>
<li>删除一行：连按两次 d 来删除光标所在的那一行。</li>
<li>删除多行：例如先输入数字 2 ，再按下 dd ，就会删除从光标所在行开始的两行。</li>
<li>删除一个单词：将光标置于一个单词的首字母处，然后按下 dw 。</li>
<li>删除多个单词：例如先按数字键 2 再按 dw 就可以删除两个单词了。</li>
<li>从光标所在位置删除至行首：d0 。</li>
<li>从光标所在位置删除至行末：d$ 。</li>
</ul>
<h3 id="5-3-复制单词，行"><a href="#5-3-复制单词，行" class="headerlink" title="5.3 复制单词，行"></a>5.3 复制单词，行</h3><ul>
<li>复制行：按两次 y 会把光标所在行复制到内存中，和 dd 类似， dd 用于”剪切”光标所在行。</li>
<li>复制单词：yw 会复制一个单词。</li>
<li>复制到行末：y$ 是复制从光标所在处到行末的所有字符。</li>
<li>复制到行首：y0 是复制光标所在处到行首的所有字符。  </li>
</ul>
<h3 id="5-4-粘贴"><a href="#5-4-粘贴" class="headerlink" title="5.4 粘贴"></a>5.4 粘贴</h3><p>如果之前用 dd 或者 yy 剪切复制过来的，可以使用 p 来粘贴。同样也可以使用 数字+p来表示复制多次。  </p>
<h3 id="5-5-替换一个字符"><a href="#5-5-替换一个字符" class="headerlink" title="5.5 替换一个字符"></a>5.5 替换一个字符</h3><p>在交互模式下，将光标置于想要替换的字符上。按下 r 键，接着输入你要替换的字符即可。  </p>
<h3 id="5-6-撤销操作"><a href="#5-6-撤销操作" class="headerlink" title="5.6 撤销操作"></a>5.6 撤销操作</h3><p>如果要撤销最近的修改，只需要按下 u 键，如果想要撤销最近四次修改，可以按下4，再按下 u 。  </p>
<h3 id="5-7-重做"><a href="#5-7-重做" class="headerlink" title="5.7 重做"></a>5.7 重做</h3><p>取消撤销，也就是重做之前的修改使用 ctrl + r 。  </p>
<h3 id="5-8-跳转到指定行"><a href="#5-8-跳转到指定行" class="headerlink" title="5.8 跳转到指定行"></a>5.8 跳转到指定行</h3><p>Vim 编辑的文件中，每一行都有一个行号，行号从1开始，逐一递增。</p>
<p>行号默认是不显示，如果需要它显示的话，可以进入命令模式，然后输入 set nu ，如果要隐藏行号的话，使用 set nonu 。</p>
<ul>
<li>跳转到指定行：数字+gg ，例如 7gg ，表示跳转到第7行。</li>
<li>要跳转到最后一行，按下 G 。</li>
<li>要跳转到第一行，按下 gg 。</li>
</ul>
<h2 id="6-高级操作"><a href="#6-高级操作" class="headerlink" title="6 高级操作"></a>6 高级操作</h2><h3 id="6-1-查找"><a href="#6-1-查找" class="headerlink" title="6.1 查找"></a>6.1 查找</h3><p>处于交互模式下，按下 / 键，那么就进入查找模式，输入你要查找的字符串，然后按下回车。光标就会跳转到文件中下一个查找到的匹配处。如果字符串不存在，那么会显示 “pattern not found” 。</p>
<ul>
<li>n 跳转到下一个匹配项；</li>
<li>N 跳转到上一个匹配项。</li>
</ul>
<p>[注意] 用斜杠来进行的查找是从当前光标处开始向文件尾搜索，如果你要从当前光标处开始，向文件头搜索则使用 ? ，当然也可以先按下 gg 跳转到第一行在进行全文搜索。  </p>
<h3 id="6-2-查找并替换"><a href="#6-2-查找并替换" class="headerlink" title="6.2 查找并替换"></a>6.2 查找并替换</h3><p>替换光标所在行第一个匹配的字符串：</p>
<h1 id="语法-s-旧字符串-新字符串-实例-s-one-two"><a href="#语法-s-旧字符串-新字符串-实例-s-one-two" class="headerlink" title="语法:s/旧字符串/新字符串# 实例:s/one/two"></a>语法:s/旧字符串/新字符串# 实例:s/one/two</h1><p>替换光标所在行所有旧字符串为新字符串：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 语法:s/旧字符串/新字符串/g</span><br></pre></td></tr></table></figure>
<p>替换第几行到第几行中所有字符串：</p>
<h1 id="语法-n-m-s-旧字符串-新字符串-g"><a href="#语法-n-m-s-旧字符串-新字符串-g" class="headerlink" title="语法:n,m s/旧字符串/新字符串/g"></a>语法:n,m s/旧字符串/新字符串/g</h1><h1 id="实例-2-4-s-one-two-g"><a href="#实例-2-4-s-one-two-g" class="headerlink" title="实例:2,4 s/one/two/g"></a>实例:2,4 s/one/two/g</h1><p>最常用的就是全文替换了：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 语法:%s/旧字符串/新字符串/g</span><br></pre></td></tr></table></figure>
<h3 id="0-1-合并文件"><a href="#0-1-合并文件" class="headerlink" title="0.1 合并文件"></a>0.1 合并文件</h3><p>可以用冒号 +r ( :r ) 实现在光标处插入一个文件的内容。</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:r filename # 可以用Tab键来自动补全另外一个文件的路径</span><br></pre></td></tr></table></figure>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/07/25/Algorithm/SkipList/">[Algorithm] SkipList</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-07-25
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <h2 id="1-核心性质"><a href="#1-核心性质" class="headerlink" title="1 核心性质"></a>1 核心性质</h2><ul>
<li>跳表由多层索引结构组成</li>
<li>每次节点个数接近于相邻下层节点数的一半</li>
<li>对于一个 m 层存在的节点，在 1~m-1层中这个节点也一定存在</li>
<li>为保证连贯性，跳表额外补充了本身不存储数据的头节点和尾节点，作为起点和终点</li>
<li>头节点和尾节点的高度是动态扩缩的，其高度取决于当前跳表内数据节点的最大高度</li>
<li>跳表的”跳“字体现在，在高层检索时，每跳过一个节点，实际上都过滤跳过了底层的大量数据，从而实现检索加速<h2 id="2-数据结构定义"><a href="#2-数据结构定义" class="headerlink" title="2 数据结构定义"></a>2 数据结构定义</h2></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 跳表的数据结构 Skiplist  </span></span><br><span class="line"> <span class="keyword">type</span> Skiplist <span class="keyword">struct</span> &#123;  </span><br><span class="line">     head *node  </span><br><span class="line"> &#125;  </span><br><span class="line"> <span class="comment">// 节点定义  </span></span><br><span class="line"> <span class="keyword">type</span> node <span class="keyword">struct</span> &#123;  </span><br><span class="line">     <span class="comment">// 长度为当前节点的高度  </span></span><br><span class="line">     nexts    []*node  </span><br><span class="line">     key, val <span class="type">int</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-读流程"><a href="#3-读流程" class="headerlink" title="3 读流程"></a>3 读流程</h2><ul>
<li>以 head 节点作为起点</li>
<li>从当前跳表存在的最大高度出发</li>
<li>倘若右侧节点 key 值小于 target，则持续向右遍历</li>
<li>倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回</li>
<li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li>
<li>重复</li>
<li>倘若已经抵达第1层仍然找到不到 target，则返回 key 不存在的信息</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 根据 key 读取 val，第二个 bool flag 反映 key 在 skiplist 中是否存在  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Get(key <span class="type">int</span>) (<span class="type">int</span>, <span class="type">bool</span>) &#123;  </span><br><span class="line">     <span class="comment">// 根据 key 尝试检索对应的 node，如果 node 存在，则返回对应的 val  </span></span><br><span class="line">     <span class="keyword">if</span> _node := s.search(key); _node != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> _node.val, <span class="literal">true</span>  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>, <span class="literal">false</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 从跳表中检索 key 对应的 node  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> search(key <span class="type">int</span>) *node &#123;  </span><br><span class="line">     <span class="comment">// 每次检索从头部出发  </span></span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="comment">// 每次检索从最大高度出发，直到来到首层  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="comment">// 在每一层中持续向右遍历，直到下一个节点不存在或者 key 值大于等于 key  </span></span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; key &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 如果 key 值相等，则找到了目标直接返回  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key == key &#123;  </span><br><span class="line">             <span class="keyword">return</span> move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 当前层没找到目标，则层数减 1，继续向下  </span></span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">// 遍历完所有层数，都没有找到目标，返回 nil  </span></span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span>  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-写流程"><a href="#4-写流程" class="headerlink" title="4 写流程"></a>4 写流程</h2><ul>
<li>首先基于读流程检索出 key 对应的节点是否存在，倘若存在，则对值进行更新并直接返回</li>
<li>随机出新插入节点的高度；倘若新插入节点的高度大于当前跳表的最大高度，则需要对起点和终点的高度进行扩容</li>
<li>以 head 节点作为起点，从当前跳表存在的最大高度出发</li>
<li>倘若右侧节点 key 值小于 target，则持续向右遍历</li>
<li>倘若右侧节点为终点（nil）或者 key 值大于 target，则在该空隙插入新节点，并降低高度进入下一层</li>
<li>重复（4）-（5）步</li>
<li>倘若已经进入第 1 层，插入新节点后即可返回<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">import</span> (<span class="string">&quot;math/rand&quot;</span>)  </span><br><span class="line"> roll 骰子，决定一个待插入的新节点在 skiplist 中最高层对应的 index  </span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> roll() <span class="type">int</span> &#123;  </span><br><span class="line">     <span class="keyword">var</span> level <span class="type">int</span>  </span><br><span class="line">     <span class="comment">// 每次投出 1，则层数加 1  </span></span><br><span class="line">     <span class="keyword">for</span> rand.Int() &gt; <span class="number">0</span> &#123;  </span><br><span class="line">         level++  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> level  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 将 key-val 对加入 skiplist  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Put(key, val <span class="type">int</span>) &#123;  </span><br><span class="line">     <span class="comment">// 假如 kv对已存在，则直接对值进行更新并返回  </span></span><br><span class="line">     <span class="keyword">if</span> _node := s.search(key); _node != <span class="literal">nil</span> &#123;  </span><br><span class="line">         _node.val = val  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// roll 出新节点的高度  </span></span><br><span class="line">     level := s.roll()  </span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 新节点高度超出跳表最大高度，则需要对高度进行补齐  </span></span><br><span class="line">     <span class="keyword">for</span> <span class="built_in">len</span>(s.head.nexts)<span class="number">-1</span> &lt; level &#123;  </span><br><span class="line">         s.head.nexts = <span class="built_in">append</span>(s.head.nexts, <span class="literal">nil</span>)  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 创建出新的节点  </span></span><br><span class="line">     newNode := node&#123;  </span><br><span class="line">         key:   key,  </span><br><span class="line">         val:   val,  </span><br><span class="line">         nexts: <span class="built_in">make</span>([]*node, level+<span class="number">1</span>),  </span><br><span class="line">     &#125;  </span><br><span class="line">    </span><br><span class="line">     <span class="comment">// 从头节点的最高层出发  </span></span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="keyword">for</span> level := level; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="comment">// 向右遍历，直到右侧节点不存在或者 key 值大于 key  </span></span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; key &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 调整指针关系，完成新节点的插入  </span></span><br><span class="line">         newNode.nexts[level] = move.nexts[level]  </span><br><span class="line">         move.nexts[level] = &amp;newNode  </span><br><span class="line">     &#125;  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="删流程"><a href="#删流程" class="headerlink" title="删流程"></a>删流程</h2><ul>
<li>以 head 节点作为起点，从当前跳表存在的最大高度出发</li>
<li>倘若右侧节点 key 值小于 target，则持续向右遍历</li>
<li>倘若右侧节点为终点（nil）或者 key 值大于 target，则在该空隙插入新节点，并降低高度进入下一层</li>
<li>倘若右侧节点 key 值等于 target，则代表找到目标</li>
<li>找到目标值后，沿当前节点层层向下，依次将每层中的目标节点删除</li>
<li>倘若已经进入第 1 层仍然没有找到节点，说明节点不存在，删除失败</li>
<li><p>倘若删除成功，需要尝试对跳表的整体高度进行缩容，即需要对高度递减，直到确定最大高度对应的层数上至少存在一个有效的数据节点为止</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 key 从跳表中删除对应的节点  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Del(key <span class="type">int</span>) &#123;  </span><br><span class="line">     <span class="comment">// 如果 kv 对不存在，则无需删除直接返回  </span></span><br><span class="line">     <span class="keyword">if</span> _node := s.search(key); _node == <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span>  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 从头节点的最高层出发      </span></span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="comment">// 向右遍历，直到右侧节点不存在或者 key 值大于等于 key  </span></span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; key &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">           </span><br><span class="line">         <span class="comment">// 右侧节点不存在或者 key 值大于 target，则直接跳过  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] == <span class="literal">nil</span> || move.nexts[level].key &gt; key&#123;  </span><br><span class="line">            <span class="keyword">continue</span>  </span><br><span class="line">         &#125;      </span><br><span class="line">         <span class="comment">// 走到此处意味着右侧节点的 key 值必然等于 key，则调整指针引用  </span></span><br><span class="line">         move.nexts[level] = move.nexts[level].nexts[level]  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 对跳表的最大高度进行更新  </span></span><br><span class="line">     <span class="keyword">var</span> dif <span class="type">int</span>  </span><br><span class="line">     <span class="comment">// 倘若某一层已经不存在数据节点，高度需要递减  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt; <span class="number">0</span> &amp;&amp; s.head.nexts[level] == <span class="literal">nil</span>; level-- &#123;  </span><br><span class="line">         dif++  </span><br><span class="line">     &#125;  </span><br><span class="line">     s.head.nexts = s.head.nexts[:<span class="built_in">len</span>(s.head.nexts)-dif]  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-RANGE-流程"><a href="#5-RANGE-流程" class="headerlink" title="5 RANGE 流程"></a>5 RANGE 流程</h2></li>
<li>以 head 节点作为起点</li>
<li>从当前跳表存在的最大高度出发</li>
<li>倘若右侧节点 key 值小于 target，则持续向右遍历</li>
<li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li>
<li>倘若右侧节点 key 值等于 target，则代表找到目标，直接沿该节点向下来到第1层</li>
<li><p>重复（3）-（5）步，直到来到第1层，接下来从首个大于等于 target 的节点出发，向右依次遍历，直到取满 range 区间的数据后返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到 skiplist 当中 ≥ start，且 ≤ end 的 kv 对  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Range(start, end <span class="type">int</span>) [][<span class="number">2</span>]<span class="type">int</span> &#123;  </span><br><span class="line">     <span class="comment">// 首先通过 ceiling 方法，找到 skiplist 中 key 值大于等于 start 且最接近于 start 的节点 ceilNode  </span></span><br><span class="line">     ceilNode := s.ceiling(start)  </span><br><span class="line">     <span class="comment">// 如果不存在，直接返回  </span></span><br><span class="line">     <span class="keyword">if</span> ceilNode == <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> [][<span class="number">2</span>]<span class="type">int</span>&#123;&#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// 从 ceilNode 首层出发向右遍历，把所有位于 [start,end] 区间内的节点统统返回  </span></span><br><span class="line">     <span class="keyword">var</span> res [][<span class="number">2</span>]<span class="type">int</span>  </span><br><span class="line">     <span class="keyword">for</span> move := ceilNode; move != <span class="literal">nil</span> &amp;&amp; move.key &lt;= end; move = move.nexts[<span class="number">0</span>] &#123;  </span><br><span class="line">         res = <span class="built_in">append</span>(res, [<span class="number">2</span>]<span class="type">int</span>&#123;move.key, move.val&#125;)  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> res  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 找到 key 值大于等于 target 且 key 值最接近于 target 的节点  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> ceiling(target <span class="type">int</span>) *node &#123;  </span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="comment">// 自上而下，找到 key 值小于 target 且最接近 target 的 kv 对  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; target &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 如果 key 值等于 targe 的 kv 对存在，则直接返回  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key == target &#123;  </span><br><span class="line">             <span class="keyword">return</span> move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="comment">// 此时 move 已经对应于在首层 key 值小于 key 且最接近于 key 的节点，其右侧第一个节点即为所寻找的目标节点  </span></span><br><span class="line">     <span class="keyword">return</span> move.nexts[<span class="number">0</span>]  </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="CEILING-流程"><a href="#CEILING-流程" class="headerlink" title="CEILING 流程"></a>CEILING 流程</h2><ul>
<li>以 head 节点作为起点</li>
<li>从当前跳表存在的最大高度出发</li>
<li>倘若右侧节点 key 值小于 target，则持续向右遍历</li>
<li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li>
<li>倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回</li>
<li>重复（3）-（5）步，直到找到 key 值等于 target 的节点或者来到第1层，接下来获取到首个大于等于 target 的节点并返回</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 找到 skiplist 中，key 值大于等于 target 且最接近于 target 的 key-value 对  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Ceiling(target <span class="type">int</span>) ([<span class="number">2</span>]<span class="type">int</span>, <span class="type">bool</span>) &#123;  </span><br><span class="line">     <span class="keyword">if</span> ceilNode := s.ceiling(target); ceilNode != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;ceilNode.key, ceilNode.val&#125;, <span class="literal">true</span>  </span><br><span class="line">     &#125;  </span><br><span class="line">     <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;&#125;, <span class="literal">false</span>  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>
<p> ​</p>
<h2 id="6-FLOOR-流程"><a href="#6-FLOOR-流程" class="headerlink" title="6 FLOOR 流程"></a>6 FLOOR 流程</h2><ul>
<li>以 head 节点作为起点</li>
<li>从当前跳表存在的最大高度出发</li>
<li>倘若右侧节点 key 值小于 target，则持续向右遍历</li>
<li>倘若右侧节点为终点（nil）或者 key 值大于 target，则沿当前节点降低高度进入下一层</li>
<li>倘若右侧节点 key 值等于 target，则代表找到目标，直接取值返回</li>
<li><p>重复（3）-（5）步，直到找到 key 值等于 target 的节点或者来到第1层，接下来获取到首个小于等于 target 的节点并返回</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 找到 skiplist 中，key 值小于等于 target 且最接近于 target 的 key-value 对  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> Floor(target <span class="type">int</span>) ([<span class="number">2</span>]<span class="type">int</span>, <span class="type">bool</span>) &#123;  </span><br><span class="line">     <span class="comment">// 引用 floor 方法，取 floorNode 值进行返回  </span></span><br><span class="line">     <span class="keyword">if</span> floorNode := s.floor(target); floorNode != <span class="literal">nil</span> &#123;  </span><br><span class="line">         <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;floorNode.key, floorNode.val&#125;, <span class="literal">true</span>  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="keyword">return</span> [<span class="number">2</span>]<span class="type">int</span>&#123;&#125;, <span class="literal">false</span>  </span><br><span class="line"> &#125;  </span><br><span class="line"> ​  </span><br><span class="line"> <span class="comment">// 找到 key 值小于等于 target 且 key 值最接近于 target 的节点  </span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="params">(s *Skiplist)</span></span> floor(target <span class="type">int</span>) *node &#123;  </span><br><span class="line">     move := s.head  </span><br><span class="line">     <span class="comment">// 自上而下，找到 key 值小于 target 且最接近 target 的 kv 对  </span></span><br><span class="line">     <span class="keyword">for</span> level := <span class="built_in">len</span>(s.head.nexts) - <span class="number">1</span>; level &gt;= <span class="number">0</span>; level-- &#123;  </span><br><span class="line">         <span class="keyword">for</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key &lt; target &#123;  </span><br><span class="line">             move = move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">         <span class="comment">// 如果 key 值等于 targe 的 kv对存在，则直接返回  </span></span><br><span class="line">         <span class="keyword">if</span> move.nexts[level] != <span class="literal">nil</span> &amp;&amp; move.nexts[level].key == target &#123;  </span><br><span class="line">             <span class="keyword">return</span> move.nexts[level]  </span><br><span class="line">         &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line"> ​  </span><br><span class="line">     <span class="comment">// move 是首层中 key 值小于 target 且最接近 target 的节点，直接返回 move 即可  </span></span><br><span class="line">     <span class="keyword">return</span> move  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>
<p>​<br>​</p>
</li>
</ul>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/07/25/Basic/Git%20%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/">[Basic] Git</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-07-25
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    

    
    <span id="more"></span>
<h1 id="一、git-工作流程"><a href="#一、git-工作流程" class="headerlink" title="一、git 工作流程"></a>一、git 工作流程</h1><p>git 有四个区域:</p>
<ul>
<li>3个本地区域<ul>
<li>工作区(Workspace): 存放项目代码的地方。</li>
<li>暂存区(Stage): 存放临时的改动, 事实上它只是一个文件, 保存即将提交的文件列表信息。</li>
<li>资源库(Repository): 安全存放数据的位置, 这里面有提交到所有版本的数据。其中 HEAD 指向最新放入仓库的版本。</li>
</ul>
</li>
<li>1个远程区域<ul>
<li>远程库(Remote): 托管代码的服务器。</li>
</ul>
</li>
</ul>
<p><img src="../../img/git/git区域.png" alt="git区域"></p>
<h1 id="二、git-初始化"><a href="#二、git-初始化" class="headerlink" title="二、git 初始化"></a>二、git 初始化</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> git-study &amp;&amp; <span class="built_in">cd</span> git-study</span><br><span class="line">$ git init</span><br><span class="line">$ <span class="built_in">ls</span> -la</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x   3 kino  staff   96 11 23 17:18 .</span><br><span class="line">drwxr-xr-x  16 kino  staff  512 11 23 17:18 ..</span><br><span class="line">drwxr-xr-x   9 kino  staff  288 11 23 17:18 .git</span><br></pre></td></tr></table></figure>
<p>创建成功之后, 会出现一个 <code>.git</code> 的隐藏文件夹, 这个就是这个项目的 git 仓库, 以后所有的 git 操作历史提交记录信息全都在此, 只要这个文件夹还存在, 就可以记住我们所有的 git 操作。</p>
<h1 id="三、git-配置相关常用命令"><a href="#三、git-配置相关常用命令" class="headerlink" title="三、git 配置相关常用命令"></a>三、git 配置相关常用命令</h1><h2 id="1-git-config"><a href="#1-git-config" class="headerlink" title="1 git config"></a>1 git config</h2><p>查看 git 配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git config --list</span><br><span class="line">credential.helper=osxkeychain</span><br><span class="line">user.name=kino</span><br><span class="line">user.email=kino@gmail.com</span><br><span class="line">core.autocrlf=input</span><br><span class="line">core.quotepath=<span class="literal">false</span></span><br><span class="line">core.repositoryformatversion=0</span><br><span class="line">core.filemode=<span class="literal">true</span></span><br><span class="line">core.bare=<span class="literal">false</span></span><br><span class="line">core.logallrefupdates=<span class="literal">true</span></span><br><span class="line">core.ignorecase=<span class="literal">true</span></span><br><span class="line">core.precomposeunicode=<span class="literal">true</span></span><br></pre></td></tr></table></figure><br>修改 git 配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config -e            <span class="comment"># 针对当前仓库</span></span><br><span class="line">$ git config -e --global   <span class="comment"># 针对系统上的所有仓库</span></span><br></pre></td></tr></table></figure><br>设置提交代码时的用户信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;yourUserName&quot;</span>     <span class="comment"># 去掉 --global 就只对当前仓库生效</span></span><br><span class="line">$ git config --gloabl user.email <span class="string">&quot;yourEmail&quot;</span>       <span class="comment"># 去掉 --global 就只对当前仓库生效</span></span><br></pre></td></tr></table></figure></p>
<h1 id="四、git-日常操作"><a href="#四、git-日常操作" class="headerlink" title="四、git 日常操作"></a>四、git 日常操作</h1><p><a href="#411-git-add"><code>git add</code>: 将文件添加到暂存区</a></p>
<p><a href="#412-git-status"><code>git status</code>: 查看在你上次提交之后是否有对文件进行再次修改</a></p>
<p><a href="#413-git-diff"><code>git diff</code>: 比较文件在暂存区和工作区的差异</a></p>
<p><a href="#414-git-status"><code>git ls-files</code>: 查看暂存区的文件</a></p>
<p><a href="#415-git-status"><code>git cat-file -p</code>: 查看暂存区文件中的内容</a></p>
<p><a href="#416-git-status"><code>git commit</code>: 提交暂存区文件到本地仓库</a></p>
<p><a href="#417-git-rm"><code>git rm</code>: 删除文件</a></p>
<h2 id="1-提交代码"><a href="#1-提交代码" class="headerlink" title="1 提交代码"></a>1 提交代码</h2><h3 id="1-1-git-add"><a href="#1-1-git-add" class="headerlink" title="1.1 git add"></a>1.1 git add</h3><p>语法:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 该命令可以将文件添加到暂存区</span></span><br><span class="line">$ git add [file1] [file2] ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 添加指定目录到暂存区</span></span><br><span class="line">$ git add [<span class="built_in">dir</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 添加当前目录下所有文件进入暂存区</span></span><br><span class="line">$ git add .</span><br></pre></td></tr></table></figure><br>示例:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> 1.txt 2.txt 3.txt 4.txt</span><br><span class="line">$ ll </span><br><span class="line">total 8</span><br><span class="line">-rw-r--r--  1 kino  staff   0  7  5 18:30 1.txt</span><br><span class="line">-rw-r--r--  1 kino  staff   0  7  5 18:30 2.txt</span><br><span class="line">-rw-r--r--  1 kino  staff   0  7  5 18:31 3.txt</span><br><span class="line">-rw-r--r--  1 kino  staff   0  7  5 18:31 4.txt</span><br><span class="line">-rw-r--r--  1 kino  staff  13  7  5 18:30 README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 1.txt 和 2.txt 进入暂存区</span></span><br><span class="line">$ git add 1.txt 2.txt</span><br></pre></td></tr></table></figure></p>
<h3 id="1-2-git-status"><a href="#1-2-git-status" class="headerlink" title="1.2 git status"></a>1.2 git status</h3><p>查看在你上次提交之后是否有对文件进行再次修改。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">$ git status </span><br><span class="line">On branch main</span><br><span class="line">Your branch is up to <span class="built_in">date</span> with <span class="string">&#x27;origin/main&#x27;</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">	new file:   1.txt</span><br><span class="line">	new file:   2.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">	3.txt</span><br><span class="line">	4.txt</span><br><span class="line"></span><br><span class="line">$ git status -s </span><br><span class="line">A  1.txt</span><br><span class="line">A  2.txt</span><br><span class="line">?? 3.txt</span><br><span class="line">?? 4.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;提交&quot;</span></span><br><span class="line">[main 26c1139] 提交</span><br><span class="line"> 2 files changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 1.txt</span><br><span class="line"> create mode 100644 2.txt</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> 11111 &gt;&gt; 1.txt</span><br><span class="line">$ <span class="built_in">echo</span> 33333 &gt;&gt; 3.txt</span><br><span class="line">$ git add 3.txt</span><br><span class="line"></span><br><span class="line">$ git status -s </span><br><span class="line"> M 1.txt</span><br><span class="line">AM 3.txt</span><br><span class="line">?? 4.txt</span><br></pre></td></tr></table></figure></p>
<ul>
<li>A 表示新提交</li>
<li>M 表示提交过，并且本地又修改了</li>
<li>AM 表示有改动</li>
</ul>
<h3 id="1-3-git-diff"><a href="#1-3-git-diff" class="headerlink" title="1.3 git diff"></a>1.3 git diff</h3><p>比较文件的不同, 即比较文件在暂存区和工作区的差异</p>
<p>git diff 显示已经写入暂存区和已经被修改但尚未写入暂存区文件的区别</p>
<p>应用场景:</p>
<ol>
<li>尚未缓存的改动: git diff</li>
<li>查看已经缓存的改动: git diff —cached</li>
<li>查看缓存成功和未缓存的所有改动: git diff HEAD</li>
<li>显示摘要而非整个diff: git diff —stat</li>
</ol>
<p>删除原来的项目重新clone<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> -rf git-study</span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> git-study</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> 1111 &gt;&gt; README.md</span><br><span class="line">$ git add . &amp;&amp; git commit -m <span class="string">&quot;readme&quot;</span> </span><br><span class="line">$ <span class="built_in">echo</span> 2222 &gt;&gt; README.md</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看暂未添加至缓存区的改动</span></span><br><span class="line">$ git diff</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 5f2f16b..4f142ee 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> 1111</span><br><span class="line">+2222</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示简略信息</span></span><br><span class="line">$ git diff --<span class="built_in">stat</span></span><br><span class="line"> README.md | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已经添加至缓存区的改动</span></span><br><span class="line">$ git add README.md</span><br><span class="line">$ git diff --cached</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 5f2f16b..4f142ee 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> 1111</span><br><span class="line">+2222</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看不在缓存区 &amp; 在缓存区的改动</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line">diff --git a/README.md b/README.md</span><br><span class="line">index 5f2f16b..4f142ee 100644</span><br><span class="line">--- a/README.md</span><br><span class="line">+++ b/README.md</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> 1111</span><br><span class="line">+2222</span><br></pre></td></tr></table></figure></p>
<h3 id="1-4-git-ls-files"><a href="#1-4-git-ls-files" class="headerlink" title="1.4 git ls-files"></a>1.4 git ls-files</h3><p>查看暂存区的文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-files</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure><br>可选参数:</p>
<ul>
<li>-c: 默认</li>
<li>-d: 显示删除的文件</li>
<li>-m: 显示被修改过的文件</li>
<li>-o: 显示没有被 git 跟踪过的文件</li>
<li>-s: 显示 mode 以及对应的 Blog对象, 进而可以获取暂存区中对应文件的内容</li>
</ul>
<h3 id="1-5-git-cat-file-p"><a href="#1-5-git-cat-file-p" class="headerlink" title="1.5 git cat-file -p"></a>1.5 git cat-file -p</h3><p>查看暂存区文件中的内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git ls-files -s</span><br><span class="line">100644 5cf7833392d65968a05971b9923f36a1ec46d7f7 0       README.md</span><br><span class="line"></span><br><span class="line">$ git cat-file -p  5cf7</span><br><span class="line">1111</span><br><span class="line">2222</span><br></pre></td></tr></table></figure></p>
<h3 id="1-6-git-commit"><a href="#1-6-git-commit" class="headerlink" title="1.6 git commit"></a>1.6 git commit</h3><p>提交暂存区文件到本地仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m [message]</span><br></pre></td></tr></table></figure><br>提交暂存区的指定文件到本地仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git commit [file1] [file2] ... -m [message]</span><br></pre></td></tr></table></figure></p>
<h3 id="1-7-git-rebase"><a href="#1-7-git-rebase" class="headerlink" title="1.7 git rebase"></a>1.7 git rebase</h3><ul>
<li>变基提交,用来重写提交历史</li>
<li>基于 master 的 a 新建的分支,后面 master 又有了 c 提交,rebase 后分支的更新就是基于 c 了<h3 id="1-8-git-stash"><a href="#1-8-git-stash" class="headerlink" title="1.8 git stash"></a>1.8 git stash</h3></li>
<li>保存当前工作进度，会把暂存区和工作区的改动保存到一个未完结变更的堆栈中；执行完这个命令后，在运行 <code>git status</code> 命令，就会发现当前是一个干净的工作区，没有任何改动<h3 id="1-9-git-rm"><a href="#1-9-git-rm" class="headerlink" title="1.9 git rm"></a>1.9 git rm</h3><code>git rm</code> 用于删除文件</li>
</ul>
<p>1、将文件从暂存区和工作区中删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">rm</span> 1.txt 2.txt</span><br></pre></td></tr></table></figure><br>2、将文件从暂存区和工作区中强制删除<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以加上 -f, 表示强制删除之前修改过而且 add 到暂存区的文件</span></span><br><span class="line">$ git <span class="built_in">rm</span> -f 1.txt 2.txt</span><br></pre></td></tr></table></figure><br>3、将文件从暂存区删除，在工作区保留<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">rm</span> --cached 1.txt 2.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="2-分支操作"><a href="#2-分支操作" class="headerlink" title="2 分支操作"></a>2 分支操作</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看分支</span></span><br><span class="line">$ git branch -a </span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于当前分支创建一个新分支</span></span><br><span class="line">$ git checkout -b feature/hotfix-001</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于指定分支创建一个新的分支</span></span><br><span class="line">$ git checkout -b feature/hotfix-002 master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换分支</span></span><br><span class="line">$ git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分支</span></span><br><span class="line">$ git branch -d feature/hotfix-001</span><br></pre></td></tr></table></figure>
<h2 id="3-更新操作"><a href="#3-更新操作" class="headerlink" title="3 更新操作"></a>3 更新操作</h2><p>@TODO</p>
<h2 id="4-合并冲突"><a href="#4-合并冲突" class="headerlink" title="4 合并冲突"></a>4 合并冲突</h2><p>简单制造一个冲突<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 再迁出一个分支(模拟其他人的修改操作)</span></span><br><span class="line">$ git checkout -b feature/hotfix-001 feature/hotfix-002</span><br><span class="line"><span class="comment"># 修改文件</span></span><br><span class="line">$ <span class="built_in">echo</span> 3333 &gt;&gt; README.md</span><br><span class="line">$ git add README.md</span><br><span class="line">$ git commit -m <span class="string">&quot;hotfix-001: add newline&quot;</span></span><br><span class="line"><span class="comment"># 合并到master</span></span><br><span class="line">$ git checkout master </span><br><span class="line">$ git merge feature/hotfix-001</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git checkout feature/hotfix-002</span><br><span class="line">$ vim README.md</span><br><span class="line"><span class="comment"># 在第三行添加</span></span><br><span class="line">3344</span><br><span class="line">$ git add README.md</span><br><span class="line">$ git commit -m <span class="string">&quot;hotfix-002: add newline&quot;</span></span><br><span class="line"></span><br><span class="line">$ git checkout master</span><br><span class="line"><span class="comment"># 再合并代码就会出现冲突提示</span></span><br><span class="line"><span class="comment"># 这个时候不可以进行任何分支切换和commit操作，需要按照提示将冲突解决。</span></span><br><span class="line">$ git merge feature/hotfix-002</span><br><span class="line">Auto-merging README.md</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> README.md</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><br>查看冲突文件内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ vim README.md</span><br><span class="line">1111</span><br><span class="line">2222</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; <span class="string">HEAD</span></span><br><span class="line"><span class="string">3333</span></span><br><span class="line"><span class="string">=======</span></span><br><span class="line"><span class="string">3344</span></span><br><span class="line"><span class="string">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/hotfix-002</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>从 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code> 开始, 到 <code>=======</code> 都是主分支已经存在的内容。</li>
<li>从 <code>=======</code> 开始, 到 <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature/hotfix-002</code> 都是 merge 过来的分支的内容。</li>
</ul>
<p>解决冲突，视情况保留(删除)记录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ vim README.md</span><br><span class="line">1111</span><br><span class="line">2222</span><br><span class="line">3333</span><br><span class="line">3344</span><br><span class="line"></span><br><span class="line"><span class="comment"># 冲突解决完成之后, 再次提交代码</span></span><br><span class="line">$ git commit -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看变更记录</span></span><br><span class="line">commit 8715c66d8ca756077040ce6d783c6caf470d115e (HEAD -&gt; master)</span><br><span class="line">Merge: b89c0c5 ba903ae</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Wed Nov 23 18:29:17 2022 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">&#x27;feature/hotfix-002&#x27;</span></span><br><span class="line"></span><br><span class="line">commit ba903aebecb447d6f485108f0321b15f6c009886 (feature/hotfix-002)</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Wed Nov 23 18:19:54 2022 +0800</span><br><span class="line"></span><br><span class="line">    hotfix-002: add newline</span><br><span class="line"></span><br><span class="line">commit b89c0c592ba11894acb2cd93564c5e43934065fb (feature/hotfix-001)</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Wed Nov 23 18:16:23 2022 +0800</span><br><span class="line"></span><br><span class="line">    hotfix-001: add newline</span><br></pre></td></tr></table></figure></p>
<h2 id="5-暂存代码保护现场"><a href="#5-暂存代码保护现场" class="headerlink" title="5 暂存代码保护现场"></a>5 暂存代码保护现场</h2><p>项目经理提了一个新的需求, 开发就需要从 master 分支迁出一个新的分支进行功能开发(例如迁出新分支为dev), 如果在开发过程工, 生产上有紧急 bug 需要修复, 就可以用到 <code>git stash</code> 了。</p>
<p><code>git stash</code> 可以将现在的 <strong>工作区</strong>全部的修改、新增、删除等操作，全部保存起来。</p>
<p><code>git stash</code> 的常用命令:</p>
<ol>
<li><code>git stash save &#39;save message&#39;</code>: 执行存储时, 添加备注, 方便查找, 当然只执行 <code>git stash</code> 也是可以的, 但查找时不方便。</li>
<li><code>git stash list</code>: 查看 stash 了哪些存储。</li>
<li><code>git stash show</code>: 显示做了哪些改动, 默认 show 第一个存储, 如果要显示其他的存储, 后面加 <code>stash@&#123;$num&#125;</code>, 比如第二个: <code>git stash show stash@&#123;1&#125;</code></li>
<li><code>git stast show -p</code>: 显示第一个存储的改动, 如果想显示其他存储, 则: <code>git stash show stash@&#123;$num&#125; -p</code>, 比如第二个: <code>git stash show stash@&#123;1&#125; -p</code></li>
<li><code>git stash apply</code>: 应用某个存储, 但不会把存储从存储列表中删除, 默认使用第一个存储, 即 <code>stash@&#123;0&#125;</code>, 如果要是用其他, 则: <code>git stash apply stash@&#123;$num&#125;</code>, 比如第二个: <code>git stash apply stash@&#123;1&#125;</code></li>
<li><code>git stash pop</code>: 恢复之前缓存的工作目录, 将缓存列表中对应的 stash 删除, 并将对应修改应用到当前的工作目录下, 默认为第一个 stash, 即 <code>stash@&#123;0&#125;</code>, 如果要应用并删除其他 stash, 则: <code>git stash pop stash@&#123;$num&#125;</code>, 比如应用并删除第二个: <code>git stash pop stash@&#123;1&#125;</code></li>
<li><code>git stash drop stash@&#123;num&#125;</code>: 丢弃 <code>stash@&#123;num&#125;</code> 存储, 从列表中删除这个存储</li>
<li><code>git stash clear</code>: 删除所有缓存的 stash</li>
</ol>
<p>开始模拟现场<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git 初始化</span></span><br><span class="line">$ <span class="built_in">cd</span> .. &amp;&amp; <span class="built_in">rm</span> -rf git-study &amp;&amp; <span class="built_in">mkdir</span> git-study &amp;&amp; <span class="built_in">cd</span> git-study &amp;&amp; git init</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;file1 init&#x27;</span> &gt; file1.txt</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;file2 init&#x27;</span> &gt; file2.txt</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&#x27;change: add file1 &amp; file2&#x27;</span></span><br><span class="line">[master (root-commit) 525c358] change: add file1 &amp; file2</span><br><span class="line"> 2 files changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 file1.txt</span><br><span class="line"> create mode 100644 file2.txt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 然后从 master 分支创建两个新的 feature 分支</span></span><br><span class="line">$ git branch feature1</span><br><span class="line">$ git branch feature2</span><br><span class="line"></span><br><span class="line"><span class="comment"># checkout feature1, 修改 file1.txt, 并在 feature1 上创建两次提交</span></span><br><span class="line">$ git checkout feature1</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;add file1.txt code 1&#x27;</span> &gt;&gt; file1.txt</span><br><span class="line">$ git add file1.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;change file1 no.1&#x27;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;add file2.txt code 2&#x27;</span> &gt;&gt; file1.txt</span><br><span class="line">$ git add file1.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;change file1 no.2&#x27;</span></span><br><span class="line"><span class="comment"># 目前 feature1 上的改动内容</span></span><br><span class="line">$ <span class="built_in">cat</span> file1.txt</span><br><span class="line">file1 init</span><br><span class="line">add file1.txt code 1</span><br><span class="line">add file2.txt code 2</span><br><span class="line">$ <span class="built_in">cat</span> file2.txt</span><br><span class="line">file2 init</span><br><span class="line"></span><br><span class="line"><span class="comment"># checkout feature2, 修改 file2.tx</span></span><br><span class="line">$ git checkout feature2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;add file2.txt code 1&#x27;</span> &gt;&gt; file2.txt</span><br><span class="line">$ git add file2.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;change file2 no.1&#x27;</span></span><br><span class="line"><span class="comment"># 目前 feature2 上的改动内容</span></span><br><span class="line">$ <span class="built_in">cat</span> file1.txt</span><br><span class="line">file1 init</span><br><span class="line">$ <span class="built_in">cat</span> file2.txt</span><br><span class="line">file2 init</span><br><span class="line">add file2.txt code 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 假设不小心将 feature2 合并到了 feature1, 并在 feature1 继续进行了代码开发并提交</span></span><br><span class="line">$ git checkout feature1</span><br><span class="line">$ git merge feature2</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;add file1.txt no.3 &amp; code end&#x27;</span> &gt;&gt; file1.txt</span><br><span class="line">$ git add file1.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;change file1 no.3&#x27;</span></span><br><span class="line"><span class="comment"># 此时 feature1 上所有文件的内容</span></span><br><span class="line">$ <span class="built_in">cat</span> file1.txt</span><br><span class="line">file1 init</span><br><span class="line">add file1.txt code 1</span><br><span class="line">add file2.txt code 2</span><br><span class="line">add file1.txt no.3 &amp; code end</span><br><span class="line">$ <span class="built_in">cat</span> file2.txt</span><br><span class="line">file2 init</span><br><span class="line">add file2.txt code 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时我们发现了不小心 merge 进来的 feature2, 而且在这基础上我们还有新的 commit, 如果我们想将 merge 剔除, 可以做如下操作</span></span><br><span class="line"><span class="comment"># 先查看需要还原 commit 的版本号</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">8a1454f (HEAD -&gt; feature1) change file1 no.3</span><br><span class="line">422a454 Merge branch <span class="string">&#x27;feature2&#x27;</span> into feature1</span><br><span class="line">4978e2c (feature2) change file2 no.1</span><br><span class="line">ee4a50e change file1 no.2</span><br><span class="line">dc397c1 change file1 no.1</span><br><span class="line">525c358 (master) change: add file1 &amp; file2</span><br><span class="line"><span class="comment"># 其中, 422a454 就是误合并的 commitid</span></span><br><span class="line"><span class="comment"># 目前我们需要做的就是撤销已提交的 commit, 回滚到 feature2 误合并到 feature1 分支的 commit 版本。</span></span><br><span class="line">$ git reset --mixed 422a454</span><br><span class="line">Unstaged changes after reset:</span><br><span class="line">M	file1.txt</span><br><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">422a454 (HEAD -&gt; feature1) Merge branch <span class="string">&#x27;feature2&#x27;</span> into feature1</span><br><span class="line">4978e2c (feature2) change file2 no.1</span><br><span class="line">ee4a50e change file1 no.2</span><br><span class="line">dc397c1 change file1 no.1</span><br><span class="line">525c358 (master) change: add file1 &amp; file2</span><br><span class="line">$ git diff file1.txt</span><br><span class="line">diff --git a/file1.txt b/file1.txt</span><br><span class="line">index 4a1ca46..6954af7 100644</span><br><span class="line">--- a/file1.txt</span><br><span class="line">+++ b/file1.txt</span><br><span class="line">@@ -1,3 +1,4 @@</span><br><span class="line"> file1 init</span><br><span class="line"> add file1.txt code 1</span><br><span class="line"> add file2.txt code 2</span><br><span class="line">+add file1.txt no.3 &amp; code end   <span class="comment">## 可以看见, feature1 最后一次提交已经是未暂存状态了</span></span><br><span class="line"><span class="comment"># 此时, 我们就可以使用 git stash, 将撤销的代码存储起来, </span></span><br><span class="line">$ git stash save <span class="string">&#x27;save file1.txt reset code&#x27;</span></span><br><span class="line">Saved working directory and index state On feature1: save file1.txt reset code</span><br><span class="line"><span class="comment"># 查看 stash 列表</span></span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: On feature1: save file1.txt reset code</span><br><span class="line"><span class="comment"># 查看 status, 可以看见在工作空间已经没有了</span></span><br><span class="line">$ git status </span><br><span class="line">On branch feature1</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后再撤销 merge 相关的信息</span></span><br><span class="line">$ git reset --hard HEAD~</span><br><span class="line"><span class="comment"># 再查看此时本地的文件内容</span></span><br><span class="line">$ <span class="built_in">cat</span> file1.txt</span><br><span class="line">file1 init</span><br><span class="line">add file1.txt code 1</span><br><span class="line">add file2.txt code 2</span><br><span class="line">$ <span class="built_in">cat</span> file2.txt</span><br><span class="line">file2 init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接下来恢复 feature1 上被撤销的代码</span></span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: On feature1: save file1.txt reset code</span><br><span class="line">$ git stash apply stash&#123;0&#125;</span><br><span class="line">On branch feature1</span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line">	modified:   file1.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br><span class="line"><span class="comment"># 此时代码就恢复回来了</span></span><br><span class="line">$ <span class="built_in">cat</span> file1.txt</span><br><span class="line">file1 init</span><br><span class="line">add file1.txt code 1</span><br><span class="line">add file2.txt code 2</span><br><span class="line">add file1.txt no.3 &amp; code end</span><br></pre></td></tr></table></figure><br>说明: git stash会贮存及不会贮存的文件范围</p>
<ul>
<li>会贮存: <ul>
<li>添加到暂存区的修改（staged changes）</li>
<li>git跟踪的但并未添加到暂存区的修改（unstaged changes）</li>
</ul>
</li>
<li>不会贮存:<ul>
<li>在工作目录中新的文件（untracked files）</li>
<li>被忽略的文件（ignored files）</li>
</ul>
</li>
</ul>
<p>当然, 如果仅仅需要 删除某个 commit, 其实有更好的方法<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设, 当前已经到了 git commit -m &#x27;change file1 no.3&#x27;, 当前 log </span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 3e6be928866581f1779bb0f0e84d29d068d698e8 (HEAD -&gt; feature1)</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 24 23:30:31 2022 +0800</span><br><span class="line"></span><br><span class="line">    change file1 no.3</span><br><span class="line"></span><br><span class="line">commit ef733ffec4e80ed851f353f2d8b2dba46b831bb6</span><br><span class="line">Merge: 5e96765 7d9cebd</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 24 23:30:29 2022 +0800</span><br><span class="line"></span><br><span class="line">    Merge branch <span class="string">&#x27;feature2&#x27;</span> into feature1</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们可以直接 git revert 指定的 commit, 例如 上面 merge 的 commit id 是 ef733ffec4e80ed851f353f2d8b2dba46b831bb6</span></span><br><span class="line">$ git revert -i ef733ffec4e80ed851f353f2d8b2dba46b831bb6 -m 1</span><br><span class="line"><span class="comment"># 注意, 已经要加上 -m 1, 否则会报如下错:</span></span><br><span class="line"><span class="comment">#   error: commit ef733ffec4e80ed851f353f2d8b2dba46b831bb6 is a merge but no -m option was given.</span></span><br><span class="line"><span class="comment">#   fatal: revert failed</span></span><br><span class="line"><span class="comment"># 在这里解释下 -m 1 的含义:</span></span><br><span class="line"><span class="comment">#   从上面的 git log 可以看见 &quot;Merge: 5e96765 7d9cebd&quot; 的信息, 这代表着, 本次 merge 是使用当前分支的 5e96765(commit) 和 feature2 分支的 7d9cebd(commit) 合并而来, 我们可以做一下验证:</span></span><br><span class="line"><span class="comment">#     # 首先 cat-file 5e96765</span></span><br><span class="line"><span class="comment">#     $ git cat-file -p 5e96765</span></span><br><span class="line"><span class="comment">#     tree fa6ff2fd55be9834b45f0be9d347b1670594ed17</span></span><br><span class="line"><span class="comment">#     parent d27c172b6e876938eb39094801ca5e436a30b3c3</span></span><br><span class="line"><span class="comment">#     author kino &lt;kino@gmail.com&gt; 1669303829 +0800</span></span><br><span class="line"><span class="comment">#     committer kino &lt;kino@gmail.com&gt; 1669303829 +0800</span></span><br><span class="line"><span class="comment">#     change file1 no.2</span></span><br><span class="line"><span class="comment">#    # 然后取 tree 的 id 继续查看, 可以看到, 这个 tree 记录该 commit 的两个文件</span></span><br><span class="line"><span class="comment">#    $ git cat-file -p fa6ff2fd55be9834b45f0be9d347b1670594ed17</span></span><br><span class="line"><span class="comment">#    100644 blob 4a1ca461271ec4e0041822373470703dca5d0626	file1.txt</span></span><br><span class="line"><span class="comment">#    100644 blob 18ffc0add953f06f00be32437b9f79e09af27d32	file2.txt</span></span><br><span class="line"><span class="comment">#    # 然后取 file2.txt 的 id 继续查看, 可以看到, 这个 tree 记录 该 file2.txt 的内容为: file2 init</span></span><br><span class="line"><span class="comment">#    $ git cat-file -p 18ffc0add953f06f00be32437b9f79e09af27d32</span></span><br><span class="line"><span class="comment">#    file2 init</span></span><br><span class="line"><span class="comment">#    # 然后我们再 cat-file 7d9cebd</span></span><br><span class="line"><span class="comment">#    tree 1b5c42acd113046ec223223affe7b3ef579a293b</span></span><br><span class="line"><span class="comment">#    parent 9acd7882175075c0f3e2f44dfa0d91f3d0a673d1</span></span><br><span class="line"><span class="comment">#    author kino &lt;kino@gmail.com&gt; 1669303829 +0800</span></span><br><span class="line"><span class="comment">#    committer kino &lt;kino@gmail.com&gt; 1669303829 +0800</span></span><br><span class="line"><span class="comment">#    change file2 no.1</span></span><br><span class="line"><span class="comment">#    # 然后取 tree 的 id 继续查看, 可以看到, 这个 tree 记录该 commit 的两个文件</span></span><br><span class="line"><span class="comment">#    git cat-file -p 1b5c42acd113046ec223223affe7b3ef579a293b</span></span><br><span class="line"><span class="comment">#    100644 blob 0c481f7fe4602d041634c353e31846bf1b638c37	file1.txt</span></span><br><span class="line"><span class="comment">#    100644 blob c6b0b29e598db81ef8e54ec955df78cfac4ae316	file2.txt</span></span><br><span class="line"><span class="comment">#    # 然后取 file2.txt 的 id 继续查看, 可以看到, 这个 tree 记录 该 file2.txt 的内容</span></span><br><span class="line"><span class="comment">#    git cat-file -p c6b0b29e598db81ef8e54ec955df78cfac4ae316</span></span><br><span class="line"><span class="comment">#    file2 init</span></span><br><span class="line"><span class="comment">#    add file2.txt code 1</span></span><br><span class="line"><span class="comment"># 由此我们可以得出结论, 5e96765 就是 feature1 在 Merge 之前的状态, 而 7d9cebd 就是 feature2 在 Merge 之前的状态。</span></span><br><span class="line"><span class="comment"># 因为 一个 Merge 记录了两个分支的 commit 信息, 所以, 在 revert merge 的时候,需要明确的支出, 要revert 到哪个commit, 因为我们是想取消 feature2 里面的内容, 所以就是 -m 1 </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ok, 回到正题, git revert 之后, 我们再查看 log</span></span><br><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">b4dde93 (HEAD -&gt; feature1) Revert <span class="string">&quot;Merge branch &#x27;feature2&#x27; into feature1&quot;</span></span><br><span class="line">3e6be92 change file1 no.3</span><br><span class="line">ef733ff Merge branch <span class="string">&#x27;feature2&#x27;</span> into feature1</span><br><span class="line">5e96765 change file1 no.2</span><br><span class="line">7d9cebd (feature2) change file2 no.1</span><br><span class="line">d27c172 change file1 no.1</span><br><span class="line">9acd788 (master) change: add file1 &amp; file2</span><br><span class="line"><span class="comment"># 然后查看 file2.txt</span></span><br><span class="line">$ <span class="built_in">cat</span> file2.txt</span><br><span class="line">file2 init</span><br></pre></td></tr></table></figure></p>
<h1 id="五、git-高级操作"><a href="#五、git-高级操作" class="headerlink" title="五、git 高级操作"></a>五、git 高级操作</h1><h2 id="1-git-撤销操作"><a href="#1-git-撤销操作" class="headerlink" title="1 git 撤销操作"></a>1 git 撤销操作</h2><p><strong>disk</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>command</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>查看修改</td>
<td><code>git diff</code></td>
</tr>
<tr>
<td>查看状态</td>
<td><code>git status</code> -&gt; <code>Changes not staged for comit</code></td>
</tr>
<tr>
<td>撤销文件修改</td>
<td><code>git checkout &lt;change_file&gt;  or git restore &lt;change_file&gt;</code></td>
</tr>
<tr>
<td>提交暂存区</td>
<td>git add <change_file></td>
</tr>
</tbody>
</table>
</div>
<p><strong>暂存区</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>command</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>查看状态</td>
<td><code>git status</code> -&gt; <code>Changes to be committed(绿色)</code></td>
</tr>
<tr>
<td>从暂存区移除，但保留硬盘上的修改</td>
<td><code>git reset &lt;change_file&gt;</code> or <code>git restore --staged &lt;change_file&gt;</code></td>
</tr>
<tr>
<td>从暂存区移除，不保留硬盘上的修改</td>
<td><code>git checkout HEAD &lt;change_file&gt;</code></td>
</tr>
<tr>
<td>提交本地git</td>
<td><code>git commit</code></td>
</tr>
</tbody>
</table>
</div>
<p><strong>local</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>command</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>撤销commit(保留磁盘上的修改和暂存区记录)</td>
<td><code>git reset --soft HEAD~1</code></td>
</tr>
<tr>
<td>撤销commit(清除暂存区记录, 只保留磁盘上的修改)</td>
<td><code>git reset HEAD~1</code> == <code>git reset --mixed HEAS~1</code></td>
</tr>
<tr>
<td>撤销commit(清除暂存区记录, 清除磁盘上的修改)</td>
<td><code>git reset --hard HEAD~1</code></td>
</tr>
<tr>
<td>生成新的<code>commitId</code>,将上一个<code>commit+</code>的内容变成<code>commit-</code></td>
<td><code>git revert HEAD</code></td>
</tr>
<tr>
<td>提交远端git</td>
<td><code>git push</code></td>
</tr>
</tbody>
</table>
</div>
<p><code>git reset</code> &amp; <code>git revert</code>:</p>
<ol>
<li><code>git reset</code>: 只能回到之前某一个commit的状态。</li>
<li><code>git revert</code>:撤销中间任意一个commit。<code>git revert 70a0;(git revert HEAD~1)</code></li>
</ol>
<p>如果操作项目的分支是公共分支，只能通过 <code>git revert</code> 生成一个新的 commitId，从这个结果上撤销我们之前的修改。</p>
<ol>
<li><code>git revert HEAD</code></li>
<li><code>git push</code></li>
</ol>
<p>如果操作项目的分支是个人分支，可以通过<code>git reset</code>撤销我们之前的修改</p>
<ol>
<li><code>git reset --hard HEAD~1</code></li>
<li><code>git push -f</code></li>
</ol>
<h2 id="2-git-找回丢失文件-commit了"><a href="#2-git-找回丢失文件-commit了" class="headerlink" title="2 git 找回丢失文件(commit了)"></a>2 git 找回丢失文件(commit了)</h2><p>恢复因为执行 <code>git reset --hard COMMITID</code> 丢失的文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新创建一个项目</span></span><br><span class="line">$ <span class="built_in">cd</span> .. &amp;&amp; <span class="built_in">rm</span> -rf git-study &amp;&amp; <span class="built_in">mkdir</span> git-study &amp;&amp; <span class="built_in">cd</span> git-study &amp;&amp; git init</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;master message 1&#x27;</span> &gt;&gt; master_1.txt</span><br><span class="line">$ git add master_1.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;first commit&#x27;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;master message 2&#x27;</span> &gt;&gt; master_2.txt</span><br><span class="line">$ git add master_2.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;No.2 commit&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在这两次commit的基础上, reset 到第一次(first commit)上</span></span><br><span class="line">$ git <span class="built_in">log</span>   <span class="comment"># 获取第一次commitid</span></span><br><span class="line">$ git reset --hard 4a9bcb880db85a1ca77807dea9b3adce29dc4fda</span><br><span class="line"><span class="comment"># 再次查看 log 信息, 此时可以看见只有一次commit了, 第二次 commit(No.2 commit) 已经丢失</span></span><br><span class="line">$ git <span class="built_in">log</span> -n 2</span><br></pre></td></tr></table></figure><br>git 提供了 <code>git reflog</code> 用来记录你的每一次改变目录树的命令，使用好他就可以很方便的恢复你的提交：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4a9bcb8 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 4a9bcb880db85a1ca77807dea9b3adce29dc4fda</span><br><span class="line">80258ce HEAD@&#123;1&#125;: commit: No.2 commit</span><br><span class="line">4a9bcb8 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): first commit</span><br></pre></td></tr></table></figure><br>可以看到最上面一条记录是将 HEAD 重新指向第一次的commit了, 同时也有显示第二次 commit 的 commitid, 有了这个 commitid, 就可以回滚了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard 80258ce</span><br><span class="line">HEAD is now at 80258ce No.2 commit</span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 80258ce0146f373d15a1991d61af4061687782bc (HEAD -&gt; master)</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 24 02:26:10 2022 +0800</span><br><span class="line"></span><br><span class="line">    No.2 commit</span><br><span class="line"></span><br><span class="line">commit 4a9bcb880db85a1ca77807dea9b3adce29dc4fda</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 24 02:25:06 2022 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure><br>可以看到, commit 已被找回.</p>
<p>但是通常情况下, 可能会出现在 <code>git reset</code> 之后, 还有新的 commit, 如果直接 <code>reset</code> 恢复的 commit, 肯定会造成新的 commit 又丢失, 所以如果我们只是想恢复这个一个 commit, 可以使用 <code>git cherry-pick commitid</code> 来单独将这个 commitid 恢复到当前分支或者用 <code>git merge</code> 来做合并<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git cherry-pick 04b0396</span><br><span class="line">[master fbf401a] No.2 commit</span><br><span class="line"> Date: Thu Nov 24 02:38:14 2022 +0800</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 master_2.txt</span><br><span class="line"> </span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit fbf401a96bd9831c18ed02e9ee852cef8111ccb1 (HEAD -&gt; master)</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 24 02:38:14 2022 +0800</span><br><span class="line"></span><br><span class="line">    No.2 commit</span><br><span class="line"></span><br><span class="line">commit 1b5bfdb36ad01fb86d94b76654347f5de5475f37</span><br><span class="line">Author: kino &lt;kino@gmail.com&gt;</span><br><span class="line">Date:   Thu Nov 24 02:38:05 2022 +0800</span><br><span class="line"></span><br><span class="line">    first commit</span><br></pre></td></tr></table></figure></p>
<h2 id="3-git-找回丢失文件-未commit-但添加暂存区了"><a href="#3-git-找回丢失文件-未commit-但添加暂存区了" class="headerlink" title="3 git 找回丢失文件(未commit,但添加暂存区了)"></a>3 git 找回丢失文件(未commit,但添加暂存区了)</h2><p>如果只 <code>git add</code> 了没有 <code>git commit</code>(如果连 <code>git add</code>都没有, 那只能找磁盘数据恢复的方式了), 这就不是仅仅一个 <code>git reflog</code> 就能找回的了。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> .. &amp;&amp; <span class="built_in">rm</span> -rf git-study &amp;&amp; <span class="built_in">mkdir</span> git-study &amp;&amp; <span class="built_in">cd</span> git-study &amp;&amp; git init</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;master message 1&#x27;</span> &gt;&gt; master_1.txt</span><br><span class="line">$ git add master_1.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;first commit&#x27;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;master message 2&#x27;</span> &gt;&gt; master_2.txt</span><br><span class="line">$ git add master_2.txt</span><br><span class="line">$ git commit -m <span class="string">&#x27;No.2 commit&#x27;</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;master message 3&#x27;</span> &gt;&gt; master_3.txt</span><br><span class="line">$ git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 log</span></span><br><span class="line">$ git <span class="built_in">log</span> -n 2</span><br><span class="line"><span class="comment"># 取最新的一次 commit id</span></span><br><span class="line">$ git reset --hard ee614a48f753479a111723ae7ad926e0750ffa6c</span><br><span class="line"><span class="comment"># 查看 status</span></span><br><span class="line">$ git status </span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"><span class="comment"># 查看本地文件</span></span><br><span class="line">total 16</span><br><span class="line">-rw-r--r--  1 kino  staff    17B 11 24 02:43 master_1.txt</span><br><span class="line">-rw-r--r--  1 kino  staff    17B 11 24 02:43 master_2.txt</span><br><span class="line"><span class="comment"># 可以看见文件已经丢了</span></span><br></pre></td></tr></table></figure><br>git 提供了 <code>git fsck --lost-found</code> 命令, 他会通过一些神奇的方式把历史操作过的文件以某种算法算出来加到.git/lost-found文件夹里，输出的记录就像下面这个样子。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ git fsck --lost-found</span><br><span class="line">Checking object directories: 100% (256/256), <span class="keyword">done</span>.</span><br><span class="line">dangling blob adbd4c8bf64367fb685336a67f02c5716dc47d73</span><br></pre></td></tr></table></figure><br>这里返回的第一行带有 <code>blob</code> 的信息，我们可以用 <code>git show</code>来查看里面的内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git show adbd4c8bf64367fb685336a67f02c5716dc47d73</span><br><span class="line">master message 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比如可以将内容追加到新文件中 </span></span><br><span class="line">$ git show adbd4c8bf64367fb685336a67f02c5716dc47d73 &gt; master_3.txt</span><br></pre></td></tr></table></figure></p>
<p>小记: 如果你的提交记录多的话, <code>git fsck --lost-found</code> 可以看见很多内容, 如下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ git fsck --lost-found</span><br><span class="line">Checking object directories: 100% (256/256), <span class="keyword">done</span>.</span><br><span class="line">Checking objects: 100% (35559/35559), <span class="keyword">done</span>.</span><br><span class="line">dangling blob 601e8abff177a0b2f8a31944654c0cdf0dd1f197</span><br><span class="line">dangling tree 6c247c35ae51aa86736f745802bb59b97b6598ee</span><br><span class="line">dangling blob 7a379e6f07391f3bca1fbcc076fcde8f719ffb69</span><br><span class="line">dangling blob c66fa02bf74853789b63615a80998b3fbd3d8823</span><br><span class="line">dangling blob 4996ec43a907f8f6312c3bf137e2f76c7f4c9c9c</span><br><span class="line">dangling commit 69a110054ca792e6b1060d20ec24ddc9710ada4d</span><br><span class="line">dangling blob 87ed1263b56d0a98cd163440f872f135a34b61da</span><br><span class="line">dangling blob aff0bc224d142929e3f82b8855dd1e97d8b3635b</span><br><span class="line">dangling blob eef114f8614a15a11ccfbb7cf5e34302072176e1</span><br><span class="line">dangling blob b50db5dad43e13fde45141039f684be48e293739</span><br><span class="line">dangling blob 820f0136b61394e482fd18e28a7ba81fbb31f688</span><br><span class="line">dangling blob 2d26cd809139b86218d3460c85baed90d018f007</span><br><span class="line">dangling blob 603ca9d770947939d8da7ff3aef3775bb27c427e</span><br><span class="line">dangling blob e54821ed942c6582d01f60b6715e16301cdcfc4d</span><br><span class="line">dangling blob e06be73bb272c7837ab38226c1c1bb13f845574e</span><br><span class="line">dangling blob 399aede4e687465bf7c895251bef685b0de089b6</span><br><span class="line">dangling blob 5ea2239d63a9a119a54a52fde6ebf208a940832a</span><br><span class="line">dangling blob 35ab95c7faf42b7dbbf4e0992527c719ffd4acbd</span><br><span class="line">dangling blob 9bb609de693b78eb1dc0e3dca7a9d684effd3f4a</span><br><span class="line">dangling blob aac499592477199b2630791aecde2db8a608dfa9</span><br><span class="line">dangling commit 10c581dcdf08ea1bed594a359e09698afd4f794e</span><br><span class="line">dangling blob 06eb7790a9f71bf796749940102030c6e9503022</span><br></pre></td></tr></table></figure><br>可以看到这里有<code>blob</code>、<code>commit</code>、<code>tree</code>类型的数据，其实还有<code>tag</code>等类型的, 这里需要了解下 git 的底层存储</p>
<ul>
<li><code>commit</code> 数据结构在每次提交之后都会生成一个, 当我们进行 <code>commit</code> 之后, 首先会创建一个 <code>commit</code> 组件, 之后创建一个 <code>tree</code> 组件, 把所有的文件信息都存在里面, 每个 <code>blob</code> 都代表一个文件, 都可以在 <code>tree</code> 里面找到。</li>
<li><code>blob</code> 组件并不会对文件信息进行存储, 而是只对文件的内容进行记录, 文件信息存储在 <code>tree</code> 里.</li>
</ul>
<h2 id="4-终极大招"><a href="#4-终极大招" class="headerlink" title="4 终极大招"></a>4 终极大招</h2><p>如果 5.3 并没有找到你想要的内容, 那只能再去看看最近修改的文件了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ find .git/objects -<span class="built_in">type</span> f | xargs <span class="built_in">ls</span> -lt | sed 3q</span><br><span class="line">-r--r--r--  1 kino  staff   33 11 24 02:43 .git/objects/ad/bd4c8bf64367fb685336a67f02c5716dc47d73</span><br><span class="line">-r--r--r--  1 kino  staff   33 11 24 02:43 .git/objects/cc/6e4eeea4f70e784fade7a18bdba6c28f7642e8</span><br><span class="line">-r--r--r--  1 kino  staff   33 11 24 02:43 .git/objects/24/b6cb352efeff7a2b24b99e8ff814ab1fc2a2fd</span><br></pre></td></tr></table></figure><br>使用 <code>git cat-file -t commitid</code> 可以看见是什么类型的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -t adbd4c8bf64367fb685336a67f02c5716dc47d73</span><br><span class="line">blob</span><br><span class="line"></span><br><span class="line">$ git cat-file -t cc6e4eeea4f70e784fade7a18bdba6c28f7642e8</span><br><span class="line">blob</span><br><span class="line"></span><br><span class="line">$ git cat-file -t 24b6cb352efeff7a2b24b99e8ff814ab1fc2a2fd</span><br><span class="line">blob</span><br></pre></td></tr></table></figure><br>再使用 <code>git cat-file -p commitid</code> 查看内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git cat-file -p adbd4c8bf64367fb685336a67f02c5716dc47d73</span><br><span class="line">master message 3</span><br><span class="line"></span><br><span class="line">$ git cat-file -p cc6e4eeea4f70e784fade7a18bdba6c28f7642e8</span><br><span class="line">master message 2</span><br><span class="line"></span><br><span class="line">$ git cat-file -p 24b6cb352efeff7a2b24b99e8ff814ab1fc2a2fd</span><br><span class="line">master message 1</span><br></pre></td></tr></table></figure></p>
<h2 id="5-git-迁移-保留-commit"><a href="#5-git-迁移-保留-commit" class="headerlink" title="5 git 迁移(保留 commit)"></a>5 git 迁移(保留 commit)</h2><h3 id="5-1-clone-原来的项目"><a href="#5-1-clone-原来的项目" class="headerlink" title="5.1 clone 原来的项目"></a>5.1 clone 原来的项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --bare git://github.com/username/project.git</span><br></pre></td></tr></table></figure>
<h3 id="5-2-推送到新的gitlab"><a href="#5-2-推送到新的gitlab" class="headerlink" title="5.2 推送到新的gitlab"></a>5.2 推送到新的gitlab</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> project</span><br><span class="line">$ git push --mirror git@example.com/username/newproject.git</span><br></pre></td></tr></table></figure>
<p>会提示没有权限, 在gitlab中把项目的权限保护关掉就好了</p>
<h3 id="5-3-本地代码更换gitlab地址"><a href="#5-3-本地代码更换gitlab地址" class="headerlink" title="5.3 本地代码更换gitlab地址"></a>5.3 本地代码更换gitlab地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote set-url origin git@example.com/username/newproject.git</span><br></pre></td></tr></table></figure>

    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/06/20/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Cond/">[Go] sync.Cond</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-06-20
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    
    
    

    
    <blockquote>
<p>sync.Cond 实现了一种条件变量，可以使用在多个Reader等待共享资源 ready 的场景</p>
</blockquote>
    <div class="read-more">
      <a href="/2025/06/20/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Cond/" class="read-more-link">Read more..</a>
    </div>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/06/20/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Mutex/">[Go] sync.Mutex</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-06-20
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    
    
    

    
    <blockquote>
<p>sync.Mutex 是 Go 语言中实现互斥锁的核心结构</p>
</blockquote>
    <div class="read-more">
      <a href="/2025/06/20/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Mutex/" class="read-more-link">Read more..</a>
    </div>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/06/20/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Pool/">[Go] sync.Pool</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-06-20
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    
    
    

    
    <blockquote>
<p>sync.Pool 可以作为保存临时取还对象的一个“池子”，可以缓存暂时不用的对象，下次需要时直接使用（无需重新分配）。</p>
</blockquote>
    <div class="read-more">
      <a href="/2025/06/20/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.Pool/" class="read-more-link">Read more..</a>
    </div>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/06/20/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.WaitGroup/">[Go] sync.WaitGroup</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-06-20
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    
    
    

    
    <blockquote>
<p>sync.WaitGroup 可以作为保存临时取还对象的一个“池子”，可以缓存暂时不用的对象，下次需要时直接使用（无需重新分配）。</p>
</blockquote>
    <div class="read-more">
      <a href="/2025/06/20/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/sync.WaitGroup/" class="read-more-link">Read more..</a>
    </div>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/06/03/Golang/0%20%E5%9F%BA%E7%A1%80/%E5%85%B3%E9%94%AE%E5%AD%97/Defer/">[Go] Defer</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-06-03
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    
    
    

    
    <blockquote>
<p>Defer 和栈比较相似，<strong>先进后出</strong>，即先注册的 defer 会后执行。</p>
</blockquote>
    <div class="read-more">
      <a href="/2025/06/03/Golang/0%20%E5%9F%BA%E7%A1%80/%E5%85%B3%E9%94%AE%E5%AD%97/Defer/" class="read-more-link">Read more..</a>
    </div>
    
    
  </div>

  

  

</article>
  
  <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      <a class="post-link" href="/2025/06/03/Golang/0%20%E5%9F%BA%E7%A1%80/%E5%85%B3%E9%94%AE%E5%AD%97/New%20%E5%92%8C%20Make%20%E7%9A%84%E5%8C%BA%E5%88%AB/">[Go] New &amp; Make</a>
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2025-06-03
      </span>
      
      
      
    </div>
  </header>

  

  <div class="post-content">
    
    
    
    
    

    
    <blockquote>
<p>new 和 make 都可以用来分配空间，初始化类型</p>
</blockquote>
    <div class="read-more">
      <a href="/2025/06/03/Golang/0%20%E5%9F%BA%E7%A1%80/%E5%85%B3%E9%94%AE%E5%AD%97/New%20%E5%92%8C%20Make%20%E7%9A%84%E5%8C%BA%E5%88%AB/" class="read-more-link">Read more..</a>
    </div>
    
    
  </div>

  

  

</article>
  
    
  <nav class="pagination">  
      
      <a class="prev" href="/page/2/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text">Prev</span>  
      </a>  
      
      
      <a class="next" href="/page/4/">  
        <span class="next-text">Next</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  
</section>
        </div>
      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2019 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">draco</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
  







<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>



<script type="text/javascript" src="/lib/slideout/slideout.js"></script>



<script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>