<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->

<meta name="description" content="[Go] GMP" />


<!-- Website keywords -->

<meta name="keywords" content="Golang, Draco&#39;s Blog" />




<!-- Website rss -->

<link rel="alternate" href="/default" title="Draco's Blog" >


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://stardustorz.github.io/2022/07/03/Golang/1 并发编程/GMP/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":false};
</script>
  
  <title>[Go] GMP - Draco&#39;s Blog</title>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Draco&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        Home              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        Archives              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        Tags              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        Categories              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        About              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">Draco's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              Home  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              Archives  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              Tags  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              Categories  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              About  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      [Go] GMP
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2022-07-03
      </span>
      
      
      <span class="post-category">
        
        <a href="/categories/Golang/">Golang</a>
        
        <a href="/categories/Golang/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a>
        
      </span>
      
      
    </div>
  </header>

  
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E5%BF%B5"><span class="toc-number">1.</span> <span class="toc-text">1 概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%8D%8F%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-Goroutine"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 Goroutine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-GMP-%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.</span> <span class="toc-text">2 GMP 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-g"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 g</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-m"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 m</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-p"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 p</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-GMP"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 GMP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">3 核心数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-g"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 g</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-m"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 m</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-p"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 p</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-schedt"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 schedt</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">4 调度流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-g0-%E5%92%8C-g-%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 g0 和 g 的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E8%B0%83%E5%BA%A6%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 调度类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-%E4%B8%BB%E5%8A%A8%E8%B0%83%E5%BA%A6"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1 主动调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E8%A2%AB%E5%8A%A8%E8%B0%83%E5%BA%A6"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2 被动调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E6%AD%A3%E5%B8%B8%E8%B0%83%E5%BA%A6"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3 正常调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E6%8A%A2%E5%8D%A0%E8%B0%83%E5%BA%A6"><span class="toc-number">4.2.4.</span> <span class="toc-text">4.2.4 抢占调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%AE%8F%E8%A7%82%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 宏观调度流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-schedule"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 schedule</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-findRunnable"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 findRunnable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-execute"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 execute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-gosched-m"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 gosched_m</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-park-m-%E4%B8%8E-ready"><span class="toc-number">4.8.</span> <span class="toc-text">4.8 park_m 与 ready</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-goexit0"><span class="toc-number">4.9.</span> <span class="toc-text">4.9 goexit0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-retake"><span class="toc-number">4.10.</span> <span class="toc-text">4.10 retake</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-reentersyscall-%E5%92%8C-exitsyscall"><span class="toc-number">4.11.</span> <span class="toc-text">4.11 reentersyscall 和 exitsyscall</span></a></li></ol></li></ol>
    </div>
  </div>
  

  <div class="post-content">
    
    <blockquote>
<p>gmp = goroutine + machine + processor</p>
</blockquote>
<span id="more"></span>
<h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><h3 id="1-1-线程"><a href="#1-1-线程" class="headerlink" title="1.1 线程"></a>1.1 线程</h3><p>通常指的是内核级线程，核心点如下：</p>
<ul>
<li>是操作系统最小调度单元；</li>
<li>创建、销毁、调度交由内核完成，cpu 需完成用户态与内核态间的切换；</li>
<li>可充分利用多核，实现并行.<h3 id="1-2-协程"><a href="#1-2-协程" class="headerlink" title="1.2 协程"></a>1.2 协程</h3></li>
</ul>
<p>协程，又称为用户级线程，核心点如下：</p>
<ul>
<li>与线程存在映射关系，为 M：1；</li>
<li>创建、销毁、调度在用户态完成，对内核透明，所以更轻；</li>
<li>从属同一个内核级线程，无法并行；一个协程阻塞会导致从属同一线程的所有协程无法执行.</li>
</ul>
<h3 id="1-3-Goroutine"><a href="#1-3-Goroutine" class="headerlink" title="1.3 Goroutine"></a>1.3 Goroutine</h3><p>Goroutine，经 Golang 优化后的特殊“协程”，特点如下：</p>
<ul>
<li>与线程存在映射关系，为 M：N；</li>
<li>创建、销毁、调度在用户态完成，对内核透明，足够轻便；</li>
<li>可利用多个线程，实现并行；</li>
<li>通过调度器的，实现和线程间的动态绑定和灵活调度；</li>
<li>栈空间大小可动态扩缩.</li>
</ul>
<h3 id="1-4-对比"><a href="#1-4-对比" class="headerlink" title="1.4 对比"></a>1.4 对比</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>模型</strong></th>
<th><strong>弱依赖内核</strong></th>
<th><strong>可并行</strong></th>
<th><strong>可应对阻塞</strong></th>
<th><strong>栈可动态扩缩</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>线程</td>
<td>❎</td>
<td>✅</td>
<td>✅</td>
<td>❎</td>
</tr>
<tr>
<td>协程</td>
<td>✅</td>
<td>❎</td>
<td>❎</td>
<td>❎</td>
</tr>
<tr>
<td>goroutine</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-GMP-模型"><a href="#2-GMP-模型" class="headerlink" title="2 GMP 模型"></a>2 GMP 模型</h2><h3 id="2-1-g"><a href="#2-1-g" class="headerlink" title="2.1 g"></a>2.1 g</h3><ul>
<li>g 即goroutine，是 golang 中对协程的抽象</li>
<li>g 有自己的运行栈、状态、以及执行的任务函数（用户通过 go func 指定）</li>
<li>g 需要绑定到 p 才能执行，在 g 的视角中，p 就是它的 cpu</li>
</ul>
<h3 id="2-2-m"><a href="#2-2-m" class="headerlink" title="2.2 m"></a>2.2 m</h3><ul>
<li>m 即 machine，是 golang 中对线程的抽象</li>
<li>m 不直接执行 g，而是先和 p 绑定，由其实现代理</li>
<li>借由 p 的存在，m 无需和 g 绑死，也无需记录 g 的状态信息，因此 g 在全生命周期中可以实现跨 m 执行.</li>
</ul>
<h3 id="2-3-p"><a href="#2-3-p" class="headerlink" title="2.3 p"></a>2.3 p</h3><ul>
<li>p 即 processor，是 golang 中的调度器</li>
<li>p 是 gmp 的中枢，借由 p 承上启下，实现 g 和 m 之间的动态有机结合</li>
<li>对 g 而言，p 是其 cpu，g 只有被 p 调度，才得以执行</li>
<li>对 m 而言，p 是其执行代理，为其提供必要信息的同时（可执行的 g、内存分配情况等），并隐藏了繁杂的调度细节</li>
<li>p 的数量决定了 g 最大并行数量，可由用户通过 GOMAXPROCS 进行设定（超过 CPU 核数时无意义）</li>
</ul>
<h3 id="2-4-GMP"><a href="#2-4-GMP" class="headerlink" title="2.4 GMP"></a>2.4 GMP</h3><ul>
<li>M 是线程的抽象；G 是 goroutine；P 是承上启下的调度器；</li>
<li>M调度G前，需要和P绑定；</li>
<li>全局有多个M和多个P，但同时并行的G的最大数量等于P的数量；</li>
<li>G的存放队列有三类：P的本地队列；全局队列；和wait队列（图中未展示，为io阻塞就绪态goroutine队列）；</li>
<li>M调度G时，优先取P本地队列，其次取全局队列，最后取wait队列；这样的好处是，取本地队列时，可以接近于无锁化，减少全局锁竞争；</li>
<li>为防止不同P的闲忙差异过大，设立work-stealing机制，本地队列为空的P可以尝试从其他P本地队列偷取一半的G补充到自身队列.</li>
</ul>
<h2 id="3-核心数据结构"><a href="#3-核心数据结构" class="headerlink" title="3 核心数据结构"></a>3 核心数据结构</h2><blockquote>
<p>gmp 数据结构定义在 runtime/runtime2.go 文件中</p>
</blockquote>
<h3 id="3-1-g"><a href="#3-1-g" class="headerlink" title="3.1 g"></a>3.1 g</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> g <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    m         *m      </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sched     gobuf</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> gobuf <span class="keyword">struct</span> &#123;</span><br><span class="line">    sp   <span class="type">uintptr</span></span><br><span class="line">    pc   <span class="type">uintptr</span></span><br><span class="line">    ret  <span class="type">uintptr</span></span><br><span class="line">    bp   <span class="type">uintptr</span> <span class="comment">// for framepointer-enabled architectures</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>m：在 p 的代理，负责执行当前 g 的 m；</li>
<li>sched.sp：保存 CPU 的 rsp 寄存器的值，指向函数调用栈栈顶；</li>
<li>sched.pc：保存 CPU 的 rip 寄存器的值，指向程序下一条执行指令的地址；</li>
<li>sched.ret：保存系统调用的返回值；</li>
<li>sched.bp：保存 CPU 的 rbp 寄存器的值，存储函数栈帧的起始位置.</li>
</ul>
<p>g的生命周期:未初始化完成 等待被执行  执行  执行系统调用  挂起态  被销毁  栈扩容 被抢占</p>
<h3 id="3-2-m"><a href="#3-2-m" class="headerlink" title="3.2 m"></a>3.2 m</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> m <span class="keyword">struct</span> &#123;</span><br><span class="line">    g0      *g     <span class="comment">// goroutine with scheduling stack</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    tls           [tlsSlots]<span class="type">uintptr</span> <span class="comment">// thread-local storage (for x86 extern register)</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>g0：一类特殊的调度协程，不用于执行用户函数，负责执行 g 之间的切换调度. 与 m 的关系为 1:1；</li>
<li>tls：thread-local storage，线程本地存储，存储内容只对当前线程可见. 线程本地存储的是 m.tls 的地址，m.tls[0] 存储的是当前运行的 g，因此线程可以通过 g 找到当前的 m、p、g0 等信息.<h3 id="3-3-p"><a href="#3-3-p" class="headerlink" title="3.3 p"></a>3.3 p</h3></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> p <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    runqhead <span class="type">uint32</span></span><br><span class="line">    runqtail <span class="type">uint32</span></span><br><span class="line">    runq     [<span class="number">256</span>]guintptr</span><br><span class="line">    </span><br><span class="line">    runnext guintptr</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>runq：本地 goroutine 队列，最大长度为 256.</li>
<li>runqhead：队列头部；</li>
<li>runqtail：队列尾部；</li>
<li>runnext：下一个可执行的 goroutine.</li>
</ul>
<h3 id="3-4-schedt"><a href="#3-4-schedt" class="headerlink" title="3.4 schedt"></a>3.4 schedt</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> schedt <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    lock mutex</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    runq     gQueue</span><br><span class="line">    runqsize <span class="type">int32</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sched 是全局 goroutine 队列的封装：</p>
<ul>
<li>lock：一把操作全局队列时使用的锁；</li>
<li>runq：全局 goroutine 队列；</li>
<li>runqsize：全局 goroutine 队列的容量.</li>
</ul>
<h2 id="4-调度流程"><a href="#4-调度流程" class="headerlink" title="4 调度流程"></a>4 调度流程</h2><h3 id="4-1-g0-和-g-的转换"><a href="#4-1-g0-和-g-的转换" class="headerlink" title="4.1 g0 和 g 的转换"></a>4.1 g0 和 g 的转换</h3><p><strong>goroutine 的类型可分为两类：</strong></p>
<ul>
<li>负责调度普通 g 的 g0，执行固定的调度流程，与 m 的关系为一对一</li>
<li>负责执行用户函数的普通 g<br>m 通过 p 调度执行的 goroutine 永远在普通 g 和 g0 之间进行切换，当 g0 找到可执行的 g 时，会调用 gogo 方法，调度 g 执行用户定义的任务；当 g 需要主动让渡或被动调度时，会触发 mcall 方法，将执行权重新交还给 g0.</li>
</ul>
<h3 id="4-2-调度类型"><a href="#4-2-调度类型" class="headerlink" title="4.2 调度类型"></a>4.2 调度类型</h3><blockquote>
<p>调度器 p 实现从执行一个 g 切换到另一个 g 的过程.</p>
</blockquote>
<h4 id="4-2-1-主动调度"><a href="#4-2-1-主动调度" class="headerlink" title="4.2.1 主动调度"></a>4.2.1 主动调度</h4><ul>
<li>用户主动执行让渡的方式，主要方式是，用户在执行代码中调用了 runtime.Gosched 方法，此时当前 g 会当让出执行权，主动进行队列等待下次被调度执行.</li>
</ul>
<h4 id="4-2-2-被动调度"><a href="#4-2-2-被动调度" class="headerlink" title="4.2.2 被动调度"></a>4.2.2 被动调度</h4><ul>
<li>因当前不满足某种执行条件，g 可能会陷入阻塞态无法被调度，直到关注的条件达成后，g才从阻塞中被唤醒，重新进入可执行队列等待被调度.</li>
<li><p>常见的被动调度触发方式为因 channel 操作或互斥锁操作陷入阻塞等操作，底层会走进 gopark 方法.</p>
<h4 id="4-2-3-正常调度"><a href="#4-2-3-正常调度" class="headerlink" title="4.2.3 正常调度"></a>4.2.3 正常调度</h4></li>
<li><p>g 中的执行任务已完成，g0 会将当前 g 置为死亡状态，发起新一轮调度.</p>
<h4 id="4-2-4-抢占调度"><a href="#4-2-4-抢占调度" class="headerlink" title="4.2.4 抢占调度"></a>4.2.4 抢占调度</h4></li>
<li><p>如果 g 执行系统调用超过指定的时长，且全局的 p 资源比较紧缺，此时将 p 和 g 解绑，抢占出来用于其他 g 的调度. 等 g 完成系统调用后，会重新进入可执行队列中等待被调度.</p>
</li>
<li>前 3 种调度方式都由 m 下的 g0 完成，唯独抢占调度不同.</li>
<li>因为发起系统调用时需要打破用户态的边界进入内核态，此时 m 也会因系统调用而陷入僵直，无法主动完成抢占调度的行为.</li>
<li>因此，在 Golang 进程会有一个全局监控协程 monitor g 的存在，这个 g 会越过 p 直接与一个 m 进行绑定，不断轮询对所有 p 的执行状况进行监控. 倘若发现满足抢占调度的条件，则会从第三方的角度出手干预，主动发起该动作.</li>
</ul>
<h3 id="4-3-宏观调度流程"><a href="#4-3-宏观调度流程" class="headerlink" title="4.3 宏观调度流程"></a>4.3 宏观调度流程</h3><ul>
<li>g0 执行 schedule() 函数，寻找到用于执行的 g</li>
<li>g0 执行 execute() 方法，更新当前 g、p 的状态信息，并调用 gogo() 方法，将执行权交给 g</li>
<li>g 因主动让渡( gosche_m() )、被动调度( park_m() )、正常结束( goexit0() )等原因，调用 m_call 函数，执行权重新回到 g0 手中</li>
<li>g0 执行 schedule() 函数，开启新一轮循环</li>
</ul>
<h3 id="4-4-schedule"><a href="#4-4-schedule" class="headerlink" title="4.4 schedule"></a>4.4 schedule</h3><p>调度流程的主干方法是位于 runtime/proc.go 中的 schedule 函数，此时的执行权位于 g0 手中：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    gp, inheritTime, tryWakeP := findRunnable() <span class="comment">// blocks until work is available</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    execute(gp, inheritTime)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>寻找到下一个执行的 goroutine</li>
<li>执行该 goroutine</li>
</ul>
<h3 id="4-5-findRunnable"><a href="#4-5-findRunnable" class="headerlink" title="4.5 findRunnable"></a>4.5 findRunnable</h3><p><img src="file-20250303232645826.png" alt=""></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRunnable</span><span class="params">()</span></span> (gp *g, inheritTime, tryWakeP <span class="type">bool</span>) &#123;</span><br><span class="line">    _g_ := getg()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">    _p_ := _g_.m.p.ptr()</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> _p_.schedtick%<span class="number">61</span> == <span class="number">0</span> &amp;&amp; sched.runqsize &gt; <span class="number">0</span> &#123;</span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        gp = globrunqget(_p_, <span class="number">1</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> gp, inheritTime := runqget(_p_); gp != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> gp, inheritTime, <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> sched.runqsize != <span class="number">0</span> &#123;</span><br><span class="line">        lock(&amp;sched.lock)</span><br><span class="line">        gp := globrunqget(_p_, <span class="number">0</span>)</span><br><span class="line">        unlock(&amp;sched.lock)</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> netpollinited() &amp;&amp; atomic.Load(&amp;netpollWaiters) &gt; <span class="number">0</span> &amp;&amp; atomic.Load64(&amp;sched.lastpoll) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> list := netpoll(<span class="number">0</span>); !list.empty() &#123; <span class="comment">// non-blocking</span></span><br><span class="line">            gp := list.pop()</span><br><span class="line">            injectglist(&amp;list)</span><br><span class="line">            casgstatus(gp, _Gwaiting, _Grunnable)</span><br><span class="line">            <span class="keyword">return</span> gp, <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    procs := <span class="type">uint32</span>(gomaxprocs)</span><br><span class="line">    <span class="keyword">if</span> _g_.m.spinning || <span class="number">2</span>*atomic.Load(&amp;sched.nmspinning) &lt; procs-atomic.Load(&amp;sched.npidle) &#123;</span><br><span class="line">        <span class="keyword">if</span> !_g_.m.spinning &#123;</span><br><span class="line">            _g_.m.spinning = <span class="literal">true</span></span><br><span class="line">            atomic.Xadd(&amp;sched.nmspinning, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gp, inheritTime, tnow, w, newWork := stealWork(now)</span><br><span class="line">        now = tnow</span><br><span class="line">        <span class="keyword">if</span> gp != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// Successfully stole.</span></span><br><span class="line">            <span class="keyword">return</span> gp, inheritTime, <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> newWork &#123;</span><br><span class="line">            <span class="comment">// There may be new timer or GC work; restart to</span></span><br><span class="line">            <span class="comment">// discover.</span></span><br><span class="line">            <span class="keyword">goto</span> top</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> w != <span class="number">0</span> &amp;&amp; (pollUntil == <span class="number">0</span> || w &lt; pollUntil) &#123;</span><br><span class="line">            <span class="comment">// Earlier timer to wait for.</span></span><br><span class="line">            pollUntil = w</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>p 每执行 61 次调度，会从全局队列中获取一个 goroutine 进行执行，并将一个全局队列中的 goroutine 填充到当前 p 的本地队列中<ul>
<li>取得 p 本地队列队首的索引，同时对本地队列加锁</li>
<li>倘若 p 的局部队列未满，则成功转移 g，将 p 的对尾索引 runqtail 值加 1 并解锁队列.</li>
<li>倘若发现本地队列 runq 已经满了，则会返回来将本地队列中一半的 g 放回全局队列中，帮助当前 p 缓解执行压力，这部分内容位于 runqputslow 方法中</li>
</ul>
</li>
<li>尝试从 p 本地队列中获取一个可执行的 goroutine，核心逻辑位于 runqget 方法中<ul>
<li>倘若当前 p 的 runnext 非空，直接获取即可</li>
<li>加锁从 p 的本地队列中获取 g, 虽然本地队列是属于 p 独有的，但是由于 work-stealing 机制的存在，其他 p 可能会前来执行窃取动作，因此操作仍需加锁.</li>
<li>倘若本地队列为空，直接终止并返回</li>
<li>倘若本地队列存在 g，则取得队首的 g，解锁并返回</li>
</ul>
</li>
<li>倘若本地队列没有可执行的 g，会从全局队列中获取</li>
<li>倘若本地队列和全局队列都没有 g，则会获取准备就绪的网络协程</li>
<li>work-stealing: 从其他 p 中偷取 g<ul>
<li>偷取操作至多会遍历全局的 p 队列 4 次，过程中只要找到可窃取的 p 则会立即返回.</li>
<li>为保证窃取行为的公平性，遍历的起点是随机的. 窃取动作的核心逻辑位于 runqgrab 方法当中</li>
<li>每次对一个 p 尝试窃取前，会对其局部队列加锁</li>
<li>尝试偷取其现有的一半 g，并且返回实际偷取的数量</li>
</ul>
</li>
</ul>
<h3 id="4-6-execute"><a href="#4-6-execute" class="headerlink" title="4.6 execute"></a>4.6 execute</h3><p>当 g0 为 m 寻找到可执行的 g 之后，接下来就开始执行 g. 这部分内容位于 runtime/proc.go 的 execute 方法中</p>
<ul>
<li>更新 g 的状态信息，建立 g 与 m 之间的绑定关系</li>
<li>更新 p 的总调度次数</li>
<li>调用 gogo 方法，执行 goroutine 中的任务</li>
</ul>
<h3 id="4-7-gosched-m"><a href="#4-7-gosched-m" class="headerlink" title="4.7 gosched_m"></a>4.7 gosched_m</h3><p>g 执行主动让渡时，会调用 mcall 方法将执行权归还给 g0，并由 g0 调用 gosched_m 方法，位于 runtime/proc.go 文件中</p>
<p><img src="file-20250303234355218.png" alt=""></p>
<ul>
<li>将当前 g 的状态由执行中切换为待执行 <code>_Grunnable</code></li>
<li>调用 dropg() 方法，将当前的 m 和 g 解绑</li>
<li>将 g 添加到全局队列当中</li>
<li>开启新一轮的调度</li>
</ul>
<h3 id="4-8-park-m-与-ready"><a href="#4-8-park-m-与-ready" class="headerlink" title="4.8 park_m 与 ready"></a>4.8 park_m 与 ready</h3><ul>
<li>g 需要被动调度时，会调用 mcall 方法切换至 g0，并调用 park_m 方法将 g 置为阻塞态，执行流程位于 runtime/proc.go 的 gopark 方法当中<ul>
<li>将当前 g 的状态由 running 改为 waiting</li>
<li>将 g 与 m 解绑</li>
<li>执行新一轮的调度 schedule</li>
</ul>
</li>
<li>当因被动调度陷入阻塞态的 g 需要被唤醒时，会由其他协程执行 goready 方法将 g 重新置为可执行的状态，方法位于 runtime/proc.go<ul>
<li>先将 g 的状态从阻塞态改为可执行的状态</li>
<li>调用 runqput 将当前 g 添加到唤醒者 p 的本地队列中，如果队列满了，会连带 g 一起将一半的元素转移到全局队列</li>
</ul>
</li>
</ul>
<h3 id="4-9-goexit0"><a href="#4-9-goexit0" class="headerlink" title="4.9 goexit0"></a>4.9 goexit0</h3><ul>
<li>当 g 执行完成时，会先执行 mcall 方法切换至 g0，然后调用 goexit0 方法<ul>
<li>将 g 状态置为 dead</li>
<li>解绑 g 和 m</li>
<li>开启新一轮的调度</li>
</ul>
</li>
</ul>
<h3 id="4-10-retake"><a href="#4-10-retake" class="headerlink" title="4.10 retake"></a>4.10 retake</h3><p>抢占调度的执行者不是 g0，而是一个全局的 monitor g，代码位于 runtime/proc.go 的 retake 方法中<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">retake</span><span class="params">(now <span class="type">int64</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">    n := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    lock(&amp;allpLock)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(allp); i++ &#123;</span><br><span class="line">        _p_ := allp[i]</span><br><span class="line">        <span class="keyword">if</span> _p_ == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">// This can happen if procresize has grown</span></span><br><span class="line">            <span class="comment">// allp but not yet created new Ps.</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        pd := &amp;_p_.sysmontick</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> s == _Psyscall &#123;            </span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">if</span> runqempty(_p_) &amp;&amp; atomic.Load(&amp;sched.nmspinning)+atomic.Load(&amp;sched.npidle) &gt; <span class="number">0</span> &amp;&amp; pd.syscallwhen+<span class="number">10</span>*<span class="number">1000</span>*<span class="number">1000</span> &gt; now &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            unlock(&amp;allpLock)</span><br><span class="line">            <span class="keyword">if</span> atomic.Cas(&amp;_p_.status, s, _Pidle) &#123;</span><br><span class="line">                n++</span><br><span class="line">                _p_.syscalltick++</span><br><span class="line">                handoffp(_p_)</span><br><span class="line">            &#125;</span><br><span class="line">            incidlelocked(<span class="number">1</span>)</span><br><span class="line">            lock(&amp;allpLock)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock(&amp;allpLock)</span><br><span class="line">    <span class="keyword">return</span> <span class="type">uint32</span>(n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>加锁后，遍历全局的 p 队列，寻找需要被抢占的目标</li>
<li>倘若某个 p 同时满足下述条件，则会进行抢占调度<ul>
<li>执行系统调用超过 10 ms</li>
<li>p 本地队列有等待执行的 g</li>
<li>或者当前没有空闲的 p 和 m</li>
</ul>
</li>
<li>抢占调度的步骤是，先将当前 p 的状态更新为 idle，然后步入 handoffp 方法中，判断是否需要为 p 寻找接管的 m（因为其原本绑定的 m 正在执行系统调用）</li>
<li>当以下条件满足其一时，则需要为 p 获取新的 m<ul>
<li>当前 p 本地队列还有待执行的 g</li>
<li>全局繁忙（没有空闲的 p 和 m，全局 g 队列为空）</li>
<li>需要处理网络 socket 读写请求</li>
</ul>
</li>
<li>获取 m 时，会先尝试获取已有的空闲的 m，若不存在，则会创建一个新的 m</li>
</ul>
<h3 id="4-11-reentersyscall-和-exitsyscall"><a href="#4-11-reentersyscall-和-exitsyscall" class="headerlink" title="4.11 reentersyscall 和 exitsyscall"></a>4.11 reentersyscall 和 exitsyscall</h3><p>在 m 需要执行系统调用前，会先执行位于 runtime/proc.go 的 reentersyscall 的方法</p>
<ul>
<li>此时执行权同样位于 m 的 g0 手中</li>
<li>保存当前 g 的执行环境</li>
<li>将 g 和 p 的状态更新为 syscall</li>
<li>解除 p 和 当前 m 之间的绑定，因为 m 即将进入系统调用而导致短暂不可用</li>
<li>将 p 添加到 当前 m 的 oldP 容器当中，后续 m 恢复后，会优先寻找旧的 p 重新建立绑定关系</li>
</ul>
<p>当 m 完成了内核态的系统调用之后，此时会步入位于 runtime/proc.go 的 exitsyscall 函数中，尝试寻找 p 重新开始运作</p>
<ul>
<li>方法执行之初，此时的执行权是普通 g.倘若此前设置的 oldp 仍然可用，则重新和 oldP 绑定，将当前 g 重新置为 running 状态，然后开始执行后续的用户函数</li>
<li>old 绑定失败，则调用 mcall 方法切换到 m 的 g0，并执行 exitsyscall0 方法</li>
<li>将 g 由系统调用状态切换为可运行态，并解绑 g 和 m 的关系</li>
<li>从全局 p 队列获取可用的 p，如果获取到了，则执行 g</li>
<li>如若无 p 可用，则将 g 添加到全局队列，当前 m 陷入沉睡. 直到被唤醒后才会继续发起调度.</li>
</ul>

    
  </div>

  
  <!-- Post Copyright -->

<div class="post-copyright">
  <p class="copyright-item">
    <span>Author: </span>
    <a href="https://stardustorz.github.io">draco</a>
  </p>
  <p class="copyright-item">
    <span>Link: </span>
    <a href="https://stardustorz.github.io/2022/07/03/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP/">https://stardustorz.github.io/2022/07/03/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP/</a>
  </p>
  <p class="copyright-item">
    <span>License: </span>
    
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
  </p>
</div>

    

  

  
  <footer class="post-footer">
    
    <div class="post-tags">
      
      <a href="/tags/Golang/">Golang</a>
      
    </div>
    
      
  <nav class="post-nav">  
      
      <a class="prev" href="/2022/07/09/Golang/1%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/go-sync.pool/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text nav-default">[Go] sync.pool</span>  
        <span class="prev-text nav-mobile">Prev</span>  
      </a>  
      
      
      <a class="next" href="/2021/12/13/Golang/0%20%E5%9F%BA%E7%A1%80/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80/">  
        <span class="next-text nav-default">[Go] 类型断言</span>  
        <span class="prev-text nav-mobile">Next</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  </footer>
  

</article>
        </div>
          
  <div class="comments" id="comments">  
      
  </div>  
  

      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2019 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">draco</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
    
    
    
    
    
    
  

  







<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>



<script type="text/javascript" src="/lib/slideout/slideout.js"></script>



<script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>