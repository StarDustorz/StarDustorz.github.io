<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->


<!-- Website keywords -->




<!-- Website rss -->

<link rel="alternate" href="/atom.xml" title="Draco's Blog" type="application/atom+xml">


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://stardustorz.github.io/2023/10/09/Basic/操作系统/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":false};
</script>
  
  <title> - Draco&#39;s Blog</title>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Draco&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        Home              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        Archives              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        Tags              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        Categories              </li>
    </a>
    
    <a href="/links/">
      <li class="mobile-menu-item">
        
        
        Links              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        About              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">Draco's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              Home  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              Archives  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              Tags  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              Categories  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/links/">  
              
              
              Links  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              About  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2023-10-09
      </span>
      
      
      
    </div>
  </header>

  
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">1 硬件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">2 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 虚拟内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 内存分段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 内存分页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E6%AE%B5%E9%A1%B5%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 段页式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-Linux-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">2.5.</span> <span class="toc-text">2.5 Linux 内存布局</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">3 进程管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%BF%9B%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 进程基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1 进程的状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2 进程的控制结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3 进程的上下文切换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 进程通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%8D%8F%E7%A8%8B"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 协程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">4 调度算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 进程调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%86%85%E5%AD%98%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 内存页面置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 磁盘调度算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BD%91%E7%BB%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.</span> <span class="toc-text">5 网络系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E9%9B%B6%E6%8B%B7%E8%B4%9D"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 零拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-I-O-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 I&#x2F;O 多路复用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-Select"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1 Select</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-poll"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2 poll</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-3-epoll"><span class="toc-number">5.2.3.</span> <span class="toc-text">5.2.3 epoll</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E9%AB%98%E6%80%A7%E8%83%BD%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 高性能网络模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-Reactor-%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.3.1 Reactor 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-Proactor-%E5%BC%82%E6%AD%A5%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.2.</span> <span class="toc-text">5.3.2 Proactor 异步网络模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-Linux%E5%91%BD%E4%BB%A4"><span class="toc-number">6.</span> <span class="toc-text">6 Linux命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%9F%A5%E7%9C%8B%E7%BD%91%E7%BB%9C%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 查看网络性能指标</span></a></li></ol></li></ol>
    </div>
  </div>
  

  <div class="post-content">
    
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1-硬件结构"><a href="#1-硬件结构" class="headerlink" title="1 硬件结构"></a>1 硬件结构</h2><ul>
<li>什么是中断？<ul>
<li>中断是系统用来响应硬件设备请求的一种机制，操作系统收到硬件的中断请求，会打断正在执行的进程，然后调用内核中的中断处理程序来响应请求。</li>
</ul>
</li>
<li>什么是软中断？<ul>
<li>为了解决中断处理程序执行过长和中断丢失的问题，将中断过程分成了两个阶段，分别是「上半部和下半部分」</li>
<li><strong>上半部直接处理硬件请求，也就是硬中断</strong>，主要是负责耗时短的工作，特点是快速执行；</li>
<li><strong>下半部是由内核触发，也就说软中断</strong>，主要是负责上半部未完成的工作，通常都是耗时比较长的事情，特点是延迟执行；</li>
</ul>
</li>
</ul>
<h2 id="2-内存管理"><a href="#2-内存管理" class="headerlink" title="2 内存管理"></a>2 内存管理</h2><h3 id="2-1-虚拟内存"><a href="#2-1-虚拟内存" class="headerlink" title="2.1 虚拟内存"></a>2.1 虚拟内存</h3><ul>
<li><em>虚拟地址</em>： 隔离不同进程，给每个进程独立的虚拟地址，并通过内存管理单元 MMU 映射到物理地址。</li>
<li><em>虚拟内存</em>：让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。  因为申请了不代表会用满，局部性原理<h3 id="2-2-内存分段"><a href="#2-2-内存分段" class="headerlink" title="2.2 内存分段"></a>2.2 内存分段</h3></li>
<li>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。<strong>不同的段是有不同的属性的，所以就用分段（<em>Segmentation</em>）的形式把这些段分离出来。</strong></li>
<li>分段机制下的虚拟地址由两部分组成，<strong>段选择因子</strong>和<strong>段内偏移量</strong>。<ul>
<li><strong>段选择子</strong>就保存在段寄存器里面。段选择子里面最重要的是<strong>段号</strong>，用作段表的索引。<strong>段表</strong>里面保存的是这个<strong>段的基地址、段的界限和特权等级</strong>等。</li>
<li>虚拟地址中的<strong>段内偏移量</strong>应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</li>
</ul>
</li>
<li>缺点：<strong>内存碎片</strong>，内存交换效率低<h3 id="2-3-内存分页"><a href="#2-3-内存分页" class="headerlink" title="2.3 内存分页"></a>2.3 内存分页</h3></li>
<li><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）。在 Linux 下，每一页的大小为 <code>4KB</code>。</li>
<li><strong>内存管理单元</strong> （<em>MMU</em>）将虚拟内存地址转换成物理地址</li>
<li>分页机制下，虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，<strong>页表</strong>包含物理页每页所在<strong>物理内存的基地址</strong>，这个基地址与页内偏移的组合就形成了物理内存地址</li>
<li><em>多级页表</em>：将页表（一级页表）分为 <code>1024</code> 个页表（二级页表），每个表（二级页表）中包含 <code>1024</code> 个「页表项」，形成<strong>二级分页</strong>。</li>
<li><em>快表 TLB</em>： 页表缓存、转址旁路缓存、快表; 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。<h3 id="2-4-段页式"><a href="#2-4-段页式" class="headerlink" title="2.4 段页式"></a>2.4 段页式</h3></li>
<li>先将程序划分为多个有逻辑意义的段，再把每个段划分为多个页</li>
<li>地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成</li>
<li>每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号<h3 id="2-5-Linux-内存布局"><a href="#2-5-Linux-内存布局" class="headerlink" title="2.5 Linux 内存布局"></a>2.5 Linux 内存布局</h3></li>
<li><strong>Linux 系统主要采用了分页管理，但是由于 Intel 处理器的发展史，Linux 系统无法避免分段管理</strong>。于是 Linux 就把所有段的基地址设为 <code>0</code>，也就意味着所有程序的地址空间都是线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。</li>
<li>Linux 系统中虚拟空间分布可分为<strong>用户态</strong>和<strong>内核态</strong>两部分，其中用户态的分布：代码段、全局变量、BSS、函数栈、堆内存、映射区。<h2 id="3-进程管理"><a href="#3-进程管理" class="headerlink" title="3 进程管理"></a>3 进程管理</h2><h3 id="3-1-进程基础知识"><a href="#3-1-进程基础知识" class="headerlink" title="3.1 进程基础知识"></a>3.1 进程基础知识</h3><blockquote>
<p><strong>进程是若干个活动的执行流以及各类相关资源的总称</strong>，这些资源包括内核结构、地址空间（内存），寄存器等<br>运行可执行文件后，它会被装载到内存中，接着 CPU 会执行程序中的每一条指令，那么这个<strong>运行中的程序，就被称为「进程」（Process）</strong></p>
<h4 id="3-1-1-进程的状态"><a href="#3-1-1-进程的状态" class="headerlink" title="3.1.1 进程的状态"></a>3.1.1 进程的状态</h4></blockquote>
</li>
<li>运行状态（<em>Running</em>）：该时刻进程占用 CPU；</li>
<li>就绪状态（<em>Ready</em>）：可运行，由于其他进程处于运行状态而暂时停止运行；</li>
<li>阻塞状态（<em>Blocked</em>）：该进程正在等待某一事件发生（如等待输入/输出操作的完成）而暂时停止运行，这时，即使给它CPU控制权，它也无法运行；</li>
<li>创建状态（<em>new</em>）：进程正在被创建时的状态；</li>
<li>结束状态（<em>Exit</em>）：进程正在从系统中消失时的状态；<h4 id="3-1-2-进程的控制结构"><a href="#3-1-2-进程的控制结构" class="headerlink" title="3.1.2 进程的控制结构"></a>3.1.2 进程的控制结构</h4></li>
<li>用<strong>进程控制块</strong>（<em>process control block，PCB</em>）数据结构来描述进程</li>
<li><em>PCB 是进程存在的唯一标识</em><ul>
<li><code>进程描述信息</code>：<ul>
<li>进程标识符：标识各个进程，每个进程都有一个并且唯一的标识符；</li>
<li>用户标识符：进程归属的用户，用户标识符主要为共享和保护服务；</li>
</ul>
</li>
<li><code>进程控制和管理信息</code>：<ul>
<li>进程当前状态，如 new、ready、running、waiting 或 blocked 等；</li>
<li>进程优先级：进程抢占 CPU 时的优先级；</li>
</ul>
</li>
<li><code>资源分配清单</code>：<ul>
<li>有关内存地址空间或虚拟地址空间的信息，所打开文件的列表和所使用的 I/O 设备信息。</li>
</ul>
</li>
<li><code>CPU 相关信息</code>：<ul>
<li>CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。<h4 id="3-1-3-进程的上下文切换"><a href="#3-1-3-进程的上下文切换" class="headerlink" title="3.1.3 进程的上下文切换"></a>3.1.3 进程的上下文切换</h4></li>
</ul>
</li>
</ul>
</li>
<li><strong>一个进程切换到另一个进程运行，称为进程的上下文切换</strong>。</li>
<li><em>CPU 上下文切换</em>：把保存前一个任务的 CPU 上下文（CPU 寄存器和程序计数器），加载新任务的上下文到这些寄存器和程序计数器，再跳转到程序计数器所指的新位置，运行新任务</li>
<li><em>进程的上下文切换</em> :不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源。</li>
</ul>
<h3 id="3-2-进程通信"><a href="#3-2-进程通信" class="headerlink" title="3.2 进程通信"></a>3.2 进程通信</h3><ul>
<li>每个进程的用户地址空间都是独立的，进程之间要通信必须通过内核。</li>
<li><em>管道</em>：对于匿名管道，它的通信范围是存在父子关系的进程，通过 fork 来复制父进程 fd 文件描述符，来达到通信的目的。</li>
<li><em>消息队列</em>：保存在内核中的消息链表</li>
<li><em>共享内存</em>：拿出一块虚拟地址空间来，映射到相同的物理内存中</li>
<li><em>信号量</em>：主要用于实现进程间的互斥与同步，而不是用于缓存进程间通信的数据</li>
<li><em>Socket</em>：跨网络与不同主机上的进程之间通信，针对 TCP、UDP、本机间的模型</li>
<li><em>死锁</em><ul>
<li>条件：互斥，占用和等待，不可抢占，循环等待</li>
<li>忽略；检测和恢复，预防，避免</li>
</ul>
</li>
</ul>
<h3 id="3-3-线程"><a href="#3-3-线程" class="headerlink" title="3.3 线程"></a>3.3 线程</h3><ul>
<li><em>线程是进程当中的一条执行流程。</em> 同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套<code>独立的寄存器和栈</code>，这样可以确保线程的控制流是相对独立的。</li>
<li><em>线程与进程的比较</em><ul>
<li>进程是<code>资源（包括内存、打开的文件等）分配</code>的单位，线程是<code>CPU 调度</code>的单位</li>
<li>进程拥有一个完整的<code>资源平台</code>，而线程只独享必不可少的资源，如<code>寄存器和栈</code></li>
<li>线程能减少并发执行的<code>时间和空间开销</code><ul>
<li>线程的创建时间比进程快，不涉及资源管理</li>
<li>线程的终止时间比进程快，释放的资源少</li>
<li>同一个进程内的线程切换比进程切换快，不需要切换页表</li>
<li>共享内存和文件资源，数据交互效率更高</li>
</ul>
</li>
</ul>
</li>
<li><em>线程的上下文切换</em>：两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的<code>私有数据</code>、寄存器等不共享的数据</li>
<li><em>线程的实现</em>：<ul>
<li><strong>用户线程（<em>User Thread</em>）</strong>：在用户空间实现的线程，不是由内核管理的线程，是由用户态的线程库来完成线程的管理；</li>
<li><strong>内核线程（<em>Kernel Thread</em>）</strong>：在内核中实现的线程，是由内核管理的线程；</li>
<li><strong>轻量级进程（<em>LightWeight Process</em>）</strong>：在内核中来支持用户线程；</li>
</ul>
</li>
<li><em>线程控制块TCB</em> ：线程状态信息（PC、栈指针、寄存器）</li>
<li><em>线程通信</em>：共享变量等，主要关注竞争共享资源的问题<h3 id="3-4-协程"><a href="#3-4-协程" class="headerlink" title="3.4 协程"></a>3.4 协程</h3></li>
<li>不是进程也不是线程，而是一个特殊的函数。协程是属于线程的。协程程序是在线程里面跑的，因此协程又称微线程和纤程等<ul>
<li>比线程更轻量级，协程完全由程序控制（也就是在用户态执行）</li>
<li>没有线程切换的开销</li>
<li>和多线程比，线程数量越多，协程的性能优势就越明显</li>
</ul>
</li>
</ul>
<h2 id="4-调度算法"><a href="#4-调度算法" class="headerlink" title="4 调度算法"></a>4 调度算法</h2><h3 id="4-1-进程调度算法"><a href="#4-1-进程调度算法" class="headerlink" title="4.1 进程调度算法"></a>4.1 进程调度算法</h3><ul>
<li><em>先来先服务调度算法</em>：每次从就绪队列选择最先进入队列的进程</li>
<li><em>最短作业优先调度算法</em>：优先选择运行时间最短的进程来运行</li>
<li><em>高响应比优先调度算法</em>：把「响应比优先级」最高的进程投入运行  服务时间+等待时间/服务时间</li>
<li><em>时间片轮转调度算法</em>：每个进程被分配一个时间段</li>
<li><em>最高优先级调度算法</em>：从就绪队列中选择最高优先级的进程进行运行</li>
<li><em>多级反馈队列调度算法</em>：设置多个优先级队列，优先级越高时间片越短，在当前队列没执行完就去下一级队尾<h3 id="4-2-内存页面置换算法"><a href="#4-2-内存页面置换算法" class="headerlink" title="4.2 内存页面置换算法"></a>4.2 内存页面置换算法</h3></li>
<li>当 CPU 访问的页面不在物理内存时，便会产生一个<code>缺页中断</code>，请求操作系统将所缺页调入到物理内存</li>
<li><em>最佳页面置换算法</em>：理想状态</li>
<li><em>先进先出置换算法</em>：置换掉在内存驻留时间很长的页面</li>
<li><em>时钟页面置换算法</em>：指到谁就替换</li>
<li><em>最不常用算法</em>：选择「访问次数」最少的那个页面，并将其淘汰<h3 id="4-3-磁盘调度算法"><a href="#4-3-磁盘调度算法" class="headerlink" title="4.3 磁盘调度算法"></a>4.3 磁盘调度算法</h3></li>
<li>_先来先服务算法</li>
<li>_最短寻道时间优先算法</li>
<li>_扫描算法</li>
<li>_循环扫描算法</li>
<li>_LOOK 与 C-LOOK 算法</li>
</ul>
<h2 id="5-网络系统"><a href="#5-网络系统" class="headerlink" title="5 网络系统"></a>5 网络系统</h2><h3 id="5-1-零拷贝"><a href="#5-1-零拷贝" class="headerlink" title="5.1 零拷贝"></a>5.1 零拷贝</h3><ul>
<li><strong>直接内存访问（<em>Direct Memory Access</em>）</strong> 技术</li>
<li>由 DMA 控制器负责进行 I/O 设备和内存的数据传输工作，CPU 不参与</li>
<li>过程：<ul>
<li>操作系统将 I/O 请求发送 DMA</li>
<li>DMA 将 I/O 请求发送给磁盘</li>
<li>磁盘把数据读取到缓冲区中，读满后，向 DMA 发起中断信号，告知缓冲区已满</li>
<li>DMA 收到磁盘的信号，将磁盘控制器缓冲区中的数据拷贝到内核缓冲区中</li>
<li>当 DMA 读取了足够多的数据，就会发送中断信号给 CPU</li>
<li>CPU 将数据从内核拷贝到用户空间，系统调用返回</li>
</ul>
</li>
<li>实现零拷贝？<ul>
<li>减少「上下文切换」和「数据拷贝」的次数</li>
<li>mmap + write：把内核缓冲区里的数据「<strong>映射</strong>」到用户空间</li>
<li>sendfile：替代前面的 <code>read()</code> 和 <code>write()</code> 这两个系统调用，这样就可以减少一次系统调用，也就减少了 2 次上下文切换的开销<h3 id="5-2-I-O-多路复用"><a href="#5-2-I-O-多路复用" class="headerlink" title="5.2 I/O 多路复用"></a>5.2 I/O 多路复用</h3></li>
</ul>
</li>
<li>多个请求复用了一个进程，这就是多路复用，<strong>程可以通过一个系统调用函数从内核中获取多个事件</strong><h4 id="5-2-1-Select"><a href="#5-2-1-Select" class="headerlink" title="5.2.1 Select"></a>5.2.1 Select</h4></li>
<li>将已连接的 Socket 都放到一个<strong>文件描述符集合</strong>，然后调用 select 函数<strong>拷贝</strong>到内核里，让内核来检查是否有网络事件产生，检查的方式很粗暴，就是通过<strong>遍历</strong>文件描述符集合的方式，当检查到有事件产生后，将此 Socket 标记为可读或可写， 接着再把整个文件描述符集合<strong>拷贝</strong>回用户态里，然后用户态还需要再通过<strong>遍历</strong>的方法找到可读或可写的 Socket，然后再对其处理。</li>
<li>需要进行 <strong>2 次「遍历」文件描述符集合</strong></li>
<li>使用固定长度的 BitsMap，表示文件描述符集合，最多监听 1024 个</li>
</ul>
<h4 id="5-2-2-poll"><a href="#5-2-2-poll" class="headerlink" title="5.2.2 poll"></a>5.2.2 poll</h4><ul>
<li>poll 用链表形式来组织存储所关注的文件描述符，突破了 select 的文件描述符个数限制</li>
<li>和 select 并没有太大的本质区别，都是线性结构，也都需要遍历</li>
</ul>
<h4 id="5-2-3-epoll"><a href="#5-2-3-epoll" class="headerlink" title="5.2.3 epoll"></a>5.2.3 epoll</h4><ul>
<li>epoll 在内核里使用<strong>红黑树来跟踪进程所有待检测的文件描述字</strong>，把需要监控的 socket 通过 <code>epoll_ctl()</code> 函数加入内核中的红黑树里</li>
<li>epoll 使用<code>事件驱动</code>的机制，内核里维护了一个<code>链表</code>来记录就绪事件，当某个 socket 有事件发生时，通过<code>回调函数</code>内核会将其加入到这个就绪事件列表中，当用户调用 <code>epoll_wait()</code> 函数时，只会返回有事件发生的文件描述符的个数，不需要像 select/poll 那样轮询扫描整个 socket 集合，大大提高了检测的效率。</li>
<li><em>事件触发模式</em><ul>
<li><strong>边缘触发</strong>：当被监控的 Socket 描述符上有可读事件发生时，<strong>服务器端只会从 epoll_wait 中苏醒一次</strong>，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；   <strong>一般和非阻塞 I/O 搭配使用</strong></li>
<li><strong>水平触发</strong>：当被监控的 Socket 上有可读事件发生时，<strong>服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束</strong>，目的是告诉我们有数据需要读取；</li>
</ul>
</li>
</ul>
<h3 id="5-3-高性能网络模式"><a href="#5-3-高性能网络模式" class="headerlink" title="5.3 高性能网络模式"></a>5.3 高性能网络模式</h3><p><strong>I/O 多路复用监听事件，收到事件后，根据事件类型分配（Dispatch）给某个进程 / 线程</strong></p>
<h4 id="5-3-1-Reactor-模式"><a href="#5-3-1-Reactor-模式" class="headerlink" title="5.3.1 Reactor 模式"></a>5.3.1 Reactor 模式</h4><ul>
<li><strong>Reactor（监听和分发事件）、Acceptor（获取连接）、Handler（处理业务）</strong></li>
<li>单 Reactor 单进程 / 线程，不用考虑进程间通信以及数据同步的问题，因此实现起来比较简单，这种方案的缺陷在于无法充分利用多核 CPU，而且处理业务逻辑的时间不能太长，否则会延迟响应，所以不适用于计算机密集型的场景，适用于业务处理快速的场景，比如 Redis（6.0之前 ） 采用的是单 Reactor 单进程的方案。</li>
<li>单 Reactor 多线程，通过多线程的方式解决了方案一的缺陷，但它离高并发还差一点距离，差在只有一个 Reactor 对象来承担所有事件的监听和响应，而且只在主线程中运行，在面对瞬间高并发的场景时，容易成为性能的瓶颈的地方。</li>
<li>Reactor 多进程 / 线程，通过多个 Reactor 来解决了方案二的缺陷，主 Reactor 只负责监听事件，响应事件的工作交给了从 Reactor<h4 id="5-3-2-Proactor-异步网络模式"><a href="#5-3-2-Proactor-异步网络模式" class="headerlink" title="5.3.2 Proactor 异步网络模式"></a>5.3.2 Proactor 异步网络模式</h4></li>
<li>阻塞 I/O：食堂等  ； 非阻塞 I/O： 过一段时间再去食堂； 异步 I/O： 阿姨送过来</li>
<li><strong>Proactor 是异步网络模式， 感知的是已完成的读写事件</strong>。<strong>「来了事件操作系统来处理，处理完再通知应用进程」</strong>。</li>
</ul>
<h2 id="6-Linux命令"><a href="#6-Linux命令" class="headerlink" title="6 Linux命令"></a>6 Linux命令</h2><h3 id="6-1-查看网络性能指标"><a href="#6-1-查看网络性能指标" class="headerlink" title="6.1 查看网络性能指标"></a>6.1 查看网络性能指标</h3><ul>
<li>网络的配置和状态   使用 <code>ifconfig</code> 或者 <code>ip</code> 命令来查看</li>
<li>socket 信息如何查看   使用 <code>netstat</code> 或者 <code>ss</code></li>
<li>网络吞吐率和 PPS 如何查看     使用 <code>sar</code> 命令</li>
<li>连通性和延时如何查看  ping</li>
</ul>

    
  </div>

  
  <!-- Post Copyright -->

<div class="post-copyright">
  <p class="copyright-item">
    <span>Author: </span>
    <a href="https://stardustorz.github.io">draco</a>
  </p>
  <p class="copyright-item">
    <span>Link: </span>
    <a href="https://stardustorz.github.io/2023/10/09/Basic/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">https://stardustorz.github.io/2023/10/09/Basic/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</a>
  </p>
  <p class="copyright-item">
    <span>License: </span>
    
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
  </p>
</div>

    

  

  
  <footer class="post-footer">
    
      
  <nav class="post-nav">  
      
      <a class="prev" href="/2023/10/09/Algorithm/%E8%B7%B3%E8%A1%A8/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text nav-default"></span>  
        <span class="prev-text nav-mobile">Prev</span>  
      </a>  
      
      
      <a class="next" href="/2023/10/09/Basic/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">  
        <span class="next-text nav-default"></span>  
        <span class="prev-text nav-mobile">Next</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  </footer>
  

</article>
        </div>
      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2019 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">draco</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
  







<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>



<script type="text/javascript" src="/lib/slideout/slideout.js"></script>



<script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>