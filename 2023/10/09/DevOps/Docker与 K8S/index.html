<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->


<!-- Website keywords -->




<!-- Website rss -->

<link rel="alternate" href="/atom.xml" title="Draco's Blog" type="application/atom+xml">


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://stardustorz.github.io/2023/10/09/DevOps/Docker与 K8S/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":false};
</script>
  
  <title> - Draco&#39;s Blog</title>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Draco&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        Home              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        Archives              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        Tags              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        Categories              </li>
    </a>
    
    <a href="/links/">
      <li class="mobile-menu-item">
        
        
        Links              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        About              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">Draco's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              Home  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              Archives  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              Tags  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              Categories  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/links/">  
              
              
              Links  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              About  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2023-10-09
      </span>
      
      
      
    </div>
  </header>

  
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Docker"><span class="toc-number">1.</span> <span class="toc-text">Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-docker%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E8%AE%B2%E4%B8%80%E4%B8%8B"><span class="toc-number">1.0.1.</span> <span class="toc-text">1 docker的工作原理是什么，讲一下</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-docker%E7%9A%84%E7%BB%84%E6%88%90%E5%8C%85%E5%90%AB%E5%93%AA%E5%87%A0%E5%A4%A7%E9%83%A8%E5%88%86"><span class="toc-number">1.0.2.</span> <span class="toc-text">2 docker的组成包含哪几大部分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-docker%E4%B8%8E%E4%BC%A0%E7%BB%9F%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.3.</span> <span class="toc-text">3 docker与传统虚拟机的区别什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-docker%E6%8A%80%E6%9C%AF%E7%9A%84%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.4.</span> <span class="toc-text">4 docker技术的三大核心概念是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-centos%E9%95%9C%E5%83%8F%E5%87%A0%E4%B8%AAG%EF%BC%8C%E4%BD%86%E6%98%AFdocker-centos%E9%95%9C%E5%83%8F%E6%89%8D%E5%87%A0%E7%99%BE%E5%85%86%EF%BC%8C%E8%BF%99%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.5.</span> <span class="toc-text">5 centos镜像几个G，但是docker centos镜像才几百兆，这是为什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E8%AE%B2%E4%B8%80%E4%B8%8B%E9%95%9C%E5%83%8F%E7%9A%84%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E9%95%9C%E5%83%8F%E7%9A%84%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84%EF%BC%9F"><span class="toc-number">1.0.6.</span> <span class="toc-text">6 讲一下镜像的分层结构以及为什么要使用镜像的分层结构？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E8%AE%B2%E4%B8%80%E4%B8%8B%E5%AE%B9%E5%99%A8%E7%9A%84copy-on-write%E7%89%B9%E6%80%A7%EF%BC%8C%E4%BF%AE%E6%94%B9%E5%AE%B9%E5%99%A8%E9%87%8C%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9%E4%BC%9A%E4%BF%AE%E6%94%B9%E9%95%9C%E5%83%8F%E5%90%97%EF%BC%9F"><span class="toc-number">1.0.7.</span> <span class="toc-text">7 讲一下容器的copy-on-write特性，修改容器里面的内容会修改镜像吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8BDockerfile%E7%9A%84%E6%95%B4%E4%B8%AA%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F%E8%BF%87%E7%A8%8B"><span class="toc-number">1.0.8.</span> <span class="toc-text">8 简单描述一下Dockerfile的整个构建镜像过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Dockerfile%E6%9E%84%E5%BB%BA%E9%95%9C%E5%83%8F%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8%EF%BC%8C%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5%EF%BC%9F"><span class="toc-number">1.0.9.</span> <span class="toc-text">9 Dockerfile构建镜像出现异常，如何排查？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Dockerfile%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.0.10.</span> <span class="toc-text">10 Dockerfile的基本指令有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E5%A6%82%E4%BD%95%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%93%AA%E4%B8%AA%E5%91%BD%E4%BB%A4"><span class="toc-number">1.0.11.</span> <span class="toc-text">11 如何进入容器？使用哪个命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BB%80%E4%B9%88%E6%98%AFk8s%EF%BC%9F%E8%AF%B4%E5%87%BA%E4%BD%A0%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.0.12.</span> <span class="toc-text">12 什么是k8s？说出你的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-k8s%E7%9A%84%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.13.</span> <span class="toc-text">13 k8s的组件有哪些，作用分别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-kube-api-server%E7%9A%84%E7%AB%AF%E5%8F%A3%E6%98%AF%E5%A4%9A%E5%B0%91%EF%BC%9F%E5%90%84%E4%B8%AApod%E6%98%AF%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AEkube-api-server%E7%9A%84%EF%BC%9F"><span class="toc-number">1.0.14.</span> <span class="toc-text">14 kube-api-server的端口是多少？各个pod是如何访问kube-api-server的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-k8s%E4%B8%AD%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.15.</span> <span class="toc-text">15 k8s中命名空间的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-k8s%E6%8F%90%E4%BE%9B%E4%BA%86%E5%A4%A7%E9%87%8F%E7%9A%84REST%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%85%B6%E4%B8%AD%E6%9C%89%E4%B8%80%E4%B8%AA%E6%98%AFKubernetes-Proxy-API%E6%8E%A5%E5%8F%A3%EF%BC%8C%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8B%E8%BF%99%E4%B8%AAProxy%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%B7%B2%E7%BB%8F%E6%80%8E%E4%B9%88%E4%BD%BF%E7%94%A8%E3%80%82"><span class="toc-number">1.0.16.</span> <span class="toc-text">16 k8s提供了大量的REST接口，其中有一个是Kubernetes Proxy API接口，简述一下这个Proxy接口的作用，已经怎么使用。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-pod%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.17.</span> <span class="toc-text">17 pod是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-pod%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.18.</span> <span class="toc-text">18 pod的原理是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-pod%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">1.0.19.</span> <span class="toc-text">19 pod有什么特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-pause%E5%AE%B9%E5%99%A8%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.20.</span> <span class="toc-text">20 pause容器作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-pod%E7%9A%84%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.0.21.</span> <span class="toc-text">21 pod的重启策略有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-pod%E7%9A%84%E9%95%9C%E5%83%8F%E6%8B%89%E5%8F%96%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">1.0.22.</span> <span class="toc-text">22 pod的镜像拉取策略有哪几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-pod%E7%9A%84%E5%AD%98%E6%B4%BB%E6%8E%A2%E9%92%88%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">1.0.23.</span> <span class="toc-text">23 pod的存活探针有哪几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E5%AD%98%E6%B4%BB%E6%8E%A2%E9%92%88%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E5%87%A0%E4%B8%AA%EF%BC%9F"><span class="toc-number">1.0.24.</span> <span class="toc-text">24 存活探针的属性参数有哪几个？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-pod%E7%9A%84%E5%B0%B1%E7%BB%AA%E6%8E%A2%E9%92%88%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">1.0.25.</span> <span class="toc-text">25 pod的就绪探针有哪几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E5%B0%B1%E7%BB%AA%E6%8E%A2%E9%92%88%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8F%82%E6%95%B0%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.0.26.</span> <span class="toc-text">26 就绪探针的属性参数有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E5%B0%B1%E7%BB%AA%E6%8E%A2%E9%92%88%E4%B8%8E%E5%AD%98%E6%B4%BB%E6%8E%A2%E9%92%88%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.27.</span> <span class="toc-text">27 就绪探针与存活探针区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E7%AE%80%E5%8D%95%E8%AE%B2%E4%B8%80%E4%B8%8B-pod%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.0.28.</span> <span class="toc-text">28 简单讲一下 pod创建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8Bpod%E7%9A%84%E7%BB%88%E6%AD%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">1.0.29.</span> <span class="toc-text">29 简单描述一下pod的终止过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-pod%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%EF%BC%9F"><span class="toc-number">1.0.30.</span> <span class="toc-text">30 pod的生命周期有哪几种？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-pod%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E5%99%A8%E6%98%AF%E5%B9%B2%E4%BB%80%E4%B9%88%E7%9A%84%EF%BC%9F"><span class="toc-number">1.0.31.</span> <span class="toc-text">31 pod的初始化容器是干什么的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-pod%E7%9A%84%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82%E3%80%81%E9%99%90%E5%88%B6%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89%EF%BC%9F"><span class="toc-number">1.0.32.</span> <span class="toc-text">32 pod的资源请求、限制如何定义？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E6%A0%87%E7%AD%BE%E5%8F%8A%E6%A0%87%E7%AD%BE%E9%80%89%E6%8B%A9%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%9F"><span class="toc-number">1.0.33.</span> <span class="toc-text">33 标签及标签选择器是什么，如何使用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-service%E6%98%AF%E5%A6%82%E4%BD%95%E4%B8%8Epod%E5%85%B3%E8%81%94%E7%9A%84%EF%BC%9F"><span class="toc-number">1.0.34.</span> <span class="toc-text">34 service是如何与pod关联的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-service%E7%9A%84%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%A0%BC%E5%BC%8F%E3%80%81pod%E7%9A%84%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.0.35.</span> <span class="toc-text">35 service的域名解析格式、pod的域名解析格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8pod%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0service%E7%9A%84%EF%BC%8C%E6%88%96%E8%80%85%E8%AF%B4%EF%BC%8Cpod%E9%87%8C%E9%9D%A2%E7%9A%84%E5%AE%B9%E5%99%A8%E7%94%A8%E4%BA%8E%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%9E%E6%8E%A5service%E7%9A%84%EF%BC%9F"><span class="toc-number">1.0.36.</span> <span class="toc-text">36 一个应用pod是如何发现service的，或者说，pod里面的容器用于是如何连接service的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAservice%E4%BB%A3%E7%90%86%E5%A4%96%E9%83%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%8C%E6%88%96%E8%80%85%E6%8D%A2%E5%8F%A5%E8%AF%9D%E6%9D%A5%E8%AF%B4%EF%BC%8C%E5%9C%A8k8s%E9%9B%86%E7%BE%A4%E5%86%85%E7%9A%84%E5%BA%94%E7%94%A8%E5%A6%82%E4%BD%95%E8%AE%BF%E9%97%AE%E5%A4%96%E9%83%A8%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%A6%82%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%EF%BC%8C%E7%BC%93%E5%AD%98%E6%9C%8D%E5%8A%A1%E7%AD%89"><span class="toc-number">1.0.37.</span> <span class="toc-text">37 如何创建一个service代理外部的服务，或者换句话来说，在k8s集群内的应用如何访问外部的服务，如数据库服务，缓存服务等?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-service%E3%80%81endpoint%E3%80%81kube-proxys%E4%B8%89%E7%A7%8D%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.38.</span> <span class="toc-text">38 service、endpoint、kube-proxys三种的关系是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-deployment%E6%80%8E%E4%B9%88%E6%89%A9%E5%AE%B9%E6%88%96%E7%BC%A9%E5%AE%B9%EF%BC%9F"><span class="toc-number">1.0.39.</span> <span class="toc-text">39 deployment怎么扩容或缩容？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-deployment%E7%9A%84%E6%9B%B4%E6%96%B0%E5%8D%87%E7%BA%A7%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.0.40.</span> <span class="toc-text">40 deployment的更新升级策略有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41-deployment%E7%9A%84%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E6%9C%89%E4%B8%A4%E4%B8%AA%E7%89%B9%E5%88%AB%E4%B8%BB%E8%A6%81%E7%9A%84%E5%8F%82%E6%95%B0%EF%BC%8C%E8%A7%A3%E9%87%8A%E4%B8%80%E4%B8%8B%E5%AE%83%E4%BB%AC%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-number">1.0.41.</span> <span class="toc-text">41 deployment的滚动更新策略有两个特别主要的参数，解释一下它们是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-deployment%E6%9B%B4%E6%96%B0%E7%9A%84%E5%91%BD%E4%BB%A4%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.0.42.</span> <span class="toc-text">42 deployment更新的命令有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E7%AE%80%E8%BF%B0%E4%B8%80%E4%B8%8Bdeployment%E7%9A%84%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">1.0.43.</span> <span class="toc-text">43 简述一下deployment的更新过程?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-deployment%E7%9A%84%E5%9B%9E%E6%BB%9A%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E5%91%BD%E4%BB%A4"><span class="toc-number">1.0.44.</span> <span class="toc-text">44 deployment的回滚使用什么命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%E8%AE%B2%E4%B8%80%E4%B8%8B%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%8D%B7%EF%BC%8C%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.0.45.</span> <span class="toc-text">45 讲一下都有哪些存储卷，作用分别是什么?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-pv%E7%9A%84%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D"><span class="toc-number">1.0.46.</span> <span class="toc-text">46 pv的回收策略有哪几种</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-%E5%9C%A8pv%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%EF%BC%8C%E4%B8%80%E8%88%AC%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">1.0.47.</span> <span class="toc-text">47 在pv的生命周期中，一般有几种状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-%E5%AD%98%E5%82%A8%E7%B1%BB%E7%9A%84%E8%B5%84%E6%BA%90%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5"><span class="toc-number">1.0.48.</span> <span class="toc-text">48 存储类的资源回收策略:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-pv%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%E6%80%8E%E4%B9%88%E6%89%A9%E5%AE%B9"><span class="toc-number">1.0.49.</span> <span class="toc-text">49 pv存储空间不足怎么扩容?</span></a></li></ol></li></ol></li></ol>
    </div>
  </div>
  

  <div class="post-content">
    
    <h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>基础<br>●Docker主要用于开发和运维的协作，可将整个项目的环境，依赖全部打包成镜像<br>●在集群中，使用一个镜像就可以很方便的进行部署<br>●Docker和虚拟机类似，但不需要去模拟硬件，启动会更快<br>○可以理解为一个浓缩版的Linux系统<br>○摒弃了Linux中不需要的很多东西<br>●概念<br>○镜像：镜像就相当于 Java类<br>○容器：容器就相当于Java对象，是一个个小型独立的Linux环境<br>○仓库：仓库是集中存放镜像的地方<br>●镜像可以生成容器实例，同一个镜像可以生成多个同时运行的容器<br>●容器可以启动，关闭，重启等等操作，就相当于一个虚拟机<br>●文档：<a target="_blank" rel="noopener" href="https://yeasy.gitbook.io/docker_practice/">文档-Gitbook</a>  </p>
<p>操作  </p>
<p>安装<br>●Docker有企业版和社区版，使用社区版(DockerCE)即可<br>●具体方法看开头Gitbook文档  </p>
<p>镜像加速<br>●阿里云推出的的Docker Hub镜像站，方便国内用户加速下载<br>●地址：<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">https://cr.console.aliyun.com/</a><br>●获取镜像加速器地址(唯一的)<br>●配置方法在上面的地址<br>○配置文件没有的话就自己创建  </p>
<p>运行hello-world<br>●与编程语言的学习一样，都会有helloworld<br>●使用以下命令运行，如果没有就会去镜像仓库去拉取最新版到本地<br>○docker run hello-world  </p>
<p>底层原理<br>●Docker是一个Client-Server结构的系统<br>○Docker守护进程运行在主机上<br>○通过Socket连接从客户端访问<br>○守护进程从客户端接受命令并管理运行在主机上的容器<br>●Docker比虚拟机更快的原因是它有更少的抽象层，不需要去模拟硬件虚拟化。<br>●Docker直接使用宿主机的引擎和内核，多个容器也是，而虚拟机需要去重新加载多个内核<br>●</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2145785/1672129612884-e7ec2dc4-181f-408d-8970-89f1d839da94.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_36%2Ctext_QW9tc2ly%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp" alt="image.png"></p>
<p>常用命令  </p>
<p>帮助命令<br>●docker version—版本信息<br>●docker info —全面的信息描述<br>●docker —help —帮助命令  </p>
<p>镜像命令<br>●docker images —-列出本地的镜像<br>○列出本地所有镜像 - docker images -a<br>■所有镜像(含中间镜像层)<br>○列出本地镜像的ID —docker images -qa<br>○镜像详细信息— docker images —digests<br>●docker search [option] 镜像名 —hub上搜索镜像<br>○罗列出点赞数为30以上的镜像—docker search -s 30 tomcat<br>●docker pull 镜像名[:tag]—丛hub拉取镜像到本地<br>○不写tag就是最新版<br>○arm架构的机器就需要加特定标签  </p>
<ul>
<li>docker rmi 镜像名[:tag]  <ul>
<li>删除单个—-docker rmi -f 镜像<br>○ 删除多个—-docker rmi -f 镜像1 镜像2<br>○ 删除全部—-docker rmi -f$(docker images -qa )<br>●docker system df<br>○查看镜像文件等占用的空间  </li>
</ul>
</li>
</ul>
<p>容器命令<br>●启动<br>○docker run -it 镜像ID<br>○docker run -it —name=”别名” 镜像ID<br>○ -it 代表启动交互式<br>○-d代表守护式交互，不会进入容器内去操作，会在后台挂着<br>○docker run -it ubuntu /bin/bash<br>●列出正在运行的全部容器<br>○docker ps<br>○正在运行/历史运行过的 docker ps -a<br>○上5次运行过的容器 docker ps -n 5<br>○列出刚刚运行过的容器 docker ps -l<br>○列出刚刚运行过的容器ID： docker ps -ql<br>●退出容器<br>○ctrl+p+q 容器不停止退出<br>○exit命令 容器停止并退出<br>●启动容器<br>○docker start 容器ID —用ps命令获取ID<br>●重启容器<br>○docker restart 容器ID<br>●停止容器<br>○docker stop 容器ID —温柔停止<br>○docker kill 容器ID —粗暴停止<br>●删除已停止的容器<br>○docker rm 容器ID<br>●查看容器内部细节<br>○docker inspect 容器ID<br>●进入正在运行的容器<br>○docker attach 容器ID<br>○docker exec 容器ID<br>■会有新的进程、用的多<br>■退出不会导致容器的停止<br>●拷贝docker内的文件到宿主机<br>○docker cp 容器ID:容器内路径以及文件名 宿主机路径<br>●导出所有<br>○docker export 容器ID&gt;xxx.tar<br>○cat xxx.tar|docker import - xxx:3.7将打的包换成镜像<br>●查看容器日志<br>○docker logs 容器ID  </p>
<p>镜像发布  </p>
<p>镜像原理<br>●Docker的镜像是一个分层的结构<br>●从底层一层层的向上，像一个画卷<br>●Docker使用的UnionFS 联合文件系统<br>●比如我拉一个Tomcat镜像，里面就有Linux内核，JDK运行环境，Tomcat等等<br>○我就可以使用Linux内核和JDK制作一个镜像<br>○然后使用这个基础镜像+不同版本的Tomcat进行操作  </p>
<p>创建<br>●Docker拉取的是精简的镜像，没有用的东西都会丢掉，比如vim<br>●制作一个带有vim的centos镜像<br>○运行一个centos容器，使用yum安装vim<br>○使用下述命令进行创建<br>○docker commit -m=”add vim” -a=”aomsir” 容器ID 新镜像名字  </p>
<p>发布  </p>
<p>阿里云<br>●这里使用的Hub是使用的阿里云的Hub<br>○<a target="_blank" rel="noopener" href="https://cr.console.aliyun.com/cn-hangzhou/instances">阿里云容器镜像服务</a><br>●docker tag 8ecc2667bae7 registry.cn-hangzhou.aliyuncs.com/aomsir/ubuntu_vim:1.0-镜像ID<br>●docker push registry.cn-hangzhou.aliyuncs.com/aomsir/ubuntu_vim:1.0 - 推送<br>●docker pull registry.cn-hangzhou.aliyuncs.com/aomsir/ubuntu_vim:1.0  </p>
<p>本地私有库<br>●拉取库：docker pull registry<br>●运行：docker run -d -p 5000:5000 -v /aomsir/myregistry/:/tmp/registry —privileged=true registry<br>●打包镜像：docker tag redis:latest 192.168.1.113:5000/redis:latest<br>●修改权限-vim /etc/docker/daemon.json，将其支持http<br>●push推送到私有库：docker push 192.168.1.113:5000/redis:1.0<br>●查看库中的镜像：curl -XGET <a target="_blank" rel="noopener" href="http://192.168.1.113:5000/v2/_catalog">http://192.168.1.113:5000/v2/_catalog</a>  </p>
<p>容器数据卷<br>●容器数据卷的作用是用于将容器内的数据进行映射，进行持久化到本地主机目录<br>●命令docker run -it —privileged=true -v /宿主机绝对路径:/容器内目录 镜像名<br>○-v 代表 volumes<br>●宿主机目录和容器目录会双向同步<br>●容器可实现可读可写，可写等操作，一般都是可读可写<br>●卷的继承和共享<br>○容器1完成和宿主机的映射<br>○容器2继承容器1的卷规则<br>●应用场景<br>○MySQL容器重启以后数据都丢失，有了容器卷就不会<br>○当我新运行一个容器，就可以使用原来的数据直接跑  </p>
<p>常用应用<br>●拉取镜像的时候一定要去Docker Hub看看有没对应自己芯片架构的镜像<br>●启动服务的时候去看一下宿主机有没有安装对应的服务<br>●对应服务在宿主机有安装的话就给Docke的r容器换个端口  </p>
<p>Tomcat<br>●最新版Tomcat安装启动后没有首页<br>○进tomcat将webapps删除<br>○将webapps.dist改名为webapps<br>●docker run -d -p 8080:8080 -name tomcat1 /bin/bash  </p>
<p>MySQL<br>●使用oracle是因为有arm架构<br>●操作<br>○创建容器<br>○/root/aomsir/mysql/conf目录下新建my.cnf文件<br>○添加下面的内容,因为容器里的mysql没有utf8编码<br>●数据备份<br>○可以使用容器卷直接转移<br>○也可以使用dump命令将SQL文件导出  </p>
<p>Redis<br>●要去官网下载对应版本的Redis配置文件<br>●创建容器<br>○将redis.conf文件放一个在宿主机的数据卷目录  </p>
<p>Nginx<br>●如下  </p>
<p>Docker网络<br>●Docker网络可以 和 主机和虚拟机的网络相结合理解<br>●可用于容器间的通信<br>○用于编排，比如a容器的接口服务，访问b容器的redis<br>●</p>
<p>简介</p>
<p>网络模式</p>
<p>为每个容器分配,设置IP等,并将容器连接到一个DOCKERO</p>
<p>BRIDGE</p>
<p>虚拟网桥,默认为该模式</p>
<p>容器将不会虚拟出自己的网卡,配置自己的IP等,而是使用</p>
<p>HOST</p>
<p>宿主机的IP和端口</p>
<p>容器有独立的NETWORK NAMESPACE,但:</p>
<p>.但并没有对其进行任</p>
<p>NONE</p>
<p>何网络设置,如分配VETHPAIR和网桥连接,IP等</p>
<p>新创建的容器不会创建自己的网桥和配置自己的IP,而是和</p>
<p>CONTAINER</p>
<p>一个指定的容器共享IP和端口范围</p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/2145785/1672131504934-9089d9fe-9263-44b6-a069-e6278cdfe2dd.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_34%2Ctext_QW9tc2ly%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp%2Fresize%2Cw_1198%2Climit_0" alt="image.png"></p>
<p>基础<br>●Docker启动以后在宿主机上会有一个docker0的虚拟网桥<br>●docker会有3大网络模式  </p>
<p>网络模式<br>●bridge<br>○Docker服务启动以后，会在宿主机上创建一块虚拟网卡，名为docker0(桥接模式)<br>■创建容器不指定网卡就默认使用docker0这块虚拟网卡<br>■启动一个默认服务时，容器内会生成一个eth0接口，docker0网卡会虚拟出一个vethxxx接口进行连接<br>○</p>
<p>DOCKER CONTAINER</p>
<p>DOCKER CONTAINER</p>
<p>DOCKER CONTAINER</p>
<p>ETHO</p>
<p>ETHO</p>
<p>ETHO</p>
<p>VETH1</p>
<p>VETH3</p>
<p>VETH2</p>
<p>DOCKERO</p>
<p>ETHO(ENS33)</p>
<p><img src="https://cdn.nlark.com/yuque/0/2023/png/2145785/1677821386653-4fe071e0-655d-4265-816e-354aba01a4a4.png?x-oss-process=image%2Fwatermark%2Ctype_d3F5LW1pY3JvaGVp%2Csize_62%2Ctext_QW9tc2ly%2Ccolor_FFFFFF%2Cshadow_50%2Ct_80%2Cg_se%2Cx_10%2Cy_10%2Fformat%2Cwebp" alt="image.png"></p>
<p>●host<br>○这个是主机模式，共用宿主机的IP和端口，不需要端口映射<br>○假如说宿主机啥服务都没有，使用host服务开一个tomcat，直接用宿主机ip➕端口即可访问<br>○不推荐这么使用<br>●none<br>○就是没有网络设置，不推荐这么使用<br>●container<br>○容器模式，a容器去公用b容器的网络设置  </p>
<p>自定义网桥<br>●docker0网卡很方便，但也有很多的弊端<br>○使用其的每个容器的IP都是动态的，每次重启都会变化<br>○容器间的通信只可以通过IP，而不可以通过hostname<br>○容器多了会降低网络传递的效率<br>●因为有弊端，所以可以自定义网桥<br>●自定义网桥操作<br>○docker nerwork create -d bridge(默认有的,可不写) 网络名称 - 创建网络<br>○自定义网段<br>■docker network create —subnet=172.18.0.0/18 my_net<br>■创建容器的时候指定容器的IP —net my_net —ip 172.18.0.2 \<br>○docker nwtwork ls - 查看现有网络<br>○docker network inspect 网络名称 - 查看某个网络的详细信息<br>○docker network rm 网络名称 - 删除某个网络<br>○使用自定义网络<br>■docker run -d —network 网络名称 - 创建容器的时候指定<br>■docker network connect 网络名称 容器名称 - 已创建的容器加入指定网络<br>●将容器加入到新建网桥中(未创建/创建容器)<br>○把启动容器的命令重新跑一遍，把network加上<br>●注意：任何模式都不可跨桥通信  </p>
<p>Dockerfile  </p>
<p>理论学习<br>●重点中的重点，学好以后可以把所有的项目使用Dockerfile进行构建<br>●Dockerfile可以认为是Docker镜像的描述文件，是由一系列命令和参数构成的脚本。主要作用是用来构建Docker镜像的构建文件<br>●官方的一个个镜像无法满足我们实际的业务需求<br>●作用：可以通过Dockerfile构建自己的镜像文件<br>●步骤<br>○<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">官方文档</a><br>○编写dockerfile文件，如下demo<br>■注意每一行是一条完整指令<br>■第一行必须是FROM命令<br>■RUN命令后面写法很多，参照官网<br>■ADD命令与COPY命令用法一致<br>■COPY只能复制，ADD后面还可以写url，会自动去这个url下载<br>■ENTRYPOINT&amp;CMD<br>●都是用于指定容器启动时默认的执行命令(思考为啥run redis，Redis就会启动)<br>●使用语法一致，CMD如果有多条，只有最后一个有效<br>●CMD命令可以使用JSON数组的格式<br>●两者区别在于运行容器时覆盖操作 - [参考redis容器的创建]<br>○docker run 镜像:版本号 覆盖的命令 ls /<br>○docker run —entrypoint=”要覆盖的指令” 镜像:版本号 传递的参数<br>●通常EHTRYPOINT与CMD搭配进行使用<br>○使用 docker build -t xx:1.0 .(指定的dockerfile所在的位置)进行构建<br>■.代表当前目录，保证Dockerfile文件所在目录下没有无关文件，因为会一起打进去<br>○注意<br>■RUN命令是构建镜像的时候使用的，CMD是启动容器时默认执行的  </p>
<p>实战操作<br>●发布一个SpringBoot项目<br>●操作<br>○打jar包，同目录下写Dockerfile文件<br>○然后进行构建启动[需要的中间件等提前准备好]  </p>
<p>Docker-Compose  </p>
<p>理论学习<br>●现有Docker在进行项目部署的时候还是有很多的问题<br>●完成一个项目肯定会用到N个容器去进行业务的开发，用到后就一定会产生一些依赖(比如容器的启动时间)<br>●新需求：把服务器A的容器迁移至服务器B，很麻烦。因为部署的时候没有站在项目的角度<br>●容器的编排就显得至关重要，所以就需要使用Docker-Compose<br>●DockerCompose是Docker官方的项目<br>○Compose负责实现对Docker实现快速编排的工具<br>○一个项目一个compose文件 - docker-compose.yml<br>○project与service<br>●Compose<br>○只有Linux上面安装Docker后没有默认安装DockerCompose的<br>○Linux平台将docker-compose文件下载放到/usr/local/bin下面，赋予权限即可  </p>
<p>操作<br>●步骤<br>○编写docker-compose.yml配置文件<br>○在配置文件所在目录下执行 docker-compose up -d<br>○使用depends_on解决容器的编排<br>●注意<br>○docker-compose up用一次就会对配置有所缓存，可以使用对应的down进行操作<br>○docker-compose的命令有很多的操作，比如只启动一个服务，停一个服务等等<br>■用到的时候去看文档  </p>
<p>YAML</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>27</p>
<p>28</p>
<p>29</p>
<p>30</p>
<p>31</p>
<p>32</p>
<p>version: ‘3.8’ # docker-compose的版本号,要看具体的docker引擎</p>
<p>services:</p>
<p>tomcat:</p>
<p>image: tomcat:8.0 # 代表使用的是什么镜像</p>
<p>ports: # 代表容器与宿主机之间的映射</p>
<ul>
<li>‘8080:8080’</li>
</ul>
<p>redis:</p>
<p>image: redis:6.5.0</p>
<p>container_name: redis # 给容器起别名,推荐使用默认的</p>
<p>ports:</p>
<ul>
<li>‘6379:6379’</li>
</ul>
<p>networks:</p>
<ul>
<li>ems</li>
</ul>
<p>volumes:</p>
<ul>
<li>/root/redis/data/:/data</li>
</ul>
<p>command: redis-server</p>
<p>mysql:</p>
<p>image: mysql:8.0</p>
<p>ports:</p>
<ul>
<li>‘3306:3306’</li>
</ul>
<p>environment: # 代表给当前容器启动制定环境</p>
<ul>
<li>‘MYSQL_ROOT_PASSWORD=root’</li>
</ul>
<p>volumes:</p>
<ul>
<li>/root/mysqldata1:/var/lib/mysql</li>
</ul>
<p>depends_on:</p>
<p>tomcat # 依赖于tomcat,需要让其先启动</p>
<p>networks:</p>
<p>ems:</p>
<p>实战操作<br>●Docker-Compose基于Dockerfile去构建镜像<br>●需要使用Compose就去看人家使用镜像是怎么操作的<br>●操作<br>○使用build命令  </p>
<p>YAML</p>
<p>1</p>
<p>2</p>
<p>3</p>
<p>4</p>
<p>5</p>
<p>6</p>
<p>7</p>
<p>8</p>
<p>9</p>
<p>10</p>
<p>11</p>
<p>12</p>
<p>13</p>
<p>14</p>
<p>15</p>
<p>16</p>
<p>17</p>
<p>18</p>
<p>19</p>
<p>20</p>
<p>21</p>
<p>22</p>
<p>23</p>
<p>24</p>
<p>25</p>
<p>26</p>
<p>version: ‘3.8’</p>
<p>services:</p>
<p>tomcat:</p>
<p>image: tomcat:8.0</p>
<p>ports:</p>
<ul>
<li>‘8080:8080’</li>
</ul>
<p>networks:</p>
<ul>
<li>dangdang</li>
</ul>
<p>apps:</p>
<p>build:</p>
<p>context: ./ # dockerfile的上下文目录</p>
<p>dockerfile: Dockerfile # 文件名</p>
<p>ports:</p>
<ul>
<li>‘80:7891’</li>
</ul>
<p>command: [“test.jar”]</p>
<p>env_file:</p>
<p>./.env # 将环境文件写到.env中</p>
<p>networks:</p>
<ul>
<li>dangdang</li>
</ul>
<p>restart: always</p>
<p>networks:</p>
<p>dangdang: # 声明网桥</p>
<p>经验之谈<br>●DockerDesktop<br>○macOS上的Docker Desktop很重，占用大打开慢，可以考虑使用OrbStack进行替代<br>○注意：Docker Desktop和Orbstack同时安装的情况下，会有两套Docker Engine、Server、CLI等。容器是隔离的，注意切换上下文<br>○docker context use orbstack/docker context use desktop-linux<br>●避免镜像推不上DockerHub ，使用docker login</p>
<h3 id="1-docker的工作原理是什么，讲一下"><a href="#1-docker的工作原理是什么，讲一下" class="headerlink" title="1 docker的工作原理是什么，讲一下"></a>1 docker的工作原理是什么，讲一下</h3><p>docker是一个Client-Server结构的系统，docker<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">守护进程</a>运行在宿主机上，守护进程从<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%AE%A2%E6%88%B7%E7%AB%AF&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">客户端</a>接受命令并管理运行在主机上的容器，容器是一个运行时环境，这就是我们说的集装箱。</p>
<h3 id="2-docker的组成包含哪几大部分"><a href="#2-docker的组成包含哪几大部分" class="headerlink" title="2 docker的组成包含哪几大部分"></a>2 docker的组成包含哪几大部分</h3><p>一个完整的docker有以下几个部分组成： 1、docker client，客户端，为用户提供一系列可执行命令，用户用这些命令实现跟 docker daemon 交互；</p>
<p>2、docker daemon，守护进程，一般在宿主主机后台运行，等待接收来自客户端的请求消息；</p>
<p>3、docker image，镜像，镜像run之后就生成为docker容器；</p>
<p>4、docker container，容器，一个系统级别的服务，拥有自己的ip和系统目录结构；运行容器前需要本地存在对应的镜像，如果本地不存在该镜像则就去镜像仓库下载。</p>
<p>docker 使用客户端-服务器 (C/S) 架构模式，使用远程api来管理和创建docker容器。docker 容器通过 docker 镜像来创建。容器与镜像的关系类似于面向对象编程中的对象与类。</p>
<h3 id="3-docker与传统虚拟机的区别什么？"><a href="#3-docker与传统虚拟机的区别什么？" class="headerlink" title="3 docker与传统虚拟机的区别什么？"></a>3 docker与传统<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">虚拟机</a>的区别什么？</h3><p>1、传统虚拟机是需要安装整个<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">操作系统</a>的，然后再在上面安装业务应用，启动应用，通常需要几分钟去启动应用，而docker是直接使用镜像来运行业务容器的，其容器启动属于秒级别；</p>
<p>2、Docker需要的资源更少，Docker在操作系统级别进行虚拟化，Docker容器和内核交互，几乎没有性能损耗，而虚拟机运行着整个操作系统，占用物理机的资源就比较多;</p>
<p>3、Docker更轻量，Docker的架构可以共用一个内核与共享应用程序库，所占内存极小;同样的硬件环境，Docker运行的镜像数远多于虚拟机数量，对系统的利用率非常高;</p>
<p>4、与虚拟机相比，Docker隔离性更弱，Docker属于进程之间的隔离，虚拟机可实现系统级别隔离;</p>
<p>5、Docker的安全性也更弱，Docker的租户root和宿主机root相同，一旦容器内的用户从普通用户权限提升为<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=root%E6%9D%83%E9%99%90&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">root权限</a>，它就直接具备了宿主机的root权限，进而可进行无限制的操作。虚拟机租户root权限和宿主机的root虚拟机权限是分离的，并且虚拟机利用如Intel的VT-d和VT-x的ring-1硬件隔离技术，这种技术可以防止虚拟机突破和彼此交互，而容器至今还没有任何形式的硬件隔离;</p>
<p>6、Docker的集中化管理工具还不算成熟，各种<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">虚拟化技术</a>都有成熟的管理工具，比如：VMware vCenter提供完备的虚拟机管理能力;</p>
<p>7、Docker对业务的高可用支持是通过快速重新部署实现的，虚拟化具备负载均衡，高可用、容错、迁移和数据保护等经过生产实践检验的成熟保障机制，Vmware可承诺虚拟机99.999%高可用，保证业务连续性;</p>
<p>8、虚拟化创建是分钟级别的，Docker容器创建是秒级别的，Docker的快速迭代性，决定了无论是开发、测试、部署都可以节省大量时间;</p>
<p>9、虚拟机可以通过镜像实现环境交付的一致性，但镜像分发无法体系化，Docker在Dockerfile中记录了容器构建过程，可在集群中实现快速分发和快速部署。</p>
<h3 id="4-docker技术的三大核心概念是什么？"><a href="#4-docker技术的三大核心概念是什么？" class="headerlink" title="4 docker技术的三大核心概念是什么？"></a>4 docker技术的三大核心概念是什么？</h3><p>镜像：镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。</p>
<p>容器：容器是基于镜像创建的，是镜像运行起来之后的一个实例，容器才是真正运行业务程序的地方。如果把镜像比作程序里面的类，那么容器就是对象。</p>
<p>镜像仓库：存放镜像的地方，研发工程师打包好镜像之后需要把镜像上传到镜像仓库中去，然后就可以运行有仓库权限的人拉取镜像来运行容器了。</p>
<h3 id="5-centos镜像几个G，但是docker-centos镜像才几百兆，这是为什么？"><a href="#5-centos镜像几个G，但是docker-centos镜像才几百兆，这是为什么？" class="headerlink" title="5 centos镜像几个G，但是docker centos镜像才几百兆，这是为什么？"></a>5 centos镜像几个G，但是docker centos镜像才几百兆，这是为什么？</h3><p>一个完整的Linux操作系统包含Linux内核和rootfs根文件系统，即我们熟悉的<code>/dev</code>、<code>/proc/</code>、<code>/bin</code>等目录。我们平时看到的CentOS除了rootfs，还会选装很多软件，服务，图形桌面等，所以CentOS镜像有好几个G也不足为奇。</p>
<p>而对于容器镜像而言，所有容器都是共享宿主机的Linux 内核的，而对于docker镜像而言，docker镜像只需要提供一个很小的rootfs即可，只需要包含最基本的命令，工具，程序库即可，所有docker镜像才会这么小。</p>
<h3 id="6-讲一下镜像的分层结构以及为什么要使用镜像的分层结构？"><a href="#6-讲一下镜像的分层结构以及为什么要使用镜像的分层结构？" class="headerlink" title="6 讲一下镜像的分层结构以及为什么要使用镜像的分层结构？"></a>6 讲一下镜像的分层结构以及为什么要使用镜像的分层结构？</h3><p>一个新的镜像其实是从 base 镜像一层一层叠加生成的。每安装一个软件，dockerfile中使用<code>RUN</code>指令，就会在现有镜像的基础上增加一层，这样一层一层的叠加最后构成整个镜像。所以我们<code>docker pull</code>拉取一个镜像的时候会看到docker是一层层拉去的。</p>
<p>分层机构最大的一个好处就是 ： 共享资源。比如：有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p>
<h3 id="7-讲一下容器的copy-on-write特性，修改容器里面的内容会修改镜像吗？"><a href="#7-讲一下容器的copy-on-write特性，修改容器里面的内容会修改镜像吗？" class="headerlink" title="7 讲一下容器的copy-on-write特性，修改容器里面的内容会修改镜像吗？"></a>7 讲一下容器的copy-on-write特性，修改容器里面的内容会修改镜像吗？</h3><p>我们知道，镜像是分层的，镜像的每一层都可以被共享，同时，镜像是只读的。当一个容器启动时，一个新的可写层被加载到镜像的顶部，这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p>
<p>所有对容器的改动 - 无论添加、删除、还是修改文件，都只会发生在容器层中，因为只有容器层是可写的，容器层下面的所有镜像层都是只读的。镜像层数量可能会很多，所有镜像层会联合在一起组成一个统一的文件系统。如果不同层中有一个相同路径的文件，比如<code>/a</code>，上层的 <code>/a</code> 会覆盖下层的<code>/a</code>，也就是说用户只能访问到上层中的文件 <code>/a</code>。在容器层中，用户看到的是一个叠加之后的文件系统。</p>
<p>添加文件时：在容器中创建文件时，新文件被添加到容器层中。</p>
<p>读取文件：在容器中读取某个文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后打开并读入内存。</p>
<p>修改文件：在容器中修改已存在的文件时，Docker 会从上往下依次在各镜像层中查找此文件。一旦找到，立即将其复制到容器层，然后修改之。</p>
<p>删除文件：在容器中删除文件时，Docker 也是从上往下依次在镜像层中查找此文件。找到后，会在容器层中记录下此删除操作。</p>
<p>只有当需要修改时才复制一份数据，这种特性被称作 Copy-on-Write。可见，容器层保存的是镜像变化的部分，不会对镜像本身进行任何修改。</p>
<h3 id="8-简单描述一下Dockerfile的整个构建镜像过程"><a href="#8-简单描述一下Dockerfile的整个构建镜像过程" class="headerlink" title="8 简单描述一下Dockerfile的整个构建镜像过程"></a>8 简单描述一下Dockerfile的整个构建镜像过程</h3><p>1、首先，创建一个目录用于存放应用程序以及构建过程中使用到的各个文件等；</p>
<p>2、然后，在这个目录下创建一个Dockerfile文件，一般建议Dockerfile的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%96%87%E4%BB%B6%E5%90%8D&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">文件名</a>就是Dockerfile；</p>
<p>3、编写Dockerfile文件，编写指令，如，使用<code>FORM指</code>令指定基础镜像，<code>COPY</code>指令复制文件，<code>RUN</code>指令指定要运行的命令，<code>ENV</code>设置环境变量，<code>EXPOSE</code>指定容器要暴露的端口，<code>WORKDIR</code>设置当前工作目录，<code>CMD</code>容器启动时运行命令，等等指令构建镜像；</p>
<p>4、Dockerfile编写完成就可以构建镜像了，使用<code>docker build -t 镜像名:tag .</code>命令来构建镜像，最后一个点是表示当前目录，docker会默认寻找当前目录下的Dockerfile文件来构建镜像，如果不使用默认，可以使用<code>-f</code>参数来指定dockerfile文件，如：<code>docker build -t 镜像名:tag -f /xx/xxx/Dockerfile</code>；</p>
<p>5、使用<code>docker build</code>命令构建之后，docker就会将当前目录下所有的文件发送给docker daemon，顺序执行Dockerfile文件里的指令，在这过程中会生成临时容器，在临时容器里面安装RUN指定的命令，安装成功后，docker底层会使用类似于<code>docker commit</code>命令来将容器保存为镜像，然后删除临时容器，以此类推，一层层的构建镜像，运行临时容器安装软件，直到最后的镜像构建成功。</p>
<h3 id="9-Dockerfile构建镜像出现异常，如何排查？"><a href="#9-Dockerfile构建镜像出现异常，如何排查？" class="headerlink" title="9 Dockerfile构建镜像出现异常，如何排查？"></a>9 Dockerfile构建镜像出现异常，如何排查？</h3><p>首先，Dockerfile是一层一层的构建镜像，期间会产生一个或多个临时容器，构建过程中其实就是在临时容器里面安装应用，如果因为临时容器安装应用出现异常导致镜像构建失败，这时容器虽然被清理掉了，但是期间构建的中间镜像还在，那么我们可以根据异常时上一层已经构建好的临时镜像，将临时镜像运行为容器，然后在容器里面运行安装命令来定位具体的异常。</p>
<h3 id="10-Dockerfile的基本指令有哪些？"><a href="#10-Dockerfile的基本指令有哪些？" class="headerlink" title="10 Dockerfile的基本指令有哪些？"></a>10 Dockerfile的基本指令有哪些？</h3><p><code>FROM</code> 指定基础镜像（必须为第一个指令，因为需要指定使用哪个基础镜像来构建镜像）；</p>
<p><code>MAINTAINER</code> 设置镜像作者相关信息，如作者名字，日期，邮件，联系方式等；</p>
<p><code>COPY</code> 复制文件到镜像；</p>
<p><code>ADD</code> 复制文件到镜像（<code>ADD</code>与<code>COPY</code>的区别在于，<code>ADD</code>会自动解压tar、zip、tgz、xz等归档文件，而<code>COPY</code>不会，同时<code>ADD</code>指令还可以接一个url下载文件地址，一般建议使用COPY复制文件即可，文件在宿主机上是什么样子复制到镜像里面就是什么样子这样比较好）；</p>
<p><code>ENV</code> 设置环境变量；</p>
<p><code>EXPOSE</code> 暴露容器进程的端口，仅仅是提示别人容器使用的哪个端口，没有过多作用；</p>
<p><code>VOLUME</code> 数据卷持久化，挂载一个目录；</p>
<p><code>WORKDIR</code> 设置工作目录，如果目录不在，则会自动创建目录；</p>
<p><code>RUN</code>在容器中运行命令，<code>RUN</code>指令会创建新的镜像层，<code>RUN</code>指令经常被用于安装软件包；</p>
<p><code>CMD</code> 指定容器启动时默认运行哪些命令，如果有多个<code>CMD</code>，则只有最后一个生效，另外，<code>CMD</code>指令可以被<code>docker run</code>之后的参数替换；</p>
<p><code>ENTRYOINT</code> 指定容器启动时运行哪些命令，如果有多个<code>ENTRYOINT</code>，则只有最后一个生效，另外，如果Dockerfile中同时存在<code>CMD</code>和<code>ENTRYOINT</code>，那么<code>CMD</code>或<code>docker run</code>之后的参数将被当做参数传递给<code>ENTRYOINT</code>；</p>
<h3 id="11-如何进入容器？使用哪个命令"><a href="#11-如何进入容器？使用哪个命令" class="headerlink" title="11 如何进入容器？使用哪个命令"></a>11 如何进入容器？使用哪个命令</h3><p>进入容器有两种方法：<code>docker attach</code>、<code>docker exec</code>；</p>
<p><code>docker attach</code>命令是attach到容器启动命令的终端，<code>docker exec</code>是另外在容器里面启动一个TTY终端。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">docker run -d centos /bin/bash -c <span class="string">&quot;while true;do sleep 2;echo I_am_a_container;done&quot;</span></span><br><span class="line">3274412d88ca4f1d1292f6d28d46f39c14c733da5a4085c11c6a854d30d1cde0</span><br><span class="line">docker attach 3274412d88ca4f                        <span class="comment">#attach进入容器</span></span><br><span class="line">Ctrl + c  退出，Ctrl + c会直接关闭容器终端，这样容器没有进程一直在前台运行就会死掉了</span><br><span class="line">Ctrl + pq 退出（不会关闭容器终端停止容器，仅退出）</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it 3274412d88ca /bin/bash              <span class="comment">#exec进入容器   </span></span><br><span class="line">[root@3274412d88ca /]<span class="comment"># ps -ef                       #进入到容器了开启了一个bash进程</span></span><br><span class="line">UID         PID   PPID  C STIME TTY          TIME CMD</span><br><span class="line">root          1      0  0 05:31 ?        00:00:01 /bin/bash -c <span class="keyword">while</span> <span class="literal">true</span>;<span class="keyword">do</span> <span class="built_in">sleep</span> 2;<span class="built_in">echo</span> I_am_a_container;<span class="keyword">done</span></span><br><span class="line">root        306      0  1 05:41 pts/0    00:00:00 /bin/bash</span><br><span class="line">root        322      1  0 05:41 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=<span class="built_in">sleep</span> /usr/bin/sleep 2</span><br><span class="line">root        323    306  0 05:41 pts/0    00:00:00 ps -ef</span><br><span class="line">[root@3274412d88ca /]<span class="comment">#exit                          #退出容器，仅退出我们自己的bash窗口</span></span><br></pre></td></tr></table></figure>
<p>小结：attach是直接进入容器启动命令的终端，不会启动新的进程；exec则是在容器里面打开新的终端，会启动新的进程；一般建议已经exec进入容器。</p>
<h3 id="12-什么是k8s？说出你的理解"><a href="#12-什么是k8s？说出你的理解" class="headerlink" title="12 什么是k8s？说出你的理解"></a>12 什么是k8s？说出你的理解</h3><p>K8s是kubernetes的简称，其本质是一个开源的容器编排系统，主要用于管理容器化的应用，其目标是让部署容器化的应用简单并且高效（powerful）,Kubernetes提供了应用部署，规划，更新，维护的一种机制。</p>
<p>说简单点：k8s就是一个编排容器的系统，一个可以管理容器应用全生命周期的工具，从创建应用，应用的部署，应用提供服务，扩容缩容应用，应用更新，都非常的方便，而且还可以做到故障自愈，所以，k8s是一个非常强大的容器编排系统。</p>
<h3 id="13-k8s的组件有哪些，作用分别是什么？"><a href="#13-k8s的组件有哪些，作用分别是什么？" class="headerlink" title="13 k8s的组件有哪些，作用分别是什么？"></a>13 k8s的组件有哪些，作用分别是什么？</h3><p>k8s主要由master节点和node节点构成。master节点负责管理集群，node节点是容器应用真正运行的地方。 master节点包含的组件有：kube-api-server、kube-controller-manager、kube-scheduler、etcd。 node节点包含的组件有：kubelet、kube-proxy、container-runtime。</p>
<p>kube-api-server：以下简称api-server，api-server是k8s最重要的核心组件之一，它是k8s集群管理的统一访问入口，提供了RESTful API接口, 实现了认证、授权和准入控制等安全功能；api-server还是其他组件之间的数据交互和通信的枢纽，其他组件彼此之间并不会直接通信，其他组件对资源对象的增、删、改、查和监听操作都是交由api-server处理后，api-server再提交给etcd<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">数据库</a>做持久化存储，只有api-server才能直接操作etcd数据库，其他组件都不能直接操作etcd数据库，其他组件都是通过api-server间接的读取，写入数据到etcd。</p>
<p>kube-controller-manager：以下简称controller-manager，controller-manager是k8s中各种控制器的的管理者，是k8s集群内部的管理控制中心，也是k8s<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E8%87%AA%E5%8A%A8%E5%8C%96&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">自动化</a>功能的核心；controller-manager内部包含replication controller、node controller、deployment controller、endpoint controller等各种资源对象的控制器，每种控制器都负责一种特定资源的控制流程，而controller-manager正是这些controller的核心管理者。</p>
<p>kube-scheduler：以下简称scheduler，scheduler负责集群资源调度，其作用是将待调度的pod通过一系列复杂的调度算法计算出最合适的node节点，然后将pod绑定到目标节点上。shceduler会根据pod的信息，全部节点信息列表，过滤掉不符合要求的节点，过滤出一批候选节点，然后给候选节点打分，选分最高的就是最佳节点，scheduler就会把目标pod安置到该节点。</p>
<p>Etcd：etcd是一个分布式的键值对存储数据库，主要是用于保存k8s集群状态数据，比如，pod，service等资源对象的信息；etcd可以是单个也可以有多个，多个就是etcd数据库集群，etcd通常部署奇数个实例，在大规模集群中，etcd有5个或7个节点就足够了；另外说明一点，etcd本质上可以不与master节点部署在一起，只要master节点能通过<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">网络连接</a>etcd数据库即可。</p>
<p>kubelet：每个node节点上都有一个kubelet服务进程，kubelet作为连接master和各node之间的桥梁，负责维护pod和容器的生命周期，当监听到master下发到本节点的任务时，比如创建、更新、终止pod等任务，kubelet 即通过控制docker来创建、更新、销毁容器； 每个kubelet进程都会在api-server上注册本节点自身的信息，用于定期向master汇报本节点资源的使用情况。</p>
<p>kube-proxy：kube-proxy运行在node节点上，在Node节点上实现Pod网络代理，维护网络规则和四层负载均衡工作，kube-proxy会监听api-server中从而获取service和endpoint的变化情况，创建并维护路由规则以提供服务IP和负载均衡功能。简单理解此进程是Service的透明代理兼负载均衡器，其核心功能是将到某个Service的访问请求转发到后端的多个Pod实例上。</p>
<p>container-runtime：容器运行时环境，即运行容器所需要的一系列程序，目前k8s支持的容器运行时有很多，如docker、rkt或其他，比较受欢迎的是docker，但是新版的k8s已经宣布弃用docker。</p>
<h3 id="14-kube-api-server的端口是多少？各个pod是如何访问kube-api-server的？"><a href="#14-kube-api-server的端口是多少？各个pod是如何访问kube-api-server的？" class="headerlink" title="14 kube-api-server的端口是多少？各个pod是如何访问kube-api-server的？"></a>14 kube-api-server的端口是多少？各个pod是如何访问kube-api-server的？</h3><p>kube-api-server的端口是8080和6443，前者是http的端口，后者是https的端口，以我本机使用kubeadm安装的k8s为例：</p>
<p>在命名空间的kube-system命名空间里，有一个名称为kube-api-master的pod，这个pod就是运行着kube-api-server进程，它绑定了master主机的ip地址和6443端口，但是在default命名空间下，存在一个叫kubernetes的服务，该服务对外暴露端口为443，目标端口6443，这个服务的ip地址是clusterip地址池里面的第一个地址，同时这个服务的yaml定义里面并没有指定标签选择器，也就是说这个kubernetes服务所对应的endpoint是手动创建的，该endpoint也是名称叫做kubernetes，该endpoint的yaml定义里面代理到master节点的6443端口，也就是kube-api-server的IP和端口。这样一来，其他pod访问kube-api-server的整个流程就是：pod创建后嵌入了环境变量，pod获取到了kubernetes这个服务的ip和443端口，请求到kubernetes这个服务其实就是转发到了master节点上的6443端口的kube-api-server这个pod里面。</p>
<h3 id="15-k8s中命名空间的作用是什么？"><a href="#15-k8s中命名空间的作用是什么？" class="headerlink" title="15 k8s中命名空间的作用是什么？"></a>15 k8s中命名空间的作用是什么？</h3><p>amespace是kubernetes系统中的一种非常重要的资源，namespace的主要作用是用来实现多套环境的资源隔离，或者说是多租户的资源隔离。</p>
<p>k8s通过将集群内部的资源分配到不同的namespace中，可以形成逻辑上的隔离，以方便不同的资源进行隔离使用和管理。不同的命名空间可以存在同名的资源，命名空间为资源提供了一个作用域。</p>
<p>可以通过k8s的授权机制，将不同的namespace交给不同的租户进行管理，这样就实现了多租户的资源隔离，还可以结合k8s的资源配额机制，限定不同的租户能占用的资源，例如CPU使用量、内存使用量等等来实现租户可用资源的管理。</p>
<h3 id="16-k8s提供了大量的REST接口，其中有一个是Kubernetes-Proxy-API接口，简述一下这个Proxy接口的作用，已经怎么使用。"><a href="#16-k8s提供了大量的REST接口，其中有一个是Kubernetes-Proxy-API接口，简述一下这个Proxy接口的作用，已经怎么使用。" class="headerlink" title="16 k8s提供了大量的REST接口，其中有一个是Kubernetes Proxy API接口，简述一下这个Proxy接口的作用，已经怎么使用。"></a>16 k8s提供了大量的REST接口，其中有一个是Kubernetes Proxy API接口，简述一下这个Proxy接口的作用，已经怎么使用。</h3><p>好的。kubernetes proxy <a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=api%E6%8E%A5%E5%8F%A3&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">api接口</a>，从名称中可以得知，proxy是代理的意思，其作用就是代理rest请求；</p>
<p>Kubernets API server 将接收到的rest请求转发到某个node上的kubelet守护进程的rest接口，由该kubelet进程负责响应。我们可以使用这种Proxy接口来<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">直接访问</a>某个pod，这对于逐一排查pod异常问题很有帮助。 下面是一些简单的例子：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">http://&lt;kube-api-server&gt;:&lt;api-sever-port&gt;/api/v1/nodes/node名称/proxy/pods    <span class="comment">#查看指定node的所有pod信息</span></span><br><span class="line">http://&lt;kube-api-server&gt;:&lt;api-sever-port&gt;/api/v1/nodes/node名称/proxy/stats   <span class="comment">#查看指定node的物理资源统计信息</span></span><br><span class="line">http://&lt;kube-api-server&gt;:&lt;api-sever-port&gt;/api/v1/nodes/node名称/proxy/spec    <span class="comment">#查看指定node的概要信息</span></span><br><span class="line"></span><br><span class="line">http://&lt;kube-api-server&gt;:&lt;api-sever-port&gt;/api/v1/namespace/命名名称/pods/pod名称/pod服务的url/   <span class="comment">#访问指定pod的程序页面</span></span><br><span class="line">http://&lt;kube-api-server&gt;:&lt;api-sever-port&gt;/api/v1/namespace/命名名称/servers/svc名称/url/      <span class="comment">#访问指定server的url程序页面</span></span><br></pre></td></tr></table></figure>
<h3 id="17-pod是什么？"><a href="#17-pod是什么？" class="headerlink" title="17 pod是什么？"></a>17 pod是什么？</h3><p>在kubernetes的世界中，k8s并不直接处理容器，而是使用多个容器共存的理念，这组容器就叫做pod。pod是k8s中可以创建和管理的最小单元，是资源对象模型中由用户创建或部署的最小资源对象模型，其他的资源对象都是用来支撑pod对象功能的，比如，pod控制器就是用来管理pod对象的，service或者ingress资源对象是用来暴露pod引用对象的，persistentvolume资源是用来为pod提供存储等等，简而言之，k8s不会直接处理容器，而是pod，pod才是k8s中可以创建和管理的最小单元，也是基本单元。</p>
<h3 id="18-pod的原理是什么？"><a href="#18-pod的原理是什么？" class="headerlink" title="18 pod的原理是什么？"></a>18 pod的原理是什么？</h3><p>在<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%BE%AE%E6%9C%8D%E5%8A%A1&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">微服务</a>的概念里，一般的，一个容器会被设计为运行一个进程，除非进程本身产生子进程，这样，由于不能将多个进程聚集在同一个单独的容器中，所以需要一种更高级的结构将容器绑定在一起，并将它们作为一个单元进行管理，这就是k8s中pod的背后原理。</p>
<h3 id="19-pod有什么特点？"><a href="#19-pod有什么特点？" class="headerlink" title="19 pod有什么特点？"></a>19 pod有什么特点？</h3><p>1、每个pod就像一个独立的逻辑机器，k8s会为每个pod分配一个集群内部唯一的IP地址，所以每个pod都拥有自己的IP地址、主机名、进程等；</p>
<p>2、一个pod可以包含1个或多个容器，1个容器一般被设计成只运行1个进程，1个pod只可能运行在单个节点上，即不可能1个pod跨节点运行，pod的生命周期是短暂，也就是说pod可能随时被消亡（如节点异常，pod异常等情况）；</p>
<p>3、每一个pod都有一个特殊的被称为”根容器”的pause容器，也称info容器，pause容器对应的镜像属于k8s平台的一部分，除了pause容器，每个pod还包含一个或多个跑业务相关组件的应用容器；</p>
<p>4、一个pod中的容器共享network命名空间；</p>
<p>5、一个pod里的多个容器共享pod IP，这就意味着1个pod里面的多个容器的进程所占用的端口不能相同，否则在这个pod里面就会产生端口冲突；既然每个pod都有自己的IP和端口空间，那么对不同的两个pod来说就不可能存在端口冲突；</p>
<p>6、应该将应用程序组织到多个pod中，而每个pod只包含紧密相关的组件或进程；</p>
<p>7、pod是k8s中扩容、缩容的基本单位，也就是说k8s中扩容缩容是针对pod而言而非容器。</p>
<h3 id="20-pause容器作用是什么？"><a href="#20-pause容器作用是什么？" class="headerlink" title="20 pause容器作用是什么？"></a>20 pause容器作用是什么？</h3><p>每个pod里运行着一个特殊的被称之为pause的容器，也称根容器，而其他容器则称为业务容器；创建pause容器主要是为了为业务容器提供 Linux命名空间，共享基础：包括 pid、icp、net 等，以及启动 init 进程，并收割僵尸进程；这些业务容器共享pause容器的网络命名空间和volume挂载卷，当pod被创建时，pod首先会创建pause容器，从而把其他业务容器加入pause容器，从而让所有业务容器都在同一个命名空间中，这样可以就可以实现网络共享。pod还可以共享存储，在pod级别引入数据卷volume，业务容器都可以挂载这个数据卷从而实现持久化存储。</p>
<h3 id="21-pod的重启策略有哪些？"><a href="#21-pod的重启策略有哪些？" class="headerlink" title="21 pod的重启策略有哪些？"></a>21 pod的重启策略有哪些？</h3><p>pod重启容器策略是指针对pod内所有容器的重启策略，不是重启pod，其可以通过<code>restartPolicy</code>字段配置pod重启容器的策略，如下：</p>
<ul>
<li><code>Always</code>: 当容器终止退出后，总是重启容器，默认策略就是<code>Always</code>。</li>
<li><code>OnFailure</code>: 当容器异常退出，退出状态码非0时，才重启容器。</li>
<li><code>Never</code>: 当容器终止退出，不管退出状态码是什么，从不重启容器。</li>
</ul>
<h3 id="22-pod的镜像拉取策略有哪几种？"><a href="#22-pod的镜像拉取策略有哪几种？" class="headerlink" title="22 pod的镜像拉取策略有哪几种？"></a>22 pod的镜像拉取策略有哪几种？</h3><p>pod镜像拉取策略可以通过<code>imagePullPolicy</code>字段配置镜像拉取策略，主要有3中镜像拉取策略，如下：</p>
<ul>
<li><code>IfNotPresent</code>: 默认值，镜像在node节点宿主机上不存在时才拉取。</li>
<li><code>Always</code>: 总是重新拉取，即每次创建pod都会重新从镜像仓库拉取一次镜像。</li>
<li><code>Never</code>: 永远不会主动拉取镜像，仅使用本地镜像，需要你手动拉取镜像到node节点，如果node节点不存在镜像则pod启动失败。</li>
</ul>
<h3 id="23-pod的存活探针有哪几种？"><a href="#23-pod的存活探针有哪几种？" class="headerlink" title="23 pod的存活探针有哪几种？"></a>23 pod的存活探针有哪几种？</h3><p>kubernetes可以通过存活探针检查容器是否还在运行，可以为pod中的每个容器单独定义存活探针，kubernetes将定期执行探针，如果探测失败，将杀死容器，并根据<code>restartPolicy</code>策略来决定是否重启容器，kubernetes提供了3种探测容器的存活探针，如下：</p>
<ul>
<li><code>httpGet</code>：通过容器的IP、端口、路径发送http 请求，返回200-400范围内的状态码表示成功。</li>
<li><code>exec</code>：在容器内执行shell命令，根据命令退出状态码是否为0进行判断，0表示健康，非0表示不健康。</li>
<li><code>TCPSocket</code>：与容器的端口建立TCP Socket链接。</li>
</ul>
<h3 id="24-存活探针的属性参数有哪几个？"><a href="#24-存活探针的属性参数有哪几个？" class="headerlink" title="24 存活探针的属性参数有哪几个？"></a>24 存活探针的属性参数有哪几个？</h3><p>存活探针的附加属性参数有以下几个：</p>
<ul>
<li><code>initialDelaySeconds</code>：表示在容器启动后延时多久秒才开始探测；</li>
<li><code>periodSeconds</code>：表示执行探测的频率，即间隔多少秒探测一次，默认间隔周期是10秒，最小1秒；</li>
<li><code>timeoutSeconds</code>：表示探测超时时间，默认1秒，最小1秒，表示容器必须在超时时间范围内做出响应，否则视为本次探测失败；</li>
<li><code>successThreshold</code>：表示最少连续探测成功多少次才被认定为成功，默认是1，对于liveness必须是1，最小值是1；</li>
<li><code>failureThreshold</code>：表示连续探测失败多少次才被认定为失败，默认是3，连续3次失败，k8s 将根据pod重启策略对容器做出决定；</li>
</ul>
<p>注意：定义存活探针时，一定要设置<code>initialDelaySeconds</code>属性，该属性为初始延时，如果不设置，默认容器启动时探针就开始探测了，这样可能会存在应用程序还未启动就绪，就会导致探针检测失败，k8s就会根据pod重启策略杀掉容器然后再重新创建容器的莫名其妙的问题。</p>
<p>在生产环境中，一定要定义一个存活探针。</p>
<h3 id="25-pod的就绪探针有哪几种？"><a href="#25-pod的就绪探针有哪几种？" class="headerlink" title="25 pod的就绪探针有哪几种？"></a>25 pod的就绪探针有哪几种？</h3><p>我们知道，当一个pod启动后，就会立即加入service的endpoint ip列表中，并开始接收到客户端的链接请求，假若此时pod中的容器的业务进程还没有初始化完毕，那么这些客户端链接请求就会失败，为了解决这个问题，kubernetes提供了就绪探针来解决这个问题的。</p>
<p>在pod中的容器定义一个就绪探针，就绪探针周期性检查容器，如果就绪探针检查失败了，说明该pod还未准备就绪，不能接受客户端链接，则该pod将从endpoint列表中移除，被剔除了service就不会把请求分发给该pod，然后就绪探针继续检查，如果随后容器就绪，则再重新把pod加回endpoint列表。k8s提供了3种就绪探针，如下：</p>
<ul>
<li><code>exec</code>：在容器中执行命令并检查命令退出的状态码，如果状态码为0，则说明容器已经准备就绪；</li>
<li><code>httpGet</code>：向容器发送http get请求，通过响应的http状态码判断容器是否准备就绪；</li>
<li><code>tcpSocket</code>：打开一个tcp连接到容器的指定端口，如果连接已建立，则认为容器已经准备就绪。</li>
</ul>
<h3 id="26-就绪探针的属性参数有哪些"><a href="#26-就绪探针的属性参数有哪些" class="headerlink" title="26 就绪探针的属性参数有哪些"></a>26 就绪探针的属性参数有哪些</h3><p>就绪探针的附加属性参数有以下几个：</p>
<ul>
<li><code>initialDelaySeconds</code>：延时秒数，即容器启动多少秒后才开始探测，不写默认容器启动就探测；</li>
<li><code>periodSeconds</code> ：执行探测的频率（秒），默认为10秒，最低值为1；</li>
<li><code>timeoutSeconds</code> ：超时时间，表示探测时在超时时间内必须得到响应，负责视为本次探测失败，默认为1秒，最小值为1；</li>
<li><code>failureThreshold</code> ：连续探测失败的次数，视为本次探测失败，默认为3次，最小值为1次；</li>
<li><code>successThreshold</code> ：连续探测成功的次数，视为本次探测成功，默认为1次，最小值为1次；</li>
</ul>
<h3 id="27-就绪探针与存活探针区别是什么？"><a href="#27-就绪探针与存活探针区别是什么？" class="headerlink" title="27 就绪探针与存活探针区别是什么？"></a>27 就绪探针与存活探针区别是什么？</h3><p>两者作用不一样，存活探针是将检查失败的容器杀死，创建新的启动容器来保持pod正常工作；</p>
<p>就绪探针是，当就绪探针检查失败，并不重启容器，而是将pod移出endpoint，就绪探针确保了service中的pod都是可用的，确保客户端只与正常的pod交互并且客户端永远不会知道系统存在问题。</p>
<h3 id="28-简单讲一下-pod创建过程"><a href="#28-简单讲一下-pod创建过程" class="headerlink" title="28 简单讲一下 pod创建过程"></a>28 简单讲一下 pod创建过程</h3><p>1、用户通过kubectl或其他api客户端工具提交需要创建的pod信息给apiserver；</p>
<p>2、apiserver验证客户端的用户权限信息，验证通过开始处理创建请求生成pod对象信息，并将信息存入etcd，然后返回确认信息给客户端；</p>
<p>3、apiserver开始反馈etcd中pod对象的变化，其他组件使用watch机制跟踪apiserver上的变动；</p>
<p>4、scheduler发现有新的pod对象要创建，开始调用内部算法机制为pod分配最佳的主机，并将结果信息更新至apiserver；</p>
<p>5、node节点上的kubelet通过watch机制跟踪apiserver发现有pod调度到本节点，尝试调用docker启动容器，并将结果反馈apiserver；</p>
<p>6、apiserver将收到的pod状态信息存入etcd中。</p>
<p>至此，整个pod调度完成，创建完毕。</p>
<h3 id="29-简单描述一下pod的终止过程"><a href="#29-简单描述一下pod的终止过程" class="headerlink" title="29 简单描述一下pod的终止过程"></a>29 简单描述一下pod的终止过程</h3><p>1、用户向apiserver发送删除pod对象的命令；</p>
<p>2、apiserver中的pod对象信息会随着时间的推移而更新，在宽限期内（默认30s），pod被视为dead；</p>
<p>3、将pod标记为terminating状态；</p>
<p>4、kubectl在监控到pod对象为terminating状态了就会启动pod关闭过程；</p>
<p>5、endpoint控制器监控到pod对象的关闭行为时将其从所有匹配到此endpoint的server资源endpoint列表中删除；</p>
<p>6、如果当前pod对象定义了preStop钩子处理器，则在其被标记为terminating后会意同步的方式启动执行；</p>
<p>7、pod对象中的容器进程收到停止信息；</p>
<p>8、宽限期结束后，若pod中还存在运行的进程，那么pod对象会收到立即终止的信息；</p>
<p>9、kubelet请求apiserver将此pod资源的宽限期设置为0从而完成删除操作，此时pod对用户已不可见。</p>
<h3 id="30-pod的生命周期有哪几种？"><a href="#30-pod的生命周期有哪几种？" class="headerlink" title="30 pod的生命周期有哪几种？"></a>30 pod的生命周期有哪几种？</h3><p>pod生命周期有的5种状态（也称5种相位），如下：</p>
<ul>
<li><strong>Pending</strong>（挂起）：API server已经创建pod，但是该pod还有一个或多个容器的镜像没有创建，包括正在下载镜像的过程；</li>
<li><strong>Running</strong>（运行中）：Pod内所有的容器已经创建，且至少有一个容器处于运行状态、正在启动括正在重启状态；</li>
<li><strong>Succeed</strong>（成功）：Pod内所有容器均已退出，且不会再重启；</li>
<li><strong>Failed</strong>（失败）：Pod内所有容器均已退出，且至少有一个容器为退出失败状态</li>
<li><strong>Unknown</strong>（未知）：某于某种原因apiserver无法获取该pod的状态，可能由于网络通行问题导致；</li>
</ul>
<h3 id="31-pod的初始化容器是干什么的？"><a href="#31-pod的初始化容器是干什么的？" class="headerlink" title="31 pod的初始化容器是干什么的？"></a>31 pod的初始化容器是干什么的？</h3><p>init container，初始化容器用于在启动应用容器之前完成应用容器所需要的前置条件，初始化容器本质上和应用容器是一样的，但是初始化容器是仅允许一次就结束的任务，初始化容器具有两大特征：</p>
<p>1、初始化容器必须运行完成直至结束，若某初始化容器运行失败，那么kubernetes需要重启它直到成功完成；</p>
<p>2、初始化容器必须按照定义的顺序执行，当且仅当前一个初始化容器成功之后，后面的一个初始化容器才能运行；</p>
<h3 id="32-pod的资源请求、限制如何定义？"><a href="#32-pod的资源请求、限制如何定义？" class="headerlink" title="32 pod的资源请求、限制如何定义？"></a>32 pod的资源请求、限制如何定义？</h3><p>pod的资源请求、资源限制可以直接在pod中定义，主要包括两块内容，limits，限制pod能使用的最大cpu和内存，requests，pod启动时申请的cpu和内存。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">resources:</span>                  <span class="comment">#资源配额</span></span><br><span class="line">  <span class="attr">limits:</span>                   <span class="comment">#限制最大资源，上限</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="number">2</span>                  <span class="comment">#CPU限制，单位是code数</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">2G</span>              <span class="comment">#内存最大限制</span></span><br><span class="line">  <span class="attr">requests:</span>                 <span class="comment">#请求资源（最小，下限）</span></span><br><span class="line">    <span class="attr">cpu:</span> <span class="number">1</span>                  <span class="comment">#CPU请求，单位是code数</span></span><br><span class="line">    <span class="attr">memory:</span> <span class="string">500G</span>            <span class="comment">#内存最小请求</span></span><br></pre></td></tr></table></figure>
<h3 id="33-标签及标签选择器是什么，如何使用？"><a href="#33-标签及标签选择器是什么，如何使用？" class="headerlink" title="33 标签及标签选择器是什么，如何使用？"></a>33 标签及标签选择器是什么，如何使用？</h3><p>标签是键值对类型，标签可以附加到任何资源对象上，主要用于管理对象，查询和筛选。标签常被用于标签选择器的匹配度检查，从而完成资源筛选；一个资源可以定义一个或多个标签在其上面。</p>
<p>标签选择器，标签要与标签选择器结合在一起，标签选择器允许我们选择标记有特定标签的资源对象子集，如pod，并对这些特定标签的pod进行查询，删除等操作。</p>
<p>标签和标签选择器最重要的使用之一在于，在deployment中，在pod模板中定义pod的标签，然后在deployment定义标签选择器，这样就通过标签选择器来选择哪些pod是受其控制的，service也是通过标签选择器来关联哪些pod最后其服务后端pod。</p>
<h3 id="34-service是如何与pod关联的？"><a href="#34-service是如何与pod关联的？" class="headerlink" title="34 service是如何与pod关联的？"></a>34 service是如何与pod关联的？</h3><p>答案是通过标签选择器，每一个由deployment创建的pod都带有标签，这样，service就可以定义标签选择器来关联哪些pod是作为其后端了，就是这样，service就与pod管联在一起了。</p>
<h3 id="35-service的域名解析格式、pod的域名解析格式"><a href="#35-service的域名解析格式、pod的域名解析格式" class="headerlink" title="35 service的域名解析格式、pod的域名解析格式"></a>35 service的<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">域名解析</a>格式、pod的域名解析格式</h3><p>service的DNS域名表示格式为<code>&lt;servicename&gt;.&lt;namespace&gt;.svc.&lt;clusterdomain&gt;</code>，servicename是service的名称，namespace是service所处的命名空间，clusterdomain是k8s集群设置的域名后缀，一般默认为 <code>cluster.local</code></p>
<p>pod的DNS域名格式为：<code>&lt;pod-ip&gt;.&lt;namespace&gt;.pod.&lt;clusterdomain&gt;</code>，其中，<code>pod-ip</code>需要使用<code>-</code>将<code>ip</code>直接的点替换掉，namespace为pod所在的命名空间，clusterdomain是k8s集群设置的域名后缀，一般默认为<code>cluster.local</code> .</p>
<h3 id="36-一个应用pod是如何发现service的，或者说，pod里面的容器用于是如何连接service的？"><a href="#36-一个应用pod是如何发现service的，或者说，pod里面的容器用于是如何连接service的？" class="headerlink" title="36 一个应用pod是如何发现service的，或者说，pod里面的容器用于是如何连接service的？"></a>36 一个应用pod是如何发现service的，或者说，pod里面的容器用于是如何连接service的？</h3><p>答：有两种方式，一种是通过环境变量，另一种是通过service的dns域名方式。</p>
<p>1、环境变量：当pod被创建之后，k8s系统会自动为容器注入集群内有效的service名称和端口号等信息为环境变量的形式，这样容器应用直接通过取环境变量值就能访问service了，如<code>curl http://$&#123;WEBAPP_SERVICE_HOST&#125;:&#123;WEBAPP_SERVICE_PORT&#125;</code></p>
<p>2、DNS方式：使用dns域名解析的前提是k8s集群内有DNS域名解析服务器，默认k8s中会有一个CoreDNS作为k8s集群的默认DNS服务器提供域名解析服务器；service的DNS域名表示格式为<code>&lt;servicename&gt;.&lt;namespace&gt;.svc.&lt;clusterdomain&gt;</code>，servicename是service的名称，namespace是service所处的命名空间，clusterdomain是k8s集群设置的域名后缀，一般默认为 cluster.local ，这样容器应用直接通过service域名就能访问service了，如<code>wget http://svc-deployment-nginx.default.svc.cluster.local:80</code>，另外，service的port端口如果定义了名称，那么port也可以通过DNS进行解析，格式为：<code>_&lt;portname&gt;._&lt;protocol&gt;.&lt;servicename&gt;.&lt;namespace&gt;.svc.&lt;clusterdomain&gt;</code></p>
<h3 id="37-如何创建一个service代理外部的服务，或者换句话来说，在k8s集群内的应用如何访问外部的服务，如数据库服务，缓存服务等"><a href="#37-如何创建一个service代理外部的服务，或者换句话来说，在k8s集群内的应用如何访问外部的服务，如数据库服务，缓存服务等" class="headerlink" title="37 如何创建一个service代理外部的服务，或者换句话来说，在k8s集群内的应用如何访问外部的服务，如数据库服务，缓存服务等?"></a>37 如何创建一个service代理外部的服务，或者换句话来说，在k8s集群内的应用如何访问外部的服务，如数据库服务，缓存服务等?</h3><p>答：可以通过创建一个没有标签选择器的service来代理集群外部的服务。</p>
<p>1、创建service时不指定selector标签选择器，但需要指定service的port、targetPort、协议等，这样创建出来的service因为没有指定标签选择器就不会自动创建endpoint；</p>
<p>2、手动创建一个与service同名的endpoint，endpoint中定义外部服务的IP和端口，endpoint的名称一定要与service的名称一样，协议也要一样，不然endpoint不能与service进行关联。 完成以上两步，k8s会自动将service和同名的endpoint进行关联，这样，k8s集群内的应用服务直接访问这个service就可以相当于访问外部的服务了。</p>
<h3 id="38-service、endpoint、kube-proxys三种的关系是什么？"><a href="#38-service、endpoint、kube-proxys三种的关系是什么？" class="headerlink" title="38 service、endpoint、kube-proxys三种的关系是什么？"></a>38 service、endpoint、kube-proxys三种的关系是什么？</h3><p>service：在kubernetes中，service是一种为一组功能相同的pod提供单一不变的接入点的资源。当service被建立时，service的IP和端口不会改变，这样外部的客户端（也可以是集群内部的客户端）通过service的IP和端口来建立链接，这些链接会被路由到提供该服务的任意一个pod上。通过这样的方式，客户端不需要知道每个单独提供服务的pod地址，这样pod就可以在集群中随时被创建或销毁。</p>
<p>endpoint：service维护一个叫endpoint的资源列表，endpoint资源对象保存着service关联的pod的ip和端口。从表面上看，当pod消失，service会在endpoint列表中剔除pod，当有新的pod加入，service就会将pod ip加入endpoint列表；但是正在底层的逻辑是，endpoint的这种自动剔除、添加、更新pod的地址其实底层是由endpoint controller控制的，endpoint controller负责监听service和对应的pod副本的变化，如果监听到service被删除，则删除和该service同名的endpoint对象，如果监听到新的service被创建或者修改，则根据该service<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BF%A1%E6%81%AF%E8%8E%B7%E5%8F%96&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A2708298459%7D">信息获取</a>得相关pod列表，然后创建或更新service对应的endpoint对象，如果监听到pod事件，则更新它所对应的service的endpoint对象。</p>
<p>kube-proxy：kube-proxy运行在node节点上，在Node节点上实现Pod网络代理，维护网络规则和四层负载均衡工作，kube-proxy会监听api-server中从而获取service和endpoint的变化情况，创建并维护路由规则以提供服务IP和负载均衡功能。简单理解此进程是Service的透明代理兼负载均衡器，其核心功能是将到某个Service的访问请求转发到后端的多个Pod实例上。</p>
<h3 id="39-deployment怎么扩容或缩容？"><a href="#39-deployment怎么扩容或缩容？" class="headerlink" title="39 deployment怎么扩容或缩容？"></a>39 deployment怎么扩容或缩容？</h3><p>答：直接修改pod副本数即可，可以通过下面的方式来修改pod副本数：</p>
<p>1、直接修改yaml文件的replicas字段数值，然后<code>kubectl apply -f xxx.yaml</code>来实现更新；</p>
<p>2、使用<code>kubectl edit deployment xxx</code>修改replicas来实现在线更新；</p>
<p>3、使用<code>kubectl scale --replicas=5 deployment/deployment-nginx</code>命令来扩容缩容。</p>
<h3 id="40-deployment的更新升级策略有哪些？"><a href="#40-deployment的更新升级策略有哪些？" class="headerlink" title="40 deployment的更新升级策略有哪些？"></a>40 deployment的更新升级策略有哪些？</h3><p>答：deployment的升级策略主要有两种。</p>
<p>1、<code>Recreate</code> 重建更新：这种更新策略会杀掉所有正在运行的pod，然后再重新创建的pod；</p>
<p>2、<code>rollingUpdate</code> 滚动更新：这种更新策略，deployment会以滚动更新的方式来逐个更新pod，同时通过设置滚动更新的两个参数<code>maxUnavailable、maxSurge</code>来控制更新的过程。</p>
<h3 id="41-deployment的滚动更新策略有两个特别主要的参数，解释一下它们是什么意思？"><a href="#41-deployment的滚动更新策略有两个特别主要的参数，解释一下它们是什么意思？" class="headerlink" title="41 deployment的滚动更新策略有两个特别主要的参数，解释一下它们是什么意思？"></a>41 deployment的滚动更新策略有两个特别主要的参数，解释一下它们是什么意思？</h3><p>答：deployment的滚动更新策略，<code>rollingUpdate</code> 策略，主要有两个参数，<code>maxUnavailable</code>、<code>maxSurge</code>。</p>
<ul>
<li><code>maxUnavailable</code>：最大不可用数，<code>maxUnavailable</code>用于指定deployment在更新的过程中不可用状态的pod的最大数量，<code>maxUnavailable</code>的值可以是一个整数值，也可以是pod期望副本的百分比，如25%，计算时向下取整。</li>
<li><code>maxSurge</code>：最大激增数，<code>maxSurge</code>指定deployment在更新的过程中pod的总数量最大能超过pod副本数多少个，<code>maxUnavailable</code>的值可以是一个整数值，也可以是pod期望副本的百分比，如25%，计算时向上取整。</li>
</ul>
<h3 id="42-deployment更新的命令有哪些？"><a href="#42-deployment更新的命令有哪些？" class="headerlink" title="42 deployment更新的命令有哪些？"></a>42 deployment更新的命令有哪些？</h3><p>答：可以通过三种方式来实现更新deployment。</p>
<p>1、直接修改yaml文件的镜像版本，然后<code>kubectl apply -f xxx.yaml</code>来实现更新；</p>
<p>2、使用<code>kubectl edit deployment xxx</code>实现在线更新；</p>
<p>3、使用<code>kubectl set image deployment/nginx busybox=busybox nginx=nginx:1.9.1</code>命令来更新。</p>
<h3 id="43-简述一下deployment的更新过程"><a href="#43-简述一下deployment的更新过程" class="headerlink" title="43 简述一下deployment的更新过程?"></a>43 简述一下deployment的更新过程?</h3><p>deployment是通过控制replicaset来实现，由replicaset真正创建pod副本，每更新一次deployment，都会创建新的replicaset，下面来举例deployment的更新过程： 假设要升级一个nginx-deployment的版本镜像为<code>nginx:1.9</code>，deployment的定义滚动更新参数如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">replicas: 3</span><br><span class="line">deployment.spec.strategy.type: RollingUpdate</span><br><span class="line">maxUnavailable：25%</span><br><span class="line">maxSurge：25%</span><br></pre></td></tr></table></figure>
<p>通过计算我们得出，3*25%=0.75，<code>maxUnavailable</code>是向下取整，则<code>maxUnavailable=0</code>，<code>maxSurge</code>是向上取整，则<code>maxSurge=1</code>，所以我们得出在整个deployment升级镜像过程中，不管旧的pod和新的pod是如何创建消亡的，pod总数最大不能超过<code>3+maxSurge=4</code>个，最大pod不可用数<code>3-maxUnavailable=3</code>个。</p>
<p>现在具体讲一下deployment的更新升级过程： 使用<code>kubectl set image deployment/nginx nginx=nginx:1.9 --record</code>命令来更新；</p>
<p>1、deployment创建一个新的replaceset，先新增1个新版本pod，此时pod总数为4个，不能再新增了，再新增就超过pod总数4个了；旧=3，新=1，总=4；</p>
<p>2、减少一个旧版本的pod，此时pod总数为3个，这时不能再减少了，再减少就不满足最大pod不可用数3个了；旧=2，新=1，总=3；</p>
<p>3、再新增一个新版本的pod，此时pod总数为4个，不能再新增了；旧=2，新=2，总=4；</p>
<p>4、减少一个旧版本的pod，此时pod总数为3个，这时不能再减少了；旧=1，新=2，总=3；</p>
<p>5、再新增一个新版本的pod，此时pod总数为4个，不能再新增了；旧=1，新=3，总=4；</p>
<p>6、减少一个旧版本的pod，此时pod总数为3个，更新完成，pod都是新版本了；旧=0，新=3，总=3；</p>
<h3 id="44-deployment的回滚使用什么命令"><a href="#44-deployment的回滚使用什么命令" class="headerlink" title="44 deployment的回滚使用什么命令"></a>44 deployment的回滚使用什么命令</h3><p>在升级deployment时kubectl set image 命令加上 —record 参数可以记录具体的升级历史信息，使用<code>kubectl rollout history deployment/deployment-nginx</code>命令来查看指定的deployment升级历史记录，如果需要回滚到某个指定的版本，可以使用<code>kubectl rollout undo deployment/deployment-nginx --to-revision=2</code>命令来实现。</p>
<h3 id="45-讲一下都有哪些存储卷，作用分别是什么"><a href="#45-讲一下都有哪些存储卷，作用分别是什么" class="headerlink" title="45 讲一下都有哪些存储卷，作用分别是什么?"></a>45 讲一下都有哪些存储卷，作用分别是什么?</h3><div class="table-container">
<table>
<thead>
<tr>
<th>卷</th>
<th>作用</th>
<th>常用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>emptyDir</td>
<td>用于存储临时数据的简单空目录</td>
<td>一个pod中的多个容器需要共享彼此的数据 ，emptyDir的数据随着容器的消亡也会销毁</td>
</tr>
<tr>
<td>hostPath</td>
<td>用于将目录从工作节点的文件系统挂载到pod中</td>
<td>不常用，缺点是，pod的调度不是固定的，也就是当pod消失后deployment重新创建一个pod，而这pod如果不是被调度到之前pod的节点，那么该pod就不能访问之前的数据</td>
</tr>
<tr>
<td>configMap</td>
<td>用于将非敏感的数据保存到键值对中，使用时可以使用作为环境变量、命令行参数arg，存储卷被pods挂载使用</td>
<td>将应用程序的不敏感配置文件创建为configmap卷，在pod中挂载configmap卷，可是实现热更新</td>
</tr>
<tr>
<td>secret</td>
<td>主要用于存储和管理一些敏感数据，然后通过在 Pod 的容器里挂载 Volume 的方式或者环境变量的方式访问到这些 Secret 里保存的信息了，pod会自动解密Secret 的信息</td>
<td>将应用程序的账号密码等敏感信息通过secret卷的形式挂载到pod中使用</td>
</tr>
<tr>
<td>downwardApi</td>
<td>主要用于暴露pod元数据，如pod的名字</td>
<td>pod中的应用程序需要指定pod的name等元数据，就可以通过downwardApi 卷的形式挂载给pod使用</td>
</tr>
<tr>
<td>projected</td>
<td>这是一种特殊的卷，用于将上面这些卷一次性的挂载给pod使用</td>
<td>将上面这些卷一次性的挂载给pod使用</td>
</tr>
<tr>
<td>pvc</td>
<td>pvc是存储卷声明</td>
<td>通常会创建pvc表示对存储的申请，然后在pod中使用pvc</td>
</tr>
<tr>
<td>网络存储卷</td>
<td>pod挂载网络存储卷，这样就能将数据持久化到后端的存储里</td>
<td>常见的网络存储卷有nfs存储、glusterfs 卷、ceph rbd存储卷</td>
</tr>
</tbody>
</table>
</div>
<p><strong>pv的访问模式有哪几种</strong></p>
<ul>
<li><code>ReadWriteOnce</code>，简写：RWO 表示，只仅允许单个节点以读写方式挂载；</li>
<li><code>ReadOnlyMany</code>，简写：ROX 表示，可以被许多节点以只读方式挂载；</li>
<li><code>ReadWriteMany</code>，简写：RWX 表示，可以被多个节点以读写方式挂载；</li>
</ul>
<h3 id="46-pv的回收策略有哪几种"><a href="#46-pv的回收策略有哪几种" class="headerlink" title="46 pv的回收策略有哪几种"></a>46 pv的回收策略有哪几种</h3><p>主要有3中回收策略：Retain 、Delete、Recycle。</p>
<ul>
<li>Retain：保留，该策略允许手动回收资源，当删除PVC时，PV仍然存在，PV被视为已释放，管理员可以手动回收卷。</li>
<li>Delete：删除，如果Volume插件支持，删除PVC时会同时删除PV，动态卷默认为Delete，目前支持Delete的存储后端包括AWS EBS，GCE PD，Azure Disk，OpenStack Cinder等。</li>
<li>Recycle：回收，如果Volume插件支持，Recycle策略会对卷执行<code>rm -rf</code>清理该PV，并使其可用于下一个新的PVC，但是本策略将来会被弃用，目前只有NFS和HostPath支持该策略。（这种策略已经被废弃，不用记）</li>
</ul>
<h3 id="47-在pv的生命周期中，一般有几种状态"><a href="#47-在pv的生命周期中，一般有几种状态" class="headerlink" title="47 在pv的生命周期中，一般有几种状态"></a>47 在pv的生命周期中，一般有几种状态</h3><p>创建pv后，pv的的状态有以下4种：</p>
<ul>
<li><code>Available</code>，表示pv已经创建正常，处于可用状态；</li>
<li><code>Bound</code>，表示pv已经被某个pvc绑定，注意，一个pv一旦被某个pvc绑定，那么该pvc就独占该pv，其他pvc不能再与该pv绑定；</li>
<li><code>Released</code>，表示pvc被删除了，pv状态就会变成已释放；</li>
<li><code>Failed</code>，表示pv的自动回收失败；</li>
</ul>
<h3 id="48-存储类的资源回收策略"><a href="#48-存储类的资源回收策略" class="headerlink" title="48 存储类的资源回收策略:"></a>48 存储类的资源回收策略:</h3><p>主要有2中回收策略，Delete 、Retain。默认就是Delete策略</p>
<ul>
<li>Retain：保留，该策略允许手动回收资源，当删除PVC时，PV仍然存在，PV被视为已释放，管理员可以手动回收卷。</li>
<li>Delete：删除，如果Volume插件支持，删除PVC时会同时删除PV，动态卷默认为Delete，目前支持Delete的存储后端包括AWS EBS，GCE PD，Azure Disk，OpenStack Cinder等。</li>
</ul>
<p>注意：使用存储类动态创建的pv默认继承存储类的回收策略，当然当pv创建后你也可以手动修改pv的回收策略。</p>
<h3 id="49-pv存储空间不足怎么扩容"><a href="#49-pv存储空间不足怎么扩容" class="headerlink" title="49 pv存储空间不足怎么扩容?"></a>49 pv存储空间不足怎么扩容?</h3><p>一般的，我们会使用动态分配存储资源，在创建<code>storageclass</code>时指定参数 <code>allowVolumeExpansion：true</code>，表示允许用户通过修改pvc申请的存储空间自动完成pv的扩容，当增大pvc的存储空间时，不会重新创建一个pv，而是扩容其绑定的后端pv。这样就能完成扩容了。但是<code>allowVolumeExpansion</code>这个特性只支持扩容空间不支持减少空间。</p>

    
  </div>

  
  <!-- Post Copyright -->

<div class="post-copyright">
  <p class="copyright-item">
    <span>Author: </span>
    <a href="https://stardustorz.github.io">draco</a>
  </p>
  <p class="copyright-item">
    <span>Link: </span>
    <a href="https://stardustorz.github.io/2023/10/09/DevOps/Docker%E4%B8%8E%20K8S/">https://stardustorz.github.io/2023/10/09/DevOps/Docker%E4%B8%8E%20K8S/</a>
  </p>
  <p class="copyright-item">
    <span>License: </span>
    
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
  </p>
</div>

    

  

  
  <footer class="post-footer">
    
      
  <nav class="post-nav">  
      
      <a class="prev" href="/2023/10/09/System-Design/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text nav-default"></span>  
        <span class="prev-text nav-mobile">Prev</span>  
      </a>  
      
      
      <a class="next" href="/2023/09/11/System-Design/Raft/">  
        <span class="next-text nav-default"></span>  
        <span class="prev-text nav-mobile">Next</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  </footer>
  

</article>
        </div>
      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2019 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">draco</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
  







<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>



<script type="text/javascript" src="/lib/slideout/slideout.js"></script>



<script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>