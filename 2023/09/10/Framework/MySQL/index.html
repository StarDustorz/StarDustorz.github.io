<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Website mata -->
<meta charset="UTF-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<!-- Disable transformation -->
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<!-- Website description -->


<!-- Website keywords -->




<!-- Website rss -->

<link rel="alternate" href="/atom.xml" title="Draco's Blog" type="application/atom+xml">


<!-- Website favicon -->

<link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=3.0.0" />


<!-- Canonical, good for google search engine -->
<link rel="canonical" href="https://stardustorz.github.io/2023/09/10/Framework/MySQL/" />

<!-- Fancybox styling -->

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />


<!-- MathJax (LaTeX) support -->


<!-- Theme styling -->
<link rel="stylesheet" type="text/css" href="/css/style.css?v=3.0.0" />

<!-- Analytics and push -->



  



<!-- LeanCloud Counter -->


<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null,"server_url":null,"cdn":null},"toc":true,"fancybox":true,"latex":false};
</script>
  
  <title> - Draco&#39;s Blog</title>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div class="scrollPercentage"></div>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">Draco&#39;s Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
    <a href="/">
      <li class="mobile-menu-item">
        
        
        Home              </li>
    </a>
    
    <a href="/archives/">
      <li class="mobile-menu-item">
        
        
        Archives              </li>
    </a>
    
    <a href="/tags/">
      <li class="mobile-menu-item">
        
        
        Tags              </li>
    </a>
    
    <a href="/categories/">
      <li class="mobile-menu-item">
        
        
        Categories              </li>
    </a>
    
    <a href="/links/">
      <li class="mobile-menu-item">
        
        
        Links              </li>
    </a>
    
    <a href="/about/">
      <li class="mobile-menu-item">
        
        
        About              </li>
    </a>
    
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
      <div class="logo-wrapper">  
  <a href="/." class="logo">Draco's Blog</a>  
</div>  
  
<nav class="site-navbar">  
    
    <ul id="menu" class="menu">  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/">  
              
              
              Home  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/archives/">  
              
              
              Archives  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/tags/">  
              
              
              Tags  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/categories/">  
              
              
              Categories  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/links/">  
              
              
              Links  
              
          </a>  
        </li>  
        
        <li class="menu-item">  
          <a class="menu-item-link" href="/about/">  
              
              
              About  
              
          </a>  
        </li>  
        
    </ul>  
    
</nav>  

    </header>
    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
  <header class="post-header">
    <h1 class="post-title">
      
      
      
    </h1>

    <div class="post-meta">
      <span class="post-time">
        2023-09-10
      </span>
      
      
      
    </div>
  </header>

  
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">1. 架构与简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-MySQL-%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">1 MySQL 架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-SQL-%E8%AF%AD%E5%8F%A5%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">2 SQL 语句执行过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%B0%E5%BD%95%E5%AD%98%E5%82%A8"><span class="toc-number">1.3.</span> <span class="toc-text">3 记录存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%B4%A2%E5%BC%95"><span class="toc-number">2.</span> <span class="toc-text">2. 索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B%E4%B8%8E-B-%E6%A0%91"><span class="toc-number">2.1.</span> <span class="toc-text">1 索引简介与 B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 什么是索引？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-B-%E6%A0%91"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 B+树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%B4%A2%E5%BC%95%E5%88%86%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">2 索引分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96"><span class="toc-number">2.3.</span> <span class="toc-text">3 索引优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">2.4.</span> <span class="toc-text">4 索引失效</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BA%8B%E5%8A%A1"><span class="toc-number">3.</span> <span class="toc-text">3 事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7-ACID"><span class="toc-number">3.1.</span> <span class="toc-text">1 事务的特性 ACID</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B9%B6%E8%A1%8C%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.</span> <span class="toc-text">2 并行事务的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">3.3.</span> <span class="toc-text">3 事务的隔离级别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-MVCC-%E4%B8%8E-ReadView"><span class="toc-number">3.4.</span> <span class="toc-text">4 MVCC 与 ReadView</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E9%94%81"><span class="toc-number">4.</span> <span class="toc-text">4. 锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-MySQL-%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81%EF%BC%9F"><span class="toc-number">4.1.</span> <span class="toc-text">1 MySQL 有哪些锁？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.1 全局锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-number">4.1.2.</span> <span class="toc-text">1.2 表级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">4.1.3.</span> <span class="toc-text">1.3 行级锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E6%AD%BB%E9%94%81"><span class="toc-number">4.1.4.</span> <span class="toc-text">1.4 死锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%97%A5%E5%BF%97"><span class="toc-number">5.</span> <span class="toc-text">5. 日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-undo-log%EF%BC%88%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%EF%BC%89"><span class="toc-number">5.1.</span> <span class="toc-text">1 undo log（回滚日志）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Buffer-Pool-%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="toc-number">5.2.</span> <span class="toc-text">2 Buffer Pool  缓冲池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-redo-log%EF%BC%88%E7%89%A9%E7%90%86%E6%97%A5%E5%BF%97%EF%BC%89"><span class="toc-number">5.3.</span> <span class="toc-text">3 redo log（物理日志）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-bin-log"><span class="toc-number">5.4.</span> <span class="toc-text">4 bin log</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%9E%B6%E6%9E%84%E4%B8%8E-SQL-%E5%9F%BA%E7%A1%80"><span class="toc-number">6.</span> <span class="toc-text">6. 架构与 SQL 基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-SQL-%E5%9F%BA%E7%A1%80"><span class="toc-number">6.1.</span> <span class="toc-text">1 SQL 基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9E%B6%E6%9E%84"><span class="toc-number">6.2.</span> <span class="toc-text">2 架构</span></a></li></ol></li></ol>
    </div>
  </div>
  

  <div class="post-content">
    
    <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1-架构与简介"><a href="#1-架构与简介" class="headerlink" title="1. 架构与简介"></a>1. 架构与简介</h2><h3 id="1-MySQL-架构"><a href="#1-MySQL-架构" class="headerlink" title="1 MySQL 架构"></a>1 MySQL 架构</h3><ul>
<li><em>Server 层</em>：建立连接、分析和执行 SQL；主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</li>
<li><em>存储引擎层</em>：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></li>
</ul>
<h3 id="2-SQL-语句执行过程"><a href="#2-SQL-语句执行过程" class="headerlink" title="2 SQL 语句执行过程"></a>2 SQL 语句执行过程</h3><blockquote>
<p>MySQL 执行一条 select 查询语句，在 MySQL 中期间发生了什么？</p>
<ul>
<li><em>连接器</em>：TCP 三次握手连接</li>
<li><em>查询缓存</em>：先去查询缓存（ Query Cache ）里查找缓存数据</li>
<li><em>解析 SQL</em>：解析器进行词法分析和语法分析</li>
<li><em>执行 SQL</em>：<ul>
<li><code>预处理器</code>：查询表和字段是否存在</li>
<li><code>优化器</code>：确定 SQL 语句执行方案，选择最高效的索引<ul>
<li>explain：select_type 查询类型； type 连接方式；key 用到的索引；rows 扫描出的行数</li>
</ul>
</li>
<li><code>执行器</code>：<ul>
<li>主键索引查询：选择符合的记录</li>
<li>全表扫描</li>
<li><strong><em>索引下推</em></strong>：<code>减少二级索引在查询时的回表操作</code>，将查询条件下推到存储引擎层面进行判断，而不是将数据加载到内存中由应用层进行过滤</li>
<li>exp： <code>where age &gt; 20 and reward = 100000</code>, 其中 age 可以用到联合索引，通过下推后，直接在存储引擎中过滤出<code>reward = 100000</code>的记录再去回表；<h3 id="3-记录存储"><a href="#3-记录存储" class="headerlink" title="3 记录存储"></a>3 记录存储</h3></li>
</ul>
</li>
</ul>
</li>
<li>数据存放：表结构（t_order.frm），表数据（t_order.ibd）</li>
<li>表空间文件结构：段（segment）、区（extent）、页（page，16KB）、行（row）</li>
<li><code>null 存储</code>：Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分</li>
<li>页的大小和结构： 16KB 文件头 页头 最小和最大记录 用户记录 空闲空间 页目录 文件尾</li>
<li>innodb的行格式：<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png" alt=""><pre><code>  1. 变长字段的真实数据占用的字节数会按照列的顺序**逆序存放**    **使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率**。
  2. trx_id   事务id；roll_pointer  记录上一个版本的指针
</code></pre></li>
</ul>
</blockquote>
<h2 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h2><h3 id="1-索引简介与-B-树"><a href="#1-索引简介与-B-树" class="headerlink" title="1 索引简介与 B+树"></a>1 索引简介与 B+树</h3><h4 id="1-1-什么是索引？"><a href="#1-1-什么是索引？" class="headerlink" title="1.1 什么是索引？"></a>1.1 什么是索引？</h4><ul>
<li>帮助存储引擎快速获取数据的一种数据结构</li>
<li>缺点：本身会占据物理空间；创建索引和维护索引要耗费时间；降低表的增删改的效率</li>
<li>使用场合：字段有唯一性限制，表数据多，更新不频繁<h4 id="1-2-B-树"><a href="#1-2-B-树" class="headerlink" title="1.2 B+树"></a>1.2 B+树</h4><blockquote>
<p>主键索引和二级索引默认使用的是 B+Tree 索引</p>
</blockquote>
</li>
<li><em>什么是 B+树？</em><ul>
<li>B 树：多叉树，左小右大，每个节点都包含索引和数据</li>
<li><em>B+树</em>:就是 B 树的升级<ul>
<li>叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引</li>
<li>所有索引都会在叶子节点出现，叶子节点之间构成一个<code>有序链表</code></li>
<li>非叶子节点中有多少个子节点，就有多少个索引</li>
<li>B+ 树点节点内容是数据页，数据页里存放了用户的记录以及各种信息，每个数据页默认大小是 16 KB</li>
</ul>
</li>
</ul>
</li>
<li><em>B+树优点</em>：<ul>
<li>B+树的非叶子节点可以存放更多的索引，出度更大</li>
<li>范围查询效率更高</li>
</ul>
</li>
<li>单表最大值：一般三层就可以存放两千万行数据，超过可能增加层级；内存放不下索引<h3 id="2-索引分类"><a href="#2-索引分类" class="headerlink" title="2 索引分类"></a>2 索引分类</h3></li>
<li>按数据结构： B+Tree 索引、HASH 索引、Full-Text 索引</li>
<li>按物理存储： <strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong> 叶子节点存放的是主键值，还要回表</li>
<li>按字段特性： <strong>主键索引、唯一索引、普通索引、前缀索引</strong></li>
<li>按字段个数： <strong>单列索引、联合索引</strong>   <ul>
<li>最左匹配原则：按照最左优先的方式进行索引的匹配</li>
<li>exp：（a，b，c）的索引会先按 a 排序，在 a 相同的情况下按 b 排序，再按 c 排序，因此<code>b 和 c 是全局无序，局部相对有序的</code>，所以 <code>where b=2 and c=3；</code> 无法利用索引</li>
<li>where a &gt; 1 and b = 2  只有 a 能利用联合索引<h3 id="3-索引优化"><a href="#3-索引优化" class="headerlink" title="3 索引优化"></a>3 索引优化</h3></li>
</ul>
</li>
</ul>
<ol>
<li><code>前缀索引</code>优化： 可以减小索引项的大小，但是不能成为覆盖索引</li>
<li><code>覆盖索引</code>优化： 直接从二级索引获取数据，避免回表</li>
<li>主键索引<code>自增</code>：插入效率高；避免造成页分裂；主键字段的长度不要太大，减小二级索引规模</li>
<li>索引设置 NOT NULL：方便优化器选择<h3 id="4-索引失效"><a href="#4-索引失效" class="headerlink" title="4 索引失效"></a>4 索引失效</h3></li>
</ol>
<ul>
<li>使用左或者左右模糊匹配，like %xx</li>
<li>在查询条件中对索引列做了计算、函数、类型转换操作</li>
<li>联合索引未遵循最左匹配原则</li>
<li>WHERE 子句中， OR 前的条件列是索引列， OR 后不是，那么索引会失效<h2 id="3-事务"><a href="#3-事务" class="headerlink" title="3 事务"></a>3 事务</h2><h3 id="1-事务的特性-ACID"><a href="#1-事务的特性-ACID" class="headerlink" title="1 事务的特性 ACID"></a>1 事务的特性 ACID</h3></li>
<li><em><strong>原子性（Atomicity）</strong></em>：一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态； <code>由 undo log（回滚日志保证）</code></li>
<li><em><strong>一致性（Consistency）</strong></em>：是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态  <code>由持久性+原子性+隔离性 共同保证</code></li>
<li><em><strong>隔离性（Isolation）</strong></em>：防止多个事务并发执行时由于交叉执行而导致数据的不一致   <code>MVCC（多版本并发控制） 或锁机制</code></li>
<li><em><strong>持久性（Durability）</strong></em>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。     <code>redo log （重做日志）</code><h3 id="2-并行事务的问题"><a href="#2-并行事务的问题" class="headerlink" title="2 并行事务的问题"></a>2 并行事务的问题</h3></li>
<li><strong>脏读</strong>： 一个事务「读到」了另一个「<strong>未提交事务修改过的数据</strong>」</li>
<li><strong>不可重复读</strong>：在一个事务内多次读取同一个数据，前后两次读到的<strong>数据</strong>不一样</li>
<li><strong>幻读</strong>：在一个事务内多次查询某个符合查询条件的「记录数量」，前后两次查询到的<strong>记录数量</strong>不一样<h3 id="3-事务的隔离级别"><a href="#3-事务的隔离级别" class="headerlink" title="3 事务的隔离级别"></a>3 事务的隔离级别</h3></li>
<li><strong>读未提交（<em>read uncommitted</em>）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到； <strong>会脏读</strong></li>
<li><strong>读提交（<em>read committed</em>）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到； <strong>会不可重复读</strong></li>
<li><strong>可重复读（<em>repeatable read</em>）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>； <strong>会幻读</strong></li>
<li><strong>串行化（<em>serializable</em> ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；  都不会，但是影响性能</li>
<li><em>默认的隔离级别</em>：可重复读，用以下方法解决幻读<ul>
<li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong></li>
<li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong></li>
</ul>
</li>
<li>幻读完全解决了吗？ 没有<ol>
<li>对于快照读，当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，就会产生幻读</li>
<li>对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。</li>
<li>在开启事务之后，马上执行 select … for update 这类当前读的语句</li>
</ol>
</li>
</ul>
<h3 id="4-MVCC-与-ReadView"><a href="#4-MVCC-与-ReadView" class="headerlink" title="4 MVCC 与 ReadView"></a>4 MVCC 与 ReadView</h3><ul>
<li><em>MVCC 原理</em>？<ul>
<li>Multi-Version Concurrency Control 多版本并发控制</li>
<li>核心思想是为每个事务创建一个独立的数据库快照，每个事务在操作时都会基于事务 ID 来访问数据库的对应版本</li>
</ul>
</li>
<li><em>ReadView 的数据结构</em>？  四个字段和聚簇索引记录中的两个隐藏列<ul>
<li><code>m_ids</code> ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li>
<li><code>min_trx_id</code> ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</li>
<li><code>max_trx_id</code> ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</li>
<li><code>creator_trx_id</code> ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</li>
<li><code>trx_id</code>，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li>
<li><code>roll_pointer</code>，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li>
</ul>
</li>
<li><em>可重复读实现</em>？<ul>
<li>启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</li>
</ul>
</li>
<li><em>读提交实现</em>？<ul>
<li>在每次读取数据时，都会生成一个新的 Read View</li>
</ul>
</li>
</ul>
<h2 id="4-锁"><a href="#4-锁" class="headerlink" title="4. 锁"></a>4. 锁</h2><h3 id="1-MySQL-有哪些锁？"><a href="#1-MySQL-有哪些锁？" class="headerlink" title="1 MySQL 有哪些锁？"></a>1 MySQL 有哪些锁？</h3><h4 id="1-1-全局锁"><a href="#1-1-全局锁" class="headerlink" title="1.1 全局锁"></a>1.1 全局锁</h4><ul>
<li><em>启用</em>：flush tables with read lock    数据库处于只读状态</li>
<li><em>使用场景</em>：全库备份</li>
<li>如果数据库的引擎支持的事务支持<strong>可重复读的隔离级别</strong>，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作<h4 id="1-2-表级锁"><a href="#1-2-表级锁" class="headerlink" title="1.2 表级锁"></a>1.2 表级锁</h4></li>
<li><em>表锁</em>：颗粒度太大，性能较差</li>
<li><em>元数据锁</em>：防止其他线程变更表结构</li>
<li><em>意向锁</em>：<strong>快速判断表里是否有记录被加锁</strong><ul>
<li>当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁</li>
</ul>
</li>
<li><em>AUTO-INC 锁</em>：实现主键自增<ul>
<li>在插入数据时，会加一个表级别的 AUTO-INC 锁，插入语句完成后就释放<h4 id="1-3-行级锁"><a href="#1-3-行级锁" class="headerlink" title="1.3 行级锁"></a>1.3 行级锁</h4></li>
</ul>
</li>
<li><em>Record Lock</em>：记录锁，锁住一条记录；只有 S 型记录锁兼容</li>
<li><em>Gap Lock</em>：间隙锁，解决可重复读隔离级别下的幻读现象； 如（3，5）会锁住 4</li>
<li><em>Next-Key Lock</em>：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身；（3，5] 锁住 4，5</li>
<li><em>插入意向锁</em>：插入有间隙锁位置会发生<strong>阻塞</strong>，生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态</li>
<li>Innodb 在扫描记录的时，都是针对索引项这个单位去加锁的， update 不带索引就是全表扫描，也就是表里的索引项都加锁，相当于锁了整张表<h4 id="1-4-死锁"><a href="#1-4-死锁" class="headerlink" title="1.4 死锁"></a>1.4 死锁</h4></li>
<li>两个事务即使生成的间隙锁的范围是一样的，也不会发生冲突，因为间隙锁目的是为了防止其他事务插入数据，因此间隙锁与间隙锁之间是相互兼容的。</li>
<li>在执行插入语句时，如果插入的记录在其他事务持有间隙锁范围内，插入语句就会被阻塞，因为插入语句在碰到间隙锁时，会生成一个插入意向锁，然后插入意向锁和间隙锁之间是互斥的关系。</li>
<li>如果两个事务分别向对方持有的间隙锁范围内插入一条记录，而插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，满足了死锁的四个条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>，因此发生了死锁</li>
<li>事务 A 和事务 B 在执行完后 update 语句后都持有范围为<code>(20, 30）</code>的间隙锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待</li>
</ul>
<h2 id="5-日志"><a href="#5-日志" class="headerlink" title="5. 日志"></a>5. 日志</h2><h3 id="1-undo-log（回滚日志）"><a href="#1-undo-log（回滚日志）" class="headerlink" title="1 undo log（回滚日志）"></a>1 undo log（回滚日志）</h3><ul>
<li>innodb 存储引擎层生成的日志，实现了事务中的 <em><strong>原子性</strong></em> ，主要用于事务回滚和 MVCC</li>
<li>当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里</li>
<li>在<code>事务没提交之前</code>，MySQL 会先记录更新前的数据到 undo log 日志文件里面</li>
<li><em>ReadView + undo log 实现 MVCC</em>：undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的<code>版本链</code>找到满足其<code>可见性</code>的记录</li>
<li>持久化：buffer pool 中有 undo 页，对 undo 页的修改也都会记录到<code>redo log</code>，redo log 会每秒刷盘，提交事务时也会刷盘<h3 id="2-Buffer-Pool-缓冲池"><a href="#2-Buffer-Pool-缓冲池" class="headerlink" title="2 Buffer Pool  缓冲池"></a>2 Buffer Pool  缓冲池</h3></li>
<li><em>基于内存，提高数据库的读写性能</em></li>
<li><em>Buffer Pool 缓存什么</em>：「索引页」和「数据页」，还包括了 Undo 页，插入缓存、自适应哈希索引、锁信息等</li>
<li>修改记录先缓存 到 change buffer，找机会去写入磁盘<pre><code>  1. 唯一索引不会用 change buffer，因为对应数据页已经加载到内存了--判断唯一性
  2. 优点：减少磁盘访问次数；提高内存利用率
</code></pre></li>
<li><strong>缓页管理方式</strong><pre><code>  1. Free List （空闲页链表），管理空闲页；
  2. Flush List （脏页链表），管理脏页；
  3. LRU List，管理脏页+干净页，将最近且经常查询的数据缓存在其中，而不常查询的数据就淘汰出去；分为 young 和 old 两个区域，先插入 old，被访问进入 young，解决数据批量访问，和大量热数据淘汰的问题；
</code></pre><h3 id="3-redo-log（物理日志）"><a href="#3-redo-log（物理日志）" class="headerlink" title="3 redo log（物理日志）"></a>3 redo log（物理日志）</h3></li>
<li>作用：记录了某个数据页做了什么修改，在事务提交时，只要先将 redo log 持久化到磁盘即可；记录了事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值</li>
<li><strong><em>预写日志WAL</em></strong>：写操作并不是立刻写到磁盘上，而是先写日志，后面再等待时机写入磁盘</li>
<li><strong><em>crash-safe</em></strong>（崩溃恢复）：即使数据库发生异常重启，之前已提交的记录都不会丢失，保证了持久性</li>
<li><strong>优点</strong>：redo log 是追加操作，所以是顺序写，开销更小</li>
<li><strong>刷盘时机</strong>： 事务提交；每秒；关闭数据库； redo log buffer占用过半</li>
<li>redo log满了？阻塞，刷新脏页到磁盘，擦除 对应的 redo log 记录腾出空间</li>
</ul>
<h3 id="4-bin-log"><a href="#4-bin-log" class="headerlink" title="4 bin log"></a>4 bin log</h3><ul>
<li>undo 和 redo 都是Innodb 存储引擎生成的，binlog 是 Server 层生成的</li>
<li>使用对象：Server 层实现的日志，所有存储引擎都可以使用</li>
<li>文件格式： STATEMENT（默认格式，记录 SQL）、ROW（记录行数据）、 MIXED</li>
<li>写入方式：追加写，会覆盖以前的日志，保存的是全量的日志。</li>
<li>作用：用于<strong>主从复制，备份恢复</strong></li>
<li>binlog cache刷盘：事务提交，内存超了</li>
<li><strong><em>主从复制实现</em></strong><ol>
<li><em>主从复制流程</em><ol>
<li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</li>
<li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</li>
<li><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。</li>
</ol>
</li>
<li><em>复制步骤</em><ol>
<li>主节点log dump线程：当从节点连接主节点时，主节点会创建一个log dump 线程，用于发送bin-log的内容。在读取bin-log中的操作时，此线程会对主节点上的bin-log加锁，当读取完成，甚至在发动给从节点之前，锁会被释放。</li>
<li>从节点I/O线程：当从节点上执行<code>start slave</code>命令之后，从节点会创建一个I/O线程用来连接主节点，请求主库中更新的bin-log。I/O线程接收到主节点bin log dump 进程发来的更新之后，保存在本地relay-log中。</li>
<li>从节点SQL线程：SQL线程负责读取relay log中的内容，解析成具体的操作并执行，最终保证主从数据的一致性。</li>
</ol>
</li>
<li><em>复制模型</em><ol>
<li>同步复制：性能差</li>
<li>异步复制：主库宕机数据会丢失</li>
<li>半同步复制：从库成功一个就行</li>
</ol>
</li>
<li><em>主从同步延迟</em><ol>
<li>从库只有一个sql Thread，主库写压力大，复制很可能延时；或者从库有大型 query 产生锁等待</li>
<li>解决：要求高就走主库；sleep 一下；判断一下主备延迟</li>
</ol>
</li>
</ol>
</li>
<li><strong><em>两阶段提交</em></strong>    防止<strong>redo log</strong>和<strong>binlog</strong>不一致，导致主从数据不一致；内部 XA 事务<ol>
<li><strong><em>prepare</em> 阶段</strong>：将 redo log 对应的事务状态设置为 prepare，然后将 redo log 刷新到硬盘；</li>
<li><strong><em>commit 阶段</em></strong>：将 binlog 刷新到磁盘，接着调用引擎的提交事务接口，将 redo log 状态设置为 commit（将事务设置为 commit 状态后，刷入到磁盘 redo log 文件）；</li>
<li><strong>是否能在 binlog 中查找到与 redo log 相同的 XID</strong>，如果有就提交事务，如果没有就回滚事务。</li>
<li>组提交：<strong>有多个事务提交的时候，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I/O 的次数</strong></li>
<li>问题：磁盘 IO 次数高，锁竞争激烈</li>
</ol>
</li>
</ul>
<h2 id="6-架构与-SQL-基础"><a href="#6-架构与-SQL-基础" class="headerlink" title="6. 架构与 SQL 基础"></a>6. 架构与 SQL 基础</h2><h3 id="1-SQL-基础"><a href="#1-SQL-基础" class="headerlink" title="1 SQL 基础"></a>1 SQL 基础</h3><ol>
<li><em>数据库四大范式</em><ol>
<li>第一范式（1NF）：属性不可拆分 或 无重复的列</li>
<li>第二范式（2NF）：非主属性对多属性候选键完全函数依赖</li>
<li>第三范式（3NF）：消除传递依赖  表中不包含已在其它表中已包含的非主属性信息。</li>
<li>BC范式（BCNF）：候选键存在多个属性时，多个主属性直接要消除传递依赖关系     主属性之间不应该有互相依赖。工号和身份证号是相互依赖。</li>
<li>第四范式（4NF）：对于候选键只能存在不超过1个多值属性。要求把同一表内的多对多关系删除。</li>
</ol>
</li>
<li><em>分页查询后期性能变慢的原因</em>    深分页问题<ol>
<li><strong>limit m n</strong>：查询从 m 开始的 n 条数据；扫 m+n 行 丢弃前 m 行</li>
<li><strong>limit n offset m</strong>：从 m 开始的 n 条</li>
<li><code>为什么慢</code>？ <ol>
<li>分页偏移量的增加，需要扫描和跳过的前面的行来到达指定的偏移量，造成浪费，也就是说<code>limit 100000,10</code>，就会扫描100010行</li>
<li><code>limit 100000,10</code> 扫描更多的行数，也意味着回表判断的次数更多</li>
</ol>
</li>
<li>优化：<ol>
<li>子查询优化：把条件转移到主键索引树，然后减少回表，比如先查到第 10000 个</li>
<li>INNER JOIN 延迟关联：先通过二级索引树查询到满足条件的主键ID，再与原表通过主键ID内连接</li>
<li>基于游标的分页：使用游标或主键来定位结果集中的特定行，而不是使用偏移量。这种方法通常比OFFSET更高效</li>
<li>使用between…and…：转换成已知位置的查询</li>
<li>使用合适的索引：确保查询中使用了适当的索引，以减少排序和过滤操作的成本</li>
</ol>
</li>
</ol>
</li>
<li>SQL(聚集函数，group by， having 子句， order by, 连接(内连接、外连接(左右)))<ol>
<li><strong>group by</strong>： 根据一个或多个列对结果集进行分组</li>
<li><strong>having</strong>：筛选分组后的各组数据    where在group by前， having在group by 之后</li>
<li><strong>order by</strong>：排序  desc 降序； asc 升序</li>
<li>连接：<ol>
<li>inner join：  只取交集</li>
<li>left join：左表所有行和右表匹配的，不匹配的行返回 null</li>
<li>right join：和上面类似</li>
<li>full join：全连接，取并集</li>
</ol>
</li>
</ol>
</li>
<li>慢查询日志<ol>
<li>set global slow_query_log = on;  long_query_time</li>
<li>mysqldumpslow进行分析<h3 id="2-架构"><a href="#2-架构" class="headerlink" title="2 架构"></a>2 架构</h3></li>
</ol>
</li>
<li>MySQL集群的结构有哪些？各自优缺点？<ol>
<li>主从架构  读写分离，数据备份</li>
<li>主主互备  </li>
</ol>
</li>
<li>分库分表的场景？   数据库性能瓶颈  <strong>IO瓶颈</strong>   <strong>CPU瓶颈</strong><ol>
<li>水平分库： 按 hash 或者 range 策略分到多个库里； 应对高并发</li>
<li>水平分表：将一个表中的数据拆分到多个表中；单表数据太多，影响 SQL 效率；</li>
<li>垂直分库：按业务归属不同分库；可以抽象出单独的业务模块</li>
<li>垂直分表：按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中。  字段多，热点数据分离出来；不可用 join</li>
<li>分配策略： hash 取模；范围分片；地理位置；时间</li>
</ol>
</li>
<li>如何不停服迁移库表？<ol>
<li><strong>不停服，增加缓冲层（MQ），数据迁移过程中增量数据写入缓存，在数据迁移完成、缓冲层数据消费完成后，打开开关开始双写数据库</strong></li>
</ol>
</li>
<li>怎么分库分表才能均匀？分库分表后某些分片热点写入怎么解决？<ol>
<li>使用哈希算法：对于分片键（通常是某个列或多个列的组合），使用哈希算法来决定数据应该存储在哪个分片上。这样可以确保数据在分片之间均匀分布，减少热点问题。</li>
<li>增加分片数量：**如果你发现某些分片写入热点问题，可以考虑增加分片的数量。这会增加分片的数量，减少每个分片的负载，提高了吞吐量。</li>
<li>负载均衡：使用负载均衡策略来确保访问请求均匀地分布到不同的分片上。负载均衡可以在应用层或数据库代理层实现。</li>
<li>随机数分片：使用随机数来分配数据到分片，这可以减少数据的热点写入问题，但可能增加查询的复杂性。</li>
<li>分片键设计：精心设计分片键是解决热点写入问题的关键。尽量避免选择容易导致热点的分片键，例如自增主键。</li>
<li>数据迁移：定期监测数据分布，如果发现某个分片过于热点，可以考虑进行数据迁移，将一些数据从热点分片移到其他分片上，以实现负载均衡。</li>
<li>垂直分片：考虑将表按照功能或业务需求进行垂直分片，将不同类型的数据存储在不同的分片上。这可以减少写入热点问题。</li>
<li>缓存：使用缓存来缓解数据库写入压力。将热点数据缓存到内存中，减少对数据库的频繁写入请求。</li>
<li>异步写入：如果一些写入操作不需要立即生效，可以考虑将它们异步化，以减轻数据库的写入负载。例如，使用消息队列将写入操作异步处理。</li>
</ol>
</li>
<li>数据库主库挂了，在存在主从延时的情况下，切从的过程中，查询的数据不一致怎么处理<ol>
<li><strong>等待同步完成</strong>：在进行主从切换前，可以等待从库追赶主库的进度，确保从库的数据已经和主库同步完全。这可以通过监测主从延时来确定。一旦主从延时减少到可以接受的水平，再进行切换。</li>
<li><strong>切换到可用从库</strong>：如果主从切换后发现某个从库数据不一致，可以尝试切换到另一个可用的从库。这需要确保备用从库与主库的数据同步是正常的。</li>
<li><strong>手动同步数据</strong>：在切换完成后，可以考虑手动同步数据以修复不一致。这可能涉及将缺失的数据从主库手动导入到从库，以确保一致性。</li>
<li><strong>数据一致性检查</strong>：在切换后，可以运行一些数据一致性检查工具或脚本来检查数据是否一致。如果发现不一致的数据，可以进行修复。</li>
<li><strong>定期备份</strong>：在数据库正常运行期间，定期进行数据库备份，包括主库和从库。在切换后，如果出现数据不一致问题，可以使用备份进行恢复。</li>
<li><strong>容错和监控</strong>：实现主从切换时，确保有足够的监控和容错机制。这样，如果出现问题，可以迅速发现并采取措施来减小数据不一致的风险。</li>
<li><strong>故障回滚</strong>：如果切换后发现数据不一致问题无法解决，可以考虑回滚到原来的主库，然后采取更谨慎的方式来进行切换，例如逐渐减小主从延时。</li>
</ol>
</li>
</ol>

    
  </div>

  
  <!-- Post Copyright -->

<div class="post-copyright">
  <p class="copyright-item">
    <span>Author: </span>
    <a href="https://stardustorz.github.io">draco</a>
  </p>
  <p class="copyright-item">
    <span>Link: </span>
    <a href="https://stardustorz.github.io/2023/09/10/Framework/MySQL/">https://stardustorz.github.io/2023/09/10/Framework/MySQL/</a>
  </p>
  <p class="copyright-item">
    <span>License: </span>
    
    <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
  </p>
</div>

    

  

  
  <footer class="post-footer">
    
      
  <nav class="post-nav">  
      
      <a class="prev" href="/2023/09/10/System-Design/%E5%88%86%E5%B8%83%E5%BC%8F%E7%90%86%E8%AE%BA/">  
        <i class="iconfont icon-left"></i>  
        <span class="prev-text nav-default"></span>  
        <span class="prev-text nav-mobile">Prev</span>  
      </a>  
      
      
      <a class="next" href="/2023/09/09/Framework/Kafka/">  
        <span class="next-text nav-default"></span>  
        <span class="prev-text nav-mobile">Next</span>  
        <i class="iconfont icon-right"></i>  
      </a>  
      
  </nav>  
  

  </footer>
  

</article>
        </div>
      </div>
    </main>
    <footer id="footer" class="footer">
      <!-- Social Links -->

<div class="social-links">
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
  
</div>



<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme -
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="hosting-info">
    footer.hosting
  </span>

  <span class="copyright-year">
    <span>
      
      &copy;
      
      2019 - 2025      
    </span>

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>

    <span class="author">draco</span>
  </span>

</div>
    </footer>
    <div class="back-to-top" id="back-to-top"> <i class="iconfont icon-up"></i> </div>
  </div>
  







<script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>



<script type="text/javascript" src="/lib/slideout/slideout.js"></script>



<script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>



  <script type="text/javascript" src="/js/src/even.js?v=3.0.0"></script>
</body>

</html>